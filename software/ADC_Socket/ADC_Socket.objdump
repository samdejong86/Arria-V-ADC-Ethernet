
ADC_Socket.elf:     file format elf32-littlenios2
ADC_Socket.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08200200

Program Header:
    LOAD off    0x00001000 vaddr 0x04a80000 paddr 0x04a80000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001060 vaddr 0x08200060 paddr 0x08200060 align 2**12
         filesz 0x00053f78 memsz 0x0005ea28 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  04a80000  04a80000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   000001a0  08200060  08200060  00001060  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004bcd4  08200200  08200200  00001200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00006018  0824bed4  0824bed4  0004ced4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000020ec  08251eec  08251eec  00052eec  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000aab0  08253fd8  08253fd8  00054fd8  2**2
                  ALLOC, SMALL_DATA
  6 .ext_flash    00000000  04a80020  04a80020  00054fd8  2**0
                  CONTENTS
  7 .descriptor_memory 00000000  08000000  08000000  00054fd8  2**0
                  CONTENTS
  8 .onchip_ram   00000000  0825ea88  0825ea88  00054fd8  2**0
                  CONTENTS
  9 .comment      00000046  00000000  00000000  00054fd8  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001d58  00000000  00000000  00055020  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00068362  00000000  00000000  00056d78  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000159f8  00000000  00000000  000bf0da  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0001dc8f  00000000  00000000  000d4ad2  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00008950  00000000  00000000  000f2764  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0000b9e5  00000000  00000000  000fb0b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0001f259  00000000  00000000  00106a99  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000050  00000000  00000000  00125cf4  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00001eb8  00000000  00000000  00125d48  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000006  00000000  00000000  0013244a  2**0
                  CONTENTS, READONLY
 20 .cpu          00000003  00000000  00000000  00132450  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  00132453  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  00132454  2**0
                  CONTENTS, READONLY
 23 .sysid_hash   00000004  00000000  00000000  00132455  2**0
                  CONTENTS, READONLY
 24 .sysid_base   00000004  00000000  00000000  00132459  2**0
                  CONTENTS, READONLY
 25 .sysid_time   00000004  00000000  00000000  0013245d  2**0
                  CONTENTS, READONLY
 26 .stderr_dev   0000000b  00000000  00000000  00132461  2**0
                  CONTENTS, READONLY
 27 .stdin_dev    0000000b  00000000  00000000  0013246c  2**0
                  CONTENTS, READONLY
 28 .stdout_dev   0000000b  00000000  00000000  00132477  2**0
                  CONTENTS, READONLY
 29 .sopc_system_name 0000000d  00000000  00000000  00132482  2**0
                  CONTENTS, READONLY
 30 .quartus_project_dir 00000023  00000000  00000000  0013248f  2**0
                  CONTENTS, READONLY
 31 .jdi          0000677b  00000000  00000000  001324b2  2**0
                  CONTENTS, READONLY
 32 .sopcinfo     000c11e2  00000000  00000000  00138c2d  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04a80000 l    d  .entry	00000000 .entry
08200060 l    d  .exceptions	00000000 .exceptions
08200200 l    d  .text	00000000 .text
0824bed4 l    d  .rodata	00000000 .rodata
08251eec l    d  .rwdata	00000000 .rwdata
08253fd8 l    d  .bss	00000000 .bss
04a80020 l    d  .ext_flash	00000000 .ext_flash
08000000 l    d  .descriptor_memory	00000000 .descriptor_memory
0825ea88 l    d  .onchip_ram	00000000 .onchip_ram
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../ADC_Socket_bsp//obj/HAL/src/crt0.o
08200244 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
082000d4 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_error_handler.c
00000000 l    df *ABS*	00000000 iniche_init.c
00000000 l    df *ABS*	00000000 led.c
00000000 l    df *ABS*	00000000 network_utilities.c
00000000 l    df *ABS*	00000000 simple_socket_server.c
08253fe4 l     O .bss	00000004 SSSCommand.4950
082541f4 l     O .bss	000005f0 conn.4980
00000000 l    df *ABS*	00000000 tse_my_system.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 ctype_.c
0824d27f l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 getc.c
00000000 l    df *ABS*	00000000 impure.c
08252024 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 perror.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 rget.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strerror.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strstr.c
08203f74 l     F .text	00000104 critical_factorization
08204078 l     F .text	000003b0 two_way_long_needle
00000000 l    df *ABS*	00000000 vfprintf.c
0824db4e l     O .rodata	00000010 zeroes.4389
0824db5e l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 u_strerr.c
00000000 l    df *ABS*	00000000 vfprintf.c
0824db6e l     O .rodata	00000010 zeroes.4404
08208bcc l     F .text	000000bc __sbprintf
0824db7e l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
08208f34 l     F .text	00000200 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0820aa64 l     F .text	00000008 __fp_unlock
0820aa78 l     F .text	0000019c __sinit.part.1
0820ac14 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 locale.c
08252468 l     O .rwdata	00000020 lc_ctype_charset
08252448 l     O .rwdata	00000020 lc_message_charset
08252488 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 mprec.c
0824dbac l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 refill.c
0820db34 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 vfprintf.c
0824dce0 l     O .rodata	00000010 blanks.4332
0824dcd0 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 vfprintf.c
0820f410 l     F .text	000000fc __sprint_r.part.0
0824dd00 l     O .rodata	00000010 blanks.4348
0824dcf0 l     O .rodata	00000010 zeroes.4349
0821099c l     F .text	000000bc __sbprintf
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_fstat.c
08214408 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
082144f4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
082145d4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
08253ea4 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_env_lock.c
08253ea8 l     O .rwdata	00000004 lockid
0825401c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
08253eac l     O .rwdata	00000004 lockid
08254024 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
0821614c l     F .text	00000048 OS_InitMisc
08216194 l     F .text	0000006c OS_InitRdyList
08216300 l     F .text	000000e4 OS_InitTCBList
0821606c l     F .text	000000e0 OS_InitEventList
08216200 l     F .text	00000080 OS_InitTaskIdle
08216280 l     F .text	00000080 OS_InitTaskStat
08216570 l     F .text	00000074 OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
08218280 l     F .text	000000f4 OS_FlagTaskRdy
08218040 l     F .text	00000160 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0821c328 l     F .text	00000034 alt_dev_reg
082528c8 l     O .rwdata	0000106c jtag_uart_0
08253934 l     O .rwdata	00000124 lcd
08253a58 l     O .rwdata	00000030 sgdma_rx
08253a88 l     O .rwdata	00000030 sgdma_tx
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0821c878 l     F .text	000002a4 altera_avalon_jtag_uart_irq
0821cb1c l     F .text	00000104 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
08253f28 l     O .rwdata	00000004 colstart
0821d2f8 l     F .text	000000b8 lcd_write_command
0821d3b0 l     F .text	000000d8 lcd_write_data
0821d488 l     F .text	000000d0 lcd_clear_screen
0821d558 l     F .text	000001ec lcd_repaint_screen
0821d744 l     F .text	000000cc lcd_scroll_up
0821d810 l     F .text	000002ac lcd_handle_escape
0821dfcc l     F .text	000000ac alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0821e238 l     F .text	0000003c alt_get_errno
0821ee68 l     F .text	000000bc alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0821efcc l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
0825407e l     O .bss	00000001 tse_system_count.4813
0825407f l     O .bss	00000001 is_init.4895
00000000 l    df *ABS*	00000000 ins_tse_mac.c
00000000 l    df *ABS*	00000000 alt_iniche_close.c
00000000 l    df *ABS*	00000000 alt_iniche_dev.c
00000000 l    df *ABS*	00000000 alt_iniche_read.c
00000000 l    df *ABS*	00000000 alt_iniche_write.c
00000000 l    df *ABS*	00000000 ipnet.c
00000000 l    df *ABS*	00000000 ipstart.c
0825480c l     O .bss	0000003c closers
08254094 l     O .bss	00000004 nclosers
00000000 l    df *ABS*	00000000 igmp_cmn.c
00000000 l    df *ABS*	00000000 bsdsock.c
00000000 l    df *ABS*	00000000 cksum.c
08253f44 l     O .rwdata	00000004 cksum_select
00000000 l    df *ABS*	00000000 in_utils.c
08254848 l     O .bss	00000018 tistring
00000000 l    df *ABS*	00000000 netmain.c
00000000 l    df *ABS*	00000000 tk_crnos.c
00000000 l    df *ABS*	00000000 dhcpclnt.c
0822b874 l     F .text	000000ac dh_getlong
00000000 l    df *ABS*	00000000 dhcputil.c
00000000 l    df *ABS*	00000000 pktalloc.c
00000000 l    df *ABS*	00000000 q.c
00000000 l    df *ABS*	00000000 udp_open.c
00000000 l    df *ABS*	00000000 asm_cksum.o
0822d410 l       .text	00000000 done
0822d2a0 l       .text	00000000 asm1
0822d3cc l       .text	00000000 loop0
0822d2c8 l       .text	00000000 loop
0822d3e8 l       .text	00000000 fold
00000000 l    df *ABS*	00000000 brdutils.c
08254100 l     O .bss	00000004 kbd_init.4233
082540fc l     O .bss	00000004 cpu_statusreg
00000000 l    df *ABS*	00000000 osportco.c
00000000 l    df *ABS*	00000000 targnios.c
00000000 l    df *ABS*	00000000 nptcp.c
08254134 l     O .bss	00000004 in_tcptick
00000000 l    df *ABS*	00000000 rawsock.c
00000000 l    df *ABS*	00000000 sockcall.c
08231790 l     F .text	0000008c sockargs
08230ab4 l     F .text	000001dc t_getname
00000000 l    df *ABS*	00000000 socket.c
00000000 l    df *ABS*	00000000 socket2.c
00000000 l    df *ABS*	00000000 soselect.c
00000000 l    df *ABS*	00000000 tcp_in.c
00000000 l    df *ABS*	00000000 tcp_out.c
08239274 l     F .text	000000c8 bld_options
00000000 l    df *ABS*	00000000 tcp_subr.c
00000000 l    df *ABS*	00000000 tcp_timr.c
00000000 l    df *ABS*	00000000 tcp_usr.c
00000000 l    df *ABS*	00000000 tcpport.c
00000000 l    df *ABS*	00000000 udpsock.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
0823ba70 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev.c
0823bbf4 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0823bc20 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0823c0f0 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
0823c230 l     F .text	0000003c alt_get_errno
0823c26c l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
0823c484 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_remap_cached.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_free.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
0823c9c8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 allports.c
0825416c l     O .bss	00000004 inside_pktdemux
00000000 l    df *ABS*	00000000 timeouts.c
0823d2fc l     F .text	0000018c check_interval_timers
08254178 l     O .bss	00000004 numtimers
00000000 l    df *ABS*	00000000 tk_misc.c
00000000 l    df *ABS*	00000000 alt_iniche_fcntl.c
00000000 l    df *ABS*	00000000 et_arp.c
0825417c l     O .bss	00000004 arp_timer
08254184 l     O .bss	00000004 cachetime
00000000 l    df *ABS*	00000000 iface.c
00000000 l    df *ABS*	00000000 ip.c
08253fc0 l     O .rwdata	00000004 uid
00000000 l    df *ABS*	00000000 ip_reasm.c
00000000 l    df *ABS*	00000000 ipdemux.c
00000000 l    df *ABS*	00000000 ipmc.c
00000000 l    df *ABS*	00000000 ipport.c
00000000 l    df *ABS*	00000000 ipraw.c
00000000 l    df *ABS*	00000000 iproute.c
00000000 l    df *ABS*	00000000 udp.c
082541c4 l     O .bss	00000002 usocket
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 igmp2.c
00000000 l    df *ABS*	00000000 ipopt.c
00000000 l    df *ABS*	00000000 u_mctest.c
08253fc8 l     O .rwdata	00000004 iCounter.4951
00000000 l    df *ABS*	00000000 dhcsetup.c
00000000 l    df *ABS*	00000000 memdev.c
00000000 l    df *ABS*	00000000 parseip.c
08254860 l     O .bss	0000001e nearBuf.4578
00000000 l    df *ABS*	00000000 tcpcksum.c
00000000 l    df *ABS*	00000000 in_pcb.c
00000000 l    df *ABS*	00000000 vfsfiles.c
00000000 l    df *ABS*	00000000 vfsport.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_fcntl.c
08249f70 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 icmp.c
08253e68 l     O .rwdata	00000018 dsts
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malign.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vprintf.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 vfprintfr_1.c
00000000 l    df *ABS*	00000000 alt_exit.c
082034c8 g     F .text	00000018 putchar
0825e584 g     O .bss	00000014 soq
0820d458 g     F .text	00000074 _mprec_log10
08220338 g     F .text	000000d8 alt_tse_get_mac_info
08253efa g     O .rwdata	00000002 OSTaskNameSize
0820d544 g     F .text	0000008c __any_on
08210f38 g     F .text	00000054 _isatty_r
0824dbb8 g     O .rodata	00000028 __mprec_tinytens
0823f08c g     F .text	00000724 ip_write_internal
082146e4 g     F .text	000000bc alt_main
0824b6b8 g     F .text	00000090 strcpy
0822cbbc g     F .text	000000ac pk_free
082034e0 g     F .text	000000c0 _puts_r
0825e730 g     O .bss	00000100 alt_irq
08253d08 g     O .rwdata	00000009 rtp_priority
08210f8c g     F .text	00000060 _lseek_r
0824b114 g     F .text	00000314 icmp_timex
0822e4b8 g     F .text	00000044 m_freem
08249920 g     F .text	00000048 vgetc
0822d570 g     F .text	00000020 clock_c
0825414c g     O .bss	00000004 tcp_optionbuf
0823ebac g     F .text	00000070 if_getbynum
08218aa0 g     F .text	000000cc OS_MemInit
082540ec g     O .bss	00000004 dsc_rlyerrs
082540dc g     O .bss	00000004 dsc_releases
08229644 g     F .text	0000006c TK_OSTaskQuery
0822d280 g       .text	00000000 asm_cksum
08223f48 g     F .text	000000f0 marvell_cfg_rgmii
0821c2c8 g     F .text	00000060 OSTimeSet
08249828 g     F .text	000000f8 vgetc_locked
0822dda8 g     F .text	00000020 post_task_setup
082426ec g     F .text	00000344 ipr_stats
0823aa9c g     F .text	00000118 tcp_attach
08253f54 g     O .rwdata	00000004 reqlist_len
0822f878 g     F .text	00000078 tcp_tick
08228930 g     F .text	0000007c print_ipad
0822954c g     F .text	000000f8 tcp_wakeup
08212e78 g     F .text	00000088 .hidden __eqdf2
08253fdc g     O .bss	00000004 last_flash_sector_offset
08254098 g     O .bss	00000004 igmp_timers_are_running
08200d98 g     F .text	000000e4 led_bit_toggle
08237cb8 g     F .text	0000012c tcp_pulloutofband
08221534 g     F .text	00000210 alt_tse_phy_print_profile
08214dc0 g     F .text	00000610 OSEventPendMulti
0825ea88 g       *ABS*	00000000 __alt_heap_start
0823cd4c g     F .text	00000024 OSTaskCreateHook
0822c3f8 g     F .text	00000068 dhc_ifacedone
08223ce8 g     F .text	00000098 marvell_phy_cfg
08242a80 g     F .text	00000380 ip_rcv
082495cc g     F .text	0000014c vfseek
08233e64 g     F .text	00000108 soqremque
08244654 g     F .text	000007a8 udpdemux
08225670 g     F .text	00000104 tse_mac_close
0820331c g     F .text	0000003c printf
08254198 g     O .bss	00000004 rt_mib
08253ed2 g     O .rwdata	00000002 OSMboxEn
0822c318 g     F .text	00000058 dhc_state_init
0824bbd4 g     F .text	0000001c vsprintf
0821e398 g     F .text	00000110 alt_avalon_sgdma_do_sync_transfer
08215428 g     F .text	0000004c OSIntEnter
0821104c g     F .text	0000009c _wcrtomb_r
0820dec4 g     F .text	0000005c __sseek
0820adb4 g     F .text	00000010 __sinit
082438ec g     F .text	0000010c in_delmulti
08208c88 g     F .text	00000140 __swbuf_r
082541b0 g     O .bss	00000004 so_evtmap_create
08253ee2 g     O .rwdata	00000002 OSQEn
08247c88 g     F .text	00000088 in_pcballoc
08253f70 g     O .rwdata	00000002 socket_defaults
0820b9d0 g     F .text	0000007c _setlocale_r
0823da88 g     F .text	00000454 send_arp
0820ac1c g     F .text	00000068 __sfmoreglue
082486e4 g     F .text	00000338 vfopen_locked
08253fe8 g     O .bss	00000004 SSSLEDCommandQ
08214a94 g     F .text	000000cc __malloc_unlock
0823cdb4 g     F .text	00000020 OSTaskStatHook
0823d21c g     F .text	00000054 prep_modules
08227f30 g     F .text	0000013c bsd_i_sockoptlen
0825402c g     O .bss	00000001 OSLockNesting
08253f4c g     O .rwdata	00000004 xids
08203ec0 g     F .text	0000001c strerror
0822057c g     F .text	00000a88 getPHYSpeed
08248c28 g     F .text	00000044 vfclose
0825e624 g     O .bss	0000002c tcb
08253f20 g     O .rwdata	00000002 OSDataSize
0823c620 g     F .text	00000034 alt_remap_cached
0825402d g     O .bss	00000001 OSRunning
0823e8f4 g     F .text	000002b8 grat_arp
08201118 g     F .text	0000005c get_ip_addr
08247710 g     F .text	00000094 inet_pton
0823ecf0 g     F .text	00000090 reg_type
0825e128 g     O .bss	000000f0 dhc_states
08226dac g     F .text	00000174 igmp_fasttimo
08248dd4 g     F .text	0000005c vunlink_flag_open_files
0822c0e0 g     F .text	00000080 dhc_halt
0821eab0 g     F .text	000003b8 alt_avalon_sgdma_construct_descriptor_burst
082540d0 g     O .bss	00000004 dsc_acks
0825e650 g     O .bss	000000e0 tcpstat
08241fe4 g     F .text	0000034c ip_reasm_copy_queued_fragments_into_reassy_buffer
0822ea04 g     F .text	0000009c dtom
08239174 g     F .text	00000100 tcp_setpersist
08230e50 g     F .text	0000018c t_getsockopt
08202fd4 g     F .text	0000015c memmove
082540e0 g     O .bss	00000004 dsc_naks
0822ee54 g     F .text	000005b0 ip_output
0823ce00 g     F .text	00000020 OSInitHookBegin
0824b428 g     F .text	00000054 icmp_du
08253f48 g     O .rwdata	00000004 num_net_tasks
082541d4 g     O .bss	00000004 vfiles
08253f18 g     O .rwdata	00000002 OSTmrSize
08246ea0 g     F .text	00000114 dhc_main_ipset
0820ad9c g     F .text	00000018 _cleanup
082411b8 g     F .text	000002b8 ip_reasm_process_first_fragment
0820c5d4 g     F .text	000000a8 _Balloc
08201614 g     F .text	00000198 get_board_mac_addr
08254030 g     O .bss	00000004 OSIdleCtr
08253fec g     O .bss	00000004 SSSLEDLightshowSem
08222f48 g     F .text	000001c4 alt_tse_phy_set_adv_1000
08253f34 g     O .rwdata	00000001 max_mac_system
08245dfc g     F .text	000005c8 ip_setmoptions
0821f5ec g     F .text	000009fc alt_tse_system_add_sys
08212f00 g     F .text	000000dc .hidden __gtdf2
0824722c g     F .text	0000002c md_fseek
0823cafc g     F .text	00000024 altera_nios2_gen2_irq_init
0823cbcc g       .text	00000000 OSStartTsk
082168a0 g     F .text	000002d4 OS_TCBInit
08241470 g     F .text	00000088 ip_reassm
0822c160 g     F .text	000001b8 dhc_reclaim
0825ea10 g     O .bss	00000010 udp_mib
04a80000 g     F .entry	00000000 __reset
082315f4 g     F .text	000000d8 t_shutdown
082026f0 g     F .text	000001f0 sss_handle_receive
082310bc g     F .text	00000140 t_recvfrom
08253f1e g     O .rwdata	00000002 OSTmrWheelTblSize
08246588 g     F .text	000006b4 u_mctest_run
0821e600 g     F .text	00000078 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
08243a5c g     F .text	00000080 prep_ifaces
082540b4 g     O .bss	00000001 to_netmain
0822c86c g     F .text	000000c4 pk_alloc
08253ebe g     O .rwdata	00000002 OSEventSize
08200a10 g     F .text	00000298 alt_SSSErrorHandler
08254034 g     O .bss	00000001 OSPrioHighRdy
08210edc g     F .text	0000005c _fstat_r
08251f04 g     O .rwdata	00000120 tse_mac_device
082292ec g     F .text	00000048 tk_nettick
0823cd70 g     F .text	00000024 OSTaskDelHook
0825400c g     O .bss	00000004 errno
08203628 g     F .text	00000014 __srget
08235068 g     F .text	000000c4 in_pcbnotify
0820de40 g     F .text	00000008 __seofread
0823cbac g       .text	00000000 OSStartHighRdy
0825e218 g     O .bss	00000014 lilfreeq
08200248 g     F .text	00000564 alt_uCOSIIErrorHandler
08243b04 g     F .text	0000002c evtmap_setup
0821ad6c g     F .text	000001e4 OSTaskCreateExt
082540b8 g     O .bss	00000004 tcp_sleep_timeout
0823482c g     F .text	000001b8 sbdrop
082541ac g     O .bss	00000004 net_system_exit
0825ea20 g     O .bss	00000068 icmp_mib
0820e1d4 g     F .text	0000123c ___svfiprintf_internal_r
08239c04 g     F .text	00000074 tcp_getseq
08243ee8 g     F .text	000000b8 ip_raw_alloc
08223830 g     F .text	000004b8 alt_tse_phy_set_common_speed
08217b88 g     F .text	00000060 OSFlagPendGetFlagsRdy
08253efe g     O .rwdata	00000002 OSTaskStatStkSize
0825dbfc g     O .bss	00000010 pmac_groups
0822a988 g     F .text	00000a84 dhc_request
082326e4 g     F .text	0000074c soreceive
08216d04 g     F .text	00000308 OSFlagAccept
082190d8 g     F .text	000000b8 OSQFlush
08218b6c g     F .text	00000140 OSQAccept
08254014 g     O .bss	00000004 alt_argv
0825be80 g       *ABS*	00000000 _gp
08242a30 g     F .text	00000050 ip_reasm_send_icmp_timex
0823c8b4 g     F .text	00000114 usleep
08248c6c g     F .text	00000048 vfflush
0825e52c g     O .bss	00000040 resid_semaphore
082287ec g     F .text	00000144 hexdump
08241080 g     F .text	000000a0 ip_reasm_incr_mem_useage
08227410 g     F .text	00000080 igmp_leavegroup
0821abc0 g     F .text	000001ac OSTaskCreate
0821a6d0 g     F .text	000004f0 OSTaskChangePrio
08254028 g     O .bss	00000004 alt_heapsem
08239a50 g     F .text	000000f0 tcp_close
08216b74 g     F .text	00000190 OSDebugInit
0821af50 g     F .text	00000344 OSTaskDel
08249d40 g     F .text	0000005c vferror
0823c83c g     F .text	00000078 alt_uncached_malloc
0821f0f0 g     F .text	00000060 tse_mac_initTransInfo2
08245238 g     F .text	000000bc udp_alloc
08253b70 g     O .rwdata	00000180 alt_fd_list
0825a8f8 g     O .bss	00000370 OSFlagTbl
08254138 g     O .bss	00000008 mbstat
08202d94 g     F .text	00000070 _getc_r
08202e04 g     F .text	00000088 getc
082034c0 g     F .text	00000008 _putchar_r
08215e4c g     F .text	000000b8 OS_EventTaskRemove
08245a44 g     F .text	00000144 igmpv2_chk_set_timer
08229334 g     F .text	00000030 TK_OSTimeDly
0823bdc0 g     F .text	00000090 alt_find_dev
08202e8c g     F .text	00000148 memcpy
0821f364 g     F .text	00000054 tse_mac_setMIImode
082540e8 g     O .bss	00000004 dsc_rebind
0823d6a8 g     F .text	0000007c task_stats
08230260 g     F .text	00000050 DOMAIN_CHECK
0822f404 g     F .text	00000038 in_broadcast
08253ee8 g     O .rwdata	00000002 OSRdyTblSize
08221004 g     F .text	00000048 alt_tse_phy_rd_mdio_addr
082541d0 g     O .bss	00000004 vfsystems
08245188 g     F .text	000000b0 udp_socket
08254088 g     O .bss	00000004 MaxMtu
08234d44 g     F .text	00000140 sock_selscan
0820aa6c g     F .text	0000000c _cleanup_r
08214164 g     F .text	000000dc .hidden __floatsidf
08240e58 g     F .text	000000c4 ip_reasm_match_frag_with_ire
08233fc4 g     F .text	00000058 socantrcvmore
0821f150 g     F .text	000000e4 tse_mac_sTxWrite
08201e48 g     F .text	000008a8 sss_exec_command
082032d8 g     F .text	00000014 perror
0823c1b4 g     F .text	0000007c alt_io_redirect
08212fdc g     F .text	000000f4 .hidden __ltdf2
08254114 g     O .bss	00000004 netq_intmask
082476c4 g     F .text	0000004c hextoa
0824bed4 g       *ABS*	00000000 __DTOR_END__
082313f0 g     F .text	00000204 t_send
0823baac g     F .text	000000d0 alt_close
08254140 g     O .bss	00000002 select_wait
082035a0 g     F .text	00000014 puts
08228e74 g     F .text	00000044 std_out
0825dc1c g     O .bss	00000030 tse_iniche_dev_driver_data
08249968 g     F .text	00000124 vfslookup_locked
08231fa4 g     F .text	00000098 soaccept
08214b60 g     F .text	00000120 OSEventNameGet
08253ecc g     O .rwdata	00000002 OSFlagMax
08203864 g     F .text	0000065c _strerror_r
0825e598 g     O .bss	0000003c tcpmib
0823181c g     F .text	00000098 t_errno
08243b30 g     F .text	000000d8 ip_raw_open
0820dd24 g     F .text	00000074 __fpclassifyd
0822b76c g     F .text	00000108 dhc_decline
0820d3b4 g     F .text	000000a4 __ratio
08215474 g     F .text	000000f8 OSIntExit
08253fc4 g     O .rwdata	00000004 ipRoutes
08248d84 g     F .text	00000050 vfeof
08210980 g     F .text	0000001c __vfiprintf_internal
08239ee8 g     F .text	00000060 tcp_canceltimers
0822a218 g     F .text	000001e4 dhc_buildheader
08253f06 g     O .rwdata	00000002 OSTCBSize
0821e6f8 g     F .text	0000008c alt_avalon_sgdma_construct_mem_to_stream_desc_burst
08254035 g     O .bss	00000001 OSPrioCur
0821cd78 g     F .text	000002bc altera_avalon_jtag_uart_read
0824b690 g     F .text	00000014 malloc
082541cc g     O .bss	00000004 inpcb_cachemiss
082032ec g     F .text	00000030 _printf_r
08247884 g     F .text	000000c4 inet46_addr
082541c8 g     O .bss	00000004 inpcb_cachehits
08202b8c g     F .text	00000064 .hidden __udivsi3
08253b30 g     O .rwdata	0000000b tcp_outflags
0825dc4c g     O .bss	00000130 tse
08214530 g     F .text	000000a4 isatty
0821ffe8 g     F .text	00000168 alt_tse_sys_enable_mdio_sharing
08253eec g     O .rwdata	00000002 OSStkWidth
0824dc08 g     O .rodata	000000c8 __mprec_tens
0824855c g     F .text	00000070 vf_alloc_and_link_vop
08253ee0 g     O .rwdata	00000002 OSPtrSize
0825419c g     O .bss	00000004 ipr_curr_mem
08226a64 g     F .text	00000070 exit_hook
0825409c g     O .bss	00000004 igmp_cticks
082202b8 g     F .text	00000080 alt_tse_get_mac_info_index
08254128 g     O .bss	00000004 mheap_sem_ptr
08238030 g     F .text	00000048 ip4_tcpmss
0820ba4c g     F .text	0000000c __locale_charset
08253ec0 g     O .rwdata	00000002 OSEventTblSize
0825e994 g     O .bss	00000014 netlist
08232e30 g     F .text	00000098 soshutdown
0823cb20 g       .text	00000000 OSCtxSw
0823d1a8 g     F .text	00000050 packet_check
0822b40c g     F .text	0000027c dhc_setip
0825e5d4 g     O .bss	00000014 mbufq
08231f54 g     F .text	00000050 soabort
08254008 g     O .bss	00000004 __malloc_top_pad
08254038 g     O .bss	00000004 OSTCBList
0822ceac g     F .text	00000100 qdel
0823d00c g     F .text	00000164 station_state
0824402c g     F .text	00000154 rt_lookup
08254158 g     O .bss	00000004 alt_fd_list_lock
08253e8c g     O .rwdata	00000004 __mb_cur_max
08227490 g     F .text	00000318 igmp_validate
0820ba7c g     F .text	0000000c _localeconv_r
082267c0 g     F .text	000002a4 ip_startup
0823056c g     F .text	00000254 t_accept
08233a5c g     F .text	00000098 soisdisconnecting
0820c9e0 g     F .text	0000003c __i2b
0820b38c g     F .text	000004bc __sfvwrite_r
0821e830 g     F .text	0000005c alt_avalon_sgdma_stop
08226200 g     F .text	000003a4 pktdemux
0825ac68 g     O .bss	00000c30 OSMemTbl
0825403c g     O .bss	00000001 OSTickStepState
082210a4 g     F .text	00000128 alt_tse_phy_wr_mdio_reg
0822d448 g     F .text	00000094 kbhit
08230c90 g     F .text	000001c0 t_setsockopt
0820dd98 g     F .text	00000054 _sbrk_r
08253cf0 g     O .rwdata	00000018 icmpdu_types
08221744 g     F .text	000006a4 alt_tse_mac_group_init
08248e30 g     F .text	00000200 vunlink
08224440 g     F .text	00000a60 tse_mac_init
08253ee4 g     O .rwdata	00000002 OSQMax
0822864c g     F .text	000000a4 ccksum
082485cc g     F .text	000000c8 vf_alloc_buffer
082541c0 g     O .bss	00000004 cachedRoute
08253f58 g     O .rwdata	00000004 lilbufs
0825b898 g     O .bss	00000800 OSTaskStatStk
08247258 g     F .text	00000024 md_ftell
082286f0 g     F .text	00000054 cksum
082186dc g     F .text	000000f0 OSMemNameGet
08231b88 g     F .text	00000110 sofree
08254090 g     O .bss	00000004 ifNumber
08253ec4 g     O .rwdata	00000002 OSFlagEn
08210fec g     F .text	00000060 _read_r
08253f0a g     O .rwdata	00000002 OSTimeTickHookEn
0823bb7c g     F .text	00000078 alt_dcache_flush
08219588 g     F .text	00000168 OSQPost
08218374 g     F .text	000000a4 OS_FlagUnlink
08253f98 g     O .rwdata	00000004 alt_max_fd
08216438 g     F .text	00000068 OS_MemCopy
08253f60 g     O .rwdata	00000004 bigbufs
0823abb4 g     F .text	000000cc tcp_disconnect
082164a0 g     F .text	000000d0 OS_Sched
08210bd0 g     F .text	000000f0 _fclose_r
082185ec g     F .text	000000f0 OSMemGet
0821b57c g     F .text	000001b4 OSTaskNameSet
0820aa34 g     F .text	00000030 fflush
08254004 g     O .bss	00000004 __malloc_max_sbrked_mem
08254040 g     O .bss	00000004 OSCtxSwCtr
0825e0a0 g     O .bss	00000064 igmpstats
0823cdd4 g     F .text	0000002c OSTimeTickHook
0822a8a4 g     F .text	000000e4 dhc_rx_offer
0822806c g     F .text	0000010c bsd_getsockopt
08253ece g     O .rwdata	00000002 OSFlagNameSize
0825e9f8 g     O .bss	00000018 ire_stats
08200ef0 g     F .text	000001d4 LEDManagementTask
0823adec g     F .text	000001a0 udp_soinput
0822cdfc g     F .text	000000b0 putq
08215f04 g     F .text	00000100 OS_EventTaskRemoveMulti
082540b0 g     O .bss	00000004 iniche_net_ready
08211ce4 g     F .text	000008ac .hidden __adddf3
08215cfc g     F .text	00000150 OS_EventTaskWaitMulti
08249cf8 g     F .text	00000048 isvfile
08232fc4 g     F .text	00000430 sosetopt
08229194 g     F .text	000000e0 netmain
08238078 g     F .text	000000f8 tcp_mss
0820d15c g     F .text	0000010c __b2d
08247368 g     F .text	000002fc parse_ipad
0824853c g     F .text	00000020 get_vfopen_error
08253ee6 g     O .rwdata	00000002 OSQSize
082117ac g     F .text	00000538 .hidden __umoddi3
08214610 g     F .text	000000d4 lseek
0823d270 g     F .text	0000008c inet_timer
0821a038 g     F .text	0000020c OSSemPend
08221298 g     F .text	0000029c alt_tse_phy_add_profile_default
082229b0 g     F .text	00000598 alt_tse_phy_get_cap
08201abc g     F .text	000002c4 sss_send_menu
08253e84 g     O .rwdata	00000004 _global_impure_ptr
08228b34 g     F .text	00000154 print_eth
08248a1c g     F .text	00000050 vfopen
0823c4c0 g     F .text	000000fc alt_read
0820d5d0 g     F .text	00000564 _realloc_r
082007ac g     F .text	00000264 alt_NetworkErrorHandler
08253ed0 g     O .rwdata	00000002 OSLowestPrio
0825ea88 g       *ABS*	00000000 __bss_end
0823c000 g     F .text	000000f0 alt_iic_isr_register
0821e274 g     F .text	00000124 alt_avalon_sgdma_do_async_transfer
0822e3b0 g     F .text	00000108 m_free
0823ce60 g     F .text	00000024 OSTCBInitHook
08225630 g     F .text	00000040 tse_mac_stats
0822c930 g     F .text	0000028c pk_validate
08253f16 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
0823c6f0 g     F .text	00000108 alt_tick
082482bc g     F .text	00000254 in_pcblookup
0822c510 g     F .text	000000c0 find_opt
08211234 g     F .text	00000578 .hidden __udivdi3
0822e228 g     F .text	00000188 m_getnbuf
0822cc88 g     F .text	000000bc dump_buf_estats
08210e38 g     F .text	00000024 _fputwc_r
08222850 g     F .text	00000160 alt_tse_phy_check_link
08254194 g     O .bss	00000004 arpRepsOut
08253eb8 g     O .rwdata	00000002 OSEventEn
0824dbe0 g     O .rodata	00000028 __mprec_bigtens
0820c7c4 g     F .text	00000104 __s2b
08253f12 g     O .rwdata	00000002 OSTmrCfgNameSize
08214240 g     F .text	000000a8 .hidden __floatunsidf
0823ce84 g     F .text	000000f4 netmain_init
08223e64 g     F .text	000000e4 marvell_cfg_sgmii
08222694 g     F .text	000001bc alt_tse_phy_restart_an
0820ce9c g     F .text	00000060 __mcmp
082540cc g     O .bss	00000004 dsc_requests
08239498 g     F .text	00000400 tcp_respond
0823b1c8 g     F .text	000002d4 udp4_sockbind
08254118 g     O .bss	00000004 old_mode
082271bc g     F .text	00000254 igmp_joingroup
0822f530 g     F .text	00000348 so_icmpdu
0820add4 g     F .text	00000018 __fp_lock_all
082541e0 g     O .bss	00000004 vfs_dir_stale
0823bfb4 g     F .text	0000004c alt_ic_irq_enabled
0825dc0c g     O .bss	00000010 pphy_profiles
08242330 g     F .text	000000d8 ip_reasm_process_timer_tick
08249d9c g     F .text	00000058 vclearerr
0822856c g     F .text	000000e0 bsd_setsockopt
0822e9b0 g     F .text	00000054 mbuf_len
082181a0 g     F .text	000000e0 OS_FlagInit
0823c654 g     F .text	0000009c alt_alarm_stop
08249ad4 g     F .text	000001cc strippath
08253f50 g     O .rwdata	00000004 reqlist
082293d8 g     F .text	00000174 tcp_sleep
0824bb3c g     F .text	0000001c strtol
08229a68 g     F .text	000007b0 dhc_upcall
0823ac80 g     F .text	000000d0 tcp_usrclosed
08000000 g       *ABS*	00000000 __alt_mem_descriptor_memory
08254104 g     O .bss	00000004 cticks_factor
08253ef4 g     O .rwdata	00000002 OSTaskIdleStkSize
08247d68 g     F .text	00000210 in_pcbbind
0825415c g     O .bss	00000004 alt_irq_active
08219c70 g     F .text	000000b0 OSSemAccept
082188e0 g     F .text	000000d8 OSMemPut
08218418 g     F .text	000001d4 OSMemCreate
08254044 g     O .bss	00000004 OSIdleCtrMax
0820012c g     F .exceptions	000000d4 alt_irq_handler
08253b48 g     O .rwdata	00000028 alt_dev_null
08253f72 g     O .rwdata	00000001 tcprexmtthresh
08253f08 g     O .rwdata	00000002 OSTicksPerSec
0823ed80 g     F .text	00000094 if_killsocks
0823f7b0 g     F .text	00000220 ip_write
08242e00 g     F .text	000005cc ip_rcv_phase2
08230a70 g     F .text	00000044 t_getsockname
082307c0 g     F .text	0000026c t_connect
08253f6c g     O .rwdata	00000004 TCPTV_MSL
0825e22c g     O .bss	00000010 memestats
0822257c g     F .text	00000118 alt_tse_phy_init
0822d4dc g     F .text	0000005c getch
08253de8 g     O .rwdata	00000080 vfs_root_path
08230a2c g     F .text	00000044 t_getpeername
0821e88c g     F .text	00000064 alt_avalon_sgdma_check_descriptor_status
08241120 g     F .text	00000098 ip_reasm_decr_mem_useage
08234150 g     F .text	00000088 soreserve
0823cb20 g       .text	00000000 OSIntCtxSw
0822dfec g     F .text	00000034 npalloc
0820c8c8 g     F .text	00000068 __hi0bits
082541bc g     O .bss	00000004 ipraw_eps
0822c5d0 g     F .text	0000029c pk_init
08247058 g     F .text	0000015c md_fread
08224ea0 g     F .text	000002f8 tse_mac_raw_send
082140e4 g     F .text	00000080 .hidden __fixdfsi
0825e830 g     O .bss	00000064 intimers
08234228 g     F .text	0000004c sbrelease
082351ac g     F .text	000000f0 ifd_clr
08234ae4 g     F .text	00000090 sbdroprecord
08228c88 g     F .text	0000007c uslash
0823ca04 g     F .text	000000f8 alt_write
08254190 g     O .bss	00000004 arpRepsIn
082298e8 g     F .text	00000088 dhc_get_srv_ipaddr
0823d488 g     F .text	00000160 in_timerset
08254048 g     O .bss	00000004 OSTCBFreeList
0821a244 g     F .text	0000016c OSSemPendAbort
08238170 g     F .text	00001004 tcp_output
08254168 g     O .bss	00000004 activehost
08253f90 g     O .rwdata	00000008 alt_dev_list
08228f90 g     F .text	00000204 parse_args
0825411c g     O .bss	00000004 global_TCPwakeup_setIndx
0820ae04 g     F .text	00000044 _fputc_r
08225974 g     F .text	00000068 write
0821e9d0 g     F .text	00000080 alt_avalon_sgdma_enable_desc_poll
0822e020 g     F .text	00000040 npfree
08203358 g     F .text	000000a0 _putc_r
0823e144 g     F .text	000002c0 arpReply
08228770 g     F .text	0000007c nextarg
08253f0c g     O .rwdata	00000002 OSVersionNbr
08241a5c g     F .text	00000530 ip_reasm_process_subsequent_fragments
08253fd0 g     O .rwdata	00000004 pton_error
082540c0 g     O .bss	00000004 dsc_errors
08254880 g     O .bss	00002000 SSSInitialTaskStk
0825dd7c g     O .bss	00000014 rcvdq
0823512c g     F .text	00000080 tcp_notify
08214444 g     F .text	000000b0 fstat
08202c70 g     F .text	00000024 fprintf
0823203c g     F .text	000000b8 soconnect
08243fe4 g     F .text	00000048 ip_raw_maxalloc
08212fdc g     F .text	000000f4 .hidden __ledf2
08224038 g     F .text	00000078 DP83848C_link_status_read
0822a3fc g     F .text	000004a8 dhc_discover
082018d8 g     F .text	000000a4 SSSCreateOSDataStructs
08248238 g     F .text	00000084 in_setpeeraddr
08253eb4 g     O .rwdata	00000004 OSEndiannessTest
0822d538 g     F .text	00000038 clock_init
08248cb4 g     F .text	000000d0 vfgets
0823d80c g     F .text	00000180 et_send
0820cc14 g     F .text	00000140 __pow5mult
0820f524 g     F .text	0000145c ___vfiprintf_internal_r
08253ffc g     O .bss	00000004 __nlocale_changed
08202bf0 g     F .text	00000058 .hidden __umodsi3
08247664 g     F .text	00000060 inet_addr
08240fec g     F .text	00000094 ip_reasm_check_mem_useage
08232ec8 g     F .text	000000fc sorflush
0824bb58 g     F .text	0000001c vprintf
0825e340 g     O .bss	000000fc global_tcb_ext
0823fe1c g     F .text	00000420 ip_fragment_lc
0825dd90 g     O .bss	00000300 netstatic
08230330 g     F .text	00000164 t_bind
0821e678 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_stream_desc
08253ec6 g     O .rwdata	00000002 OSFlagGrpSize
0822d1a8 g     F .text	000000d8 udp_close
0821e784 g     F .text	00000054 alt_avalon_sgdma_register_callback
0822db60 g     F .text	000001fc alt_iniche_init
0825ea88 g       *ABS*	00000000 end
0822d754 g     F .text	00000088 UNLOCK_NET_RESOURCE
082241e8 g     F .text	00000258 prep_tse_mac
08230fdc g     F .text	000000e0 t_recv
0821dabc g     F .text	00000510 altera_avalon_lcd_16207_write
08249030 g     F .text	0000018c vfread
0822611c g     F .text	000000e4 netclose
082028e0 g     F .text	000001b4 SSSSimpleSocketServerTask
0824b49c g     F .text	0000000c _atoi_r
0821f408 g     F .text	000001e4 alt_tse_phy_add_profile
08253f7c g     O .rwdata	00000004 tcp_keepintvl
0821c730 g     F .text	00000148 altera_avalon_jtag_uart_init
08216708 g     F .text	000000cc OS_TaskStat
082540c4 g     O .bss	00000004 dsc_discovers
08253f24 g     O .rwdata	00000004 tse_mac_name
08253ae8 g     O .rwdata	00000018 tcp_protosw
0824bed4 g       *ABS*	00000000 __CTOR_LIST__
082541dc g     O .bss	00000004 vfopen_error
08380000 g       *ABS*	00000000 __alt_stack_pointer
08254150 g     O .bss	00000004 tcp_maxidle
082540f0 g     O .bss	00000004 firstudp
0821ea50 g     F .text	00000060 alt_avalon_sgdma_disable_desc_poll
0821f044 g     F .text	0000007c alt_avalon_timer_sc_init
082142e8 g     F .text	00000064 .hidden __clzsi2
0821d034 g     F .text	000002c4 altera_avalon_jtag_uart_write
0821e4a8 g     F .text	00000074 alt_avalon_sgdma_construct_mem_to_mem_desc
0820adc4 g     F .text	00000004 __sfp_lock_acquire
0820c474 g     F .text	000000e4 memchr
082163e4 g     F .text	00000054 OS_MemClr
082069b8 g     F .text	000021f8 ___vfprintf_internal_r
0823cbf0 g     F .text	0000015c OSTaskStkInit
0820363c g     F .text	00000058 _sprintf_r
0821e5a0 g     F .text	00000060 alt_avalon_sgdma_construct_stream_to_mem_desc
0820b07c g     F .text	00000310 _free_r
08245b88 g     F .text	00000140 igmpv2_chk4_rtr_alert_opt
0820ba58 g     F .text	00000010 __locale_mb_cur_max
082316cc g     F .text	000000c4 t_socketclose
08256880 g     O .bss	00002000 LED7SegLightshowTaskStk
08215a54 g     F .text	00000198 OS_EventTaskRdy
0824bd08 g     F .text	00000180 __call_exitprocs
082035b4 g     F .text	00000074 __srget_r
08225198 g     F .text	000000ac tse_sgdmaRx_isr
0825404c g     O .bss	00000001 OSCPUUsage
0825e090 g     O .bss	00000010 nets
0822d690 g     F .text	000000c4 LOCK_NET_RESOURCE
0822b688 g     F .text	000000e4 dhc_resetip
08253ff8 g     O .bss	00000004 __mlocale_changed
082253f0 g     F .text	00000240 tse_mac_rcv
082302b0 g     F .text	00000080 t_socket
08253e90 g     O .rwdata	00000004 __malloc_sbrk_base
08200200 g     F .text	00000048 _start
0823d7c4 g     F .text	00000048 etainit
08254160 g     O .bss	00000004 _alt_tick_rate
0823d1f8 g     F .text	00000024 mcastlist
08219190 g     F .text	0000028c OSQPend
08204428 g     F .text	000003b0 strstr
0825e23c g     O .bss	000000f0 pktlog
08245724 g     F .text	00000134 igmpv2_process_report
08235314 g     F .text	00000078 ifd_isset
08244540 g     F .text	00000114 del_route
0821e8f0 g     F .text	00000054 alt_avalon_sgdma_open
082069b0 g     F .text	00000008 _user_strerror
0821be3c g     F .text	00000104 OSTimeDly
082010c4 g     F .text	00000054 get_mac_addr
08231ab8 g     F .text	000000d0 solisten
0820cd54 g     F .text	00000148 __lshift
08254164 g     O .bss	00000004 _alt_nticks
082211cc g     F .text	000000cc alt_tse_phy_rd_mdio_reg
08225904 g     F .text	00000070 read
0821c394 g     F .text	00000238 alt_sys_init
08239b40 g     F .text	0000004c tcp_quench
0820e004 g     F .text	000001d0 __ssprint_r
08228d04 g     F .text	00000170 ns_printf
0823ec1c g     F .text	000000d4 isbcast
0822d7dc g     F .text	0000024c TK_NEWTASK
0824bbf0 g     F .text	00000118 __register_exitproc
0825404d g     O .bss	00000001 OSTaskCtr
08240f1c g     F .text	000000d0 ip_reasm_determine_type_of_frag
0825407c g     O .bss	00000001 phy_profile_count
0824b748 g     F .text	000000d0 strncmp
08220244 g     F .text	00000074 alt_tse_get_mac_group_index
0821bf40 g     F .text	00000158 OSTimeDlyHMSM
08243c08 g     F .text	000000bc ip_raw_close
0820ca1c g     F .text	000001f8 __multiply
08253d38 g     O .rwdata	000000b0 mdlist
0821cc20 g     F .text	00000068 altera_avalon_jtag_uart_close
08226ccc g     F .text	000000e0 igmp_input
0823fd54 g     F .text	000000c8 ip_raw_write
082491bc g     F .text	000003b0 vfwrite_locked
0824b818 g     F .text	000000ec strncpy
082540c8 g     O .bss	00000004 dsc_offers
082547e4 g     O .bss	00000028 __malloc_current_mallinfo
08253eba g     O .rwdata	00000002 OSEventMax
08247948 g     F .text	0000006c inet_setport
0820d268 g     F .text	0000014c __d2b
0821a3b0 g     F .text	00000110 OSSemPost
08237b30 g     F .text	00000188 tcp_dooptions
08253ff0 g     O .bss	00000004 SSSLEDEventFlag
08233958 g     F .text	00000104 soisconnected
082155f8 g     F .text	000000dc OSSchedUnlock
08243adc g     F .text	00000028 netexit
08201174 g     F .text	000001bc get_serial_number
082540ac g     O .bss	00000004 nettick_wakes
0822104c g     F .text	00000058 alt_tse_phy_wr_mdio_addr
08254144 g     O .bss	00000001 tcpprintfs
0823d5e8 g     F .text	0000009c in_timerkill
08245600 g     F .text	00000124 igmpv2_input
082540d8 g     O .bss	00000004 dsc_declines
0821c5cc g     F .text	00000060 altera_avalon_jtag_uart_read_fd
08228744 g     F .text	0000002c do_trap
0824a1d4 g     F .text	000000dc alt_get_fd
08228178 g     F .text	000000f4 bsd_ioctl
08254050 g     O .bss	00000004 OSMemFreeList
08215744 g     F .text	000000b0 OSStatInit
0822ec84 g     F .text	000001d0 tcp_rcv
08228aec g     F .text	00000048 panic
082541e4 g     O .bss	00000004 vfs_open_files
08249e18 g     F .text	00000158 alt_busy_sleep
08226634 g     F .text	0000018c ip2mac
08217f7c g     F .text	000000c4 OSFlagQuery
08234e84 g     F .text	000001e4 sock_select
08246c3c g     F .text	00000264 dhc_setup
0823933c g     F .text	00000054 tcp_init
08254120 g     O .bss	00000004 cticks
082540b5 g     O .bss	00000001 to_nettick
08253ef0 g     O .rwdata	00000002 OSTaskCreateExtEn
08210ab8 g     F .text	00000054 _close_r
082259dc g     F .text	000005e8 Netinit
0822ddc8 g     F .text	00000038 prep_armintcp
082437a0 g     F .text	0000014c in_addmulti
08239390 g     F .text	00000108 tcp_template
08223508 g     F .text	00000328 alt_tse_phy_get_common_speed
0822eaa0 g     F .text	00000070 remque
0824bb74 g     F .text	00000010 _vprintf_r
082353f0 g     F .text	00000410 tcp_reass
08247ae8 g     F .text	000001a0 tcp_cksum
0823b49c g     F .text	00000380 udp4_socksend
08248a6c g     F .text	000001bc vfclose_locked
0823529c g     F .text	00000078 ifd_set
0820c558 g     F .text	0000007c memcmp
08215a34 g     F .text	00000020 OS_Dummy
0821c68c g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0822c460 g     F .text	000000b0 dhc_set_state
0825408c g     O .bss	00000004 NDEBUG
0825ea88 g       *ABS*	00000000 __alt_stack_base
08253fe0 g     O .bss	00000004 last_flash_sector
0821c6dc g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
082341d8 g     F .text	00000050 sbreserve
0825407d g     O .bss	00000001 mac_group_count
08243cc4 g     F .text	00000224 ip_raw_input
08202c94 g     F .text	000000cc _fwrite_r
08253f5c g     O .rwdata	00000004 lilbufsiz
0823538c g     F .text	00000064 ifd_get
082340c4 g     F .text	0000008c sbwakeup
08208de0 g     F .text	00000154 __swsetup_r
082240b0 g     F .text	00000138 altera_eth_tse_init
0825c098 g     O .bss	000001e0 OSQTbl
08237de4 g     F .text	0000024c tcp_xmit_timer
08225244 g     F .text	000001ac tse_sgdma_read_init
08212590 g     F .text	000008e8 .hidden __divdf3
0820ac84 g     F .text	00000118 __sfp
082014d8 g     F .text	0000013c generate_mac_addr
0823eefc g     F .text	00000190 ip_bldhead
0820d4cc g     F .text	00000078 __copybits
08234274 g     F .text	000000a0 sbappend
082524c0 g     O .rwdata	00000408 __malloc_av_
0820add0 g     F .text	00000004 __sinit_lock_release
08254054 g     O .bss	00000004 OSTCBHighRdy
082130d0 g     F .text	00000718 .hidden __muldf3
0823f9d0 g     F .text	00000384 ip_write2
0820ddec g     F .text	00000054 __sread
08253fbc g     O .rwdata	00000004 arp_ageout
08254058 g     O .bss	00000004 OSQFreeList
08221de8 g     F .text	00000424 alt_tse_mac_get_phy
0823ee14 g     F .text	000000e8 ip_init
0824a0cc g     F .text	00000108 alt_find_file
08243fa0 g     F .text	00000044 ip_raw_free
0823e048 g     F .text	000000fc make_arp_entry
0823bc5c g     F .text	000000a4 alt_dev_llist_insert
08214974 g     F .text	00000120 __malloc_lock
08202c48 g     F .text	00000028 _fprintf_r
082147a0 g     F .text	000000b0 sbrk
0823ad90 g     F .text	0000005c udp_lookup
082047d8 g     F .text	000021d8 ___svfprintf_internal_r
0821e7d8 g     F .text	00000058 alt_avalon_sgdma_start
08214c80 g     F .text	00000140 OSEventNameSet
0820a9d8 g     F .text	0000005c _fflush_r
082204f0 g     F .text	0000008c alt_tse_mac_set_duplex
08210b0c g     F .text	000000c4 _calloc_r
0822df0c g     F .text	000000e0 npfree_base
0825405c g     O .bss	00000001 OSRdyGrp
0824700c g     F .text	00000028 md_fopen
08253b00 g     O .rwdata	00000018 udp_protosw
08253e9c g     O .rwdata	00000008 alt_flash_dev_list
082481b4 g     F .text	00000084 in_setsockaddr
08253fd8 g       *ABS*	00000000 __bss_start
08200e7c g     F .text	00000074 LED7SegLightshowTask
08234314 g     F .text	000000d8 sbappendrecord
0825e9a8 g     O .bss	00000050 ip_mib
08203130 g     F .text	00000128 memset
082320f4 g     F .text	00000098 sodisconnect
08200d18 g     F .text	00000080 main
08254018 g     O .bss	00000004 alt_envp
08254000 g     O .bss	00000004 __malloc_max_total_mem
08201a4c g     F .text	00000070 sss_reset_connection
0822e7f0 g     F .text	000001c0 m_adj
0821c62c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
08208dc8 g     F .text	00000018 __swbuf
0824727c g     F .text	000000c8 md_fgetc
0824de24 g     O .rodata	00000100 OSUnMapTbl
082408a4 g     F .text	000002a8 ip_dump
082296e0 g     F .text	00000208 tk_stats
08253f38 g     O .rwdata	00000008 alt_iniche_dev_list
08258880 g     O .bss	00000078 SSSLEDCommandQTbl
0821e078 g     F .text	00000160 altera_avalon_lcd_16207_init
08253f2c g     O .rwdata	00000008 alt_sgdma_list
08253eea g     O .rwdata	00000002 OSSemEn
08254108 g     O .bss	00000004 OS_TPS
0822fb14 g     F .text	0000074c rawip_usrreq
08217be8 g     F .text	00000394 OSFlagPost
0820df20 g     F .text	00000008 __sclose
08247828 g     F .text	0000005c print46_addr
08380000 g       *ABS*	00000000 __alt_heap_limit
08210cc0 g     F .text	00000014 fclose
08215bec g     F .text	00000110 OS_EventTaskWait
0824b904 g     F .text	00000238 _strtol_r
082289ac g     F .text	00000140 print_uptime
082167d4 g     F .text	000000cc OS_TaskStatStkChk
0821b294 g     F .text	00000150 OSTaskDelReq
08209134 g     F .text	00001688 _dtoa_r
0820bc68 g     F .text	0000080c _malloc_r
08247344 g     F .text	00000024 md_unlink
0821f2dc g     F .text	00000088 tse_mac_SwReset
082111a8 g     F .text	00000030 __ascii_wctomb
08247d10 g     F .text	00000058 in_pcbdetach
08253f9c g     O .rwdata	00000004 alt_errno
08253fcc g     O .rwdata	00000004 mdlist_size
082156d4 g     F .text	00000070 OSStart
08246554 g     F .text	00000034 u_mctest_init
08214914 g     F .text	00000060 __env_unlock
0820b848 g     F .text	000000c4 _fwalk
0821b730 g     F .text	000001d4 OSTaskResume
082189b8 g     F .text	000000e8 OSMemQuery
082479b4 g     F .text	00000134 convert_ip
0823dedc g     F .text	0000016c find_oldest_arp
08253efc g     O .rwdata	00000002 OSTaskStatEn
08254188 g     O .bss	00000004 arpReqsIn
08248694 g     F .text	00000050 vf_free_buffer
08249fac g     F .text	00000120 alt_fcntl
08253ed6 g     O .rwdata	00000002 OSMemMax
082196f0 g     F .text	00000170 OSQPostFront
0822d414 g     F .text	00000034 dtrap
08253f68 g     O .rwdata	00000004 kb_last
082033f8 g     F .text	000000c8 putc
08202a94 g     F .text	00000084 .hidden __divsi3
08220190 g     F .text	00000048 alt_tse_mac_set_common_speed
0825405d g     O .bss	00000003 OSRdyTbl
08253eb0 g     O .rwdata	00000002 OSDebugEn
0822de00 g     F .text	0000010c npalloc_base
08226ad4 g     F .text	000000d0 ip_exit
0820af58 g     F .text	00000124 _malloc_trim_r
0824bed4 g       *ABS*	00000000 __CTOR_END__
08253ec8 g     O .rwdata	00000002 OSFlagNodeSize
082540bc g     O .bss	00000004 dhc_conn
0822d590 g     F .text	0000005c cticks_hook
08253f10 g     O .rwdata	00000002 OSTmrCfgMax
0823d170 g     F .text	00000038 sysuptime
0820df28 g     F .text	000000dc strcmp
08201330 g     F .text	000001a8 generate_and_store_mac_addr
08242408 g     F .text	000001b4 ip_reasm_delete_ire
08218cac g     F .text	000001ac OSQCreate
0822d5ec g     F .text	00000060 irq_Mask
0821b3e4 g     F .text	00000198 OSTaskNameGet
08254170 g     O .bss	00000004 nextppp
082540f8 g     O .bss	00000004 irq_level
08225fc4 g     F .text	00000158 fixup_subnet_mask
08219860 g     F .text	0000020c OSQPostOpt
082157f4 g     F .text	00000220 OSTimeTick
08240d24 g     F .text	00000134 ip_copypkt
0822c370 g     F .text	00000088 dhc_alldone
08253ef8 g     O .rwdata	00000002 OSTaskMax
0824bed4 g       *ABS*	00000000 __DTOR_LIST__
08219d20 g     F .text	000000d8 OSSemCreate
082540a0 g     O .bss	00000004 igmp_all_hosts_group
08253f1c g     O .rwdata	00000002 OSTmrWheelSize
0823401c g     F .text	0000003c sbselqueue
082540a8 g     O .bss	00000004 netmain_wakes
0823e404 g     F .text	00000264 arprcv
08229364 g     F .text	00000074 TK_OSTaskResume
082277a8 g     F .text	0000041c igmp_print_stats
08212e78 g     F .text	00000088 .hidden __nedf2
0822e0d4 g     F .text	00000090 pffindtype
08253ef2 g     O .rwdata	00000002 OSTaskDelEn
08253f80 g     O .rwdata	00000004 tcp_sendspace
08249718 g     F .text	00000110 vftell
0825e104 g     O .bss	00000012 eth_prt_buf
0821a4c0 g     F .text	00000110 OSSemQuery
08218e58 g     F .text	00000280 OSQDel
0821941c g     F .text	0000016c OSQPendAbort
0821c35c g     F .text	00000038 alt_irq_init
08220150 g     F .text	00000040 alt_tse_mac_get_common_speed
0825e56c g     O .bss	00000018 app_semaphore
0823c5bc g     F .text	00000064 alt_release_fd
0822dae4 g     F .text	0000007c post_app_sem
08226c28 g     F .text	000000a4 igmp_init
0824b4e0 g     F .text	00000018 memalign
08203694 g     F .text	0000006c sprintf
0824dd10 g     O .rodata	00000100 .hidden __clz_tab
082540e4 g     O .bss	00000004 dsc_renew
082471b4 g     F .text	00000078 md_fwrite
08253ff4 g     O .bss	00000004 _PathLocale
0825410c g     O .bss	00000004 tcp_sleep_count
0822eb10 g     F .text	0000007c insque
0824b47c g     F .text	00000014 atexit
082541d8 g     O .bss	00000004 vfsfiles
08210a58 g     F .text	00000060 _write_r
0824bb84 g     F .text	00000050 _vsprintf_r
08244dfc g     F .text	00000298 udp_send
0821556c g     F .text	0000008c OSSchedLock
08226f20 g     F .text	0000029c igmp_send
0820ba88 g     F .text	00000018 setlocale
0821700c g     F .text	00000108 OSFlagCreate
082588f8 g     O .bss	00002000 LEDManagementTaskStk
0822d64c g     F .text	00000044 irq_Unmask
08230494 g     F .text	000000d8 t_listen
08253e88 g     O .rwdata	00000004 _impure_ptr
08251eec g     O .rwdata	00000018 ssstask
08254010 g     O .bss	00000004 alt_argc
0823a3c8 g     F .text	000006d4 tcp_usrreq
0823af8c g     F .text	0000023c udp_usrreq
0822e060 g     F .text	00000034 ncpalloc
0820a7bc g     F .text	0000021c __sflush_r
0823bd60 g     F .text	00000060 _do_dtors
0820ba74 g     F .text	00000008 __locale_cjk_lang
08253ec2 g     O .rwdata	00000002 OSEventMultiEn
08253fb4 g     O .rwdata	00000004 pingdelay
0823da14 g     F .text	00000074 arp_send_pending
0825db1c g     O .bss	000000e0 tse_mac_if
0824535c g     F .text	000002a4 igmpv1_input
0820db50 g     F .text	000001d4 __srefill_r
0822dd5c g     F .text	0000004c pre_task_setup
0825412c g     O .bss	00000004 rcvdq_sem_ptr
08227e0c g     F .text	00000124 bsd_getsockname
082425bc g     F .text	00000130 ip_reasm_mark_compact_rfq
082017ac g     F .text	0000012c FindLastFlashSectorOffset
08217114 g     F .text	00000248 OSFlagDel
08254060 g     O .bss	00000004 OSEventFreeList
08229a20 g     F .text	00000048 dhc_set_callback
08200060 g       .exceptions	00000000 alt_irq_entry
08254180 g     O .bss	00000004 arpcache
0824ae14 g     F .text	00000300 icmp_destun
082439f8 g     F .text	00000064 lookup_mcast
08249a8c g     F .text	00000048 vfslookup
082433cc g     F .text	000003d4 ip_demux
0820d0f8 g     F .text	00000064 __ulp
08254110 g     O .bss	00000004 tcp_wakeup_count
082175d0 g     F .text	000005b8 OSFlagPend
08253f0e g     O .rwdata	00000002 OSTmrEn
0820adec g     F .text	00000018 __fp_unlock_all
0822da28 g     F .text	000000bc wait_app_sem
0821e1d8 g     F .text	00000060 altera_avalon_lcd_16207_write_fd
0820ae48 g     F .text	0000005c fputc
08253f40 g     O .rwdata	00000004 ipmcfail_str
08254124 g     O .bss	00000004 memtrapsize
0822e4fc g     F .text	000002f4 m_copy
08253f88 g     O .rwdata	00000008 alt_fs_list
0825e5e8 g     O .bss	00000014 mfreeq
082165e4 g     F .text	00000074 OS_StrCopy
08231a5c g     F .text	0000005c sobind
08246fb4 g     F .text	00000058 init_memdev
08253fd8 g     O .bss	00000001 to_ssstask
0822eb8c g     F .text	000000f8 nptcp_init
08253ed8 g     O .rwdata	00000002 OSMemNameSize
0825e43c g     O .bss	000000f0 global_TCPwakeup_set
0823ce20 g     F .text	00000020 OSInitHookEnd
08233af4 g     F .text	000000c4 soisdisconnected
0823d98c g     F .text	00000088 arp_free_pending
08253f04 g     O .rwdata	00000002 OSTCBPrioTblMax
0820baa0 g     F .text	0000000c localeconv
08231c98 g     F .text	000002bc soclose
0825e32c g     O .bss	00000014 bigfreeq
08253f00 g     O .rwdata	00000002 OSTaskStatStkChkEn
08253fb0 g     O .rwdata	00000004 prompt
08253f78 g     O .rwdata	00000004 tcp_keepidle
08223360 g     F .text	000001a8 alt_tse_phy_set_adv_10
0822f94c g     F .text	000001c8 rawip_soinput
0823be50 g     F .text	00000050 alt_ic_isr_register
0824956c g     F .text	00000060 vfwrite
08253ed4 g     O .rwdata	00000002 OSMemEn
08233db8 g     F .text	000000ac soqinsque
082541b4 g     O .bss	00000004 so_evtmap_delete
08202d60 g     F .text	00000034 fwrite
08253ede g     O .rwdata	00000002 OSMutexEn
082541a0 g     O .bss	00000004 h_ireq
08253fd8 g       *ABS*	00000000 _edata
0824023c g     F .text	000005c4 ip_fragment
082257bc g     F .text	00000148 iniche_devices_init
0825e5fc g     O .bss	00000028 tcp_saveti
08228eb8 g     F .text	000000d8 con_page
0825ea88 g       *ABS*	00000000 _end
082333f4 g     F .text	000004a8 sogetopt
0821434c g     F .text	00000068 alt_flash_open_dev
08254064 g     O .bss	00000001 OSIntNesting
0822220c g     F .text	00000248 alt_tse_mac_associate_phy
08253ab8 g     O .rwdata	00000030 nettasks
0822cc68 g     F .text	00000020 pk_get_max_intrsafe_buf_len
08210cd4 g     F .text	00000164 __fputwc
08240b4c g     F .text	000001d8 iproute
0822f43c g     F .text	000000f4 np_stripoptions
082541b8 g     O .bss	00000001 so_evtmap
0821cc88 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
0820aea4 g     F .text	0000009c _fputs_r
0821c098 g     F .text	000001d4 OSTimeDlyResume
0820197c g     F .text	000000d0 SSSCreateTasks
08244180 g     F .text	000003c0 add_route
08217484 g     F .text	0000014c OSFlagNameSet
082265a4 g     F .text	00000090 c_older
082347a8 g     F .text	00000084 sbflush
08247034 g     F .text	00000024 md_fclose
082296b0 g     F .text	00000030 tk_yield
08201d80 g     F .text	000000c8 sss_handle_accept
0821b904 g     F .text	000001c0 OSTaskStkChk
0823bf28 g     F .text	0000008c alt_ic_irq_disable
0823218c g     F .text	00000558 sosend
08253eda g     O .rwdata	00000002 OSMemSize
08240800 g     F .text	000000a4 ip_mymach
0821e944 g     F .text	0000008c alt_avalon_sgdma_construct_descriptor
0820de48 g     F .text	0000007c __swrite
082540f4 g     O .bss	00000004 cticks_initialized
08253fb8 g     O .rwdata	00000004 deflength
082311fc g     F .text	000001f4 t_sendto
08253e94 g     O .rwdata	00000004 __malloc_trim_threshold
08203258 g     F .text	00000080 _perror_r
0820ba68 g     F .text	0000000c __locale_msgcharset
08254068 g     O .bss	00000004 OSTCBCur
082318b4 g     F .text	000001a8 socreate
0824b4a8 g     F .text	00000038 exit
0825e894 g     O .bss	00000100 arp_table
082541f0 g     O .bss	00000004 icmpdu_hook
08253edc g     O .rwdata	00000002 OSMemTblSize
0820b90c g     F .text	000000c4 _fwalk_reent
0823d684 g     F .text	00000024 create_apptasks
08253f74 g     O .rwdata	00000004 tcp_ttl
0820cefc g     F .text	000001fc __mdiff
082143b4 g     F .text	00000054 alt_flash_close_dev
0822e094 g     F .text	00000040 ncpfree
08202b18 g     F .text	00000074 .hidden __modsi3
0824b4f8 g     F .text	00000198 _memalign_r
08254084 g     O .bss	00000004 MaxLnh
08253e80 g     O .rwdata	00000004 __ctype_ptr__
0821f3b8 g     F .text	00000050 tse_mac_setGMIImode
082477a4 g     F .text	00000084 inet_ntop
082452f4 g     F .text	00000024 udp_maxalloc
08223d80 g     F .text	000000e4 marvell_cfg_gmii
08380000 g       *ABS*	00000000 __alt_data_end
08200060 g     F .exceptions	00000000 alt_exception
0820adc8 g     F .text	00000004 __sfp_lock_release
082153d0 g     F .text	00000058 OSInit
08222454 g     F .text	00000128 alt_tse_phy_cfg_pcs
0821bca8 g     F .text	00000124 OSTaskQuery
0823cf78 g     F .text	00000094 icmp_port_du
08254154 g     O .bss	00000004 tcp_iss
08219bc8 g     F .text	000000a8 OS_QInit
0824b490 g     F .text	0000000c atoi
08253f64 g     O .rwdata	00000004 bigbufsiz
08216658 g     F .text	00000054 OS_StrLen
08239b8c g     F .text	00000078 tcp_putseq
082187cc g     F .text	00000114 OSMemNameSet
0824d17e g     O .rodata	00000101 _ctype_
08200000 g       *ABS*	00000000 __alt_mem_onchip_ram
082343ec g     F .text	000001dc sbappendaddr
00000000 g       *ABS*	00000000 __alt_mem_ext_flash
082541e8 g     O .bss	00000004 vfs_total_rw_space
082463c4 g     F .text	00000108 ip_getmoptions
08253ef6 g     O .rwdata	00000002 OSTaskProfileEn
08245094 g     F .text	000000f4 udpswap
0825406c g     O .bss	00000004 OSTime
08254130 g     O .bss	00000004 nextslow
08239c78 g     F .text	00000270 tcp_slowtimo
08239898 g     F .text	0000010c tcp_newtcpcb
0823e668 g     F .text	00000180 send_via_arp
08229970 g     F .text	000000b0 dhc_init
08241f8c g     F .text	00000058 ip_reasm_find_ire
0825c278 g     O .bss	00000800 OSTaskIdleStk
0824bea0 g     F .text	00000034 _exit
08249ca0 g     F .text	00000058 isvfile_locked
082283e8 g     F .text	00000184 bsd_select
0823b944 g     F .text	0000012c alt_alarm_start
0821735c g     F .text	00000128 OSFlagNameGet
08245318 g     F .text	00000044 udp_free
0822cd44 g     F .text	000000b8 getq
08249df4 g     F .text	00000024 prep_vfs
0821c26c g     F .text	0000005c OSTimeGet
08253fac g     O .rwdata	00000004 name
082349e4 g     F .text	00000100 sbdropend
0820baac g     F .text	000001bc __smakebuf_r
0823e7e8 g     F .text	0000010c cb_arpent_tmo
08203edc g     F .text	00000098 strlen
08245cc8 g     F .text	00000134 IPADDR_TO_NETP
0822826c g     F .text	00000034 bsd_inet_ntoa
0823cd94 g     F .text	00000020 OSTaskSwHook
0823c330 g     F .text	00000154 open
0822cfac g     F .text	000001fc udp_open
0825ca78 g     O .bss	00000b40 OSEventTbl
08233f6c g     F .text	00000058 socantsendmore
082541ec g     O .bss	00000004 vfs_total_dyna_files
08212f00 g     F .text	000000dc .hidden __gedf2
0823c7f8 g     F .text	00000044 alt_uncached_free
0825d5b8 g     O .bss	00000510 OSTCBTbl
0825418c g     O .bss	00000004 arpReqsOut
0821a5d0 g     F .text	00000100 OSSemSet
08253fd4 g     O .rwdata	00000004 http_root_path
0822b920 g     F .text	00000270 dhc_extract_opts
082414f8 g     F .text	00000564 ip_reasm_compute_overlap
08253e98 g     O .rwdata	00000004 __wctomb
0820f50c g     F .text	00000018 __sprint_r
0821f234 g     F .text	000000a8 tse_mac_aRxRead
08203700 g     F .text	00000164 strchr
0825e116 g     O .bss	00000012 ipreturn
082541a8 g     O .bss	00000004 port_prep
08253b3b g     O .rwdata	0000000d tcp_backoff
082338e8 g     F .text	00000070 soisconnecting
08200ca8 g     F .text	00000070 SSSInitialTask
0820af40 g     F .text	00000018 fputs
08253fa0 g     O .rwdata	00000004 alt_priority_mask
08245858 g     F .text	000001ec igmpv2_process_query
08234b74 g     F .text	000001d0 t_select
08219df8 g     F .text	00000240 OSSemDel
0823b81c g     F .text	00000128 udp4_sockaddr
08254070 g     O .bss	00000004 OSFlagFreeList
08247f78 g     F .text	000001e0 in_pcbconnect
08254148 g     O .bss	00000004 dropline
082541a4 g     O .bss	00000004 ire_cticks
0823bea0 g     F .text	00000088 alt_ic_irq_enable
08253ebc g     O .rwdata	00000002 OSEventNameSize
08208bb0 g     F .text	0000001c __vfprintf_internal
08229274 g     F .text	00000078 tk_netmain
08248158 g     F .text	0000005c in_pcbdisconnect
08254074 g     O .bss	00000001 OSStatRdy
0825dac8 g     O .bss	00000054 OSTCBPrioTbl
082111d8 g     F .text	0000005c _wctomb_r
08214850 g     F .text	000000c4 __env_lock
08253f02 g     O .rwdata	00000002 OSTaskSwHookEn
08253d14 g     O .rwdata	00000024 mdio
08220410 g     F .text	000000e0 alt_tse_mac_set_speed
0821e51c g     F .text	00000084 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
08227bc4 g     F .text	00000124 bsd_accept
08253f84 g     O .rwdata	00000004 tcp_recvspace
082137e8 g     F .text	000008fc .hidden __subdf3
0824be88 g     F .text	00000018 _vfprintf_r
0823ad50 g     F .text	00000040 tcpinit
082540a4 g     O .bss	00000004 igmp_all_rtrs_group
0822f8f0 g     F .text	0000005c rawip_lookup
0823d724 g     F .text	000000a0 fcntl
0820c930 g     F .text	000000b0 __lo0bits
082345c8 g     F .text	000001e0 sbcompress
08253fa4 g     O .rwdata	00000008 alt_alarm_list
082399a4 g     F .text	000000ac tcp_drop
08253eca g     O .rwdata	00000002 OSFlagWidth
0823bd00 g     F .text	00000060 _do_ctors
0822310c g     F .text	00000254 alt_tse_phy_set_adv_100
08239f48 g     F .text	00000480 tcp_timers
08226ba4 g     F .text	00000084 if_netnumber
082464cc g     F .text	00000088 ip_freemoptions
0823389c g     F .text	0000004c sohasoutofband
082110e8 g     F .text	000000c0 wcrtomb
08235800 g     F .text	00002330 tcp_input
08227ce8 g     F .text	00000124 bsd_getpeername
082282a0 g     F .text	00000148 bsd_recvfrom
08225774 g     F .text	00000048 close
082540d4 g     O .bss	00000004 dsc_bpreplys
08254020 g     O .bss	00000004 alt_envsem
08254078 g     O .bss	00000004 OSIdleCtrRun
08215a14 g     F .text	00000020 OSVersion
08253f14 g     O .rwdata	00000002 OSTmrCfgWheelSize
0821bdcc g     F .text	00000070 OS_TaskStkClr
08248510 g     F .text	0000002c set_vfopen_error
08253eee g     O .rwdata	00000002 OSTaskCreateEn
082201d8 g     F .text	0000006c alt_tse_get_system_index
08253b18 g     O .rwdata	00000018 rawip_protosw
08234058 g     F .text	0000006c sbwait
08216004 g     F .text	00000068 OS_EventWaitListInit
0822bb90 g     F .text	00000550 dhc_second
0821ef24 g     F .text	000000a8 alt_avalon_sgdma_init
08254174 g     O .bss	00000004 port_1s_callout
08210e5c g     F .text	00000080 fputwc
0823ce40 g     F .text	00000020 OSTaskIdleHook
0824b6a4 g     F .text	00000014 free
0820adcc g     F .text	00000004 __sinit_lock_acquire
08254080 g     O .bss	00000001 number_of_tse_mac
0820c6a4 g     F .text	00000120 __multadd
0821bac4 g     F .text	000001e4 OSTaskSuspend
0820c67c g     F .text	00000028 _Bfree
0821f0c0 g     F .text	00000030 no_printf
08233bb8 g     F .text	00000200 sonewconn
0824a2b0 g     F .text	00000b64 icmprcv
0822e164 g     F .text	000000c4 pffindproto
082166ac g     F .text	0000005c OS_TaskIdle
08253f1a g     O .rwdata	00000002 OSTmrTblSize
08219a6c g     F .text	0000015c OSQQuery



Disassembly of section .exceptions:

08200060 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 8200060:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 8200064:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 8200068:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 820006c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 8200070:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 8200074:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 8200078:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 820007c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 8200080:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 8200084:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 8200088:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 820008c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 8200090:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 8200094:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 8200098:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 820009c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 82000a0:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 82000a4:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 82000a8:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 82000ac:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 82000b0:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 82000b4:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 82000b8:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 82000bc:	10000326 	beq	r2,zero,82000cc <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 82000c0:	20000226 	beq	r4,zero,82000cc <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 82000c4:	820012c0 	call	820012c <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 82000c8:	00000306 	br	82000d8 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
 82000cc:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
 82000d0:	e8bfff17 	ldw	r2,-4(ea)

082000d4 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 82000d4:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 82000d8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 82000dc:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 82000e0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 82000e4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 82000e8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 82000ec:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 82000f0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 82000f4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 82000f8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 82000fc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 8200100:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 8200104:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 8200108:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 820010c:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 8200110:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 8200114:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 8200118:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 820011c:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 8200120:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 8200124:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 8200128:	ef80083a 	eret

0820012c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 820012c:	defff904 	addi	sp,sp,-28
 8200130:	dfc00615 	stw	ra,24(sp)
 8200134:	df000515 	stw	fp,20(sp)
 8200138:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 820013c:	82154280 	call	8215428 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 8200140:	0005313a 	rdctl	r2,ipending
 8200144:	e0bffe15 	stw	r2,-8(fp)

  return active;
 8200148:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 820014c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 8200150:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 8200154:	00800044 	movi	r2,1
 8200158:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 820015c:	e0fffb17 	ldw	r3,-20(fp)
 8200160:	e0bffc17 	ldw	r2,-16(fp)
 8200164:	1884703a 	and	r2,r3,r2
 8200168:	10001426 	beq	r2,zero,82001bc <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 820016c:	008209b4 	movhi	r2,2086
 8200170:	10b9cc04 	addi	r2,r2,-6352
 8200174:	e0fffd17 	ldw	r3,-12(fp)
 8200178:	180690fa 	slli	r3,r3,3
 820017c:	10c5883a 	add	r2,r2,r3
 8200180:	10c00017 	ldw	r3,0(r2)
 8200184:	008209b4 	movhi	r2,2086
 8200188:	10b9cc04 	addi	r2,r2,-6352
 820018c:	e13ffd17 	ldw	r4,-12(fp)
 8200190:	200890fa 	slli	r4,r4,3
 8200194:	1105883a 	add	r2,r2,r4
 8200198:	10800104 	addi	r2,r2,4
 820019c:	10800017 	ldw	r2,0(r2)
 82001a0:	1009883a 	mov	r4,r2
 82001a4:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 82001a8:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 82001ac:	0005313a 	rdctl	r2,ipending
 82001b0:	e0bfff15 	stw	r2,-4(fp)

  return active;
 82001b4:	e0bfff17 	ldw	r2,-4(fp)
 82001b8:	00000706 	br	82001d8 <alt_irq_handler+0xac>
      }
      mask <<= 1;
 82001bc:	e0bffc17 	ldw	r2,-16(fp)
 82001c0:	1085883a 	add	r2,r2,r2
 82001c4:	e0bffc15 	stw	r2,-16(fp)
      i++;
 82001c8:	e0bffd17 	ldw	r2,-12(fp)
 82001cc:	10800044 	addi	r2,r2,1
 82001d0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 82001d4:	003fe106 	br	820015c <alt_irq_handler+0x30>

    active = alt_irq_pending ();
 82001d8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 82001dc:	e0bffb17 	ldw	r2,-20(fp)
 82001e0:	103fdb1e 	bne	r2,zero,8200150 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 82001e4:	82154740 	call	8215474 <OSIntExit>
}
 82001e8:	0001883a 	nop
 82001ec:	e037883a 	mov	sp,fp
 82001f0:	dfc00117 	ldw	ra,4(sp)
 82001f4:	df000017 	ldw	fp,0(sp)
 82001f8:	dec00204 	addi	sp,sp,8
 82001fc:	f800283a 	ret

Disassembly of section .text:

08200200 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 8200200:	00a00014 	movui	r2,32768
#endif

0:
    initd 0(r2)
 8200204:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 8200208:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 820020c:	00bffd16 	blt	zero,r2,8200204 <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 8200210:	06c20e34 	movhi	sp,2104
    ori sp, sp, %lo(__alt_stack_pointer)
 8200214:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 8200218:	06820974 	movhi	gp,2085
    ori gp, gp, %lo(_gp)
 820021c:	d6afa014 	ori	gp,gp,48768
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 8200220:	00820974 	movhi	r2,2085
    ori r2, r2, %lo(__bss_start)
 8200224:	108ff614 	ori	r2,r2,16344

    movhi r3, %hi(__bss_end)
 8200228:	00c20974 	movhi	r3,2085
    ori r3, r3, %lo(__bss_end)
 820022c:	18faa214 	ori	r3,r3,60040

    beq r2, r3, 1f
 8200230:	10c00326 	beq	r2,r3,8200240 <_start+0x40>

0:
    stw zero, (r2)
 8200234:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 8200238:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 820023c:	10fffd36 	bltu	r2,r3,8200234 <_start+0x34>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 8200240:	82146e40 	call	82146e4 <alt_main>

08200244 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 8200244:	003fff06 	br	8200244 <alt_after_alt_main>

08200248 <alt_uCOSIIErrorHandler>:
#include <errno.h>
#include "includes.h"
#include "alt_error_handler.h"
 
void alt_uCOSIIErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 8200248:	defffb04 	addi	sp,sp,-20
 820024c:	dfc00415 	stw	ra,16(sp)
 8200250:	df000315 	stw	fp,12(sp)
 8200254:	df000304 	addi	fp,sp,12
 8200258:	2005883a 	mov	r2,r4
 820025c:	e17fff15 	stw	r5,-4(fp)
 8200260:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
 8200264:	e0bffe03 	ldbu	r2,-8(fp)
 8200268:	10014a26 	beq	r2,zero,8200794 <alt_uCOSIIErrorHandler+0x54c>
   {
      return;
   }
   
   fault_level = SYSTEM;  
 820026c:	00800084 	movi	r2,2
 8200270:	e0bffd15 	stw	r2,-12(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 8200274:	821556c0 	call	821556c <OSSchedLock>
      
   switch (error_code)
 8200278:	e0bffe03 	ldbu	r2,-8(fp)
 820027c:	10c00a20 	cmpeqi	r3,r2,40
 8200280:	1800261e 	bne	r3,zero,820031c <alt_uCOSIIErrorHandler+0xd4>
 8200284:	10c00a48 	cmpgei	r3,r2,41
 8200288:	1800121e 	bne	r3,zero,82002d4 <alt_uCOSIIErrorHandler+0x8c>
 820028c:	10c00120 	cmpeqi	r3,r2,4
 8200290:	1800601e 	bne	r3,zero,8200414 <alt_uCOSIIErrorHandler+0x1cc>
 8200294:	10c00148 	cmpgei	r3,r2,5
 8200298:	1800071e 	bne	r3,zero,82002b8 <alt_uCOSIIErrorHandler+0x70>
 820029c:	10c000a0 	cmpeqi	r3,r2,2
 82002a0:	18007a1e 	bne	r3,zero,820048c <alt_uCOSIIErrorHandler+0x244>
 82002a4:	10c000c8 	cmpgei	r3,r2,3
 82002a8:	1800631e 	bne	r3,zero,8200438 <alt_uCOSIIErrorHandler+0x1f0>
 82002ac:	10800060 	cmpeqi	r2,r2,1
 82002b0:	10004d1e 	bne	r2,zero,82003e8 <alt_uCOSIIErrorHandler+0x1a0>
 82002b4:	0000bc06 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
 82002b8:	10c00520 	cmpeqi	r3,r2,20
 82002bc:	1800401e 	bne	r3,zero,82003c0 <alt_uCOSIIErrorHandler+0x178>
 82002c0:	10c007a0 	cmpeqi	r3,r2,30
 82002c4:	1800961e 	bne	r3,zero,8200520 <alt_uCOSIIErrorHandler+0x2d8>
 82002c8:	108002a0 	cmpeqi	r2,r2,10
 82002cc:	1000651e 	bne	r2,zero,8200464 <alt_uCOSIIErrorHandler+0x21c>
 82002d0:	0000b506 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
 82002d4:	10c01020 	cmpeqi	r3,r2,64
 82002d8:	1800881e 	bne	r3,zero,82004fc <alt_uCOSIIErrorHandler+0x2b4>
 82002dc:	10c01048 	cmpgei	r3,r2,65
 82002e0:	1800071e 	bne	r3,zero,8200300 <alt_uCOSIIErrorHandler+0xb8>
 82002e4:	10c00f60 	cmpeqi	r3,r2,61
 82002e8:	18007a1e 	bne	r3,zero,82004d4 <alt_uCOSIIErrorHandler+0x28c>
 82002ec:	10c00fa0 	cmpeqi	r3,r2,62
 82002f0:	18006f1e 	bne	r3,zero,82004b0 <alt_uCOSIIErrorHandler+0x268>
 82002f4:	10800aa0 	cmpeqi	r2,r2,42
 82002f8:	1000111e 	bne	r2,zero,8200340 <alt_uCOSIIErrorHandler+0xf8>
 82002fc:	0000aa06 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
 8200300:	10c01920 	cmpeqi	r3,r2,100
 8200304:	1800901e 	bne	r3,zero,8200548 <alt_uCOSIIErrorHandler+0x300>
 8200308:	10c03fe0 	cmpeqi	r3,r2,255
 820030c:	1800991e 	bne	r3,zero,8200574 <alt_uCOSIIErrorHandler+0x32c>
 8200310:	108010a0 	cmpeqi	r2,r2,66
 8200314:	10001a1e 	bne	r2,zero,8200380 <alt_uCOSIIErrorHandler+0x138>
 8200318:	0000a306 	br	82005a8 <alt_uCOSIIErrorHandler+0x360>
   {  
      case OS_PRIO_EXIST:
         fprintf(stderr, "Attempted to assign task priority aready in use.\n");
 820031c:	d0a00217 	ldw	r2,-32760(gp)
 8200320:	10800317 	ldw	r2,12(r2)
 8200324:	100f883a 	mov	r7,r2
 8200328:	01800c44 	movi	r6,49
 820032c:	01400044 	movi	r5,1
 8200330:	01020974 	movhi	r4,2085
 8200334:	212fb504 	addi	r4,r4,-16684
 8200338:	8202d600 	call	8202d60 <fwrite>
         break;
 820033c:	0000b106 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_PRIO_INVALID:
         fprintf(stderr, "Specified task priority higher than allowed max.\n");
 8200340:	d0a00217 	ldw	r2,-32760(gp)
 8200344:	10800317 	ldw	r2,12(r2)
 8200348:	100f883a 	mov	r7,r2
 820034c:	01800c44 	movi	r6,49
 8200350:	01400044 	movi	r5,1
 8200354:	01020974 	movhi	r4,2085
 8200358:	212fc204 	addi	r4,r4,-16632
 820035c:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, "Task can't be assigned a priority higher than %d\n",
 8200360:	d0a00217 	ldw	r2,-32760(gp)
 8200364:	10800317 	ldw	r2,12(r2)
 8200368:	01800504 	movi	r6,20
 820036c:	01420974 	movhi	r5,2085
 8200370:	296fcf04 	addi	r5,r5,-16580
 8200374:	1009883a 	mov	r4,r2
 8200378:	8202c700 	call	8202c70 <fprintf>
            OS_LOWEST_PRIO);
         break;
 820037c:	0000a106 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_NO_MORE_TCB:
         fprintf(stderr, "Task Control Blocks have been exhausted\n");
 8200380:	d0a00217 	ldw	r2,-32760(gp)
 8200384:	10800317 	ldw	r2,12(r2)
 8200388:	100f883a 	mov	r7,r2
 820038c:	01800a04 	movi	r6,40
 8200390:	01400044 	movi	r5,1
 8200394:	01020974 	movhi	r4,2085
 8200398:	212fdc04 	addi	r4,r4,-16528
 820039c:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, "Current max number of tasks is %d\n",OS_MAX_TASKS);
 82003a0:	d0a00217 	ldw	r2,-32760(gp)
 82003a4:	10800317 	ldw	r2,12(r2)
 82003a8:	01800284 	movi	r6,10
 82003ac:	01420974 	movhi	r5,2085
 82003b0:	296fe704 	addi	r5,r5,-16484
 82003b4:	1009883a 	mov	r4,r2
 82003b8:	8202c700 	call	8202c70 <fprintf>
         break;
 82003bc:	00009106 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_MBOX_FULL:
         fault_level = NONE;
 82003c0:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted Post to Mailbox already holding message\n");
 82003c4:	d0a00217 	ldw	r2,-32760(gp)
 82003c8:	10800317 	ldw	r2,12(r2)
 82003cc:	100f883a 	mov	r7,r2
 82003d0:	01800c84 	movi	r6,50
 82003d4:	01400044 	movi	r5,1
 82003d8:	01020974 	movhi	r4,2085
 82003dc:	212ff004 	addi	r4,r4,-16448
 82003e0:	8202d600 	call	8202d60 <fwrite>
         break;
 82003e4:	00008706 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_EVENT_TYPE:
         fault_level = TASK;
 82003e8:	00800044 	movi	r2,1
 82003ec:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, 
 82003f0:	d0a00217 	ldw	r2,-32760(gp)
 82003f4:	10800317 	ldw	r2,12(r2)
 82003f8:	100f883a 	mov	r7,r2
 82003fc:	01801244 	movi	r6,73
 8200400:	01400044 	movi	r5,1
 8200404:	01020974 	movhi	r4,2085
 8200408:	212ffd04 	addi	r4,r4,-16396
 820040c:	8202d600 	call	8202d60 <fwrite>
"Attempted to access a resource with no match for the required data type.\n");
         break;
 8200410:	00007c06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_PEVENT_NULL:
         fprintf(stderr, "Attempting to access a resource pointing to NULL\n");
 8200414:	d0a00217 	ldw	r2,-32760(gp)
 8200418:	10800317 	ldw	r2,12(r2)
 820041c:	100f883a 	mov	r7,r2
 8200420:	01800c44 	movi	r6,49
 8200424:	01400044 	movi	r5,1
 8200428:	01020974 	movhi	r4,2085
 820042c:	21301004 	addi	r4,r4,-16320
 8200430:	8202d600 	call	8202d60 <fwrite>
         break;
 8200434:	00007306 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_POST_NULL_PTR:
         fault_level = TASK;
 8200438:	00800044 	movi	r2,1
 820043c:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, "Attempted to Post a NULL to a resource. \n");
 8200440:	d0a00217 	ldw	r2,-32760(gp)
 8200444:	10800317 	ldw	r2,12(r2)
 8200448:	100f883a 	mov	r7,r2
 820044c:	01800a44 	movi	r6,41
 8200450:	01400044 	movi	r5,1
 8200454:	01020974 	movhi	r4,2085
 8200458:	21301d04 	addi	r4,r4,-16268
 820045c:	8202d600 	call	8202d60 <fwrite>
         break;
 8200460:	00006806 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TIMEOUT:
         fault_level = NONE;
 8200464:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Resource not received in specified time\n");
 8200468:	d0a00217 	ldw	r2,-32760(gp)
 820046c:	10800317 	ldw	r2,12(r2)
 8200470:	100f883a 	mov	r7,r2
 8200474:	01800a04 	movi	r6,40
 8200478:	01400044 	movi	r5,1
 820047c:	01020974 	movhi	r4,2085
 8200480:	21302804 	addi	r4,r4,-16224
 8200484:	8202d600 	call	8202d60 <fwrite>
         break;
 8200488:	00005e06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_PEND_ISR:
         fprintf(stderr, "Attempting to pend for a resource in an ISR\n");
 820048c:	d0a00217 	ldw	r2,-32760(gp)
 8200490:	10800317 	ldw	r2,12(r2)
 8200494:	100f883a 	mov	r7,r2
 8200498:	01800b04 	movi	r6,44
 820049c:	01400044 	movi	r5,1
 82004a0:	01020974 	movhi	r4,2085
 82004a4:	21303304 	addi	r4,r4,-16180
 82004a8:	8202d600 	call	8202d60 <fwrite>
         break;
 82004ac:	00005506 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TASK_DEL_IDLE:
         fprintf(stderr, "Attempted to delete the IDLE task\n");
 82004b0:	d0a00217 	ldw	r2,-32760(gp)
 82004b4:	10800317 	ldw	r2,12(r2)
 82004b8:	100f883a 	mov	r7,r2
 82004bc:	01800884 	movi	r6,34
 82004c0:	01400044 	movi	r5,1
 82004c4:	01020974 	movhi	r4,2085
 82004c8:	21303f04 	addi	r4,r4,-16132
 82004cc:	8202d600 	call	8202d60 <fwrite>
         break;
 82004d0:	00004c06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TASK_DEL_ERR:
         fault_level = NONE;
 82004d4:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted to delete a task that does not exist\n");
 82004d8:	d0a00217 	ldw	r2,-32760(gp)
 82004dc:	10800317 	ldw	r2,12(r2)
 82004e0:	100f883a 	mov	r7,r2
 82004e4:	01800bc4 	movi	r6,47
 82004e8:	01400044 	movi	r5,1
 82004ec:	01020974 	movhi	r4,2085
 82004f0:	21304804 	addi	r4,r4,-16096
 82004f4:	8202d600 	call	8202d60 <fwrite>
         break;
 82004f8:	00004206 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_TASK_DEL_ISR:
         fprintf(stderr, "Attempted to delete a task from an ISR\n");
 82004fc:	d0a00217 	ldw	r2,-32760(gp)
 8200500:	10800317 	ldw	r2,12(r2)
 8200504:	100f883a 	mov	r7,r2
 8200508:	018009c4 	movi	r6,39
 820050c:	01400044 	movi	r5,1
 8200510:	01020974 	movhi	r4,2085
 8200514:	21305404 	addi	r4,r4,-16048
 8200518:	8202d600 	call	8202d60 <fwrite>
         break;
 820051c:	00003906 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_Q_FULL:
         fault_level = NONE;
 8200520:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted to post to a full message queue\n");
 8200524:	d0a00217 	ldw	r2,-32760(gp)
 8200528:	10800317 	ldw	r2,12(r2)
 820052c:	100f883a 	mov	r7,r2
 8200530:	01800a84 	movi	r6,42
 8200534:	01400044 	movi	r5,1
 8200538:	01020974 	movhi	r4,2085
 820053c:	21305e04 	addi	r4,r4,-16008
 8200540:	8202d600 	call	8202d60 <fwrite>
         break;
 8200544:	00002f06 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case OS_ERR_NOT_MUTEX_OWNER:
         fault_level = TASK;
 8200548:	00800044 	movi	r2,1
 820054c:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, "Attempted to post a mutex not owned by the task\n");
 8200550:	d0a00217 	ldw	r2,-32760(gp)
 8200554:	10800317 	ldw	r2,12(r2)
 8200558:	100f883a 	mov	r7,r2
 820055c:	01800c04 	movi	r6,48
 8200560:	01400044 	movi	r5,1
 8200564:	01020974 	movhi	r4,2085
 8200568:	21306904 	addi	r4,r4,-15964
 820056c:	8202d600 	call	8202d60 <fwrite>
         break;
 8200570:	00002406 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 8200574:	00800084 	movi	r2,2
 8200578:	e0bffd15 	stw	r2,-12(fp)
         printf(
 820057c:	01020974 	movhi	r4,2085
 8200580:	21307604 	addi	r4,r4,-15912
 8200584:	820331c0 	call	820331c <printf>
"\n[MicroC/OS-II]: See STDERR for expanded diagnosis translation.");    
         fprintf(stderr, "\n[MicroC/OS-II]: Expanded Diagnosis: %s.", 
 8200588:	d0a00217 	ldw	r2,-32760(gp)
 820058c:	10800317 	ldw	r2,12(r2)
 8200590:	e1bfff17 	ldw	r6,-4(fp)
 8200594:	01420974 	movhi	r5,2085
 8200598:	29708604 	addi	r5,r5,-15848
 820059c:	1009883a 	mov	r4,r2
 82005a0:	8202c700 	call	8202c70 <fprintf>
                 (char *)expanded_diagnosis_ptr);
         break;           
 82005a4:	00001706 	br	8200604 <alt_uCOSIIErrorHandler+0x3bc>
      default:
         printf("\n[MicroC/OS-II]: (Not a MicroC/OS-II error) See STDERR.\n");    
 82005a8:	01020974 	movhi	r4,2085
 82005ac:	21309104 	addi	r4,r4,-15804
 82005b0:	82035a00 	call	82035a0 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]:");
 82005b4:	d0a00217 	ldw	r2,-32760(gp)
 82005b8:	10800317 	ldw	r2,12(r2)
 82005bc:	100f883a 	mov	r7,r2
 82005c0:	01800404 	movi	r6,16
 82005c4:	01400044 	movi	r5,1
 82005c8:	01020974 	movhi	r4,2085
 82005cc:	21309f04 	addi	r4,r4,-15748
 82005d0:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, "\nError_code %d.\n", error_code);
 82005d4:	d0a00217 	ldw	r2,-32760(gp)
 82005d8:	10800317 	ldw	r2,12(r2)
 82005dc:	e0fffe03 	ldbu	r3,-8(fp)
 82005e0:	180d883a 	mov	r6,r3
 82005e4:	01420974 	movhi	r5,2085
 82005e8:	2970a404 	addi	r5,r5,-15728
 82005ec:	1009883a 	mov	r4,r2
 82005f0:	8202c700 	call	8202c70 <fprintf>
         perror("\n[MicroC/OS-II]: (Not a MicroC/OS-II error), ERRNO: ");
 82005f4:	01020974 	movhi	r4,2085
 82005f8:	2130a904 	addi	r4,r4,-15708
 82005fc:	82032d80 	call	82032d8 <perror>
         break;
 8200600:	0001883a 	nop

   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */  
   switch (fault_level) {
 8200604:	e0bffd17 	ldw	r2,-12(fp)
 8200608:	10c00060 	cmpeqi	r3,r2,1
 820060c:	1800041e 	bne	r3,zero,8200620 <alt_uCOSIIErrorHandler+0x3d8>
 8200610:	00803a2e 	bgeu	zero,r2,82006fc <alt_uCOSIIErrorHandler+0x4b4>
 8200614:	108000a0 	cmpeqi	r2,r2,2
 8200618:	10001c1e 	bne	r2,zero,820068c <alt_uCOSIIErrorHandler+0x444>
 820061c:	00005106 	br	8200764 <alt_uCOSIIErrorHandler+0x51c>
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is TASK).");
 8200620:	01020974 	movhi	r4,2085
 8200624:	2130b704 	addi	r4,r4,-15652
 8200628:	820331c0 	call	820331c <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is TASK");
 820062c:	d0a00217 	ldw	r2,-32760(gp)
 8200630:	10800317 	ldw	r2,12(r2)
 8200634:	100f883a 	mov	r7,r2
 8200638:	01800904 	movi	r6,36
 820063c:	01400044 	movi	r5,1
 8200640:	01020974 	movhi	r4,2085
 8200644:	2130c404 	addi	r4,r4,-15600
 8200648:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Task is being deleted.\n");
 820064c:	d0a00217 	ldw	r2,-32760(gp)
 8200650:	10800317 	ldw	r2,12(r2)
 8200654:	100f883a 	mov	r7,r2
 8200658:	01800a04 	movi	r6,40
 820065c:	01400044 	movi	r5,1
 8200660:	01020974 	movhi	r4,2085
 8200664:	2130ce04 	addi	r4,r4,-15560
 8200668:	8202d600 	call	8202d60 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 820066c:	82155f80 	call	82155f8 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 8200670:	01003fc4 	movi	r4,255
 8200674:	821af500 	call	821af50 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 8200678:	e0bffe03 	ldbu	r2,-8(fp)
 820067c:	000b883a 	mov	r5,zero
 8200680:	1009883a 	mov	r4,r2
 8200684:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
         break;
 8200688:	00004106 	br	8200790 <alt_uCOSIIErrorHandler+0x548>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 820068c:	01020974 	movhi	r4,2085
 8200690:	2130d904 	addi	r4,r4,-15516
 8200694:	820331c0 	call	820331c <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is SYSTEM");
 8200698:	d0a00217 	ldw	r2,-32760(gp)
 820069c:	10800317 	ldw	r2,12(r2)
 82006a0:	100f883a 	mov	r7,r2
 82006a4:	01800984 	movi	r6,38
 82006a8:	01400044 	movi	r5,1
 82006ac:	01020974 	movhi	r4,2085
 82006b0:	2130e704 	addi	r4,r4,-15460
 82006b4:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: FATAL Error, Restart required.");
 82006b8:	d0a00217 	ldw	r2,-32760(gp)
 82006bc:	10800317 	ldw	r2,12(r2)
 82006c0:	100f883a 	mov	r7,r2
 82006c4:	01800bc4 	movi	r6,47
 82006c8:	01400044 	movi	r5,1
 82006cc:	01020974 	movhi	r4,2085
 82006d0:	2130f104 	addi	r4,r4,-15420
 82006d4:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Locking scheduler - endless loop.\n");
 82006d8:	d0a00217 	ldw	r2,-32760(gp)
 82006dc:	10800317 	ldw	r2,12(r2)
 82006e0:	100f883a 	mov	r7,r2
 82006e4:	01800cc4 	movi	r6,51
 82006e8:	01400044 	movi	r5,1
 82006ec:	01020974 	movhi	r4,2085
 82006f0:	2130fd04 	addi	r4,r4,-15372
 82006f4:	8202d600 	call	8202d60 <fwrite>
         while(1); /* Since scheduler is locked,loop halts all task activity.*/
 82006f8:	003fff06 	br	82006f8 <alt_uCOSIIErrorHandler+0x4b0>
         break;
      case NONE:
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is NONE");
 82006fc:	d0a00217 	ldw	r2,-32760(gp)
 8200700:	10800317 	ldw	r2,12(r2)
 8200704:	100f883a 	mov	r7,r2
 8200708:	01800904 	movi	r6,36
 820070c:	01400044 	movi	r5,1
 8200710:	01020974 	movhi	r4,2085
 8200714:	21310a04 	addi	r4,r4,-15320
 8200718:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Informational error only, control"); 
 820071c:	d0a00217 	ldw	r2,-32760(gp)
 8200720:	10800317 	ldw	r2,12(r2)
 8200724:	100f883a 	mov	r7,r2
 8200728:	01800c84 	movi	r6,50
 820072c:	01400044 	movi	r5,1
 8200730:	01020974 	movhi	r4,2085
 8200734:	21311404 	addi	r4,r4,-15280
 8200738:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, 
 820073c:	d0a00217 	ldw	r2,-32760(gp)
 8200740:	10800317 	ldw	r2,12(r2)
 8200744:	100f883a 	mov	r7,r2
 8200748:	01800f84 	movi	r6,62
 820074c:	01400044 	movi	r5,1
 8200750:	01020974 	movhi	r4,2085
 8200754:	21312104 	addi	r4,r4,-15228
 8200758:	8202d600 	call	8202d60 <fwrite>
            "returned to task to complete processing at application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */
 820075c:	82155f80 	call	82155f8 <OSSchedUnlock>
         return;   
 8200760:	00000d06 	br	8200798 <alt_uCOSIIErrorHandler+0x550>
         break;      
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
 8200764:	01020974 	movhi	r4,2085
 8200768:	21313104 	addi	r4,r4,-15164
 820076c:	82035a00 	call	82035a0 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
 8200770:	d0a00217 	ldw	r2,-32760(gp)
 8200774:	10800317 	ldw	r2,12(r2)
 8200778:	100f883a 	mov	r7,r2
 820077c:	01800ac4 	movi	r6,43
 8200780:	01400044 	movi	r5,1
 8200784:	01020974 	movhi	r4,2085
 8200788:	21313f04 	addi	r4,r4,-15108
 820078c:	8202d600 	call	8202d60 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 8200790:	003fff06 	br	8200790 <alt_uCOSIIErrorHandler+0x548>
{
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
   {
      return;
 8200794:	0001883a 	nop
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 8200798:	e037883a 	mov	sp,fp
 820079c:	dfc00117 	ldw	ra,4(sp)
 82007a0:	df000017 	ldw	fp,0(sp)
 82007a4:	dec00204 	addi	sp,sp,8
 82007a8:	f800283a 	ret

082007ac <alt_NetworkErrorHandler>:

void alt_NetworkErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 82007ac:	defffb04 	addi	sp,sp,-20
 82007b0:	dfc00415 	stw	ra,16(sp)
 82007b4:	df000315 	stw	fp,12(sp)
 82007b8:	df000304 	addi	fp,sp,12
 82007bc:	2005883a 	mov	r2,r4
 82007c0:	e17fff15 	stw	r5,-4(fp)
 82007c4:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
 82007c8:	e0bffe03 	ldbu	r2,-8(fp)
 82007cc:	10008a26 	beq	r2,zero,82009f8 <alt_NetworkErrorHandler+0x24c>
   {
      return;
   }

   fault_level = SYSTEM;   
 82007d0:	00800084 	movi	r2,2
 82007d4:	e0bffd15 	stw	r2,-12(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */  
 82007d8:	821556c0 	call	821556c <OSSchedLock>

   if (error_code == EXPANDED_DIAGNOSIS_CODE) 
 82007dc:	e0bffe03 	ldbu	r2,-8(fp)
 82007e0:	10803fd8 	cmpnei	r2,r2,255
 82007e4:	1000101e 	bne	r2,zero,8200828 <alt_NetworkErrorHandler+0x7c>
   {
      fault_level = SYSTEM;
 82007e8:	00800084 	movi	r2,2
 82007ec:	e0bffd15 	stw	r2,-12(fp)
      printf("\n[Network]: See STDERR for expanded diagnosis translation.");    
 82007f0:	01020974 	movhi	r4,2085
 82007f4:	21314a04 	addi	r4,r4,-15064
 82007f8:	820331c0 	call	820331c <printf>
      fprintf(stderr, "\n[Network]: %s", (char *)expanded_diagnosis_ptr);
 82007fc:	d0a00217 	ldw	r2,-32760(gp)
 8200800:	10800317 	ldw	r2,12(r2)
 8200804:	e1bfff17 	ldw	r6,-4(fp)
 8200808:	01420974 	movhi	r5,2085
 820080c:	29715904 	addi	r5,r5,-15004
 8200810:	1009883a 	mov	r4,r2
 8200814:	8202c700 	call	8202c70 <fprintf>
      /* Check errno also in case it has been set. */
      perror("\n[Network]:  ERRNO: ");
 8200818:	01020974 	movhi	r4,2085
 820081c:	21315d04 	addi	r4,r4,-14988
 8200820:	82032d80 	call	82032d8 <perror>
 8200824:	00001006 	br	8200868 <alt_NetworkErrorHandler+0xbc>
   }
   else 
   {
      fault_level = TASK;
 8200828:	00800044 	movi	r2,1
 820082c:	e0bffd15 	stw	r2,-12(fp)
      printf("\n[Network]: See STDERR.\n");    
 8200830:	01020974 	movhi	r4,2085
 8200834:	21316304 	addi	r4,r4,-14964
 8200838:	82035a00 	call	82035a0 <puts>
      fprintf(stderr, "\n[Network]: Error_code %d!\n", error_code);        
 820083c:	d0a00217 	ldw	r2,-32760(gp)
 8200840:	10800317 	ldw	r2,12(r2)
 8200844:	e0fffe03 	ldbu	r3,-8(fp)
 8200848:	180d883a 	mov	r6,r3
 820084c:	01420974 	movhi	r5,2085
 8200850:	29716904 	addi	r5,r5,-14940
 8200854:	1009883a 	mov	r4,r2
 8200858:	8202c700 	call	8202c70 <fprintf>
      perror("\n[Network]:  ERRNO: ");
 820085c:	01020974 	movhi	r4,2085
 8200860:	21315d04 	addi	r4,r4,-14988
 8200864:	82032d80 	call	82032d8 <perror>
   }

   /* Process error based on fault level, reenable scheduler if appropriate. */     
   switch (fault_level) 
 8200868:	e0bffd17 	ldw	r2,-12(fp)
 820086c:	10c00060 	cmpeqi	r3,r2,1
 8200870:	1800041e 	bne	r3,zero,8200884 <alt_NetworkErrorHandler+0xd8>
 8200874:	00803a2e 	bgeu	zero,r2,8200960 <alt_NetworkErrorHandler+0x1b4>
 8200878:	108000a0 	cmpeqi	r2,r2,2
 820087c:	10001c1e 	bne	r2,zero,82008f0 <alt_NetworkErrorHandler+0x144>
 8200880:	00005106 	br	82009c8 <alt_NetworkErrorHandler+0x21c>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is TASK).");
 8200884:	01020974 	movhi	r4,2085
 8200888:	21317004 	addi	r4,r4,-14912
 820088c:	820331c0 	call	820331c <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is TASK");
 8200890:	d0a00217 	ldw	r2,-32760(gp)
 8200894:	10800317 	ldw	r2,12(r2)
 8200898:	100f883a 	mov	r7,r2
 820089c:	018007c4 	movi	r6,31
 82008a0:	01400044 	movi	r5,1
 82008a4:	01020974 	movhi	r4,2085
 82008a8:	21317c04 	addi	r4,r4,-14864
 82008ac:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, "\n[Network]: Task is being deleted.\n");
 82008b0:	d0a00217 	ldw	r2,-32760(gp)
 82008b4:	10800317 	ldw	r2,12(r2)
 82008b8:	100f883a 	mov	r7,r2
 82008bc:	018008c4 	movi	r6,35
 82008c0:	01400044 	movi	r5,1
 82008c4:	01020974 	movhi	r4,2085
 82008c8:	21318404 	addi	r4,r4,-14832
 82008cc:	8202d600 	call	8202d60 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 82008d0:	82155f80 	call	82155f8 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 82008d4:	01003fc4 	movi	r4,255
 82008d8:	821af500 	call	821af50 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 82008dc:	e0bffe03 	ldbu	r2,-8(fp)
 82008e0:	000b883a 	mov	r5,zero
 82008e4:	1009883a 	mov	r4,r2
 82008e8:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
         break;
 82008ec:	00004106 	br	82009f4 <alt_NetworkErrorHandler+0x248>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 82008f0:	01020974 	movhi	r4,2085
 82008f4:	21318d04 	addi	r4,r4,-14796
 82008f8:	820331c0 	call	820331c <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is SYSTEM.");
 82008fc:	d0a00217 	ldw	r2,-32760(gp)
 8200900:	10800317 	ldw	r2,12(r2)
 8200904:	100f883a 	mov	r7,r2
 8200908:	01800884 	movi	r6,34
 820090c:	01400044 	movi	r5,1
 8200910:	01020974 	movhi	r4,2085
 8200914:	21319904 	addi	r4,r4,-14748
 8200918:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, "\n[Network]: FATAL Error, Restart required.");
 820091c:	d0a00217 	ldw	r2,-32760(gp)
 8200920:	10800317 	ldw	r2,12(r2)
 8200924:	100f883a 	mov	r7,r2
 8200928:	01800a84 	movi	r6,42
 820092c:	01400044 	movi	r5,1
 8200930:	01020974 	movhi	r4,2085
 8200934:	2131a204 	addi	r4,r4,-14712
 8200938:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, "\n[Network]: Locking scheduler - endless loop.\n");
 820093c:	d0a00217 	ldw	r2,-32760(gp)
 8200940:	10800317 	ldw	r2,12(r2)
 8200944:	100f883a 	mov	r7,r2
 8200948:	01800b84 	movi	r6,46
 820094c:	01400044 	movi	r5,1
 8200950:	01020974 	movhi	r4,2085
 8200954:	2131ad04 	addi	r4,r4,-14668
 8200958:	8202d600 	call	8202d60 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 820095c:	003fff06 	br	820095c <alt_NetworkErrorHandler+0x1b0>
         break;
      case NONE:
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is NONE.");
 8200960:	d0a00217 	ldw	r2,-32760(gp)
 8200964:	10800317 	ldw	r2,12(r2)
 8200968:	100f883a 	mov	r7,r2
 820096c:	01800804 	movi	r6,32
 8200970:	01400044 	movi	r5,1
 8200974:	01020974 	movhi	r4,2085
 8200978:	2131b904 	addi	r4,r4,-14620
 820097c:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, "\n[Network]: Informational "
 8200980:	d0a00217 	ldw	r2,-32760(gp)
 8200984:	10800317 	ldw	r2,12(r2)
 8200988:	100f883a 	mov	r7,r2
 820098c:	01800d84 	movi	r6,54
 8200990:	01400044 	movi	r5,1
 8200994:	01020974 	movhi	r4,2085
 8200998:	2131c204 	addi	r4,r4,-14584
 820099c:	8202d600 	call	8202d60 <fwrite>
                         "error only, control returned");
         fprintf(stderr, 
 82009a0:	d0a00217 	ldw	r2,-32760(gp)
 82009a4:	10800317 	ldw	r2,12(r2)
 82009a8:	100f883a 	mov	r7,r2
 82009ac:	01800e44 	movi	r6,57
 82009b0:	01400044 	movi	r5,1
 82009b4:	01020974 	movhi	r4,2085
 82009b8:	2131d004 	addi	r4,r4,-14528
 82009bc:	8202d600 	call	8202d60 <fwrite>
            "to task to complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 82009c0:	82155f80 	call	82155f8 <OSSchedUnlock>
         return;
 82009c4:	00000d06 	br	82009fc <alt_NetworkErrorHandler+0x250>
         break;         
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
 82009c8:	01020974 	movhi	r4,2085
 82009cc:	2131df04 	addi	r4,r4,-14468
 82009d0:	82035a00 	call	82035a0 <puts>
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
 82009d4:	d0a00217 	ldw	r2,-32760(gp)
 82009d8:	10800317 	ldw	r2,12(r2)
 82009dc:	100f883a 	mov	r7,r2
 82009e0:	01800984 	movi	r6,38
 82009e4:	01400044 	movi	r5,1
 82009e8:	01020974 	movhi	r4,2085
 82009ec:	2131ec04 	addi	r4,r4,-14416
 82009f0:	8202d600 	call	8202d60 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 82009f4:	003fff06 	br	82009f4 <alt_NetworkErrorHandler+0x248>
{
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
   {
      return;
 82009f8:	0001883a 	nop
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 82009fc:	e037883a 	mov	sp,fp
 8200a00:	dfc00117 	ldw	ra,4(sp)
 8200a04:	df000017 	ldw	fp,0(sp)
 8200a08:	dec00204 	addi	sp,sp,8
 8200a0c:	f800283a 	ret

08200a10 <alt_SSSErrorHandler>:
   
   
void alt_SSSErrorHandler(INT8U error_code, 
                         void *expanded_diagnosis_ptr)
{
 8200a10:	defffb04 	addi	sp,sp,-20
 8200a14:	dfc00415 	stw	ra,16(sp)
 8200a18:	df000315 	stw	fp,12(sp)
 8200a1c:	df000304 	addi	fp,sp,12
 8200a20:	2005883a 	mov	r2,r4
 8200a24:	e17fff15 	stw	r5,-4(fp)
 8200a28:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
 8200a2c:	e0bffe03 	ldbu	r2,-8(fp)
 8200a30:	10009726 	beq	r2,zero,8200c90 <alt_SSSErrorHandler+0x280>
   {
      return;
   }

   fault_level = (error_code == OS_NO_ERR) ? NONE : SYSTEM;
 8200a34:	e0bffe03 	ldbu	r2,-8(fp)
 8200a38:	1000021e 	bne	r2,zero,8200a44 <alt_SSSErrorHandler+0x34>
 8200a3c:	0005883a 	mov	r2,zero
 8200a40:	00000106 	br	8200a48 <alt_SSSErrorHandler+0x38>
 8200a44:	00800084 	movi	r2,2
 8200a48:	e0bffd15 	stw	r2,-12(fp)
   
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 8200a4c:	821556c0 	call	821556c <OSSchedLock>
   switch (error_code)
 8200a50:	e0bffe03 	ldbu	r2,-8(fp)
 8200a54:	10c007a0 	cmpeqi	r3,r2,30
 8200a58:	18000f1e 	bne	r3,zero,8200a98 <alt_SSSErrorHandler+0x88>
 8200a5c:	10803fe0 	cmpeqi	r2,r2,255
 8200a60:	10001726 	beq	r2,zero,8200ac0 <alt_SSSErrorHandler+0xb0>
   {
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 8200a64:	00800084 	movi	r2,2
 8200a68:	e0bffd15 	stw	r2,-12(fp)
         printf("\n[SSS]: See STDERR for expanded diagnosis translation.");    
 8200a6c:	01020974 	movhi	r4,2085
 8200a70:	2131f604 	addi	r4,r4,-14376
 8200a74:	820331c0 	call	820331c <printf>
         fprintf(stderr, "\n[SSS]: %s", (char *)expanded_diagnosis_ptr);
 8200a78:	d0a00217 	ldw	r2,-32760(gp)
 8200a7c:	10800317 	ldw	r2,12(r2)
 8200a80:	e1bfff17 	ldw	r6,-4(fp)
 8200a84:	01420974 	movhi	r5,2085
 8200a88:	29720404 	addi	r5,r5,-14320
 8200a8c:	1009883a 	mov	r4,r2
 8200a90:	8202c700 	call	8202c70 <fprintf>
         break;
 8200a94:	00001a06 	br	8200b00 <alt_SSSErrorHandler+0xf0>
         
      case OS_Q_FULL:
         fault_level = NONE;
 8200a98:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr,"\n[SSS]: Attempted to post to a full message queue.");
 8200a9c:	d0a00217 	ldw	r2,-32760(gp)
 8200aa0:	10800317 	ldw	r2,12(r2)
 8200aa4:	100f883a 	mov	r7,r2
 8200aa8:	01800c84 	movi	r6,50
 8200aac:	01400044 	movi	r5,1
 8200ab0:	01020974 	movhi	r4,2085
 8200ab4:	21320704 	addi	r4,r4,-14308
 8200ab8:	8202d600 	call	8202d60 <fwrite>
         break;
 8200abc:	00001006 	br	8200b00 <alt_SSSErrorHandler+0xf0>
      
      default:
         fault_level = SYSTEM;
 8200ac0:	00800084 	movi	r2,2
 8200ac4:	e0bffd15 	stw	r2,-12(fp)
         printf("\n[SSS]: See STDERR.\n");    
 8200ac8:	01020974 	movhi	r4,2085
 8200acc:	21321404 	addi	r4,r4,-14256
 8200ad0:	82035a00 	call	82035a0 <puts>
         fprintf(stderr, "\n[SSS]: Error_code %d!", error_code);        
 8200ad4:	d0a00217 	ldw	r2,-32760(gp)
 8200ad8:	10800317 	ldw	r2,12(r2)
 8200adc:	e0fffe03 	ldbu	r3,-8(fp)
 8200ae0:	180d883a 	mov	r6,r3
 8200ae4:	01420974 	movhi	r5,2085
 8200ae8:	29721904 	addi	r5,r5,-14236
 8200aec:	1009883a 	mov	r4,r2
 8200af0:	8202c700 	call	8202c70 <fprintf>
         perror("\n[SSS]:  ERRNO: ");
 8200af4:	01020974 	movhi	r4,2085
 8200af8:	21321f04 	addi	r4,r4,-14212
 8200afc:	82032d80 	call	82032d8 <perror>
   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */     
   switch (fault_level) 
 8200b00:	e0bffd17 	ldw	r2,-12(fp)
 8200b04:	10c00060 	cmpeqi	r3,r2,1
 8200b08:	1800041e 	bne	r3,zero,8200b1c <alt_SSSErrorHandler+0x10c>
 8200b0c:	00803a2e 	bgeu	zero,r2,8200bf8 <alt_SSSErrorHandler+0x1e8>
 8200b10:	108000a0 	cmpeqi	r2,r2,2
 8200b14:	10001c1e 	bne	r2,zero,8200b88 <alt_SSSErrorHandler+0x178>
 8200b18:	00005106 	br	8200c60 <alt_SSSErrorHandler+0x250>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is TASK).");
 8200b1c:	01020974 	movhi	r4,2085
 8200b20:	21322404 	addi	r4,r4,-14192
 8200b24:	820331c0 	call	820331c <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is TASK");
 8200b28:	d0a00217 	ldw	r2,-32760(gp)
 8200b2c:	10800317 	ldw	r2,12(r2)
 8200b30:	100f883a 	mov	r7,r2
 8200b34:	018006c4 	movi	r6,27
 8200b38:	01400044 	movi	r5,1
 8200b3c:	01020974 	movhi	r4,2085
 8200b40:	21322f04 	addi	r4,r4,-14148
 8200b44:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, "\n[SSS]: Task is being deleted.\n");
 8200b48:	d0a00217 	ldw	r2,-32760(gp)
 8200b4c:	10800317 	ldw	r2,12(r2)
 8200b50:	100f883a 	mov	r7,r2
 8200b54:	018007c4 	movi	r6,31
 8200b58:	01400044 	movi	r5,1
 8200b5c:	01020974 	movhi	r4,2085
 8200b60:	21323604 	addi	r4,r4,-14120
 8200b64:	8202d600 	call	8202d60 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 8200b68:	82155f80 	call	82155f8 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 8200b6c:	01003fc4 	movi	r4,255
 8200b70:	821af500 	call	821af50 <OSTaskDel>
         /* Invoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 8200b74:	e0bffe03 	ldbu	r2,-8(fp)
 8200b78:	000b883a 	mov	r5,zero
 8200b7c:	1009883a 	mov	r4,r2
 8200b80:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
         break;
 8200b84:	00004106 	br	8200c8c <alt_SSSErrorHandler+0x27c>
      case SYSTEM:
          /* Total System Failure, Restart Required */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 8200b88:	01020974 	movhi	r4,2085
 8200b8c:	21323e04 	addi	r4,r4,-14088
 8200b90:	820331c0 	call	820331c <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is SYSTEM.");
 8200b94:	d0a00217 	ldw	r2,-32760(gp)
 8200b98:	10800317 	ldw	r2,12(r2)
 8200b9c:	100f883a 	mov	r7,r2
 8200ba0:	01800784 	movi	r6,30
 8200ba4:	01400044 	movi	r5,1
 8200ba8:	01020974 	movhi	r4,2085
 8200bac:	21324904 	addi	r4,r4,-14044
 8200bb0:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, "\n[SSS]: FATAL Error, Restart required.");
 8200bb4:	d0a00217 	ldw	r2,-32760(gp)
 8200bb8:	10800317 	ldw	r2,12(r2)
 8200bbc:	100f883a 	mov	r7,r2
 8200bc0:	01800984 	movi	r6,38
 8200bc4:	01400044 	movi	r5,1
 8200bc8:	01020974 	movhi	r4,2085
 8200bcc:	21325104 	addi	r4,r4,-14012
 8200bd0:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, "\n[SSS]: Locking scheduler - endless loop.\n");
 8200bd4:	d0a00217 	ldw	r2,-32760(gp)
 8200bd8:	10800317 	ldw	r2,12(r2)
 8200bdc:	100f883a 	mov	r7,r2
 8200be0:	01800a84 	movi	r6,42
 8200be4:	01400044 	movi	r5,1
 8200be8:	01020974 	movhi	r4,2085
 8200bec:	21325b04 	addi	r4,r4,-13972
 8200bf0:	8202d600 	call	8202d60 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 8200bf4:	003fff06 	br	8200bf4 <alt_SSSErrorHandler+0x1e4>
         break;
      case NONE:
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is NONE.");
 8200bf8:	d0a00217 	ldw	r2,-32760(gp)
 8200bfc:	10800317 	ldw	r2,12(r2)
 8200c00:	100f883a 	mov	r7,r2
 8200c04:	018006c4 	movi	r6,27
 8200c08:	01400044 	movi	r5,1
 8200c0c:	01020974 	movhi	r4,2085
 8200c10:	21326604 	addi	r4,r4,-13928
 8200c14:	8202d600 	call	8202d60 <fwrite>
         fprintf(stderr, 
 8200c18:	d0a00217 	ldw	r2,-32760(gp)
 8200c1c:	10800317 	ldw	r2,12(r2)
 8200c20:	100f883a 	mov	r7,r2
 8200c24:	01800f44 	movi	r6,61
 8200c28:	01400044 	movi	r5,1
 8200c2c:	01020974 	movhi	r4,2085
 8200c30:	21326d04 	addi	r4,r4,-13900
 8200c34:	8202d600 	call	8202d60 <fwrite>
            "\n[SSS] Informational error only, control returned to task to ");
         fprintf(stderr,
 8200c38:	d0a00217 	ldw	r2,-32760(gp)
 8200c3c:	10800317 	ldw	r2,12(r2)
 8200c40:	100f883a 	mov	r7,r2
 8200c44:	01800b84 	movi	r6,46
 8200c48:	01400044 	movi	r5,1
 8200c4c:	01020974 	movhi	r4,2085
 8200c50:	21327d04 	addi	r4,r4,-13836
 8200c54:	8202d600 	call	8202d60 <fwrite>
            "complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 8200c58:	82155f80 	call	82155f8 <OSSchedUnlock>
         return;         
 8200c5c:	00000d06 	br	8200c94 <alt_SSSErrorHandler+0x284>
         break;
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
 8200c60:	01020974 	movhi	r4,2085
 8200c64:	21328904 	addi	r4,r4,-13788
 8200c68:	82035a00 	call	82035a0 <puts>
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
 8200c6c:	d0a00217 	ldw	r2,-32760(gp)
 8200c70:	10800317 	ldw	r2,12(r2)
 8200c74:	100f883a 	mov	r7,r2
 8200c78:	01800844 	movi	r6,33
 8200c7c:	01400044 	movi	r5,1
 8200c80:	01020974 	movhi	r4,2085
 8200c84:	21329504 	addi	r4,r4,-13740
 8200c88:	8202d600 	call	8202d60 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 8200c8c:	003fff06 	br	8200c8c <alt_SSSErrorHandler+0x27c>
{
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
   {
      return;
 8200c90:	0001883a 	nop
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 8200c94:	e037883a 	mov	sp,fp
 8200c98:	dfc00117 	ldw	ra,4(sp)
 8200c9c:	df000017 	ldw	fp,0(sp)
 8200ca0:	dec00204 	addi	sp,sp,8
 8200ca4:	f800283a 	ret

08200ca8 <SSSInitialTask>:
/* SSSInitialTask will initialize the NicheStack
 * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
 * RTOS structures and tasks. 
 */
void SSSInitialTask(void *task_data)
{
 8200ca8:	defffc04 	addi	sp,sp,-16
 8200cac:	dfc00315 	stw	ra,12(sp)
 8200cb0:	df000215 	stw	fp,8(sp)
 8200cb4:	df000204 	addi	fp,sp,8
 8200cb8:	e13fff15 	stw	r4,-4(fp)
   * NicheStack is initialized from a task, so that RTOS will have started, and 
   * I/O drivers are available.  Two tasks are created:
   *    "Inet main"  task with priority 2
   *    "clock tick" task with priority 3
   */   
  alt_iniche_init();
 8200cbc:	822db600 	call	822db60 <alt_iniche_init>
  netmain(); 
 8200cc0:	82291940 	call	8229194 <netmain>

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 8200cc4:	00000206 	br	8200cd0 <SSSInitialTask+0x28>
    TK_SLEEP(1);
 8200cc8:	01000084 	movi	r4,2
 8200ccc:	821be3c0 	call	821be3c <OSTimeDly>
  netmain(); 

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 8200cd0:	d0a08c17 	ldw	r2,-32208(gp)
 8200cd4:	103ffc26 	beq	r2,zero,8200cc8 <SSSInitialTask+0x20>

  /* Now that the stack is running, perform the application initialization steps */
  
  /* Application Specific Task Launching Code Block Begin */

  printf("\nSimple Socket Server starting up\n");
 8200cd8:	01020974 	movhi	r4,2085
 8200cdc:	2132a404 	addi	r4,r4,-13680
 8200ce0:	82035a00 	call	82035a0 <puts>

  /* Create the main simple socket server task. */
  TK_NEWTASK(&ssstask);
 8200ce4:	01020974 	movhi	r4,2085
 8200ce8:	2107bb04 	addi	r4,r4,7916
 8200cec:	822d7dc0 	call	822d7dc <TK_NEWTASK>
  
  /*create os data structures */
  SSSCreateOSDataStructs(); 
 8200cf0:	82018d80 	call	82018d8 <SSSCreateOSDataStructs>

  /* create the other tasks */
  SSSCreateTasks();
 8200cf4:	820197c0 	call	820197c <SSSCreateTasks>

  /* Application Specific Task Launching Code Block End */
  
  /*This task is deleted because there is no need for it to run again */
  error_code = OSTaskDel(OS_PRIO_SELF);
 8200cf8:	01003fc4 	movi	r4,255
 8200cfc:	821af500 	call	821af50 <OSTaskDel>
 8200d00:	e0bffe05 	stb	r2,-8(fp)
  alt_uCOSIIErrorHandler(error_code, 0);
 8200d04:	e0bffe03 	ldbu	r2,-8(fp)
 8200d08:	000b883a 	mov	r5,zero
 8200d0c:	1009883a 	mov	r4,r2
 8200d10:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  
  while (1); /* Correct Program Flow should never get here */
 8200d14:	003fff06 	br	8200d14 <SSSInitialTask+0x6c>

08200d18 <main>:

/* Main creates a single task, SSSInitialTask, and starts task scheduler.
 */

int main (int argc, char* argv[], char* envp[])
{
 8200d18:	defff504 	addi	sp,sp,-44
 8200d1c:	dfc00a15 	stw	ra,40(sp)
 8200d20:	df000915 	stw	fp,36(sp)
 8200d24:	df000904 	addi	fp,sp,36
 8200d28:	e13ffd15 	stw	r4,-12(fp)
 8200d2c:	e17ffe15 	stw	r5,-8(fp)
 8200d30:	e1bfff15 	stw	r6,-4(fp)
  
  INT8U error_code;

  /* Clear the RTOS timer */
  OSTimeSet(0);
 8200d34:	0009883a 	mov	r4,zero
 8200d38:	821c2c80 	call	821c2c8 <OSTimeSet>

  /* SSSInitialTask will initialize the NicheStack
   * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
   * RTOS structures and tasks. 
   */  
  error_code = OSTaskCreateExt(SSSInitialTask,
 8200d3c:	d8000415 	stw	zero,16(sp)
 8200d40:	d8000315 	stw	zero,12(sp)
 8200d44:	00820004 	movi	r2,2048
 8200d48:	d8800215 	stw	r2,8(sp)
 8200d4c:	00820974 	movhi	r2,2085
 8200d50:	10922004 	addi	r2,r2,18560
 8200d54:	d8800115 	stw	r2,4(sp)
 8200d58:	00800144 	movi	r2,5
 8200d5c:	d8800015 	stw	r2,0(sp)
 8200d60:	01c00144 	movi	r7,5
 8200d64:	01820974 	movhi	r6,2085
 8200d68:	319a2004 	addi	r6,r6,26752
 8200d6c:	000b883a 	mov	r5,zero
 8200d70:	01020834 	movhi	r4,2080
 8200d74:	21032a04 	addi	r4,r4,3240
 8200d78:	821ad6c0 	call	821ad6c <OSTaskCreateExt>
 8200d7c:	e0bffc05 	stb	r2,-16(fp)
                             SSS_INITIAL_TASK_PRIORITY,
                             SSSInitialTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
  alt_uCOSIIErrorHandler(error_code, 0);
 8200d80:	e0bffc03 	ldbu	r2,-16(fp)
 8200d84:	000b883a 	mov	r5,zero
 8200d88:	1009883a 	mov	r4,r2
 8200d8c:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>

  /*
   * As with all MicroC/OS-II designs, once the initial thread(s) and 
   * associated RTOS resources are declared, we start the RTOS. That's it!
   */
  OSStart();
 8200d90:	82156d40 	call	82156d4 <OSStart>

  
  while(1); /* Correct Program Flow never gets here. */
 8200d94:	003fff06 	br	8200d94 <main+0x7c>

08200d98 <led_bit_toggle>:
 * Development Board which controls 8 LEDs, D0 - D7.
 * 
 */
 
void led_bit_toggle(OS_FLAGS bit)
{
 8200d98:	defffc04 	addi	sp,sp,-16
 8200d9c:	dfc00315 	stw	ra,12(sp)
 8200da0:	df000215 	stw	fp,8(sp)
 8200da4:	df000204 	addi	fp,sp,8
 8200da8:	2005883a 	mov	r2,r4
 8200dac:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS  led_8_val;
    INT8U error_code;
    
    led_8_val = OSFlagQuery(SSSLEDEventFlag, &error_code);
 8200db0:	d0a05c17 	ldw	r2,-32400(gp)
 8200db4:	e0fffe84 	addi	r3,fp,-6
 8200db8:	180b883a 	mov	r5,r3
 8200dbc:	1009883a 	mov	r4,r2
 8200dc0:	8217f7c0 	call	8217f7c <OSFlagQuery>
 8200dc4:	e0bffe0d 	sth	r2,-8(fp)
    alt_uCOSIIErrorHandler(error_code, 0);
 8200dc8:	e0bffe83 	ldbu	r2,-6(fp)
 8200dcc:	10803fcc 	andi	r2,r2,255
 8200dd0:	000b883a 	mov	r5,zero
 8200dd4:	1009883a 	mov	r4,r2
 8200dd8:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
    if (bit & led_8_val)
 8200ddc:	e0ffff0b 	ldhu	r3,-4(fp)
 8200de0:	e0bffe0b 	ldhu	r2,-8(fp)
 8200de4:	1884703a 	and	r2,r3,r2
 8200de8:	10bfffcc 	andi	r2,r2,65535
 8200dec:	10000f26 	beq	r2,zero,8200e2c <led_bit_toggle+0x94>
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_CLR, &error_code);
 8200df0:	d0a05c17 	ldw	r2,-32400(gp)
 8200df4:	e0ffff0b 	ldhu	r3,-4(fp)
 8200df8:	e13ffe84 	addi	r4,fp,-6
 8200dfc:	200f883a 	mov	r7,r4
 8200e00:	000d883a 	mov	r6,zero
 8200e04:	180b883a 	mov	r5,r3
 8200e08:	1009883a 	mov	r4,r2
 8200e0c:	8217be80 	call	8217be8 <OSFlagPost>
 8200e10:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 8200e14:	e0bffe83 	ldbu	r2,-6(fp)
 8200e18:	10803fcc 	andi	r2,r2,255
 8200e1c:	000b883a 	mov	r5,zero
 8200e20:	1009883a 	mov	r4,r2
 8200e24:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
    #ifdef LED_PIO_BASE
       IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, led_8_val);
       printf("Value for LED_PIO_BASE set to %d.\n", (INT8U)led_8_val);
    #endif
      
    return;
 8200e28:	00000f06 	br	8200e68 <led_bit_toggle+0xd0>
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_CLR, &error_code);
       alt_uCOSIIErrorHandler(error_code, 0);
    }
    else
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_SET, &error_code);
 8200e2c:	d0a05c17 	ldw	r2,-32400(gp)
 8200e30:	e0ffff0b 	ldhu	r3,-4(fp)
 8200e34:	e13ffe84 	addi	r4,fp,-6
 8200e38:	200f883a 	mov	r7,r4
 8200e3c:	01800044 	movi	r6,1
 8200e40:	180b883a 	mov	r5,r3
 8200e44:	1009883a 	mov	r4,r2
 8200e48:	8217be80 	call	8217be8 <OSFlagPost>
 8200e4c:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 8200e50:	e0bffe83 	ldbu	r2,-6(fp)
 8200e54:	10803fcc 	andi	r2,r2,255
 8200e58:	000b883a 	mov	r5,zero
 8200e5c:	1009883a 	mov	r4,r2
 8200e60:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
    #ifdef LED_PIO_BASE
       IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, led_8_val);
       printf("Value for LED_PIO_BASE set to %d.\n", (INT8U)led_8_val);
    #endif
      
    return;
 8200e64:	0001883a 	nop
}
 8200e68:	e037883a 	mov	sp,fp
 8200e6c:	dfc00117 	ldw	ra,4(sp)
 8200e70:	df000017 	ldw	fp,0(sp)
 8200e74:	dec00204 	addi	sp,sp,8
 8200e78:	f800283a 	ret

08200e7c <LED7SegLightshowTask>:
 * SSSLEDLightshowSem semaphore controlled in LEDManagementTask.
 * 
 */ 
 
void LED7SegLightshowTask()
{
 8200e7c:	defffd04 	addi	sp,sp,-12
 8200e80:	dfc00215 	stw	ra,8(sp)
 8200e84:	df000115 	stw	fp,4(sp)
 8200e88:	df000104 	addi	fp,sp,4
   {
    
      /* Wait 50 milliseconds between pattern updates, to make the pattern slow
       * enough for the human eye, and more impotantly, to give up control so
       * MicroC/OS-II can schedule other lower priority tasks. */ 
      OSTimeDlyHMSM(0,0,0,50);
 8200e8c:	01c00c84 	movi	r7,50
 8200e90:	000d883a 	mov	r6,zero
 8200e94:	000b883a 	mov	r5,zero
 8200e98:	0009883a 	mov	r4,zero
 8200e9c:	821bf400 	call	821bf40 <OSTimeDlyHMSM>
      
      /* Check that we still have the SSSLEDLightshowSem semaphore. If we don't,
       * then wait until the LEDManagement task gives it back to us. */
      OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 8200ea0:	d0a05b17 	ldw	r2,-32404(gp)
 8200ea4:	e1bfff04 	addi	r6,fp,-4
 8200ea8:	000b883a 	mov	r5,zero
 8200eac:	1009883a 	mov	r4,r2
 8200eb0:	821a0380 	call	821a038 <OSSemPend>
      alt_uCOSIIErrorHandler(error_code, 0);
 8200eb4:	e0bfff03 	ldbu	r2,-4(fp)
 8200eb8:	10803fcc 	andi	r2,r2,255
 8200ebc:	000b883a 	mov	r5,zero
 8200ec0:	1009883a 	mov	r4,r2
 8200ec4:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
      #if SEVEN_SEG_PIO_BASE
         led_7_seg_val = rand();
         IOWR_ALTERA_AVALON_PIO_DATA(SEVEN_SEG_PIO_BASE, led_7_seg_val);
      #endif
      
      error_code = OSSemPost(SSSLEDLightshowSem);
 8200ec8:	d0a05b17 	ldw	r2,-32404(gp)
 8200ecc:	1009883a 	mov	r4,r2
 8200ed0:	821a3b00 	call	821a3b0 <OSSemPost>
 8200ed4:	e0bfff05 	stb	r2,-4(fp)
      alt_uCOSIIErrorHandler(error_code, 0);
 8200ed8:	e0bfff03 	ldbu	r2,-4(fp)
 8200edc:	10803fcc 	andi	r2,r2,255
 8200ee0:	000b883a 	mov	r5,zero
 8200ee4:	1009883a 	mov	r4,r2
 8200ee8:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
      
   }
 8200eec:	003fe706 	br	8200e8c <LED7SegLightshowTask+0x10>

08200ef0 <LEDManagementTask>:
 * The task will read the SSSLedCommandQ for an 
 * in-coming message command from the SSSSimpleSocketServerTask. 
 */
 
void LEDManagementTask()
{
 8200ef0:	defffb04 	addi	sp,sp,-20
 8200ef4:	dfc00415 	stw	ra,16(sp)
 8200ef8:	df000315 	stw	fp,12(sp)
 8200efc:	df000304 	addi	fp,sp,12
  
  INT32U led_command; 
  BOOLEAN SSSLEDLightshowActive;
  INT8U error_code;
  
  SSSLEDLightshowActive = OS_TRUE;
 8200f00:	00800044 	movi	r2,1
 8200f04:	e0bffd05 	stb	r2,-12(fp)
  
  while(1)
  {
    led_command = (INT32U)OSQPend(SSSLEDCommandQ, 0, &error_code);
 8200f08:	d0a05a17 	ldw	r2,-32408(gp)
 8200f0c:	e0ffff04 	addi	r3,fp,-4
 8200f10:	180d883a 	mov	r6,r3
 8200f14:	000b883a 	mov	r5,zero
 8200f18:	1009883a 	mov	r4,r2
 8200f1c:	82191900 	call	8219190 <OSQPend>
 8200f20:	e0bffe15 	stw	r2,-8(fp)
   
    alt_uCOSIIErrorHandler(error_code, 0);
 8200f24:	e0bfff03 	ldbu	r2,-4(fp)
 8200f28:	10803fcc 	andi	r2,r2,255
 8200f2c:	000b883a 	mov	r5,zero
 8200f30:	1009883a 	mov	r4,r2
 8200f34:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
        
    switch (led_command) {
 8200f38:	e0bffe17 	ldw	r2,-8(fp)
 8200f3c:	10bff404 	addi	r2,r2,-48
 8200f40:	10c00928 	cmpgeui	r3,r2,36
 8200f44:	18005d1e 	bne	r3,zero,82010bc <LEDManagementTask+0x1cc>
 8200f48:	100690ba 	slli	r3,r2,2
 8200f4c:	00820834 	movhi	r2,2080
 8200f50:	1083d804 	addi	r2,r2,3936
 8200f54:	1885883a 	add	r2,r3,r2
 8200f58:	10800017 	ldw	r2,0(r2)
 8200f5c:	1000683a 	jmp	r2
 8200f60:	08200ff0 	cmpltui	zero,at,32831
 8200f64:	08200ffc 	xorhi	zero,at,32831
 8200f68:	08201008 	cmpgei	zero,at,-32704
 8200f6c:	08201014 	ori	zero,at,32832
 8200f70:	08201020 	cmpeqi	zero,at,-32704
 8200f74:	0820102c 	andhi	zero,at,32832
 8200f78:	08201038 	rdprs	zero,at,-32704
 8200f7c:	08201044 	addi	zero,at,-32703
 8200f80:	082010bc 	xorhi	zero,at,32834
 8200f84:	082010bc 	xorhi	zero,at,32834
 8200f88:	082010bc 	xorhi	zero,at,32834
 8200f8c:	082010bc 	xorhi	zero,at,32834
 8200f90:	082010bc 	xorhi	zero,at,32834
 8200f94:	082010bc 	xorhi	zero,at,32834
 8200f98:	082010bc 	xorhi	zero,at,32834
 8200f9c:	082010bc 	xorhi	zero,at,32834
 8200fa0:	082010bc 	xorhi	zero,at,32834
 8200fa4:	082010bc 	xorhi	zero,at,32834
 8200fa8:	082010bc 	xorhi	zero,at,32834
 8200fac:	082010bc 	xorhi	zero,at,32834
 8200fb0:	082010bc 	xorhi	zero,at,32834
 8200fb4:	082010bc 	xorhi	zero,at,32834
 8200fb8:	082010bc 	xorhi	zero,at,32834
 8200fbc:	082010bc 	xorhi	zero,at,32834
 8200fc0:	082010bc 	xorhi	zero,at,32834
 8200fc4:	082010bc 	xorhi	zero,at,32834
 8200fc8:	082010bc 	xorhi	zero,at,32834
 8200fcc:	082010bc 	xorhi	zero,at,32834
 8200fd0:	082010bc 	xorhi	zero,at,32834
 8200fd4:	082010bc 	xorhi	zero,at,32834
 8200fd8:	082010bc 	xorhi	zero,at,32834
 8200fdc:	082010bc 	xorhi	zero,at,32834
 8200fe0:	082010bc 	xorhi	zero,at,32834
 8200fe4:	082010bc 	xorhi	zero,at,32834
 8200fe8:	082010bc 	xorhi	zero,at,32834
 8200fec:	08201050 	cmplti	zero,at,-32703
      case CMD_LEDS_BIT_0_TOGGLE:
         led_bit_toggle(BIT_0);
 8200ff0:	01000044 	movi	r4,1
 8200ff4:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8200ff8:	00003106 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_1_TOGGLE:
         led_bit_toggle(BIT_1);
 8200ffc:	01000084 	movi	r4,2
 8201000:	8200d980 	call	8200d98 <led_bit_toggle>
         break;   
 8201004:	00002e06 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_2_TOGGLE:
         led_bit_toggle(BIT_2);
 8201008:	01000104 	movi	r4,4
 820100c:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201010:	00002b06 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_3_TOGGLE:
         led_bit_toggle(BIT_3);
 8201014:	01000204 	movi	r4,8
 8201018:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 820101c:	00002806 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_4_TOGGLE:
         led_bit_toggle(BIT_4);
 8201020:	01000404 	movi	r4,16
 8201024:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201028:	00002506 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_5_TOGGLE:
         led_bit_toggle(BIT_5);
 820102c:	01000804 	movi	r4,32
 8201030:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201034:	00002206 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_6_TOGGLE:
         led_bit_toggle(BIT_6);
 8201038:	01001004 	movi	r4,64
 820103c:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 8201040:	00001f06 	br	82010c0 <LEDManagementTask+0x1d0>
      case CMD_LEDS_BIT_7_TOGGLE:
         led_bit_toggle(BIT_7);
 8201044:	01002004 	movi	r4,128
 8201048:	8200d980 	call	8200d98 <led_bit_toggle>
         break;
 820104c:	00001c06 	br	82010c0 <LEDManagementTask+0x1d0>
         /* The SSSLEDLightshowSem semaphore is checked by LED7SegLightshowTask 
          * each time it updates 7 segment LED displays, U8 and U9.  Grab the 
          * semaphore (pend) away from the lightshow task to toggle the lightshow off, 
          * and give up the semaphore (post) to turn the lightshow back on.  
          */
         if (SSSLEDLightshowActive == OS_FALSE)
 8201050:	e0bffd03 	ldbu	r2,-12(fp)
 8201054:	10000c1e 	bne	r2,zero,8201088 <LEDManagementTask+0x198>
         {
             error_code = OSSemPost(SSSLEDLightshowSem);
 8201058:	d0a05b17 	ldw	r2,-32404(gp)
 820105c:	1009883a 	mov	r4,r2
 8201060:	821a3b00 	call	821a3b0 <OSSemPost>
 8201064:	e0bfff05 	stb	r2,-4(fp)
             alt_uCOSIIErrorHandler(error_code, 0);
 8201068:	e0bfff03 	ldbu	r2,-4(fp)
 820106c:	10803fcc 	andi	r2,r2,255
 8201070:	000b883a 	mov	r5,zero
 8201074:	1009883a 	mov	r4,r2
 8201078:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_TRUE;
 820107c:	00800044 	movi	r2,1
 8201080:	e0bffd05 	stb	r2,-12(fp)
         {
             OSSemPend(SSSLEDLightshowSem, 0, &error_code);
             alt_uCOSIIErrorHandler(error_code, 0); 
             SSSLEDLightshowActive = OS_FALSE;
         }     
         break;
 8201084:	00000e06 	br	82010c0 <LEDManagementTask+0x1d0>
             alt_uCOSIIErrorHandler(error_code, 0);
             SSSLEDLightshowActive = OS_TRUE;
         }
         else
         {
             OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 8201088:	d0a05b17 	ldw	r2,-32404(gp)
 820108c:	e0ffff04 	addi	r3,fp,-4
 8201090:	180d883a 	mov	r6,r3
 8201094:	000b883a 	mov	r5,zero
 8201098:	1009883a 	mov	r4,r2
 820109c:	821a0380 	call	821a038 <OSSemPend>
             alt_uCOSIIErrorHandler(error_code, 0); 
 82010a0:	e0bfff03 	ldbu	r2,-4(fp)
 82010a4:	10803fcc 	andi	r2,r2,255
 82010a8:	000b883a 	mov	r5,zero
 82010ac:	1009883a 	mov	r4,r2
 82010b0:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_FALSE;
 82010b4:	e03ffd05 	stb	zero,-12(fp)
         }     
         break;
 82010b8:	00000106 	br	82010c0 <LEDManagementTask+0x1d0>
      default:     
        /* Discard unknown LED commands. */
        break;
 82010bc:	0001883a 	nop
    } /* switch led_command */
  } /* while(1) */
 82010c0:	003f9106 	br	8200f08 <LEDManagementTask+0x18>

082010c4 <get_mac_addr>:
* Read the MAC address in a board specific way. Prompt user to enter serial 
* number to generate MAC address if failed to read from flash.
*
*/
int get_mac_addr(NET net, unsigned char mac_addr[6])
{
 82010c4:	defffb04 	addi	sp,sp,-20
 82010c8:	dfc00415 	stw	ra,16(sp)
 82010cc:	df000315 	stw	fp,12(sp)
 82010d0:	df000304 	addi	fp,sp,12
 82010d4:	e13ffe15 	stw	r4,-8(fp)
 82010d8:	e17fff15 	stw	r5,-4(fp)
    error_t error = 0;
 82010dc:	e03ffd15 	stw	zero,-12(fp)
    
    error = get_board_mac_addr(mac_addr);
 82010e0:	e13fff17 	ldw	r4,-4(fp)
 82010e4:	82016140 	call	8201614 <get_board_mac_addr>
 82010e8:	e0bffd15 	stw	r2,-12(fp)
    
    if(error)
 82010ec:	e0bffd17 	ldw	r2,-12(fp)
 82010f0:	10000326 	beq	r2,zero,8201100 <get_mac_addr+0x3c>
    {
        /* Failed read MAC address from flash, prompt user to enter serial 
           number to generate MAC address. */
        error = generate_mac_addr(mac_addr);
 82010f4:	e13fff17 	ldw	r4,-4(fp)
 82010f8:	82014d80 	call	82014d8 <generate_mac_addr>
 82010fc:	e0bffd15 	stw	r2,-12(fp)
    }
    return error;
 8201100:	e0bffd17 	ldw	r2,-12(fp)
}
 8201104:	e037883a 	mov	sp,fp
 8201108:	dfc00117 	ldw	ra,4(sp)
 820110c:	df000017 	ldw	fp,0(sp)
 8201110:	dec00204 	addi	sp,sp,8
 8201114:	f800283a 	ret

08201118 <get_ip_addr>:
int get_ip_addr(alt_iniche_dev *p_dev,
                ip_addr* ipaddr,
                ip_addr* netmask,
                ip_addr* gw,
                int* use_dhcp)
{
 8201118:	defffb04 	addi	sp,sp,-20
 820111c:	df000415 	stw	fp,16(sp)
 8201120:	df000404 	addi	fp,sp,16
 8201124:	e13ffc15 	stw	r4,-16(fp)
 8201128:	e17ffd15 	stw	r5,-12(fp)
 820112c:	e1bffe15 	stw	r6,-8(fp)
 8201130:	e1ffff15 	stw	r7,-4(fp)

    IP4_ADDR(*ipaddr, IPADDR0, IPADDR1, IPADDR2, IPADDR3);
 8201134:	e0bffd17 	ldw	r2,-12(fp)
 8201138:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*gw, GWADDR0, GWADDR1, GWADDR2, GWADDR3);
 820113c:	e0bfff17 	ldw	r2,-4(fp)
 8201140:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*netmask, MSKADDR0, MSKADDR1, MSKADDR2, MSKADDR3);
 8201144:	e0fffe17 	ldw	r3,-8(fp)
 8201148:	00804034 	movhi	r2,256
 820114c:	10bfffc4 	addi	r2,r2,-1
 8201150:	18800015 	stw	r2,0(r3)

#ifdef DHCP_CLIENT
    *use_dhcp = 1;
 8201154:	e0800117 	ldw	r2,4(fp)
 8201158:	00c00044 	movi	r3,1
 820115c:	10c00015 	stw	r3,0(r2)
        ip4_addr4(*ipaddr));
#endif /* not DHCP_CLIENT */


    /* Non-standard API: return 1 for success */
    return 1;
 8201160:	00800044 	movi	r2,1
}
 8201164:	e037883a 	mov	sp,fp
 8201168:	df000017 	ldw	fp,0(sp)
 820116c:	dec00104 	addi	sp,sp,4
 8201170:	f800283a 	ret

08201174 <get_serial_number>:
*
* Prompt user to enter 9-digit serial number. 
*
*/
alt_u32 get_serial_number (void)
{
 8201174:	defff904 	addi	sp,sp,-28
 8201178:	dfc00615 	stw	ra,24(sp)
 820117c:	df000515 	stw	fp,20(sp)
 8201180:	df000504 	addi	fp,sp,20
    alt_u32 ser_num = 0;
 8201184:	e03ffb15 	stw	zero,-20(fp)
    char serial_number[9];
    int i = 0;
 8201188:	e03ffc15 	stw	zero,-16(fp)
    
    while(!ser_num)
 820118c:	00006006 	br	8201310 <get_serial_number+0x19c>
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
 8201190:	01020974 	movhi	r4,2085
 8201194:	2132ad04 	addi	r4,r4,-13644
 8201198:	82035a00 	call	82035a0 <puts>
        printf("label under your Nios dev. board. The first 3 digits of the \n");
 820119c:	01020974 	movhi	r4,2085
 82011a0:	2132bd04 	addi	r4,r4,-13580
 82011a4:	82035a00 	call	82035a0 <puts>
        printf("label are ASJ and the serial number follows this.\n -->");
 82011a8:	01020974 	movhi	r4,2085
 82011ac:	2132cd04 	addi	r4,r4,-13516
 82011b0:	820331c0 	call	820331c <printf>
        
        for(i=0; i<9; i++)
 82011b4:	e03ffc15 	stw	zero,-16(fp)
 82011b8:	00002606 	br	8201254 <get_serial_number+0xe0>
        {
            serial_number[i] = getchar();
 82011bc:	d0a00217 	ldw	r2,-32760(gp)
 82011c0:	10800117 	ldw	r2,4(r2)
 82011c4:	1009883a 	mov	r4,r2
 82011c8:	8202e040 	call	8202e04 <getc>
 82011cc:	1009883a 	mov	r4,r2
 82011d0:	e0fffd04 	addi	r3,fp,-12
 82011d4:	e0bffc17 	ldw	r2,-16(fp)
 82011d8:	1885883a 	add	r2,r3,r2
 82011dc:	11000005 	stb	r4,0(r2)
            putchar(serial_number[i]);
 82011e0:	e0fffd04 	addi	r3,fp,-12
 82011e4:	e0bffc17 	ldw	r2,-16(fp)
 82011e8:	1885883a 	add	r2,r3,r2
 82011ec:	10800003 	ldbu	r2,0(r2)
 82011f0:	10c03fcc 	andi	r3,r2,255
 82011f4:	18c0201c 	xori	r3,r3,128
 82011f8:	18ffe004 	addi	r3,r3,-128
 82011fc:	d0a00217 	ldw	r2,-32760(gp)
 8201200:	10800217 	ldw	r2,8(r2)
 8201204:	100b883a 	mov	r5,r2
 8201208:	1809883a 	mov	r4,r3
 820120c:	82033f80 	call	82033f8 <putc>
            
            /* Handle backspaces.  How civilized. */
            if ((serial_number[i] == 0x08) && (i >= 0)) 
 8201210:	e0fffd04 	addi	r3,fp,-12
 8201214:	e0bffc17 	ldw	r2,-16(fp)
 8201218:	1885883a 	add	r2,r3,r2
 820121c:	10800003 	ldbu	r2,0(r2)
 8201220:	10803fcc 	andi	r2,r2,255
 8201224:	1080201c 	xori	r2,r2,128
 8201228:	10bfe004 	addi	r2,r2,-128
 820122c:	10800218 	cmpnei	r2,r2,8
 8201230:	1000051e 	bne	r2,zero,8201248 <get_serial_number+0xd4>
 8201234:	e0bffc17 	ldw	r2,-16(fp)
 8201238:	10000316 	blt	r2,zero,8201248 <get_serial_number+0xd4>
            {
                i--;
 820123c:	e0bffc17 	ldw	r2,-16(fp)
 8201240:	10bfffc4 	addi	r2,r2,-1
 8201244:	e0bffc15 	stw	r2,-16(fp)
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
        printf("label under your Nios dev. board. The first 3 digits of the \n");
        printf("label are ASJ and the serial number follows this.\n -->");
        
        for(i=0; i<9; i++)
 8201248:	e0bffc17 	ldw	r2,-16(fp)
 820124c:	10800044 	addi	r2,r2,1
 8201250:	e0bffc15 	stw	r2,-16(fp)
 8201254:	e0bffc17 	ldw	r2,-16(fp)
 8201258:	10800250 	cmplti	r2,r2,9
 820125c:	103fd71e 	bne	r2,zero,82011bc <get_serial_number+0x48>
            if ((serial_number[i] == 0x08) && (i >= 0)) 
            {
                i--;
            }
        }
        printf("\n");
 8201260:	01000284 	movi	r4,10
 8201264:	82034c80 	call	82034c8 <putchar>
                
        for(i=0; i<9; i++)
 8201268:	e03ffc15 	stw	zero,-16(fp)
 820126c:	00002506 	br	8201304 <get_serial_number+0x190>
        {
            if (isdigit(serial_number[i]))
 8201270:	d0e00017 	ldw	r3,-32768(gp)
 8201274:	e13ffd04 	addi	r4,fp,-12
 8201278:	e0bffc17 	ldw	r2,-16(fp)
 820127c:	2085883a 	add	r2,r4,r2
 8201280:	10800003 	ldbu	r2,0(r2)
 8201284:	10803fcc 	andi	r2,r2,255
 8201288:	1080201c 	xori	r2,r2,128
 820128c:	10bfe004 	addi	r2,r2,-128
 8201290:	10800044 	addi	r2,r2,1
 8201294:	1885883a 	add	r2,r3,r2
 8201298:	10800003 	ldbu	r2,0(r2)
 820129c:	10803fcc 	andi	r2,r2,255
 82012a0:	1080010c 	andi	r2,r2,4
 82012a4:	10000f26 	beq	r2,zero,82012e4 <get_serial_number+0x170>
            {
                ser_num *= 10;
 82012a8:	e0bffb17 	ldw	r2,-20(fp)
 82012ac:	108002a4 	muli	r2,r2,10
 82012b0:	e0bffb15 	stw	r2,-20(fp)
                ser_num += serial_number[i] - '0';
 82012b4:	e0fffd04 	addi	r3,fp,-12
 82012b8:	e0bffc17 	ldw	r2,-16(fp)
 82012bc:	1885883a 	add	r2,r3,r2
 82012c0:	10800003 	ldbu	r2,0(r2)
 82012c4:	10c03fcc 	andi	r3,r2,255
 82012c8:	18c0201c 	xori	r3,r3,128
 82012cc:	18ffe004 	addi	r3,r3,-128
 82012d0:	e0bffb17 	ldw	r2,-20(fp)
 82012d4:	1885883a 	add	r2,r3,r2
 82012d8:	10bff404 	addi	r2,r2,-48
 82012dc:	e0bffb15 	stw	r2,-20(fp)
 82012e0:	00000506 	br	82012f8 <get_serial_number+0x184>
            }
            else
            {
                ser_num = 0;
 82012e4:	e03ffb15 	stw	zero,-20(fp)
                printf("Serial number only contains decimal digits and is non-zero\n");
 82012e8:	01020974 	movhi	r4,2085
 82012ec:	2132db04 	addi	r4,r4,-13460
 82012f0:	82035a00 	call	82035a0 <puts>
                break;
 82012f4:	00000606 	br	8201310 <get_serial_number+0x19c>
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 82012f8:	e0bffc17 	ldw	r2,-16(fp)
 82012fc:	10800044 	addi	r2,r2,1
 8201300:	e0bffc15 	stw	r2,-16(fp)
 8201304:	e0bffc17 	ldw	r2,-16(fp)
 8201308:	10800250 	cmplti	r2,r2,9
 820130c:	103fd81e 	bne	r2,zero,8201270 <get_serial_number+0xfc>
{
    alt_u32 ser_num = 0;
    char serial_number[9];
    int i = 0;
    
    while(!ser_num)
 8201310:	e0bffb17 	ldw	r2,-20(fp)
 8201314:	103f9e26 	beq	r2,zero,8201190 <get_serial_number+0x1c>
                break;
            }
        }
    }
    
    return ser_num;
 8201318:	e0bffb17 	ldw	r2,-20(fp)
}
 820131c:	e037883a 	mov	sp,fp
 8201320:	dfc00117 	ldw	ra,4(sp)
 8201324:	df000017 	ldw	fp,0(sp)
 8201328:	dec00204 	addi	sp,sp,8
 820132c:	f800283a 	ret

08201330 <generate_and_store_mac_addr>:
 * sections. These fail-safe static settings are compatible with previous
 * Nios Ethernet designs, and allow the "factory-safe" design to behave 
 * as expected if the last flash sector is erased.
 */
error_t generate_and_store_mac_addr()
{
 8201330:	deffef04 	addi	sp,sp,-68
 8201334:	dfc01015 	stw	ra,64(sp)
 8201338:	df000f15 	stw	fp,60(sp)
 820133c:	df000f04 	addi	fp,sp,60
    error_t error = -1;
 8201340:	00bfffc4 	movi	r2,-1
 8201344:	e0bff115 	stw	r2,-60(fp)
    alt_u32 ser_num = 0;
 8201348:	e03ff215 	stw	zero,-56(fp)
    char flash_content[32];
    alt_flash_fd* flash_handle;
    
    printf("Can't read the MAC address from your board (this probably means\n");
 820134c:	01020974 	movhi	r4,2085
 8201350:	2132ea04 	addi	r4,r4,-13400
 8201354:	82035a00 	call	82035a0 <puts>
    printf("that your flash was erased). We will assign you a MAC address and\n");
 8201358:	01020974 	movhi	r4,2085
 820135c:	2132fa04 	addi	r4,r4,-13336
 8201360:	82035a00 	call	82035a0 <puts>
    printf("static network settings\n\n");
 8201364:	01020974 	movhi	r4,2085
 8201368:	21330b04 	addi	r4,r4,-13268
 820136c:	82035a00 	call	82035a0 <puts>
    
    ser_num = 123456789;//get_serial_number();
 8201370:	0081d734 	movhi	r2,1884
 8201374:	10b34544 	addi	r2,r2,-13035
 8201378:	e0bff215 	stw	r2,-56(fp)
  
    if (ser_num)
 820137c:	e0bff217 	ldw	r2,-56(fp)
 8201380:	10004f26 	beq	r2,zero,82014c0 <generate_and_store_mac_addr+0x190>
    {
        /* This says the image is safe */
        flash_content[0] = 0xfe;
 8201384:	00bfff84 	movi	r2,-2
 8201388:	e0bff805 	stb	r2,-32(fp)
        flash_content[1] = 0x5a;
 820138c:	00801684 	movi	r2,90
 8201390:	e0bff845 	stb	r2,-31(fp)
        flash_content[2] = 0x0;
 8201394:	e03ff885 	stb	zero,-30(fp)
        flash_content[3] = 0x0;
 8201398:	e03ff8c5 	stb	zero,-29(fp)
        
        /* This is the Altera Vendor ID */
        flash_content[4] = 0x0;
 820139c:	e03ff905 	stb	zero,-28(fp)
        flash_content[5] = 0x7;
 82013a0:	008001c4 	movi	r2,7
 82013a4:	e0bff945 	stb	r2,-27(fp)
        flash_content[6] = 0xed;
 82013a8:	00bffb44 	movi	r2,-19
 82013ac:	e0bff985 	stb	r2,-26(fp)
        
        /* Reserverd Board identifier for erase boards */
        flash_content[7] = 0xFF;
 82013b0:	00bfffc4 	movi	r2,-1
 82013b4:	e0bff9c5 	stb	r2,-25(fp)
        flash_content[8] = (ser_num & 0xff00) >> 8;
 82013b8:	e0bff217 	ldw	r2,-56(fp)
 82013bc:	10bfc00c 	andi	r2,r2,65280
 82013c0:	1004d23a 	srli	r2,r2,8
 82013c4:	e0bffa05 	stb	r2,-24(fp)
        flash_content[9] = ser_num & 0xff;
 82013c8:	e0bff217 	ldw	r2,-56(fp)
 82013cc:	e0bffa45 	stb	r2,-23(fp)
        
        /* Then comes a 16-bit "flags" field */
        flash_content[10] = 0xFF;
 82013d0:	00bfffc4 	movi	r2,-1
 82013d4:	e0bffa85 	stb	r2,-22(fp)
        flash_content[11] = 0xFF;
 82013d8:	00bfffc4 	movi	r2,-1
 82013dc:	e0bffac5 	stb	r2,-21(fp)
        
        /* Then comes the static IP address */
        flash_content[12] = IPADDR0;
 82013e0:	e03ffb05 	stb	zero,-20(fp)
        flash_content[13] = IPADDR1;
 82013e4:	e03ffb45 	stb	zero,-19(fp)
        flash_content[14] = IPADDR2;
 82013e8:	e03ffb85 	stb	zero,-18(fp)
        flash_content[15] = IPADDR3;
 82013ec:	e03ffbc5 	stb	zero,-17(fp)
        
        /* Then comes the static nameserver address */
        flash_content[16] = 0xFF;
 82013f0:	00bfffc4 	movi	r2,-1
 82013f4:	e0bffc05 	stb	r2,-16(fp)
        flash_content[17] = 0xFF;
 82013f8:	00bfffc4 	movi	r2,-1
 82013fc:	e0bffc45 	stb	r2,-15(fp)
        flash_content[18] = 0xFF;
 8201400:	00bfffc4 	movi	r2,-1
 8201404:	e0bffc85 	stb	r2,-14(fp)
        flash_content[19] = 0xFF;
 8201408:	00bfffc4 	movi	r2,-1
 820140c:	e0bffcc5 	stb	r2,-13(fp)
        
        /* Then comes the static subnet mask */
        flash_content[20] = MSKADDR0;
 8201410:	00bfffc4 	movi	r2,-1
 8201414:	e0bffd05 	stb	r2,-12(fp)
        flash_content[21] = MSKADDR1;
 8201418:	00bfffc4 	movi	r2,-1
 820141c:	e0bffd45 	stb	r2,-11(fp)
        flash_content[22] = MSKADDR2;
 8201420:	00bfffc4 	movi	r2,-1
 8201424:	e0bffd85 	stb	r2,-10(fp)
        flash_content[23] = MSKADDR3;
 8201428:	e03ffdc5 	stb	zero,-9(fp)
        
        /* Then comes the static gateway address */
        flash_content[24] = GWADDR0;
 820142c:	e03ffe05 	stb	zero,-8(fp)
        flash_content[25] = GWADDR1;
 8201430:	e03ffe45 	stb	zero,-7(fp)
        flash_content[26] = GWADDR2;
 8201434:	e03ffe85 	stb	zero,-6(fp)
        flash_content[27] = GWADDR3;
 8201438:	e03ffec5 	stb	zero,-5(fp)
        
        /* And finally whether to use DHCP - set all bits to be safe */
        flash_content[28] = 0xFF;
 820143c:	00bfffc4 	movi	r2,-1
 8201440:	e0bfff05 	stb	r2,-4(fp)
        flash_content[29] = 0xFF;
 8201444:	00bfffc4 	movi	r2,-1
 8201448:	e0bfff45 	stb	r2,-3(fp)
        flash_content[30] = 0xFF;
 820144c:	00bfffc4 	movi	r2,-1
 8201450:	e0bfff85 	stb	r2,-2(fp)
        flash_content[31] = 0xFF;
 8201454:	00bfffc4 	movi	r2,-1
 8201458:	e0bfffc5 	stb	r2,-1(fp)
        
        /* Write the MAC address to flash */
        flash_handle = alt_flash_open_dev(EXT_FLASH_NAME);
 820145c:	01020974 	movhi	r4,2085
 8201460:	21331204 	addi	r4,r4,-13240
 8201464:	821434c0 	call	821434c <alt_flash_open_dev>
 8201468:	e0bff315 	stw	r2,-52(fp)
        if (flash_handle)
 820146c:	e0bff317 	ldw	r2,-52(fp)
 8201470:	10001326 	beq	r2,zero,82014c0 <generate_and_store_mac_addr+0x190>
        {
            alt_write_flash(flash_handle,
 8201474:	d0a05717 	ldw	r2,-32420(gp)
 8201478:	1007883a 	mov	r3,r2
 820147c:	e0bff317 	ldw	r2,-52(fp)
 8201480:	e0bff415 	stw	r2,-48(fp)
 8201484:	e0fff515 	stw	r3,-44(fp)
 8201488:	e0bff804 	addi	r2,fp,-32
 820148c:	e0bff615 	stw	r2,-40(fp)
 8201490:	00800804 	movi	r2,32
 8201494:	e0bff715 	stw	r2,-36(fp)
                                                           alt_flash_fd* fd, 
                                                           int offset, 
                                                           const void* src_addr, 
                                                           int length )
{
  return fd->write( fd, offset, src_addr, length );
 8201498:	e0bff417 	ldw	r2,-48(fp)
 820149c:	10800517 	ldw	r2,20(r2)
 82014a0:	e1fff717 	ldw	r7,-36(fp)
 82014a4:	e1bff617 	ldw	r6,-40(fp)
 82014a8:	e17ff517 	ldw	r5,-44(fp)
 82014ac:	e13ff417 	ldw	r4,-48(fp)
 82014b0:	103ee83a 	callr	r2
                            last_flash_sector_offset,
                            flash_content,
                            32);
            alt_flash_close_dev(flash_handle);
 82014b4:	e13ff317 	ldw	r4,-52(fp)
 82014b8:	82143b40 	call	82143b4 <alt_flash_close_dev>
            error = 0;
 82014bc:	e03ff115 	stw	zero,-60(fp)
        }
    }

    return error;    
 82014c0:	e0bff117 	ldw	r2,-60(fp)
}
 82014c4:	e037883a 	mov	sp,fp
 82014c8:	dfc00117 	ldw	ra,4(sp)
 82014cc:	df000017 	ldw	fp,0(sp)
 82014d0:	dec00204 	addi	sp,sp,8
 82014d4:	f800283a 	ret

082014d8 <generate_mac_addr>:
 * Development Board serial number is 040800017, the corresponding ethernet 
 * number generated will be 00:07:ED:FF:8F:11.
 * 
 */
error_t generate_mac_addr(unsigned char mac_addr[6])
{
 82014d8:	defff804 	addi	sp,sp,-32
 82014dc:	dfc00715 	stw	ra,28(sp)
 82014e0:	df000615 	stw	fp,24(sp)
 82014e4:	df000604 	addi	fp,sp,24
 82014e8:	e13fff15 	stw	r4,-4(fp)
    error_t error = -1;
 82014ec:	00bfffc4 	movi	r2,-1
 82014f0:	e0bffd15 	stw	r2,-12(fp)
    alt_u32 ser_num = 0;
 82014f4:	e03ffe15 	stw	zero,-8(fp)
    
    printf("\nCan't read the MAC address from your board. We will assign you\n");
 82014f8:	01020974 	movhi	r4,2085
 82014fc:	21331604 	addi	r4,r4,-13224
 8201500:	82035a00 	call	82035a0 <puts>
    printf("a MAC address.\n\n");
 8201504:	01020974 	movhi	r4,2085
 8201508:	21332604 	addi	r4,r4,-13160
 820150c:	82035a00 	call	82035a0 <puts>
    
    ser_num = 123456789;//get_serial_number();
 8201510:	0081d734 	movhi	r2,1884
 8201514:	10b34544 	addi	r2,r2,-13035
 8201518:	e0bffe15 	stw	r2,-8(fp)
  
    if (ser_num)
 820151c:	e0bffe17 	ldw	r2,-8(fp)
 8201520:	10003626 	beq	r2,zero,82015fc <generate_mac_addr+0x124>
    {
        /* This is the Altera Vendor ID */
        mac_addr[0] = 0x0;
 8201524:	e0bfff17 	ldw	r2,-4(fp)
 8201528:	10000005 	stb	zero,0(r2)
        mac_addr[1] = 0x7;
 820152c:	e0bfff17 	ldw	r2,-4(fp)
 8201530:	10800044 	addi	r2,r2,1
 8201534:	00c001c4 	movi	r3,7
 8201538:	10c00005 	stb	r3,0(r2)
        mac_addr[2] = 0xed;
 820153c:	e0bfff17 	ldw	r2,-4(fp)
 8201540:	10800084 	addi	r2,r2,2
 8201544:	00fffb44 	movi	r3,-19
 8201548:	10c00005 	stb	r3,0(r2)
        
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
 820154c:	e0bfff17 	ldw	r2,-4(fp)
 8201550:	108000c4 	addi	r2,r2,3
 8201554:	00ffffc4 	movi	r3,-1
 8201558:	10c00005 	stb	r3,0(r2)
        mac_addr[4] = (ser_num & 0xff00) >> 8;
 820155c:	e0bfff17 	ldw	r2,-4(fp)
 8201560:	10800104 	addi	r2,r2,4
 8201564:	e0fffe17 	ldw	r3,-8(fp)
 8201568:	18ffc00c 	andi	r3,r3,65280
 820156c:	1806d23a 	srli	r3,r3,8
 8201570:	10c00005 	stb	r3,0(r2)
        mac_addr[5] = ser_num & 0xff;
 8201574:	e0bfff17 	ldw	r2,-4(fp)
 8201578:	10800144 	addi	r2,r2,5
 820157c:	e0fffe17 	ldw	r3,-8(fp)
 8201580:	10c00005 	stb	r3,0(r2)
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
            mac_addr[0],
 8201584:	e0bfff17 	ldw	r2,-4(fp)
 8201588:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 820158c:	11403fcc 	andi	r5,r2,255
            mac_addr[0],
            mac_addr[1],
 8201590:	e0bfff17 	ldw	r2,-4(fp)
 8201594:	10800044 	addi	r2,r2,1
 8201598:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 820159c:	11803fcc 	andi	r6,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
 82015a0:	e0bfff17 	ldw	r2,-4(fp)
 82015a4:	10800084 	addi	r2,r2,2
 82015a8:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015ac:	11c03fcc 	andi	r7,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
 82015b0:	e0bfff17 	ldw	r2,-4(fp)
 82015b4:	108000c4 	addi	r2,r2,3
 82015b8:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015bc:	10803fcc 	andi	r2,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
 82015c0:	e0ffff17 	ldw	r3,-4(fp)
 82015c4:	18c00104 	addi	r3,r3,4
 82015c8:	18c00003 	ldbu	r3,0(r3)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015cc:	18c03fcc 	andi	r3,r3,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
 82015d0:	e13fff17 	ldw	r4,-4(fp)
 82015d4:	21000144 	addi	r4,r4,5
 82015d8:	21000003 	ldbu	r4,0(r4)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 82015dc:	21003fcc 	andi	r4,r4,255
 82015e0:	d9000215 	stw	r4,8(sp)
 82015e4:	d8c00115 	stw	r3,4(sp)
 82015e8:	d8800015 	stw	r2,0(sp)
 82015ec:	01020974 	movhi	r4,2085
 82015f0:	21332a04 	addi	r4,r4,-13144
 82015f4:	820331c0 	call	820331c <printf>
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
        
        error = 0;
 82015f8:	e03ffd15 	stw	zero,-12(fp)
    }
  
    return error;    
 82015fc:	e0bffd17 	ldw	r2,-12(fp)
}
 8201600:	e037883a 	mov	sp,fp
 8201604:	dfc00117 	ldw	ra,4(sp)
 8201608:	df000017 	ldw	fp,0(sp)
 820160c:	dec00204 	addi	sp,sp,8
 8201610:	f800283a 	ret

08201614 <get_board_mac_addr>:
*
* Read the MAC address in a board specific way
*
*/
error_t get_board_mac_addr(unsigned char mac_addr[6])
{
 8201614:	defff804 	addi	sp,sp,-32
 8201618:	dfc00715 	stw	ra,28(sp)
 820161c:	df000615 	stw	fp,24(sp)
 8201620:	df000604 	addi	fp,sp,24
 8201624:	e13fff15 	stw	r4,-4(fp)
    error_t error = 0;
 8201628:	e03ffd15 	stw	zero,-12(fp)
    alt_u32 signature;
    
    /* Get the flash sector with the MAC address. */
    error = FindLastFlashSectorOffset(&last_flash_sector_offset);
 820162c:	d1205704 	addi	r4,gp,-32420
 8201630:	82017ac0 	call	82017ac <FindLastFlashSectorOffset>
 8201634:	e0bffd15 	stw	r2,-12(fp)
    if (!error)
 8201638:	e0bffd17 	ldw	r2,-12(fp)
 820163c:	1000021e 	bne	r2,zero,8201648 <get_board_mac_addr+0x34>
        last_flash_sector = EXT_FLASH_BASE + last_flash_sector_offset;
 8201640:	d0a05717 	ldw	r2,-32420(gp)
 8201644:	d0a05815 	stw	r2,-32416(gp)
     * valid network settings are present, indicated by a signature of 0x00005afe at 
     * the first address of the last flash sector.  This hex value is chosen as the 
     * signature since it looks like the english word "SAFE", meaning that it is 
     * safe to use these network address values.  
    */
    if (!error)
 8201648:	e0bffd17 	ldw	r2,-12(fp)
 820164c:	1000081e 	bne	r2,zero,8201670 <get_board_mac_addr+0x5c>
    {
        signature = IORD_32DIRECT(last_flash_sector, 0);
 8201650:	d0a05817 	ldw	r2,-32416(gp)
 8201654:	10800037 	ldwio	r2,0(r2)
 8201658:	e0bffe15 	stw	r2,-8(fp)
        if (signature != 0x00005afe)
 820165c:	e0bffe17 	ldw	r2,-8(fp)
 8201660:	1096bfa0 	cmpeqi	r2,r2,23294
 8201664:	1000021e 	bne	r2,zero,8201670 <get_board_mac_addr+0x5c>
        {
          error = generate_and_store_mac_addr();
 8201668:	82013300 	call	8201330 <generate_and_store_mac_addr>
 820166c:	e0bffd15 	stw	r2,-12(fp)
        }
    }
  
    if (!error)
 8201670:	e0bffd17 	ldw	r2,-12(fp)
 8201674:	1000471e 	bne	r2,zero,8201794 <get_board_mac_addr+0x180>
    {
        mac_addr[0] = IORD_8DIRECT(last_flash_sector, 4);
 8201678:	d0a05817 	ldw	r2,-32416(gp)
 820167c:	10800104 	addi	r2,r2,4
 8201680:	10800023 	ldbuio	r2,0(r2)
 8201684:	10803fcc 	andi	r2,r2,255
 8201688:	1007883a 	mov	r3,r2
 820168c:	e0bfff17 	ldw	r2,-4(fp)
 8201690:	10c00005 	stb	r3,0(r2)
        mac_addr[1] = IORD_8DIRECT(last_flash_sector, 5);
 8201694:	e0bfff17 	ldw	r2,-4(fp)
 8201698:	10800044 	addi	r2,r2,1
 820169c:	d0e05817 	ldw	r3,-32416(gp)
 82016a0:	18c00144 	addi	r3,r3,5
 82016a4:	18c00023 	ldbuio	r3,0(r3)
 82016a8:	18c03fcc 	andi	r3,r3,255
 82016ac:	10c00005 	stb	r3,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
 82016b0:	e0bfff17 	ldw	r2,-4(fp)
 82016b4:	10800084 	addi	r2,r2,2
 82016b8:	d0e05817 	ldw	r3,-32416(gp)
 82016bc:	18c00184 	addi	r3,r3,6
 82016c0:	18c00023 	ldbuio	r3,0(r3)
 82016c4:	18c03fcc 	andi	r3,r3,255
 82016c8:	10c00005 	stb	r3,0(r2)
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
 82016cc:	e0bfff17 	ldw	r2,-4(fp)
 82016d0:	108000c4 	addi	r2,r2,3
 82016d4:	d0e05817 	ldw	r3,-32416(gp)
 82016d8:	18c001c4 	addi	r3,r3,7
 82016dc:	18c00023 	ldbuio	r3,0(r3)
 82016e0:	18c03fcc 	andi	r3,r3,255
 82016e4:	10c00005 	stb	r3,0(r2)
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
 82016e8:	e0bfff17 	ldw	r2,-4(fp)
 82016ec:	10800104 	addi	r2,r2,4
 82016f0:	d0e05817 	ldw	r3,-32416(gp)
 82016f4:	18c00204 	addi	r3,r3,8
 82016f8:	18c00023 	ldbuio	r3,0(r3)
 82016fc:	18c03fcc 	andi	r3,r3,255
 8201700:	10c00005 	stb	r3,0(r2)
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
 8201704:	e0bfff17 	ldw	r2,-4(fp)
 8201708:	10800144 	addi	r2,r2,5
 820170c:	d0e05817 	ldw	r3,-32416(gp)
 8201710:	18c00244 	addi	r3,r3,9
 8201714:	18c00023 	ldbuio	r3,0(r3)
 8201718:	18c03fcc 	andi	r3,r3,255
 820171c:	10c00005 	stb	r3,0(r2)
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
            mac_addr[0],
 8201720:	e0bfff17 	ldw	r2,-4(fp)
 8201724:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201728:	11403fcc 	andi	r5,r2,255
            mac_addr[0],
            mac_addr[1],
 820172c:	e0bfff17 	ldw	r2,-4(fp)
 8201730:	10800044 	addi	r2,r2,1
 8201734:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201738:	11803fcc 	andi	r6,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
 820173c:	e0bfff17 	ldw	r2,-4(fp)
 8201740:	10800084 	addi	r2,r2,2
 8201744:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201748:	11c03fcc 	andi	r7,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
 820174c:	e0bfff17 	ldw	r2,-4(fp)
 8201750:	108000c4 	addi	r2,r2,3
 8201754:	10800003 	ldbu	r2,0(r2)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201758:	10803fcc 	andi	r2,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
 820175c:	e0ffff17 	ldw	r3,-4(fp)
 8201760:	18c00104 	addi	r3,r3,4
 8201764:	18c00003 	ldbu	r3,0(r3)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201768:	18c03fcc 	andi	r3,r3,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
 820176c:	e13fff17 	ldw	r4,-4(fp)
 8201770:	21000144 	addi	r4,r4,5
 8201774:	21000003 	ldbu	r4,0(r4)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 8201778:	21003fcc 	andi	r4,r4,255
 820177c:	d9000215 	stw	r4,8(sp)
 8201780:	d8c00115 	stw	r3,4(sp)
 8201784:	d8800015 	stw	r2,0(sp)
 8201788:	01020974 	movhi	r4,2085
 820178c:	21332a04 	addi	r4,r4,-13144
 8201790:	820331c0 	call	820331c <printf>
            mac_addr[4],
            mac_addr[5]);
    
    }
    
    return error;
 8201794:	e0bffd17 	ldw	r2,-12(fp)
}
 8201798:	e037883a 	mov	sp,fp
 820179c:	dfc00117 	ldw	ra,4(sp)
 82017a0:	df000017 	ldw	fp,0(sp)
 82017a4:	dec00204 	addi	sp,sp,8
 82017a8:	f800283a 	ret

082017ac <FindLastFlashSectorOffset>:
 * in pLastFlashSectorOffset.
 */

int FindLastFlashSectorOffset(
    alt_u32                     *pLastFlashSectorOffset)
{
 82017ac:	defff304 	addi	sp,sp,-52
 82017b0:	dfc00c15 	stw	ra,48(sp)
 82017b4:	df000b15 	stw	fp,44(sp)
 82017b8:	df000b04 	addi	fp,sp,44
 82017bc:	e13fff15 	stw	r4,-4(fp)
    flash_region                *regions;
    int                         numRegions;
    flash_region                *pLastRegion;
    int                         lastFlashSectorOffset;
    int                         n;
    int                         error = 0;
 82017c0:	e03ff815 	stw	zero,-32(fp)

    /* Open the flash device. */
    fd = alt_flash_open_dev(EXT_FLASH_NAME);
 82017c4:	01020974 	movhi	r4,2085
 82017c8:	21331204 	addi	r4,r4,-13240
 82017cc:	821434c0 	call	821434c <alt_flash_open_dev>
 82017d0:	e0bff915 	stw	r2,-28(fp)
    if (fd <= 0)
 82017d4:	e0bff917 	ldw	r2,-28(fp)
 82017d8:	1000021e 	bne	r2,zero,82017e4 <FindLastFlashSectorOffset+0x38>
        error = -1;
 82017dc:	00bfffc4 	movi	r2,-1
 82017e0:	e0bff815 	stw	r2,-32(fp)

    /* Get the flash info. */
    if (!error)
 82017e4:	e0bff817 	ldw	r2,-32(fp)
 82017e8:	10000d1e 	bne	r2,zero,8201820 <FindLastFlashSectorOffset+0x74>
 82017ec:	e0bff917 	ldw	r2,-28(fp)
 82017f0:	e0bffa15 	stw	r2,-24(fp)
 82017f4:	e0bffd04 	addi	r2,fp,-12
 82017f8:	e0bffb15 	stw	r2,-20(fp)
 82017fc:	e0bffe04 	addi	r2,fp,-8
 8201800:	e0bffc15 	stw	r2,-16(fp)
 */
static __inline__ int __attribute__ ((always_inline)) alt_get_flash_info( 
                                      alt_flash_fd* fd, flash_region** info, 
                                      int* number_of_regions)
{
  return fd->get_info( fd, info, number_of_regions);
 8201804:	e0bffa17 	ldw	r2,-24(fp)
 8201808:	10800717 	ldw	r2,28(r2)
 820180c:	e1bffc17 	ldw	r6,-16(fp)
 8201810:	e17ffb17 	ldw	r5,-20(fp)
 8201814:	e13ffa17 	ldw	r4,-24(fp)
 8201818:	103ee83a 	callr	r2
        error = alt_get_flash_info(fd, &regions, &numRegions);
 820181c:	e0bff815 	stw	r2,-32(fp)

    /* Find the last flash sector. */
    if (!error)
 8201820:	e0bff817 	ldw	r2,-32(fp)
 8201824:	1000211e 	bne	r2,zero,82018ac <FindLastFlashSectorOffset+0x100>
    {
        pLastRegion = &(regions[0]);
 8201828:	e0bffd17 	ldw	r2,-12(fp)
 820182c:	e0bff515 	stw	r2,-44(fp)
        for (n = 1; n < numRegions; n++)
 8201830:	00800044 	movi	r2,1
 8201834:	e0bff715 	stw	r2,-36(fp)
 8201838:	00001006 	br	820187c <FindLastFlashSectorOffset+0xd0>
        {
            if (regions[n].offset > pLastRegion->offset)
 820183c:	e0fffd17 	ldw	r3,-12(fp)
 8201840:	e0bff717 	ldw	r2,-36(fp)
 8201844:	1004913a 	slli	r2,r2,4
 8201848:	1885883a 	add	r2,r3,r2
 820184c:	10800017 	ldw	r2,0(r2)
 8201850:	e0fff517 	ldw	r3,-44(fp)
 8201854:	18c00017 	ldw	r3,0(r3)
 8201858:	1880050e 	bge	r3,r2,8201870 <FindLastFlashSectorOffset+0xc4>
                pLastRegion = &(regions[n]);
 820185c:	e0fffd17 	ldw	r3,-12(fp)
 8201860:	e0bff717 	ldw	r2,-36(fp)
 8201864:	1004913a 	slli	r2,r2,4
 8201868:	1885883a 	add	r2,r3,r2
 820186c:	e0bff515 	stw	r2,-44(fp)

    /* Find the last flash sector. */
    if (!error)
    {
        pLastRegion = &(regions[0]);
        for (n = 1; n < numRegions; n++)
 8201870:	e0bff717 	ldw	r2,-36(fp)
 8201874:	10800044 	addi	r2,r2,1
 8201878:	e0bff715 	stw	r2,-36(fp)
 820187c:	e0bffe17 	ldw	r2,-8(fp)
 8201880:	e0fff717 	ldw	r3,-36(fp)
 8201884:	18bfed16 	blt	r3,r2,820183c <FindLastFlashSectorOffset+0x90>
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 8201888:	e0bff517 	ldw	r2,-44(fp)
 820188c:	10c00017 	ldw	r3,0(r2)
                                + pLastRegion->region_size
 8201890:	e0bff517 	ldw	r2,-44(fp)
 8201894:	10800117 	ldw	r2,4(r2)
 8201898:	1887883a 	add	r3,r3,r2
                                - pLastRegion->block_size;
 820189c:	e0bff517 	ldw	r2,-44(fp)
 82018a0:	10800317 	ldw	r2,12(r2)
        for (n = 1; n < numRegions; n++)
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 82018a4:	1885c83a 	sub	r2,r3,r2
 82018a8:	e0bff615 	stw	r2,-40(fp)
                                + pLastRegion->region_size
                                - pLastRegion->block_size;
    }

    /* Return results. */
    if (!error)
 82018ac:	e0bff817 	ldw	r2,-32(fp)
 82018b0:	1000031e 	bne	r2,zero,82018c0 <FindLastFlashSectorOffset+0x114>
        *pLastFlashSectorOffset = lastFlashSectorOffset;
 82018b4:	e0fff617 	ldw	r3,-40(fp)
 82018b8:	e0bfff17 	ldw	r2,-4(fp)
 82018bc:	10c00015 	stw	r3,0(r2)

    return (error);
 82018c0:	e0bff817 	ldw	r2,-32(fp)
}
 82018c4:	e037883a 	mov	sp,fp
 82018c8:	dfc00117 	ldw	ra,4(sp)
 82018cc:	df000017 	ldw	fp,0(sp)
 82018d0:	dec00204 	addi	sp,sp,8
 82018d4:	f800283a 	ret

082018d8 <SSSCreateOSDataStructs>:
/*
 * Create our MicroC/OS-II resources. All of the resources beginning with 
 * "SSS" are declared in this file, and created in this function.
 */
void SSSCreateOSDataStructs(void)
{
 82018d8:	defffd04 	addi	sp,sp,-12
 82018dc:	dfc00215 	stw	ra,8(sp)
 82018e0:	df000115 	stw	fp,4(sp)
 82018e4:	df000104 	addi	fp,sp,4
  /*
  * Create the resource for our MicroC/OS-II Queue for sending commands 
  * received on the TCP/IP socket from the SSSSimpleSocketServerTask()
  * to the LEDManagementTask().
  */
  SSSLEDCommandQ = OSQCreate(&SSSLEDCommandQTbl[0], SSS_LED_COMMAND_Q_SIZE);
 82018e8:	01400784 	movi	r5,30
 82018ec:	010209b4 	movhi	r4,2086
 82018f0:	21222004 	addi	r4,r4,-30592
 82018f4:	8218cac0 	call	8218cac <OSQCreate>
 82018f8:	d0a05a15 	stw	r2,-32408(gp)
  if (!SSSLEDCommandQ)
 82018fc:	d0a05a17 	ldw	r2,-32408(gp)
 8201900:	1000041e 	bne	r2,zero,8201914 <SSSCreateOSDataStructs+0x3c>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 8201904:	01420974 	movhi	r5,2085
 8201908:	29733904 	addi	r5,r5,-13084
 820190c:	01003fc4 	movi	r4,255
 8201910:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  * toggle the lightshow off, and gives up the semaphore to turn the lightshow
  * back on.  The LEDTask does this in response to the CMD_LEDS_LIGHTSHOW
  * command sent from the SSSSimpleSocketServerTask when the user sends the 
  * toggle lightshow command over the TCPIP socket.
  */
  SSSLEDLightshowSem = OSSemCreate(1);
 8201914:	01000044 	movi	r4,1
 8201918:	8219d200 	call	8219d20 <OSSemCreate>
 820191c:	d0a05b15 	stw	r2,-32404(gp)
  if (!SSSLEDLightshowSem)
 8201920:	d0a05b17 	ldw	r2,-32404(gp)
 8201924:	1000041e 	bne	r2,zero,8201938 <SSSCreateOSDataStructs+0x60>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 8201928:	01420974 	movhi	r5,2085
 820192c:	29734204 	addi	r5,r5,-13048
 8201930:	01003fc4 	movi	r4,255
 8201934:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  
 /*
  * Create our MicroC/OS-II LED Event Flag.  Each flag corresponds to one of
  * the LEDs on the Nios Development board, D0 - D7. 
  */   
  SSSLEDEventFlag = OSFlagCreate(0, &error_code);
 8201938:	e17fff04 	addi	r5,fp,-4
 820193c:	0009883a 	mov	r4,zero
 8201940:	821700c0 	call	821700c <OSFlagCreate>
 8201944:	d0a05c15 	stw	r2,-32400(gp)
  if (!SSSLEDEventFlag)
 8201948:	d0a05c17 	ldw	r2,-32400(gp)
 820194c:	1000051e 	bne	r2,zero,8201964 <SSSCreateOSDataStructs+0x8c>
  {
     alt_uCOSIIErrorHandler(error_code, 0);
 8201950:	e0bfff03 	ldbu	r2,-4(fp)
 8201954:	10803fcc 	andi	r2,r2,255
 8201958:	000b883a 	mov	r5,zero
 820195c:	1009883a 	mov	r4,r2
 8201960:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  }
}
 8201964:	0001883a 	nop
 8201968:	e037883a 	mov	sp,fp
 820196c:	dfc00117 	ldw	ra,4(sp)
 8201970:	df000017 	ldw	fp,0(sp)
 8201974:	dec00204 	addi	sp,sp,8
 8201978:	f800283a 	ret

0820197c <SSSCreateTasks>:
/* This function creates tasks used in this example which do not use sockets.
 * Tasks which use Interniche sockets must be created with TK_NEWTASK.
 */
 
void SSSCreateTasks(void)
{
 820197c:	defff804 	addi	sp,sp,-32
 8201980:	dfc00715 	stw	ra,28(sp)
 8201984:	df000615 	stw	fp,24(sp)
 8201988:	df000604 	addi	fp,sp,24
   INT8U error_code;
  
   error_code = OSTaskCreateExt(LED7SegLightshowTask,
 820198c:	d8000415 	stw	zero,16(sp)
 8201990:	d8000315 	stw	zero,12(sp)
 8201994:	00820004 	movi	r2,2048
 8201998:	d8800215 	stw	r2,8(sp)
 820199c:	00820974 	movhi	r2,2085
 82019a0:	109a2004 	addi	r2,r2,26752
 82019a4:	d8800115 	stw	r2,4(sp)
 82019a8:	00800484 	movi	r2,18
 82019ac:	d8800015 	stw	r2,0(sp)
 82019b0:	01c00484 	movi	r7,18
 82019b4:	018209b4 	movhi	r6,2086
 82019b8:	31a21f04 	addi	r6,r6,-30596
 82019bc:	000b883a 	mov	r5,zero
 82019c0:	01020834 	movhi	r4,2080
 82019c4:	21039f04 	addi	r4,r4,3708
 82019c8:	821ad6c0 	call	821ad6c <OSTaskCreateExt>
 82019cc:	e0bfff05 	stb	r2,-4(fp)
                             LED7SegLightshowTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
   
   alt_uCOSIIErrorHandler(error_code, 0);
 82019d0:	e0bfff03 	ldbu	r2,-4(fp)
 82019d4:	000b883a 	mov	r5,zero
 82019d8:	1009883a 	mov	r4,r2
 82019dc:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>
  
   error_code = OSTaskCreateExt(LEDManagementTask,
 82019e0:	d8000415 	stw	zero,16(sp)
 82019e4:	d8000315 	stw	zero,12(sp)
 82019e8:	00820004 	movi	r2,2048
 82019ec:	d8800215 	stw	r2,8(sp)
 82019f0:	008209b4 	movhi	r2,2086
 82019f4:	10a23e04 	addi	r2,r2,-30472
 82019f8:	d8800115 	stw	r2,4(sp)
 82019fc:	008001c4 	movi	r2,7
 8201a00:	d8800015 	stw	r2,0(sp)
 8201a04:	01c001c4 	movi	r7,7
 8201a08:	018209b4 	movhi	r6,2086
 8201a0c:	31aa3d04 	addi	r6,r6,-22284
 8201a10:	000b883a 	mov	r5,zero
 8201a14:	01020834 	movhi	r4,2080
 8201a18:	2103bc04 	addi	r4,r4,3824
 8201a1c:	821ad6c0 	call	821ad6c <OSTaskCreateExt>
 8201a20:	e0bfff05 	stb	r2,-4(fp)
                              LEDManagementTaskStk,
                              TASK_STACKSIZE,
                              NULL,
                              0);

   alt_uCOSIIErrorHandler(error_code, 0);
 8201a24:	e0bfff03 	ldbu	r2,-4(fp)
 8201a28:	000b883a 	mov	r5,zero
 8201a2c:	1009883a 	mov	r4,r2
 8201a30:	82002480 	call	8200248 <alt_uCOSIIErrorHandler>

}
 8201a34:	0001883a 	nop
 8201a38:	e037883a 	mov	sp,fp
 8201a3c:	dfc00117 	ldw	ra,4(sp)
 8201a40:	df000017 	ldw	fp,0(sp)
 8201a44:	dec00204 	addi	sp,sp,8
 8201a48:	f800283a 	ret

08201a4c <sss_reset_connection>:
 * to a reliable initial state. Note that we set our socket (FD) number to
 * -1 to easily determine whether the connection is in a "reset, ready to go" 
 * state.
 */
void sss_reset_connection(SSSConn* conn)
{
 8201a4c:	defffd04 	addi	sp,sp,-12
 8201a50:	dfc00215 	stw	ra,8(sp)
 8201a54:	df000115 	stw	fp,4(sp)
 8201a58:	df000104 	addi	fp,sp,4
 8201a5c:	e13fff15 	stw	r4,-4(fp)
  memset(conn, 0, sizeof(SSSConn));
 8201a60:	01817c04 	movi	r6,1520
 8201a64:	000b883a 	mov	r5,zero
 8201a68:	e13fff17 	ldw	r4,-4(fp)
 8201a6c:	82031300 	call	8203130 <memset>

  conn->fd = -1;
 8201a70:	e0bfff17 	ldw	r2,-4(fp)
 8201a74:	00ffffc4 	movi	r3,-1
 8201a78:	10c00115 	stw	r3,4(r2)
  conn->state = READY;
 8201a7c:	e0bfff17 	ldw	r2,-4(fp)
 8201a80:	10000015 	stw	zero,0(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 8201a84:	e0bfff17 	ldw	r2,-4(fp)
 8201a88:	10c00304 	addi	r3,r2,12
 8201a8c:	e0bfff17 	ldw	r2,-4(fp)
 8201a90:	10c17b15 	stw	r3,1516(r2)
  conn->rx_rd_pos = conn->rx_buffer;
 8201a94:	e0bfff17 	ldw	r2,-4(fp)
 8201a98:	10c00304 	addi	r3,r2,12
 8201a9c:	e0bfff17 	ldw	r2,-4(fp)
 8201aa0:	10c17a15 	stw	r3,1512(r2)
  return;
 8201aa4:	0001883a 	nop
}
 8201aa8:	e037883a 	mov	sp,fp
 8201aac:	dfc00117 	ldw	ra,4(sp)
 8201ab0:	df000017 	ldw	fp,0(sp)
 8201ab4:	dec00204 	addi	sp,sp,8
 8201ab8:	f800283a 	ret

08201abc <sss_send_menu>:
 * sss_send_menu()
 * 
 * This routine will transmit the menu out to the telent client.
 */
void sss_send_menu(SSSConn* conn)
{
 8201abc:	defe8504 	addi	sp,sp,-1516
 8201ac0:	dfc17a15 	stw	ra,1512(sp)
 8201ac4:	df017915 	stw	fp,1508(sp)
 8201ac8:	df017904 	addi	fp,sp,1508
 8201acc:	e13fff15 	stw	r4,-4(fp)
  char  tx_buf[SSS_TX_BUF_SIZE];
  char *tx_wr_pos = tx_buf;
 8201ad0:	e0be8804 	addi	r2,fp,-1504
 8201ad4:	e0be8715 	stw	r2,-1508(fp)

  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 8201ad8:	e0fe8717 	ldw	r3,-1508(fp)
 8201adc:	00820974 	movhi	r2,2085
 8201ae0:	10b34c04 	addi	r2,r2,-13008
 8201ae4:	1009883a 	mov	r4,r2
 8201ae8:	00800904 	movi	r2,36
 8201aec:	100d883a 	mov	r6,r2
 8201af0:	200b883a 	mov	r5,r4
 8201af4:	1809883a 	mov	r4,r3
 8201af8:	8202e8c0 	call	8202e8c <memcpy>
 8201afc:	008008c4 	movi	r2,35
 8201b00:	1007883a 	mov	r3,r2
 8201b04:	e0be8717 	ldw	r2,-1508(fp)
 8201b08:	10c5883a 	add	r2,r2,r3
 8201b0c:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"ADC Socket Server Menu\n\r");
 8201b10:	e0fe8717 	ldw	r3,-1508(fp)
 8201b14:	00820974 	movhi	r2,2085
 8201b18:	10b35504 	addi	r2,r2,-12972
 8201b1c:	1009883a 	mov	r4,r2
 8201b20:	00800644 	movi	r2,25
 8201b24:	100d883a 	mov	r6,r2
 8201b28:	200b883a 	mov	r5,r4
 8201b2c:	1809883a 	mov	r4,r3
 8201b30:	8202e8c0 	call	8202e8c <memcpy>
 8201b34:	00800604 	movi	r2,24
 8201b38:	1007883a 	mov	r3,r2
 8201b3c:	e0be8717 	ldw	r2,-1508(fp)
 8201b40:	10c5883a 	add	r2,r2,r3
 8201b44:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 8201b48:	e0fe8717 	ldw	r3,-1508(fp)
 8201b4c:	00820974 	movhi	r2,2085
 8201b50:	10b34c04 	addi	r2,r2,-13008
 8201b54:	1009883a 	mov	r4,r2
 8201b58:	00800904 	movi	r2,36
 8201b5c:	100d883a 	mov	r6,r2
 8201b60:	200b883a 	mov	r5,r4
 8201b64:	1809883a 	mov	r4,r3
 8201b68:	8202e8c0 	call	8202e8c <memcpy>
 8201b6c:	008008c4 	movi	r2,35
 8201b70:	1007883a 	mov	r3,r2
 8201b74:	e0be8717 	ldw	r2,-1508(fp)
 8201b78:	10c5883a 	add	r2,r2,r3
 8201b7c:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"ACQUIRE      - output most recent trigger\n\r");
 8201b80:	e0fe8717 	ldw	r3,-1508(fp)
 8201b84:	00820974 	movhi	r2,2085
 8201b88:	10b35c04 	addi	r2,r2,-12944
 8201b8c:	1009883a 	mov	r4,r2
 8201b90:	00800b04 	movi	r2,44
 8201b94:	100d883a 	mov	r6,r2
 8201b98:	200b883a 	mov	r5,r4
 8201b9c:	1809883a 	mov	r4,r3
 8201ba0:	8202e8c0 	call	8202e8c <memcpy>
 8201ba4:	00800ac4 	movi	r2,43
 8201ba8:	1007883a 	mov	r3,r2
 8201bac:	e0be8717 	ldw	r2,-1508(fp)
 8201bb0:	10c5883a 	add	r2,r2,r3
 8201bb4:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"TRIG:SLOPE:  - Set trigger slope: POS or NEG\n\r");
 8201bb8:	e0fe8717 	ldw	r3,-1508(fp)
 8201bbc:	00820974 	movhi	r2,2085
 8201bc0:	10b36704 	addi	r2,r2,-12900
 8201bc4:	1009883a 	mov	r4,r2
 8201bc8:	00800bc4 	movi	r2,47
 8201bcc:	100d883a 	mov	r6,r2
 8201bd0:	200b883a 	mov	r5,r4
 8201bd4:	1809883a 	mov	r4,r3
 8201bd8:	8202e8c0 	call	8202e8c <memcpy>
 8201bdc:	00800b84 	movi	r2,46
 8201be0:	1007883a 	mov	r3,r2
 8201be4:	e0be8717 	ldw	r2,-1508(fp)
 8201be8:	10c5883a 	add	r2,r2,r3
 8201bec:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"TRIG:SOURCE: - Set trigger source: SELF or EXT\n\r");
 8201bf0:	e0fe8717 	ldw	r3,-1508(fp)
 8201bf4:	00820974 	movhi	r2,2085
 8201bf8:	10b37304 	addi	r2,r2,-12852
 8201bfc:	1009883a 	mov	r4,r2
 8201c00:	00800c44 	movi	r2,49
 8201c04:	100d883a 	mov	r6,r2
 8201c08:	200b883a 	mov	r5,r4
 8201c0c:	1809883a 	mov	r4,r3
 8201c10:	8202e8c0 	call	8202e8c <memcpy>
 8201c14:	00800c04 	movi	r2,48
 8201c18:	1007883a 	mov	r3,r2
 8201c1c:	e0be8717 	ldw	r2,-1508(fp)
 8201c20:	10c5883a 	add	r2,r2,r3
 8201c24:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"DELAY:       - Set delay: ON or OFF\n\r");
 8201c28:	e0fe8717 	ldw	r3,-1508(fp)
 8201c2c:	00820974 	movhi	r2,2085
 8201c30:	10b38004 	addi	r2,r2,-12800
 8201c34:	1009883a 	mov	r4,r2
 8201c38:	00800984 	movi	r2,38
 8201c3c:	100d883a 	mov	r6,r2
 8201c40:	200b883a 	mov	r5,r4
 8201c44:	1809883a 	mov	r4,r3
 8201c48:	8202e8c0 	call	8202e8c <memcpy>
 8201c4c:	00800944 	movi	r2,37
 8201c50:	1007883a 	mov	r3,r2
 8201c54:	e0be8717 	ldw	r2,-1508(fp)
 8201c58:	10c5883a 	add	r2,r2,r3
 8201c5c:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"MENU         - display this menu \n\r");
 8201c60:	e0fe8717 	ldw	r3,-1508(fp)
 8201c64:	00820974 	movhi	r2,2085
 8201c68:	10b38a04 	addi	r2,r2,-12760
 8201c6c:	1009883a 	mov	r4,r2
 8201c70:	00800904 	movi	r2,36
 8201c74:	100d883a 	mov	r6,r2
 8201c78:	200b883a 	mov	r5,r4
 8201c7c:	1809883a 	mov	r4,r3
 8201c80:	8202e8c0 	call	8202e8c <memcpy>
 8201c84:	008008c4 	movi	r2,35
 8201c88:	1007883a 	mov	r3,r2
 8201c8c:	e0be8717 	ldw	r2,-1508(fp)
 8201c90:	10c5883a 	add	r2,r2,r3
 8201c94:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"QUIT         - quit \n\r");
 8201c98:	e0fe8717 	ldw	r3,-1508(fp)
 8201c9c:	00820974 	movhi	r2,2085
 8201ca0:	10b39304 	addi	r2,r2,-12724
 8201ca4:	1009883a 	mov	r4,r2
 8201ca8:	008005c4 	movi	r2,23
 8201cac:	100d883a 	mov	r6,r2
 8201cb0:	200b883a 	mov	r5,r4
 8201cb4:	1809883a 	mov	r4,r3
 8201cb8:	8202e8c0 	call	8202e8c <memcpy>
 8201cbc:	00800584 	movi	r2,22
 8201cc0:	1007883a 	mov	r3,r2
 8201cc4:	e0be8717 	ldw	r2,-1508(fp)
 8201cc8:	10c5883a 	add	r2,r2,r3
 8201ccc:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 8201cd0:	e0fe8717 	ldw	r3,-1508(fp)
 8201cd4:	00820974 	movhi	r2,2085
 8201cd8:	10b34c04 	addi	r2,r2,-13008
 8201cdc:	1009883a 	mov	r4,r2
 8201ce0:	00800904 	movi	r2,36
 8201ce4:	100d883a 	mov	r6,r2
 8201ce8:	200b883a 	mov	r5,r4
 8201cec:	1809883a 	mov	r4,r3
 8201cf0:	8202e8c0 	call	8202e8c <memcpy>
 8201cf4:	008008c4 	movi	r2,35
 8201cf8:	1007883a 	mov	r3,r2
 8201cfc:	e0be8717 	ldw	r2,-1508(fp)
 8201d00:	10c5883a 	add	r2,r2,r3
 8201d04:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Enter your choice & press return:\n\r");
 8201d08:	e0fe8717 	ldw	r3,-1508(fp)
 8201d0c:	00820974 	movhi	r2,2085
 8201d10:	10b39904 	addi	r2,r2,-12700
 8201d14:	1009883a 	mov	r4,r2
 8201d18:	00800904 	movi	r2,36
 8201d1c:	100d883a 	mov	r6,r2
 8201d20:	200b883a 	mov	r5,r4
 8201d24:	1809883a 	mov	r4,r3
 8201d28:	8202e8c0 	call	8202e8c <memcpy>
 8201d2c:	008008c4 	movi	r2,35
 8201d30:	1007883a 	mov	r3,r2
 8201d34:	e0be8717 	ldw	r2,-1508(fp)
 8201d38:	10c5883a 	add	r2,r2,r3
 8201d3c:	e0be8715 	stw	r2,-1508(fp)

  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 8201d40:	e0bfff17 	ldw	r2,-4(fp)
 8201d44:	11000117 	ldw	r4,4(r2)
 8201d48:	e0fe8717 	ldw	r3,-1508(fp)
 8201d4c:	e0be8804 	addi	r2,fp,-1504
 8201d50:	1887c83a 	sub	r3,r3,r2
 8201d54:	e0be8804 	addi	r2,fp,-1504
 8201d58:	000f883a 	mov	r7,zero
 8201d5c:	180d883a 	mov	r6,r3
 8201d60:	100b883a 	mov	r5,r2
 8201d64:	82313f00 	call	82313f0 <t_send>
  
  return;
 8201d68:	0001883a 	nop
}
 8201d6c:	e037883a 	mov	sp,fp
 8201d70:	dfc00117 	ldw	ra,4(sp)
 8201d74:	df000017 	ldw	fp,0(sp)
 8201d78:	dec00204 	addi	sp,sp,8
 8201d7c:	f800283a 	ret

08201d80 <sss_handle_accept>:
 * reject the incoming request by immediately closing the new socket.
 * 
 * We'll also print out the client's IP address.
 */
void sss_handle_accept(int listen_socket, SSSConn* conn)
{
 8201d80:	defff604 	addi	sp,sp,-40
 8201d84:	dfc00915 	stw	ra,36(sp)
 8201d88:	df000815 	stw	fp,32(sp)
 8201d8c:	df000804 	addi	fp,sp,32
 8201d90:	e13ffe15 	stw	r4,-8(fp)
 8201d94:	e17fff15 	stw	r5,-4(fp)
  int                 socket, len;
  struct sockaddr_in  incoming_addr;

  len = sizeof(incoming_addr);
 8201d98:	00800404 	movi	r2,16
 8201d9c:	e0bff915 	stw	r2,-28(fp)

  if ((conn)->fd == -1)
 8201da0:	e0bfff17 	ldw	r2,-4(fp)
 8201da4:	10800117 	ldw	r2,4(r2)
 8201da8:	10bfffd8 	cmpnei	r2,r2,-1
 8201dac:	10001a1e 	bne	r2,zero,8201e18 <sss_handle_accept+0x98>
  {
     if((socket=accept(listen_socket,(struct sockaddr*)&incoming_addr,&len))<0)
 8201db0:	e0fff904 	addi	r3,fp,-28
 8201db4:	e0bffa04 	addi	r2,fp,-24
 8201db8:	180d883a 	mov	r6,r3
 8201dbc:	100b883a 	mov	r5,r2
 8201dc0:	e13ffe17 	ldw	r4,-8(fp)
 8201dc4:	8227bc40 	call	8227bc4 <bsd_accept>
 8201dc8:	e0bff815 	stw	r2,-32(fp)
 8201dcc:	e0bff817 	ldw	r2,-32(fp)
 8201dd0:	1000050e 	bge	r2,zero,8201de8 <sss_handle_accept+0x68>
     {
         alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,
 8201dd4:	01420974 	movhi	r5,2085
 8201dd8:	2973a204 	addi	r5,r5,-12664
 8201ddc:	01003fc4 	movi	r4,255
 8201de0:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
 8201de4:	00001306 	br	8201e34 <sss_handle_accept+0xb4>
         alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,
                                 "[sss_handle_accept] accept failed");
     }
     else
     {
        (conn)->fd = socket;
 8201de8:	e0bfff17 	ldw	r2,-4(fp)
 8201dec:	e0fff817 	ldw	r3,-32(fp)
 8201df0:	10c00115 	stw	r3,4(r2)
        sss_send_menu(conn);
 8201df4:	e13fff17 	ldw	r4,-4(fp)
 8201df8:	8201abc0 	call	8201abc <sss_send_menu>
        printf("[sss_handle_accept] accepted connection request from %s\n",
 8201dfc:	e13ffb17 	ldw	r4,-20(fp)
 8201e00:	822826c0 	call	822826c <bsd_inet_ntoa>
 8201e04:	100b883a 	mov	r5,r2
 8201e08:	01020974 	movhi	r4,2085
 8201e0c:	2133ab04 	addi	r4,r4,-12628
 8201e10:	820331c0 	call	820331c <printf>
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
 8201e14:	00000706 	br	8201e34 <sss_handle_accept+0xb4>
               inet_ntoa(incoming_addr.sin_addr));
     }
  }
  else
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
 8201e18:	e13ffb17 	ldw	r4,-20(fp)
 8201e1c:	822826c0 	call	822826c <bsd_inet_ntoa>
 8201e20:	100b883a 	mov	r5,r2
 8201e24:	01020974 	movhi	r4,2085
 8201e28:	2133ba04 	addi	r4,r4,-12568
 8201e2c:	820331c0 	call	820331c <printf>
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
 8201e30:	0001883a 	nop
}
 8201e34:	e037883a 	mov	sp,fp
 8201e38:	dfc00117 	ldw	ra,4(sp)
 8201e3c:	df000017 	ldw	fp,0(sp)
 8201e40:	dec00204 	addi	sp,sp,8
 8201e44:	f800283a 	ret

08201e48 <sss_exec_command>:
 * If the user wishes to quit, we set the "close" member of our SSSConn
 * struct, which will be looked at back in sss_handle_receive() when it 
 * comes time to see whether to close the connection or not.
 */
void sss_exec_command(SSSConn* conn)
{
 8201e48:	defb9104 	addi	sp,sp,-4540
 8201e4c:	dfc46e15 	stw	ra,4536(sp)
 8201e50:	df046d15 	stw	fp,4532(sp)
 8201e54:	df046d04 	addi	fp,sp,4532
 8201e58:	e13fff15 	stw	r4,-4(fp)
   int bytes_to_process = conn->rx_wr_pos - conn->rx_rd_pos;
 8201e5c:	e0bfff17 	ldw	r2,-4(fp)
 8201e60:	10817b17 	ldw	r2,1516(r2)
 8201e64:	1007883a 	mov	r3,r2
 8201e68:	e0bfff17 	ldw	r2,-4(fp)
 8201e6c:	10817a17 	ldw	r2,1512(r2)
 8201e70:	1885c83a 	sub	r2,r3,r2
 8201e74:	e0bb9315 	stw	r2,-4532(fp)

   char  tx_buf[SSS_TX_BUF_SIZE];
   char *tx_wr_pos = tx_buf;
 8201e78:	e0bb9a04 	addi	r2,fp,-4504
 8201e7c:	e0bb9415 	stw	r2,-4528(fp)

   char text_buf[SSS_TX_BUF_SIZE];
   char *text = text_buf;
 8201e80:	e0bd1104 	addi	r2,fp,-3004
 8201e84:	e0bb9515 	stw	r2,-4524(fp)
    * SSSSimpleSocketServerTask, since the LEDManagementTask does not 
    * have access to the stack of the SSSSimpleSocketServerTask.
    */
   static INT32U SSSCommand;
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;
 8201e88:	00800c04 	movi	r2,48
 8201e8c:	d0a05915 	stw	r2,-32412(gp)

   while(bytes_to_process--) {
 8201e90:	00002206 	br	8201f1c <sss_exec_command+0xd4>
      SSSCommand = tolower(*(conn->rx_rd_pos++));
 8201e94:	e0bfff17 	ldw	r2,-4(fp)
 8201e98:	10817a17 	ldw	r2,1512(r2)
 8201e9c:	11000044 	addi	r4,r2,1
 8201ea0:	e0ffff17 	ldw	r3,-4(fp)
 8201ea4:	19017a15 	stw	r4,1512(r3)
 8201ea8:	10800003 	ldbu	r2,0(r2)
 8201eac:	e0bb9885 	stb	r2,-4510(fp)
 8201eb0:	d0e00017 	ldw	r3,-32768(gp)
 8201eb4:	e0bb9883 	ldbu	r2,-4510(fp)
 8201eb8:	10800044 	addi	r2,r2,1
 8201ebc:	1885883a 	add	r2,r3,r2
 8201ec0:	10800003 	ldbu	r2,0(r2)
 8201ec4:	10803fcc 	andi	r2,r2,255
 8201ec8:	108000cc 	andi	r2,r2,3
 8201ecc:	10800058 	cmpnei	r2,r2,1
 8201ed0:	1000031e 	bne	r2,zero,8201ee0 <sss_exec_command+0x98>
 8201ed4:	e0bb9883 	ldbu	r2,-4510(fp)
 8201ed8:	10800804 	addi	r2,r2,32
 8201edc:	00000106 	br	8201ee4 <sss_exec_command+0x9c>
 8201ee0:	e0bb9883 	ldbu	r2,-4510(fp)
 8201ee4:	d0a05915 	stw	r2,-32412(gp)
	  text += sprintf(text,"%c",(char)SSSCommand);
 8201ee8:	d0a05917 	ldw	r2,-32412(gp)
 8201eec:	10803fcc 	andi	r2,r2,255
 8201ef0:	1080201c 	xori	r2,r2,128
 8201ef4:	10bfe004 	addi	r2,r2,-128
 8201ef8:	100d883a 	mov	r6,r2
 8201efc:	01420974 	movhi	r5,2085
 8201f00:	2973c904 	addi	r5,r5,-12508
 8201f04:	e13b9517 	ldw	r4,-4524(fp)
 8201f08:	82036940 	call	8203694 <sprintf>
 8201f0c:	1007883a 	mov	r3,r2
 8201f10:	e0bb9517 	ldw	r2,-4524(fp)
 8201f14:	10c5883a 	add	r2,r2,r3
 8201f18:	e0bb9515 	stw	r2,-4524(fp)
    */
   static INT32U SSSCommand;
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;

   while(bytes_to_process--) {
 8201f1c:	e0bb9317 	ldw	r2,-4532(fp)
 8201f20:	10ffffc4 	addi	r3,r2,-1
 8201f24:	e0fb9315 	stw	r3,-4532(fp)
 8201f28:	103fda1e 	bne	r2,zero,8201e94 <sss_exec_command+0x4c>
      SSSCommand = tolower(*(conn->rx_rd_pos++));
	  text += sprintf(text,"%c",(char)SSSCommand);
   }

   alt_u8 startValue = IORD_ALTERA_AVALON_PIO_DATA(ADC_CONTROL_BASE);
 8201f2c:	00824034 	movhi	r2,2304
 8201f30:	10801004 	addi	r2,r2,64
 8201f34:	10800037 	ldwio	r2,0(r2)
 8201f38:	e0bb98c5 	stb	r2,-4509(fp)

   alt_u8 endValue = startValue;
 8201f3c:	e0bb98c3 	ldbu	r2,-4509(fp)
 8201f40:	e0bb9605 	stb	r2,-4520(fp)

   if(strstr(text_buf, "acquire") != NULL){
 8201f44:	e0bd1104 	addi	r2,fp,-3004
 8201f48:	01420974 	movhi	r5,2085
 8201f4c:	2973ca04 	addi	r5,r5,-12504
 8201f50:	1009883a 	mov	r4,r2
 8201f54:	82044280 	call	8204428 <strstr>
 8201f58:	10006b26 	beq	r2,zero,8202108 <sss_exec_command+0x2c0>
	   endValue ^= (-1 ^ endValue) & (1 << 0);
 8201f5c:	e0bb9603 	ldbu	r2,-4520(fp)
 8201f60:	1080004c 	andi	r2,r2,1
 8201f64:	1005003a 	cmpeq	r2,r2,zero
 8201f68:	1007883a 	mov	r3,r2
 8201f6c:	e0bb9603 	ldbu	r2,-4520(fp)
 8201f70:	1884f03a 	xor	r2,r3,r2
 8201f74:	e0bb9605 	stb	r2,-4520(fp)


	   IOWR_ALTERA_AVALON_PIO_DATA(ADC_CONTROL_BASE, endValue);
 8201f78:	e0fb9603 	ldbu	r3,-4520(fp)
 8201f7c:	00824034 	movhi	r2,2304
 8201f80:	10801004 	addi	r2,r2,64
 8201f84:	10c00035 	stwio	r3,0(r2)


	   char  tx_buf_data[SSS_TX_BUF_SIZE];
	   char *tx_wr_pos_data = tx_buf_data;
 8201f88:	e0be8804 	addi	r2,fp,-1504
 8201f8c:	e0bb9715 	stw	r2,-4516(fp)

	   //loop over the waveform
	   for(alt_u16 i=1; i<=1000; i++){
 8201f90:	00800044 	movi	r2,1
 8201f94:	e0bb980d 	sth	r2,-4512(fp)
 8201f98:	00002c06 	br	820204c <sss_exec_command+0x204>

		   //request the ith sample of the waveform
		   IOWR_ALTERA_AVALON_PIO_DATA(SAMPLENUM_BASE, i);
 8201f9c:	e0fb980b 	ldhu	r3,-4512(fp)
 8201fa0:	00824034 	movhi	r2,2304
 8201fa4:	10801804 	addi	r2,r2,96
 8201fa8:	10c00035 	stwio	r3,0(r2)

		   //usleep(10);

		   alt_u16 sample = IORD_ALTERA_AVALON_PIO_DATA(WAVESAMPLE_BASE);
 8201fac:	00824034 	movhi	r2,2304
 8201fb0:	10801404 	addi	r2,r2,80
 8201fb4:	10800037 	ldwio	r2,0(r2)
 8201fb8:	e0bb990d 	sth	r2,-4508(fp)

		   //printf("%d\t", i);
		   //printf("%d\n", sample);

		   tx_wr_pos_data += sprintf(tx_wr_pos_data, "%d\n", sample);
 8201fbc:	e0bb990b 	ldhu	r2,-4508(fp)
 8201fc0:	100d883a 	mov	r6,r2
 8201fc4:	01420974 	movhi	r5,2085
 8201fc8:	2973cc04 	addi	r5,r5,-12496
 8201fcc:	e13b9717 	ldw	r4,-4516(fp)
 8201fd0:	82036940 	call	8203694 <sprintf>
 8201fd4:	1007883a 	mov	r3,r2
 8201fd8:	e0bb9717 	ldw	r2,-4516(fp)
 8201fdc:	10c5883a 	add	r2,r2,r3
 8201fe0:	e0bb9715 	stw	r2,-4516(fp)

		   //send data every 100 samples.
		   if(i%100==0){
 8201fe4:	e0bb980b 	ldhu	r2,-4512(fp)
 8201fe8:	01401904 	movi	r5,100
 8201fec:	1009883a 	mov	r4,r2
 8201ff0:	8202bf00 	call	8202bf0 <__umodsi3>
 8201ff4:	10bfffcc 	andi	r2,r2,65535
 8201ff8:	1000111e 	bne	r2,zero,8202040 <sss_exec_command+0x1f8>
			   send(conn->fd, tx_buf_data, tx_wr_pos_data - tx_buf_data, 0);
 8201ffc:	e0bfff17 	ldw	r2,-4(fp)
 8202000:	11000117 	ldw	r4,4(r2)
 8202004:	e0fb9717 	ldw	r3,-4516(fp)
 8202008:	e0be8804 	addi	r2,fp,-1504
 820200c:	1887c83a 	sub	r3,r3,r2
 8202010:	e0be8804 	addi	r2,fp,-1504
 8202014:	000f883a 	mov	r7,zero
 8202018:	180d883a 	mov	r6,r3
 820201c:	100b883a 	mov	r5,r2
 8202020:	82313f00 	call	82313f0 <t_send>

			   memset(tx_buf_data, 0, sizeof tx_buf_data);
 8202024:	e0be8804 	addi	r2,fp,-1504
 8202028:	01817704 	movi	r6,1500
 820202c:	000b883a 	mov	r5,zero
 8202030:	1009883a 	mov	r4,r2
 8202034:	82031300 	call	8203130 <memset>
			   tx_wr_pos_data = tx_buf_data;
 8202038:	e0be8804 	addi	r2,fp,-1504
 820203c:	e0bb9715 	stw	r2,-4516(fp)

	   char  tx_buf_data[SSS_TX_BUF_SIZE];
	   char *tx_wr_pos_data = tx_buf_data;

	   //loop over the waveform
	   for(alt_u16 i=1; i<=1000; i++){
 8202040:	e0bb980b 	ldhu	r2,-4512(fp)
 8202044:	10800044 	addi	r2,r2,1
 8202048:	e0bb980d 	sth	r2,-4512(fp)
 820204c:	e0bb980b 	ldhu	r2,-4512(fp)
 8202050:	1080fa70 	cmpltui	r2,r2,1001
 8202054:	103fd11e 	bne	r2,zero,8201f9c <sss_exec_command+0x154>
			   tx_wr_pos_data = tx_buf_data;

		   }

	   }
	   IOWR_ALTERA_AVALON_PIO_DATA(SAMPLENUM_BASE, 1001);
 8202058:	00c0fa44 	movi	r3,1001
 820205c:	00824034 	movhi	r2,2304
 8202060:	10801804 	addi	r2,r2,96
 8202064:	10c00035 	stwio	r3,0(r2)
	   //usleep(10);
	   alt_u16 waveNum = IORD_ALTERA_AVALON_PIO_DATA(WAVESAMPLE_BASE);
 8202068:	00824034 	movhi	r2,2304
 820206c:	10801404 	addi	r2,r2,80
 8202070:	10800037 	ldwio	r2,0(r2)
 8202074:	e0bb998d 	sth	r2,-4506(fp)
	   //printf("%d\n", waveNum);


	   IOWR_ALTERA_AVALON_PIO_DATA(SAMPLENUM_BASE, 0);
 8202078:	0007883a 	mov	r3,zero
 820207c:	00824034 	movhi	r2,2304
 8202080:	10801804 	addi	r2,r2,96
 8202084:	10c00035 	stwio	r3,0(r2)

	   memset(tx_buf_data, 0, sizeof tx_buf_data);
 8202088:	e0be8804 	addi	r2,fp,-1504
 820208c:	01817704 	movi	r6,1500
 8202090:	000b883a 	mov	r5,zero
 8202094:	1009883a 	mov	r4,r2
 8202098:	82031300 	call	8203130 <memset>
	   tx_wr_pos_data = tx_buf_data;
 820209c:	e0be8804 	addi	r2,fp,-1504
 82020a0:	e0bb9715 	stw	r2,-4516(fp)

	   tx_wr_pos_data += sprintf(tx_wr_pos_data, "%d\ncomplete\n",waveNum);
 82020a4:	e0bb998b 	ldhu	r2,-4506(fp)
 82020a8:	100d883a 	mov	r6,r2
 82020ac:	01420974 	movhi	r5,2085
 82020b0:	2973cd04 	addi	r5,r5,-12492
 82020b4:	e13b9717 	ldw	r4,-4516(fp)
 82020b8:	82036940 	call	8203694 <sprintf>
 82020bc:	1007883a 	mov	r3,r2
 82020c0:	e0bb9717 	ldw	r2,-4516(fp)
 82020c4:	10c5883a 	add	r2,r2,r3
 82020c8:	e0bb9715 	stw	r2,-4516(fp)

	   send(conn->fd, tx_buf_data, tx_wr_pos_data - tx_buf_data, 0);
 82020cc:	e0bfff17 	ldw	r2,-4(fp)
 82020d0:	11000117 	ldw	r4,4(r2)
 82020d4:	e0fb9717 	ldw	r3,-4516(fp)
 82020d8:	e0be8804 	addi	r2,fp,-1504
 82020dc:	1887c83a 	sub	r3,r3,r2
 82020e0:	e0be8804 	addi	r2,fp,-1504
 82020e4:	000f883a 	mov	r7,zero
 82020e8:	180d883a 	mov	r6,r3
 82020ec:	100b883a 	mov	r5,r2
 82020f0:	82313f00 	call	82313f0 <t_send>

	   //reset the control pio

	   endValue ^= (-0 ^ endValue) & (1 << 0);
 82020f4:	e0fb9603 	ldbu	r3,-4520(fp)
 82020f8:	00bfff84 	movi	r2,-2
 82020fc:	1884703a 	and	r2,r3,r2
 8202100:	e0bb9605 	stb	r2,-4520(fp)
 8202104:	00016606 	br	82026a0 <sss_exec_command+0x858>
   } else if( strstr(text_buf, "delay")) {
 8202108:	e0bd1104 	addi	r2,fp,-3004
 820210c:	01420974 	movhi	r5,2085
 8202110:	2973d104 	addi	r5,r5,-12476
 8202114:	1009883a 	mov	r4,r2
 8202118:	82044280 	call	8204428 <strstr>
 820211c:	10004d26 	beq	r2,zero,8202254 <sss_exec_command+0x40c>
	   if ( strstr(text_buf, ":on")){
 8202120:	e0bd1104 	addi	r2,fp,-3004
 8202124:	01420974 	movhi	r5,2085
 8202128:	2973d304 	addi	r5,r5,-12468
 820212c:	1009883a 	mov	r4,r2
 8202130:	82044280 	call	8204428 <strstr>
 8202134:	10001626 	beq	r2,zero,8202190 <sss_exec_command+0x348>
		   tx_wr_pos += sprintf(tx_wr_pos, "Enabling delay\n");
 8202138:	e0fb9417 	ldw	r3,-4528(fp)
 820213c:	00820974 	movhi	r2,2085
 8202140:	10b3d404 	addi	r2,r2,-12464
 8202144:	1009883a 	mov	r4,r2
 8202148:	00800404 	movi	r2,16
 820214c:	100d883a 	mov	r6,r2
 8202150:	200b883a 	mov	r5,r4
 8202154:	1809883a 	mov	r4,r3
 8202158:	8202e8c0 	call	8202e8c <memcpy>
 820215c:	008003c4 	movi	r2,15
 8202160:	1007883a 	mov	r3,r2
 8202164:	e0bb9417 	ldw	r2,-4528(fp)
 8202168:	10c5883a 	add	r2,r2,r3
 820216c:	e0bb9415 	stw	r2,-4528(fp)
		   endValue ^= (-1 ^ endValue) & (1 << 3);
 8202170:	e0bb9603 	ldbu	r2,-4520(fp)
 8202174:	0084303a 	nor	r2,zero,r2
 8202178:	1080020c 	andi	r2,r2,8
 820217c:	1007883a 	mov	r3,r2
 8202180:	e0bb9603 	ldbu	r2,-4520(fp)
 8202184:	1884f03a 	xor	r2,r3,r2
 8202188:	e0bb9605 	stb	r2,-4520(fp)
 820218c:	00014406 	br	82026a0 <sss_exec_command+0x858>

	   } else if ( strstr(text_buf, ":off")){
 8202190:	e0bd1104 	addi	r2,fp,-3004
 8202194:	01420974 	movhi	r5,2085
 8202198:	2973d804 	addi	r5,r5,-12448
 820219c:	1009883a 	mov	r4,r2
 82021a0:	82044280 	call	8204428 <strstr>
 82021a4:	10001326 	beq	r2,zero,82021f4 <sss_exec_command+0x3ac>
		   tx_wr_pos += sprintf(tx_wr_pos, "Disabling delay\n");
 82021a8:	e0fb9417 	ldw	r3,-4528(fp)
 82021ac:	00820974 	movhi	r2,2085
 82021b0:	10b3da04 	addi	r2,r2,-12440
 82021b4:	1009883a 	mov	r4,r2
 82021b8:	00800444 	movi	r2,17
 82021bc:	100d883a 	mov	r6,r2
 82021c0:	200b883a 	mov	r5,r4
 82021c4:	1809883a 	mov	r4,r3
 82021c8:	8202e8c0 	call	8202e8c <memcpy>
 82021cc:	00800404 	movi	r2,16
 82021d0:	1007883a 	mov	r3,r2
 82021d4:	e0bb9417 	ldw	r2,-4528(fp)
 82021d8:	10c5883a 	add	r2,r2,r3
 82021dc:	e0bb9415 	stw	r2,-4528(fp)
		   endValue ^= (-0 ^ endValue) & (1 << 3);
 82021e0:	e0fb9603 	ldbu	r3,-4520(fp)
 82021e4:	00bffdc4 	movi	r2,-9
 82021e8:	1884703a 	and	r2,r3,r2
 82021ec:	e0bb9605 	stb	r2,-4520(fp)
 82021f0:	00012b06 	br	82026a0 <sss_exec_command+0x858>
	   } else if ( strstr(text_buf, ":toggle")){
 82021f4:	e0bd1104 	addi	r2,fp,-3004
 82021f8:	01420974 	movhi	r5,2085
 82021fc:	2973df04 	addi	r5,r5,-12420
 8202200:	1009883a 	mov	r4,r2
 8202204:	82044280 	call	8204428 <strstr>
 8202208:	10012526 	beq	r2,zero,82026a0 <sss_exec_command+0x858>
		   tx_wr_pos += sprintf(tx_wr_pos, "Toggling delay\n");
 820220c:	e0fb9417 	ldw	r3,-4528(fp)
 8202210:	00820974 	movhi	r2,2085
 8202214:	10b3e104 	addi	r2,r2,-12412
 8202218:	1009883a 	mov	r4,r2
 820221c:	00800404 	movi	r2,16
 8202220:	100d883a 	mov	r6,r2
 8202224:	200b883a 	mov	r5,r4
 8202228:	1809883a 	mov	r4,r3
 820222c:	8202e8c0 	call	8202e8c <memcpy>
 8202230:	008003c4 	movi	r2,15
 8202234:	1007883a 	mov	r3,r2
 8202238:	e0bb9417 	ldw	r2,-4528(fp)
 820223c:	10c5883a 	add	r2,r2,r3
 8202240:	e0bb9415 	stw	r2,-4528(fp)
		   endValue ^= 1 << 3;
 8202244:	e0bb9603 	ldbu	r2,-4520(fp)
 8202248:	1080021c 	xori	r2,r2,8
 820224c:	e0bb9605 	stb	r2,-4520(fp)
 8202250:	00011306 	br	82026a0 <sss_exec_command+0x858>
	   }


   } else if( strstr(text_buf, "trig")) {
 8202254:	e0bd1104 	addi	r2,fp,-3004
 8202258:	01420974 	movhi	r5,2085
 820225c:	2973e504 	addi	r5,r5,-12396
 8202260:	1009883a 	mov	r4,r2
 8202264:	82044280 	call	8204428 <strstr>
 8202268:	1000b926 	beq	r2,zero,8202550 <sss_exec_command+0x708>
	   if( strstr(text_buf, ":source")) {
 820226c:	e0bd1104 	addi	r2,fp,-3004
 8202270:	01420974 	movhi	r5,2085
 8202274:	2973e704 	addi	r5,r5,-12388
 8202278:	1009883a 	mov	r4,r2
 820227c:	82044280 	call	8204428 <strstr>
 8202280:	10006026 	beq	r2,zero,8202404 <sss_exec_command+0x5bc>
	   	   if ( strstr(text_buf, ":self")){
 8202284:	e0bd1104 	addi	r2,fp,-3004
 8202288:	01420974 	movhi	r5,2085
 820228c:	2973e904 	addi	r5,r5,-12380
 8202290:	1009883a 	mov	r4,r2
 8202294:	82044280 	call	8204428 <strstr>
 8202298:	10002926 	beq	r2,zero,8202340 <sss_exec_command+0x4f8>
			   tx_wr_pos += sprintf(tx_wr_pos, "Self trigger\n");
 820229c:	e0bb9417 	ldw	r2,-4528(fp)
 82022a0:	00c014c4 	movi	r3,83
 82022a4:	10c00005 	stb	r3,0(r2)
 82022a8:	00c01944 	movi	r3,101
 82022ac:	10c00045 	stb	r3,1(r2)
 82022b0:	00c01b04 	movi	r3,108
 82022b4:	10c00085 	stb	r3,2(r2)
 82022b8:	00c01984 	movi	r3,102
 82022bc:	10c000c5 	stb	r3,3(r2)
 82022c0:	00c00804 	movi	r3,32
 82022c4:	10c00105 	stb	r3,4(r2)
 82022c8:	00c01d04 	movi	r3,116
 82022cc:	10c00145 	stb	r3,5(r2)
 82022d0:	00c01c84 	movi	r3,114
 82022d4:	10c00185 	stb	r3,6(r2)
 82022d8:	00c01a44 	movi	r3,105
 82022dc:	10c001c5 	stb	r3,7(r2)
 82022e0:	00c019c4 	movi	r3,103
 82022e4:	10c00205 	stb	r3,8(r2)
 82022e8:	00c019c4 	movi	r3,103
 82022ec:	10c00245 	stb	r3,9(r2)
 82022f0:	00c01944 	movi	r3,101
 82022f4:	10c00285 	stb	r3,10(r2)
 82022f8:	00c01c84 	movi	r3,114
 82022fc:	10c002c5 	stb	r3,11(r2)
 8202300:	00c00284 	movi	r3,10
 8202304:	10c00305 	stb	r3,12(r2)
 8202308:	10000345 	stb	zero,13(r2)
 820230c:	00800344 	movi	r2,13
 8202310:	1007883a 	mov	r3,r2
 8202314:	e0bb9417 	ldw	r2,-4528(fp)
 8202318:	10c5883a 	add	r2,r2,r3
 820231c:	e0bb9415 	stw	r2,-4528(fp)
	   		   endValue ^= (-1 ^ endValue) & (1 << 1);
 8202320:	e0bb9603 	ldbu	r2,-4520(fp)
 8202324:	0084303a 	nor	r2,zero,r2
 8202328:	1080008c 	andi	r2,r2,2
 820232c:	1007883a 	mov	r3,r2
 8202330:	e0bb9603 	ldbu	r2,-4520(fp)
 8202334:	1884f03a 	xor	r2,r3,r2
 8202338:	e0bb9605 	stb	r2,-4520(fp)
 820233c:	0000d806 	br	82026a0 <sss_exec_command+0x858>

	   	   } else if ( strstr(text_buf, ":ext")){
 8202340:	e0bd1104 	addi	r2,fp,-3004
 8202344:	01420974 	movhi	r5,2085
 8202348:	2973eb04 	addi	r5,r5,-12372
 820234c:	1009883a 	mov	r4,r2
 8202350:	82044280 	call	8204428 <strstr>
 8202354:	10001326 	beq	r2,zero,82023a4 <sss_exec_command+0x55c>
			   tx_wr_pos += sprintf(tx_wr_pos, "External trigger\n");
 8202358:	e0fb9417 	ldw	r3,-4528(fp)
 820235c:	00820974 	movhi	r2,2085
 8202360:	10b3ed04 	addi	r2,r2,-12364
 8202364:	1009883a 	mov	r4,r2
 8202368:	00800484 	movi	r2,18
 820236c:	100d883a 	mov	r6,r2
 8202370:	200b883a 	mov	r5,r4
 8202374:	1809883a 	mov	r4,r3
 8202378:	8202e8c0 	call	8202e8c <memcpy>
 820237c:	00800444 	movi	r2,17
 8202380:	1007883a 	mov	r3,r2
 8202384:	e0bb9417 	ldw	r2,-4528(fp)
 8202388:	10c5883a 	add	r2,r2,r3
 820238c:	e0bb9415 	stw	r2,-4528(fp)
	   		   endValue ^= (-0 ^ endValue) & (1 << 1);
 8202390:	e0fb9603 	ldbu	r3,-4520(fp)
 8202394:	00bfff44 	movi	r2,-3
 8202398:	1884703a 	and	r2,r3,r2
 820239c:	e0bb9605 	stb	r2,-4520(fp)
 82023a0:	0000bf06 	br	82026a0 <sss_exec_command+0x858>
	   	   } else if ( strstr(text_buf, ":toggle")){
 82023a4:	e0bd1104 	addi	r2,fp,-3004
 82023a8:	01420974 	movhi	r5,2085
 82023ac:	2973df04 	addi	r5,r5,-12420
 82023b0:	1009883a 	mov	r4,r2
 82023b4:	82044280 	call	8204428 <strstr>
 82023b8:	1000b926 	beq	r2,zero,82026a0 <sss_exec_command+0x858>
			   	tx_wr_pos += sprintf(tx_wr_pos, "Toggling trigger source\n");
 82023bc:	e0fb9417 	ldw	r3,-4528(fp)
 82023c0:	00820974 	movhi	r2,2085
 82023c4:	10b3f204 	addi	r2,r2,-12344
 82023c8:	1009883a 	mov	r4,r2
 82023cc:	00800644 	movi	r2,25
 82023d0:	100d883a 	mov	r6,r2
 82023d4:	200b883a 	mov	r5,r4
 82023d8:	1809883a 	mov	r4,r3
 82023dc:	8202e8c0 	call	8202e8c <memcpy>
 82023e0:	00800604 	movi	r2,24
 82023e4:	1007883a 	mov	r3,r2
 82023e8:	e0bb9417 	ldw	r2,-4528(fp)
 82023ec:	10c5883a 	add	r2,r2,r3
 82023f0:	e0bb9415 	stw	r2,-4528(fp)
			   	endValue ^= 1 << 1;
 82023f4:	e0bb9603 	ldbu	r2,-4520(fp)
 82023f8:	1080009c 	xori	r2,r2,2
 82023fc:	e0bb9605 	stb	r2,-4520(fp)
 8202400:	0000a706 	br	82026a0 <sss_exec_command+0x858>
		   }
	   } else if( strstr(text_buf, ":slope")) {
 8202404:	e0bd1104 	addi	r2,fp,-3004
 8202408:	01420974 	movhi	r5,2085
 820240c:	2973f904 	addi	r5,r5,-12316
 8202410:	1009883a 	mov	r4,r2
 8202414:	82044280 	call	8204428 <strstr>
 8202418:	1000a126 	beq	r2,zero,82026a0 <sss_exec_command+0x858>
		   if ( strstr(text_buf, ":pos")){
 820241c:	e0bd1104 	addi	r2,fp,-3004
 8202420:	01420974 	movhi	r5,2085
 8202424:	2973fb04 	addi	r5,r5,-12308
 8202428:	1009883a 	mov	r4,r2
 820242c:	82044280 	call	8204428 <strstr>
 8202430:	10001626 	beq	r2,zero,820248c <sss_exec_command+0x644>
			   tx_wr_pos += sprintf(tx_wr_pos, "Positive trigger\n");
 8202434:	e0fb9417 	ldw	r3,-4528(fp)
 8202438:	00820974 	movhi	r2,2085
 820243c:	10b3fd04 	addi	r2,r2,-12300
 8202440:	1009883a 	mov	r4,r2
 8202444:	00800484 	movi	r2,18
 8202448:	100d883a 	mov	r6,r2
 820244c:	200b883a 	mov	r5,r4
 8202450:	1809883a 	mov	r4,r3
 8202454:	8202e8c0 	call	8202e8c <memcpy>
 8202458:	00800444 	movi	r2,17
 820245c:	1007883a 	mov	r3,r2
 8202460:	e0bb9417 	ldw	r2,-4528(fp)
 8202464:	10c5883a 	add	r2,r2,r3
 8202468:	e0bb9415 	stw	r2,-4528(fp)
			   endValue ^= (-1 ^ endValue) & (1 << 2);
 820246c:	e0bb9603 	ldbu	r2,-4520(fp)
 8202470:	0084303a 	nor	r2,zero,r2
 8202474:	1080010c 	andi	r2,r2,4
 8202478:	1007883a 	mov	r3,r2
 820247c:	e0bb9603 	ldbu	r2,-4520(fp)
 8202480:	1884f03a 	xor	r2,r3,r2
 8202484:	e0bb9605 	stb	r2,-4520(fp)
 8202488:	00008506 	br	82026a0 <sss_exec_command+0x858>

		   } else if ( strstr(text_buf, ":neg")){
 820248c:	e0bd1104 	addi	r2,fp,-3004
 8202490:	01420974 	movhi	r5,2085
 8202494:	29740204 	addi	r5,r5,-12280
 8202498:	1009883a 	mov	r4,r2
 820249c:	82044280 	call	8204428 <strstr>
 82024a0:	10001326 	beq	r2,zero,82024f0 <sss_exec_command+0x6a8>
			   tx_wr_pos += sprintf(tx_wr_pos, "negative trigger\n");
 82024a4:	e0fb9417 	ldw	r3,-4528(fp)
 82024a8:	00820974 	movhi	r2,2085
 82024ac:	10b40404 	addi	r2,r2,-12272
 82024b0:	1009883a 	mov	r4,r2
 82024b4:	00800484 	movi	r2,18
 82024b8:	100d883a 	mov	r6,r2
 82024bc:	200b883a 	mov	r5,r4
 82024c0:	1809883a 	mov	r4,r3
 82024c4:	8202e8c0 	call	8202e8c <memcpy>
 82024c8:	00800444 	movi	r2,17
 82024cc:	1007883a 	mov	r3,r2
 82024d0:	e0bb9417 	ldw	r2,-4528(fp)
 82024d4:	10c5883a 	add	r2,r2,r3
 82024d8:	e0bb9415 	stw	r2,-4528(fp)
			   endValue ^= (-0 ^ endValue) & (1 << 2);
 82024dc:	e0fb9603 	ldbu	r3,-4520(fp)
 82024e0:	00bffec4 	movi	r2,-5
 82024e4:	1884703a 	and	r2,r3,r2
 82024e8:	e0bb9605 	stb	r2,-4520(fp)
 82024ec:	00006c06 	br	82026a0 <sss_exec_command+0x858>
		   } else if ( strstr(text_buf, ":toggle")){
 82024f0:	e0bd1104 	addi	r2,fp,-3004
 82024f4:	01420974 	movhi	r5,2085
 82024f8:	2973df04 	addi	r5,r5,-12420
 82024fc:	1009883a 	mov	r4,r2
 8202500:	82044280 	call	8204428 <strstr>
 8202504:	10006626 	beq	r2,zero,82026a0 <sss_exec_command+0x858>
			   tx_wr_pos += sprintf(tx_wr_pos, "Toggling trigger slope\n");
 8202508:	e0fb9417 	ldw	r3,-4528(fp)
 820250c:	00820974 	movhi	r2,2085
 8202510:	10b40904 	addi	r2,r2,-12252
 8202514:	1009883a 	mov	r4,r2
 8202518:	00800604 	movi	r2,24
 820251c:	100d883a 	mov	r6,r2
 8202520:	200b883a 	mov	r5,r4
 8202524:	1809883a 	mov	r4,r3
 8202528:	8202e8c0 	call	8202e8c <memcpy>
 820252c:	008005c4 	movi	r2,23
 8202530:	1007883a 	mov	r3,r2
 8202534:	e0bb9417 	ldw	r2,-4528(fp)
 8202538:	10c5883a 	add	r2,r2,r3
 820253c:	e0bb9415 	stw	r2,-4528(fp)
			   endValue ^= 1 << 2;
 8202540:	e0bb9603 	ldbu	r2,-4520(fp)
 8202544:	1080011c 	xori	r2,r2,4
 8202548:	e0bb9605 	stb	r2,-4520(fp)
 820254c:	00005406 	br	82026a0 <sss_exec_command+0x858>
		   }
	   }
   } else if ( strstr(text_buf, "quit") != NULL){
 8202550:	e0bd1104 	addi	r2,fp,-3004
 8202554:	01420974 	movhi	r5,2085
 8202558:	29740f04 	addi	r5,r5,-12228
 820255c:	1009883a 	mov	r4,r2
 8202560:	82044280 	call	8204428 <strstr>
 8202564:	10001226 	beq	r2,zero,82025b0 <sss_exec_command+0x768>
	   tx_wr_pos += sprintf(tx_wr_pos,"Terminating connection.\n\n\r");
 8202568:	e0fb9417 	ldw	r3,-4528(fp)
 820256c:	00820974 	movhi	r2,2085
 8202570:	10b41104 	addi	r2,r2,-12220
 8202574:	1009883a 	mov	r4,r2
 8202578:	008006c4 	movi	r2,27
 820257c:	100d883a 	mov	r6,r2
 8202580:	200b883a 	mov	r5,r4
 8202584:	1809883a 	mov	r4,r3
 8202588:	8202e8c0 	call	8202e8c <memcpy>
 820258c:	00800684 	movi	r2,26
 8202590:	1007883a 	mov	r3,r2
 8202594:	e0bb9417 	ldw	r2,-4528(fp)
 8202598:	10c5883a 	add	r2,r2,r3
 820259c:	e0bb9415 	stw	r2,-4528(fp)
	   conn->close = 1;
 82025a0:	e0bfff17 	ldw	r2,-4(fp)
 82025a4:	00c00044 	movi	r3,1
 82025a8:	10c00215 	stw	r3,8(r2)
 82025ac:	00003c06 	br	82026a0 <sss_exec_command+0x858>
   } else if ( strstr(text_buf, "*rst") != NULL){
 82025b0:	e0bd1104 	addi	r2,fp,-3004
 82025b4:	01420974 	movhi	r5,2085
 82025b8:	29741804 	addi	r5,r5,-12192
 82025bc:	1009883a 	mov	r4,r2
 82025c0:	82044280 	call	8204428 <strstr>
 82025c4:	10001d26 	beq	r2,zero,820263c <sss_exec_command+0x7f4>
	   tx_wr_pos += sprintf(tx_wr_pos, "Resetting\n");
 82025c8:	e0bb9417 	ldw	r2,-4528(fp)
 82025cc:	00c01484 	movi	r3,82
 82025d0:	10c00005 	stb	r3,0(r2)
 82025d4:	00c01944 	movi	r3,101
 82025d8:	10c00045 	stb	r3,1(r2)
 82025dc:	00c01cc4 	movi	r3,115
 82025e0:	10c00085 	stb	r3,2(r2)
 82025e4:	00c01944 	movi	r3,101
 82025e8:	10c000c5 	stb	r3,3(r2)
 82025ec:	00c01d04 	movi	r3,116
 82025f0:	10c00105 	stb	r3,4(r2)
 82025f4:	00c01d04 	movi	r3,116
 82025f8:	10c00145 	stb	r3,5(r2)
 82025fc:	00c01a44 	movi	r3,105
 8202600:	10c00185 	stb	r3,6(r2)
 8202604:	00c01b84 	movi	r3,110
 8202608:	10c001c5 	stb	r3,7(r2)
 820260c:	00c019c4 	movi	r3,103
 8202610:	10c00205 	stb	r3,8(r2)
 8202614:	00c00284 	movi	r3,10
 8202618:	10c00245 	stb	r3,9(r2)
 820261c:	10000285 	stb	zero,10(r2)
 8202620:	00800284 	movi	r2,10
 8202624:	1007883a 	mov	r3,r2
 8202628:	e0bb9417 	ldw	r2,-4528(fp)
 820262c:	10c5883a 	add	r2,r2,r3
 8202630:	e0bb9415 	stw	r2,-4528(fp)
	   endValue=0;
 8202634:	e03b9605 	stb	zero,-4520(fp)
 8202638:	00001906 	br	82026a0 <sss_exec_command+0x858>

   } else if ( strstr(text_buf, "status") != NULL){
 820263c:	e0bd1104 	addi	r2,fp,-3004
 8202640:	01420974 	movhi	r5,2085
 8202644:	29741a04 	addi	r5,r5,-12184
 8202648:	1009883a 	mov	r4,r2
 820264c:	82044280 	call	8204428 <strstr>
 8202650:	10000b26 	beq	r2,zero,8202680 <sss_exec_command+0x838>
	   tx_wr_pos += sprintf(tx_wr_pos, "%ddone\n", startValue);
 8202654:	e0bb98c3 	ldbu	r2,-4509(fp)
 8202658:	100d883a 	mov	r6,r2
 820265c:	01420974 	movhi	r5,2085
 8202660:	29741c04 	addi	r5,r5,-12176
 8202664:	e13b9417 	ldw	r4,-4528(fp)
 8202668:	82036940 	call	8203694 <sprintf>
 820266c:	1007883a 	mov	r3,r2
 8202670:	e0bb9417 	ldw	r2,-4528(fp)
 8202674:	10c5883a 	add	r2,r2,r3
 8202678:	e0bb9415 	stw	r2,-4528(fp)
 820267c:	00000806 	br	82026a0 <sss_exec_command+0x858>

   } else if ( strstr(text_buf, "menu") != NULL){
 8202680:	e0bd1104 	addi	r2,fp,-3004
 8202684:	01420974 	movhi	r5,2085
 8202688:	29741e04 	addi	r5,r5,-12168
 820268c:	1009883a 	mov	r4,r2
 8202690:	82044280 	call	8204428 <strstr>
 8202694:	10000226 	beq	r2,zero,82026a0 <sss_exec_command+0x858>
	   sss_send_menu(conn);
 8202698:	e13fff17 	ldw	r4,-4(fp)
 820269c:	8201abc0 	call	8201abc <sss_send_menu>

   }



  IOWR_ALTERA_AVALON_PIO_DATA(ADC_CONTROL_BASE, endValue);
 82026a0:	e0fb9603 	ldbu	r3,-4520(fp)
 82026a4:	00824034 	movhi	r2,2304
 82026a8:	10801004 	addi	r2,r2,64
 82026ac:	10c00035 	stwio	r3,0(r2)


  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);  
 82026b0:	e0bfff17 	ldw	r2,-4(fp)
 82026b4:	11000117 	ldw	r4,4(r2)
 82026b8:	e0fb9417 	ldw	r3,-4528(fp)
 82026bc:	e0bb9a04 	addi	r2,fp,-4504
 82026c0:	1887c83a 	sub	r3,r3,r2
 82026c4:	e0bb9a04 	addi	r2,fp,-4504
 82026c8:	000f883a 	mov	r7,zero
 82026cc:	180d883a 	mov	r6,r3
 82026d0:	100b883a 	mov	r5,r2
 82026d4:	82313f00 	call	82313f0 <t_send>
  
  return;
 82026d8:	0001883a 	nop
}
 82026dc:	e037883a 	mov	sp,fp
 82026e0:	dfc00117 	ldw	ra,4(sp)
 82026e4:	df000017 	ldw	fp,0(sp)
 82026e8:	dec00204 	addi	sp,sp,8
 82026ec:	f800283a 	ret

082026f0 <sss_handle_receive>:
 * sss_exec_command() routine. Aside from these, we must move incoming
 * (un-processed) data to buffer start as appropriate and keep track of 
 * associated pointers.
 */
void sss_handle_receive(SSSConn* conn)
{
 82026f0:	defffa04 	addi	sp,sp,-24
 82026f4:	dfc00515 	stw	ra,20(sp)
 82026f8:	df000415 	stw	fp,16(sp)
 82026fc:	df000404 	addi	fp,sp,16
 8202700:	e13fff15 	stw	r4,-4(fp)
  int data_used = 0, rx_code = 0;
 8202704:	e03ffc15 	stw	zero,-16(fp)
 8202708:	e03ffd15 	stw	zero,-12(fp)
  char *lf_addr; 
  
  conn->rx_rd_pos = conn->rx_buffer;
 820270c:	e0bfff17 	ldw	r2,-4(fp)
 8202710:	10c00304 	addi	r3,r2,12
 8202714:	e0bfff17 	ldw	r2,-4(fp)
 8202718:	10c17a15 	stw	r3,1512(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 820271c:	e0bfff17 	ldw	r2,-4(fp)
 8202720:	10c00304 	addi	r3,r2,12
 8202724:	e0bfff17 	ldw	r2,-4(fp)
 8202728:	10c17b15 	stw	r3,1516(r2)
  
  printf("[sss_handle_receive] processing RX data\n");
 820272c:	01020974 	movhi	r4,2085
 8202730:	21342004 	addi	r4,r4,-12160
 8202734:	82035a00 	call	82035a0 <puts>
  
  while(conn->state != CLOSE)
 8202738:	00005606 	br	8202894 <sss_handle_receive+0x1a4>
  {
    /* Find the Carriage return which marks the end of the header */
    lf_addr = strchr((const char*)conn->rx_buffer, '\n');
 820273c:	e0bfff17 	ldw	r2,-4(fp)
 8202740:	10800304 	addi	r2,r2,12
 8202744:	01400284 	movi	r5,10
 8202748:	1009883a 	mov	r4,r2
 820274c:	82037000 	call	8203700 <strchr>
 8202750:	e0bffe15 	stw	r2,-8(fp)
      
    if(lf_addr)
 8202754:	e0bffe17 	ldw	r2,-8(fp)
 8202758:	10000326 	beq	r2,zero,8202768 <sss_handle_receive+0x78>
    {
      /* go off and do whatever the user wanted us to do */
      sss_exec_command(conn);
 820275c:	e13fff17 	ldw	r4,-4(fp)
 8202760:	8201e480 	call	8201e48 <sss_exec_command>
 8202764:	00001c06 	br	82027d8 <sss_handle_receive+0xe8>
    }
    /* No newline received? Then ask the socket for data */
    else
    {
      rx_code = recv(conn->fd, (char*)conn->rx_wr_pos, 
 8202768:	e0bfff17 	ldw	r2,-4(fp)
 820276c:	11000117 	ldw	r4,4(r2)
 8202770:	e0bfff17 	ldw	r2,-4(fp)
 8202774:	11417b17 	ldw	r5,1516(r2)
 8202778:	e0bfff17 	ldw	r2,-4(fp)
 820277c:	10817b17 	ldw	r2,1516(r2)
 8202780:	1007883a 	mov	r3,r2
 8202784:	e0bfff17 	ldw	r2,-4(fp)
 8202788:	10800304 	addi	r2,r2,12
 820278c:	1885c83a 	sub	r2,r3,r2
 8202790:	00c176c4 	movi	r3,1499
 8202794:	1885c83a 	sub	r2,r3,r2
 8202798:	000f883a 	mov	r7,zero
 820279c:	100d883a 	mov	r6,r2
 82027a0:	8230fdc0 	call	8230fdc <t_recv>
 82027a4:	e0bffd15 	stw	r2,-12(fp)
        SSS_RX_BUF_SIZE - (conn->rx_wr_pos - conn->rx_buffer) -1, 0);
          
     if(rx_code > 0)
 82027a8:	e0bffd17 	ldw	r2,-12(fp)
 82027ac:	00800a0e 	bge	zero,r2,82027d8 <sss_handle_receive+0xe8>
      {
        conn->rx_wr_pos += rx_code;
 82027b0:	e0bfff17 	ldw	r2,-4(fp)
 82027b4:	10c17b17 	ldw	r3,1516(r2)
 82027b8:	e0bffd17 	ldw	r2,-12(fp)
 82027bc:	1887883a 	add	r3,r3,r2
 82027c0:	e0bfff17 	ldw	r2,-4(fp)
 82027c4:	10c17b15 	stw	r3,1516(r2)
        
        /* Zero terminate so we can use string functions */
        *(conn->rx_wr_pos+1) = 0;
 82027c8:	e0bfff17 	ldw	r2,-4(fp)
 82027cc:	10817b17 	ldw	r2,1516(r2)
 82027d0:	10800044 	addi	r2,r2,1
 82027d4:	10000005 	stb	zero,0(r2)

    /* 
     * When the quit command is received, update our connection state so that
     * we can exit the while() loop and close the connection
     */
    conn->state = conn->close ? CLOSE : READY;
 82027d8:	e0bfff17 	ldw	r2,-4(fp)
 82027dc:	10800217 	ldw	r2,8(r2)
 82027e0:	10000226 	beq	r2,zero,82027ec <sss_handle_receive+0xfc>
 82027e4:	00800084 	movi	r2,2
 82027e8:	00000106 	br	82027f0 <sss_handle_receive+0x100>
 82027ec:	0005883a 	mov	r2,zero
 82027f0:	e0ffff17 	ldw	r3,-4(fp)
 82027f4:	18800015 	stw	r2,0(r3)

    /* Manage buffer */
    data_used = conn->rx_rd_pos - conn->rx_buffer;
 82027f8:	e0bfff17 	ldw	r2,-4(fp)
 82027fc:	10817a17 	ldw	r2,1512(r2)
 8202800:	1007883a 	mov	r3,r2
 8202804:	e0bfff17 	ldw	r2,-4(fp)
 8202808:	10800304 	addi	r2,r2,12
 820280c:	1885c83a 	sub	r2,r3,r2
 8202810:	e0bffc15 	stw	r2,-16(fp)
    memmove(conn->rx_buffer, conn->rx_rd_pos, 
 8202814:	e0bfff17 	ldw	r2,-4(fp)
 8202818:	10c00304 	addi	r3,r2,12
 820281c:	e0bfff17 	ldw	r2,-4(fp)
 8202820:	11017a17 	ldw	r4,1512(r2)
       conn->rx_wr_pos - conn->rx_rd_pos);
 8202824:	e0bfff17 	ldw	r2,-4(fp)
 8202828:	10817b17 	ldw	r2,1516(r2)
 820282c:	100b883a 	mov	r5,r2
 8202830:	e0bfff17 	ldw	r2,-4(fp)
 8202834:	10817a17 	ldw	r2,1512(r2)
 8202838:	2885c83a 	sub	r2,r5,r2
     */
    conn->state = conn->close ? CLOSE : READY;

    /* Manage buffer */
    data_used = conn->rx_rd_pos - conn->rx_buffer;
    memmove(conn->rx_buffer, conn->rx_rd_pos, 
 820283c:	100d883a 	mov	r6,r2
 8202840:	200b883a 	mov	r5,r4
 8202844:	1809883a 	mov	r4,r3
 8202848:	8202fd40 	call	8202fd4 <memmove>
       conn->rx_wr_pos - conn->rx_rd_pos);
    conn->rx_rd_pos = conn->rx_buffer;
 820284c:	e0bfff17 	ldw	r2,-4(fp)
 8202850:	10c00304 	addi	r3,r2,12
 8202854:	e0bfff17 	ldw	r2,-4(fp)
 8202858:	10c17a15 	stw	r3,1512(r2)
    conn->rx_wr_pos -= data_used;
 820285c:	e0bfff17 	ldw	r2,-4(fp)
 8202860:	10c17b17 	ldw	r3,1516(r2)
 8202864:	e0bffc17 	ldw	r2,-16(fp)
 8202868:	0085c83a 	sub	r2,zero,r2
 820286c:	1887883a 	add	r3,r3,r2
 8202870:	e0bfff17 	ldw	r2,-4(fp)
 8202874:	10c17b15 	stw	r3,1516(r2)
    memset(conn->rx_wr_pos, 0, data_used);
 8202878:	e0bfff17 	ldw	r2,-4(fp)
 820287c:	10817b17 	ldw	r2,1516(r2)
 8202880:	e0fffc17 	ldw	r3,-16(fp)
 8202884:	180d883a 	mov	r6,r3
 8202888:	000b883a 	mov	r5,zero
 820288c:	1009883a 	mov	r4,r2
 8202890:	82031300 	call	8203130 <memset>
  conn->rx_rd_pos = conn->rx_buffer;
  conn->rx_wr_pos = conn->rx_buffer;
  
  printf("[sss_handle_receive] processing RX data\n");
  
  while(conn->state != CLOSE)
 8202894:	e0bfff17 	ldw	r2,-4(fp)
 8202898:	10800017 	ldw	r2,0(r2)
 820289c:	10800098 	cmpnei	r2,r2,2
 82028a0:	103fa61e 	bne	r2,zero,820273c <sss_handle_receive+0x4c>
    conn->rx_rd_pos = conn->rx_buffer;
    conn->rx_wr_pos -= data_used;
    memset(conn->rx_wr_pos, 0, data_used);
  }

  printf("[sss_handle_receive] closing connection\n");
 82028a4:	01020974 	movhi	r4,2085
 82028a8:	21342a04 	addi	r4,r4,-12120
 82028ac:	82035a00 	call	82035a0 <puts>
  close(conn->fd);
 82028b0:	e0bfff17 	ldw	r2,-4(fp)
 82028b4:	10800117 	ldw	r2,4(r2)
 82028b8:	1009883a 	mov	r4,r2
 82028bc:	82257740 	call	8225774 <close>
  sss_reset_connection(conn);
 82028c0:	e13fff17 	ldw	r4,-4(fp)
 82028c4:	8201a4c0 	call	8201a4c <sss_reset_connection>
  
  return;
 82028c8:	0001883a 	nop
}
 82028cc:	e037883a 	mov	sp,fp
 82028d0:	dfc00117 	ldw	ra,4(sp)
 82028d4:	df000017 	ldw	fp,0(sp)
 82028d8:	dec00204 	addi	sp,sp,8
 82028dc:	f800283a 	ret

082028e0 <SSSSimpleSocketServerTask>:
 * (if a connection is active), the sss data socket. When data arrives, 
 * the approrpriate routine is called to either accept/reject a connection 
 * request, or process incoming data.
 */
void SSSSimpleSocketServerTask()
{
 82028e0:	deffb604 	addi	sp,sp,-296
 82028e4:	dfc04915 	stw	ra,292(sp)
 82028e8:	df004815 	stw	fp,288(sp)
 82028ec:	df004804 	addi	fp,sp,288
   * protocol and address families respectively. However, there is usually only
   * 1 address per protocol family. Thus PF_INET and AF_INET can be interchanged.
   * In the case of NicheStack, only the use of AF_INET is supported.
   * PF_INET is not supported in NicheStack.
   */ 
  if ((fd_listen = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 82028f0:	000d883a 	mov	r6,zero
 82028f4:	01400044 	movi	r5,1
 82028f8:	01000084 	movi	r4,2
 82028fc:	82302b00 	call	82302b0 <t_socket>
 8202900:	e0bfba15 	stw	r2,-280(fp)
 8202904:	e0bfba17 	ldw	r2,-280(fp)
 8202908:	1000040e 	bge	r2,zero,820291c <SSSSimpleSocketServerTask+0x3c>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Socket creation failed");
 820290c:	01420974 	movhi	r5,2085
 8202910:	29743404 	addi	r5,r5,-12080
 8202914:	01003fc4 	movi	r4,255
 8202918:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
   * port and incoming address. In this case we're binding to SSS_PORT and to
   * INADDR_ANY address (allowing anyone to connect to us. Bind may fail for 
   * various reasons, but the most common is that some other socket is bound to
   * the port we're requesting. 
   */ 
  addr.sin_family = AF_INET;
 820291c:	00800084 	movi	r2,2
 8202920:	e0bfbb0d 	sth	r2,-276(fp)
  addr.sin_port = htons(SSS_PORT);
 8202924:	00878004 	movi	r2,7680
 8202928:	e0bfbb8d 	sth	r2,-274(fp)
  addr.sin_addr.s_addr = INADDR_ANY;
 820292c:	e03fbc15 	stw	zero,-272(fp)
  
  if ((bind(fd_listen,(struct sockaddr *)&addr,sizeof(addr))) < 0)
 8202930:	e0bfbb04 	addi	r2,fp,-276
 8202934:	01800404 	movi	r6,16
 8202938:	100b883a 	mov	r5,r2
 820293c:	e13fba17 	ldw	r4,-280(fp)
 8202940:	82303300 	call	8230330 <t_bind>
 8202944:	1000040e 	bge	r2,zero,8202958 <SSSSimpleSocketServerTask+0x78>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Bind failed");
 8202948:	01420974 	movhi	r5,2085
 820294c:	29743d04 	addi	r5,r5,-12044
 8202950:	01003fc4 	movi	r4,255
 8202954:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
   * Sockets primer, continued...
   * The listen socket is a socket which is waiting for incoming connections.
   * This call to listen will block (i.e. not return) until someone tries to 
   * connect to this port.
   */ 
  if ((listen(fd_listen,1)) < 0)
 8202958:	01400044 	movi	r5,1
 820295c:	e13fba17 	ldw	r4,-280(fp)
 8202960:	82304940 	call	8230494 <t_listen>
 8202964:	1000040e 	bge	r2,zero,8202978 <SSSSimpleSocketServerTask+0x98>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Listen failed");
 8202968:	01420974 	movhi	r5,2085
 820296c:	29744304 	addi	r5,r5,-12020
 8202970:	01003fc4 	movi	r4,255
 8202974:	82007ac0 	call	82007ac <alt_NetworkErrorHandler>
  }

  /* At this point we have successfully created a socket which is listening
   * on SSS_PORT for connection requests from any remote address.
   */
  sss_reset_connection(&conn);
 8202978:	01020974 	movhi	r4,2085
 820297c:	21107d04 	addi	r4,r4,16884
 8202980:	8201a4c0 	call	8201a4c <sss_reset_connection>
  printf("[sss_task] Simple Socket Server listening on port %d\n", SSS_PORT);
 8202984:	01400784 	movi	r5,30
 8202988:	01020974 	movhi	r4,2085
 820298c:	21344a04 	addi	r4,r4,-11992
 8202990:	820331c0 	call	820331c <printf>
     * 
     *   FD_ZERO  - Zero's out the sockets we're interested in
     *   FD_SET   - Adds a socket to those we're interested in
     *   FD_ISSET - Tests whether the chosen socket is set 
     */
    FD_ZERO(&readfds);
 8202994:	e03fbf15 	stw	zero,-260(fp)
    FD_SET(fd_listen, &readfds);
 8202998:	e0bfbf04 	addi	r2,fp,-260
 820299c:	100b883a 	mov	r5,r2
 82029a0:	e13fba17 	ldw	r4,-280(fp)
 82029a4:	823529c0 	call	823529c <ifd_set>
    max_socket = fd_listen+1;
 82029a8:	e0bfba17 	ldw	r2,-280(fp)
 82029ac:	10800044 	addi	r2,r2,1
 82029b0:	e0bfb915 	stw	r2,-284(fp)

    if (conn.fd != -1)
 82029b4:	00820974 	movhi	r2,2085
 82029b8:	10907d04 	addi	r2,r2,16884
 82029bc:	10800117 	ldw	r2,4(r2)
 82029c0:	10bfffe0 	cmpeqi	r2,r2,-1
 82029c4:	1000111e 	bne	r2,zero,8202a0c <SSSSimpleSocketServerTask+0x12c>
    {
      FD_SET(conn.fd, &readfds);
 82029c8:	00820974 	movhi	r2,2085
 82029cc:	10907d04 	addi	r2,r2,16884
 82029d0:	10800117 	ldw	r2,4(r2)
 82029d4:	e0ffbf04 	addi	r3,fp,-260
 82029d8:	180b883a 	mov	r5,r3
 82029dc:	1009883a 	mov	r4,r2
 82029e0:	823529c0 	call	823529c <ifd_set>
      if (max_socket <= conn.fd)
 82029e4:	00820974 	movhi	r2,2085
 82029e8:	10907d04 	addi	r2,r2,16884
 82029ec:	10c00117 	ldw	r3,4(r2)
 82029f0:	e0bfb917 	ldw	r2,-284(fp)
 82029f4:	18800516 	blt	r3,r2,8202a0c <SSSSimpleSocketServerTask+0x12c>
      {
        max_socket = conn.fd+1;
 82029f8:	00820974 	movhi	r2,2085
 82029fc:	10907d04 	addi	r2,r2,16884
 8202a00:	10800117 	ldw	r2,4(r2)
 8202a04:	10800044 	addi	r2,r2,1
 8202a08:	e0bfb915 	stw	r2,-284(fp)
      }
    }

    select(max_socket, &readfds, NULL, NULL, NULL);
 8202a0c:	e0bfbf04 	addi	r2,fp,-260
 8202a10:	d8000015 	stw	zero,0(sp)
 8202a14:	000f883a 	mov	r7,zero
 8202a18:	000d883a 	mov	r6,zero
 8202a1c:	100b883a 	mov	r5,r2
 8202a20:	e13fb917 	ldw	r4,-284(fp)
 8202a24:	82283e80 	call	82283e8 <bsd_select>
     * is "set" in readfs, then we have an incoming connection request. We'll
     * call a routine to explicitly accept or deny the incoming connection 
     * request (in this example, we accept a single connection and reject any
     * others that come in while the connection is open).
     */
    if (FD_ISSET(fd_listen, &readfds))
 8202a28:	e0bfbf04 	addi	r2,fp,-260
 8202a2c:	100b883a 	mov	r5,r2
 8202a30:	e13fba17 	ldw	r4,-280(fp)
 8202a34:	82353140 	call	8235314 <ifd_isset>
 8202a38:	10000526 	beq	r2,zero,8202a50 <SSSSimpleSocketServerTask+0x170>
    {
      sss_handle_accept(fd_listen, &conn);
 8202a3c:	01420974 	movhi	r5,2085
 8202a40:	29507d04 	addi	r5,r5,16884
 8202a44:	e13fba17 	ldw	r4,-280(fp)
 8202a48:	8201d800 	call	8201d80 <sss_handle_accept>
 8202a4c:	003fd106 	br	8202994 <SSSSimpleSocketServerTask+0xb4>
     * incoming data for our sss server, and we call our receiver routine
     * to process it.
     */
    else
    {
      if ((conn.fd != -1) && FD_ISSET(conn.fd, &readfds))
 8202a50:	00820974 	movhi	r2,2085
 8202a54:	10907d04 	addi	r2,r2,16884
 8202a58:	10800117 	ldw	r2,4(r2)
 8202a5c:	10bfffe0 	cmpeqi	r2,r2,-1
 8202a60:	103fcc1e 	bne	r2,zero,8202994 <SSSSimpleSocketServerTask+0xb4>
 8202a64:	00820974 	movhi	r2,2085
 8202a68:	10907d04 	addi	r2,r2,16884
 8202a6c:	10800117 	ldw	r2,4(r2)
 8202a70:	e0ffbf04 	addi	r3,fp,-260
 8202a74:	180b883a 	mov	r5,r3
 8202a78:	1009883a 	mov	r4,r2
 8202a7c:	82353140 	call	8235314 <ifd_isset>
 8202a80:	103fc426 	beq	r2,zero,8202994 <SSSSimpleSocketServerTask+0xb4>
      {
        sss_handle_receive(&conn);
 8202a84:	01020974 	movhi	r4,2085
 8202a88:	21107d04 	addi	r4,r4,16884
 8202a8c:	82026f00 	call	82026f0 <sss_handle_receive>
      }
    }
  } /* while(1) */
 8202a90:	003fc006 	br	8202994 <SSSSimpleSocketServerTask+0xb4>

08202a94 <__divsi3>:
 8202a94:	20001b16 	blt	r4,zero,8202b04 <__divsi3+0x70>
 8202a98:	000f883a 	mov	r7,zero
 8202a9c:	28001616 	blt	r5,zero,8202af8 <__divsi3+0x64>
 8202aa0:	200d883a 	mov	r6,r4
 8202aa4:	29001a2e 	bgeu	r5,r4,8202b10 <__divsi3+0x7c>
 8202aa8:	00800804 	movi	r2,32
 8202aac:	00c00044 	movi	r3,1
 8202ab0:	00000106 	br	8202ab8 <__divsi3+0x24>
 8202ab4:	10000d26 	beq	r2,zero,8202aec <__divsi3+0x58>
 8202ab8:	294b883a 	add	r5,r5,r5
 8202abc:	10bfffc4 	addi	r2,r2,-1
 8202ac0:	18c7883a 	add	r3,r3,r3
 8202ac4:	293ffb36 	bltu	r5,r4,8202ab4 <__divsi3+0x20>
 8202ac8:	0005883a 	mov	r2,zero
 8202acc:	18000726 	beq	r3,zero,8202aec <__divsi3+0x58>
 8202ad0:	0005883a 	mov	r2,zero
 8202ad4:	31400236 	bltu	r6,r5,8202ae0 <__divsi3+0x4c>
 8202ad8:	314dc83a 	sub	r6,r6,r5
 8202adc:	10c4b03a 	or	r2,r2,r3
 8202ae0:	1806d07a 	srli	r3,r3,1
 8202ae4:	280ad07a 	srli	r5,r5,1
 8202ae8:	183ffa1e 	bne	r3,zero,8202ad4 <__divsi3+0x40>
 8202aec:	38000126 	beq	r7,zero,8202af4 <__divsi3+0x60>
 8202af0:	0085c83a 	sub	r2,zero,r2
 8202af4:	f800283a 	ret
 8202af8:	014bc83a 	sub	r5,zero,r5
 8202afc:	39c0005c 	xori	r7,r7,1
 8202b00:	003fe706 	br	8202aa0 <__divsi3+0xc>
 8202b04:	0109c83a 	sub	r4,zero,r4
 8202b08:	01c00044 	movi	r7,1
 8202b0c:	003fe306 	br	8202a9c <__divsi3+0x8>
 8202b10:	00c00044 	movi	r3,1
 8202b14:	003fee06 	br	8202ad0 <__divsi3+0x3c>

08202b18 <__modsi3>:
 8202b18:	20001716 	blt	r4,zero,8202b78 <__modsi3+0x60>
 8202b1c:	000f883a 	mov	r7,zero
 8202b20:	2005883a 	mov	r2,r4
 8202b24:	28001216 	blt	r5,zero,8202b70 <__modsi3+0x58>
 8202b28:	2900162e 	bgeu	r5,r4,8202b84 <__modsi3+0x6c>
 8202b2c:	01800804 	movi	r6,32
 8202b30:	00c00044 	movi	r3,1
 8202b34:	00000106 	br	8202b3c <__modsi3+0x24>
 8202b38:	30000a26 	beq	r6,zero,8202b64 <__modsi3+0x4c>
 8202b3c:	294b883a 	add	r5,r5,r5
 8202b40:	31bfffc4 	addi	r6,r6,-1
 8202b44:	18c7883a 	add	r3,r3,r3
 8202b48:	293ffb36 	bltu	r5,r4,8202b38 <__modsi3+0x20>
 8202b4c:	18000526 	beq	r3,zero,8202b64 <__modsi3+0x4c>
 8202b50:	1806d07a 	srli	r3,r3,1
 8202b54:	11400136 	bltu	r2,r5,8202b5c <__modsi3+0x44>
 8202b58:	1145c83a 	sub	r2,r2,r5
 8202b5c:	280ad07a 	srli	r5,r5,1
 8202b60:	183ffb1e 	bne	r3,zero,8202b50 <__modsi3+0x38>
 8202b64:	38000126 	beq	r7,zero,8202b6c <__modsi3+0x54>
 8202b68:	0085c83a 	sub	r2,zero,r2
 8202b6c:	f800283a 	ret
 8202b70:	014bc83a 	sub	r5,zero,r5
 8202b74:	003fec06 	br	8202b28 <__modsi3+0x10>
 8202b78:	0109c83a 	sub	r4,zero,r4
 8202b7c:	01c00044 	movi	r7,1
 8202b80:	003fe706 	br	8202b20 <__modsi3+0x8>
 8202b84:	00c00044 	movi	r3,1
 8202b88:	003ff106 	br	8202b50 <__modsi3+0x38>

08202b8c <__udivsi3>:
 8202b8c:	200d883a 	mov	r6,r4
 8202b90:	2900152e 	bgeu	r5,r4,8202be8 <__udivsi3+0x5c>
 8202b94:	28001416 	blt	r5,zero,8202be8 <__udivsi3+0x5c>
 8202b98:	00800804 	movi	r2,32
 8202b9c:	00c00044 	movi	r3,1
 8202ba0:	00000206 	br	8202bac <__udivsi3+0x20>
 8202ba4:	10000e26 	beq	r2,zero,8202be0 <__udivsi3+0x54>
 8202ba8:	28000516 	blt	r5,zero,8202bc0 <__udivsi3+0x34>
 8202bac:	294b883a 	add	r5,r5,r5
 8202bb0:	10bfffc4 	addi	r2,r2,-1
 8202bb4:	18c7883a 	add	r3,r3,r3
 8202bb8:	293ffa36 	bltu	r5,r4,8202ba4 <__udivsi3+0x18>
 8202bbc:	18000826 	beq	r3,zero,8202be0 <__udivsi3+0x54>
 8202bc0:	0005883a 	mov	r2,zero
 8202bc4:	31400236 	bltu	r6,r5,8202bd0 <__udivsi3+0x44>
 8202bc8:	314dc83a 	sub	r6,r6,r5
 8202bcc:	10c4b03a 	or	r2,r2,r3
 8202bd0:	1806d07a 	srli	r3,r3,1
 8202bd4:	280ad07a 	srli	r5,r5,1
 8202bd8:	183ffa1e 	bne	r3,zero,8202bc4 <__udivsi3+0x38>
 8202bdc:	f800283a 	ret
 8202be0:	0005883a 	mov	r2,zero
 8202be4:	f800283a 	ret
 8202be8:	00c00044 	movi	r3,1
 8202bec:	003ff406 	br	8202bc0 <__udivsi3+0x34>

08202bf0 <__umodsi3>:
 8202bf0:	2005883a 	mov	r2,r4
 8202bf4:	2900122e 	bgeu	r5,r4,8202c40 <__umodsi3+0x50>
 8202bf8:	28001116 	blt	r5,zero,8202c40 <__umodsi3+0x50>
 8202bfc:	01800804 	movi	r6,32
 8202c00:	00c00044 	movi	r3,1
 8202c04:	00000206 	br	8202c10 <__umodsi3+0x20>
 8202c08:	30000c26 	beq	r6,zero,8202c3c <__umodsi3+0x4c>
 8202c0c:	28000516 	blt	r5,zero,8202c24 <__umodsi3+0x34>
 8202c10:	294b883a 	add	r5,r5,r5
 8202c14:	31bfffc4 	addi	r6,r6,-1
 8202c18:	18c7883a 	add	r3,r3,r3
 8202c1c:	293ffa36 	bltu	r5,r4,8202c08 <__umodsi3+0x18>
 8202c20:	18000626 	beq	r3,zero,8202c3c <__umodsi3+0x4c>
 8202c24:	1806d07a 	srli	r3,r3,1
 8202c28:	11400136 	bltu	r2,r5,8202c30 <__umodsi3+0x40>
 8202c2c:	1145c83a 	sub	r2,r2,r5
 8202c30:	280ad07a 	srli	r5,r5,1
 8202c34:	183ffb1e 	bne	r3,zero,8202c24 <__umodsi3+0x34>
 8202c38:	f800283a 	ret
 8202c3c:	f800283a 	ret
 8202c40:	00c00044 	movi	r3,1
 8202c44:	003ff706 	br	8202c24 <__umodsi3+0x34>

08202c48 <_fprintf_r>:
 8202c48:	defffe04 	addi	sp,sp,-8
 8202c4c:	2809883a 	mov	r4,r5
 8202c50:	300b883a 	mov	r5,r6
 8202c54:	dfc00015 	stw	ra,0(sp)
 8202c58:	d9c00115 	stw	r7,4(sp)
 8202c5c:	d9800104 	addi	r6,sp,4
 8202c60:	8208bb00 	call	8208bb0 <__vfprintf_internal>
 8202c64:	dfc00017 	ldw	ra,0(sp)
 8202c68:	dec00204 	addi	sp,sp,8
 8202c6c:	f800283a 	ret

08202c70 <fprintf>:
 8202c70:	defffd04 	addi	sp,sp,-12
 8202c74:	dfc00015 	stw	ra,0(sp)
 8202c78:	d9800115 	stw	r6,4(sp)
 8202c7c:	d9c00215 	stw	r7,8(sp)
 8202c80:	d9800104 	addi	r6,sp,4
 8202c84:	8208bb00 	call	8208bb0 <__vfprintf_internal>
 8202c88:	dfc00017 	ldw	ra,0(sp)
 8202c8c:	dec00304 	addi	sp,sp,12
 8202c90:	f800283a 	ret

08202c94 <_fwrite_r>:
 8202c94:	defff504 	addi	sp,sp,-44
 8202c98:	dc800815 	stw	r18,32(sp)
 8202c9c:	39a5383a 	mul	r18,r7,r6
 8202ca0:	d8800304 	addi	r2,sp,12
 8202ca4:	d8800015 	stw	r2,0(sp)
 8202ca8:	00800044 	movi	r2,1
 8202cac:	dcc00915 	stw	r19,36(sp)
 8202cb0:	dc400715 	stw	r17,28(sp)
 8202cb4:	dc000615 	stw	r16,24(sp)
 8202cb8:	d9400315 	stw	r5,12(sp)
 8202cbc:	dfc00a15 	stw	ra,40(sp)
 8202cc0:	dc800415 	stw	r18,16(sp)
 8202cc4:	dc800215 	stw	r18,8(sp)
 8202cc8:	d8800115 	stw	r2,4(sp)
 8202ccc:	3027883a 	mov	r19,r6
 8202cd0:	3821883a 	mov	r16,r7
 8202cd4:	2023883a 	mov	r17,r4
 8202cd8:	d9400b17 	ldw	r5,44(sp)
 8202cdc:	20000226 	beq	r4,zero,8202ce8 <_fwrite_r+0x54>
 8202ce0:	20800e17 	ldw	r2,56(r4)
 8202ce4:	10001a26 	beq	r2,zero,8202d50 <_fwrite_r+0xbc>
 8202ce8:	2880030b 	ldhu	r2,12(r5)
 8202cec:	10c8000c 	andi	r3,r2,8192
 8202cf0:	1800061e 	bne	r3,zero,8202d0c <_fwrite_r+0x78>
 8202cf4:	29001917 	ldw	r4,100(r5)
 8202cf8:	00f7ffc4 	movi	r3,-8193
 8202cfc:	10880014 	ori	r2,r2,8192
 8202d00:	20c6703a 	and	r3,r4,r3
 8202d04:	2880030d 	sth	r2,12(r5)
 8202d08:	28c01915 	stw	r3,100(r5)
 8202d0c:	d80d883a 	mov	r6,sp
 8202d10:	8809883a 	mov	r4,r17
 8202d14:	820b38c0 	call	820b38c <__sfvwrite_r>
 8202d18:	10000b26 	beq	r2,zero,8202d48 <_fwrite_r+0xb4>
 8202d1c:	d9000217 	ldw	r4,8(sp)
 8202d20:	980b883a 	mov	r5,r19
 8202d24:	9109c83a 	sub	r4,r18,r4
 8202d28:	8202b8c0 	call	8202b8c <__udivsi3>
 8202d2c:	dfc00a17 	ldw	ra,40(sp)
 8202d30:	dcc00917 	ldw	r19,36(sp)
 8202d34:	dc800817 	ldw	r18,32(sp)
 8202d38:	dc400717 	ldw	r17,28(sp)
 8202d3c:	dc000617 	ldw	r16,24(sp)
 8202d40:	dec00b04 	addi	sp,sp,44
 8202d44:	f800283a 	ret
 8202d48:	8005883a 	mov	r2,r16
 8202d4c:	003ff706 	br	8202d2c <_fwrite_r+0x98>
 8202d50:	d9400515 	stw	r5,20(sp)
 8202d54:	820adb40 	call	820adb4 <__sinit>
 8202d58:	d9400517 	ldw	r5,20(sp)
 8202d5c:	003fe206 	br	8202ce8 <_fwrite_r+0x54>

08202d60 <fwrite>:
 8202d60:	defffe04 	addi	sp,sp,-8
 8202d64:	00820974 	movhi	r2,2085
 8202d68:	d9c00015 	stw	r7,0(sp)
 8202d6c:	108fa204 	addi	r2,r2,16008
 8202d70:	300f883a 	mov	r7,r6
 8202d74:	280d883a 	mov	r6,r5
 8202d78:	200b883a 	mov	r5,r4
 8202d7c:	11000017 	ldw	r4,0(r2)
 8202d80:	dfc00115 	stw	ra,4(sp)
 8202d84:	8202c940 	call	8202c94 <_fwrite_r>
 8202d88:	dfc00117 	ldw	ra,4(sp)
 8202d8c:	dec00204 	addi	sp,sp,8
 8202d90:	f800283a 	ret

08202d94 <_getc_r>:
 8202d94:	defffd04 	addi	sp,sp,-12
 8202d98:	dc000115 	stw	r16,4(sp)
 8202d9c:	dfc00215 	stw	ra,8(sp)
 8202da0:	2021883a 	mov	r16,r4
 8202da4:	20000226 	beq	r4,zero,8202db0 <_getc_r+0x1c>
 8202da8:	20800e17 	ldw	r2,56(r4)
 8202dac:	10000c26 	beq	r2,zero,8202de0 <_getc_r+0x4c>
 8202db0:	28800117 	ldw	r2,4(r5)
 8202db4:	10bfffc4 	addi	r2,r2,-1
 8202db8:	28800115 	stw	r2,4(r5)
 8202dbc:	10000c16 	blt	r2,zero,8202df0 <_getc_r+0x5c>
 8202dc0:	28800017 	ldw	r2,0(r5)
 8202dc4:	10c00044 	addi	r3,r2,1
 8202dc8:	28c00015 	stw	r3,0(r5)
 8202dcc:	10800003 	ldbu	r2,0(r2)
 8202dd0:	dfc00217 	ldw	ra,8(sp)
 8202dd4:	dc000117 	ldw	r16,4(sp)
 8202dd8:	dec00304 	addi	sp,sp,12
 8202ddc:	f800283a 	ret
 8202de0:	d9400015 	stw	r5,0(sp)
 8202de4:	820adb40 	call	820adb4 <__sinit>
 8202de8:	d9400017 	ldw	r5,0(sp)
 8202dec:	003ff006 	br	8202db0 <_getc_r+0x1c>
 8202df0:	8009883a 	mov	r4,r16
 8202df4:	dfc00217 	ldw	ra,8(sp)
 8202df8:	dc000117 	ldw	r16,4(sp)
 8202dfc:	dec00304 	addi	sp,sp,12
 8202e00:	82035b41 	jmpi	82035b4 <__srget_r>

08202e04 <getc>:
 8202e04:	00820974 	movhi	r2,2085
 8202e08:	defffd04 	addi	sp,sp,-12
 8202e0c:	108fa204 	addi	r2,r2,16008
 8202e10:	dc400115 	stw	r17,4(sp)
 8202e14:	14400017 	ldw	r17,0(r2)
 8202e18:	dc000015 	stw	r16,0(sp)
 8202e1c:	dfc00215 	stw	ra,8(sp)
 8202e20:	2021883a 	mov	r16,r4
 8202e24:	88000226 	beq	r17,zero,8202e30 <getc+0x2c>
 8202e28:	88800e17 	ldw	r2,56(r17)
 8202e2c:	10000d26 	beq	r2,zero,8202e64 <getc+0x60>
 8202e30:	80800117 	ldw	r2,4(r16)
 8202e34:	10bfffc4 	addi	r2,r2,-1
 8202e38:	80800115 	stw	r2,4(r16)
 8202e3c:	10000c16 	blt	r2,zero,8202e70 <getc+0x6c>
 8202e40:	80800017 	ldw	r2,0(r16)
 8202e44:	10c00044 	addi	r3,r2,1
 8202e48:	80c00015 	stw	r3,0(r16)
 8202e4c:	10800003 	ldbu	r2,0(r2)
 8202e50:	dfc00217 	ldw	ra,8(sp)
 8202e54:	dc400117 	ldw	r17,4(sp)
 8202e58:	dc000017 	ldw	r16,0(sp)
 8202e5c:	dec00304 	addi	sp,sp,12
 8202e60:	f800283a 	ret
 8202e64:	8809883a 	mov	r4,r17
 8202e68:	820adb40 	call	820adb4 <__sinit>
 8202e6c:	003ff006 	br	8202e30 <getc+0x2c>
 8202e70:	800b883a 	mov	r5,r16
 8202e74:	8809883a 	mov	r4,r17
 8202e78:	dfc00217 	ldw	ra,8(sp)
 8202e7c:	dc400117 	ldw	r17,4(sp)
 8202e80:	dc000017 	ldw	r16,0(sp)
 8202e84:	dec00304 	addi	sp,sp,12
 8202e88:	82035b41 	jmpi	82035b4 <__srget_r>

08202e8c <memcpy>:
 8202e8c:	defffd04 	addi	sp,sp,-12
 8202e90:	dfc00215 	stw	ra,8(sp)
 8202e94:	dc400115 	stw	r17,4(sp)
 8202e98:	dc000015 	stw	r16,0(sp)
 8202e9c:	00c003c4 	movi	r3,15
 8202ea0:	2005883a 	mov	r2,r4
 8202ea4:	1980452e 	bgeu	r3,r6,8202fbc <memcpy+0x130>
 8202ea8:	2906b03a 	or	r3,r5,r4
 8202eac:	18c000cc 	andi	r3,r3,3
 8202eb0:	1800441e 	bne	r3,zero,8202fc4 <memcpy+0x138>
 8202eb4:	347ffc04 	addi	r17,r6,-16
 8202eb8:	8822d13a 	srli	r17,r17,4
 8202ebc:	28c00104 	addi	r3,r5,4
 8202ec0:	23400104 	addi	r13,r4,4
 8202ec4:	8820913a 	slli	r16,r17,4
 8202ec8:	2b000204 	addi	r12,r5,8
 8202ecc:	22c00204 	addi	r11,r4,8
 8202ed0:	84000504 	addi	r16,r16,20
 8202ed4:	2a800304 	addi	r10,r5,12
 8202ed8:	22400304 	addi	r9,r4,12
 8202edc:	2c21883a 	add	r16,r5,r16
 8202ee0:	2811883a 	mov	r8,r5
 8202ee4:	200f883a 	mov	r7,r4
 8202ee8:	41000017 	ldw	r4,0(r8)
 8202eec:	1fc00017 	ldw	ra,0(r3)
 8202ef0:	63c00017 	ldw	r15,0(r12)
 8202ef4:	39000015 	stw	r4,0(r7)
 8202ef8:	53800017 	ldw	r14,0(r10)
 8202efc:	6fc00015 	stw	ra,0(r13)
 8202f00:	5bc00015 	stw	r15,0(r11)
 8202f04:	4b800015 	stw	r14,0(r9)
 8202f08:	18c00404 	addi	r3,r3,16
 8202f0c:	39c00404 	addi	r7,r7,16
 8202f10:	42000404 	addi	r8,r8,16
 8202f14:	6b400404 	addi	r13,r13,16
 8202f18:	63000404 	addi	r12,r12,16
 8202f1c:	5ac00404 	addi	r11,r11,16
 8202f20:	52800404 	addi	r10,r10,16
 8202f24:	4a400404 	addi	r9,r9,16
 8202f28:	1c3fef1e 	bne	r3,r16,8202ee8 <memcpy+0x5c>
 8202f2c:	89c00044 	addi	r7,r17,1
 8202f30:	380e913a 	slli	r7,r7,4
 8202f34:	310003cc 	andi	r4,r6,15
 8202f38:	02c000c4 	movi	r11,3
 8202f3c:	11c7883a 	add	r3,r2,r7
 8202f40:	29cb883a 	add	r5,r5,r7
 8202f44:	5900212e 	bgeu	r11,r4,8202fcc <memcpy+0x140>
 8202f48:	1813883a 	mov	r9,r3
 8202f4c:	2811883a 	mov	r8,r5
 8202f50:	200f883a 	mov	r7,r4
 8202f54:	42800017 	ldw	r10,0(r8)
 8202f58:	4a400104 	addi	r9,r9,4
 8202f5c:	39ffff04 	addi	r7,r7,-4
 8202f60:	4abfff15 	stw	r10,-4(r9)
 8202f64:	42000104 	addi	r8,r8,4
 8202f68:	59fffa36 	bltu	r11,r7,8202f54 <memcpy+0xc8>
 8202f6c:	213fff04 	addi	r4,r4,-4
 8202f70:	2008d0ba 	srli	r4,r4,2
 8202f74:	318000cc 	andi	r6,r6,3
 8202f78:	21000044 	addi	r4,r4,1
 8202f7c:	2109883a 	add	r4,r4,r4
 8202f80:	2109883a 	add	r4,r4,r4
 8202f84:	1907883a 	add	r3,r3,r4
 8202f88:	290b883a 	add	r5,r5,r4
 8202f8c:	30000626 	beq	r6,zero,8202fa8 <memcpy+0x11c>
 8202f90:	198d883a 	add	r6,r3,r6
 8202f94:	29c00003 	ldbu	r7,0(r5)
 8202f98:	18c00044 	addi	r3,r3,1
 8202f9c:	29400044 	addi	r5,r5,1
 8202fa0:	19ffffc5 	stb	r7,-1(r3)
 8202fa4:	19bffb1e 	bne	r3,r6,8202f94 <memcpy+0x108>
 8202fa8:	dfc00217 	ldw	ra,8(sp)
 8202fac:	dc400117 	ldw	r17,4(sp)
 8202fb0:	dc000017 	ldw	r16,0(sp)
 8202fb4:	dec00304 	addi	sp,sp,12
 8202fb8:	f800283a 	ret
 8202fbc:	2007883a 	mov	r3,r4
 8202fc0:	003ff206 	br	8202f8c <memcpy+0x100>
 8202fc4:	2007883a 	mov	r3,r4
 8202fc8:	003ff106 	br	8202f90 <memcpy+0x104>
 8202fcc:	200d883a 	mov	r6,r4
 8202fd0:	003fee06 	br	8202f8c <memcpy+0x100>

08202fd4 <memmove>:
 8202fd4:	2005883a 	mov	r2,r4
 8202fd8:	29000b2e 	bgeu	r5,r4,8203008 <memmove+0x34>
 8202fdc:	298f883a 	add	r7,r5,r6
 8202fe0:	21c0092e 	bgeu	r4,r7,8203008 <memmove+0x34>
 8202fe4:	2187883a 	add	r3,r4,r6
 8202fe8:	198bc83a 	sub	r5,r3,r6
 8202fec:	30004826 	beq	r6,zero,8203110 <memmove+0x13c>
 8202ff0:	39ffffc4 	addi	r7,r7,-1
 8202ff4:	39000003 	ldbu	r4,0(r7)
 8202ff8:	18ffffc4 	addi	r3,r3,-1
 8202ffc:	19000005 	stb	r4,0(r3)
 8203000:	28fffb1e 	bne	r5,r3,8202ff0 <memmove+0x1c>
 8203004:	f800283a 	ret
 8203008:	00c003c4 	movi	r3,15
 820300c:	1980412e 	bgeu	r3,r6,8203114 <memmove+0x140>
 8203010:	2886b03a 	or	r3,r5,r2
 8203014:	18c000cc 	andi	r3,r3,3
 8203018:	1800401e 	bne	r3,zero,820311c <memmove+0x148>
 820301c:	33fffc04 	addi	r15,r6,-16
 8203020:	781ed13a 	srli	r15,r15,4
 8203024:	28c00104 	addi	r3,r5,4
 8203028:	13400104 	addi	r13,r2,4
 820302c:	781c913a 	slli	r14,r15,4
 8203030:	2b000204 	addi	r12,r5,8
 8203034:	12c00204 	addi	r11,r2,8
 8203038:	73800504 	addi	r14,r14,20
 820303c:	2a800304 	addi	r10,r5,12
 8203040:	12400304 	addi	r9,r2,12
 8203044:	2b9d883a 	add	r14,r5,r14
 8203048:	2811883a 	mov	r8,r5
 820304c:	100f883a 	mov	r7,r2
 8203050:	41000017 	ldw	r4,0(r8)
 8203054:	39c00404 	addi	r7,r7,16
 8203058:	18c00404 	addi	r3,r3,16
 820305c:	393ffc15 	stw	r4,-16(r7)
 8203060:	193ffc17 	ldw	r4,-16(r3)
 8203064:	6b400404 	addi	r13,r13,16
 8203068:	5ac00404 	addi	r11,r11,16
 820306c:	693ffc15 	stw	r4,-16(r13)
 8203070:	61000017 	ldw	r4,0(r12)
 8203074:	4a400404 	addi	r9,r9,16
 8203078:	42000404 	addi	r8,r8,16
 820307c:	593ffc15 	stw	r4,-16(r11)
 8203080:	51000017 	ldw	r4,0(r10)
 8203084:	63000404 	addi	r12,r12,16
 8203088:	52800404 	addi	r10,r10,16
 820308c:	493ffc15 	stw	r4,-16(r9)
 8203090:	1bbfef1e 	bne	r3,r14,8203050 <memmove+0x7c>
 8203094:	79000044 	addi	r4,r15,1
 8203098:	2008913a 	slli	r4,r4,4
 820309c:	328003cc 	andi	r10,r6,15
 82030a0:	02c000c4 	movi	r11,3
 82030a4:	1107883a 	add	r3,r2,r4
 82030a8:	290b883a 	add	r5,r5,r4
 82030ac:	5a801e2e 	bgeu	r11,r10,8203128 <memmove+0x154>
 82030b0:	1813883a 	mov	r9,r3
 82030b4:	2811883a 	mov	r8,r5
 82030b8:	500f883a 	mov	r7,r10
 82030bc:	41000017 	ldw	r4,0(r8)
 82030c0:	4a400104 	addi	r9,r9,4
 82030c4:	39ffff04 	addi	r7,r7,-4
 82030c8:	493fff15 	stw	r4,-4(r9)
 82030cc:	42000104 	addi	r8,r8,4
 82030d0:	59fffa36 	bltu	r11,r7,82030bc <memmove+0xe8>
 82030d4:	513fff04 	addi	r4,r10,-4
 82030d8:	2008d0ba 	srli	r4,r4,2
 82030dc:	318000cc 	andi	r6,r6,3
 82030e0:	21000044 	addi	r4,r4,1
 82030e4:	2109883a 	add	r4,r4,r4
 82030e8:	2109883a 	add	r4,r4,r4
 82030ec:	1907883a 	add	r3,r3,r4
 82030f0:	290b883a 	add	r5,r5,r4
 82030f4:	30000b26 	beq	r6,zero,8203124 <memmove+0x150>
 82030f8:	198d883a 	add	r6,r3,r6
 82030fc:	29c00003 	ldbu	r7,0(r5)
 8203100:	18c00044 	addi	r3,r3,1
 8203104:	29400044 	addi	r5,r5,1
 8203108:	19ffffc5 	stb	r7,-1(r3)
 820310c:	19bffb1e 	bne	r3,r6,82030fc <memmove+0x128>
 8203110:	f800283a 	ret
 8203114:	1007883a 	mov	r3,r2
 8203118:	003ff606 	br	82030f4 <memmove+0x120>
 820311c:	1007883a 	mov	r3,r2
 8203120:	003ff506 	br	82030f8 <memmove+0x124>
 8203124:	f800283a 	ret
 8203128:	500d883a 	mov	r6,r10
 820312c:	003ff106 	br	82030f4 <memmove+0x120>

08203130 <memset>:
 8203130:	20c000cc 	andi	r3,r4,3
 8203134:	2005883a 	mov	r2,r4
 8203138:	18004426 	beq	r3,zero,820324c <memset+0x11c>
 820313c:	31ffffc4 	addi	r7,r6,-1
 8203140:	30004026 	beq	r6,zero,8203244 <memset+0x114>
 8203144:	2813883a 	mov	r9,r5
 8203148:	200d883a 	mov	r6,r4
 820314c:	2007883a 	mov	r3,r4
 8203150:	00000406 	br	8203164 <memset+0x34>
 8203154:	3a3fffc4 	addi	r8,r7,-1
 8203158:	31800044 	addi	r6,r6,1
 820315c:	38003926 	beq	r7,zero,8203244 <memset+0x114>
 8203160:	400f883a 	mov	r7,r8
 8203164:	18c00044 	addi	r3,r3,1
 8203168:	32400005 	stb	r9,0(r6)
 820316c:	1a0000cc 	andi	r8,r3,3
 8203170:	403ff81e 	bne	r8,zero,8203154 <memset+0x24>
 8203174:	010000c4 	movi	r4,3
 8203178:	21c02d2e 	bgeu	r4,r7,8203230 <memset+0x100>
 820317c:	29003fcc 	andi	r4,r5,255
 8203180:	200c923a 	slli	r6,r4,8
 8203184:	3108b03a 	or	r4,r6,r4
 8203188:	200c943a 	slli	r6,r4,16
 820318c:	218cb03a 	or	r6,r4,r6
 8203190:	010003c4 	movi	r4,15
 8203194:	21c0182e 	bgeu	r4,r7,82031f8 <memset+0xc8>
 8203198:	3b3ffc04 	addi	r12,r7,-16
 820319c:	6018d13a 	srli	r12,r12,4
 82031a0:	1a000104 	addi	r8,r3,4
 82031a4:	1ac00204 	addi	r11,r3,8
 82031a8:	6008913a 	slli	r4,r12,4
 82031ac:	1a800304 	addi	r10,r3,12
 82031b0:	1813883a 	mov	r9,r3
 82031b4:	21000504 	addi	r4,r4,20
 82031b8:	1909883a 	add	r4,r3,r4
 82031bc:	49800015 	stw	r6,0(r9)
 82031c0:	41800015 	stw	r6,0(r8)
 82031c4:	59800015 	stw	r6,0(r11)
 82031c8:	51800015 	stw	r6,0(r10)
 82031cc:	42000404 	addi	r8,r8,16
 82031d0:	4a400404 	addi	r9,r9,16
 82031d4:	5ac00404 	addi	r11,r11,16
 82031d8:	52800404 	addi	r10,r10,16
 82031dc:	413ff71e 	bne	r8,r4,82031bc <memset+0x8c>
 82031e0:	63000044 	addi	r12,r12,1
 82031e4:	6018913a 	slli	r12,r12,4
 82031e8:	39c003cc 	andi	r7,r7,15
 82031ec:	010000c4 	movi	r4,3
 82031f0:	1b07883a 	add	r3,r3,r12
 82031f4:	21c00e2e 	bgeu	r4,r7,8203230 <memset+0x100>
 82031f8:	1813883a 	mov	r9,r3
 82031fc:	3811883a 	mov	r8,r7
 8203200:	010000c4 	movi	r4,3
 8203204:	49800015 	stw	r6,0(r9)
 8203208:	423fff04 	addi	r8,r8,-4
 820320c:	4a400104 	addi	r9,r9,4
 8203210:	223ffc36 	bltu	r4,r8,8203204 <memset+0xd4>
 8203214:	393fff04 	addi	r4,r7,-4
 8203218:	2008d0ba 	srli	r4,r4,2
 820321c:	39c000cc 	andi	r7,r7,3
 8203220:	21000044 	addi	r4,r4,1
 8203224:	2109883a 	add	r4,r4,r4
 8203228:	2109883a 	add	r4,r4,r4
 820322c:	1907883a 	add	r3,r3,r4
 8203230:	38000526 	beq	r7,zero,8203248 <memset+0x118>
 8203234:	19cf883a 	add	r7,r3,r7
 8203238:	19400005 	stb	r5,0(r3)
 820323c:	18c00044 	addi	r3,r3,1
 8203240:	38fffd1e 	bne	r7,r3,8203238 <memset+0x108>
 8203244:	f800283a 	ret
 8203248:	f800283a 	ret
 820324c:	2007883a 	mov	r3,r4
 8203250:	300f883a 	mov	r7,r6
 8203254:	003fc706 	br	8203174 <memset+0x44>

08203258 <_perror_r>:
 8203258:	defffd04 	addi	sp,sp,-12
 820325c:	dc000115 	stw	r16,4(sp)
 8203260:	dfc00215 	stw	ra,8(sp)
 8203264:	2021883a 	mov	r16,r4
 8203268:	28000326 	beq	r5,zero,8203278 <_perror_r+0x20>
 820326c:	28c00007 	ldb	r3,0(r5)
 8203270:	2805883a 	mov	r2,r5
 8203274:	1800101e 	bne	r3,zero,82032b8 <_perror_r+0x60>
 8203278:	81400017 	ldw	r5,0(r16)
 820327c:	d80f883a 	mov	r7,sp
 8203280:	01800044 	movi	r6,1
 8203284:	8009883a 	mov	r4,r16
 8203288:	82038640 	call	8203864 <_strerror_r>
 820328c:	10000326 	beq	r2,zero,820329c <_perror_r+0x44>
 8203290:	81400317 	ldw	r5,12(r16)
 8203294:	1009883a 	mov	r4,r2
 8203298:	820af400 	call	820af40 <fputs>
 820329c:	81400317 	ldw	r5,12(r16)
 82032a0:	01000284 	movi	r4,10
 82032a4:	820ae480 	call	820ae48 <fputc>
 82032a8:	dfc00217 	ldw	ra,8(sp)
 82032ac:	dc000117 	ldw	r16,4(sp)
 82032b0:	dec00304 	addi	sp,sp,12
 82032b4:	f800283a 	ret
 82032b8:	21400317 	ldw	r5,12(r4)
 82032bc:	1009883a 	mov	r4,r2
 82032c0:	820af400 	call	820af40 <fputs>
 82032c4:	81400317 	ldw	r5,12(r16)
 82032c8:	01020974 	movhi	r4,2085
 82032cc:	21350104 	addi	r4,r4,-11260
 82032d0:	820af400 	call	820af40 <fputs>
 82032d4:	003fe806 	br	8203278 <_perror_r+0x20>

082032d8 <perror>:
 82032d8:	00820974 	movhi	r2,2085
 82032dc:	108fa204 	addi	r2,r2,16008
 82032e0:	200b883a 	mov	r5,r4
 82032e4:	11000017 	ldw	r4,0(r2)
 82032e8:	82032581 	jmpi	8203258 <_perror_r>

082032ec <_printf_r>:
 82032ec:	defffd04 	addi	sp,sp,-12
 82032f0:	2805883a 	mov	r2,r5
 82032f4:	dfc00015 	stw	ra,0(sp)
 82032f8:	d9800115 	stw	r6,4(sp)
 82032fc:	d9c00215 	stw	r7,8(sp)
 8203300:	21400217 	ldw	r5,8(r4)
 8203304:	d9c00104 	addi	r7,sp,4
 8203308:	100d883a 	mov	r6,r2
 820330c:	82069b80 	call	82069b8 <___vfprintf_internal_r>
 8203310:	dfc00017 	ldw	ra,0(sp)
 8203314:	dec00304 	addi	sp,sp,12
 8203318:	f800283a 	ret

0820331c <printf>:
 820331c:	defffc04 	addi	sp,sp,-16
 8203320:	dfc00015 	stw	ra,0(sp)
 8203324:	d9400115 	stw	r5,4(sp)
 8203328:	d9800215 	stw	r6,8(sp)
 820332c:	d9c00315 	stw	r7,12(sp)
 8203330:	00820974 	movhi	r2,2085
 8203334:	108fa204 	addi	r2,r2,16008
 8203338:	10800017 	ldw	r2,0(r2)
 820333c:	200b883a 	mov	r5,r4
 8203340:	d9800104 	addi	r6,sp,4
 8203344:	11000217 	ldw	r4,8(r2)
 8203348:	8208bb00 	call	8208bb0 <__vfprintf_internal>
 820334c:	dfc00017 	ldw	ra,0(sp)
 8203350:	dec00404 	addi	sp,sp,16
 8203354:	f800283a 	ret

08203358 <_putc_r>:
 8203358:	defffc04 	addi	sp,sp,-16
 820335c:	dc000215 	stw	r16,8(sp)
 8203360:	dfc00315 	stw	ra,12(sp)
 8203364:	2021883a 	mov	r16,r4
 8203368:	20000226 	beq	r4,zero,8203374 <_putc_r+0x1c>
 820336c:	20800e17 	ldw	r2,56(r4)
 8203370:	10001b26 	beq	r2,zero,82033e0 <_putc_r+0x88>
 8203374:	30800217 	ldw	r2,8(r6)
 8203378:	10bfffc4 	addi	r2,r2,-1
 820337c:	30800215 	stw	r2,8(r6)
 8203380:	10000a16 	blt	r2,zero,82033ac <_putc_r+0x54>
 8203384:	30800017 	ldw	r2,0(r6)
 8203388:	11400005 	stb	r5,0(r2)
 820338c:	30800017 	ldw	r2,0(r6)
 8203390:	10c00044 	addi	r3,r2,1
 8203394:	30c00015 	stw	r3,0(r6)
 8203398:	10800003 	ldbu	r2,0(r2)
 820339c:	dfc00317 	ldw	ra,12(sp)
 82033a0:	dc000217 	ldw	r16,8(sp)
 82033a4:	dec00404 	addi	sp,sp,16
 82033a8:	f800283a 	ret
 82033ac:	30c00617 	ldw	r3,24(r6)
 82033b0:	10c00616 	blt	r2,r3,82033cc <_putc_r+0x74>
 82033b4:	30800017 	ldw	r2,0(r6)
 82033b8:	00c00284 	movi	r3,10
 82033bc:	11400005 	stb	r5,0(r2)
 82033c0:	30800017 	ldw	r2,0(r6)
 82033c4:	11400003 	ldbu	r5,0(r2)
 82033c8:	28fff11e 	bne	r5,r3,8203390 <_putc_r+0x38>
 82033cc:	8009883a 	mov	r4,r16
 82033d0:	dfc00317 	ldw	ra,12(sp)
 82033d4:	dc000217 	ldw	r16,8(sp)
 82033d8:	dec00404 	addi	sp,sp,16
 82033dc:	8208c881 	jmpi	8208c88 <__swbuf_r>
 82033e0:	d9400015 	stw	r5,0(sp)
 82033e4:	d9800115 	stw	r6,4(sp)
 82033e8:	820adb40 	call	820adb4 <__sinit>
 82033ec:	d9800117 	ldw	r6,4(sp)
 82033f0:	d9400017 	ldw	r5,0(sp)
 82033f4:	003fdf06 	br	8203374 <_putc_r+0x1c>

082033f8 <putc>:
 82033f8:	00820974 	movhi	r2,2085
 82033fc:	defffc04 	addi	sp,sp,-16
 8203400:	108fa204 	addi	r2,r2,16008
 8203404:	dc000115 	stw	r16,4(sp)
 8203408:	14000017 	ldw	r16,0(r2)
 820340c:	dc400215 	stw	r17,8(sp)
 8203410:	dfc00315 	stw	ra,12(sp)
 8203414:	2023883a 	mov	r17,r4
 8203418:	80000226 	beq	r16,zero,8203424 <putc+0x2c>
 820341c:	80800e17 	ldw	r2,56(r16)
 8203420:	10001a26 	beq	r2,zero,820348c <putc+0x94>
 8203424:	28800217 	ldw	r2,8(r5)
 8203428:	10bfffc4 	addi	r2,r2,-1
 820342c:	28800215 	stw	r2,8(r5)
 8203430:	10000b16 	blt	r2,zero,8203460 <putc+0x68>
 8203434:	28800017 	ldw	r2,0(r5)
 8203438:	14400005 	stb	r17,0(r2)
 820343c:	28800017 	ldw	r2,0(r5)
 8203440:	10c00044 	addi	r3,r2,1
 8203444:	28c00015 	stw	r3,0(r5)
 8203448:	10800003 	ldbu	r2,0(r2)
 820344c:	dfc00317 	ldw	ra,12(sp)
 8203450:	dc400217 	ldw	r17,8(sp)
 8203454:	dc000117 	ldw	r16,4(sp)
 8203458:	dec00404 	addi	sp,sp,16
 820345c:	f800283a 	ret
 8203460:	28c00617 	ldw	r3,24(r5)
 8203464:	10c00e16 	blt	r2,r3,82034a0 <putc+0xa8>
 8203468:	28800017 	ldw	r2,0(r5)
 820346c:	01000284 	movi	r4,10
 8203470:	14400005 	stb	r17,0(r2)
 8203474:	28800017 	ldw	r2,0(r5)
 8203478:	10c00003 	ldbu	r3,0(r2)
 820347c:	193ff01e 	bne	r3,r4,8203440 <putc+0x48>
 8203480:	280d883a 	mov	r6,r5
 8203484:	180b883a 	mov	r5,r3
 8203488:	00000706 	br	82034a8 <putc+0xb0>
 820348c:	8009883a 	mov	r4,r16
 8203490:	d9400015 	stw	r5,0(sp)
 8203494:	820adb40 	call	820adb4 <__sinit>
 8203498:	d9400017 	ldw	r5,0(sp)
 820349c:	003fe106 	br	8203424 <putc+0x2c>
 82034a0:	280d883a 	mov	r6,r5
 82034a4:	880b883a 	mov	r5,r17
 82034a8:	8009883a 	mov	r4,r16
 82034ac:	dfc00317 	ldw	ra,12(sp)
 82034b0:	dc400217 	ldw	r17,8(sp)
 82034b4:	dc000117 	ldw	r16,4(sp)
 82034b8:	dec00404 	addi	sp,sp,16
 82034bc:	8208c881 	jmpi	8208c88 <__swbuf_r>

082034c0 <_putchar_r>:
 82034c0:	21800217 	ldw	r6,8(r4)
 82034c4:	82033581 	jmpi	8203358 <_putc_r>

082034c8 <putchar>:
 82034c8:	00820974 	movhi	r2,2085
 82034cc:	108fa204 	addi	r2,r2,16008
 82034d0:	200b883a 	mov	r5,r4
 82034d4:	11000017 	ldw	r4,0(r2)
 82034d8:	21800217 	ldw	r6,8(r4)
 82034dc:	82033581 	jmpi	8203358 <_putc_r>

082034e0 <_puts_r>:
 82034e0:	defff604 	addi	sp,sp,-40
 82034e4:	dc000715 	stw	r16,28(sp)
 82034e8:	2021883a 	mov	r16,r4
 82034ec:	2809883a 	mov	r4,r5
 82034f0:	dc400815 	stw	r17,32(sp)
 82034f4:	dfc00915 	stw	ra,36(sp)
 82034f8:	2823883a 	mov	r17,r5
 82034fc:	8203edc0 	call	8203edc <strlen>
 8203500:	10c00044 	addi	r3,r2,1
 8203504:	d8800115 	stw	r2,4(sp)
 8203508:	00820974 	movhi	r2,2085
 820350c:	10b50204 	addi	r2,r2,-11256
 8203510:	d8800215 	stw	r2,8(sp)
 8203514:	00800044 	movi	r2,1
 8203518:	d8800315 	stw	r2,12(sp)
 820351c:	00800084 	movi	r2,2
 8203520:	dc400015 	stw	r17,0(sp)
 8203524:	d8c00615 	stw	r3,24(sp)
 8203528:	dec00415 	stw	sp,16(sp)
 820352c:	d8800515 	stw	r2,20(sp)
 8203530:	80000226 	beq	r16,zero,820353c <_puts_r+0x5c>
 8203534:	80800e17 	ldw	r2,56(r16)
 8203538:	10001426 	beq	r2,zero,820358c <_puts_r+0xac>
 820353c:	81400217 	ldw	r5,8(r16)
 8203540:	2880030b 	ldhu	r2,12(r5)
 8203544:	10c8000c 	andi	r3,r2,8192
 8203548:	1800061e 	bne	r3,zero,8203564 <_puts_r+0x84>
 820354c:	29001917 	ldw	r4,100(r5)
 8203550:	00f7ffc4 	movi	r3,-8193
 8203554:	10880014 	ori	r2,r2,8192
 8203558:	20c6703a 	and	r3,r4,r3
 820355c:	2880030d 	sth	r2,12(r5)
 8203560:	28c01915 	stw	r3,100(r5)
 8203564:	d9800404 	addi	r6,sp,16
 8203568:	8009883a 	mov	r4,r16
 820356c:	820b38c0 	call	820b38c <__sfvwrite_r>
 8203570:	1000091e 	bne	r2,zero,8203598 <_puts_r+0xb8>
 8203574:	00800284 	movi	r2,10
 8203578:	dfc00917 	ldw	ra,36(sp)
 820357c:	dc400817 	ldw	r17,32(sp)
 8203580:	dc000717 	ldw	r16,28(sp)
 8203584:	dec00a04 	addi	sp,sp,40
 8203588:	f800283a 	ret
 820358c:	8009883a 	mov	r4,r16
 8203590:	820adb40 	call	820adb4 <__sinit>
 8203594:	003fe906 	br	820353c <_puts_r+0x5c>
 8203598:	00bfffc4 	movi	r2,-1
 820359c:	003ff606 	br	8203578 <_puts_r+0x98>

082035a0 <puts>:
 82035a0:	00820974 	movhi	r2,2085
 82035a4:	108fa204 	addi	r2,r2,16008
 82035a8:	200b883a 	mov	r5,r4
 82035ac:	11000017 	ldw	r4,0(r2)
 82035b0:	82034e01 	jmpi	82034e0 <_puts_r>

082035b4 <__srget_r>:
 82035b4:	defffd04 	addi	sp,sp,-12
 82035b8:	dc400115 	stw	r17,4(sp)
 82035bc:	dc000015 	stw	r16,0(sp)
 82035c0:	dfc00215 	stw	ra,8(sp)
 82035c4:	2023883a 	mov	r17,r4
 82035c8:	2821883a 	mov	r16,r5
 82035cc:	20000226 	beq	r4,zero,82035d8 <__srget_r+0x24>
 82035d0:	20800e17 	ldw	r2,56(r4)
 82035d4:	10001026 	beq	r2,zero,8203618 <__srget_r+0x64>
 82035d8:	800b883a 	mov	r5,r16
 82035dc:	8809883a 	mov	r4,r17
 82035e0:	820db500 	call	820db50 <__srefill_r>
 82035e4:	10000e1e 	bne	r2,zero,8203620 <__srget_r+0x6c>
 82035e8:	80c00017 	ldw	r3,0(r16)
 82035ec:	80800117 	ldw	r2,4(r16)
 82035f0:	19000044 	addi	r4,r3,1
 82035f4:	10bfffc4 	addi	r2,r2,-1
 82035f8:	80800115 	stw	r2,4(r16)
 82035fc:	81000015 	stw	r4,0(r16)
 8203600:	18800003 	ldbu	r2,0(r3)
 8203604:	dfc00217 	ldw	ra,8(sp)
 8203608:	dc400117 	ldw	r17,4(sp)
 820360c:	dc000017 	ldw	r16,0(sp)
 8203610:	dec00304 	addi	sp,sp,12
 8203614:	f800283a 	ret
 8203618:	820adb40 	call	820adb4 <__sinit>
 820361c:	003fee06 	br	82035d8 <__srget_r+0x24>
 8203620:	00bfffc4 	movi	r2,-1
 8203624:	003ff706 	br	8203604 <__srget_r+0x50>

08203628 <__srget>:
 8203628:	00820974 	movhi	r2,2085
 820362c:	108fa204 	addi	r2,r2,16008
 8203630:	200b883a 	mov	r5,r4
 8203634:	11000017 	ldw	r4,0(r2)
 8203638:	82035b41 	jmpi	82035b4 <__srget_r>

0820363c <_sprintf_r>:
 820363c:	deffe404 	addi	sp,sp,-112
 8203640:	2807883a 	mov	r3,r5
 8203644:	dfc01a15 	stw	ra,104(sp)
 8203648:	d9c01b15 	stw	r7,108(sp)
 820364c:	00a00034 	movhi	r2,32768
 8203650:	10bfffc4 	addi	r2,r2,-1
 8203654:	02008204 	movi	r8,520
 8203658:	d8800215 	stw	r2,8(sp)
 820365c:	d8800515 	stw	r2,20(sp)
 8203660:	d9c01b04 	addi	r7,sp,108
 8203664:	d80b883a 	mov	r5,sp
 8203668:	00bfffc4 	movi	r2,-1
 820366c:	d8c00015 	stw	r3,0(sp)
 8203670:	d8c00415 	stw	r3,16(sp)
 8203674:	da00030d 	sth	r8,12(sp)
 8203678:	d880038d 	sth	r2,14(sp)
 820367c:	82047d80 	call	82047d8 <___svfprintf_internal_r>
 8203680:	d8c00017 	ldw	r3,0(sp)
 8203684:	18000005 	stb	zero,0(r3)
 8203688:	dfc01a17 	ldw	ra,104(sp)
 820368c:	dec01c04 	addi	sp,sp,112
 8203690:	f800283a 	ret

08203694 <sprintf>:
 8203694:	deffe304 	addi	sp,sp,-116
 8203698:	2007883a 	mov	r3,r4
 820369c:	dfc01a15 	stw	ra,104(sp)
 82036a0:	d9801b15 	stw	r6,108(sp)
 82036a4:	d9c01c15 	stw	r7,112(sp)
 82036a8:	01020974 	movhi	r4,2085
 82036ac:	210fa204 	addi	r4,r4,16008
 82036b0:	21000017 	ldw	r4,0(r4)
 82036b4:	00a00034 	movhi	r2,32768
 82036b8:	10bfffc4 	addi	r2,r2,-1
 82036bc:	280d883a 	mov	r6,r5
 82036c0:	02008204 	movi	r8,520
 82036c4:	d8800215 	stw	r2,8(sp)
 82036c8:	d8800515 	stw	r2,20(sp)
 82036cc:	d9c01b04 	addi	r7,sp,108
 82036d0:	d80b883a 	mov	r5,sp
 82036d4:	00bfffc4 	movi	r2,-1
 82036d8:	d8c00015 	stw	r3,0(sp)
 82036dc:	d8c00415 	stw	r3,16(sp)
 82036e0:	da00030d 	sth	r8,12(sp)
 82036e4:	d880038d 	sth	r2,14(sp)
 82036e8:	82047d80 	call	82047d8 <___svfprintf_internal_r>
 82036ec:	d8c00017 	ldw	r3,0(sp)
 82036f0:	18000005 	stb	zero,0(r3)
 82036f4:	dfc01a17 	ldw	ra,104(sp)
 82036f8:	dec01d04 	addi	sp,sp,116
 82036fc:	f800283a 	ret

08203700 <strchr>:
 8203700:	2ac03fcc 	andi	r11,r5,255
 8203704:	2813883a 	mov	r9,r5
 8203708:	208000cc 	andi	r2,r4,3
 820370c:	58003726 	beq	r11,zero,82037ec <strchr+0xec>
 8203710:	10000b26 	beq	r2,zero,8203740 <strchr+0x40>
 8203714:	20800003 	ldbu	r2,0(r4)
 8203718:	10003226 	beq	r2,zero,82037e4 <strchr+0xe4>
 820371c:	28c03fcc 	andi	r3,r5,255
 8203720:	5880041e 	bne	r11,r2,8203734 <strchr+0x34>
 8203724:	00004d06 	br	820385c <strchr+0x15c>
 8203728:	20800003 	ldbu	r2,0(r4)
 820372c:	10002d26 	beq	r2,zero,82037e4 <strchr+0xe4>
 8203730:	18804a26 	beq	r3,r2,820385c <strchr+0x15c>
 8203734:	21000044 	addi	r4,r4,1
 8203738:	208000cc 	andi	r2,r4,3
 820373c:	103ffa1e 	bne	r2,zero,8203728 <strchr+0x28>
 8203740:	29403fcc 	andi	r5,r5,255
 8203744:	2814923a 	slli	r10,r5,8
 8203748:	20800017 	ldw	r2,0(r4)
 820374c:	01bfbff4 	movhi	r6,65279
 8203750:	2a8ab03a 	or	r5,r5,r10
 8203754:	2814943a 	slli	r10,r5,16
 8203758:	31bfbfc4 	addi	r6,r6,-257
 820375c:	119b883a 	add	r13,r2,r6
 8203760:	5154b03a 	or	r10,r10,r5
 8203764:	008e303a 	nor	r7,zero,r2
 8203768:	5084f03a 	xor	r2,r10,r2
 820376c:	1191883a 	add	r8,r2,r6
 8203770:	0086303a 	nor	r3,zero,r2
 8203774:	03202074 	movhi	r12,32897
 8203778:	69ca703a 	and	r5,r13,r7
 820377c:	40c4703a 	and	r2,r8,r3
 8203780:	63202004 	addi	r12,r12,-32640
 8203784:	2884b03a 	or	r2,r5,r2
 8203788:	1304703a 	and	r2,r2,r12
 820378c:	10000c1e 	bne	r2,zero,82037c0 <strchr+0xc0>
 8203790:	21000104 	addi	r4,r4,4
 8203794:	20c00017 	ldw	r3,0(r4)
 8203798:	50c4f03a 	xor	r2,r10,r3
 820379c:	1991883a 	add	r8,r3,r6
 82037a0:	00ca303a 	nor	r5,zero,r3
 82037a4:	118f883a 	add	r7,r2,r6
 82037a8:	0086303a 	nor	r3,zero,r2
 82037ac:	414a703a 	and	r5,r8,r5
 82037b0:	38c4703a 	and	r2,r7,r3
 82037b4:	2884b03a 	or	r2,r5,r2
 82037b8:	1304703a 	and	r2,r2,r12
 82037bc:	103ff426 	beq	r2,zero,8203790 <strchr+0x90>
 82037c0:	20800003 	ldbu	r2,0(r4)
 82037c4:	10000726 	beq	r2,zero,82037e4 <strchr+0xe4>
 82037c8:	58802426 	beq	r11,r2,820385c <strchr+0x15c>
 82037cc:	48c03fcc 	andi	r3,r9,255
 82037d0:	00000106 	br	82037d8 <strchr+0xd8>
 82037d4:	18802126 	beq	r3,r2,820385c <strchr+0x15c>
 82037d8:	21000044 	addi	r4,r4,1
 82037dc:	20800003 	ldbu	r2,0(r4)
 82037e0:	103ffc1e 	bne	r2,zero,82037d4 <strchr+0xd4>
 82037e4:	0005883a 	mov	r2,zero
 82037e8:	f800283a 	ret
 82037ec:	10000526 	beq	r2,zero,8203804 <strchr+0x104>
 82037f0:	20800003 	ldbu	r2,0(r4)
 82037f4:	10001926 	beq	r2,zero,820385c <strchr+0x15c>
 82037f8:	21000044 	addi	r4,r4,1
 82037fc:	208000cc 	andi	r2,r4,3
 8203800:	103ffb1e 	bne	r2,zero,82037f0 <strchr+0xf0>
 8203804:	20800017 	ldw	r2,0(r4)
 8203808:	01bfbff4 	movhi	r6,65279
 820380c:	31bfbfc4 	addi	r6,r6,-257
 8203810:	0086303a 	nor	r3,zero,r2
 8203814:	01602074 	movhi	r5,32897
 8203818:	1185883a 	add	r2,r2,r6
 820381c:	29602004 	addi	r5,r5,-32640
 8203820:	10c4703a 	and	r2,r2,r3
 8203824:	1144703a 	and	r2,r2,r5
 8203828:	1000071e 	bne	r2,zero,8203848 <strchr+0x148>
 820382c:	21000104 	addi	r4,r4,4
 8203830:	20800017 	ldw	r2,0(r4)
 8203834:	1187883a 	add	r3,r2,r6
 8203838:	0084303a 	nor	r2,zero,r2
 820383c:	1884703a 	and	r2,r3,r2
 8203840:	1144703a 	and	r2,r2,r5
 8203844:	103ff926 	beq	r2,zero,820382c <strchr+0x12c>
 8203848:	20800003 	ldbu	r2,0(r4)
 820384c:	10000326 	beq	r2,zero,820385c <strchr+0x15c>
 8203850:	21000044 	addi	r4,r4,1
 8203854:	20800003 	ldbu	r2,0(r4)
 8203858:	103ffd1e 	bne	r2,zero,8203850 <strchr+0x150>
 820385c:	2005883a 	mov	r2,r4
 8203860:	f800283a 	ret

08203864 <_strerror_r>:
 8203864:	deffff04 	addi	sp,sp,-4
 8203868:	2807883a 	mov	r3,r5
 820386c:	dfc00015 	stw	ra,0(sp)
 8203870:	00802384 	movi	r2,142
 8203874:	300b883a 	mov	r5,r6
 8203878:	10c18736 	bltu	r2,r3,8203e98 <_strerror_r+0x634>
 820387c:	181090ba 	slli	r8,r3,2
 8203880:	00820834 	movhi	r2,2080
 8203884:	108e2504 	addi	r2,r2,14484
 8203888:	4085883a 	add	r2,r8,r2
 820388c:	10800017 	ldw	r2,0(r2)
 8203890:	1000683a 	jmp	r2
 8203894:	08203ad0 	cmplti	zero,at,-32533
 8203898:	08203e8c 	andi	zero,at,33018
 820389c:	08203e80 	call	8203e8 <OSCtxSw_SWITCH_PC+0x8203a8>
 82038a0:	08203e74 	orhi	zero,at,33017
 82038a4:	08203e68 	cmpgeui	zero,at,33017
 82038a8:	08203e5c 	xori	zero,at,33017
 82038ac:	08203e50 	cmplti	zero,at,-32519
 82038b0:	08203e44 	addi	zero,at,-32519
 82038b4:	08203e38 	rdprs	zero,at,-32520
 82038b8:	08203e2c 	andhi	zero,at,33016
 82038bc:	08203e20 	cmpeqi	zero,at,-32520
 82038c0:	08203e14 	ori	zero,at,33016
 82038c4:	08203e08 	cmpgei	zero,at,-32520
 82038c8:	08203dfc 	xorhi	zero,at,33015
 82038cc:	08203df0 	cmpltui	zero,at,33015
 82038d0:	08203e98 	cmpnei	zero,at,-32518
 82038d4:	08203de4 	muli	zero,at,-32521
 82038d8:	08203dd8 	cmpnei	zero,at,-32521
 82038dc:	08203dcc 	andi	zero,at,33015
 82038e0:	08203dc0 	call	8203dc <OSCtxSw_SWITCH_PC+0x82039c>
 82038e4:	08203db4 	orhi	zero,at,33014
 82038e8:	08203da8 	cmpgeui	zero,at,33014
 82038ec:	08203d9c 	xori	zero,at,33014
 82038f0:	08203d90 	cmplti	zero,at,-32522
 82038f4:	08203d84 	addi	zero,at,-32522
 82038f8:	08203d78 	rdprs	zero,at,-32523
 82038fc:	08203d6c 	andhi	zero,at,33013
 8203900:	08203d60 	cmpeqi	zero,at,-32523
 8203904:	08203d54 	ori	zero,at,33013
 8203908:	08203d48 	cmpgei	zero,at,-32523
 820390c:	08203d3c 	xorhi	zero,at,33012
 8203910:	08203d30 	cmpltui	zero,at,33012
 8203914:	08203d24 	muli	zero,at,-32524
 8203918:	08203d18 	cmpnei	zero,at,-32524
 820391c:	08203d0c 	andi	zero,at,33012
 8203920:	08203d00 	call	8203d0 <OSCtxSw_SWITCH_PC+0x820390>
 8203924:	08203cf4 	orhi	zero,at,33011
 8203928:	08203e98 	cmpnei	zero,at,-32518
 820392c:	08203e98 	cmpnei	zero,at,-32518
 8203930:	08203e98 	cmpnei	zero,at,-32518
 8203934:	08203e98 	cmpnei	zero,at,-32518
 8203938:	08203e98 	cmpnei	zero,at,-32518
 820393c:	08203e98 	cmpnei	zero,at,-32518
 8203940:	08203e98 	cmpnei	zero,at,-32518
 8203944:	08203e98 	cmpnei	zero,at,-32518
 8203948:	08203ce8 	cmpgeui	zero,at,33011
 820394c:	08203cdc 	xori	zero,at,33011
 8203950:	08203e98 	cmpnei	zero,at,-32518
 8203954:	08203e98 	cmpnei	zero,at,-32518
 8203958:	08203e98 	cmpnei	zero,at,-32518
 820395c:	08203e98 	cmpnei	zero,at,-32518
 8203960:	08203e98 	cmpnei	zero,at,-32518
 8203964:	08203e98 	cmpnei	zero,at,-32518
 8203968:	08203e98 	cmpnei	zero,at,-32518
 820396c:	08203e98 	cmpnei	zero,at,-32518
 8203970:	08203e98 	cmpnei	zero,at,-32518
 8203974:	08203e98 	cmpnei	zero,at,-32518
 8203978:	08203e98 	cmpnei	zero,at,-32518
 820397c:	08203e98 	cmpnei	zero,at,-32518
 8203980:	08203e98 	cmpnei	zero,at,-32518
 8203984:	08203cd0 	cmplti	zero,at,-32525
 8203988:	08203cc4 	addi	zero,at,-32525
 820398c:	08203cb8 	rdprs	zero,at,-32526
 8203990:	08203cac 	andhi	zero,at,33010
 8203994:	08203e98 	cmpnei	zero,at,-32518
 8203998:	08203e98 	cmpnei	zero,at,-32518
 820399c:	08203e98 	cmpnei	zero,at,-32518
 82039a0:	08203ca0 	cmpeqi	zero,at,-32526
 82039a4:	08203e98 	cmpnei	zero,at,-32518
 82039a8:	08203e98 	cmpnei	zero,at,-32518
 82039ac:	08203e98 	cmpnei	zero,at,-32518
 82039b0:	08203c94 	ori	zero,at,33010
 82039b4:	08203e98 	cmpnei	zero,at,-32518
 82039b8:	08203e98 	cmpnei	zero,at,-32518
 82039bc:	08203c88 	cmpgei	zero,at,-32526
 82039c0:	08203e98 	cmpnei	zero,at,-32518
 82039c4:	08203e98 	cmpnei	zero,at,-32518
 82039c8:	08203c7c 	xorhi	zero,at,33009
 82039cc:	08203e98 	cmpnei	zero,at,-32518
 82039d0:	08203e98 	cmpnei	zero,at,-32518
 82039d4:	08203e98 	cmpnei	zero,at,-32518
 82039d8:	08203e98 	cmpnei	zero,at,-32518
 82039dc:	08203e98 	cmpnei	zero,at,-32518
 82039e0:	08203e98 	cmpnei	zero,at,-32518
 82039e4:	08203e98 	cmpnei	zero,at,-32518
 82039e8:	08203e98 	cmpnei	zero,at,-32518
 82039ec:	08203e98 	cmpnei	zero,at,-32518
 82039f0:	08203e98 	cmpnei	zero,at,-32518
 82039f4:	08203c70 	cmpltui	zero,at,33009
 82039f8:	08203e98 	cmpnei	zero,at,-32518
 82039fc:	08203c64 	muli	zero,at,-32527
 8203a00:	08203c58 	cmpnei	zero,at,-32527
 8203a04:	08203c4c 	andi	zero,at,33009
 8203a08:	08203e98 	cmpnei	zero,at,-32518
 8203a0c:	08203e98 	cmpnei	zero,at,-32518
 8203a10:	08203c40 	call	8203c4 <OSCtxSw_SWITCH_PC+0x820384>
 8203a14:	08203e98 	cmpnei	zero,at,-32518
 8203a18:	08203e98 	cmpnei	zero,at,-32518
 8203a1c:	08203e98 	cmpnei	zero,at,-32518
 8203a20:	08203e98 	cmpnei	zero,at,-32518
 8203a24:	08203e98 	cmpnei	zero,at,-32518
 8203a28:	08203e98 	cmpnei	zero,at,-32518
 8203a2c:	08203e98 	cmpnei	zero,at,-32518
 8203a30:	08203e98 	cmpnei	zero,at,-32518
 8203a34:	08203c34 	orhi	zero,at,33008
 8203a38:	08203c28 	cmpgeui	zero,at,33008
 8203a3c:	08203c1c 	xori	zero,at,33008
 8203a40:	08203c10 	cmplti	zero,at,-32528
 8203a44:	08203c04 	addi	zero,at,-32528
 8203a48:	08203bf8 	rdprs	zero,at,-32529
 8203a4c:	08203e98 	cmpnei	zero,at,-32518
 8203a50:	08203bec 	andhi	zero,at,33007
 8203a54:	08203be0 	cmpeqi	zero,at,-32529
 8203a58:	08203bd4 	ori	zero,at,33007
 8203a5c:	08203bc8 	cmpgei	zero,at,-32529
 8203a60:	08203bbc 	xorhi	zero,at,33006
 8203a64:	08203bb0 	cmpltui	zero,at,33006
 8203a68:	08203ba4 	muli	zero,at,-32530
 8203a6c:	08203b98 	cmpnei	zero,at,-32530
 8203a70:	08203b8c 	andi	zero,at,33006
 8203a74:	08203b80 	call	8203b8 <OSCtxSw_SWITCH_PC+0x820378>
 8203a78:	08203b74 	orhi	zero,at,33005
 8203a7c:	08203b68 	cmpgeui	zero,at,33005
 8203a80:	08203b5c 	xori	zero,at,33005
 8203a84:	08203e98 	cmpnei	zero,at,-32518
 8203a88:	08203b50 	cmplti	zero,at,-32531
 8203a8c:	08203b44 	addi	zero,at,-32531
 8203a90:	08203b38 	rdprs	zero,at,-32532
 8203a94:	08203b2c 	andhi	zero,at,33004
 8203a98:	08203e98 	cmpnei	zero,at,-32518
 8203a9c:	08203e98 	cmpnei	zero,at,-32518
 8203aa0:	08203e98 	cmpnei	zero,at,-32518
 8203aa4:	08203e98 	cmpnei	zero,at,-32518
 8203aa8:	08203e98 	cmpnei	zero,at,-32518
 8203aac:	08203b20 	cmpeqi	zero,at,-32532
 8203ab0:	08203e98 	cmpnei	zero,at,-32518
 8203ab4:	08203e98 	cmpnei	zero,at,-32518
 8203ab8:	08203e98 	cmpnei	zero,at,-32518
 8203abc:	08203b14 	ori	zero,at,33004
 8203ac0:	08203b08 	cmpgei	zero,at,-32532
 8203ac4:	08203afc 	xorhi	zero,at,33003
 8203ac8:	08203af0 	cmpltui	zero,at,33003
 8203acc:	08203ae4 	muli	zero,at,-32533
 8203ad0:	00820974 	movhi	r2,2085
 8203ad4:	10b50304 	addi	r2,r2,-11252
 8203ad8:	dfc00017 	ldw	ra,0(sp)
 8203adc:	dec00104 	addi	sp,sp,4
 8203ae0:	f800283a 	ret
 8203ae4:	00820974 	movhi	r2,2085
 8203ae8:	10b6a004 	addi	r2,r2,-9600
 8203aec:	003ffa06 	br	8203ad8 <_strerror_r+0x274>
 8203af0:	00820974 	movhi	r2,2085
 8203af4:	10b69a04 	addi	r2,r2,-9624
 8203af8:	003ff706 	br	8203ad8 <_strerror_r+0x274>
 8203afc:	00820974 	movhi	r2,2085
 8203b00:	10b69504 	addi	r2,r2,-9644
 8203b04:	003ff406 	br	8203ad8 <_strerror_r+0x274>
 8203b08:	00820974 	movhi	r2,2085
 8203b0c:	10b6ae04 	addi	r2,r2,-9544
 8203b10:	003ff106 	br	8203ad8 <_strerror_r+0x274>
 8203b14:	00820974 	movhi	r2,2085
 8203b18:	10b5ec04 	addi	r2,r2,-10320
 8203b1c:	003fee06 	br	8203ad8 <_strerror_r+0x274>
 8203b20:	00820974 	movhi	r2,2085
 8203b24:	10b5ba04 	addi	r2,r2,-10520
 8203b28:	003feb06 	br	8203ad8 <_strerror_r+0x274>
 8203b2c:	00820974 	movhi	r2,2085
 8203b30:	10b68804 	addi	r2,r2,-9696
 8203b34:	003fe806 	br	8203ad8 <_strerror_r+0x274>
 8203b38:	00820974 	movhi	r2,2085
 8203b3c:	10b68e04 	addi	r2,r2,-9672
 8203b40:	003fe506 	br	8203ad8 <_strerror_r+0x274>
 8203b44:	00820974 	movhi	r2,2085
 8203b48:	10b58904 	addi	r2,r2,-10716
 8203b4c:	003fe206 	br	8203ad8 <_strerror_r+0x274>
 8203b50:	00820974 	movhi	r2,2085
 8203b54:	10b67904 	addi	r2,r2,-9756
 8203b58:	003fdf06 	br	8203ad8 <_strerror_r+0x274>
 8203b5c:	00820974 	movhi	r2,2085
 8203b60:	10b61604 	addi	r2,r2,-10152
 8203b64:	003fdc06 	br	8203ad8 <_strerror_r+0x274>
 8203b68:	00820974 	movhi	r2,2085
 8203b6c:	10b6b804 	addi	r2,r2,-9504
 8203b70:	003fd906 	br	8203ad8 <_strerror_r+0x274>
 8203b74:	00820974 	movhi	r2,2085
 8203b78:	10b53b04 	addi	r2,r2,-11028
 8203b7c:	003fd606 	br	8203ad8 <_strerror_r+0x274>
 8203b80:	00820974 	movhi	r2,2085
 8203b84:	10b52d04 	addi	r2,r2,-11084
 8203b88:	003fd306 	br	8203ad8 <_strerror_r+0x274>
 8203b8c:	00820974 	movhi	r2,2085
 8203b90:	10b56f04 	addi	r2,r2,-10820
 8203b94:	003fd006 	br	8203ad8 <_strerror_r+0x274>
 8203b98:	00820974 	movhi	r2,2085
 8203b9c:	10b5af04 	addi	r2,r2,-10564
 8203ba0:	003fcd06 	br	8203ad8 <_strerror_r+0x274>
 8203ba4:	00820974 	movhi	r2,2085
 8203ba8:	10b56b04 	addi	r2,r2,-10836
 8203bac:	003fca06 	br	8203ad8 <_strerror_r+0x274>
 8203bb0:	00820974 	movhi	r2,2085
 8203bb4:	10b6bd04 	addi	r2,r2,-9484
 8203bb8:	003fc706 	br	8203ad8 <_strerror_r+0x274>
 8203bbc:	00820974 	movhi	r2,2085
 8203bc0:	10b58004 	addi	r2,r2,-10752
 8203bc4:	003fc406 	br	8203ad8 <_strerror_r+0x274>
 8203bc8:	00820974 	movhi	r2,2085
 8203bcc:	10b5f504 	addi	r2,r2,-10284
 8203bd0:	003fc106 	br	8203ad8 <_strerror_r+0x274>
 8203bd4:	00820974 	movhi	r2,2085
 8203bd8:	10b67f04 	addi	r2,r2,-9732
 8203bdc:	003fbe06 	br	8203ad8 <_strerror_r+0x274>
 8203be0:	00820974 	movhi	r2,2085
 8203be4:	10b67304 	addi	r2,r2,-9780
 8203be8:	003fbb06 	br	8203ad8 <_strerror_r+0x274>
 8203bec:	00820974 	movhi	r2,2085
 8203bf0:	10b66704 	addi	r2,r2,-9828
 8203bf4:	003fb806 	br	8203ad8 <_strerror_r+0x274>
 8203bf8:	00820974 	movhi	r2,2085
 8203bfc:	10b66104 	addi	r2,r2,-9852
 8203c00:	003fb506 	br	8203ad8 <_strerror_r+0x274>
 8203c04:	00820974 	movhi	r2,2085
 8203c08:	10b65904 	addi	r2,r2,-9884
 8203c0c:	003fb206 	br	8203ad8 <_strerror_r+0x274>
 8203c10:	00820974 	movhi	r2,2085
 8203c14:	10b65104 	addi	r2,r2,-9916
 8203c18:	003faf06 	br	8203ad8 <_strerror_r+0x274>
 8203c1c:	00820974 	movhi	r2,2085
 8203c20:	10b64504 	addi	r2,r2,-9964
 8203c24:	003fac06 	br	8203ad8 <_strerror_r+0x274>
 8203c28:	00820974 	movhi	r2,2085
 8203c2c:	10b63c04 	addi	r2,r2,-10000
 8203c30:	003fa906 	br	8203ad8 <_strerror_r+0x274>
 8203c34:	00820974 	movhi	r2,2085
 8203c38:	10b66c04 	addi	r2,r2,-9808
 8203c3c:	003fa606 	br	8203ad8 <_strerror_r+0x274>
 8203c40:	00820974 	movhi	r2,2085
 8203c44:	10b6a504 	addi	r2,r2,-9580
 8203c48:	003fa306 	br	8203ad8 <_strerror_r+0x274>
 8203c4c:	00820974 	movhi	r2,2085
 8203c50:	10b63604 	addi	r2,r2,-10024
 8203c54:	003fa006 	br	8203ad8 <_strerror_r+0x274>
 8203c58:	00820974 	movhi	r2,2085
 8203c5c:	10b62f04 	addi	r2,r2,-10052
 8203c60:	003f9d06 	br	8203ad8 <_strerror_r+0x274>
 8203c64:	00820974 	movhi	r2,2085
 8203c68:	10b62a04 	addi	r2,r2,-10072
 8203c6c:	003f9a06 	br	8203ad8 <_strerror_r+0x274>
 8203c70:	00820974 	movhi	r2,2085
 8203c74:	10b62304 	addi	r2,r2,-10100
 8203c78:	003f9706 	br	8203ad8 <_strerror_r+0x274>
 8203c7c:	00820974 	movhi	r2,2085
 8203c80:	10b62004 	addi	r2,r2,-10112
 8203c84:	003f9406 	br	8203ad8 <_strerror_r+0x274>
 8203c88:	00820974 	movhi	r2,2085
 8203c8c:	10b61b04 	addi	r2,r2,-10132
 8203c90:	003f9106 	br	8203ad8 <_strerror_r+0x274>
 8203c94:	00820974 	movhi	r2,2085
 8203c98:	10b61204 	addi	r2,r2,-10168
 8203c9c:	003f8e06 	br	8203ad8 <_strerror_r+0x274>
 8203ca0:	00820974 	movhi	r2,2085
 8203ca4:	10b60c04 	addi	r2,r2,-10192
 8203ca8:	003f8b06 	br	8203ad8 <_strerror_r+0x274>
 8203cac:	00820974 	movhi	r2,2085
 8203cb0:	10b60704 	addi	r2,r2,-10212
 8203cb4:	003f8806 	br	8203ad8 <_strerror_r+0x274>
 8203cb8:	00820974 	movhi	r2,2085
 8203cbc:	10b60104 	addi	r2,r2,-10236
 8203cc0:	003f8506 	br	8203ad8 <_strerror_r+0x274>
 8203cc4:	00820974 	movhi	r2,2085
 8203cc8:	10b64304 	addi	r2,r2,-9972
 8203ccc:	003f8206 	br	8203ad8 <_strerror_r+0x274>
 8203cd0:	00820974 	movhi	r2,2085
 8203cd4:	10b5fd04 	addi	r2,r2,-10252
 8203cd8:	003f7f06 	br	8203ad8 <_strerror_r+0x274>
 8203cdc:	00820974 	movhi	r2,2085
 8203ce0:	10b5fb04 	addi	r2,r2,-10260
 8203ce4:	003f7c06 	br	8203ad8 <_strerror_r+0x274>
 8203ce8:	00820974 	movhi	r2,2085
 8203cec:	10b5f204 	addi	r2,r2,-10296
 8203cf0:	003f7906 	br	8203ad8 <_strerror_r+0x274>
 8203cf4:	00820974 	movhi	r2,2085
 8203cf8:	10b5e704 	addi	r2,r2,-10340
 8203cfc:	003f7606 	br	8203ad8 <_strerror_r+0x274>
 8203d00:	00820974 	movhi	r2,2085
 8203d04:	10b5e004 	addi	r2,r2,-10368
 8203d08:	003f7306 	br	8203ad8 <_strerror_r+0x274>
 8203d0c:	00820974 	movhi	r2,2085
 8203d10:	10b5db04 	addi	r2,r2,-10388
 8203d14:	003f7006 	br	8203ad8 <_strerror_r+0x274>
 8203d18:	00820974 	movhi	r2,2085
 8203d1c:	10b5cf04 	addi	r2,r2,-10436
 8203d20:	003f6d06 	br	8203ad8 <_strerror_r+0x274>
 8203d24:	00820974 	movhi	r2,2085
 8203d28:	10b5cc04 	addi	r2,r2,-10448
 8203d2c:	003f6a06 	br	8203ad8 <_strerror_r+0x274>
 8203d30:	00820974 	movhi	r2,2085
 8203d34:	10b5c804 	addi	r2,r2,-10464
 8203d38:	003f6706 	br	8203ad8 <_strerror_r+0x274>
 8203d3c:	00820974 	movhi	r2,2085
 8203d40:	10b5c204 	addi	r2,r2,-10488
 8203d44:	003f6406 	br	8203ad8 <_strerror_r+0x274>
 8203d48:	00820974 	movhi	r2,2085
 8203d4c:	10b5be04 	addi	r2,r2,-10504
 8203d50:	003f6106 	br	8203ad8 <_strerror_r+0x274>
 8203d54:	00820974 	movhi	r2,2085
 8203d58:	10b5b404 	addi	r2,r2,-10544
 8203d5c:	003f5e06 	br	8203ad8 <_strerror_r+0x274>
 8203d60:	00820974 	movhi	r2,2085
 8203d64:	10b5ab04 	addi	r2,r2,-10580
 8203d68:	003f5b06 	br	8203ad8 <_strerror_r+0x274>
 8203d6c:	00820974 	movhi	r2,2085
 8203d70:	10b5a704 	addi	r2,r2,-10596
 8203d74:	003f5806 	br	8203ad8 <_strerror_r+0x274>
 8203d78:	00820974 	movhi	r2,2085
 8203d7c:	10b5a104 	addi	r2,r2,-10620
 8203d80:	003f5506 	br	8203ad8 <_strerror_r+0x274>
 8203d84:	00820974 	movhi	r2,2085
 8203d88:	10b59904 	addi	r2,r2,-10652
 8203d8c:	003f5206 	br	8203ad8 <_strerror_r+0x274>
 8203d90:	00820974 	movhi	r2,2085
 8203d94:	10b59104 	addi	r2,r2,-10684
 8203d98:	003f4f06 	br	8203ad8 <_strerror_r+0x274>
 8203d9c:	00820974 	movhi	r2,2085
 8203da0:	10b57b04 	addi	r2,r2,-10772
 8203da4:	003f4c06 	br	8203ad8 <_strerror_r+0x274>
 8203da8:	00820974 	movhi	r2,2085
 8203dac:	10b57704 	addi	r2,r2,-10788
 8203db0:	003f4906 	br	8203ad8 <_strerror_r+0x274>
 8203db4:	00820974 	movhi	r2,2085
 8203db8:	10b56704 	addi	r2,r2,-10852
 8203dbc:	003f4606 	br	8203ad8 <_strerror_r+0x274>
 8203dc0:	00820974 	movhi	r2,2085
 8203dc4:	10b56304 	addi	r2,r2,-10868
 8203dc8:	003f4306 	br	8203ad8 <_strerror_r+0x274>
 8203dcc:	00820974 	movhi	r2,2085
 8203dd0:	10b55e04 	addi	r2,r2,-10888
 8203dd4:	003f4006 	br	8203ad8 <_strerror_r+0x274>
 8203dd8:	00820974 	movhi	r2,2085
 8203ddc:	10b55b04 	addi	r2,r2,-10900
 8203de0:	003f3d06 	br	8203ad8 <_strerror_r+0x274>
 8203de4:	00820974 	movhi	r2,2085
 8203de8:	10b55504 	addi	r2,r2,-10924
 8203dec:	003f3a06 	br	8203ad8 <_strerror_r+0x274>
 8203df0:	00820974 	movhi	r2,2085
 8203df4:	10b55204 	addi	r2,r2,-10936
 8203df8:	003f3706 	br	8203ad8 <_strerror_r+0x274>
 8203dfc:	00820974 	movhi	r2,2085
 8203e00:	10b54d04 	addi	r2,r2,-10956
 8203e04:	003f3406 	br	8203ad8 <_strerror_r+0x274>
 8203e08:	00820974 	movhi	r2,2085
 8203e0c:	10b54804 	addi	r2,r2,-10976
 8203e10:	003f3106 	br	8203ad8 <_strerror_r+0x274>
 8203e14:	00820974 	movhi	r2,2085
 8203e18:	10b54304 	addi	r2,r2,-10996
 8203e1c:	003f2e06 	br	8203ad8 <_strerror_r+0x274>
 8203e20:	00820974 	movhi	r2,2085
 8203e24:	10b53804 	addi	r2,r2,-11040
 8203e28:	003f2b06 	br	8203ad8 <_strerror_r+0x274>
 8203e2c:	00820974 	movhi	r2,2085
 8203e30:	10b53404 	addi	r2,r2,-11056
 8203e34:	003f2806 	br	8203ad8 <_strerror_r+0x274>
 8203e38:	00820974 	movhi	r2,2085
 8203e3c:	10b52804 	addi	r2,r2,-11104
 8203e40:	003f2506 	br	8203ad8 <_strerror_r+0x274>
 8203e44:	00820974 	movhi	r2,2085
 8203e48:	10b52304 	addi	r2,r2,-11124
 8203e4c:	003f2206 	br	8203ad8 <_strerror_r+0x274>
 8203e50:	00820974 	movhi	r2,2085
 8203e54:	10b51c04 	addi	r2,r2,-11152
 8203e58:	003f1f06 	br	8203ad8 <_strerror_r+0x274>
 8203e5c:	00820974 	movhi	r2,2085
 8203e60:	10b51904 	addi	r2,r2,-11164
 8203e64:	003f1c06 	br	8203ad8 <_strerror_r+0x274>
 8203e68:	00820974 	movhi	r2,2085
 8203e6c:	10b51304 	addi	r2,r2,-11188
 8203e70:	003f1906 	br	8203ad8 <_strerror_r+0x274>
 8203e74:	00820974 	movhi	r2,2085
 8203e78:	10b50f04 	addi	r2,r2,-11204
 8203e7c:	003f1606 	br	8203ad8 <_strerror_r+0x274>
 8203e80:	00820974 	movhi	r2,2085
 8203e84:	10b50804 	addi	r2,r2,-11232
 8203e88:	003f1306 	br	8203ad8 <_strerror_r+0x274>
 8203e8c:	00820974 	movhi	r2,2085
 8203e90:	10b50504 	addi	r2,r2,-11244
 8203e94:	003f1006 	br	8203ad8 <_strerror_r+0x274>
 8203e98:	38000726 	beq	r7,zero,8203eb8 <_strerror_r+0x654>
 8203e9c:	380d883a 	mov	r6,r7
 8203ea0:	1809883a 	mov	r4,r3
 8203ea4:	82069b00 	call	82069b0 <_user_strerror>
 8203ea8:	103f0b1e 	bne	r2,zero,8203ad8 <_strerror_r+0x274>
 8203eac:	00820974 	movhi	r2,2085
 8203eb0:	10b6cb04 	addi	r2,r2,-9428
 8203eb4:	003f0806 	br	8203ad8 <_strerror_r+0x274>
 8203eb8:	200f883a 	mov	r7,r4
 8203ebc:	003ff706 	br	8203e9c <_strerror_r+0x638>

08203ec0 <strerror>:
 8203ec0:	00820974 	movhi	r2,2085
 8203ec4:	108fa204 	addi	r2,r2,16008
 8203ec8:	200b883a 	mov	r5,r4
 8203ecc:	11000017 	ldw	r4,0(r2)
 8203ed0:	000f883a 	mov	r7,zero
 8203ed4:	000d883a 	mov	r6,zero
 8203ed8:	82038641 	jmpi	8203864 <_strerror_r>

08203edc <strlen>:
 8203edc:	208000cc 	andi	r2,r4,3
 8203ee0:	10002026 	beq	r2,zero,8203f64 <strlen+0x88>
 8203ee4:	20800007 	ldb	r2,0(r4)
 8203ee8:	10002026 	beq	r2,zero,8203f6c <strlen+0x90>
 8203eec:	2005883a 	mov	r2,r4
 8203ef0:	00000206 	br	8203efc <strlen+0x20>
 8203ef4:	10c00007 	ldb	r3,0(r2)
 8203ef8:	18001826 	beq	r3,zero,8203f5c <strlen+0x80>
 8203efc:	10800044 	addi	r2,r2,1
 8203f00:	10c000cc 	andi	r3,r2,3
 8203f04:	183ffb1e 	bne	r3,zero,8203ef4 <strlen+0x18>
 8203f08:	10c00017 	ldw	r3,0(r2)
 8203f0c:	01ffbff4 	movhi	r7,65279
 8203f10:	39ffbfc4 	addi	r7,r7,-257
 8203f14:	00ca303a 	nor	r5,zero,r3
 8203f18:	01a02074 	movhi	r6,32897
 8203f1c:	19c7883a 	add	r3,r3,r7
 8203f20:	31a02004 	addi	r6,r6,-32640
 8203f24:	1946703a 	and	r3,r3,r5
 8203f28:	1986703a 	and	r3,r3,r6
 8203f2c:	1800091e 	bne	r3,zero,8203f54 <strlen+0x78>
 8203f30:	10800104 	addi	r2,r2,4
 8203f34:	10c00017 	ldw	r3,0(r2)
 8203f38:	19cb883a 	add	r5,r3,r7
 8203f3c:	00c6303a 	nor	r3,zero,r3
 8203f40:	28c6703a 	and	r3,r5,r3
 8203f44:	1986703a 	and	r3,r3,r6
 8203f48:	183ff926 	beq	r3,zero,8203f30 <strlen+0x54>
 8203f4c:	00000106 	br	8203f54 <strlen+0x78>
 8203f50:	10800044 	addi	r2,r2,1
 8203f54:	10c00007 	ldb	r3,0(r2)
 8203f58:	183ffd1e 	bne	r3,zero,8203f50 <strlen+0x74>
 8203f5c:	1105c83a 	sub	r2,r2,r4
 8203f60:	f800283a 	ret
 8203f64:	2005883a 	mov	r2,r4
 8203f68:	003fe706 	br	8203f08 <strlen+0x2c>
 8203f6c:	0005883a 	mov	r2,zero
 8203f70:	f800283a 	ret

08203f74 <critical_factorization>:
 8203f74:	02c00044 	movi	r11,1
 8203f78:	5811883a 	mov	r8,r11
 8203f7c:	0013883a 	mov	r9,zero
 8203f80:	00bfffc4 	movi	r2,-1
 8203f84:	2087883a 	add	r3,r4,r2
 8203f88:	1a0f883a 	add	r7,r3,r8
 8203f8c:	4a07883a 	add	r3,r9,r8
 8203f90:	20d5883a 	add	r10,r4,r3
 8203f94:	1940102e 	bgeu	r3,r5,8203fd8 <critical_factorization+0x64>
 8203f98:	52800003 	ldbu	r10,0(r10)
 8203f9c:	39c00003 	ldbu	r7,0(r7)
 8203fa0:	51c0042e 	bgeu	r10,r7,8203fb4 <critical_factorization+0x40>
 8203fa4:	1897c83a 	sub	r11,r3,r2
 8203fa8:	1813883a 	mov	r9,r3
 8203fac:	02000044 	movi	r8,1
 8203fb0:	003ff406 	br	8203f84 <critical_factorization+0x10>
 8203fb4:	51c00526 	beq	r10,r7,8203fcc <critical_factorization+0x58>
 8203fb8:	02c00044 	movi	r11,1
 8203fbc:	4805883a 	mov	r2,r9
 8203fc0:	5811883a 	mov	r8,r11
 8203fc4:	4ad3883a 	add	r9,r9,r11
 8203fc8:	003fee06 	br	8203f84 <critical_factorization+0x10>
 8203fcc:	42c02226 	beq	r8,r11,8204058 <critical_factorization+0xe4>
 8203fd0:	42000044 	addi	r8,r8,1
 8203fd4:	003feb06 	br	8203f84 <critical_factorization+0x10>
 8203fd8:	03000044 	movi	r12,1
 8203fdc:	32c00015 	stw	r11,0(r6)
 8203fe0:	6011883a 	mov	r8,r12
 8203fe4:	0013883a 	mov	r9,zero
 8203fe8:	02ffffc4 	movi	r11,-1
 8203fec:	22c7883a 	add	r3,r4,r11
 8203ff0:	1a0f883a 	add	r7,r3,r8
 8203ff4:	4a07883a 	add	r3,r9,r8
 8203ff8:	20d5883a 	add	r10,r4,r3
 8203ffc:	1940102e 	bgeu	r3,r5,8204040 <critical_factorization+0xcc>
 8204000:	52800003 	ldbu	r10,0(r10)
 8204004:	39c00003 	ldbu	r7,0(r7)
 8204008:	3a80042e 	bgeu	r7,r10,820401c <critical_factorization+0xa8>
 820400c:	1ad9c83a 	sub	r12,r3,r11
 8204010:	1813883a 	mov	r9,r3
 8204014:	02000044 	movi	r8,1
 8204018:	003ff406 	br	8203fec <critical_factorization+0x78>
 820401c:	51c00526 	beq	r10,r7,8204034 <critical_factorization+0xc0>
 8204020:	03000044 	movi	r12,1
 8204024:	4817883a 	mov	r11,r9
 8204028:	6011883a 	mov	r8,r12
 820402c:	4b13883a 	add	r9,r9,r12
 8204030:	003fee06 	br	8203fec <critical_factorization+0x78>
 8204034:	43000c26 	beq	r8,r12,8204068 <critical_factorization+0xf4>
 8204038:	42000044 	addi	r8,r8,1
 820403c:	003feb06 	br	8203fec <critical_factorization+0x78>
 8204040:	5ac00044 	addi	r11,r11,1
 8204044:	10800044 	addi	r2,r2,1
 8204048:	58800236 	bltu	r11,r2,8204054 <critical_factorization+0xe0>
 820404c:	33000015 	stw	r12,0(r6)
 8204050:	5805883a 	mov	r2,r11
 8204054:	f800283a 	ret
 8204058:	4017883a 	mov	r11,r8
 820405c:	1813883a 	mov	r9,r3
 8204060:	02000044 	movi	r8,1
 8204064:	003fc706 	br	8203f84 <critical_factorization+0x10>
 8204068:	4019883a 	mov	r12,r8
 820406c:	1813883a 	mov	r9,r3
 8204070:	02000044 	movi	r8,1
 8204074:	003fdd06 	br	8203fec <critical_factorization+0x78>

08204078 <two_way_long_needle>:
 8204078:	defef104 	addi	sp,sp,-1084
 820407c:	dc810715 	stw	r18,1052(sp)
 8204080:	dc410615 	stw	r17,1048(sp)
 8204084:	dc810004 	addi	r18,sp,1024
 8204088:	3023883a 	mov	r17,r6
 820408c:	2807883a 	mov	r3,r5
 8204090:	ddc10c15 	stw	r23,1072(sp)
 8204094:	900d883a 	mov	r6,r18
 8204098:	202f883a 	mov	r23,r4
 820409c:	380b883a 	mov	r5,r7
 82040a0:	8809883a 	mov	r4,r17
 82040a4:	dd810b15 	stw	r22,1068(sp)
 82040a8:	dc010515 	stw	r16,1044(sp)
 82040ac:	d8c10415 	stw	r3,1040(sp)
 82040b0:	dfc10e15 	stw	ra,1080(sp)
 82040b4:	df010d15 	stw	fp,1076(sp)
 82040b8:	dd410a15 	stw	r21,1064(sp)
 82040bc:	dd010915 	stw	r20,1060(sp)
 82040c0:	dcc10815 	stw	r19,1056(sp)
 82040c4:	382d883a 	mov	r22,r7
 82040c8:	8203f740 	call	8203f74 <critical_factorization>
 82040cc:	d8c10417 	ldw	r3,1040(sp)
 82040d0:	1021883a 	mov	r16,r2
 82040d4:	d805883a 	mov	r2,sp
 82040d8:	15800015 	stw	r22,0(r2)
 82040dc:	10800104 	addi	r2,r2,4
 82040e0:	90bffd1e 	bne	r18,r2,82040d8 <two_way_long_needle+0x60>
 82040e4:	b0000b26 	beq	r22,zero,8204114 <two_way_long_needle+0x9c>
 82040e8:	b17fffc4 	addi	r5,r22,-1
 82040ec:	8809883a 	mov	r4,r17
 82040f0:	8d8d883a 	add	r6,r17,r22
 82040f4:	20800003 	ldbu	r2,0(r4)
 82040f8:	21000044 	addi	r4,r4,1
 82040fc:	1085883a 	add	r2,r2,r2
 8204100:	1085883a 	add	r2,r2,r2
 8204104:	d885883a 	add	r2,sp,r2
 8204108:	11400015 	stw	r5,0(r2)
 820410c:	297fffc4 	addi	r5,r5,-1
 8204110:	21bff81e 	bne	r4,r6,82040f4 <two_way_long_needle+0x7c>
 8204114:	d9410017 	ldw	r5,1024(sp)
 8204118:	800d883a 	mov	r6,r16
 820411c:	8809883a 	mov	r4,r17
 8204120:	894b883a 	add	r5,r17,r5
 8204124:	d8c10415 	stw	r3,1040(sp)
 8204128:	820c5580 	call	820c558 <memcmp>
 820412c:	d8c10417 	ldw	r3,1040(sp)
 8204130:	10006a1e 	bne	r2,zero,82042dc <two_way_long_needle+0x264>
 8204134:	84bfffc4 	addi	r18,r16,-1
 8204138:	8c85883a 	add	r2,r17,r18
 820413c:	d8810215 	stw	r2,1032(sp)
 8204140:	00800044 	movi	r2,1
 8204144:	813fff84 	addi	r4,r16,-2
 8204148:	1405c83a 	sub	r2,r2,r16
 820414c:	0029883a 	mov	r20,zero
 8204150:	0039883a 	mov	fp,zero
 8204154:	b57fffc4 	addi	r21,r22,-1
 8204158:	d9010115 	stw	r4,1028(sp)
 820415c:	d8810315 	stw	r2,1036(sp)
 8204160:	00000706 	br	8204180 <two_way_long_needle+0x108>
 8204164:	a0000326 	beq	r20,zero,8204174 <two_way_long_needle+0xfc>
 8204168:	d8c10017 	ldw	r3,1024(sp)
 820416c:	10c0012e 	bgeu	r2,r3,8204174 <two_way_long_needle+0xfc>
 8204170:	b0c5c83a 	sub	r2,r22,r3
 8204174:	e0b9883a 	add	fp,fp,r2
 8204178:	0029883a 	mov	r20,zero
 820417c:	9807883a 	mov	r3,r19
 8204180:	e5a7883a 	add	r19,fp,r22
 8204184:	98cdc83a 	sub	r6,r19,r3
 8204188:	000b883a 	mov	r5,zero
 820418c:	b8c9883a 	add	r4,r23,r3
 8204190:	820c4740 	call	820c474 <memchr>
 8204194:	1000441e 	bne	r2,zero,82042a8 <two_way_long_needle+0x230>
 8204198:	98004326 	beq	r19,zero,82042a8 <two_way_long_needle+0x230>
 820419c:	bcc5883a 	add	r2,r23,r19
 82041a0:	10bfffc3 	ldbu	r2,-1(r2)
 82041a4:	1085883a 	add	r2,r2,r2
 82041a8:	1085883a 	add	r2,r2,r2
 82041ac:	d885883a 	add	r2,sp,r2
 82041b0:	10800017 	ldw	r2,0(r2)
 82041b4:	103feb1e 	bne	r2,zero,8204164 <two_way_long_needle+0xec>
 82041b8:	a015883a 	mov	r10,r20
 82041bc:	a400012e 	bgeu	r20,r16,82041c4 <two_way_long_needle+0x14c>
 82041c0:	8015883a 	mov	r10,r16
 82041c4:	5540152e 	bgeu	r10,r21,820421c <two_way_long_needle+0x1a4>
 82041c8:	bf05883a 	add	r2,r23,fp
 82041cc:	8a87883a 	add	r3,r17,r10
 82041d0:	1285883a 	add	r2,r2,r10
 82041d4:	18c00003 	ldbu	r3,0(r3)
 82041d8:	10800003 	ldbu	r2,0(r2)
 82041dc:	18802d1e 	bne	r3,r2,8204294 <two_way_long_needle+0x21c>
 82041e0:	e1400044 	addi	r5,fp,1
 82041e4:	50800044 	addi	r2,r10,1
 82041e8:	2a8b883a 	add	r5,r5,r10
 82041ec:	888d883a 	add	r6,r17,r2
 82041f0:	b94b883a 	add	r5,r23,r5
 82041f4:	00000706 	br	8204214 <two_way_long_needle+0x19c>
 82041f8:	31000003 	ldbu	r4,0(r6)
 82041fc:	28c00003 	ldbu	r3,0(r5)
 8204200:	31800044 	addi	r6,r6,1
 8204204:	21003fcc 	andi	r4,r4,255
 8204208:	29400044 	addi	r5,r5,1
 820420c:	20c0211e 	bne	r4,r3,8204294 <two_way_long_needle+0x21c>
 8204210:	10800044 	addi	r2,r2,1
 8204214:	1015883a 	mov	r10,r2
 8204218:	157ff736 	bltu	r2,r21,82041f8 <two_way_long_needle+0x180>
 820421c:	900d883a 	mov	r6,r18
 8204220:	a4007d2e 	bgeu	r20,r16,8204418 <two_way_long_needle+0x3a0>
 8204224:	d9410217 	ldw	r5,1032(sp)
 8204228:	bf05883a 	add	r2,r23,fp
 820422c:	1485883a 	add	r2,r2,r18
 8204230:	28c00003 	ldbu	r3,0(r5)
 8204234:	10800003 	ldbu	r2,0(r2)
 8204238:	1880771e 	bne	r3,r2,8204418 <two_way_long_needle+0x3a0>
 820423c:	d8c10117 	ldw	r3,1028(sp)
 8204240:	a2ffffc4 	addi	r11,r20,-1
 8204244:	8ad7883a 	add	r11,r17,r11
 8204248:	e0cb883a 	add	r5,fp,r3
 820424c:	88c5883a 	add	r2,r17,r3
 8204250:	b94b883a 	add	r5,r23,r5
 8204254:	00000706 	br	8204274 <two_way_long_needle+0x1fc>
 8204258:	11000003 	ldbu	r4,0(r2)
 820425c:	28c00003 	ldbu	r3,0(r5)
 8204260:	10bfffc4 	addi	r2,r2,-1
 8204264:	21003fcc 	andi	r4,r4,255
 8204268:	297fffc4 	addi	r5,r5,-1
 820426c:	20c0031e 	bne	r4,r3,820427c <two_way_long_needle+0x204>
 8204270:	500d883a 	mov	r6,r10
 8204274:	32bfffc4 	addi	r10,r6,-1
 8204278:	58bff71e 	bne	r11,r2,8204258 <two_way_long_needle+0x1e0>
 820427c:	a2400044 	addi	r9,r20,1
 8204280:	32406736 	bltu	r6,r9,8204420 <two_way_long_needle+0x3a8>
 8204284:	da410017 	ldw	r9,1024(sp)
 8204288:	e279883a 	add	fp,fp,r9
 820428c:	b269c83a 	sub	r20,r22,r9
 8204290:	003fba06 	br	820417c <two_way_long_needle+0x104>
 8204294:	d8c10317 	ldw	r3,1036(sp)
 8204298:	0029883a 	mov	r20,zero
 820429c:	1f39883a 	add	fp,r3,fp
 82042a0:	e2b9883a 	add	fp,fp,r10
 82042a4:	003fb506 	br	820417c <two_way_long_needle+0x104>
 82042a8:	0005883a 	mov	r2,zero
 82042ac:	dfc10e17 	ldw	ra,1080(sp)
 82042b0:	df010d17 	ldw	fp,1076(sp)
 82042b4:	ddc10c17 	ldw	r23,1072(sp)
 82042b8:	dd810b17 	ldw	r22,1068(sp)
 82042bc:	dd410a17 	ldw	r21,1064(sp)
 82042c0:	dd010917 	ldw	r20,1060(sp)
 82042c4:	dcc10817 	ldw	r19,1056(sp)
 82042c8:	dc810717 	ldw	r18,1052(sp)
 82042cc:	dc410617 	ldw	r17,1048(sp)
 82042d0:	dc010517 	ldw	r16,1044(sp)
 82042d4:	dec10f04 	addi	sp,sp,1084
 82042d8:	f800283a 	ret
 82042dc:	b405c83a 	sub	r2,r22,r16
 82042e0:	14004b36 	bltu	r2,r16,8204410 <two_way_long_needle+0x398>
 82042e4:	10800044 	addi	r2,r2,1
 82042e8:	84bfffc4 	addi	r18,r16,-1
 82042ec:	d8810015 	stw	r2,1024(sp)
 82042f0:	00800044 	movi	r2,1
 82042f4:	8c89883a 	add	r4,r17,r18
 82042f8:	817fff84 	addi	r5,r16,-2
 82042fc:	1405c83a 	sub	r2,r2,r16
 8204300:	0029883a 	mov	r20,zero
 8204304:	b73fffc4 	addi	fp,r22,-1
 8204308:	d9010215 	stw	r4,1032(sp)
 820430c:	d9410115 	stw	r5,1028(sp)
 8204310:	8d7fffc4 	addi	r21,r17,-1
 8204314:	d8810315 	stw	r2,1036(sp)
 8204318:	a5a7883a 	add	r19,r20,r22
 820431c:	98cdc83a 	sub	r6,r19,r3
 8204320:	000b883a 	mov	r5,zero
 8204324:	b8c9883a 	add	r4,r23,r3
 8204328:	820c4740 	call	820c474 <memchr>
 820432c:	103fde1e 	bne	r2,zero,82042a8 <two_way_long_needle+0x230>
 8204330:	983fdd26 	beq	r19,zero,82042a8 <two_way_long_needle+0x230>
 8204334:	bcc5883a 	add	r2,r23,r19
 8204338:	10bfffc3 	ldbu	r2,-1(r2)
 820433c:	1085883a 	add	r2,r2,r2
 8204340:	1085883a 	add	r2,r2,r2
 8204344:	d885883a 	add	r2,sp,r2
 8204348:	10800017 	ldw	r2,0(r2)
 820434c:	1000291e 	bne	r2,zero,82043f4 <two_way_long_needle+0x37c>
 8204350:	bd05883a 	add	r2,r23,r20
 8204354:	8700142e 	bgeu	r16,fp,82043a8 <two_way_long_needle+0x330>
 8204358:	8c07883a 	add	r3,r17,r16
 820435c:	140b883a 	add	r5,r2,r16
 8204360:	19000003 	ldbu	r4,0(r3)
 8204364:	28c00003 	ldbu	r3,0(r5)
 8204368:	800d883a 	mov	r6,r16
 820436c:	20c0241e 	bne	r4,r3,8204400 <two_way_long_needle+0x388>
 8204370:	81400044 	addi	r5,r16,1
 8204374:	a155883a 	add	r10,r20,r5
 8204378:	ba95883a 	add	r10,r23,r10
 820437c:	894b883a 	add	r5,r17,r5
 8204380:	800d883a 	mov	r6,r16
 8204384:	00000606 	br	82043a0 <two_way_long_needle+0x328>
 8204388:	29000003 	ldbu	r4,0(r5)
 820438c:	50c00003 	ldbu	r3,0(r10)
 8204390:	29400044 	addi	r5,r5,1
 8204394:	21003fcc 	andi	r4,r4,255
 8204398:	52800044 	addi	r10,r10,1
 820439c:	20c0181e 	bne	r4,r3,8204400 <two_way_long_needle+0x388>
 82043a0:	31800044 	addi	r6,r6,1
 82043a4:	373ff836 	bltu	r6,fp,8204388 <two_way_long_needle+0x310>
 82043a8:	00ffffc4 	movi	r3,-1
 82043ac:	90ffbf26 	beq	r18,r3,82042ac <two_way_long_needle+0x234>
 82043b0:	d9410217 	ldw	r5,1032(sp)
 82043b4:	1487883a 	add	r3,r2,r18
 82043b8:	18c00003 	ldbu	r3,0(r3)
 82043bc:	29000003 	ldbu	r4,0(r5)
 82043c0:	20c00b1e 	bne	r4,r3,82043f0 <two_way_long_needle+0x378>
 82043c4:	d8c10117 	ldw	r3,1028(sp)
 82043c8:	a0cd883a 	add	r6,r20,r3
 82043cc:	b98d883a 	add	r6,r23,r6
 82043d0:	88c7883a 	add	r3,r17,r3
 82043d4:	1d7fb526 	beq	r3,r21,82042ac <two_way_long_needle+0x234>
 82043d8:	19400003 	ldbu	r5,0(r3)
 82043dc:	31000003 	ldbu	r4,0(r6)
 82043e0:	18ffffc4 	addi	r3,r3,-1
 82043e4:	29403fcc 	andi	r5,r5,255
 82043e8:	31bfffc4 	addi	r6,r6,-1
 82043ec:	293ff926 	beq	r5,r4,82043d4 <two_way_long_needle+0x35c>
 82043f0:	d8810017 	ldw	r2,1024(sp)
 82043f4:	a0a9883a 	add	r20,r20,r2
 82043f8:	9807883a 	mov	r3,r19
 82043fc:	003fc606 	br	8204318 <two_way_long_needle+0x2a0>
 8204400:	d8c10317 	ldw	r3,1036(sp)
 8204404:	1d11883a 	add	r8,r3,r20
 8204408:	41a9883a 	add	r20,r8,r6
 820440c:	003ffa06 	br	82043f8 <two_way_long_needle+0x380>
 8204410:	8005883a 	mov	r2,r16
 8204414:	003fb306 	br	82042e4 <two_way_long_needle+0x26c>
 8204418:	800d883a 	mov	r6,r16
 820441c:	003f9706 	br	820427c <two_way_long_needle+0x204>
 8204420:	bf05883a 	add	r2,r23,fp
 8204424:	003fa106 	br	82042ac <two_way_long_needle+0x234>

08204428 <strstr>:
 8204428:	21800007 	ldb	r6,0(r4)
 820442c:	30009226 	beq	r6,zero,8204678 <strstr+0x250>
 8204430:	28c00007 	ldb	r3,0(r5)
 8204434:	18000f26 	beq	r3,zero,8204474 <strstr+0x4c>
 8204438:	280f883a 	mov	r7,r5
 820443c:	2011883a 	mov	r8,r4
 8204440:	02400044 	movi	r9,1
 8204444:	00000206 	br	8204450 <strstr+0x28>
 8204448:	38c00007 	ldb	r3,0(r7)
 820444c:	18000826 	beq	r3,zero,8204470 <strstr+0x48>
 8204450:	42000044 	addi	r8,r8,1
 8204454:	1987003a 	cmpeq	r3,r3,r6
 8204458:	41800007 	ldb	r6,0(r8)
 820445c:	39c00044 	addi	r7,r7,1
 8204460:	48d2703a 	and	r9,r9,r3
 8204464:	303ff81e 	bne	r6,zero,8204448 <strstr+0x20>
 8204468:	38800007 	ldb	r2,0(r7)
 820446c:	1000841e 	bne	r2,zero,8204680 <strstr+0x258>
 8204470:	48000226 	beq	r9,zero,820447c <strstr+0x54>
 8204474:	2005883a 	mov	r2,r4
 8204478:	f800283a 	ret
 820447c:	defff104 	addi	sp,sp,-60
 8204480:	ddc00c15 	stw	r23,48(sp)
 8204484:	dd800b15 	stw	r22,44(sp)
 8204488:	dd400a15 	stw	r21,40(sp)
 820448c:	dc000515 	stw	r16,20(sp)
 8204490:	dfc00e15 	stw	ra,56(sp)
 8204494:	df000d15 	stw	fp,52(sp)
 8204498:	dd000915 	stw	r20,36(sp)
 820449c:	dcc00815 	stw	r19,32(sp)
 82044a0:	dc800715 	stw	r18,28(sp)
 82044a4:	dc400615 	stw	r17,24(sp)
 82044a8:	282d883a 	mov	r22,r5
 82044ac:	29400007 	ldb	r5,0(r5)
 82044b0:	202b883a 	mov	r21,r4
 82044b4:	21000044 	addi	r4,r4,1
 82044b8:	3da1c83a 	sub	r16,r7,r22
 82044bc:	82037000 	call	8203700 <strchr>
 82044c0:	102f883a 	mov	r23,r2
 82044c4:	10007526 	beq	r2,zero,820469c <strstr+0x274>
 82044c8:	00c00044 	movi	r3,1
 82044cc:	80c00a26 	beq	r16,r3,82044f8 <strstr+0xd0>
 82044d0:	ac09883a 	add	r4,r21,r16
 82044d4:	20800136 	bltu	r4,r2,82044dc <strstr+0xb4>
 82044d8:	2087c83a 	sub	r3,r4,r2
 82044dc:	008007c4 	movi	r2,31
 82044e0:	1400112e 	bgeu	r2,r16,8204528 <strstr+0x100>
 82044e4:	800f883a 	mov	r7,r16
 82044e8:	b00d883a 	mov	r6,r22
 82044ec:	180b883a 	mov	r5,r3
 82044f0:	b809883a 	mov	r4,r23
 82044f4:	82040780 	call	8204078 <two_way_long_needle>
 82044f8:	dfc00e17 	ldw	ra,56(sp)
 82044fc:	df000d17 	ldw	fp,52(sp)
 8204500:	ddc00c17 	ldw	r23,48(sp)
 8204504:	dd800b17 	ldw	r22,44(sp)
 8204508:	dd400a17 	ldw	r21,40(sp)
 820450c:	dd000917 	ldw	r20,36(sp)
 8204510:	dcc00817 	ldw	r19,32(sp)
 8204514:	dc800717 	ldw	r18,28(sp)
 8204518:	dc400617 	ldw	r17,24(sp)
 820451c:	dc000517 	ldw	r16,20(sp)
 8204520:	dec00f04 	addi	sp,sp,60
 8204524:	f800283a 	ret
 8204528:	d80d883a 	mov	r6,sp
 820452c:	800b883a 	mov	r5,r16
 8204530:	b009883a 	mov	r4,r22
 8204534:	d8c00415 	stw	r3,16(sp)
 8204538:	8203f740 	call	8203f74 <critical_factorization>
 820453c:	d9400017 	ldw	r5,0(sp)
 8204540:	100d883a 	mov	r6,r2
 8204544:	b009883a 	mov	r4,r22
 8204548:	b14b883a 	add	r5,r22,r5
 820454c:	1039883a 	mov	fp,r2
 8204550:	820c5580 	call	820c558 <memcmp>
 8204554:	d8c00417 	ldw	r3,16(sp)
 8204558:	1000521e 	bne	r2,zero,82046a4 <strstr+0x27c>
 820455c:	e47fffc4 	addi	r17,fp,-1
 8204560:	04c00044 	movi	r19,1
 8204564:	b445883a 	add	r2,r22,r17
 8204568:	9f27c83a 	sub	r19,r19,fp
 820456c:	0029883a 	mov	r20,zero
 8204570:	002b883a 	mov	r21,zero
 8204574:	d8800215 	stw	r2,8(sp)
 8204578:	e4bfff84 	addi	r18,fp,-2
 820457c:	dcc00115 	stw	r19,4(sp)
 8204580:	8567883a 	add	r19,r16,r21
 8204584:	98cdc83a 	sub	r6,r19,r3
 8204588:	000b883a 	mov	r5,zero
 820458c:	b8c9883a 	add	r4,r23,r3
 8204590:	820c4740 	call	820c474 <memchr>
 8204594:	1000411e 	bne	r2,zero,820469c <strstr+0x274>
 8204598:	98004026 	beq	r19,zero,820469c <strstr+0x274>
 820459c:	e00b883a 	mov	r5,fp
 82045a0:	e500012e 	bgeu	fp,r20,82045a8 <strstr+0x180>
 82045a4:	a00b883a 	mov	r5,r20
 82045a8:	2c00152e 	bgeu	r5,r16,8204600 <strstr+0x1d8>
 82045ac:	b947883a 	add	r3,r23,r5
 82045b0:	1d47883a 	add	r3,r3,r21
 82045b4:	b145883a 	add	r2,r22,r5
 82045b8:	18c00003 	ldbu	r3,0(r3)
 82045bc:	10800003 	ldbu	r2,0(r2)
 82045c0:	1880311e 	bne	r3,r2,8204688 <strstr+0x260>
 82045c4:	a8800044 	addi	r2,r21,1
 82045c8:	28c00044 	addi	r3,r5,1
 82045cc:	1145883a 	add	r2,r2,r5
 82045d0:	b0c9883a 	add	r4,r22,r3
 82045d4:	b885883a 	add	r2,r23,r2
 82045d8:	00000706 	br	82045f8 <strstr+0x1d0>
 82045dc:	21c00003 	ldbu	r7,0(r4)
 82045e0:	11800003 	ldbu	r6,0(r2)
 82045e4:	21000044 	addi	r4,r4,1
 82045e8:	39c03fcc 	andi	r7,r7,255
 82045ec:	10800044 	addi	r2,r2,1
 82045f0:	3980251e 	bne	r7,r6,8204688 <strstr+0x260>
 82045f4:	18c00044 	addi	r3,r3,1
 82045f8:	180b883a 	mov	r5,r3
 82045fc:	1c3ff736 	bltu	r3,r16,82045dc <strstr+0x1b4>
 8204600:	880d883a 	mov	r6,r17
 8204604:	a700702e 	bgeu	r20,fp,82047c8 <strstr+0x3a0>
 8204608:	d9000217 	ldw	r4,8(sp)
 820460c:	bd45883a 	add	r2,r23,r21
 8204610:	1445883a 	add	r2,r2,r17
 8204614:	20c00003 	ldbu	r3,0(r4)
 8204618:	10800003 	ldbu	r2,0(r2)
 820461c:	18806a1e 	bne	r3,r2,82047c8 <strstr+0x3a0>
 8204620:	954b883a 	add	r5,r18,r21
 8204624:	a2bfffc4 	addi	r10,r20,-1
 8204628:	b485883a 	add	r2,r22,r18
 820462c:	b94b883a 	add	r5,r23,r5
 8204630:	b295883a 	add	r10,r22,r10
 8204634:	00000706 	br	8204654 <strstr+0x22c>
 8204638:	11000003 	ldbu	r4,0(r2)
 820463c:	28c00003 	ldbu	r3,0(r5)
 8204640:	10bfffc4 	addi	r2,r2,-1
 8204644:	21003fcc 	andi	r4,r4,255
 8204648:	297fffc4 	addi	r5,r5,-1
 820464c:	20c0031e 	bne	r4,r3,820465c <strstr+0x234>
 8204650:	380d883a 	mov	r6,r7
 8204654:	31ffffc4 	addi	r7,r6,-1
 8204658:	12bff71e 	bne	r2,r10,8204638 <strstr+0x210>
 820465c:	a2000044 	addi	r8,r20,1
 8204660:	32005b36 	bltu	r6,r8,82047d0 <strstr+0x3a8>
 8204664:	da000017 	ldw	r8,0(sp)
 8204668:	aa2b883a 	add	r21,r21,r8
 820466c:	8229c83a 	sub	r20,r16,r8
 8204670:	9807883a 	mov	r3,r19
 8204674:	003fc206 	br	8204580 <strstr+0x158>
 8204678:	28800007 	ldb	r2,0(r5)
 820467c:	103f7d26 	beq	r2,zero,8204474 <strstr+0x4c>
 8204680:	0005883a 	mov	r2,zero
 8204684:	f800283a 	ret
 8204688:	d8c00117 	ldw	r3,4(sp)
 820468c:	0029883a 	mov	r20,zero
 8204690:	1d6b883a 	add	r21,r3,r21
 8204694:	a96b883a 	add	r21,r21,r5
 8204698:	003ff506 	br	8204670 <strstr+0x248>
 820469c:	0005883a 	mov	r2,zero
 82046a0:	003f9506 	br	82044f8 <strstr+0xd0>
 82046a4:	8705c83a 	sub	r2,r16,fp
 82046a8:	1700012e 	bgeu	r2,fp,82046b0 <strstr+0x288>
 82046ac:	e005883a 	mov	r2,fp
 82046b0:	10800044 	addi	r2,r2,1
 82046b4:	e4bfffc4 	addi	r18,fp,-1
 82046b8:	05000044 	movi	r20,1
 82046bc:	a729c83a 	sub	r20,r20,fp
 82046c0:	d8800015 	stw	r2,0(sp)
 82046c4:	b48b883a 	add	r5,r22,r18
 82046c8:	e0bfff84 	addi	r2,fp,-2
 82046cc:	dd000215 	stw	r20,8(sp)
 82046d0:	002b883a 	mov	r21,zero
 82046d4:	e4400044 	addi	r17,fp,1
 82046d8:	d9400315 	stw	r5,12(sp)
 82046dc:	d8800115 	stw	r2,4(sp)
 82046e0:	b53fffc4 	addi	r20,r22,-1
 82046e4:	8567883a 	add	r19,r16,r21
 82046e8:	98cdc83a 	sub	r6,r19,r3
 82046ec:	000b883a 	mov	r5,zero
 82046f0:	b8c9883a 	add	r4,r23,r3
 82046f4:	820c4740 	call	820c474 <memchr>
 82046f8:	103fe81e 	bne	r2,zero,820469c <strstr+0x274>
 82046fc:	983fe726 	beq	r19,zero,820469c <strstr+0x274>
 8204700:	e400132e 	bgeu	fp,r16,8204750 <strstr+0x328>
 8204704:	bf07883a 	add	r3,r23,fp
 8204708:	1d47883a 	add	r3,r3,r21
 820470c:	b705883a 	add	r2,r22,fp
 8204710:	18c00003 	ldbu	r3,0(r3)
 8204714:	10800003 	ldbu	r2,0(r2)
 8204718:	1880241e 	bne	r3,r2,82047ac <strstr+0x384>
 820471c:	ac45883a 	add	r2,r21,r17
 8204720:	b44b883a 	add	r5,r22,r17
 8204724:	b885883a 	add	r2,r23,r2
 8204728:	e009883a 	mov	r4,fp
 820472c:	00000606 	br	8204748 <strstr+0x320>
 8204730:	29800003 	ldbu	r6,0(r5)
 8204734:	10c00003 	ldbu	r3,0(r2)
 8204738:	29400044 	addi	r5,r5,1
 820473c:	31803fcc 	andi	r6,r6,255
 8204740:	10800044 	addi	r2,r2,1
 8204744:	30c01a1e 	bne	r6,r3,82047b0 <strstr+0x388>
 8204748:	21000044 	addi	r4,r4,1
 820474c:	243ff836 	bltu	r4,r16,8204730 <strstr+0x308>
 8204750:	00bfffc4 	movi	r2,-1
 8204754:	bd49883a 	add	r4,r23,r21
 8204758:	90801926 	beq	r18,r2,82047c0 <strstr+0x398>
 820475c:	d9400317 	ldw	r5,12(sp)
 8204760:	2485883a 	add	r2,r4,r18
 8204764:	10800003 	ldbu	r2,0(r2)
 8204768:	28c00003 	ldbu	r3,0(r5)
 820476c:	18800b1e 	bne	r3,r2,820479c <strstr+0x374>
 8204770:	d8c00117 	ldw	r3,4(sp)
 8204774:	a8c5883a 	add	r2,r21,r3
 8204778:	b885883a 	add	r2,r23,r2
 820477c:	b0c7883a 	add	r3,r22,r3
 8204780:	1d000f26 	beq	r3,r20,82047c0 <strstr+0x398>
 8204784:	19800003 	ldbu	r6,0(r3)
 8204788:	11400003 	ldbu	r5,0(r2)
 820478c:	18ffffc4 	addi	r3,r3,-1
 8204790:	31803fcc 	andi	r6,r6,255
 8204794:	10bfffc4 	addi	r2,r2,-1
 8204798:	317ff926 	beq	r6,r5,8204780 <strstr+0x358>
 820479c:	d8800017 	ldw	r2,0(sp)
 82047a0:	a8ab883a 	add	r21,r21,r2
 82047a4:	9807883a 	mov	r3,r19
 82047a8:	003fce06 	br	82046e4 <strstr+0x2bc>
 82047ac:	e009883a 	mov	r4,fp
 82047b0:	d8c00217 	ldw	r3,8(sp)
 82047b4:	1d4f883a 	add	r7,r3,r21
 82047b8:	392b883a 	add	r21,r7,r4
 82047bc:	003ff906 	br	82047a4 <strstr+0x37c>
 82047c0:	2005883a 	mov	r2,r4
 82047c4:	003f4c06 	br	82044f8 <strstr+0xd0>
 82047c8:	e00d883a 	mov	r6,fp
 82047cc:	003fa306 	br	820465c <strstr+0x234>
 82047d0:	bd45883a 	add	r2,r23,r21
 82047d4:	003f4806 	br	82044f8 <strstr+0xd0>

082047d8 <___svfprintf_internal_r>:
 82047d8:	deffb704 	addi	sp,sp,-292
 82047dc:	dfc04815 	stw	ra,288(sp)
 82047e0:	ddc04615 	stw	r23,280(sp)
 82047e4:	d9402c15 	stw	r5,176(sp)
 82047e8:	d9003915 	stw	r4,228(sp)
 82047ec:	302f883a 	mov	r23,r6
 82047f0:	d9c02d15 	stw	r7,180(sp)
 82047f4:	df004715 	stw	fp,284(sp)
 82047f8:	dd804515 	stw	r22,276(sp)
 82047fc:	dd404415 	stw	r21,272(sp)
 8204800:	dd004315 	stw	r20,268(sp)
 8204804:	dcc04215 	stw	r19,264(sp)
 8204808:	dc804115 	stw	r18,260(sp)
 820480c:	dc404015 	stw	r17,256(sp)
 8204810:	dc003f15 	stw	r16,252(sp)
 8204814:	820ba7c0 	call	820ba7c <_localeconv_r>
 8204818:	10800017 	ldw	r2,0(r2)
 820481c:	1009883a 	mov	r4,r2
 8204820:	d8803415 	stw	r2,208(sp)
 8204824:	8203edc0 	call	8203edc <strlen>
 8204828:	d8c02c17 	ldw	r3,176(sp)
 820482c:	d8803815 	stw	r2,224(sp)
 8204830:	1880030b 	ldhu	r2,12(r3)
 8204834:	1080200c 	andi	r2,r2,128
 8204838:	10000226 	beq	r2,zero,8204844 <___svfprintf_internal_r+0x6c>
 820483c:	18800417 	ldw	r2,16(r3)
 8204840:	10067f26 	beq	r2,zero,8206240 <___svfprintf_internal_r+0x1a68>
 8204844:	dcc03917 	ldw	r19,228(sp)
 8204848:	d8c00404 	addi	r3,sp,16
 820484c:	05420974 	movhi	r21,2085
 8204850:	d9001e04 	addi	r4,sp,120
 8204854:	ad76d384 	addi	r21,r21,-9394
 8204858:	d8c01e15 	stw	r3,120(sp)
 820485c:	d8002015 	stw	zero,128(sp)
 8204860:	d8001f15 	stw	zero,124(sp)
 8204864:	d8003315 	stw	zero,204(sp)
 8204868:	d8003615 	stw	zero,216(sp)
 820486c:	d8003715 	stw	zero,220(sp)
 8204870:	1811883a 	mov	r8,r3
 8204874:	d8003a15 	stw	zero,232(sp)
 8204878:	d8003b15 	stw	zero,236(sp)
 820487c:	d8002f15 	stw	zero,188(sp)
 8204880:	d9002815 	stw	r4,160(sp)
 8204884:	b8800007 	ldb	r2,0(r23)
 8204888:	10026726 	beq	r2,zero,8205228 <___svfprintf_internal_r+0xa50>
 820488c:	00c00944 	movi	r3,37
 8204890:	b821883a 	mov	r16,r23
 8204894:	10c0021e 	bne	r2,r3,82048a0 <___svfprintf_internal_r+0xc8>
 8204898:	00001406 	br	82048ec <___svfprintf_internal_r+0x114>
 820489c:	10c00326 	beq	r2,r3,82048ac <___svfprintf_internal_r+0xd4>
 82048a0:	84000044 	addi	r16,r16,1
 82048a4:	80800007 	ldb	r2,0(r16)
 82048a8:	103ffc1e 	bne	r2,zero,820489c <___svfprintf_internal_r+0xc4>
 82048ac:	85e3c83a 	sub	r17,r16,r23
 82048b0:	88000e26 	beq	r17,zero,82048ec <___svfprintf_internal_r+0x114>
 82048b4:	d8c02017 	ldw	r3,128(sp)
 82048b8:	d8801f17 	ldw	r2,124(sp)
 82048bc:	45c00015 	stw	r23,0(r8)
 82048c0:	1c47883a 	add	r3,r3,r17
 82048c4:	10800044 	addi	r2,r2,1
 82048c8:	d8c02015 	stw	r3,128(sp)
 82048cc:	44400115 	stw	r17,4(r8)
 82048d0:	d8801f15 	stw	r2,124(sp)
 82048d4:	00c001c4 	movi	r3,7
 82048d8:	18809716 	blt	r3,r2,8204b38 <___svfprintf_internal_r+0x360>
 82048dc:	42000204 	addi	r8,r8,8
 82048e0:	d9402f17 	ldw	r5,188(sp)
 82048e4:	2c4b883a 	add	r5,r5,r17
 82048e8:	d9402f15 	stw	r5,188(sp)
 82048ec:	80800007 	ldb	r2,0(r16)
 82048f0:	10009826 	beq	r2,zero,8204b54 <___svfprintf_internal_r+0x37c>
 82048f4:	84400047 	ldb	r17,1(r16)
 82048f8:	00bfffc4 	movi	r2,-1
 82048fc:	85c00044 	addi	r23,r16,1
 8204900:	d8002785 	stb	zero,158(sp)
 8204904:	0007883a 	mov	r3,zero
 8204908:	000f883a 	mov	r7,zero
 820490c:	d8802915 	stw	r2,164(sp)
 8204910:	d8003115 	stw	zero,196(sp)
 8204914:	0025883a 	mov	r18,zero
 8204918:	01401604 	movi	r5,88
 820491c:	01800244 	movi	r6,9
 8204920:	02800a84 	movi	r10,42
 8204924:	02401b04 	movi	r9,108
 8204928:	bdc00044 	addi	r23,r23,1
 820492c:	88bff804 	addi	r2,r17,-32
 8204930:	2882f036 	bltu	r5,r2,82054f4 <___svfprintf_internal_r+0xd1c>
 8204934:	100490ba 	slli	r2,r2,2
 8204938:	01020834 	movhi	r4,2080
 820493c:	21125304 	addi	r4,r4,18764
 8204940:	1105883a 	add	r2,r2,r4
 8204944:	10800017 	ldw	r2,0(r2)
 8204948:	1000683a 	jmp	r2
 820494c:	0820545c 	xori	zero,at,33105
 8204950:	082054f4 	orhi	zero,at,33107
 8204954:	082054f4 	orhi	zero,at,33107
 8204958:	08205450 	cmplti	zero,at,-32431
 820495c:	082054f4 	orhi	zero,at,33107
 8204960:	082054f4 	orhi	zero,at,33107
 8204964:	082054f4 	orhi	zero,at,33107
 8204968:	082054f4 	orhi	zero,at,33107
 820496c:	082054f4 	orhi	zero,at,33107
 8204970:	082054f4 	orhi	zero,at,33107
 8204974:	08204bb0 	cmpltui	zero,at,33070
 8204978:	0820538c 	andi	zero,at,33102
 820497c:	082054f4 	orhi	zero,at,33107
 8204980:	08204ac0 	call	8204ac <OSCtxSw_SWITCH_PC+0x82046c>
 8204984:	08204bd8 	cmpnei	zero,at,-32465
 8204988:	082054f4 	orhi	zero,at,33107
 820498c:	08204c4c 	andi	zero,at,33073
 8204990:	08204c18 	cmpnei	zero,at,-32464
 8204994:	08204c18 	cmpnei	zero,at,-32464
 8204998:	08204c18 	cmpnei	zero,at,-32464
 820499c:	08204c18 	cmpnei	zero,at,-32464
 82049a0:	08204c18 	cmpnei	zero,at,-32464
 82049a4:	08204c18 	cmpnei	zero,at,-32464
 82049a8:	08204c18 	cmpnei	zero,at,-32464
 82049ac:	08204c18 	cmpnei	zero,at,-32464
 82049b0:	08204c18 	cmpnei	zero,at,-32464
 82049b4:	082054f4 	orhi	zero,at,33107
 82049b8:	082054f4 	orhi	zero,at,33107
 82049bc:	082054f4 	orhi	zero,at,33107
 82049c0:	082054f4 	orhi	zero,at,33107
 82049c4:	082054f4 	orhi	zero,at,33107
 82049c8:	082054f4 	orhi	zero,at,33107
 82049cc:	082054f4 	orhi	zero,at,33107
 82049d0:	082054f4 	orhi	zero,at,33107
 82049d4:	082054f4 	orhi	zero,at,33107
 82049d8:	082054f4 	orhi	zero,at,33107
 82049dc:	08204d04 	addi	zero,at,-32460
 82049e0:	08204c58 	cmpnei	zero,at,-32463
 82049e4:	082054f4 	orhi	zero,at,33107
 82049e8:	08204c58 	cmpnei	zero,at,-32463
 82049ec:	082054f4 	orhi	zero,at,33107
 82049f0:	082054f4 	orhi	zero,at,33107
 82049f4:	082054f4 	orhi	zero,at,33107
 82049f8:	082054f4 	orhi	zero,at,33107
 82049fc:	08204cf8 	rdprs	zero,at,-32461
 8204a00:	082054f4 	orhi	zero,at,33107
 8204a04:	082054f4 	orhi	zero,at,33107
 8204a08:	08204dc0 	call	8204dc <OSCtxSw_SWITCH_PC+0x82049c>
 8204a0c:	082054f4 	orhi	zero,at,33107
 8204a10:	082054f4 	orhi	zero,at,33107
 8204a14:	082054f4 	orhi	zero,at,33107
 8204a18:	082054f4 	orhi	zero,at,33107
 8204a1c:	082054f4 	orhi	zero,at,33107
 8204a20:	08205230 	cmpltui	zero,at,33096
 8204a24:	082054f4 	orhi	zero,at,33107
 8204a28:	082054f4 	orhi	zero,at,33107
 8204a2c:	08205290 	cmplti	zero,at,-32438
 8204a30:	082054f4 	orhi	zero,at,33107
 8204a34:	082054f4 	orhi	zero,at,33107
 8204a38:	082054f4 	orhi	zero,at,33107
 8204a3c:	082054f4 	orhi	zero,at,33107
 8204a40:	082054f4 	orhi	zero,at,33107
 8204a44:	082054f4 	orhi	zero,at,33107
 8204a48:	082054f4 	orhi	zero,at,33107
 8204a4c:	082054f4 	orhi	zero,at,33107
 8204a50:	082054f4 	orhi	zero,at,33107
 8204a54:	082054f4 	orhi	zero,at,33107
 8204a58:	08205340 	call	820534 <OSCtxSw_SWITCH_PC+0x8204f4>
 8204a5c:	0820547c 	xorhi	zero,at,33105
 8204a60:	08204c58 	cmpnei	zero,at,-32463
 8204a64:	08204c58 	cmpnei	zero,at,-32463
 8204a68:	08204c58 	cmpnei	zero,at,-32463
 8204a6c:	082054d0 	cmplti	zero,at,-32429
 8204a70:	0820547c 	xorhi	zero,at,33105
 8204a74:	082054f4 	orhi	zero,at,33107
 8204a78:	082054f4 	orhi	zero,at,33107
 8204a7c:	0820548c 	andi	zero,at,33106
 8204a80:	082054f4 	orhi	zero,at,33107
 8204a84:	0820549c 	xori	zero,at,33106
 8204a88:	0820537c 	xorhi	zero,at,33101
 8204a8c:	08204acc 	andi	zero,at,33067
 8204a90:	0820539c 	xori	zero,at,33102
 8204a94:	082054f4 	orhi	zero,at,33107
 8204a98:	082053a8 	cmpgeui	zero,at,33102
 8204a9c:	082054f4 	orhi	zero,at,33107
 8204aa0:	08205404 	addi	zero,at,-32432
 8204aa4:	082054f4 	orhi	zero,at,33107
 8204aa8:	082054f4 	orhi	zero,at,33107
 8204aac:	08205414 	ori	zero,at,33104
 8204ab0:	d9003117 	ldw	r4,196(sp)
 8204ab4:	d8802d15 	stw	r2,180(sp)
 8204ab8:	0109c83a 	sub	r4,zero,r4
 8204abc:	d9003115 	stw	r4,196(sp)
 8204ac0:	94800114 	ori	r18,r18,4
 8204ac4:	bc400007 	ldb	r17,0(r23)
 8204ac8:	003f9706 	br	8204928 <___svfprintf_internal_r+0x150>
 8204acc:	00800c04 	movi	r2,48
 8204ad0:	d9002d17 	ldw	r4,180(sp)
 8204ad4:	d9402917 	ldw	r5,164(sp)
 8204ad8:	d8802705 	stb	r2,156(sp)
 8204adc:	00801e04 	movi	r2,120
 8204ae0:	d8802745 	stb	r2,157(sp)
 8204ae4:	d8002785 	stb	zero,158(sp)
 8204ae8:	20c00104 	addi	r3,r4,4
 8204aec:	25000017 	ldw	r20,0(r4)
 8204af0:	002d883a 	mov	r22,zero
 8204af4:	90800094 	ori	r2,r18,2
 8204af8:	28028616 	blt	r5,zero,8205514 <___svfprintf_internal_r+0xd3c>
 8204afc:	00bfdfc4 	movi	r2,-129
 8204b00:	90a4703a 	and	r18,r18,r2
 8204b04:	d8c02d15 	stw	r3,180(sp)
 8204b08:	94800094 	ori	r18,r18,2
 8204b0c:	a002731e 	bne	r20,zero,82054dc <___svfprintf_internal_r+0xd04>
 8204b10:	00820974 	movhi	r2,2085
 8204b14:	10b6cc04 	addi	r2,r2,-9424
 8204b18:	d8803a15 	stw	r2,232(sp)
 8204b1c:	04401e04 	movi	r17,120
 8204b20:	d8c02917 	ldw	r3,164(sp)
 8204b24:	0039883a 	mov	fp,zero
 8204b28:	1801d526 	beq	r3,zero,8205280 <___svfprintf_internal_r+0xaa8>
 8204b2c:	0029883a 	mov	r20,zero
 8204b30:	002d883a 	mov	r22,zero
 8204b34:	0001f106 	br	82052fc <___svfprintf_internal_r+0xb24>
 8204b38:	d9402c17 	ldw	r5,176(sp)
 8204b3c:	d9801e04 	addi	r6,sp,120
 8204b40:	9809883a 	mov	r4,r19
 8204b44:	820e0040 	call	820e004 <__ssprint_r>
 8204b48:	1000081e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8204b4c:	da000404 	addi	r8,sp,16
 8204b50:	003f6306 	br	82048e0 <___svfprintf_internal_r+0x108>
 8204b54:	d8802017 	ldw	r2,128(sp)
 8204b58:	10000426 	beq	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8204b5c:	d9402c17 	ldw	r5,176(sp)
 8204b60:	d9003917 	ldw	r4,228(sp)
 8204b64:	d9801e04 	addi	r6,sp,120
 8204b68:	820e0040 	call	820e004 <__ssprint_r>
 8204b6c:	d8802c17 	ldw	r2,176(sp)
 8204b70:	10c0030b 	ldhu	r3,12(r2)
 8204b74:	d8802f17 	ldw	r2,188(sp)
 8204b78:	18c0100c 	andi	r3,r3,64
 8204b7c:	1805f51e 	bne	r3,zero,8206354 <___svfprintf_internal_r+0x1b7c>
 8204b80:	dfc04817 	ldw	ra,288(sp)
 8204b84:	df004717 	ldw	fp,284(sp)
 8204b88:	ddc04617 	ldw	r23,280(sp)
 8204b8c:	dd804517 	ldw	r22,276(sp)
 8204b90:	dd404417 	ldw	r21,272(sp)
 8204b94:	dd004317 	ldw	r20,268(sp)
 8204b98:	dcc04217 	ldw	r19,264(sp)
 8204b9c:	dc804117 	ldw	r18,260(sp)
 8204ba0:	dc404017 	ldw	r17,256(sp)
 8204ba4:	dc003f17 	ldw	r16,252(sp)
 8204ba8:	dec04904 	addi	sp,sp,292
 8204bac:	f800283a 	ret
 8204bb0:	d8802d17 	ldw	r2,180(sp)
 8204bb4:	d9002d17 	ldw	r4,180(sp)
 8204bb8:	10800017 	ldw	r2,0(r2)
 8204bbc:	d8803115 	stw	r2,196(sp)
 8204bc0:	20800104 	addi	r2,r4,4
 8204bc4:	d9003117 	ldw	r4,196(sp)
 8204bc8:	203fb916 	blt	r4,zero,8204ab0 <___svfprintf_internal_r+0x2d8>
 8204bcc:	d8802d15 	stw	r2,180(sp)
 8204bd0:	bc400007 	ldb	r17,0(r23)
 8204bd4:	003f5406 	br	8204928 <___svfprintf_internal_r+0x150>
 8204bd8:	bc400007 	ldb	r17,0(r23)
 8204bdc:	bac00044 	addi	r11,r23,1
 8204be0:	8a873926 	beq	r17,r10,82068c8 <___svfprintf_internal_r+0x20f0>
 8204be4:	88bff404 	addi	r2,r17,-48
 8204be8:	0009883a 	mov	r4,zero
 8204bec:	30868836 	bltu	r6,r2,8206610 <___svfprintf_internal_r+0x1e38>
 8204bf0:	5c400007 	ldb	r17,0(r11)
 8204bf4:	210002a4 	muli	r4,r4,10
 8204bf8:	5dc00044 	addi	r23,r11,1
 8204bfc:	b817883a 	mov	r11,r23
 8204c00:	2089883a 	add	r4,r4,r2
 8204c04:	88bff404 	addi	r2,r17,-48
 8204c08:	30bff92e 	bgeu	r6,r2,8204bf0 <___svfprintf_internal_r+0x418>
 8204c0c:	2005d716 	blt	r4,zero,820636c <___svfprintf_internal_r+0x1b94>
 8204c10:	d9002915 	stw	r4,164(sp)
 8204c14:	003f4506 	br	820492c <___svfprintf_internal_r+0x154>
 8204c18:	b809883a 	mov	r4,r23
 8204c1c:	d8003115 	stw	zero,196(sp)
 8204c20:	88bff404 	addi	r2,r17,-48
 8204c24:	0017883a 	mov	r11,zero
 8204c28:	24400007 	ldb	r17,0(r4)
 8204c2c:	5ac002a4 	muli	r11,r11,10
 8204c30:	bdc00044 	addi	r23,r23,1
 8204c34:	b809883a 	mov	r4,r23
 8204c38:	12d7883a 	add	r11,r2,r11
 8204c3c:	88bff404 	addi	r2,r17,-48
 8204c40:	30bff92e 	bgeu	r6,r2,8204c28 <___svfprintf_internal_r+0x450>
 8204c44:	dac03115 	stw	r11,196(sp)
 8204c48:	003f3806 	br	820492c <___svfprintf_internal_r+0x154>
 8204c4c:	94802014 	ori	r18,r18,128
 8204c50:	bc400007 	ldb	r17,0(r23)
 8204c54:	003f3406 	br	8204928 <___svfprintf_internal_r+0x150>
 8204c58:	18c03fcc 	andi	r3,r3,255
 8204c5c:	1807471e 	bne	r3,zero,820697c <___svfprintf_internal_r+0x21a4>
 8204c60:	9080020c 	andi	r2,r18,8
 8204c64:	10047d26 	beq	r2,zero,8205e5c <___svfprintf_internal_r+0x1684>
 8204c68:	d8c02d17 	ldw	r3,180(sp)
 8204c6c:	d9002d17 	ldw	r4,180(sp)
 8204c70:	d9402d17 	ldw	r5,180(sp)
 8204c74:	18c00017 	ldw	r3,0(r3)
 8204c78:	21000117 	ldw	r4,4(r4)
 8204c7c:	29400204 	addi	r5,r5,8
 8204c80:	d8c03615 	stw	r3,216(sp)
 8204c84:	d9003715 	stw	r4,220(sp)
 8204c88:	d9402d15 	stw	r5,180(sp)
 8204c8c:	d9003617 	ldw	r4,216(sp)
 8204c90:	d9403717 	ldw	r5,220(sp)
 8204c94:	da003e15 	stw	r8,248(sp)
 8204c98:	04000044 	movi	r16,1
 8204c9c:	820dd240 	call	820dd24 <__fpclassifyd>
 8204ca0:	da003e17 	ldw	r8,248(sp)
 8204ca4:	14044b1e 	bne	r2,r16,8205dd4 <___svfprintf_internal_r+0x15fc>
 8204ca8:	d9003617 	ldw	r4,216(sp)
 8204cac:	d9403717 	ldw	r5,220(sp)
 8204cb0:	000d883a 	mov	r6,zero
 8204cb4:	000f883a 	mov	r7,zero
 8204cb8:	8212fdc0 	call	8212fdc <__ledf2>
 8204cbc:	da003e17 	ldw	r8,248(sp)
 8204cc0:	1005f316 	blt	r2,zero,8206490 <___svfprintf_internal_r+0x1cb8>
 8204cc4:	df002783 	ldbu	fp,158(sp)
 8204cc8:	008011c4 	movi	r2,71
 8204ccc:	1445590e 	bge	r2,r17,8206234 <___svfprintf_internal_r+0x1a5c>
 8204cd0:	04020974 	movhi	r16,2085
 8204cd4:	8436c404 	addi	r16,r16,-9456
 8204cd8:	00c000c4 	movi	r3,3
 8204cdc:	00bfdfc4 	movi	r2,-129
 8204ce0:	d8c02a15 	stw	r3,168(sp)
 8204ce4:	90a4703a 	and	r18,r18,r2
 8204ce8:	d8c02e15 	stw	r3,184(sp)
 8204cec:	d8002915 	stw	zero,164(sp)
 8204cf0:	d8003215 	stw	zero,200(sp)
 8204cf4:	00006606 	br	8204e90 <___svfprintf_internal_r+0x6b8>
 8204cf8:	94800214 	ori	r18,r18,8
 8204cfc:	bc400007 	ldb	r17,0(r23)
 8204d00:	003f0906 	br	8204928 <___svfprintf_internal_r+0x150>
 8204d04:	18c03fcc 	andi	r3,r3,255
 8204d08:	1807181e 	bne	r3,zero,820696c <___svfprintf_internal_r+0x2194>
 8204d0c:	94800414 	ori	r18,r18,16
 8204d10:	9080080c 	andi	r2,r18,32
 8204d14:	10039626 	beq	r2,zero,8205b70 <___svfprintf_internal_r+0x1398>
 8204d18:	d9402d17 	ldw	r5,180(sp)
 8204d1c:	28800117 	ldw	r2,4(r5)
 8204d20:	2d000017 	ldw	r20,0(r5)
 8204d24:	29400204 	addi	r5,r5,8
 8204d28:	d9402d15 	stw	r5,180(sp)
 8204d2c:	102d883a 	mov	r22,r2
 8204d30:	10039816 	blt	r2,zero,8205b94 <___svfprintf_internal_r+0x13bc>
 8204d34:	d9402917 	ldw	r5,164(sp)
 8204d38:	df002783 	ldbu	fp,158(sp)
 8204d3c:	2803ab16 	blt	r5,zero,8205bec <___svfprintf_internal_r+0x1414>
 8204d40:	00ffdfc4 	movi	r3,-129
 8204d44:	a584b03a 	or	r2,r20,r22
 8204d48:	90e4703a 	and	r18,r18,r3
 8204d4c:	10014a26 	beq	r2,zero,8205278 <___svfprintf_internal_r+0xaa0>
 8204d50:	b0034b26 	beq	r22,zero,8205a80 <___svfprintf_internal_r+0x12a8>
 8204d54:	dc402a15 	stw	r17,168(sp)
 8204d58:	dc001e04 	addi	r16,sp,120
 8204d5c:	b023883a 	mov	r17,r22
 8204d60:	402d883a 	mov	r22,r8
 8204d64:	a009883a 	mov	r4,r20
 8204d68:	880b883a 	mov	r5,r17
 8204d6c:	01800284 	movi	r6,10
 8204d70:	000f883a 	mov	r7,zero
 8204d74:	82117ac0 	call	82117ac <__umoddi3>
 8204d78:	10800c04 	addi	r2,r2,48
 8204d7c:	843fffc4 	addi	r16,r16,-1
 8204d80:	a009883a 	mov	r4,r20
 8204d84:	880b883a 	mov	r5,r17
 8204d88:	80800005 	stb	r2,0(r16)
 8204d8c:	01800284 	movi	r6,10
 8204d90:	000f883a 	mov	r7,zero
 8204d94:	82112340 	call	8211234 <__udivdi3>
 8204d98:	1029883a 	mov	r20,r2
 8204d9c:	10c4b03a 	or	r2,r2,r3
 8204da0:	1823883a 	mov	r17,r3
 8204da4:	103fef1e 	bne	r2,zero,8204d64 <___svfprintf_internal_r+0x58c>
 8204da8:	d8c02817 	ldw	r3,160(sp)
 8204dac:	dc402a17 	ldw	r17,168(sp)
 8204db0:	b011883a 	mov	r8,r22
 8204db4:	1c07c83a 	sub	r3,r3,r16
 8204db8:	d8c02e15 	stw	r3,184(sp)
 8204dbc:	00002e06 	br	8204e78 <___svfprintf_internal_r+0x6a0>
 8204dc0:	18c03fcc 	andi	r3,r3,255
 8204dc4:	1806e71e 	bne	r3,zero,8206964 <___svfprintf_internal_r+0x218c>
 8204dc8:	94800414 	ori	r18,r18,16
 8204dcc:	9080080c 	andi	r2,r18,32
 8204dd0:	1002d426 	beq	r2,zero,8205924 <___svfprintf_internal_r+0x114c>
 8204dd4:	d9402d17 	ldw	r5,180(sp)
 8204dd8:	d8c02917 	ldw	r3,164(sp)
 8204ddc:	d8002785 	stb	zero,158(sp)
 8204de0:	28800204 	addi	r2,r5,8
 8204de4:	2d000017 	ldw	r20,0(r5)
 8204de8:	2d800117 	ldw	r22,4(r5)
 8204dec:	18041516 	blt	r3,zero,8205e44 <___svfprintf_internal_r+0x166c>
 8204df0:	013fdfc4 	movi	r4,-129
 8204df4:	a586b03a 	or	r3,r20,r22
 8204df8:	d8802d15 	stw	r2,180(sp)
 8204dfc:	9124703a 	and	r18,r18,r4
 8204e00:	1802d51e 	bne	r3,zero,8205958 <___svfprintf_internal_r+0x1180>
 8204e04:	d9402917 	ldw	r5,164(sp)
 8204e08:	0039883a 	mov	fp,zero
 8204e0c:	2806be26 	beq	r5,zero,8206908 <___svfprintf_internal_r+0x2130>
 8204e10:	0029883a 	mov	r20,zero
 8204e14:	002d883a 	mov	r22,zero
 8204e18:	dc001e04 	addi	r16,sp,120
 8204e1c:	a006d0fa 	srli	r3,r20,3
 8204e20:	b008977a 	slli	r4,r22,29
 8204e24:	b02cd0fa 	srli	r22,r22,3
 8204e28:	a50001cc 	andi	r20,r20,7
 8204e2c:	a0800c04 	addi	r2,r20,48
 8204e30:	843fffc4 	addi	r16,r16,-1
 8204e34:	20e8b03a 	or	r20,r4,r3
 8204e38:	80800005 	stb	r2,0(r16)
 8204e3c:	a586b03a 	or	r3,r20,r22
 8204e40:	183ff61e 	bne	r3,zero,8204e1c <___svfprintf_internal_r+0x644>
 8204e44:	90c0004c 	andi	r3,r18,1
 8204e48:	18013926 	beq	r3,zero,8205330 <___svfprintf_internal_r+0xb58>
 8204e4c:	10803fcc 	andi	r2,r2,255
 8204e50:	1080201c 	xori	r2,r2,128
 8204e54:	10bfe004 	addi	r2,r2,-128
 8204e58:	00c00c04 	movi	r3,48
 8204e5c:	10c13426 	beq	r2,r3,8205330 <___svfprintf_internal_r+0xb58>
 8204e60:	80ffffc5 	stb	r3,-1(r16)
 8204e64:	d8c02817 	ldw	r3,160(sp)
 8204e68:	80bfffc4 	addi	r2,r16,-1
 8204e6c:	1021883a 	mov	r16,r2
 8204e70:	1887c83a 	sub	r3,r3,r2
 8204e74:	d8c02e15 	stw	r3,184(sp)
 8204e78:	d8802e17 	ldw	r2,184(sp)
 8204e7c:	d9002917 	ldw	r4,164(sp)
 8204e80:	1100010e 	bge	r2,r4,8204e88 <___svfprintf_internal_r+0x6b0>
 8204e84:	2005883a 	mov	r2,r4
 8204e88:	d8802a15 	stw	r2,168(sp)
 8204e8c:	d8003215 	stw	zero,200(sp)
 8204e90:	e7003fcc 	andi	fp,fp,255
 8204e94:	e700201c 	xori	fp,fp,128
 8204e98:	e73fe004 	addi	fp,fp,-128
 8204e9c:	e0000326 	beq	fp,zero,8204eac <___svfprintf_internal_r+0x6d4>
 8204ea0:	d8c02a17 	ldw	r3,168(sp)
 8204ea4:	18c00044 	addi	r3,r3,1
 8204ea8:	d8c02a15 	stw	r3,168(sp)
 8204eac:	90c0008c 	andi	r3,r18,2
 8204eb0:	d8c02b15 	stw	r3,172(sp)
 8204eb4:	18000326 	beq	r3,zero,8204ec4 <___svfprintf_internal_r+0x6ec>
 8204eb8:	d8c02a17 	ldw	r3,168(sp)
 8204ebc:	18c00084 	addi	r3,r3,2
 8204ec0:	d8c02a15 	stw	r3,168(sp)
 8204ec4:	90c0210c 	andi	r3,r18,132
 8204ec8:	d8c03015 	stw	r3,192(sp)
 8204ecc:	1801a11e 	bne	r3,zero,8205554 <___svfprintf_internal_r+0xd7c>
 8204ed0:	d9003117 	ldw	r4,196(sp)
 8204ed4:	d8c02a17 	ldw	r3,168(sp)
 8204ed8:	20e9c83a 	sub	r20,r4,r3
 8204edc:	05019d0e 	bge	zero,r20,8205554 <___svfprintf_internal_r+0xd7c>
 8204ee0:	02400404 	movi	r9,16
 8204ee4:	d8c02017 	ldw	r3,128(sp)
 8204ee8:	d8801f17 	ldw	r2,124(sp)
 8204eec:	4d051b0e 	bge	r9,r20,820635c <___svfprintf_internal_r+0x1b84>
 8204ef0:	01420974 	movhi	r5,2085
 8204ef4:	2976d784 	addi	r5,r5,-9378
 8204ef8:	dc403c15 	stw	r17,240(sp)
 8204efc:	d9403515 	stw	r5,212(sp)
 8204f00:	a023883a 	mov	r17,r20
 8204f04:	482d883a 	mov	r22,r9
 8204f08:	9029883a 	mov	r20,r18
 8204f0c:	070001c4 	movi	fp,7
 8204f10:	8025883a 	mov	r18,r16
 8204f14:	dc002c17 	ldw	r16,176(sp)
 8204f18:	00000306 	br	8204f28 <___svfprintf_internal_r+0x750>
 8204f1c:	8c7ffc04 	addi	r17,r17,-16
 8204f20:	42000204 	addi	r8,r8,8
 8204f24:	b440130e 	bge	r22,r17,8204f74 <___svfprintf_internal_r+0x79c>
 8204f28:	01020974 	movhi	r4,2085
 8204f2c:	18c00404 	addi	r3,r3,16
 8204f30:	10800044 	addi	r2,r2,1
 8204f34:	2136d784 	addi	r4,r4,-9378
 8204f38:	41000015 	stw	r4,0(r8)
 8204f3c:	45800115 	stw	r22,4(r8)
 8204f40:	d8c02015 	stw	r3,128(sp)
 8204f44:	d8801f15 	stw	r2,124(sp)
 8204f48:	e0bff40e 	bge	fp,r2,8204f1c <___svfprintf_internal_r+0x744>
 8204f4c:	d9801e04 	addi	r6,sp,120
 8204f50:	800b883a 	mov	r5,r16
 8204f54:	9809883a 	mov	r4,r19
 8204f58:	820e0040 	call	820e004 <__ssprint_r>
 8204f5c:	103f031e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8204f60:	8c7ffc04 	addi	r17,r17,-16
 8204f64:	d8c02017 	ldw	r3,128(sp)
 8204f68:	d8801f17 	ldw	r2,124(sp)
 8204f6c:	da000404 	addi	r8,sp,16
 8204f70:	b47fed16 	blt	r22,r17,8204f28 <___svfprintf_internal_r+0x750>
 8204f74:	9021883a 	mov	r16,r18
 8204f78:	a025883a 	mov	r18,r20
 8204f7c:	8829883a 	mov	r20,r17
 8204f80:	dc403c17 	ldw	r17,240(sp)
 8204f84:	d9403517 	ldw	r5,212(sp)
 8204f88:	a0c7883a 	add	r3,r20,r3
 8204f8c:	10800044 	addi	r2,r2,1
 8204f90:	41400015 	stw	r5,0(r8)
 8204f94:	45000115 	stw	r20,4(r8)
 8204f98:	d8c02015 	stw	r3,128(sp)
 8204f9c:	d8801f15 	stw	r2,124(sp)
 8204fa0:	010001c4 	movi	r4,7
 8204fa4:	20829f16 	blt	r4,r2,8205a24 <___svfprintf_internal_r+0x124c>
 8204fa8:	df002787 	ldb	fp,158(sp)
 8204fac:	42000204 	addi	r8,r8,8
 8204fb0:	e0000c26 	beq	fp,zero,8204fe4 <___svfprintf_internal_r+0x80c>
 8204fb4:	d8801f17 	ldw	r2,124(sp)
 8204fb8:	d9002784 	addi	r4,sp,158
 8204fbc:	18c00044 	addi	r3,r3,1
 8204fc0:	10800044 	addi	r2,r2,1
 8204fc4:	41000015 	stw	r4,0(r8)
 8204fc8:	01000044 	movi	r4,1
 8204fcc:	41000115 	stw	r4,4(r8)
 8204fd0:	d8c02015 	stw	r3,128(sp)
 8204fd4:	d8801f15 	stw	r2,124(sp)
 8204fd8:	010001c4 	movi	r4,7
 8204fdc:	20823816 	blt	r4,r2,82058c0 <___svfprintf_internal_r+0x10e8>
 8204fe0:	42000204 	addi	r8,r8,8
 8204fe4:	d8802b17 	ldw	r2,172(sp)
 8204fe8:	10000c26 	beq	r2,zero,820501c <___svfprintf_internal_r+0x844>
 8204fec:	d8801f17 	ldw	r2,124(sp)
 8204ff0:	d9002704 	addi	r4,sp,156
 8204ff4:	18c00084 	addi	r3,r3,2
 8204ff8:	10800044 	addi	r2,r2,1
 8204ffc:	41000015 	stw	r4,0(r8)
 8205000:	01000084 	movi	r4,2
 8205004:	41000115 	stw	r4,4(r8)
 8205008:	d8c02015 	stw	r3,128(sp)
 820500c:	d8801f15 	stw	r2,124(sp)
 8205010:	010001c4 	movi	r4,7
 8205014:	20823216 	blt	r4,r2,82058e0 <___svfprintf_internal_r+0x1108>
 8205018:	42000204 	addi	r8,r8,8
 820501c:	d9003017 	ldw	r4,192(sp)
 8205020:	00802004 	movi	r2,128
 8205024:	20819726 	beq	r4,r2,8205684 <___svfprintf_internal_r+0xeac>
 8205028:	d9402917 	ldw	r5,164(sp)
 820502c:	d8802e17 	ldw	r2,184(sp)
 8205030:	28adc83a 	sub	r22,r5,r2
 8205034:	05802f0e 	bge	zero,r22,82050f4 <___svfprintf_internal_r+0x91c>
 8205038:	07000404 	movi	fp,16
 820503c:	d8801f17 	ldw	r2,124(sp)
 8205040:	e583c00e 	bge	fp,r22,8205f44 <___svfprintf_internal_r+0x176c>
 8205044:	01420974 	movhi	r5,2085
 8205048:	2976d384 	addi	r5,r5,-9394
 820504c:	dc402915 	stw	r17,164(sp)
 8205050:	d9402b15 	stw	r5,172(sp)
 8205054:	b023883a 	mov	r17,r22
 8205058:	050001c4 	movi	r20,7
 820505c:	902d883a 	mov	r22,r18
 8205060:	8025883a 	mov	r18,r16
 8205064:	dc002c17 	ldw	r16,176(sp)
 8205068:	00000306 	br	8205078 <___svfprintf_internal_r+0x8a0>
 820506c:	8c7ffc04 	addi	r17,r17,-16
 8205070:	42000204 	addi	r8,r8,8
 8205074:	e440110e 	bge	fp,r17,82050bc <___svfprintf_internal_r+0x8e4>
 8205078:	18c00404 	addi	r3,r3,16
 820507c:	10800044 	addi	r2,r2,1
 8205080:	45400015 	stw	r21,0(r8)
 8205084:	47000115 	stw	fp,4(r8)
 8205088:	d8c02015 	stw	r3,128(sp)
 820508c:	d8801f15 	stw	r2,124(sp)
 8205090:	a0bff60e 	bge	r20,r2,820506c <___svfprintf_internal_r+0x894>
 8205094:	d9801e04 	addi	r6,sp,120
 8205098:	800b883a 	mov	r5,r16
 820509c:	9809883a 	mov	r4,r19
 82050a0:	820e0040 	call	820e004 <__ssprint_r>
 82050a4:	103eb11e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 82050a8:	8c7ffc04 	addi	r17,r17,-16
 82050ac:	d8c02017 	ldw	r3,128(sp)
 82050b0:	d8801f17 	ldw	r2,124(sp)
 82050b4:	da000404 	addi	r8,sp,16
 82050b8:	e47fef16 	blt	fp,r17,8205078 <___svfprintf_internal_r+0x8a0>
 82050bc:	9021883a 	mov	r16,r18
 82050c0:	b025883a 	mov	r18,r22
 82050c4:	882d883a 	mov	r22,r17
 82050c8:	dc402917 	ldw	r17,164(sp)
 82050cc:	d9002b17 	ldw	r4,172(sp)
 82050d0:	1d87883a 	add	r3,r3,r22
 82050d4:	10800044 	addi	r2,r2,1
 82050d8:	41000015 	stw	r4,0(r8)
 82050dc:	45800115 	stw	r22,4(r8)
 82050e0:	d8c02015 	stw	r3,128(sp)
 82050e4:	d8801f15 	stw	r2,124(sp)
 82050e8:	010001c4 	movi	r4,7
 82050ec:	2081ec16 	blt	r4,r2,82058a0 <___svfprintf_internal_r+0x10c8>
 82050f0:	42000204 	addi	r8,r8,8
 82050f4:	9080400c 	andi	r2,r18,256
 82050f8:	1001181e 	bne	r2,zero,820555c <___svfprintf_internal_r+0xd84>
 82050fc:	d9402e17 	ldw	r5,184(sp)
 8205100:	d8801f17 	ldw	r2,124(sp)
 8205104:	44000015 	stw	r16,0(r8)
 8205108:	1947883a 	add	r3,r3,r5
 820510c:	10800044 	addi	r2,r2,1
 8205110:	41400115 	stw	r5,4(r8)
 8205114:	d8c02015 	stw	r3,128(sp)
 8205118:	d8801f15 	stw	r2,124(sp)
 820511c:	010001c4 	movi	r4,7
 8205120:	2081d116 	blt	r4,r2,8205868 <___svfprintf_internal_r+0x1090>
 8205124:	42000204 	addi	r8,r8,8
 8205128:	9480010c 	andi	r18,r18,4
 820512c:	90003226 	beq	r18,zero,82051f8 <___svfprintf_internal_r+0xa20>
 8205130:	d9403117 	ldw	r5,196(sp)
 8205134:	d8802a17 	ldw	r2,168(sp)
 8205138:	28a1c83a 	sub	r16,r5,r2
 820513c:	04002e0e 	bge	zero,r16,82051f8 <___svfprintf_internal_r+0xa20>
 8205140:	04400404 	movi	r17,16
 8205144:	d8801f17 	ldw	r2,124(sp)
 8205148:	8c04b90e 	bge	r17,r16,8206430 <___svfprintf_internal_r+0x1c58>
 820514c:	01420974 	movhi	r5,2085
 8205150:	2976d784 	addi	r5,r5,-9378
 8205154:	d9403515 	stw	r5,212(sp)
 8205158:	048001c4 	movi	r18,7
 820515c:	dd002c17 	ldw	r20,176(sp)
 8205160:	00000306 	br	8205170 <___svfprintf_internal_r+0x998>
 8205164:	843ffc04 	addi	r16,r16,-16
 8205168:	42000204 	addi	r8,r8,8
 820516c:	8c00130e 	bge	r17,r16,82051bc <___svfprintf_internal_r+0x9e4>
 8205170:	01020974 	movhi	r4,2085
 8205174:	18c00404 	addi	r3,r3,16
 8205178:	10800044 	addi	r2,r2,1
 820517c:	2136d784 	addi	r4,r4,-9378
 8205180:	41000015 	stw	r4,0(r8)
 8205184:	44400115 	stw	r17,4(r8)
 8205188:	d8c02015 	stw	r3,128(sp)
 820518c:	d8801f15 	stw	r2,124(sp)
 8205190:	90bff40e 	bge	r18,r2,8205164 <___svfprintf_internal_r+0x98c>
 8205194:	d9801e04 	addi	r6,sp,120
 8205198:	a00b883a 	mov	r5,r20
 820519c:	9809883a 	mov	r4,r19
 82051a0:	820e0040 	call	820e004 <__ssprint_r>
 82051a4:	103e711e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 82051a8:	843ffc04 	addi	r16,r16,-16
 82051ac:	d8c02017 	ldw	r3,128(sp)
 82051b0:	d8801f17 	ldw	r2,124(sp)
 82051b4:	da000404 	addi	r8,sp,16
 82051b8:	8c3fed16 	blt	r17,r16,8205170 <___svfprintf_internal_r+0x998>
 82051bc:	d9403517 	ldw	r5,212(sp)
 82051c0:	1c07883a 	add	r3,r3,r16
 82051c4:	10800044 	addi	r2,r2,1
 82051c8:	41400015 	stw	r5,0(r8)
 82051cc:	44000115 	stw	r16,4(r8)
 82051d0:	d8c02015 	stw	r3,128(sp)
 82051d4:	d8801f15 	stw	r2,124(sp)
 82051d8:	010001c4 	movi	r4,7
 82051dc:	2080060e 	bge	r4,r2,82051f8 <___svfprintf_internal_r+0xa20>
 82051e0:	d9402c17 	ldw	r5,176(sp)
 82051e4:	d9801e04 	addi	r6,sp,120
 82051e8:	9809883a 	mov	r4,r19
 82051ec:	820e0040 	call	820e004 <__ssprint_r>
 82051f0:	103e5e1e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 82051f4:	d8c02017 	ldw	r3,128(sp)
 82051f8:	d8803117 	ldw	r2,196(sp)
 82051fc:	d9002a17 	ldw	r4,168(sp)
 8205200:	1100010e 	bge	r2,r4,8205208 <___svfprintf_internal_r+0xa30>
 8205204:	2005883a 	mov	r2,r4
 8205208:	d9402f17 	ldw	r5,188(sp)
 820520c:	288b883a 	add	r5,r5,r2
 8205210:	d9402f15 	stw	r5,188(sp)
 8205214:	18019c1e 	bne	r3,zero,8205888 <___svfprintf_internal_r+0x10b0>
 8205218:	b8800007 	ldb	r2,0(r23)
 820521c:	d8001f15 	stw	zero,124(sp)
 8205220:	da000404 	addi	r8,sp,16
 8205224:	103d991e 	bne	r2,zero,820488c <___svfprintf_internal_r+0xb4>
 8205228:	b821883a 	mov	r16,r23
 820522c:	003daf06 	br	82048ec <___svfprintf_internal_r+0x114>
 8205230:	18c03fcc 	andi	r3,r3,255
 8205234:	1805c71e 	bne	r3,zero,8206954 <___svfprintf_internal_r+0x217c>
 8205238:	94800414 	ori	r18,r18,16
 820523c:	9080080c 	andi	r2,r18,32
 8205240:	10020126 	beq	r2,zero,8205a48 <___svfprintf_internal_r+0x1270>
 8205244:	d8802d17 	ldw	r2,180(sp)
 8205248:	d9002917 	ldw	r4,164(sp)
 820524c:	d8002785 	stb	zero,158(sp)
 8205250:	10c00204 	addi	r3,r2,8
 8205254:	15000017 	ldw	r20,0(r2)
 8205258:	15800117 	ldw	r22,4(r2)
 820525c:	20038e16 	blt	r4,zero,8206098 <___svfprintf_internal_r+0x18c0>
 8205260:	013fdfc4 	movi	r4,-129
 8205264:	a584b03a 	or	r2,r20,r22
 8205268:	d8c02d15 	stw	r3,180(sp)
 820526c:	9124703a 	and	r18,r18,r4
 8205270:	0039883a 	mov	fp,zero
 8205274:	103eb61e 	bne	r2,zero,8204d50 <___svfprintf_internal_r+0x578>
 8205278:	d8802917 	ldw	r2,164(sp)
 820527c:	1002c81e 	bne	r2,zero,8205da0 <___svfprintf_internal_r+0x15c8>
 8205280:	d8002915 	stw	zero,164(sp)
 8205284:	d8002e15 	stw	zero,184(sp)
 8205288:	dc001e04 	addi	r16,sp,120
 820528c:	003efa06 	br	8204e78 <___svfprintf_internal_r+0x6a0>
 8205290:	18c03fcc 	andi	r3,r3,255
 8205294:	1805ad1e 	bne	r3,zero,820694c <___svfprintf_internal_r+0x2174>
 8205298:	01420974 	movhi	r5,2085
 820529c:	2976c704 	addi	r5,r5,-9444
 82052a0:	d9403a15 	stw	r5,232(sp)
 82052a4:	9080080c 	andi	r2,r18,32
 82052a8:	10006126 	beq	r2,zero,8205430 <___svfprintf_internal_r+0xc58>
 82052ac:	d8802d17 	ldw	r2,180(sp)
 82052b0:	15000017 	ldw	r20,0(r2)
 82052b4:	15800117 	ldw	r22,4(r2)
 82052b8:	10800204 	addi	r2,r2,8
 82052bc:	d8802d15 	stw	r2,180(sp)
 82052c0:	9080004c 	andi	r2,r18,1
 82052c4:	10018e26 	beq	r2,zero,8205900 <___svfprintf_internal_r+0x1128>
 82052c8:	a584b03a 	or	r2,r20,r22
 82052cc:	10030926 	beq	r2,zero,8205ef4 <___svfprintf_internal_r+0x171c>
 82052d0:	d8c02917 	ldw	r3,164(sp)
 82052d4:	00800c04 	movi	r2,48
 82052d8:	d8802705 	stb	r2,156(sp)
 82052dc:	dc402745 	stb	r17,157(sp)
 82052e0:	d8002785 	stb	zero,158(sp)
 82052e4:	90800094 	ori	r2,r18,2
 82052e8:	18048716 	blt	r3,zero,8206508 <___svfprintf_internal_r+0x1d30>
 82052ec:	00bfdfc4 	movi	r2,-129
 82052f0:	90a4703a 	and	r18,r18,r2
 82052f4:	94800094 	ori	r18,r18,2
 82052f8:	0039883a 	mov	fp,zero
 82052fc:	d9003a17 	ldw	r4,232(sp)
 8205300:	dc001e04 	addi	r16,sp,120
 8205304:	a08003cc 	andi	r2,r20,15
 8205308:	b006973a 	slli	r3,r22,28
 820530c:	2085883a 	add	r2,r4,r2
 8205310:	a028d13a 	srli	r20,r20,4
 8205314:	10800003 	ldbu	r2,0(r2)
 8205318:	b02cd13a 	srli	r22,r22,4
 820531c:	843fffc4 	addi	r16,r16,-1
 8205320:	1d28b03a 	or	r20,r3,r20
 8205324:	80800005 	stb	r2,0(r16)
 8205328:	a584b03a 	or	r2,r20,r22
 820532c:	103ff51e 	bne	r2,zero,8205304 <___svfprintf_internal_r+0xb2c>
 8205330:	d8c02817 	ldw	r3,160(sp)
 8205334:	1c07c83a 	sub	r3,r3,r16
 8205338:	d8c02e15 	stw	r3,184(sp)
 820533c:	003ece06 	br	8204e78 <___svfprintf_internal_r+0x6a0>
 8205340:	d8c02d17 	ldw	r3,180(sp)
 8205344:	d9002d17 	ldw	r4,180(sp)
 8205348:	d8002785 	stb	zero,158(sp)
 820534c:	18800017 	ldw	r2,0(r3)
 8205350:	21000104 	addi	r4,r4,4
 8205354:	00c00044 	movi	r3,1
 8205358:	d8c02a15 	stw	r3,168(sp)
 820535c:	d8801405 	stb	r2,80(sp)
 8205360:	d9002d15 	stw	r4,180(sp)
 8205364:	d8c02e15 	stw	r3,184(sp)
 8205368:	d8002915 	stw	zero,164(sp)
 820536c:	d8003215 	stw	zero,200(sp)
 8205370:	dc001404 	addi	r16,sp,80
 8205374:	0039883a 	mov	fp,zero
 8205378:	003ecc06 	br	8204eac <___svfprintf_internal_r+0x6d4>
 820537c:	18c03fcc 	andi	r3,r3,255
 8205380:	183e9226 	beq	r3,zero,8204dcc <___svfprintf_internal_r+0x5f4>
 8205384:	d9c02785 	stb	r7,158(sp)
 8205388:	003e9006 	br	8204dcc <___svfprintf_internal_r+0x5f4>
 820538c:	00c00044 	movi	r3,1
 8205390:	01c00ac4 	movi	r7,43
 8205394:	bc400007 	ldb	r17,0(r23)
 8205398:	003d6306 	br	8204928 <___svfprintf_internal_r+0x150>
 820539c:	94800814 	ori	r18,r18,32
 82053a0:	bc400007 	ldb	r17,0(r23)
 82053a4:	003d6006 	br	8204928 <___svfprintf_internal_r+0x150>
 82053a8:	d8c02d17 	ldw	r3,180(sp)
 82053ac:	d8002785 	stb	zero,158(sp)
 82053b0:	1c000017 	ldw	r16,0(r3)
 82053b4:	1d000104 	addi	r20,r3,4
 82053b8:	80040f26 	beq	r16,zero,82063f8 <___svfprintf_internal_r+0x1c20>
 82053bc:	d9002917 	ldw	r4,164(sp)
 82053c0:	2003dc16 	blt	r4,zero,8206334 <___svfprintf_internal_r+0x1b5c>
 82053c4:	200d883a 	mov	r6,r4
 82053c8:	000b883a 	mov	r5,zero
 82053cc:	8009883a 	mov	r4,r16
 82053d0:	da003e15 	stw	r8,248(sp)
 82053d4:	820c4740 	call	820c474 <memchr>
 82053d8:	da003e17 	ldw	r8,248(sp)
 82053dc:	10045826 	beq	r2,zero,8206540 <___svfprintf_internal_r+0x1d68>
 82053e0:	1405c83a 	sub	r2,r2,r16
 82053e4:	d8802e15 	stw	r2,184(sp)
 82053e8:	1003d816 	blt	r2,zero,820634c <___svfprintf_internal_r+0x1b74>
 82053ec:	df002783 	ldbu	fp,158(sp)
 82053f0:	d8802a15 	stw	r2,168(sp)
 82053f4:	dd002d15 	stw	r20,180(sp)
 82053f8:	d8002915 	stw	zero,164(sp)
 82053fc:	d8003215 	stw	zero,200(sp)
 8205400:	003ea306 	br	8204e90 <___svfprintf_internal_r+0x6b8>
 8205404:	18c03fcc 	andi	r3,r3,255
 8205408:	183f8c26 	beq	r3,zero,820523c <___svfprintf_internal_r+0xa64>
 820540c:	d9c02785 	stb	r7,158(sp)
 8205410:	003f8a06 	br	820523c <___svfprintf_internal_r+0xa64>
 8205414:	18c03fcc 	andi	r3,r3,255
 8205418:	1805631e 	bne	r3,zero,82069a8 <___svfprintf_internal_r+0x21d0>
 820541c:	01420974 	movhi	r5,2085
 8205420:	2976cc04 	addi	r5,r5,-9424
 8205424:	d9403a15 	stw	r5,232(sp)
 8205428:	9080080c 	andi	r2,r18,32
 820542c:	103f9f1e 	bne	r2,zero,82052ac <___svfprintf_internal_r+0xad4>
 8205430:	9080040c 	andi	r2,r18,16
 8205434:	10029c26 	beq	r2,zero,8205ea8 <___svfprintf_internal_r+0x16d0>
 8205438:	d8c02d17 	ldw	r3,180(sp)
 820543c:	002d883a 	mov	r22,zero
 8205440:	1d000017 	ldw	r20,0(r3)
 8205444:	18c00104 	addi	r3,r3,4
 8205448:	d8c02d15 	stw	r3,180(sp)
 820544c:	003f9c06 	br	82052c0 <___svfprintf_internal_r+0xae8>
 8205450:	94800054 	ori	r18,r18,1
 8205454:	bc400007 	ldb	r17,0(r23)
 8205458:	003d3306 	br	8204928 <___svfprintf_internal_r+0x150>
 820545c:	38803fcc 	andi	r2,r7,255
 8205460:	1080201c 	xori	r2,r2,128
 8205464:	10bfe004 	addi	r2,r2,-128
 8205468:	1002971e 	bne	r2,zero,8205ec8 <___svfprintf_internal_r+0x16f0>
 820546c:	00c00044 	movi	r3,1
 8205470:	01c00804 	movi	r7,32
 8205474:	bc400007 	ldb	r17,0(r23)
 8205478:	003d2b06 	br	8204928 <___svfprintf_internal_r+0x150>
 820547c:	18c03fcc 	andi	r3,r3,255
 8205480:	183e2326 	beq	r3,zero,8204d10 <___svfprintf_internal_r+0x538>
 8205484:	d9c02785 	stb	r7,158(sp)
 8205488:	003e2106 	br	8204d10 <___svfprintf_internal_r+0x538>
 820548c:	bc400007 	ldb	r17,0(r23)
 8205490:	8a430426 	beq	r17,r9,82060a4 <___svfprintf_internal_r+0x18cc>
 8205494:	94800414 	ori	r18,r18,16
 8205498:	003d2306 	br	8204928 <___svfprintf_internal_r+0x150>
 820549c:	18c03fcc 	andi	r3,r3,255
 82054a0:	18053f1e 	bne	r3,zero,82069a0 <___svfprintf_internal_r+0x21c8>
 82054a4:	9080080c 	andi	r2,r18,32
 82054a8:	10028926 	beq	r2,zero,8205ed0 <___svfprintf_internal_r+0x16f8>
 82054ac:	d9402d17 	ldw	r5,180(sp)
 82054b0:	d9002f17 	ldw	r4,188(sp)
 82054b4:	28800017 	ldw	r2,0(r5)
 82054b8:	2007d7fa 	srai	r3,r4,31
 82054bc:	29400104 	addi	r5,r5,4
 82054c0:	d9402d15 	stw	r5,180(sp)
 82054c4:	11000015 	stw	r4,0(r2)
 82054c8:	10c00115 	stw	r3,4(r2)
 82054cc:	003ced06 	br	8204884 <___svfprintf_internal_r+0xac>
 82054d0:	94801014 	ori	r18,r18,64
 82054d4:	bc400007 	ldb	r17,0(r23)
 82054d8:	003d1306 	br	8204928 <___svfprintf_internal_r+0x150>
 82054dc:	01020974 	movhi	r4,2085
 82054e0:	2136cc04 	addi	r4,r4,-9424
 82054e4:	0039883a 	mov	fp,zero
 82054e8:	d9003a15 	stw	r4,232(sp)
 82054ec:	04401e04 	movi	r17,120
 82054f0:	003f8206 	br	82052fc <___svfprintf_internal_r+0xb24>
 82054f4:	18c03fcc 	andi	r3,r3,255
 82054f8:	1805221e 	bne	r3,zero,8206984 <___svfprintf_internal_r+0x21ac>
 82054fc:	883d9526 	beq	r17,zero,8204b54 <___svfprintf_internal_r+0x37c>
 8205500:	00c00044 	movi	r3,1
 8205504:	d8c02a15 	stw	r3,168(sp)
 8205508:	dc401405 	stb	r17,80(sp)
 820550c:	d8002785 	stb	zero,158(sp)
 8205510:	003f9406 	br	8205364 <___svfprintf_internal_r+0xb8c>
 8205514:	01020974 	movhi	r4,2085
 8205518:	2136cc04 	addi	r4,r4,-9424
 820551c:	d9003a15 	stw	r4,232(sp)
 8205520:	d8c02d15 	stw	r3,180(sp)
 8205524:	1025883a 	mov	r18,r2
 8205528:	04401e04 	movi	r17,120
 820552c:	a584b03a 	or	r2,r20,r22
 8205530:	1000fa1e 	bne	r2,zero,820591c <___svfprintf_internal_r+0x1144>
 8205534:	0039883a 	mov	fp,zero
 8205538:	00800084 	movi	r2,2
 820553c:	10803fcc 	andi	r2,r2,255
 8205540:	00c00044 	movi	r3,1
 8205544:	10c21626 	beq	r2,r3,8205da0 <___svfprintf_internal_r+0x15c8>
 8205548:	00c00084 	movi	r3,2
 820554c:	10fe301e 	bne	r2,r3,8204e10 <___svfprintf_internal_r+0x638>
 8205550:	003d7606 	br	8204b2c <___svfprintf_internal_r+0x354>
 8205554:	d8c02017 	ldw	r3,128(sp)
 8205558:	003e9506 	br	8204fb0 <___svfprintf_internal_r+0x7d8>
 820555c:	00801944 	movi	r2,101
 8205560:	14407c0e 	bge	r2,r17,8205754 <___svfprintf_internal_r+0xf7c>
 8205564:	d9003617 	ldw	r4,216(sp)
 8205568:	d9403717 	ldw	r5,220(sp)
 820556c:	000d883a 	mov	r6,zero
 8205570:	000f883a 	mov	r7,zero
 8205574:	d8c03d15 	stw	r3,244(sp)
 8205578:	da003e15 	stw	r8,248(sp)
 820557c:	8212e780 	call	8212e78 <__eqdf2>
 8205580:	d8c03d17 	ldw	r3,244(sp)
 8205584:	da003e17 	ldw	r8,248(sp)
 8205588:	1000f51e 	bne	r2,zero,8205960 <___svfprintf_internal_r+0x1188>
 820558c:	d8801f17 	ldw	r2,124(sp)
 8205590:	01020974 	movhi	r4,2085
 8205594:	2136d304 	addi	r4,r4,-9396
 8205598:	18c00044 	addi	r3,r3,1
 820559c:	10800044 	addi	r2,r2,1
 82055a0:	41000015 	stw	r4,0(r8)
 82055a4:	01000044 	movi	r4,1
 82055a8:	41000115 	stw	r4,4(r8)
 82055ac:	d8c02015 	stw	r3,128(sp)
 82055b0:	d8801f15 	stw	r2,124(sp)
 82055b4:	010001c4 	movi	r4,7
 82055b8:	20826616 	blt	r4,r2,8205f54 <___svfprintf_internal_r+0x177c>
 82055bc:	42000204 	addi	r8,r8,8
 82055c0:	d8802617 	ldw	r2,152(sp)
 82055c4:	d9403317 	ldw	r5,204(sp)
 82055c8:	11400216 	blt	r2,r5,82055d4 <___svfprintf_internal_r+0xdfc>
 82055cc:	9080004c 	andi	r2,r18,1
 82055d0:	103ed526 	beq	r2,zero,8205128 <___svfprintf_internal_r+0x950>
 82055d4:	d8803817 	ldw	r2,224(sp)
 82055d8:	d9003417 	ldw	r4,208(sp)
 82055dc:	d9403817 	ldw	r5,224(sp)
 82055e0:	1887883a 	add	r3,r3,r2
 82055e4:	d8801f17 	ldw	r2,124(sp)
 82055e8:	41000015 	stw	r4,0(r8)
 82055ec:	41400115 	stw	r5,4(r8)
 82055f0:	10800044 	addi	r2,r2,1
 82055f4:	d8c02015 	stw	r3,128(sp)
 82055f8:	d8801f15 	stw	r2,124(sp)
 82055fc:	010001c4 	movi	r4,7
 8205600:	2082af16 	blt	r4,r2,82060c0 <___svfprintf_internal_r+0x18e8>
 8205604:	42000204 	addi	r8,r8,8
 8205608:	d8803317 	ldw	r2,204(sp)
 820560c:	143fffc4 	addi	r16,r2,-1
 8205610:	043ec50e 	bge	zero,r16,8205128 <___svfprintf_internal_r+0x950>
 8205614:	04400404 	movi	r17,16
 8205618:	d8801f17 	ldw	r2,124(sp)
 820561c:	8c00860e 	bge	r17,r16,8205838 <___svfprintf_internal_r+0x1060>
 8205620:	01420974 	movhi	r5,2085
 8205624:	2976d384 	addi	r5,r5,-9394
 8205628:	d9402b15 	stw	r5,172(sp)
 820562c:	058001c4 	movi	r22,7
 8205630:	dd002c17 	ldw	r20,176(sp)
 8205634:	00000306 	br	8205644 <___svfprintf_internal_r+0xe6c>
 8205638:	42000204 	addi	r8,r8,8
 820563c:	843ffc04 	addi	r16,r16,-16
 8205640:	8c00800e 	bge	r17,r16,8205844 <___svfprintf_internal_r+0x106c>
 8205644:	18c00404 	addi	r3,r3,16
 8205648:	10800044 	addi	r2,r2,1
 820564c:	45400015 	stw	r21,0(r8)
 8205650:	44400115 	stw	r17,4(r8)
 8205654:	d8c02015 	stw	r3,128(sp)
 8205658:	d8801f15 	stw	r2,124(sp)
 820565c:	b0bff60e 	bge	r22,r2,8205638 <___svfprintf_internal_r+0xe60>
 8205660:	d9801e04 	addi	r6,sp,120
 8205664:	a00b883a 	mov	r5,r20
 8205668:	9809883a 	mov	r4,r19
 820566c:	820e0040 	call	820e004 <__ssprint_r>
 8205670:	103d3e1e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8205674:	d8c02017 	ldw	r3,128(sp)
 8205678:	d8801f17 	ldw	r2,124(sp)
 820567c:	da000404 	addi	r8,sp,16
 8205680:	003fee06 	br	820563c <___svfprintf_internal_r+0xe64>
 8205684:	d9403117 	ldw	r5,196(sp)
 8205688:	d8802a17 	ldw	r2,168(sp)
 820568c:	28adc83a 	sub	r22,r5,r2
 8205690:	05be650e 	bge	zero,r22,8205028 <___svfprintf_internal_r+0x850>
 8205694:	07000404 	movi	fp,16
 8205698:	d8801f17 	ldw	r2,124(sp)
 820569c:	e583a20e 	bge	fp,r22,8206528 <___svfprintf_internal_r+0x1d50>
 82056a0:	01420974 	movhi	r5,2085
 82056a4:	2976d384 	addi	r5,r5,-9394
 82056a8:	dc403015 	stw	r17,192(sp)
 82056ac:	d9402b15 	stw	r5,172(sp)
 82056b0:	b023883a 	mov	r17,r22
 82056b4:	050001c4 	movi	r20,7
 82056b8:	902d883a 	mov	r22,r18
 82056bc:	8025883a 	mov	r18,r16
 82056c0:	dc002c17 	ldw	r16,176(sp)
 82056c4:	00000306 	br	82056d4 <___svfprintf_internal_r+0xefc>
 82056c8:	8c7ffc04 	addi	r17,r17,-16
 82056cc:	42000204 	addi	r8,r8,8
 82056d0:	e440110e 	bge	fp,r17,8205718 <___svfprintf_internal_r+0xf40>
 82056d4:	18c00404 	addi	r3,r3,16
 82056d8:	10800044 	addi	r2,r2,1
 82056dc:	45400015 	stw	r21,0(r8)
 82056e0:	47000115 	stw	fp,4(r8)
 82056e4:	d8c02015 	stw	r3,128(sp)
 82056e8:	d8801f15 	stw	r2,124(sp)
 82056ec:	a0bff60e 	bge	r20,r2,82056c8 <___svfprintf_internal_r+0xef0>
 82056f0:	d9801e04 	addi	r6,sp,120
 82056f4:	800b883a 	mov	r5,r16
 82056f8:	9809883a 	mov	r4,r19
 82056fc:	820e0040 	call	820e004 <__ssprint_r>
 8205700:	103d1a1e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8205704:	8c7ffc04 	addi	r17,r17,-16
 8205708:	d8c02017 	ldw	r3,128(sp)
 820570c:	d8801f17 	ldw	r2,124(sp)
 8205710:	da000404 	addi	r8,sp,16
 8205714:	e47fef16 	blt	fp,r17,82056d4 <___svfprintf_internal_r+0xefc>
 8205718:	9021883a 	mov	r16,r18
 820571c:	b025883a 	mov	r18,r22
 8205720:	882d883a 	mov	r22,r17
 8205724:	dc403017 	ldw	r17,192(sp)
 8205728:	d9002b17 	ldw	r4,172(sp)
 820572c:	1d87883a 	add	r3,r3,r22
 8205730:	10800044 	addi	r2,r2,1
 8205734:	41000015 	stw	r4,0(r8)
 8205738:	45800115 	stw	r22,4(r8)
 820573c:	d8c02015 	stw	r3,128(sp)
 8205740:	d8801f15 	stw	r2,124(sp)
 8205744:	010001c4 	movi	r4,7
 8205748:	20819a16 	blt	r4,r2,8205db4 <___svfprintf_internal_r+0x15dc>
 820574c:	42000204 	addi	r8,r8,8
 8205750:	003e3506 	br	8205028 <___svfprintf_internal_r+0x850>
 8205754:	d9403317 	ldw	r5,204(sp)
 8205758:	00800044 	movi	r2,1
 820575c:	18c00044 	addi	r3,r3,1
 8205760:	1141710e 	bge	r2,r5,8205d28 <___svfprintf_internal_r+0x1550>
 8205764:	dc401f17 	ldw	r17,124(sp)
 8205768:	00800044 	movi	r2,1
 820576c:	40800115 	stw	r2,4(r8)
 8205770:	8c400044 	addi	r17,r17,1
 8205774:	44000015 	stw	r16,0(r8)
 8205778:	d8c02015 	stw	r3,128(sp)
 820577c:	dc401f15 	stw	r17,124(sp)
 8205780:	008001c4 	movi	r2,7
 8205784:	14417416 	blt	r2,r17,8205d58 <___svfprintf_internal_r+0x1580>
 8205788:	42000204 	addi	r8,r8,8
 820578c:	d8803817 	ldw	r2,224(sp)
 8205790:	d9003417 	ldw	r4,208(sp)
 8205794:	8c400044 	addi	r17,r17,1
 8205798:	10c7883a 	add	r3,r2,r3
 820579c:	40800115 	stw	r2,4(r8)
 82057a0:	41000015 	stw	r4,0(r8)
 82057a4:	d8c02015 	stw	r3,128(sp)
 82057a8:	dc401f15 	stw	r17,124(sp)
 82057ac:	008001c4 	movi	r2,7
 82057b0:	14417216 	blt	r2,r17,8205d7c <___svfprintf_internal_r+0x15a4>
 82057b4:	45800204 	addi	r22,r8,8
 82057b8:	d9003617 	ldw	r4,216(sp)
 82057bc:	d9403717 	ldw	r5,220(sp)
 82057c0:	000d883a 	mov	r6,zero
 82057c4:	000f883a 	mov	r7,zero
 82057c8:	d8c03d15 	stw	r3,244(sp)
 82057cc:	8212e780 	call	8212e78 <__eqdf2>
 82057d0:	d8c03d17 	ldw	r3,244(sp)
 82057d4:	1000b326 	beq	r2,zero,8205aa4 <___svfprintf_internal_r+0x12cc>
 82057d8:	d9403317 	ldw	r5,204(sp)
 82057dc:	84000044 	addi	r16,r16,1
 82057e0:	8c400044 	addi	r17,r17,1
 82057e4:	28bfffc4 	addi	r2,r5,-1
 82057e8:	1887883a 	add	r3,r3,r2
 82057ec:	b0800115 	stw	r2,4(r22)
 82057f0:	b4000015 	stw	r16,0(r22)
 82057f4:	d8c02015 	stw	r3,128(sp)
 82057f8:	dc401f15 	stw	r17,124(sp)
 82057fc:	008001c4 	movi	r2,7
 8205800:	1440d216 	blt	r2,r17,8205b4c <___svfprintf_internal_r+0x1374>
 8205804:	b5800204 	addi	r22,r22,8
 8205808:	d9003b17 	ldw	r4,236(sp)
 820580c:	df0022c4 	addi	fp,sp,139
 8205810:	8c400044 	addi	r17,r17,1
 8205814:	20c7883a 	add	r3,r4,r3
 8205818:	b7000015 	stw	fp,0(r22)
 820581c:	b1000115 	stw	r4,4(r22)
 8205820:	d8c02015 	stw	r3,128(sp)
 8205824:	dc401f15 	stw	r17,124(sp)
 8205828:	008001c4 	movi	r2,7
 820582c:	14400e16 	blt	r2,r17,8205868 <___svfprintf_internal_r+0x1090>
 8205830:	b2000204 	addi	r8,r22,8
 8205834:	003e3c06 	br	8205128 <___svfprintf_internal_r+0x950>
 8205838:	01020974 	movhi	r4,2085
 820583c:	2136d384 	addi	r4,r4,-9394
 8205840:	d9002b15 	stw	r4,172(sp)
 8205844:	d9002b17 	ldw	r4,172(sp)
 8205848:	1c07883a 	add	r3,r3,r16
 820584c:	44000115 	stw	r16,4(r8)
 8205850:	41000015 	stw	r4,0(r8)
 8205854:	10800044 	addi	r2,r2,1
 8205858:	d8c02015 	stw	r3,128(sp)
 820585c:	d8801f15 	stw	r2,124(sp)
 8205860:	010001c4 	movi	r4,7
 8205864:	20be2f0e 	bge	r4,r2,8205124 <___svfprintf_internal_r+0x94c>
 8205868:	d9402c17 	ldw	r5,176(sp)
 820586c:	d9801e04 	addi	r6,sp,120
 8205870:	9809883a 	mov	r4,r19
 8205874:	820e0040 	call	820e004 <__ssprint_r>
 8205878:	103cbc1e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 820587c:	d8c02017 	ldw	r3,128(sp)
 8205880:	da000404 	addi	r8,sp,16
 8205884:	003e2806 	br	8205128 <___svfprintf_internal_r+0x950>
 8205888:	d9402c17 	ldw	r5,176(sp)
 820588c:	d9801e04 	addi	r6,sp,120
 8205890:	9809883a 	mov	r4,r19
 8205894:	820e0040 	call	820e004 <__ssprint_r>
 8205898:	103e5f26 	beq	r2,zero,8205218 <___svfprintf_internal_r+0xa40>
 820589c:	003cb306 	br	8204b6c <___svfprintf_internal_r+0x394>
 82058a0:	d9402c17 	ldw	r5,176(sp)
 82058a4:	d9801e04 	addi	r6,sp,120
 82058a8:	9809883a 	mov	r4,r19
 82058ac:	820e0040 	call	820e004 <__ssprint_r>
 82058b0:	103cae1e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 82058b4:	d8c02017 	ldw	r3,128(sp)
 82058b8:	da000404 	addi	r8,sp,16
 82058bc:	003e0d06 	br	82050f4 <___svfprintf_internal_r+0x91c>
 82058c0:	d9402c17 	ldw	r5,176(sp)
 82058c4:	d9801e04 	addi	r6,sp,120
 82058c8:	9809883a 	mov	r4,r19
 82058cc:	820e0040 	call	820e004 <__ssprint_r>
 82058d0:	103ca61e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 82058d4:	d8c02017 	ldw	r3,128(sp)
 82058d8:	da000404 	addi	r8,sp,16
 82058dc:	003dc106 	br	8204fe4 <___svfprintf_internal_r+0x80c>
 82058e0:	d9402c17 	ldw	r5,176(sp)
 82058e4:	d9801e04 	addi	r6,sp,120
 82058e8:	9809883a 	mov	r4,r19
 82058ec:	820e0040 	call	820e004 <__ssprint_r>
 82058f0:	103c9e1e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 82058f4:	d8c02017 	ldw	r3,128(sp)
 82058f8:	da000404 	addi	r8,sp,16
 82058fc:	003dc706 	br	820501c <___svfprintf_internal_r+0x844>
 8205900:	d8802917 	ldw	r2,164(sp)
 8205904:	d8002785 	stb	zero,158(sp)
 8205908:	103f0816 	blt	r2,zero,820552c <___svfprintf_internal_r+0xd54>
 820590c:	00ffdfc4 	movi	r3,-129
 8205910:	a584b03a 	or	r2,r20,r22
 8205914:	90e4703a 	and	r18,r18,r3
 8205918:	103c8126 	beq	r2,zero,8204b20 <___svfprintf_internal_r+0x348>
 820591c:	0039883a 	mov	fp,zero
 8205920:	003e7606 	br	82052fc <___svfprintf_internal_r+0xb24>
 8205924:	9080040c 	andi	r2,r18,16
 8205928:	10013d26 	beq	r2,zero,8205e20 <___svfprintf_internal_r+0x1648>
 820592c:	d9002d17 	ldw	r4,180(sp)
 8205930:	d9402917 	ldw	r5,164(sp)
 8205934:	d8002785 	stb	zero,158(sp)
 8205938:	20800104 	addi	r2,r4,4
 820593c:	25000017 	ldw	r20,0(r4)
 8205940:	002d883a 	mov	r22,zero
 8205944:	28013f16 	blt	r5,zero,8205e44 <___svfprintf_internal_r+0x166c>
 8205948:	00ffdfc4 	movi	r3,-129
 820594c:	d8802d15 	stw	r2,180(sp)
 8205950:	90e4703a 	and	r18,r18,r3
 8205954:	a03d2b26 	beq	r20,zero,8204e04 <___svfprintf_internal_r+0x62c>
 8205958:	0039883a 	mov	fp,zero
 820595c:	003d2e06 	br	8204e18 <___svfprintf_internal_r+0x640>
 8205960:	dc402617 	ldw	r17,152(sp)
 8205964:	0441830e 	bge	zero,r17,8205f74 <___svfprintf_internal_r+0x179c>
 8205968:	dc403217 	ldw	r17,200(sp)
 820596c:	d8803317 	ldw	r2,204(sp)
 8205970:	1440010e 	bge	r2,r17,8205978 <___svfprintf_internal_r+0x11a0>
 8205974:	1023883a 	mov	r17,r2
 8205978:	04400a0e 	bge	zero,r17,82059a4 <___svfprintf_internal_r+0x11cc>
 820597c:	d8801f17 	ldw	r2,124(sp)
 8205980:	1c47883a 	add	r3,r3,r17
 8205984:	44000015 	stw	r16,0(r8)
 8205988:	10800044 	addi	r2,r2,1
 820598c:	44400115 	stw	r17,4(r8)
 8205990:	d8c02015 	stw	r3,128(sp)
 8205994:	d8801f15 	stw	r2,124(sp)
 8205998:	010001c4 	movi	r4,7
 820599c:	20827516 	blt	r4,r2,8206374 <___svfprintf_internal_r+0x1b9c>
 82059a0:	42000204 	addi	r8,r8,8
 82059a4:	88027b16 	blt	r17,zero,8206394 <___svfprintf_internal_r+0x1bbc>
 82059a8:	d9003217 	ldw	r4,200(sp)
 82059ac:	2463c83a 	sub	r17,r4,r17
 82059b0:	0440990e 	bge	zero,r17,8205c18 <___svfprintf_internal_r+0x1440>
 82059b4:	05800404 	movi	r22,16
 82059b8:	d8801f17 	ldw	r2,124(sp)
 82059bc:	b441530e 	bge	r22,r17,8205f0c <___svfprintf_internal_r+0x1734>
 82059c0:	01020974 	movhi	r4,2085
 82059c4:	2136d384 	addi	r4,r4,-9394
 82059c8:	d9002b15 	stw	r4,172(sp)
 82059cc:	070001c4 	movi	fp,7
 82059d0:	dd002c17 	ldw	r20,176(sp)
 82059d4:	00000306 	br	82059e4 <___svfprintf_internal_r+0x120c>
 82059d8:	42000204 	addi	r8,r8,8
 82059dc:	8c7ffc04 	addi	r17,r17,-16
 82059e0:	b4414d0e 	bge	r22,r17,8205f18 <___svfprintf_internal_r+0x1740>
 82059e4:	18c00404 	addi	r3,r3,16
 82059e8:	10800044 	addi	r2,r2,1
 82059ec:	45400015 	stw	r21,0(r8)
 82059f0:	45800115 	stw	r22,4(r8)
 82059f4:	d8c02015 	stw	r3,128(sp)
 82059f8:	d8801f15 	stw	r2,124(sp)
 82059fc:	e0bff60e 	bge	fp,r2,82059d8 <___svfprintf_internal_r+0x1200>
 8205a00:	d9801e04 	addi	r6,sp,120
 8205a04:	a00b883a 	mov	r5,r20
 8205a08:	9809883a 	mov	r4,r19
 8205a0c:	820e0040 	call	820e004 <__ssprint_r>
 8205a10:	103c561e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8205a14:	d8c02017 	ldw	r3,128(sp)
 8205a18:	d8801f17 	ldw	r2,124(sp)
 8205a1c:	da000404 	addi	r8,sp,16
 8205a20:	003fee06 	br	82059dc <___svfprintf_internal_r+0x1204>
 8205a24:	d9402c17 	ldw	r5,176(sp)
 8205a28:	d9801e04 	addi	r6,sp,120
 8205a2c:	9809883a 	mov	r4,r19
 8205a30:	820e0040 	call	820e004 <__ssprint_r>
 8205a34:	103c4d1e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8205a38:	d8c02017 	ldw	r3,128(sp)
 8205a3c:	df002787 	ldb	fp,158(sp)
 8205a40:	da000404 	addi	r8,sp,16
 8205a44:	003d5a06 	br	8204fb0 <___svfprintf_internal_r+0x7d8>
 8205a48:	9080040c 	andi	r2,r18,16
 8205a4c:	10005c26 	beq	r2,zero,8205bc0 <___svfprintf_internal_r+0x13e8>
 8205a50:	d9402d17 	ldw	r5,180(sp)
 8205a54:	d8c02917 	ldw	r3,164(sp)
 8205a58:	d8002785 	stb	zero,158(sp)
 8205a5c:	28800104 	addi	r2,r5,4
 8205a60:	2d000017 	ldw	r20,0(r5)
 8205a64:	002d883a 	mov	r22,zero
 8205a68:	18005e16 	blt	r3,zero,8205be4 <___svfprintf_internal_r+0x140c>
 8205a6c:	00ffdfc4 	movi	r3,-129
 8205a70:	d8802d15 	stw	r2,180(sp)
 8205a74:	90e4703a 	and	r18,r18,r3
 8205a78:	0039883a 	mov	fp,zero
 8205a7c:	a03dfe26 	beq	r20,zero,8205278 <___svfprintf_internal_r+0xaa0>
 8205a80:	00800244 	movi	r2,9
 8205a84:	153cb336 	bltu	r2,r20,8204d54 <___svfprintf_internal_r+0x57c>
 8205a88:	a5000c04 	addi	r20,r20,48
 8205a8c:	dc001dc4 	addi	r16,sp,119
 8205a90:	dd001dc5 	stb	r20,119(sp)
 8205a94:	d8c02817 	ldw	r3,160(sp)
 8205a98:	1c07c83a 	sub	r3,r3,r16
 8205a9c:	d8c02e15 	stw	r3,184(sp)
 8205aa0:	003cf506 	br	8204e78 <___svfprintf_internal_r+0x6a0>
 8205aa4:	d8803317 	ldw	r2,204(sp)
 8205aa8:	143fffc4 	addi	r16,r2,-1
 8205aac:	043f560e 	bge	zero,r16,8205808 <___svfprintf_internal_r+0x1030>
 8205ab0:	07000404 	movi	fp,16
 8205ab4:	e403530e 	bge	fp,r16,8206804 <___svfprintf_internal_r+0x202c>
 8205ab8:	01420974 	movhi	r5,2085
 8205abc:	2976d384 	addi	r5,r5,-9394
 8205ac0:	d9402b15 	stw	r5,172(sp)
 8205ac4:	01c001c4 	movi	r7,7
 8205ac8:	dd002c17 	ldw	r20,176(sp)
 8205acc:	00000306 	br	8205adc <___svfprintf_internal_r+0x1304>
 8205ad0:	843ffc04 	addi	r16,r16,-16
 8205ad4:	b5800204 	addi	r22,r22,8
 8205ad8:	e400130e 	bge	fp,r16,8205b28 <___svfprintf_internal_r+0x1350>
 8205adc:	18c00404 	addi	r3,r3,16
 8205ae0:	8c400044 	addi	r17,r17,1
 8205ae4:	b5400015 	stw	r21,0(r22)
 8205ae8:	b7000115 	stw	fp,4(r22)
 8205aec:	d8c02015 	stw	r3,128(sp)
 8205af0:	dc401f15 	stw	r17,124(sp)
 8205af4:	3c7ff60e 	bge	r7,r17,8205ad0 <___svfprintf_internal_r+0x12f8>
 8205af8:	d9801e04 	addi	r6,sp,120
 8205afc:	a00b883a 	mov	r5,r20
 8205b00:	9809883a 	mov	r4,r19
 8205b04:	d9c03d15 	stw	r7,244(sp)
 8205b08:	820e0040 	call	820e004 <__ssprint_r>
 8205b0c:	d9c03d17 	ldw	r7,244(sp)
 8205b10:	103c161e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8205b14:	843ffc04 	addi	r16,r16,-16
 8205b18:	d8c02017 	ldw	r3,128(sp)
 8205b1c:	dc401f17 	ldw	r17,124(sp)
 8205b20:	dd800404 	addi	r22,sp,16
 8205b24:	e43fed16 	blt	fp,r16,8205adc <___svfprintf_internal_r+0x1304>
 8205b28:	d8802b17 	ldw	r2,172(sp)
 8205b2c:	1c07883a 	add	r3,r3,r16
 8205b30:	8c400044 	addi	r17,r17,1
 8205b34:	b0800015 	stw	r2,0(r22)
 8205b38:	b4000115 	stw	r16,4(r22)
 8205b3c:	d8c02015 	stw	r3,128(sp)
 8205b40:	dc401f15 	stw	r17,124(sp)
 8205b44:	008001c4 	movi	r2,7
 8205b48:	147f2e0e 	bge	r2,r17,8205804 <___svfprintf_internal_r+0x102c>
 8205b4c:	d9402c17 	ldw	r5,176(sp)
 8205b50:	d9801e04 	addi	r6,sp,120
 8205b54:	9809883a 	mov	r4,r19
 8205b58:	820e0040 	call	820e004 <__ssprint_r>
 8205b5c:	103c031e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8205b60:	d8c02017 	ldw	r3,128(sp)
 8205b64:	dc401f17 	ldw	r17,124(sp)
 8205b68:	dd800404 	addi	r22,sp,16
 8205b6c:	003f2606 	br	8205808 <___svfprintf_internal_r+0x1030>
 8205b70:	9080040c 	andi	r2,r18,16
 8205b74:	1000c326 	beq	r2,zero,8205e84 <___svfprintf_internal_r+0x16ac>
 8205b78:	d8802d17 	ldw	r2,180(sp)
 8205b7c:	15000017 	ldw	r20,0(r2)
 8205b80:	10800104 	addi	r2,r2,4
 8205b84:	d8802d15 	stw	r2,180(sp)
 8205b88:	a02dd7fa 	srai	r22,r20,31
 8205b8c:	b005883a 	mov	r2,r22
 8205b90:	103c680e 	bge	r2,zero,8204d34 <___svfprintf_internal_r+0x55c>
 8205b94:	0529c83a 	sub	r20,zero,r20
 8205b98:	a004c03a 	cmpne	r2,r20,zero
 8205b9c:	05adc83a 	sub	r22,zero,r22
 8205ba0:	b0adc83a 	sub	r22,r22,r2
 8205ba4:	d8802917 	ldw	r2,164(sp)
 8205ba8:	07000b44 	movi	fp,45
 8205bac:	df002785 	stb	fp,158(sp)
 8205bb0:	10022e16 	blt	r2,zero,820646c <___svfprintf_internal_r+0x1c94>
 8205bb4:	00bfdfc4 	movi	r2,-129
 8205bb8:	90a4703a 	and	r18,r18,r2
 8205bbc:	003c6406 	br	8204d50 <___svfprintf_internal_r+0x578>
 8205bc0:	9080100c 	andi	r2,r18,64
 8205bc4:	d8002785 	stb	zero,158(sp)
 8205bc8:	10012526 	beq	r2,zero,8206060 <___svfprintf_internal_r+0x1888>
 8205bcc:	d9002d17 	ldw	r4,180(sp)
 8205bd0:	d9402917 	ldw	r5,164(sp)
 8205bd4:	002d883a 	mov	r22,zero
 8205bd8:	20800104 	addi	r2,r4,4
 8205bdc:	2500000b 	ldhu	r20,0(r4)
 8205be0:	283fa20e 	bge	r5,zero,8205a6c <___svfprintf_internal_r+0x1294>
 8205be4:	d8802d15 	stw	r2,180(sp)
 8205be8:	0039883a 	mov	fp,zero
 8205bec:	a584b03a 	or	r2,r20,r22
 8205bf0:	103c571e 	bne	r2,zero,8204d50 <___svfprintf_internal_r+0x578>
 8205bf4:	00800044 	movi	r2,1
 8205bf8:	003e5006 	br	820553c <___svfprintf_internal_r+0xd64>
 8205bfc:	d9402c17 	ldw	r5,176(sp)
 8205c00:	d9801e04 	addi	r6,sp,120
 8205c04:	9809883a 	mov	r4,r19
 8205c08:	820e0040 	call	820e004 <__ssprint_r>
 8205c0c:	103bd71e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8205c10:	d8c02017 	ldw	r3,128(sp)
 8205c14:	da000404 	addi	r8,sp,16
 8205c18:	d9003217 	ldw	r4,200(sp)
 8205c1c:	d8802617 	ldw	r2,152(sp)
 8205c20:	d9403317 	ldw	r5,204(sp)
 8205c24:	8123883a 	add	r17,r16,r4
 8205c28:	11400216 	blt	r2,r5,8205c34 <___svfprintf_internal_r+0x145c>
 8205c2c:	9100004c 	andi	r4,r18,1
 8205c30:	20000d26 	beq	r4,zero,8205c68 <___svfprintf_internal_r+0x1490>
 8205c34:	d9003817 	ldw	r4,224(sp)
 8205c38:	d9403417 	ldw	r5,208(sp)
 8205c3c:	1907883a 	add	r3,r3,r4
 8205c40:	d9001f17 	ldw	r4,124(sp)
 8205c44:	41400015 	stw	r5,0(r8)
 8205c48:	d9403817 	ldw	r5,224(sp)
 8205c4c:	21000044 	addi	r4,r4,1
 8205c50:	d8c02015 	stw	r3,128(sp)
 8205c54:	41400115 	stw	r5,4(r8)
 8205c58:	d9001f15 	stw	r4,124(sp)
 8205c5c:	014001c4 	movi	r5,7
 8205c60:	2901dc16 	blt	r5,r4,82063d4 <___svfprintf_internal_r+0x1bfc>
 8205c64:	42000204 	addi	r8,r8,8
 8205c68:	d9003317 	ldw	r4,204(sp)
 8205c6c:	8121883a 	add	r16,r16,r4
 8205c70:	2085c83a 	sub	r2,r4,r2
 8205c74:	8461c83a 	sub	r16,r16,r17
 8205c78:	1400010e 	bge	r2,r16,8205c80 <___svfprintf_internal_r+0x14a8>
 8205c7c:	1021883a 	mov	r16,r2
 8205c80:	04000a0e 	bge	zero,r16,8205cac <___svfprintf_internal_r+0x14d4>
 8205c84:	d9001f17 	ldw	r4,124(sp)
 8205c88:	1c07883a 	add	r3,r3,r16
 8205c8c:	44400015 	stw	r17,0(r8)
 8205c90:	21000044 	addi	r4,r4,1
 8205c94:	44000115 	stw	r16,4(r8)
 8205c98:	d8c02015 	stw	r3,128(sp)
 8205c9c:	d9001f15 	stw	r4,124(sp)
 8205ca0:	014001c4 	movi	r5,7
 8205ca4:	2901e616 	blt	r5,r4,8206440 <___svfprintf_internal_r+0x1c68>
 8205ca8:	42000204 	addi	r8,r8,8
 8205cac:	8001f616 	blt	r16,zero,8206488 <___svfprintf_internal_r+0x1cb0>
 8205cb0:	1421c83a 	sub	r16,r2,r16
 8205cb4:	043d1c0e 	bge	zero,r16,8205128 <___svfprintf_internal_r+0x950>
 8205cb8:	04400404 	movi	r17,16
 8205cbc:	d8801f17 	ldw	r2,124(sp)
 8205cc0:	8c3edd0e 	bge	r17,r16,8205838 <___svfprintf_internal_r+0x1060>
 8205cc4:	01420974 	movhi	r5,2085
 8205cc8:	2976d384 	addi	r5,r5,-9394
 8205ccc:	d9402b15 	stw	r5,172(sp)
 8205cd0:	058001c4 	movi	r22,7
 8205cd4:	dd002c17 	ldw	r20,176(sp)
 8205cd8:	00000306 	br	8205ce8 <___svfprintf_internal_r+0x1510>
 8205cdc:	42000204 	addi	r8,r8,8
 8205ce0:	843ffc04 	addi	r16,r16,-16
 8205ce4:	8c3ed70e 	bge	r17,r16,8205844 <___svfprintf_internal_r+0x106c>
 8205ce8:	18c00404 	addi	r3,r3,16
 8205cec:	10800044 	addi	r2,r2,1
 8205cf0:	45400015 	stw	r21,0(r8)
 8205cf4:	44400115 	stw	r17,4(r8)
 8205cf8:	d8c02015 	stw	r3,128(sp)
 8205cfc:	d8801f15 	stw	r2,124(sp)
 8205d00:	b0bff60e 	bge	r22,r2,8205cdc <___svfprintf_internal_r+0x1504>
 8205d04:	d9801e04 	addi	r6,sp,120
 8205d08:	a00b883a 	mov	r5,r20
 8205d0c:	9809883a 	mov	r4,r19
 8205d10:	820e0040 	call	820e004 <__ssprint_r>
 8205d14:	103b951e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8205d18:	d8c02017 	ldw	r3,128(sp)
 8205d1c:	d8801f17 	ldw	r2,124(sp)
 8205d20:	da000404 	addi	r8,sp,16
 8205d24:	003fee06 	br	8205ce0 <___svfprintf_internal_r+0x1508>
 8205d28:	9088703a 	and	r4,r18,r2
 8205d2c:	203e8d1e 	bne	r4,zero,8205764 <___svfprintf_internal_r+0xf8c>
 8205d30:	dc401f17 	ldw	r17,124(sp)
 8205d34:	40800115 	stw	r2,4(r8)
 8205d38:	44000015 	stw	r16,0(r8)
 8205d3c:	8c400044 	addi	r17,r17,1
 8205d40:	d8c02015 	stw	r3,128(sp)
 8205d44:	dc401f15 	stw	r17,124(sp)
 8205d48:	008001c4 	movi	r2,7
 8205d4c:	147f7f16 	blt	r2,r17,8205b4c <___svfprintf_internal_r+0x1374>
 8205d50:	45800204 	addi	r22,r8,8
 8205d54:	003eac06 	br	8205808 <___svfprintf_internal_r+0x1030>
 8205d58:	d9402c17 	ldw	r5,176(sp)
 8205d5c:	d9801e04 	addi	r6,sp,120
 8205d60:	9809883a 	mov	r4,r19
 8205d64:	820e0040 	call	820e004 <__ssprint_r>
 8205d68:	103b801e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8205d6c:	d8c02017 	ldw	r3,128(sp)
 8205d70:	dc401f17 	ldw	r17,124(sp)
 8205d74:	da000404 	addi	r8,sp,16
 8205d78:	003e8406 	br	820578c <___svfprintf_internal_r+0xfb4>
 8205d7c:	d9402c17 	ldw	r5,176(sp)
 8205d80:	d9801e04 	addi	r6,sp,120
 8205d84:	9809883a 	mov	r4,r19
 8205d88:	820e0040 	call	820e004 <__ssprint_r>
 8205d8c:	103b771e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8205d90:	d8c02017 	ldw	r3,128(sp)
 8205d94:	dc401f17 	ldw	r17,124(sp)
 8205d98:	dd800404 	addi	r22,sp,16
 8205d9c:	003e8606 	br	82057b8 <___svfprintf_internal_r+0xfe0>
 8205da0:	0029883a 	mov	r20,zero
 8205da4:	a5000c04 	addi	r20,r20,48
 8205da8:	dc001dc4 	addi	r16,sp,119
 8205dac:	dd001dc5 	stb	r20,119(sp)
 8205db0:	003f3806 	br	8205a94 <___svfprintf_internal_r+0x12bc>
 8205db4:	d9402c17 	ldw	r5,176(sp)
 8205db8:	d9801e04 	addi	r6,sp,120
 8205dbc:	9809883a 	mov	r4,r19
 8205dc0:	820e0040 	call	820e004 <__ssprint_r>
 8205dc4:	103b691e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8205dc8:	d8c02017 	ldw	r3,128(sp)
 8205dcc:	da000404 	addi	r8,sp,16
 8205dd0:	003c9506 	br	8205028 <___svfprintf_internal_r+0x850>
 8205dd4:	d9003617 	ldw	r4,216(sp)
 8205dd8:	d9403717 	ldw	r5,220(sp)
 8205ddc:	da003e15 	stw	r8,248(sp)
 8205de0:	820dd240 	call	820dd24 <__fpclassifyd>
 8205de4:	da003e17 	ldw	r8,248(sp)
 8205de8:	1000bd1e 	bne	r2,zero,82060e0 <___svfprintf_internal_r+0x1908>
 8205dec:	008011c4 	movi	r2,71
 8205df0:	14411e0e 	bge	r2,r17,820626c <___svfprintf_internal_r+0x1a94>
 8205df4:	04020974 	movhi	r16,2085
 8205df8:	8436c604 	addi	r16,r16,-9448
 8205dfc:	00c000c4 	movi	r3,3
 8205e00:	00bfdfc4 	movi	r2,-129
 8205e04:	d8c02a15 	stw	r3,168(sp)
 8205e08:	90a4703a 	and	r18,r18,r2
 8205e0c:	df002783 	ldbu	fp,158(sp)
 8205e10:	d8c02e15 	stw	r3,184(sp)
 8205e14:	d8002915 	stw	zero,164(sp)
 8205e18:	d8003215 	stw	zero,200(sp)
 8205e1c:	003c1c06 	br	8204e90 <___svfprintf_internal_r+0x6b8>
 8205e20:	9080100c 	andi	r2,r18,64
 8205e24:	d8002785 	stb	zero,158(sp)
 8205e28:	10009426 	beq	r2,zero,820607c <___svfprintf_internal_r+0x18a4>
 8205e2c:	d8c02d17 	ldw	r3,180(sp)
 8205e30:	d9002917 	ldw	r4,164(sp)
 8205e34:	002d883a 	mov	r22,zero
 8205e38:	18800104 	addi	r2,r3,4
 8205e3c:	1d00000b 	ldhu	r20,0(r3)
 8205e40:	203ec10e 	bge	r4,zero,8205948 <___svfprintf_internal_r+0x1170>
 8205e44:	a586b03a 	or	r3,r20,r22
 8205e48:	d8802d15 	stw	r2,180(sp)
 8205e4c:	183ec21e 	bne	r3,zero,8205958 <___svfprintf_internal_r+0x1180>
 8205e50:	0039883a 	mov	fp,zero
 8205e54:	0005883a 	mov	r2,zero
 8205e58:	003db806 	br	820553c <___svfprintf_internal_r+0xd64>
 8205e5c:	d8802d17 	ldw	r2,180(sp)
 8205e60:	d8c02d17 	ldw	r3,180(sp)
 8205e64:	d9002d17 	ldw	r4,180(sp)
 8205e68:	10800017 	ldw	r2,0(r2)
 8205e6c:	18c00117 	ldw	r3,4(r3)
 8205e70:	21000204 	addi	r4,r4,8
 8205e74:	d8803615 	stw	r2,216(sp)
 8205e78:	d8c03715 	stw	r3,220(sp)
 8205e7c:	d9002d15 	stw	r4,180(sp)
 8205e80:	003b8206 	br	8204c8c <___svfprintf_internal_r+0x4b4>
 8205e84:	9080100c 	andi	r2,r18,64
 8205e88:	10010726 	beq	r2,zero,82062a8 <___svfprintf_internal_r+0x1ad0>
 8205e8c:	d8c02d17 	ldw	r3,180(sp)
 8205e90:	1d00000f 	ldh	r20,0(r3)
 8205e94:	18c00104 	addi	r3,r3,4
 8205e98:	d8c02d15 	stw	r3,180(sp)
 8205e9c:	a02dd7fa 	srai	r22,r20,31
 8205ea0:	b005883a 	mov	r2,r22
 8205ea4:	003ba206 	br	8204d30 <___svfprintf_internal_r+0x558>
 8205ea8:	9080100c 	andi	r2,r18,64
 8205eac:	10010526 	beq	r2,zero,82062c4 <___svfprintf_internal_r+0x1aec>
 8205eb0:	d9002d17 	ldw	r4,180(sp)
 8205eb4:	002d883a 	mov	r22,zero
 8205eb8:	2500000b 	ldhu	r20,0(r4)
 8205ebc:	21000104 	addi	r4,r4,4
 8205ec0:	d9002d15 	stw	r4,180(sp)
 8205ec4:	003cfe06 	br	82052c0 <___svfprintf_internal_r+0xae8>
 8205ec8:	bc400007 	ldb	r17,0(r23)
 8205ecc:	003a9606 	br	8204928 <___svfprintf_internal_r+0x150>
 8205ed0:	9080040c 	andi	r2,r18,16
 8205ed4:	10010126 	beq	r2,zero,82062dc <___svfprintf_internal_r+0x1b04>
 8205ed8:	d9402d17 	ldw	r5,180(sp)
 8205edc:	d8c02f17 	ldw	r3,188(sp)
 8205ee0:	28800017 	ldw	r2,0(r5)
 8205ee4:	29400104 	addi	r5,r5,4
 8205ee8:	d9402d15 	stw	r5,180(sp)
 8205eec:	10c00015 	stw	r3,0(r2)
 8205ef0:	003a6406 	br	8204884 <___svfprintf_internal_r+0xac>
 8205ef4:	d9002917 	ldw	r4,164(sp)
 8205ef8:	d8002785 	stb	zero,158(sp)
 8205efc:	203d8d16 	blt	r4,zero,8205534 <___svfprintf_internal_r+0xd5c>
 8205f00:	00bfdfc4 	movi	r2,-129
 8205f04:	90a4703a 	and	r18,r18,r2
 8205f08:	003b0506 	br	8204b20 <___svfprintf_internal_r+0x348>
 8205f0c:	01420974 	movhi	r5,2085
 8205f10:	2976d384 	addi	r5,r5,-9394
 8205f14:	d9402b15 	stw	r5,172(sp)
 8205f18:	d9402b17 	ldw	r5,172(sp)
 8205f1c:	1c47883a 	add	r3,r3,r17
 8205f20:	10800044 	addi	r2,r2,1
 8205f24:	41400015 	stw	r5,0(r8)
 8205f28:	44400115 	stw	r17,4(r8)
 8205f2c:	d8c02015 	stw	r3,128(sp)
 8205f30:	d8801f15 	stw	r2,124(sp)
 8205f34:	010001c4 	movi	r4,7
 8205f38:	20bf3016 	blt	r4,r2,8205bfc <___svfprintf_internal_r+0x1424>
 8205f3c:	42000204 	addi	r8,r8,8
 8205f40:	003f3506 	br	8205c18 <___svfprintf_internal_r+0x1440>
 8205f44:	01020974 	movhi	r4,2085
 8205f48:	2136d384 	addi	r4,r4,-9394
 8205f4c:	d9002b15 	stw	r4,172(sp)
 8205f50:	003c5e06 	br	82050cc <___svfprintf_internal_r+0x8f4>
 8205f54:	d9402c17 	ldw	r5,176(sp)
 8205f58:	d9801e04 	addi	r6,sp,120
 8205f5c:	9809883a 	mov	r4,r19
 8205f60:	820e0040 	call	820e004 <__ssprint_r>
 8205f64:	103b011e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8205f68:	d8c02017 	ldw	r3,128(sp)
 8205f6c:	da000404 	addi	r8,sp,16
 8205f70:	003d9306 	br	82055c0 <___svfprintf_internal_r+0xde8>
 8205f74:	d8801f17 	ldw	r2,124(sp)
 8205f78:	01420974 	movhi	r5,2085
 8205f7c:	01000044 	movi	r4,1
 8205f80:	18c00044 	addi	r3,r3,1
 8205f84:	10800044 	addi	r2,r2,1
 8205f88:	2976d304 	addi	r5,r5,-9396
 8205f8c:	41000115 	stw	r4,4(r8)
 8205f90:	41400015 	stw	r5,0(r8)
 8205f94:	d8c02015 	stw	r3,128(sp)
 8205f98:	d8801f15 	stw	r2,124(sp)
 8205f9c:	010001c4 	movi	r4,7
 8205fa0:	2080b516 	blt	r4,r2,8206278 <___svfprintf_internal_r+0x1aa0>
 8205fa4:	42000204 	addi	r8,r8,8
 8205fa8:	8800041e 	bne	r17,zero,8205fbc <___svfprintf_internal_r+0x17e4>
 8205fac:	d8803317 	ldw	r2,204(sp)
 8205fb0:	1000021e 	bne	r2,zero,8205fbc <___svfprintf_internal_r+0x17e4>
 8205fb4:	9080004c 	andi	r2,r18,1
 8205fb8:	103c5b26 	beq	r2,zero,8205128 <___svfprintf_internal_r+0x950>
 8205fbc:	d9003817 	ldw	r4,224(sp)
 8205fc0:	d8801f17 	ldw	r2,124(sp)
 8205fc4:	d9403417 	ldw	r5,208(sp)
 8205fc8:	20c7883a 	add	r3,r4,r3
 8205fcc:	10800044 	addi	r2,r2,1
 8205fd0:	41000115 	stw	r4,4(r8)
 8205fd4:	41400015 	stw	r5,0(r8)
 8205fd8:	d8c02015 	stw	r3,128(sp)
 8205fdc:	d8801f15 	stw	r2,124(sp)
 8205fe0:	010001c4 	movi	r4,7
 8205fe4:	20818016 	blt	r4,r2,82065e8 <___svfprintf_internal_r+0x1e10>
 8205fe8:	42000204 	addi	r8,r8,8
 8205fec:	0463c83a 	sub	r17,zero,r17
 8205ff0:	0440cb0e 	bge	zero,r17,8206320 <___svfprintf_internal_r+0x1b48>
 8205ff4:	05800404 	movi	r22,16
 8205ff8:	b440e80e 	bge	r22,r17,820639c <___svfprintf_internal_r+0x1bc4>
 8205ffc:	01420974 	movhi	r5,2085
 8206000:	2976d384 	addi	r5,r5,-9394
 8206004:	d9402b15 	stw	r5,172(sp)
 8206008:	070001c4 	movi	fp,7
 820600c:	dd002c17 	ldw	r20,176(sp)
 8206010:	00000306 	br	8206020 <___svfprintf_internal_r+0x1848>
 8206014:	42000204 	addi	r8,r8,8
 8206018:	8c7ffc04 	addi	r17,r17,-16
 820601c:	b440e20e 	bge	r22,r17,82063a8 <___svfprintf_internal_r+0x1bd0>
 8206020:	18c00404 	addi	r3,r3,16
 8206024:	10800044 	addi	r2,r2,1
 8206028:	45400015 	stw	r21,0(r8)
 820602c:	45800115 	stw	r22,4(r8)
 8206030:	d8c02015 	stw	r3,128(sp)
 8206034:	d8801f15 	stw	r2,124(sp)
 8206038:	e0bff60e 	bge	fp,r2,8206014 <___svfprintf_internal_r+0x183c>
 820603c:	d9801e04 	addi	r6,sp,120
 8206040:	a00b883a 	mov	r5,r20
 8206044:	9809883a 	mov	r4,r19
 8206048:	820e0040 	call	820e004 <__ssprint_r>
 820604c:	103ac71e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8206050:	d8c02017 	ldw	r3,128(sp)
 8206054:	d8801f17 	ldw	r2,124(sp)
 8206058:	da000404 	addi	r8,sp,16
 820605c:	003fee06 	br	8206018 <___svfprintf_internal_r+0x1840>
 8206060:	d8c02d17 	ldw	r3,180(sp)
 8206064:	d9002917 	ldw	r4,164(sp)
 8206068:	002d883a 	mov	r22,zero
 820606c:	18800104 	addi	r2,r3,4
 8206070:	1d000017 	ldw	r20,0(r3)
 8206074:	203e7d0e 	bge	r4,zero,8205a6c <___svfprintf_internal_r+0x1294>
 8206078:	003eda06 	br	8205be4 <___svfprintf_internal_r+0x140c>
 820607c:	d9402d17 	ldw	r5,180(sp)
 8206080:	d8c02917 	ldw	r3,164(sp)
 8206084:	002d883a 	mov	r22,zero
 8206088:	28800104 	addi	r2,r5,4
 820608c:	2d000017 	ldw	r20,0(r5)
 8206090:	183e2d0e 	bge	r3,zero,8205948 <___svfprintf_internal_r+0x1170>
 8206094:	003f6b06 	br	8205e44 <___svfprintf_internal_r+0x166c>
 8206098:	d8c02d15 	stw	r3,180(sp)
 820609c:	0039883a 	mov	fp,zero
 82060a0:	003ed206 	br	8205bec <___svfprintf_internal_r+0x1414>
 82060a4:	bc400043 	ldbu	r17,1(r23)
 82060a8:	94800814 	ori	r18,r18,32
 82060ac:	bdc00044 	addi	r23,r23,1
 82060b0:	8c403fcc 	andi	r17,r17,255
 82060b4:	8c40201c 	xori	r17,r17,128
 82060b8:	8c7fe004 	addi	r17,r17,-128
 82060bc:	003a1a06 	br	8204928 <___svfprintf_internal_r+0x150>
 82060c0:	d9402c17 	ldw	r5,176(sp)
 82060c4:	d9801e04 	addi	r6,sp,120
 82060c8:	9809883a 	mov	r4,r19
 82060cc:	820e0040 	call	820e004 <__ssprint_r>
 82060d0:	103aa61e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 82060d4:	d8c02017 	ldw	r3,128(sp)
 82060d8:	da000404 	addi	r8,sp,16
 82060dc:	003d4a06 	br	8205608 <___svfprintf_internal_r+0xe30>
 82060e0:	d9002917 	ldw	r4,164(sp)
 82060e4:	05bff7c4 	movi	r22,-33
 82060e8:	00bfffc4 	movi	r2,-1
 82060ec:	8dac703a 	and	r22,r17,r22
 82060f0:	20806a26 	beq	r4,r2,820629c <___svfprintf_internal_r+0x1ac4>
 82060f4:	008011c4 	movi	r2,71
 82060f8:	b0813726 	beq	r22,r2,82065d8 <___svfprintf_internal_r+0x1e00>
 82060fc:	d9003717 	ldw	r4,220(sp)
 8206100:	90c04014 	ori	r3,r18,256
 8206104:	d8c02b15 	stw	r3,172(sp)
 8206108:	20015d16 	blt	r4,zero,8206680 <___svfprintf_internal_r+0x1ea8>
 820610c:	dd003717 	ldw	r20,220(sp)
 8206110:	d8002a05 	stb	zero,168(sp)
 8206114:	00801984 	movi	r2,102
 8206118:	88814026 	beq	r17,r2,820661c <___svfprintf_internal_r+0x1e44>
 820611c:	00801184 	movi	r2,70
 8206120:	88817126 	beq	r17,r2,82066e8 <___svfprintf_internal_r+0x1f10>
 8206124:	00801144 	movi	r2,69
 8206128:	b0816226 	beq	r22,r2,82066b4 <___svfprintf_internal_r+0x1edc>
 820612c:	d8c02917 	ldw	r3,164(sp)
 8206130:	d8802104 	addi	r2,sp,132
 8206134:	d8800315 	stw	r2,12(sp)
 8206138:	d9403617 	ldw	r5,216(sp)
 820613c:	d8802504 	addi	r2,sp,148
 8206140:	d8800215 	stw	r2,8(sp)
 8206144:	d8802604 	addi	r2,sp,152
 8206148:	d8c00015 	stw	r3,0(sp)
 820614c:	d8800115 	stw	r2,4(sp)
 8206150:	01c00084 	movi	r7,2
 8206154:	a00d883a 	mov	r6,r20
 8206158:	9809883a 	mov	r4,r19
 820615c:	d8c03d15 	stw	r3,244(sp)
 8206160:	da003e15 	stw	r8,248(sp)
 8206164:	82091340 	call	8209134 <_dtoa_r>
 8206168:	1021883a 	mov	r16,r2
 820616c:	008019c4 	movi	r2,103
 8206170:	d8c03d17 	ldw	r3,244(sp)
 8206174:	da003e17 	ldw	r8,248(sp)
 8206178:	8880e726 	beq	r17,r2,8206518 <___svfprintf_internal_r+0x1d40>
 820617c:	008011c4 	movi	r2,71
 8206180:	8880d426 	beq	r17,r2,82064d4 <___svfprintf_internal_r+0x1cfc>
 8206184:	80f9883a 	add	fp,r16,r3
 8206188:	d9003617 	ldw	r4,216(sp)
 820618c:	000d883a 	mov	r6,zero
 8206190:	000f883a 	mov	r7,zero
 8206194:	a00b883a 	mov	r5,r20
 8206198:	da003e15 	stw	r8,248(sp)
 820619c:	8212e780 	call	8212e78 <__eqdf2>
 82061a0:	da003e17 	ldw	r8,248(sp)
 82061a4:	1000e426 	beq	r2,zero,8206538 <___svfprintf_internal_r+0x1d60>
 82061a8:	d8802117 	ldw	r2,132(sp)
 82061ac:	1700062e 	bgeu	r2,fp,82061c8 <___svfprintf_internal_r+0x19f0>
 82061b0:	01000c04 	movi	r4,48
 82061b4:	10c00044 	addi	r3,r2,1
 82061b8:	d8c02115 	stw	r3,132(sp)
 82061bc:	11000005 	stb	r4,0(r2)
 82061c0:	d8802117 	ldw	r2,132(sp)
 82061c4:	173ffb36 	bltu	r2,fp,82061b4 <___svfprintf_internal_r+0x19dc>
 82061c8:	1405c83a 	sub	r2,r2,r16
 82061cc:	d8803315 	stw	r2,204(sp)
 82061d0:	008011c4 	movi	r2,71
 82061d4:	b080c526 	beq	r22,r2,82064ec <___svfprintf_internal_r+0x1d14>
 82061d8:	00801944 	movi	r2,101
 82061dc:	1441d90e 	bge	r2,r17,8206944 <___svfprintf_internal_r+0x216c>
 82061e0:	d8c02617 	ldw	r3,152(sp)
 82061e4:	00801984 	movi	r2,102
 82061e8:	d8c03215 	stw	r3,200(sp)
 82061ec:	88813426 	beq	r17,r2,82066c0 <___svfprintf_internal_r+0x1ee8>
 82061f0:	d8c03217 	ldw	r3,200(sp)
 82061f4:	d9003317 	ldw	r4,204(sp)
 82061f8:	19012516 	blt	r3,r4,8206690 <___svfprintf_internal_r+0x1eb8>
 82061fc:	9480004c 	andi	r18,r18,1
 8206200:	9001841e 	bne	r18,zero,8206814 <___svfprintf_internal_r+0x203c>
 8206204:	1805883a 	mov	r2,r3
 8206208:	1801cc16 	blt	r3,zero,820693c <___svfprintf_internal_r+0x2164>
 820620c:	d8c03217 	ldw	r3,200(sp)
 8206210:	044019c4 	movi	r17,103
 8206214:	d8c02e15 	stw	r3,184(sp)
 8206218:	df002a07 	ldb	fp,168(sp)
 820621c:	e000a61e 	bne	fp,zero,82064b8 <___svfprintf_internal_r+0x1ce0>
 8206220:	df002783 	ldbu	fp,158(sp)
 8206224:	d8802a15 	stw	r2,168(sp)
 8206228:	dc802b17 	ldw	r18,172(sp)
 820622c:	d8002915 	stw	zero,164(sp)
 8206230:	003b1706 	br	8204e90 <___svfprintf_internal_r+0x6b8>
 8206234:	04020974 	movhi	r16,2085
 8206238:	8436c304 	addi	r16,r16,-9460
 820623c:	003aa606 	br	8204cd8 <___svfprintf_internal_r+0x500>
 8206240:	d9003917 	ldw	r4,228(sp)
 8206244:	04001004 	movi	r16,64
 8206248:	800b883a 	mov	r5,r16
 820624c:	820bc680 	call	820bc68 <_malloc_r>
 8206250:	d9002c17 	ldw	r4,176(sp)
 8206254:	20800015 	stw	r2,0(r4)
 8206258:	20800415 	stw	r2,16(r4)
 820625c:	1001cb26 	beq	r2,zero,820698c <___svfprintf_internal_r+0x21b4>
 8206260:	d8802c17 	ldw	r2,176(sp)
 8206264:	14000515 	stw	r16,20(r2)
 8206268:	00397606 	br	8204844 <___svfprintf_internal_r+0x6c>
 820626c:	04020974 	movhi	r16,2085
 8206270:	8436c504 	addi	r16,r16,-9452
 8206274:	003ee106 	br	8205dfc <___svfprintf_internal_r+0x1624>
 8206278:	d9402c17 	ldw	r5,176(sp)
 820627c:	d9801e04 	addi	r6,sp,120
 8206280:	9809883a 	mov	r4,r19
 8206284:	820e0040 	call	820e004 <__ssprint_r>
 8206288:	103a381e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 820628c:	dc402617 	ldw	r17,152(sp)
 8206290:	d8c02017 	ldw	r3,128(sp)
 8206294:	da000404 	addi	r8,sp,16
 8206298:	003f4306 	br	8205fa8 <___svfprintf_internal_r+0x17d0>
 820629c:	01400184 	movi	r5,6
 82062a0:	d9402915 	stw	r5,164(sp)
 82062a4:	003f9506 	br	82060fc <___svfprintf_internal_r+0x1924>
 82062a8:	d9002d17 	ldw	r4,180(sp)
 82062ac:	25000017 	ldw	r20,0(r4)
 82062b0:	21000104 	addi	r4,r4,4
 82062b4:	d9002d15 	stw	r4,180(sp)
 82062b8:	a02dd7fa 	srai	r22,r20,31
 82062bc:	b005883a 	mov	r2,r22
 82062c0:	003a9b06 	br	8204d30 <___svfprintf_internal_r+0x558>
 82062c4:	d9402d17 	ldw	r5,180(sp)
 82062c8:	002d883a 	mov	r22,zero
 82062cc:	2d000017 	ldw	r20,0(r5)
 82062d0:	29400104 	addi	r5,r5,4
 82062d4:	d9402d15 	stw	r5,180(sp)
 82062d8:	003bf906 	br	82052c0 <___svfprintf_internal_r+0xae8>
 82062dc:	9480100c 	andi	r18,r18,64
 82062e0:	90006e26 	beq	r18,zero,820649c <___svfprintf_internal_r+0x1cc4>
 82062e4:	d9002d17 	ldw	r4,180(sp)
 82062e8:	d9402f17 	ldw	r5,188(sp)
 82062ec:	20800017 	ldw	r2,0(r4)
 82062f0:	21000104 	addi	r4,r4,4
 82062f4:	d9002d15 	stw	r4,180(sp)
 82062f8:	1140000d 	sth	r5,0(r2)
 82062fc:	00396106 	br	8204884 <___svfprintf_internal_r+0xac>
 8206300:	d9402c17 	ldw	r5,176(sp)
 8206304:	d9801e04 	addi	r6,sp,120
 8206308:	9809883a 	mov	r4,r19
 820630c:	820e0040 	call	820e004 <__ssprint_r>
 8206310:	103a161e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8206314:	d8c02017 	ldw	r3,128(sp)
 8206318:	d8801f17 	ldw	r2,124(sp)
 820631c:	da000404 	addi	r8,sp,16
 8206320:	d9403317 	ldw	r5,204(sp)
 8206324:	10800044 	addi	r2,r2,1
 8206328:	44000015 	stw	r16,0(r8)
 820632c:	28c7883a 	add	r3,r5,r3
 8206330:	003b7706 	br	8205110 <___svfprintf_internal_r+0x938>
 8206334:	8009883a 	mov	r4,r16
 8206338:	da003e15 	stw	r8,248(sp)
 820633c:	8203edc0 	call	8203edc <strlen>
 8206340:	d8802e15 	stw	r2,184(sp)
 8206344:	da003e17 	ldw	r8,248(sp)
 8206348:	103c280e 	bge	r2,zero,82053ec <___svfprintf_internal_r+0xc14>
 820634c:	0005883a 	mov	r2,zero
 8206350:	003c2606 	br	82053ec <___svfprintf_internal_r+0xc14>
 8206354:	00bfffc4 	movi	r2,-1
 8206358:	003a0906 	br	8204b80 <___svfprintf_internal_r+0x3a8>
 820635c:	01020974 	movhi	r4,2085
 8206360:	2136d784 	addi	r4,r4,-9378
 8206364:	d9003515 	stw	r4,212(sp)
 8206368:	003b0606 	br	8204f84 <___svfprintf_internal_r+0x7ac>
 820636c:	013fffc4 	movi	r4,-1
 8206370:	003a2706 	br	8204c10 <___svfprintf_internal_r+0x438>
 8206374:	d9402c17 	ldw	r5,176(sp)
 8206378:	d9801e04 	addi	r6,sp,120
 820637c:	9809883a 	mov	r4,r19
 8206380:	820e0040 	call	820e004 <__ssprint_r>
 8206384:	1039f91e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8206388:	d8c02017 	ldw	r3,128(sp)
 820638c:	da000404 	addi	r8,sp,16
 8206390:	003d8406 	br	82059a4 <___svfprintf_internal_r+0x11cc>
 8206394:	0023883a 	mov	r17,zero
 8206398:	003d8306 	br	82059a8 <___svfprintf_internal_r+0x11d0>
 820639c:	01020974 	movhi	r4,2085
 82063a0:	2136d384 	addi	r4,r4,-9394
 82063a4:	d9002b15 	stw	r4,172(sp)
 82063a8:	d9002b17 	ldw	r4,172(sp)
 82063ac:	1c47883a 	add	r3,r3,r17
 82063b0:	10800044 	addi	r2,r2,1
 82063b4:	41000015 	stw	r4,0(r8)
 82063b8:	44400115 	stw	r17,4(r8)
 82063bc:	d8c02015 	stw	r3,128(sp)
 82063c0:	d8801f15 	stw	r2,124(sp)
 82063c4:	010001c4 	movi	r4,7
 82063c8:	20bfcd16 	blt	r4,r2,8206300 <___svfprintf_internal_r+0x1b28>
 82063cc:	42000204 	addi	r8,r8,8
 82063d0:	003fd306 	br	8206320 <___svfprintf_internal_r+0x1b48>
 82063d4:	d9402c17 	ldw	r5,176(sp)
 82063d8:	d9801e04 	addi	r6,sp,120
 82063dc:	9809883a 	mov	r4,r19
 82063e0:	820e0040 	call	820e004 <__ssprint_r>
 82063e4:	1039e11e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 82063e8:	d8802617 	ldw	r2,152(sp)
 82063ec:	d8c02017 	ldw	r3,128(sp)
 82063f0:	da000404 	addi	r8,sp,16
 82063f4:	003e1c06 	br	8205c68 <___svfprintf_internal_r+0x1490>
 82063f8:	d8802917 	ldw	r2,164(sp)
 82063fc:	00c00184 	movi	r3,6
 8206400:	1880012e 	bgeu	r3,r2,8206408 <___svfprintf_internal_r+0x1c30>
 8206404:	1805883a 	mov	r2,r3
 8206408:	d8802e15 	stw	r2,184(sp)
 820640c:	1000f316 	blt	r2,zero,82067dc <___svfprintf_internal_r+0x2004>
 8206410:	04020974 	movhi	r16,2085
 8206414:	d8802a15 	stw	r2,168(sp)
 8206418:	dd002d15 	stw	r20,180(sp)
 820641c:	d8002915 	stw	zero,164(sp)
 8206420:	d8003215 	stw	zero,200(sp)
 8206424:	8436d104 	addi	r16,r16,-9404
 8206428:	0039883a 	mov	fp,zero
 820642c:	003a9f06 	br	8204eac <___svfprintf_internal_r+0x6d4>
 8206430:	01020974 	movhi	r4,2085
 8206434:	2136d784 	addi	r4,r4,-9378
 8206438:	d9003515 	stw	r4,212(sp)
 820643c:	003b5f06 	br	82051bc <___svfprintf_internal_r+0x9e4>
 8206440:	d9402c17 	ldw	r5,176(sp)
 8206444:	d9801e04 	addi	r6,sp,120
 8206448:	9809883a 	mov	r4,r19
 820644c:	820e0040 	call	820e004 <__ssprint_r>
 8206450:	1039c61e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 8206454:	d8802617 	ldw	r2,152(sp)
 8206458:	d9403317 	ldw	r5,204(sp)
 820645c:	d8c02017 	ldw	r3,128(sp)
 8206460:	da000404 	addi	r8,sp,16
 8206464:	2885c83a 	sub	r2,r5,r2
 8206468:	003e1006 	br	8205cac <___svfprintf_internal_r+0x14d4>
 820646c:	00800044 	movi	r2,1
 8206470:	10803fcc 	andi	r2,r2,255
 8206474:	00c00044 	movi	r3,1
 8206478:	10fa3526 	beq	r2,r3,8204d50 <___svfprintf_internal_r+0x578>
 820647c:	00c00084 	movi	r3,2
 8206480:	10fb9e26 	beq	r2,r3,82052fc <___svfprintf_internal_r+0xb24>
 8206484:	003a6406 	br	8204e18 <___svfprintf_internal_r+0x640>
 8206488:	0021883a 	mov	r16,zero
 820648c:	003e0806 	br	8205cb0 <___svfprintf_internal_r+0x14d8>
 8206490:	07000b44 	movi	fp,45
 8206494:	df002785 	stb	fp,158(sp)
 8206498:	003a0b06 	br	8204cc8 <___svfprintf_internal_r+0x4f0>
 820649c:	d8c02d17 	ldw	r3,180(sp)
 82064a0:	d9002f17 	ldw	r4,188(sp)
 82064a4:	18800017 	ldw	r2,0(r3)
 82064a8:	18c00104 	addi	r3,r3,4
 82064ac:	d8c02d15 	stw	r3,180(sp)
 82064b0:	11000015 	stw	r4,0(r2)
 82064b4:	0038f306 	br	8204884 <___svfprintf_internal_r+0xac>
 82064b8:	00c00b44 	movi	r3,45
 82064bc:	d8c02785 	stb	r3,158(sp)
 82064c0:	d8802a15 	stw	r2,168(sp)
 82064c4:	dc802b17 	ldw	r18,172(sp)
 82064c8:	d8002915 	stw	zero,164(sp)
 82064cc:	07000b44 	movi	fp,45
 82064d0:	003a7306 	br	8204ea0 <___svfprintf_internal_r+0x6c8>
 82064d4:	9080004c 	andi	r2,r18,1
 82064d8:	1000941e 	bne	r2,zero,820672c <___svfprintf_internal_r+0x1f54>
 82064dc:	d8802117 	ldw	r2,132(sp)
 82064e0:	1405c83a 	sub	r2,r2,r16
 82064e4:	d8803315 	stw	r2,204(sp)
 82064e8:	b441161e 	bne	r22,r17,8206944 <___svfprintf_internal_r+0x216c>
 82064ec:	dd802617 	ldw	r22,152(sp)
 82064f0:	00bfff44 	movi	r2,-3
 82064f4:	b0801a16 	blt	r22,r2,8206560 <___svfprintf_internal_r+0x1d88>
 82064f8:	d9402917 	ldw	r5,164(sp)
 82064fc:	2d801816 	blt	r5,r22,8206560 <___svfprintf_internal_r+0x1d88>
 8206500:	dd803215 	stw	r22,200(sp)
 8206504:	003f3a06 	br	82061f0 <___svfprintf_internal_r+0x1a18>
 8206508:	1025883a 	mov	r18,r2
 820650c:	0039883a 	mov	fp,zero
 8206510:	00800084 	movi	r2,2
 8206514:	003fd606 	br	8206470 <___svfprintf_internal_r+0x1c98>
 8206518:	9080004c 	andi	r2,r18,1
 820651c:	103f191e 	bne	r2,zero,8206184 <___svfprintf_internal_r+0x19ac>
 8206520:	d8802117 	ldw	r2,132(sp)
 8206524:	003f2806 	br	82061c8 <___svfprintf_internal_r+0x19f0>
 8206528:	01020974 	movhi	r4,2085
 820652c:	2136d384 	addi	r4,r4,-9394
 8206530:	d9002b15 	stw	r4,172(sp)
 8206534:	003c7c06 	br	8205728 <___svfprintf_internal_r+0xf50>
 8206538:	e005883a 	mov	r2,fp
 820653c:	003f2206 	br	82061c8 <___svfprintf_internal_r+0x19f0>
 8206540:	d9402917 	ldw	r5,164(sp)
 8206544:	df002783 	ldbu	fp,158(sp)
 8206548:	dd002d15 	stw	r20,180(sp)
 820654c:	d9402a15 	stw	r5,168(sp)
 8206550:	d9402e15 	stw	r5,184(sp)
 8206554:	d8002915 	stw	zero,164(sp)
 8206558:	d8003215 	stw	zero,200(sp)
 820655c:	003a4c06 	br	8204e90 <___svfprintf_internal_r+0x6b8>
 8206560:	8c7fff84 	addi	r17,r17,-2
 8206564:	b5bfffc4 	addi	r22,r22,-1
 8206568:	dd802615 	stw	r22,152(sp)
 820656c:	dc4022c5 	stb	r17,139(sp)
 8206570:	b000c316 	blt	r22,zero,8206880 <___svfprintf_internal_r+0x20a8>
 8206574:	00800ac4 	movi	r2,43
 8206578:	d8802305 	stb	r2,140(sp)
 820657c:	00800244 	movi	r2,9
 8206580:	15806e16 	blt	r2,r22,820673c <___svfprintf_internal_r+0x1f64>
 8206584:	00800c04 	movi	r2,48
 8206588:	b5800c04 	addi	r22,r22,48
 820658c:	d8802345 	stb	r2,141(sp)
 8206590:	dd802385 	stb	r22,142(sp)
 8206594:	d88023c4 	addi	r2,sp,143
 8206598:	df0022c4 	addi	fp,sp,139
 820659c:	d8c03317 	ldw	r3,204(sp)
 82065a0:	1739c83a 	sub	fp,r2,fp
 82065a4:	d9003317 	ldw	r4,204(sp)
 82065a8:	e0c7883a 	add	r3,fp,r3
 82065ac:	df003b15 	stw	fp,236(sp)
 82065b0:	d8c02e15 	stw	r3,184(sp)
 82065b4:	00800044 	movi	r2,1
 82065b8:	1100b70e 	bge	r2,r4,8206898 <___svfprintf_internal_r+0x20c0>
 82065bc:	d8c02e17 	ldw	r3,184(sp)
 82065c0:	18c00044 	addi	r3,r3,1
 82065c4:	d8c02e15 	stw	r3,184(sp)
 82065c8:	1805883a 	mov	r2,r3
 82065cc:	1800b016 	blt	r3,zero,8206890 <___svfprintf_internal_r+0x20b8>
 82065d0:	d8003215 	stw	zero,200(sp)
 82065d4:	003f1006 	br	8206218 <___svfprintf_internal_r+0x1a40>
 82065d8:	d8802917 	ldw	r2,164(sp)
 82065dc:	103ec71e 	bne	r2,zero,82060fc <___svfprintf_internal_r+0x1924>
 82065e0:	dc002915 	stw	r16,164(sp)
 82065e4:	003ec506 	br	82060fc <___svfprintf_internal_r+0x1924>
 82065e8:	d9402c17 	ldw	r5,176(sp)
 82065ec:	d9801e04 	addi	r6,sp,120
 82065f0:	9809883a 	mov	r4,r19
 82065f4:	820e0040 	call	820e004 <__ssprint_r>
 82065f8:	10395c1e 	bne	r2,zero,8204b6c <___svfprintf_internal_r+0x394>
 82065fc:	dc402617 	ldw	r17,152(sp)
 8206600:	d8c02017 	ldw	r3,128(sp)
 8206604:	d8801f17 	ldw	r2,124(sp)
 8206608:	da000404 	addi	r8,sp,16
 820660c:	003e7706 	br	8205fec <___svfprintf_internal_r+0x1814>
 8206610:	582f883a 	mov	r23,r11
 8206614:	d8002915 	stw	zero,164(sp)
 8206618:	0038c406 	br	820492c <___svfprintf_internal_r+0x154>
 820661c:	d8c02917 	ldw	r3,164(sp)
 8206620:	d8802104 	addi	r2,sp,132
 8206624:	d8800315 	stw	r2,12(sp)
 8206628:	d9403617 	ldw	r5,216(sp)
 820662c:	d8802504 	addi	r2,sp,148
 8206630:	d8800215 	stw	r2,8(sp)
 8206634:	d8802604 	addi	r2,sp,152
 8206638:	d8c00015 	stw	r3,0(sp)
 820663c:	9809883a 	mov	r4,r19
 8206640:	d8800115 	stw	r2,4(sp)
 8206644:	01c000c4 	movi	r7,3
 8206648:	a00d883a 	mov	r6,r20
 820664c:	da003e15 	stw	r8,248(sp)
 8206650:	82091340 	call	8209134 <_dtoa_r>
 8206654:	d9002917 	ldw	r4,164(sp)
 8206658:	da003e17 	ldw	r8,248(sp)
 820665c:	1021883a 	mov	r16,r2
 8206660:	1139883a 	add	fp,r2,r4
 8206664:	2007883a 	mov	r3,r4
 8206668:	81000007 	ldb	r4,0(r16)
 820666c:	00800c04 	movi	r2,48
 8206670:	20806f26 	beq	r4,r2,8206830 <___svfprintf_internal_r+0x2058>
 8206674:	d8c02617 	ldw	r3,152(sp)
 8206678:	e0f9883a 	add	fp,fp,r3
 820667c:	003ec206 	br	8206188 <___svfprintf_internal_r+0x19b0>
 8206680:	00c00b44 	movi	r3,45
 8206684:	2520003c 	xorhi	r20,r4,32768
 8206688:	d8c02a05 	stb	r3,168(sp)
 820668c:	003ea106 	br	8206114 <___svfprintf_internal_r+0x193c>
 8206690:	d8c03217 	ldw	r3,200(sp)
 8206694:	00c0890e 	bge	zero,r3,82068bc <___svfprintf_internal_r+0x20e4>
 8206698:	00800044 	movi	r2,1
 820669c:	d9003317 	ldw	r4,204(sp)
 82066a0:	1105883a 	add	r2,r2,r4
 82066a4:	d8802e15 	stw	r2,184(sp)
 82066a8:	10005f16 	blt	r2,zero,8206828 <___svfprintf_internal_r+0x2050>
 82066ac:	044019c4 	movi	r17,103
 82066b0:	003ed906 	br	8206218 <___svfprintf_internal_r+0x1a40>
 82066b4:	d9002917 	ldw	r4,164(sp)
 82066b8:	20c00044 	addi	r3,r4,1
 82066bc:	003e9c06 	br	8206130 <___svfprintf_internal_r+0x1958>
 82066c0:	d9002917 	ldw	r4,164(sp)
 82066c4:	00c0680e 	bge	zero,r3,8206868 <___svfprintf_internal_r+0x2090>
 82066c8:	2000461e 	bne	r4,zero,82067e4 <___svfprintf_internal_r+0x200c>
 82066cc:	9480004c 	andi	r18,r18,1
 82066d0:	9000441e 	bne	r18,zero,82067e4 <___svfprintf_internal_r+0x200c>
 82066d4:	1805883a 	mov	r2,r3
 82066d8:	1800a016 	blt	r3,zero,820695c <___svfprintf_internal_r+0x2184>
 82066dc:	d8c03217 	ldw	r3,200(sp)
 82066e0:	d8c02e15 	stw	r3,184(sp)
 82066e4:	003ecc06 	br	8206218 <___svfprintf_internal_r+0x1a40>
 82066e8:	d9402917 	ldw	r5,164(sp)
 82066ec:	d8802104 	addi	r2,sp,132
 82066f0:	d8800315 	stw	r2,12(sp)
 82066f4:	d9400015 	stw	r5,0(sp)
 82066f8:	d8802504 	addi	r2,sp,148
 82066fc:	d9403617 	ldw	r5,216(sp)
 8206700:	d8800215 	stw	r2,8(sp)
 8206704:	d8802604 	addi	r2,sp,152
 8206708:	d8800115 	stw	r2,4(sp)
 820670c:	01c000c4 	movi	r7,3
 8206710:	a00d883a 	mov	r6,r20
 8206714:	9809883a 	mov	r4,r19
 8206718:	da003e15 	stw	r8,248(sp)
 820671c:	82091340 	call	8209134 <_dtoa_r>
 8206720:	d8c02917 	ldw	r3,164(sp)
 8206724:	da003e17 	ldw	r8,248(sp)
 8206728:	1021883a 	mov	r16,r2
 820672c:	00801184 	movi	r2,70
 8206730:	80f9883a 	add	fp,r16,r3
 8206734:	88bfcc26 	beq	r17,r2,8206668 <___svfprintf_internal_r+0x1e90>
 8206738:	003e9306 	br	8206188 <___svfprintf_internal_r+0x19b0>
 820673c:	df0022c4 	addi	fp,sp,139
 8206740:	dc002915 	stw	r16,164(sp)
 8206744:	9829883a 	mov	r20,r19
 8206748:	e021883a 	mov	r16,fp
 820674c:	4027883a 	mov	r19,r8
 8206750:	b009883a 	mov	r4,r22
 8206754:	01400284 	movi	r5,10
 8206758:	8202b180 	call	8202b18 <__modsi3>
 820675c:	10800c04 	addi	r2,r2,48
 8206760:	843fffc4 	addi	r16,r16,-1
 8206764:	b009883a 	mov	r4,r22
 8206768:	01400284 	movi	r5,10
 820676c:	80800005 	stb	r2,0(r16)
 8206770:	8202a940 	call	8202a94 <__divsi3>
 8206774:	102d883a 	mov	r22,r2
 8206778:	00800244 	movi	r2,9
 820677c:	15bff416 	blt	r2,r22,8206750 <___svfprintf_internal_r+0x1f78>
 8206780:	9811883a 	mov	r8,r19
 8206784:	b0800c04 	addi	r2,r22,48
 8206788:	a027883a 	mov	r19,r20
 820678c:	8029883a 	mov	r20,r16
 8206790:	a17fffc4 	addi	r5,r20,-1
 8206794:	a0bfffc5 	stb	r2,-1(r20)
 8206798:	dc002917 	ldw	r16,164(sp)
 820679c:	2f00752e 	bgeu	r5,fp,8206974 <___svfprintf_internal_r+0x219c>
 82067a0:	d9c02384 	addi	r7,sp,142
 82067a4:	3d0fc83a 	sub	r7,r7,r20
 82067a8:	d9002344 	addi	r4,sp,141
 82067ac:	e1cf883a 	add	r7,fp,r7
 82067b0:	00000106 	br	82067b8 <___svfprintf_internal_r+0x1fe0>
 82067b4:	28800003 	ldbu	r2,0(r5)
 82067b8:	20800005 	stb	r2,0(r4)
 82067bc:	21000044 	addi	r4,r4,1
 82067c0:	29400044 	addi	r5,r5,1
 82067c4:	21fffb1e 	bne	r4,r7,82067b4 <___svfprintf_internal_r+0x1fdc>
 82067c8:	d8802304 	addi	r2,sp,140
 82067cc:	1505c83a 	sub	r2,r2,r20
 82067d0:	d8c02344 	addi	r3,sp,141
 82067d4:	1885883a 	add	r2,r3,r2
 82067d8:	003f7006 	br	820659c <___svfprintf_internal_r+0x1dc4>
 82067dc:	0005883a 	mov	r2,zero
 82067e0:	003f0b06 	br	8206410 <___svfprintf_internal_r+0x1c38>
 82067e4:	d9002917 	ldw	r4,164(sp)
 82067e8:	d8c03217 	ldw	r3,200(sp)
 82067ec:	20800044 	addi	r2,r4,1
 82067f0:	1885883a 	add	r2,r3,r2
 82067f4:	d8802e15 	stw	r2,184(sp)
 82067f8:	103e870e 	bge	r2,zero,8206218 <___svfprintf_internal_r+0x1a40>
 82067fc:	0005883a 	mov	r2,zero
 8206800:	003e8506 	br	8206218 <___svfprintf_internal_r+0x1a40>
 8206804:	01020974 	movhi	r4,2085
 8206808:	2136d384 	addi	r4,r4,-9394
 820680c:	d9002b15 	stw	r4,172(sp)
 8206810:	003cc506 	br	8205b28 <___svfprintf_internal_r+0x1350>
 8206814:	d8c03217 	ldw	r3,200(sp)
 8206818:	18c00044 	addi	r3,r3,1
 820681c:	d8c02e15 	stw	r3,184(sp)
 8206820:	1805883a 	mov	r2,r3
 8206824:	183fa10e 	bge	r3,zero,82066ac <___svfprintf_internal_r+0x1ed4>
 8206828:	0005883a 	mov	r2,zero
 820682c:	003f9f06 	br	82066ac <___svfprintf_internal_r+0x1ed4>
 8206830:	d9003617 	ldw	r4,216(sp)
 8206834:	000d883a 	mov	r6,zero
 8206838:	000f883a 	mov	r7,zero
 820683c:	a00b883a 	mov	r5,r20
 8206840:	d8c03d15 	stw	r3,244(sp)
 8206844:	da003e15 	stw	r8,248(sp)
 8206848:	8212e780 	call	8212e78 <__eqdf2>
 820684c:	d8c03d17 	ldw	r3,244(sp)
 8206850:	da003e17 	ldw	r8,248(sp)
 8206854:	103f8726 	beq	r2,zero,8206674 <___svfprintf_internal_r+0x1e9c>
 8206858:	00800044 	movi	r2,1
 820685c:	10c7c83a 	sub	r3,r2,r3
 8206860:	d8c02615 	stw	r3,152(sp)
 8206864:	003f8406 	br	8206678 <___svfprintf_internal_r+0x1ea0>
 8206868:	20000e1e 	bne	r4,zero,82068a4 <___svfprintf_internal_r+0x20cc>
 820686c:	9480004c 	andi	r18,r18,1
 8206870:	90000c1e 	bne	r18,zero,82068a4 <___svfprintf_internal_r+0x20cc>
 8206874:	00800044 	movi	r2,1
 8206878:	d8802e15 	stw	r2,184(sp)
 820687c:	003e6606 	br	8206218 <___svfprintf_internal_r+0x1a40>
 8206880:	00800b44 	movi	r2,45
 8206884:	05adc83a 	sub	r22,zero,r22
 8206888:	d8802305 	stb	r2,140(sp)
 820688c:	003f3b06 	br	820657c <___svfprintf_internal_r+0x1da4>
 8206890:	0005883a 	mov	r2,zero
 8206894:	003f4e06 	br	82065d0 <___svfprintf_internal_r+0x1df8>
 8206898:	90a4703a 	and	r18,r18,r2
 820689c:	903f4a26 	beq	r18,zero,82065c8 <___svfprintf_internal_r+0x1df0>
 82068a0:	003f4606 	br	82065bc <___svfprintf_internal_r+0x1de4>
 82068a4:	d8c02917 	ldw	r3,164(sp)
 82068a8:	18c00084 	addi	r3,r3,2
 82068ac:	d8c02e15 	stw	r3,184(sp)
 82068b0:	1805883a 	mov	r2,r3
 82068b4:	183e580e 	bge	r3,zero,8206218 <___svfprintf_internal_r+0x1a40>
 82068b8:	003fd006 	br	82067fc <___svfprintf_internal_r+0x2024>
 82068bc:	00800084 	movi	r2,2
 82068c0:	10c5c83a 	sub	r2,r2,r3
 82068c4:	003f7506 	br	820669c <___svfprintf_internal_r+0x1ec4>
 82068c8:	d8802d17 	ldw	r2,180(sp)
 82068cc:	d9002d17 	ldw	r4,180(sp)
 82068d0:	bc400043 	ldbu	r17,1(r23)
 82068d4:	10800017 	ldw	r2,0(r2)
 82068d8:	582f883a 	mov	r23,r11
 82068dc:	d8802915 	stw	r2,164(sp)
 82068e0:	20800104 	addi	r2,r4,4
 82068e4:	d9002917 	ldw	r4,164(sp)
 82068e8:	d8802d15 	stw	r2,180(sp)
 82068ec:	203df00e 	bge	r4,zero,82060b0 <___svfprintf_internal_r+0x18d8>
 82068f0:	8c403fcc 	andi	r17,r17,255
 82068f4:	00bfffc4 	movi	r2,-1
 82068f8:	8c40201c 	xori	r17,r17,128
 82068fc:	d8802915 	stw	r2,164(sp)
 8206900:	8c7fe004 	addi	r17,r17,-128
 8206904:	00380806 	br	8204928 <___svfprintf_internal_r+0x150>
 8206908:	9080004c 	andi	r2,r18,1
 820690c:	0039883a 	mov	fp,zero
 8206910:	10000726 	beq	r2,zero,8206930 <___svfprintf_internal_r+0x2158>
 8206914:	d8c02817 	ldw	r3,160(sp)
 8206918:	dc001dc4 	addi	r16,sp,119
 820691c:	00800c04 	movi	r2,48
 8206920:	1c07c83a 	sub	r3,r3,r16
 8206924:	d8801dc5 	stb	r2,119(sp)
 8206928:	d8c02e15 	stw	r3,184(sp)
 820692c:	00395206 	br	8204e78 <___svfprintf_internal_r+0x6a0>
 8206930:	d8002e15 	stw	zero,184(sp)
 8206934:	dc001e04 	addi	r16,sp,120
 8206938:	00394f06 	br	8204e78 <___svfprintf_internal_r+0x6a0>
 820693c:	0005883a 	mov	r2,zero
 8206940:	003e3206 	br	820620c <___svfprintf_internal_r+0x1a34>
 8206944:	dd802617 	ldw	r22,152(sp)
 8206948:	003f0606 	br	8206564 <___svfprintf_internal_r+0x1d8c>
 820694c:	d9c02785 	stb	r7,158(sp)
 8206950:	003a5106 	br	8205298 <___svfprintf_internal_r+0xac0>
 8206954:	d9c02785 	stb	r7,158(sp)
 8206958:	003a3706 	br	8205238 <___svfprintf_internal_r+0xa60>
 820695c:	0005883a 	mov	r2,zero
 8206960:	003f5e06 	br	82066dc <___svfprintf_internal_r+0x1f04>
 8206964:	d9c02785 	stb	r7,158(sp)
 8206968:	00391706 	br	8204dc8 <___svfprintf_internal_r+0x5f0>
 820696c:	d9c02785 	stb	r7,158(sp)
 8206970:	0038e606 	br	8204d0c <___svfprintf_internal_r+0x534>
 8206974:	d8802344 	addi	r2,sp,141
 8206978:	003f0806 	br	820659c <___svfprintf_internal_r+0x1dc4>
 820697c:	d9c02785 	stb	r7,158(sp)
 8206980:	0038b706 	br	8204c60 <___svfprintf_internal_r+0x488>
 8206984:	d9c02785 	stb	r7,158(sp)
 8206988:	003adc06 	br	82054fc <___svfprintf_internal_r+0xd24>
 820698c:	d9403917 	ldw	r5,228(sp)
 8206990:	00800304 	movi	r2,12
 8206994:	28800015 	stw	r2,0(r5)
 8206998:	00bfffc4 	movi	r2,-1
 820699c:	00387806 	br	8204b80 <___svfprintf_internal_r+0x3a8>
 82069a0:	d9c02785 	stb	r7,158(sp)
 82069a4:	003abf06 	br	82054a4 <___svfprintf_internal_r+0xccc>
 82069a8:	d9c02785 	stb	r7,158(sp)
 82069ac:	003a9b06 	br	820541c <___svfprintf_internal_r+0xc44>

082069b0 <_user_strerror>:
 82069b0:	0005883a 	mov	r2,zero
 82069b4:	f800283a 	ret

082069b8 <___vfprintf_internal_r>:
 82069b8:	deffb804 	addi	sp,sp,-288
 82069bc:	dfc04715 	stw	ra,284(sp)
 82069c0:	ddc04515 	stw	r23,276(sp)
 82069c4:	dd404315 	stw	r21,268(sp)
 82069c8:	d9002c15 	stw	r4,176(sp)
 82069cc:	282f883a 	mov	r23,r5
 82069d0:	302b883a 	mov	r21,r6
 82069d4:	d9c02d15 	stw	r7,180(sp)
 82069d8:	df004615 	stw	fp,280(sp)
 82069dc:	dd804415 	stw	r22,272(sp)
 82069e0:	dd004215 	stw	r20,264(sp)
 82069e4:	dcc04115 	stw	r19,260(sp)
 82069e8:	dc804015 	stw	r18,256(sp)
 82069ec:	dc403f15 	stw	r17,252(sp)
 82069f0:	dc003e15 	stw	r16,248(sp)
 82069f4:	820ba7c0 	call	820ba7c <_localeconv_r>
 82069f8:	10800017 	ldw	r2,0(r2)
 82069fc:	1009883a 	mov	r4,r2
 8206a00:	d8803415 	stw	r2,208(sp)
 8206a04:	8203edc0 	call	8203edc <strlen>
 8206a08:	d8803715 	stw	r2,220(sp)
 8206a0c:	d8802c17 	ldw	r2,176(sp)
 8206a10:	10000226 	beq	r2,zero,8206a1c <___vfprintf_internal_r+0x64>
 8206a14:	10800e17 	ldw	r2,56(r2)
 8206a18:	1000f926 	beq	r2,zero,8206e00 <___vfprintf_internal_r+0x448>
 8206a1c:	b880030b 	ldhu	r2,12(r23)
 8206a20:	10c8000c 	andi	r3,r2,8192
 8206a24:	1800061e 	bne	r3,zero,8206a40 <___vfprintf_internal_r+0x88>
 8206a28:	b9001917 	ldw	r4,100(r23)
 8206a2c:	00f7ffc4 	movi	r3,-8193
 8206a30:	10880014 	ori	r2,r2,8192
 8206a34:	20c6703a 	and	r3,r4,r3
 8206a38:	b880030d 	sth	r2,12(r23)
 8206a3c:	b8c01915 	stw	r3,100(r23)
 8206a40:	10c0020c 	andi	r3,r2,8
 8206a44:	1800c126 	beq	r3,zero,8206d4c <___vfprintf_internal_r+0x394>
 8206a48:	b8c00417 	ldw	r3,16(r23)
 8206a4c:	1800bf26 	beq	r3,zero,8206d4c <___vfprintf_internal_r+0x394>
 8206a50:	1080068c 	andi	r2,r2,26
 8206a54:	00c00284 	movi	r3,10
 8206a58:	10c0c426 	beq	r2,r3,8206d6c <___vfprintf_internal_r+0x3b4>
 8206a5c:	d8c00404 	addi	r3,sp,16
 8206a60:	05020974 	movhi	r20,2085
 8206a64:	d9001e04 	addi	r4,sp,120
 8206a68:	a536db84 	addi	r20,r20,-9362
 8206a6c:	d8c01e15 	stw	r3,120(sp)
 8206a70:	d8002015 	stw	zero,128(sp)
 8206a74:	d8001f15 	stw	zero,124(sp)
 8206a78:	d8003315 	stw	zero,204(sp)
 8206a7c:	d8003615 	stw	zero,216(sp)
 8206a80:	d8003815 	stw	zero,224(sp)
 8206a84:	1811883a 	mov	r8,r3
 8206a88:	d8003915 	stw	zero,228(sp)
 8206a8c:	d8003a15 	stw	zero,232(sp)
 8206a90:	d8002f15 	stw	zero,188(sp)
 8206a94:	d9002815 	stw	r4,160(sp)
 8206a98:	a8800007 	ldb	r2,0(r21)
 8206a9c:	10027b26 	beq	r2,zero,820748c <___vfprintf_internal_r+0xad4>
 8206aa0:	00c00944 	movi	r3,37
 8206aa4:	a821883a 	mov	r16,r21
 8206aa8:	10c0021e 	bne	r2,r3,8206ab4 <___vfprintf_internal_r+0xfc>
 8206aac:	00001406 	br	8206b00 <___vfprintf_internal_r+0x148>
 8206ab0:	10c00326 	beq	r2,r3,8206ac0 <___vfprintf_internal_r+0x108>
 8206ab4:	84000044 	addi	r16,r16,1
 8206ab8:	80800007 	ldb	r2,0(r16)
 8206abc:	103ffc1e 	bne	r2,zero,8206ab0 <___vfprintf_internal_r+0xf8>
 8206ac0:	8563c83a 	sub	r17,r16,r21
 8206ac4:	88000e26 	beq	r17,zero,8206b00 <___vfprintf_internal_r+0x148>
 8206ac8:	d8c02017 	ldw	r3,128(sp)
 8206acc:	d8801f17 	ldw	r2,124(sp)
 8206ad0:	45400015 	stw	r21,0(r8)
 8206ad4:	1c47883a 	add	r3,r3,r17
 8206ad8:	10800044 	addi	r2,r2,1
 8206adc:	d8c02015 	stw	r3,128(sp)
 8206ae0:	44400115 	stw	r17,4(r8)
 8206ae4:	d8801f15 	stw	r2,124(sp)
 8206ae8:	00c001c4 	movi	r3,7
 8206aec:	1880a716 	blt	r3,r2,8206d8c <___vfprintf_internal_r+0x3d4>
 8206af0:	42000204 	addi	r8,r8,8
 8206af4:	d9402f17 	ldw	r5,188(sp)
 8206af8:	2c4b883a 	add	r5,r5,r17
 8206afc:	d9402f15 	stw	r5,188(sp)
 8206b00:	80800007 	ldb	r2,0(r16)
 8206b04:	1000a826 	beq	r2,zero,8206da8 <___vfprintf_internal_r+0x3f0>
 8206b08:	84400047 	ldb	r17,1(r16)
 8206b0c:	00bfffc4 	movi	r2,-1
 8206b10:	85400044 	addi	r21,r16,1
 8206b14:	d8002785 	stb	zero,158(sp)
 8206b18:	0007883a 	mov	r3,zero
 8206b1c:	000f883a 	mov	r7,zero
 8206b20:	d8802915 	stw	r2,164(sp)
 8206b24:	d8003115 	stw	zero,196(sp)
 8206b28:	0025883a 	mov	r18,zero
 8206b2c:	01401604 	movi	r5,88
 8206b30:	01800244 	movi	r6,9
 8206b34:	02800a84 	movi	r10,42
 8206b38:	02401b04 	movi	r9,108
 8206b3c:	ad400044 	addi	r21,r21,1
 8206b40:	88bff804 	addi	r2,r17,-32
 8206b44:	28830436 	bltu	r5,r2,8207758 <___vfprintf_internal_r+0xda0>
 8206b48:	100490ba 	slli	r2,r2,2
 8206b4c:	01020834 	movhi	r4,2080
 8206b50:	211ad804 	addi	r4,r4,27488
 8206b54:	1105883a 	add	r2,r2,r4
 8206b58:	10800017 	ldw	r2,0(r2)
 8206b5c:	1000683a 	jmp	r2
 8206b60:	08207678 	rdprs	zero,at,-32295
 8206b64:	08207758 	cmpnei	zero,at,-32291
 8206b68:	08207758 	cmpnei	zero,at,-32291
 8206b6c:	08207698 	cmpnei	zero,at,-32294
 8206b70:	08207758 	cmpnei	zero,at,-32291
 8206b74:	08207758 	cmpnei	zero,at,-32291
 8206b78:	08207758 	cmpnei	zero,at,-32291
 8206b7c:	08207758 	cmpnei	zero,at,-32291
 8206b80:	08207758 	cmpnei	zero,at,-32291
 8206b84:	08207758 	cmpnei	zero,at,-32291
 8206b88:	08206e0c 	andi	zero,at,33208
 8206b8c:	082075b4 	orhi	zero,at,33238
 8206b90:	08207758 	cmpnei	zero,at,-32291
 8206b94:	08206cd4 	ori	zero,at,33203
 8206b98:	08206e34 	orhi	zero,at,33208
 8206b9c:	08207758 	cmpnei	zero,at,-32291
 8206ba0:	08206e74 	orhi	zero,at,33209
 8206ba4:	08206e80 	call	8206e8 <OSCtxSw_SWITCH_PC+0x8206a8>
 8206ba8:	08206e80 	call	8206e8 <OSCtxSw_SWITCH_PC+0x8206a8>
 8206bac:	08206e80 	call	8206e8 <OSCtxSw_SWITCH_PC+0x8206a8>
 8206bb0:	08206e80 	call	8206e8 <OSCtxSw_SWITCH_PC+0x8206a8>
 8206bb4:	08206e80 	call	8206e8 <OSCtxSw_SWITCH_PC+0x8206a8>
 8206bb8:	08206e80 	call	8206e8 <OSCtxSw_SWITCH_PC+0x8206a8>
 8206bbc:	08206e80 	call	8206e8 <OSCtxSw_SWITCH_PC+0x8206a8>
 8206bc0:	08206e80 	call	8206e8 <OSCtxSw_SWITCH_PC+0x8206a8>
 8206bc4:	08206e80 	call	8206e8 <OSCtxSw_SWITCH_PC+0x8206a8>
 8206bc8:	08207758 	cmpnei	zero,at,-32291
 8206bcc:	08207758 	cmpnei	zero,at,-32291
 8206bd0:	08207758 	cmpnei	zero,at,-32291
 8206bd4:	08207758 	cmpnei	zero,at,-32291
 8206bd8:	08207758 	cmpnei	zero,at,-32291
 8206bdc:	08207758 	cmpnei	zero,at,-32291
 8206be0:	08207758 	cmpnei	zero,at,-32291
 8206be4:	08207758 	cmpnei	zero,at,-32291
 8206be8:	08207758 	cmpnei	zero,at,-32291
 8206bec:	08207758 	cmpnei	zero,at,-32291
 8206bf0:	08206eb4 	orhi	zero,at,33210
 8206bf4:	08206f70 	cmpltui	zero,at,33213
 8206bf8:	08207758 	cmpnei	zero,at,-32291
 8206bfc:	08206f70 	cmpltui	zero,at,33213
 8206c00:	08207758 	cmpnei	zero,at,-32291
 8206c04:	08207758 	cmpnei	zero,at,-32291
 8206c08:	08207758 	cmpnei	zero,at,-32291
 8206c0c:	08207758 	cmpnei	zero,at,-32291
 8206c10:	08207010 	cmplti	zero,at,-32320
 8206c14:	08207758 	cmpnei	zero,at,-32291
 8206c18:	08207758 	cmpnei	zero,at,-32291
 8206c1c:	0820701c 	xori	zero,at,33216
 8206c20:	08207758 	cmpnei	zero,at,-32291
 8206c24:	08207758 	cmpnei	zero,at,-32291
 8206c28:	08207758 	cmpnei	zero,at,-32291
 8206c2c:	08207758 	cmpnei	zero,at,-32291
 8206c30:	08207758 	cmpnei	zero,at,-32291
 8206c34:	08207494 	ori	zero,at,33234
 8206c38:	08207758 	cmpnei	zero,at,-32291
 8206c3c:	08207758 	cmpnei	zero,at,-32291
 8206c40:	082074f4 	orhi	zero,at,33235
 8206c44:	08207758 	cmpnei	zero,at,-32291
 8206c48:	08207758 	cmpnei	zero,at,-32291
 8206c4c:	08207758 	cmpnei	zero,at,-32291
 8206c50:	08207758 	cmpnei	zero,at,-32291
 8206c54:	08207758 	cmpnei	zero,at,-32291
 8206c58:	08207758 	cmpnei	zero,at,-32291
 8206c5c:	08207758 	cmpnei	zero,at,-32291
 8206c60:	08207758 	cmpnei	zero,at,-32291
 8206c64:	08207758 	cmpnei	zero,at,-32291
 8206c68:	08207758 	cmpnei	zero,at,-32291
 8206c6c:	08207704 	addi	zero,at,-32292
 8206c70:	082076a4 	muli	zero,at,-32294
 8206c74:	08206f70 	cmpltui	zero,at,33213
 8206c78:	08206f70 	cmpltui	zero,at,33213
 8206c7c:	08206f70 	cmpltui	zero,at,33213
 8206c80:	082076b4 	orhi	zero,at,33242
 8206c84:	082076a4 	muli	zero,at,-32294
 8206c88:	08207758 	cmpnei	zero,at,-32291
 8206c8c:	08207758 	cmpnei	zero,at,-32291
 8206c90:	082076c0 	call	82076c <OSCtxSw_SWITCH_PC+0x82072c>
 8206c94:	08207758 	cmpnei	zero,at,-32291
 8206c98:	082076d0 	cmplti	zero,at,-32293
 8206c9c:	082075a4 	muli	zero,at,-32298
 8206ca0:	08206ce0 	cmpeqi	zero,at,-32333
 8206ca4:	082075c4 	addi	zero,at,-32297
 8206ca8:	08207758 	cmpnei	zero,at,-32291
 8206cac:	082075d0 	cmplti	zero,at,-32297
 8206cb0:	08207758 	cmpnei	zero,at,-32291
 8206cb4:	0820762c 	andhi	zero,at,33240
 8206cb8:	08207758 	cmpnei	zero,at,-32291
 8206cbc:	08207758 	cmpnei	zero,at,-32291
 8206cc0:	0820763c 	xorhi	zero,at,33240
 8206cc4:	d9003117 	ldw	r4,196(sp)
 8206cc8:	d8802d15 	stw	r2,180(sp)
 8206ccc:	0109c83a 	sub	r4,zero,r4
 8206cd0:	d9003115 	stw	r4,196(sp)
 8206cd4:	94800114 	ori	r18,r18,4
 8206cd8:	ac400007 	ldb	r17,0(r21)
 8206cdc:	003f9706 	br	8206b3c <___vfprintf_internal_r+0x184>
 8206ce0:	00800c04 	movi	r2,48
 8206ce4:	d9002d17 	ldw	r4,180(sp)
 8206ce8:	d9402917 	ldw	r5,164(sp)
 8206cec:	d8802705 	stb	r2,156(sp)
 8206cf0:	00801e04 	movi	r2,120
 8206cf4:	d8802745 	stb	r2,157(sp)
 8206cf8:	d8002785 	stb	zero,158(sp)
 8206cfc:	20c00104 	addi	r3,r4,4
 8206d00:	24c00017 	ldw	r19,0(r4)
 8206d04:	002d883a 	mov	r22,zero
 8206d08:	90800094 	ori	r2,r18,2
 8206d0c:	28029a16 	blt	r5,zero,8207778 <___vfprintf_internal_r+0xdc0>
 8206d10:	00bfdfc4 	movi	r2,-129
 8206d14:	90a4703a 	and	r18,r18,r2
 8206d18:	d8c02d15 	stw	r3,180(sp)
 8206d1c:	94800094 	ori	r18,r18,2
 8206d20:	9802871e 	bne	r19,zero,8207740 <___vfprintf_internal_r+0xd88>
 8206d24:	00820974 	movhi	r2,2085
 8206d28:	10b6cc04 	addi	r2,r2,-9424
 8206d2c:	d8803915 	stw	r2,228(sp)
 8206d30:	04401e04 	movi	r17,120
 8206d34:	d8802917 	ldw	r2,164(sp)
 8206d38:	0039883a 	mov	fp,zero
 8206d3c:	1001e926 	beq	r2,zero,82074e4 <___vfprintf_internal_r+0xb2c>
 8206d40:	0027883a 	mov	r19,zero
 8206d44:	002d883a 	mov	r22,zero
 8206d48:	00020506 	br	8207560 <___vfprintf_internal_r+0xba8>
 8206d4c:	d9002c17 	ldw	r4,176(sp)
 8206d50:	b80b883a 	mov	r5,r23
 8206d54:	8208de00 	call	8208de0 <__swsetup_r>
 8206d58:	1005ac1e 	bne	r2,zero,820840c <___vfprintf_internal_r+0x1a54>
 8206d5c:	b880030b 	ldhu	r2,12(r23)
 8206d60:	00c00284 	movi	r3,10
 8206d64:	1080068c 	andi	r2,r2,26
 8206d68:	10ff3c1e 	bne	r2,r3,8206a5c <___vfprintf_internal_r+0xa4>
 8206d6c:	b880038f 	ldh	r2,14(r23)
 8206d70:	103f3a16 	blt	r2,zero,8206a5c <___vfprintf_internal_r+0xa4>
 8206d74:	d9c02d17 	ldw	r7,180(sp)
 8206d78:	d9002c17 	ldw	r4,176(sp)
 8206d7c:	a80d883a 	mov	r6,r21
 8206d80:	b80b883a 	mov	r5,r23
 8206d84:	8208bcc0 	call	8208bcc <__sbprintf>
 8206d88:	00001106 	br	8206dd0 <___vfprintf_internal_r+0x418>
 8206d8c:	d9002c17 	ldw	r4,176(sp)
 8206d90:	d9801e04 	addi	r6,sp,120
 8206d94:	b80b883a 	mov	r5,r23
 8206d98:	820f50c0 	call	820f50c <__sprint_r>
 8206d9c:	1000081e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8206da0:	da000404 	addi	r8,sp,16
 8206da4:	003f5306 	br	8206af4 <___vfprintf_internal_r+0x13c>
 8206da8:	d8802017 	ldw	r2,128(sp)
 8206dac:	10000426 	beq	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8206db0:	d9002c17 	ldw	r4,176(sp)
 8206db4:	d9801e04 	addi	r6,sp,120
 8206db8:	b80b883a 	mov	r5,r23
 8206dbc:	820f50c0 	call	820f50c <__sprint_r>
 8206dc0:	b880030b 	ldhu	r2,12(r23)
 8206dc4:	1080100c 	andi	r2,r2,64
 8206dc8:	1005901e 	bne	r2,zero,820840c <___vfprintf_internal_r+0x1a54>
 8206dcc:	d8802f17 	ldw	r2,188(sp)
 8206dd0:	dfc04717 	ldw	ra,284(sp)
 8206dd4:	df004617 	ldw	fp,280(sp)
 8206dd8:	ddc04517 	ldw	r23,276(sp)
 8206ddc:	dd804417 	ldw	r22,272(sp)
 8206de0:	dd404317 	ldw	r21,268(sp)
 8206de4:	dd004217 	ldw	r20,264(sp)
 8206de8:	dcc04117 	ldw	r19,260(sp)
 8206dec:	dc804017 	ldw	r18,256(sp)
 8206df0:	dc403f17 	ldw	r17,252(sp)
 8206df4:	dc003e17 	ldw	r16,248(sp)
 8206df8:	dec04804 	addi	sp,sp,288
 8206dfc:	f800283a 	ret
 8206e00:	d9002c17 	ldw	r4,176(sp)
 8206e04:	820adb40 	call	820adb4 <__sinit>
 8206e08:	003f0406 	br	8206a1c <___vfprintf_internal_r+0x64>
 8206e0c:	d8802d17 	ldw	r2,180(sp)
 8206e10:	d9002d17 	ldw	r4,180(sp)
 8206e14:	10800017 	ldw	r2,0(r2)
 8206e18:	d8803115 	stw	r2,196(sp)
 8206e1c:	20800104 	addi	r2,r4,4
 8206e20:	d9003117 	ldw	r4,196(sp)
 8206e24:	203fa716 	blt	r4,zero,8206cc4 <___vfprintf_internal_r+0x30c>
 8206e28:	d8802d15 	stw	r2,180(sp)
 8206e2c:	ac400007 	ldb	r17,0(r21)
 8206e30:	003f4206 	br	8206b3c <___vfprintf_internal_r+0x184>
 8206e34:	ac400007 	ldb	r17,0(r21)
 8206e38:	aac00044 	addi	r11,r21,1
 8206e3c:	8a872826 	beq	r17,r10,8208ae0 <___vfprintf_internal_r+0x2128>
 8206e40:	88bff404 	addi	r2,r17,-48
 8206e44:	0009883a 	mov	r4,zero
 8206e48:	30867d36 	bltu	r6,r2,8208840 <___vfprintf_internal_r+0x1e88>
 8206e4c:	5c400007 	ldb	r17,0(r11)
 8206e50:	210002a4 	muli	r4,r4,10
 8206e54:	5d400044 	addi	r21,r11,1
 8206e58:	a817883a 	mov	r11,r21
 8206e5c:	2089883a 	add	r4,r4,r2
 8206e60:	88bff404 	addi	r2,r17,-48
 8206e64:	30bff92e 	bgeu	r6,r2,8206e4c <___vfprintf_internal_r+0x494>
 8206e68:	2005c916 	blt	r4,zero,8208590 <___vfprintf_internal_r+0x1bd8>
 8206e6c:	d9002915 	stw	r4,164(sp)
 8206e70:	003f3306 	br	8206b40 <___vfprintf_internal_r+0x188>
 8206e74:	94802014 	ori	r18,r18,128
 8206e78:	ac400007 	ldb	r17,0(r21)
 8206e7c:	003f2f06 	br	8206b3c <___vfprintf_internal_r+0x184>
 8206e80:	a809883a 	mov	r4,r21
 8206e84:	d8003115 	stw	zero,196(sp)
 8206e88:	88bff404 	addi	r2,r17,-48
 8206e8c:	0017883a 	mov	r11,zero
 8206e90:	24400007 	ldb	r17,0(r4)
 8206e94:	5ac002a4 	muli	r11,r11,10
 8206e98:	ad400044 	addi	r21,r21,1
 8206e9c:	a809883a 	mov	r4,r21
 8206ea0:	12d7883a 	add	r11,r2,r11
 8206ea4:	88bff404 	addi	r2,r17,-48
 8206ea8:	30bff92e 	bgeu	r6,r2,8206e90 <___vfprintf_internal_r+0x4d8>
 8206eac:	dac03115 	stw	r11,196(sp)
 8206eb0:	003f2306 	br	8206b40 <___vfprintf_internal_r+0x188>
 8206eb4:	18c03fcc 	andi	r3,r3,255
 8206eb8:	18072b1e 	bne	r3,zero,8208b68 <___vfprintf_internal_r+0x21b0>
 8206ebc:	94800414 	ori	r18,r18,16
 8206ec0:	9080080c 	andi	r2,r18,32
 8206ec4:	10037b26 	beq	r2,zero,8207cb4 <___vfprintf_internal_r+0x12fc>
 8206ec8:	d9402d17 	ldw	r5,180(sp)
 8206ecc:	28800117 	ldw	r2,4(r5)
 8206ed0:	2cc00017 	ldw	r19,0(r5)
 8206ed4:	29400204 	addi	r5,r5,8
 8206ed8:	d9402d15 	stw	r5,180(sp)
 8206edc:	102d883a 	mov	r22,r2
 8206ee0:	10044b16 	blt	r2,zero,8208010 <___vfprintf_internal_r+0x1658>
 8206ee4:	d9402917 	ldw	r5,164(sp)
 8206ee8:	df002783 	ldbu	fp,158(sp)
 8206eec:	2803bc16 	blt	r5,zero,8207de0 <___vfprintf_internal_r+0x1428>
 8206ef0:	00ffdfc4 	movi	r3,-129
 8206ef4:	9d84b03a 	or	r2,r19,r22
 8206ef8:	90e4703a 	and	r18,r18,r3
 8206efc:	10017726 	beq	r2,zero,82074dc <___vfprintf_internal_r+0xb24>
 8206f00:	b0038326 	beq	r22,zero,8207d10 <___vfprintf_internal_r+0x1358>
 8206f04:	dc402a15 	stw	r17,168(sp)
 8206f08:	dc001e04 	addi	r16,sp,120
 8206f0c:	b023883a 	mov	r17,r22
 8206f10:	402d883a 	mov	r22,r8
 8206f14:	9809883a 	mov	r4,r19
 8206f18:	880b883a 	mov	r5,r17
 8206f1c:	01800284 	movi	r6,10
 8206f20:	000f883a 	mov	r7,zero
 8206f24:	82117ac0 	call	82117ac <__umoddi3>
 8206f28:	10800c04 	addi	r2,r2,48
 8206f2c:	843fffc4 	addi	r16,r16,-1
 8206f30:	9809883a 	mov	r4,r19
 8206f34:	880b883a 	mov	r5,r17
 8206f38:	80800005 	stb	r2,0(r16)
 8206f3c:	01800284 	movi	r6,10
 8206f40:	000f883a 	mov	r7,zero
 8206f44:	82112340 	call	8211234 <__udivdi3>
 8206f48:	1027883a 	mov	r19,r2
 8206f4c:	10c4b03a 	or	r2,r2,r3
 8206f50:	1823883a 	mov	r17,r3
 8206f54:	103fef1e 	bne	r2,zero,8206f14 <___vfprintf_internal_r+0x55c>
 8206f58:	d8c02817 	ldw	r3,160(sp)
 8206f5c:	dc402a17 	ldw	r17,168(sp)
 8206f60:	b011883a 	mov	r8,r22
 8206f64:	1c07c83a 	sub	r3,r3,r16
 8206f68:	d8c02e15 	stw	r3,184(sp)
 8206f6c:	00005906 	br	82070d4 <___vfprintf_internal_r+0x71c>
 8206f70:	18c03fcc 	andi	r3,r3,255
 8206f74:	1806fa1e 	bne	r3,zero,8208b60 <___vfprintf_internal_r+0x21a8>
 8206f78:	9080020c 	andi	r2,r18,8
 8206f7c:	10048a26 	beq	r2,zero,82081a8 <___vfprintf_internal_r+0x17f0>
 8206f80:	d8c02d17 	ldw	r3,180(sp)
 8206f84:	d9002d17 	ldw	r4,180(sp)
 8206f88:	d9402d17 	ldw	r5,180(sp)
 8206f8c:	18c00017 	ldw	r3,0(r3)
 8206f90:	21000117 	ldw	r4,4(r4)
 8206f94:	29400204 	addi	r5,r5,8
 8206f98:	d8c03615 	stw	r3,216(sp)
 8206f9c:	d9003815 	stw	r4,224(sp)
 8206fa0:	d9402d15 	stw	r5,180(sp)
 8206fa4:	d9003617 	ldw	r4,216(sp)
 8206fa8:	d9403817 	ldw	r5,224(sp)
 8206fac:	da003d15 	stw	r8,244(sp)
 8206fb0:	04000044 	movi	r16,1
 8206fb4:	820dd240 	call	820dd24 <__fpclassifyd>
 8206fb8:	da003d17 	ldw	r8,244(sp)
 8206fbc:	14041f1e 	bne	r2,r16,820803c <___vfprintf_internal_r+0x1684>
 8206fc0:	d9003617 	ldw	r4,216(sp)
 8206fc4:	d9403817 	ldw	r5,224(sp)
 8206fc8:	000d883a 	mov	r6,zero
 8206fcc:	000f883a 	mov	r7,zero
 8206fd0:	8212fdc0 	call	8212fdc <__ledf2>
 8206fd4:	da003d17 	ldw	r8,244(sp)
 8206fd8:	1005be16 	blt	r2,zero,82086d4 <___vfprintf_internal_r+0x1d1c>
 8206fdc:	df002783 	ldbu	fp,158(sp)
 8206fe0:	008011c4 	movi	r2,71
 8206fe4:	1445330e 	bge	r2,r17,82084b4 <___vfprintf_internal_r+0x1afc>
 8206fe8:	04020974 	movhi	r16,2085
 8206fec:	8436c404 	addi	r16,r16,-9456
 8206ff0:	00c000c4 	movi	r3,3
 8206ff4:	00bfdfc4 	movi	r2,-129
 8206ff8:	d8c02a15 	stw	r3,168(sp)
 8206ffc:	90a4703a 	and	r18,r18,r2
 8207000:	d8c02e15 	stw	r3,184(sp)
 8207004:	d8002915 	stw	zero,164(sp)
 8207008:	d8003215 	stw	zero,200(sp)
 820700c:	00003706 	br	82070ec <___vfprintf_internal_r+0x734>
 8207010:	94800214 	ori	r18,r18,8
 8207014:	ac400007 	ldb	r17,0(r21)
 8207018:	003ec806 	br	8206b3c <___vfprintf_internal_r+0x184>
 820701c:	18c03fcc 	andi	r3,r3,255
 8207020:	1806db1e 	bne	r3,zero,8208b90 <___vfprintf_internal_r+0x21d8>
 8207024:	94800414 	ori	r18,r18,16
 8207028:	9080080c 	andi	r2,r18,32
 820702c:	1002d826 	beq	r2,zero,8207b90 <___vfprintf_internal_r+0x11d8>
 8207030:	d9402d17 	ldw	r5,180(sp)
 8207034:	d8c02917 	ldw	r3,164(sp)
 8207038:	d8002785 	stb	zero,158(sp)
 820703c:	28800204 	addi	r2,r5,8
 8207040:	2cc00017 	ldw	r19,0(r5)
 8207044:	2d800117 	ldw	r22,4(r5)
 8207048:	18048f16 	blt	r3,zero,8208288 <___vfprintf_internal_r+0x18d0>
 820704c:	013fdfc4 	movi	r4,-129
 8207050:	9d86b03a 	or	r3,r19,r22
 8207054:	d8802d15 	stw	r2,180(sp)
 8207058:	9124703a 	and	r18,r18,r4
 820705c:	1802d91e 	bne	r3,zero,8207bc4 <___vfprintf_internal_r+0x120c>
 8207060:	d8c02917 	ldw	r3,164(sp)
 8207064:	0039883a 	mov	fp,zero
 8207068:	1805c326 	beq	r3,zero,8208778 <___vfprintf_internal_r+0x1dc0>
 820706c:	0027883a 	mov	r19,zero
 8207070:	002d883a 	mov	r22,zero
 8207074:	dc001e04 	addi	r16,sp,120
 8207078:	9806d0fa 	srli	r3,r19,3
 820707c:	b008977a 	slli	r4,r22,29
 8207080:	b02cd0fa 	srli	r22,r22,3
 8207084:	9cc001cc 	andi	r19,r19,7
 8207088:	98800c04 	addi	r2,r19,48
 820708c:	843fffc4 	addi	r16,r16,-1
 8207090:	20e6b03a 	or	r19,r4,r3
 8207094:	80800005 	stb	r2,0(r16)
 8207098:	9d86b03a 	or	r3,r19,r22
 820709c:	183ff61e 	bne	r3,zero,8207078 <___vfprintf_internal_r+0x6c0>
 82070a0:	90c0004c 	andi	r3,r18,1
 82070a4:	18013b26 	beq	r3,zero,8207594 <___vfprintf_internal_r+0xbdc>
 82070a8:	10803fcc 	andi	r2,r2,255
 82070ac:	1080201c 	xori	r2,r2,128
 82070b0:	10bfe004 	addi	r2,r2,-128
 82070b4:	00c00c04 	movi	r3,48
 82070b8:	10c13626 	beq	r2,r3,8207594 <___vfprintf_internal_r+0xbdc>
 82070bc:	80ffffc5 	stb	r3,-1(r16)
 82070c0:	d8c02817 	ldw	r3,160(sp)
 82070c4:	80bfffc4 	addi	r2,r16,-1
 82070c8:	1021883a 	mov	r16,r2
 82070cc:	1887c83a 	sub	r3,r3,r2
 82070d0:	d8c02e15 	stw	r3,184(sp)
 82070d4:	d8802e17 	ldw	r2,184(sp)
 82070d8:	d9002917 	ldw	r4,164(sp)
 82070dc:	1100010e 	bge	r2,r4,82070e4 <___vfprintf_internal_r+0x72c>
 82070e0:	2005883a 	mov	r2,r4
 82070e4:	d8802a15 	stw	r2,168(sp)
 82070e8:	d8003215 	stw	zero,200(sp)
 82070ec:	e7003fcc 	andi	fp,fp,255
 82070f0:	e700201c 	xori	fp,fp,128
 82070f4:	e73fe004 	addi	fp,fp,-128
 82070f8:	e0000326 	beq	fp,zero,8207108 <___vfprintf_internal_r+0x750>
 82070fc:	d8c02a17 	ldw	r3,168(sp)
 8207100:	18c00044 	addi	r3,r3,1
 8207104:	d8c02a15 	stw	r3,168(sp)
 8207108:	90c0008c 	andi	r3,r18,2
 820710c:	d8c02b15 	stw	r3,172(sp)
 8207110:	18000326 	beq	r3,zero,8207120 <___vfprintf_internal_r+0x768>
 8207114:	d8c02a17 	ldw	r3,168(sp)
 8207118:	18c00084 	addi	r3,r3,2
 820711c:	d8c02a15 	stw	r3,168(sp)
 8207120:	90c0210c 	andi	r3,r18,132
 8207124:	d8c03015 	stw	r3,192(sp)
 8207128:	1801a31e 	bne	r3,zero,82077b8 <___vfprintf_internal_r+0xe00>
 820712c:	d9003117 	ldw	r4,196(sp)
 8207130:	d8c02a17 	ldw	r3,168(sp)
 8207134:	20e7c83a 	sub	r19,r4,r3
 8207138:	04c19f0e 	bge	zero,r19,82077b8 <___vfprintf_internal_r+0xe00>
 820713c:	02400404 	movi	r9,16
 8207140:	d8c02017 	ldw	r3,128(sp)
 8207144:	d8801f17 	ldw	r2,124(sp)
 8207148:	4cc50d0e 	bge	r9,r19,8208580 <___vfprintf_internal_r+0x1bc8>
 820714c:	01420974 	movhi	r5,2085
 8207150:	2976df84 	addi	r5,r5,-9346
 8207154:	dc403b15 	stw	r17,236(sp)
 8207158:	d9403515 	stw	r5,212(sp)
 820715c:	9823883a 	mov	r17,r19
 8207160:	482d883a 	mov	r22,r9
 8207164:	9027883a 	mov	r19,r18
 8207168:	070001c4 	movi	fp,7
 820716c:	8025883a 	mov	r18,r16
 8207170:	dc002c17 	ldw	r16,176(sp)
 8207174:	00000306 	br	8207184 <___vfprintf_internal_r+0x7cc>
 8207178:	8c7ffc04 	addi	r17,r17,-16
 820717c:	42000204 	addi	r8,r8,8
 8207180:	b440130e 	bge	r22,r17,82071d0 <___vfprintf_internal_r+0x818>
 8207184:	01020974 	movhi	r4,2085
 8207188:	18c00404 	addi	r3,r3,16
 820718c:	10800044 	addi	r2,r2,1
 8207190:	2136df84 	addi	r4,r4,-9346
 8207194:	41000015 	stw	r4,0(r8)
 8207198:	45800115 	stw	r22,4(r8)
 820719c:	d8c02015 	stw	r3,128(sp)
 82071a0:	d8801f15 	stw	r2,124(sp)
 82071a4:	e0bff40e 	bge	fp,r2,8207178 <___vfprintf_internal_r+0x7c0>
 82071a8:	d9801e04 	addi	r6,sp,120
 82071ac:	b80b883a 	mov	r5,r23
 82071b0:	8009883a 	mov	r4,r16
 82071b4:	820f50c0 	call	820f50c <__sprint_r>
 82071b8:	103f011e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 82071bc:	8c7ffc04 	addi	r17,r17,-16
 82071c0:	d8c02017 	ldw	r3,128(sp)
 82071c4:	d8801f17 	ldw	r2,124(sp)
 82071c8:	da000404 	addi	r8,sp,16
 82071cc:	b47fed16 	blt	r22,r17,8207184 <___vfprintf_internal_r+0x7cc>
 82071d0:	9021883a 	mov	r16,r18
 82071d4:	9825883a 	mov	r18,r19
 82071d8:	8827883a 	mov	r19,r17
 82071dc:	dc403b17 	ldw	r17,236(sp)
 82071e0:	d9403517 	ldw	r5,212(sp)
 82071e4:	98c7883a 	add	r3,r19,r3
 82071e8:	10800044 	addi	r2,r2,1
 82071ec:	41400015 	stw	r5,0(r8)
 82071f0:	44c00115 	stw	r19,4(r8)
 82071f4:	d8c02015 	stw	r3,128(sp)
 82071f8:	d8801f15 	stw	r2,124(sp)
 82071fc:	010001c4 	movi	r4,7
 8207200:	2082a316 	blt	r4,r2,8207c90 <___vfprintf_internal_r+0x12d8>
 8207204:	df002787 	ldb	fp,158(sp)
 8207208:	42000204 	addi	r8,r8,8
 820720c:	e0000c26 	beq	fp,zero,8207240 <___vfprintf_internal_r+0x888>
 8207210:	d8801f17 	ldw	r2,124(sp)
 8207214:	d9002784 	addi	r4,sp,158
 8207218:	18c00044 	addi	r3,r3,1
 820721c:	10800044 	addi	r2,r2,1
 8207220:	41000015 	stw	r4,0(r8)
 8207224:	01000044 	movi	r4,1
 8207228:	41000115 	stw	r4,4(r8)
 820722c:	d8c02015 	stw	r3,128(sp)
 8207230:	d8801f15 	stw	r2,124(sp)
 8207234:	010001c4 	movi	r4,7
 8207238:	20823c16 	blt	r4,r2,8207b2c <___vfprintf_internal_r+0x1174>
 820723c:	42000204 	addi	r8,r8,8
 8207240:	d8802b17 	ldw	r2,172(sp)
 8207244:	10000c26 	beq	r2,zero,8207278 <___vfprintf_internal_r+0x8c0>
 8207248:	d8801f17 	ldw	r2,124(sp)
 820724c:	d9002704 	addi	r4,sp,156
 8207250:	18c00084 	addi	r3,r3,2
 8207254:	10800044 	addi	r2,r2,1
 8207258:	41000015 	stw	r4,0(r8)
 820725c:	01000084 	movi	r4,2
 8207260:	41000115 	stw	r4,4(r8)
 8207264:	d8c02015 	stw	r3,128(sp)
 8207268:	d8801f15 	stw	r2,124(sp)
 820726c:	010001c4 	movi	r4,7
 8207270:	20823616 	blt	r4,r2,8207b4c <___vfprintf_internal_r+0x1194>
 8207274:	42000204 	addi	r8,r8,8
 8207278:	d9003017 	ldw	r4,192(sp)
 820727c:	00802004 	movi	r2,128
 8207280:	20819926 	beq	r4,r2,82078e8 <___vfprintf_internal_r+0xf30>
 8207284:	d9402917 	ldw	r5,164(sp)
 8207288:	d8802e17 	ldw	r2,184(sp)
 820728c:	28adc83a 	sub	r22,r5,r2
 8207290:	0580310e 	bge	zero,r22,8207358 <___vfprintf_internal_r+0x9a0>
 8207294:	07000404 	movi	fp,16
 8207298:	d8801f17 	ldw	r2,124(sp)
 820729c:	e584140e 	bge	fp,r22,82082f0 <___vfprintf_internal_r+0x1938>
 82072a0:	01420974 	movhi	r5,2085
 82072a4:	2976db84 	addi	r5,r5,-9362
 82072a8:	dc402915 	stw	r17,164(sp)
 82072ac:	d9402b15 	stw	r5,172(sp)
 82072b0:	b023883a 	mov	r17,r22
 82072b4:	04c001c4 	movi	r19,7
 82072b8:	a82d883a 	mov	r22,r21
 82072bc:	902b883a 	mov	r21,r18
 82072c0:	8025883a 	mov	r18,r16
 82072c4:	dc002c17 	ldw	r16,176(sp)
 82072c8:	00000306 	br	82072d8 <___vfprintf_internal_r+0x920>
 82072cc:	8c7ffc04 	addi	r17,r17,-16
 82072d0:	42000204 	addi	r8,r8,8
 82072d4:	e440110e 	bge	fp,r17,820731c <___vfprintf_internal_r+0x964>
 82072d8:	18c00404 	addi	r3,r3,16
 82072dc:	10800044 	addi	r2,r2,1
 82072e0:	45000015 	stw	r20,0(r8)
 82072e4:	47000115 	stw	fp,4(r8)
 82072e8:	d8c02015 	stw	r3,128(sp)
 82072ec:	d8801f15 	stw	r2,124(sp)
 82072f0:	98bff60e 	bge	r19,r2,82072cc <___vfprintf_internal_r+0x914>
 82072f4:	d9801e04 	addi	r6,sp,120
 82072f8:	b80b883a 	mov	r5,r23
 82072fc:	8009883a 	mov	r4,r16
 8207300:	820f50c0 	call	820f50c <__sprint_r>
 8207304:	103eae1e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8207308:	8c7ffc04 	addi	r17,r17,-16
 820730c:	d8c02017 	ldw	r3,128(sp)
 8207310:	d8801f17 	ldw	r2,124(sp)
 8207314:	da000404 	addi	r8,sp,16
 8207318:	e47fef16 	blt	fp,r17,82072d8 <___vfprintf_internal_r+0x920>
 820731c:	9021883a 	mov	r16,r18
 8207320:	a825883a 	mov	r18,r21
 8207324:	b02b883a 	mov	r21,r22
 8207328:	882d883a 	mov	r22,r17
 820732c:	dc402917 	ldw	r17,164(sp)
 8207330:	d9002b17 	ldw	r4,172(sp)
 8207334:	1d87883a 	add	r3,r3,r22
 8207338:	10800044 	addi	r2,r2,1
 820733c:	41000015 	stw	r4,0(r8)
 8207340:	45800115 	stw	r22,4(r8)
 8207344:	d8c02015 	stw	r3,128(sp)
 8207348:	d8801f15 	stw	r2,124(sp)
 820734c:	010001c4 	movi	r4,7
 8207350:	2081ee16 	blt	r4,r2,8207b0c <___vfprintf_internal_r+0x1154>
 8207354:	42000204 	addi	r8,r8,8
 8207358:	9080400c 	andi	r2,r18,256
 820735c:	1001181e 	bne	r2,zero,82077c0 <___vfprintf_internal_r+0xe08>
 8207360:	d9402e17 	ldw	r5,184(sp)
 8207364:	d8801f17 	ldw	r2,124(sp)
 8207368:	44000015 	stw	r16,0(r8)
 820736c:	1947883a 	add	r3,r3,r5
 8207370:	10800044 	addi	r2,r2,1
 8207374:	41400115 	stw	r5,4(r8)
 8207378:	d8c02015 	stw	r3,128(sp)
 820737c:	d8801f15 	stw	r2,124(sp)
 8207380:	010001c4 	movi	r4,7
 8207384:	2081d316 	blt	r4,r2,8207ad4 <___vfprintf_internal_r+0x111c>
 8207388:	42000204 	addi	r8,r8,8
 820738c:	9480010c 	andi	r18,r18,4
 8207390:	90003226 	beq	r18,zero,820745c <___vfprintf_internal_r+0xaa4>
 8207394:	d9403117 	ldw	r5,196(sp)
 8207398:	d8802a17 	ldw	r2,168(sp)
 820739c:	28a1c83a 	sub	r16,r5,r2
 82073a0:	04002e0e 	bge	zero,r16,820745c <___vfprintf_internal_r+0xaa4>
 82073a4:	04400404 	movi	r17,16
 82073a8:	d8801f17 	ldw	r2,124(sp)
 82073ac:	8c04a20e 	bge	r17,r16,8208638 <___vfprintf_internal_r+0x1c80>
 82073b0:	01420974 	movhi	r5,2085
 82073b4:	2976df84 	addi	r5,r5,-9346
 82073b8:	d9403515 	stw	r5,212(sp)
 82073bc:	048001c4 	movi	r18,7
 82073c0:	dcc02c17 	ldw	r19,176(sp)
 82073c4:	00000306 	br	82073d4 <___vfprintf_internal_r+0xa1c>
 82073c8:	843ffc04 	addi	r16,r16,-16
 82073cc:	42000204 	addi	r8,r8,8
 82073d0:	8c00130e 	bge	r17,r16,8207420 <___vfprintf_internal_r+0xa68>
 82073d4:	01020974 	movhi	r4,2085
 82073d8:	18c00404 	addi	r3,r3,16
 82073dc:	10800044 	addi	r2,r2,1
 82073e0:	2136df84 	addi	r4,r4,-9346
 82073e4:	41000015 	stw	r4,0(r8)
 82073e8:	44400115 	stw	r17,4(r8)
 82073ec:	d8c02015 	stw	r3,128(sp)
 82073f0:	d8801f15 	stw	r2,124(sp)
 82073f4:	90bff40e 	bge	r18,r2,82073c8 <___vfprintf_internal_r+0xa10>
 82073f8:	d9801e04 	addi	r6,sp,120
 82073fc:	b80b883a 	mov	r5,r23
 8207400:	9809883a 	mov	r4,r19
 8207404:	820f50c0 	call	820f50c <__sprint_r>
 8207408:	103e6d1e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 820740c:	843ffc04 	addi	r16,r16,-16
 8207410:	d8c02017 	ldw	r3,128(sp)
 8207414:	d8801f17 	ldw	r2,124(sp)
 8207418:	da000404 	addi	r8,sp,16
 820741c:	8c3fed16 	blt	r17,r16,82073d4 <___vfprintf_internal_r+0xa1c>
 8207420:	d9403517 	ldw	r5,212(sp)
 8207424:	1c07883a 	add	r3,r3,r16
 8207428:	10800044 	addi	r2,r2,1
 820742c:	41400015 	stw	r5,0(r8)
 8207430:	44000115 	stw	r16,4(r8)
 8207434:	d8c02015 	stw	r3,128(sp)
 8207438:	d8801f15 	stw	r2,124(sp)
 820743c:	010001c4 	movi	r4,7
 8207440:	2080060e 	bge	r4,r2,820745c <___vfprintf_internal_r+0xaa4>
 8207444:	d9002c17 	ldw	r4,176(sp)
 8207448:	d9801e04 	addi	r6,sp,120
 820744c:	b80b883a 	mov	r5,r23
 8207450:	820f50c0 	call	820f50c <__sprint_r>
 8207454:	103e5a1e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8207458:	d8c02017 	ldw	r3,128(sp)
 820745c:	d8803117 	ldw	r2,196(sp)
 8207460:	d9002a17 	ldw	r4,168(sp)
 8207464:	1100010e 	bge	r2,r4,820746c <___vfprintf_internal_r+0xab4>
 8207468:	2005883a 	mov	r2,r4
 820746c:	d9402f17 	ldw	r5,188(sp)
 8207470:	288b883a 	add	r5,r5,r2
 8207474:	d9402f15 	stw	r5,188(sp)
 8207478:	18019e1e 	bne	r3,zero,8207af4 <___vfprintf_internal_r+0x113c>
 820747c:	a8800007 	ldb	r2,0(r21)
 8207480:	d8001f15 	stw	zero,124(sp)
 8207484:	da000404 	addi	r8,sp,16
 8207488:	103d851e 	bne	r2,zero,8206aa0 <___vfprintf_internal_r+0xe8>
 820748c:	a821883a 	mov	r16,r21
 8207490:	003d9b06 	br	8206b00 <___vfprintf_internal_r+0x148>
 8207494:	18c03fcc 	andi	r3,r3,255
 8207498:	1805c11e 	bne	r3,zero,8208ba0 <___vfprintf_internal_r+0x21e8>
 820749c:	94800414 	ori	r18,r18,16
 82074a0:	9080080c 	andi	r2,r18,32
 82074a4:	10020c26 	beq	r2,zero,8207cd8 <___vfprintf_internal_r+0x1320>
 82074a8:	d8802d17 	ldw	r2,180(sp)
 82074ac:	d9002917 	ldw	r4,164(sp)
 82074b0:	d8002785 	stb	zero,158(sp)
 82074b4:	10c00204 	addi	r3,r2,8
 82074b8:	14c00017 	ldw	r19,0(r2)
 82074bc:	15800117 	ldw	r22,4(r2)
 82074c0:	20040f16 	blt	r4,zero,8208500 <___vfprintf_internal_r+0x1b48>
 82074c4:	013fdfc4 	movi	r4,-129
 82074c8:	9d84b03a 	or	r2,r19,r22
 82074cc:	d8c02d15 	stw	r3,180(sp)
 82074d0:	9124703a 	and	r18,r18,r4
 82074d4:	0039883a 	mov	fp,zero
 82074d8:	103e891e 	bne	r2,zero,8206f00 <___vfprintf_internal_r+0x548>
 82074dc:	d9002917 	ldw	r4,164(sp)
 82074e0:	2002c11e 	bne	r4,zero,8207fe8 <___vfprintf_internal_r+0x1630>
 82074e4:	d8002915 	stw	zero,164(sp)
 82074e8:	d8002e15 	stw	zero,184(sp)
 82074ec:	dc001e04 	addi	r16,sp,120
 82074f0:	003ef806 	br	82070d4 <___vfprintf_internal_r+0x71c>
 82074f4:	18c03fcc 	andi	r3,r3,255
 82074f8:	18059d1e 	bne	r3,zero,8208b70 <___vfprintf_internal_r+0x21b8>
 82074fc:	01420974 	movhi	r5,2085
 8207500:	2976c704 	addi	r5,r5,-9444
 8207504:	d9403915 	stw	r5,228(sp)
 8207508:	9080080c 	andi	r2,r18,32
 820750c:	10005226 	beq	r2,zero,8207658 <___vfprintf_internal_r+0xca0>
 8207510:	d8802d17 	ldw	r2,180(sp)
 8207514:	14c00017 	ldw	r19,0(r2)
 8207518:	15800117 	ldw	r22,4(r2)
 820751c:	10800204 	addi	r2,r2,8
 8207520:	d8802d15 	stw	r2,180(sp)
 8207524:	9080004c 	andi	r2,r18,1
 8207528:	10019026 	beq	r2,zero,8207b6c <___vfprintf_internal_r+0x11b4>
 820752c:	9d84b03a 	or	r2,r19,r22
 8207530:	10036926 	beq	r2,zero,82082d8 <___vfprintf_internal_r+0x1920>
 8207534:	d8c02917 	ldw	r3,164(sp)
 8207538:	00800c04 	movi	r2,48
 820753c:	d8802705 	stb	r2,156(sp)
 8207540:	dc402745 	stb	r17,157(sp)
 8207544:	d8002785 	stb	zero,158(sp)
 8207548:	90800094 	ori	r2,r18,2
 820754c:	18045d16 	blt	r3,zero,82086c4 <___vfprintf_internal_r+0x1d0c>
 8207550:	00bfdfc4 	movi	r2,-129
 8207554:	90a4703a 	and	r18,r18,r2
 8207558:	94800094 	ori	r18,r18,2
 820755c:	0039883a 	mov	fp,zero
 8207560:	d9003917 	ldw	r4,228(sp)
 8207564:	dc001e04 	addi	r16,sp,120
 8207568:	988003cc 	andi	r2,r19,15
 820756c:	b006973a 	slli	r3,r22,28
 8207570:	2085883a 	add	r2,r4,r2
 8207574:	9826d13a 	srli	r19,r19,4
 8207578:	10800003 	ldbu	r2,0(r2)
 820757c:	b02cd13a 	srli	r22,r22,4
 8207580:	843fffc4 	addi	r16,r16,-1
 8207584:	1ce6b03a 	or	r19,r3,r19
 8207588:	80800005 	stb	r2,0(r16)
 820758c:	9d84b03a 	or	r2,r19,r22
 8207590:	103ff51e 	bne	r2,zero,8207568 <___vfprintf_internal_r+0xbb0>
 8207594:	d8c02817 	ldw	r3,160(sp)
 8207598:	1c07c83a 	sub	r3,r3,r16
 820759c:	d8c02e15 	stw	r3,184(sp)
 82075a0:	003ecc06 	br	82070d4 <___vfprintf_internal_r+0x71c>
 82075a4:	18c03fcc 	andi	r3,r3,255
 82075a8:	183e9f26 	beq	r3,zero,8207028 <___vfprintf_internal_r+0x670>
 82075ac:	d9c02785 	stb	r7,158(sp)
 82075b0:	003e9d06 	br	8207028 <___vfprintf_internal_r+0x670>
 82075b4:	00c00044 	movi	r3,1
 82075b8:	01c00ac4 	movi	r7,43
 82075bc:	ac400007 	ldb	r17,0(r21)
 82075c0:	003d5e06 	br	8206b3c <___vfprintf_internal_r+0x184>
 82075c4:	94800814 	ori	r18,r18,32
 82075c8:	ac400007 	ldb	r17,0(r21)
 82075cc:	003d5b06 	br	8206b3c <___vfprintf_internal_r+0x184>
 82075d0:	d8c02d17 	ldw	r3,180(sp)
 82075d4:	d8002785 	stb	zero,158(sp)
 82075d8:	1c000017 	ldw	r16,0(r3)
 82075dc:	1cc00104 	addi	r19,r3,4
 82075e0:	80041926 	beq	r16,zero,8208648 <___vfprintf_internal_r+0x1c90>
 82075e4:	d9002917 	ldw	r4,164(sp)
 82075e8:	2003d016 	blt	r4,zero,820852c <___vfprintf_internal_r+0x1b74>
 82075ec:	200d883a 	mov	r6,r4
 82075f0:	000b883a 	mov	r5,zero
 82075f4:	8009883a 	mov	r4,r16
 82075f8:	da003d15 	stw	r8,244(sp)
 82075fc:	820c4740 	call	820c474 <memchr>
 8207600:	da003d17 	ldw	r8,244(sp)
 8207604:	10045426 	beq	r2,zero,8208758 <___vfprintf_internal_r+0x1da0>
 8207608:	1405c83a 	sub	r2,r2,r16
 820760c:	d8802e15 	stw	r2,184(sp)
 8207610:	1003cc16 	blt	r2,zero,8208544 <___vfprintf_internal_r+0x1b8c>
 8207614:	df002783 	ldbu	fp,158(sp)
 8207618:	d8802a15 	stw	r2,168(sp)
 820761c:	dcc02d15 	stw	r19,180(sp)
 8207620:	d8002915 	stw	zero,164(sp)
 8207624:	d8003215 	stw	zero,200(sp)
 8207628:	003eb006 	br	82070ec <___vfprintf_internal_r+0x734>
 820762c:	18c03fcc 	andi	r3,r3,255
 8207630:	183f9b26 	beq	r3,zero,82074a0 <___vfprintf_internal_r+0xae8>
 8207634:	d9c02785 	stb	r7,158(sp)
 8207638:	003f9906 	br	82074a0 <___vfprintf_internal_r+0xae8>
 820763c:	18c03fcc 	andi	r3,r3,255
 8207640:	1805551e 	bne	r3,zero,8208b98 <___vfprintf_internal_r+0x21e0>
 8207644:	01420974 	movhi	r5,2085
 8207648:	2976cc04 	addi	r5,r5,-9424
 820764c:	d9403915 	stw	r5,228(sp)
 8207650:	9080080c 	andi	r2,r18,32
 8207654:	103fae1e 	bne	r2,zero,8207510 <___vfprintf_internal_r+0xb58>
 8207658:	9080040c 	andi	r2,r18,16
 820765c:	1002de26 	beq	r2,zero,82081d8 <___vfprintf_internal_r+0x1820>
 8207660:	d8c02d17 	ldw	r3,180(sp)
 8207664:	002d883a 	mov	r22,zero
 8207668:	1cc00017 	ldw	r19,0(r3)
 820766c:	18c00104 	addi	r3,r3,4
 8207670:	d8c02d15 	stw	r3,180(sp)
 8207674:	003fab06 	br	8207524 <___vfprintf_internal_r+0xb6c>
 8207678:	38803fcc 	andi	r2,r7,255
 820767c:	1080201c 	xori	r2,r2,128
 8207680:	10bfe004 	addi	r2,r2,-128
 8207684:	1002d21e 	bne	r2,zero,82081d0 <___vfprintf_internal_r+0x1818>
 8207688:	00c00044 	movi	r3,1
 820768c:	01c00804 	movi	r7,32
 8207690:	ac400007 	ldb	r17,0(r21)
 8207694:	003d2906 	br	8206b3c <___vfprintf_internal_r+0x184>
 8207698:	94800054 	ori	r18,r18,1
 820769c:	ac400007 	ldb	r17,0(r21)
 82076a0:	003d2606 	br	8206b3c <___vfprintf_internal_r+0x184>
 82076a4:	18c03fcc 	andi	r3,r3,255
 82076a8:	183e0526 	beq	r3,zero,8206ec0 <___vfprintf_internal_r+0x508>
 82076ac:	d9c02785 	stb	r7,158(sp)
 82076b0:	003e0306 	br	8206ec0 <___vfprintf_internal_r+0x508>
 82076b4:	94801014 	ori	r18,r18,64
 82076b8:	ac400007 	ldb	r17,0(r21)
 82076bc:	003d1f06 	br	8206b3c <___vfprintf_internal_r+0x184>
 82076c0:	ac400007 	ldb	r17,0(r21)
 82076c4:	8a438726 	beq	r17,r9,82084e4 <___vfprintf_internal_r+0x1b2c>
 82076c8:	94800414 	ori	r18,r18,16
 82076cc:	003d1b06 	br	8206b3c <___vfprintf_internal_r+0x184>
 82076d0:	18c03fcc 	andi	r3,r3,255
 82076d4:	1805341e 	bne	r3,zero,8208ba8 <___vfprintf_internal_r+0x21f0>
 82076d8:	9080080c 	andi	r2,r18,32
 82076dc:	1002cd26 	beq	r2,zero,8208214 <___vfprintf_internal_r+0x185c>
 82076e0:	d9402d17 	ldw	r5,180(sp)
 82076e4:	d9002f17 	ldw	r4,188(sp)
 82076e8:	28800017 	ldw	r2,0(r5)
 82076ec:	2007d7fa 	srai	r3,r4,31
 82076f0:	29400104 	addi	r5,r5,4
 82076f4:	d9402d15 	stw	r5,180(sp)
 82076f8:	11000015 	stw	r4,0(r2)
 82076fc:	10c00115 	stw	r3,4(r2)
 8207700:	003ce506 	br	8206a98 <___vfprintf_internal_r+0xe0>
 8207704:	d8c02d17 	ldw	r3,180(sp)
 8207708:	d9002d17 	ldw	r4,180(sp)
 820770c:	d8002785 	stb	zero,158(sp)
 8207710:	18800017 	ldw	r2,0(r3)
 8207714:	21000104 	addi	r4,r4,4
 8207718:	00c00044 	movi	r3,1
 820771c:	d8c02a15 	stw	r3,168(sp)
 8207720:	d8801405 	stb	r2,80(sp)
 8207724:	d9002d15 	stw	r4,180(sp)
 8207728:	d8c02e15 	stw	r3,184(sp)
 820772c:	d8002915 	stw	zero,164(sp)
 8207730:	d8003215 	stw	zero,200(sp)
 8207734:	dc001404 	addi	r16,sp,80
 8207738:	0039883a 	mov	fp,zero
 820773c:	003e7206 	br	8207108 <___vfprintf_internal_r+0x750>
 8207740:	01020974 	movhi	r4,2085
 8207744:	2136cc04 	addi	r4,r4,-9424
 8207748:	0039883a 	mov	fp,zero
 820774c:	d9003915 	stw	r4,228(sp)
 8207750:	04401e04 	movi	r17,120
 8207754:	003f8206 	br	8207560 <___vfprintf_internal_r+0xba8>
 8207758:	18c03fcc 	andi	r3,r3,255
 820775c:	1805061e 	bne	r3,zero,8208b78 <___vfprintf_internal_r+0x21c0>
 8207760:	883d9126 	beq	r17,zero,8206da8 <___vfprintf_internal_r+0x3f0>
 8207764:	00c00044 	movi	r3,1
 8207768:	d8c02a15 	stw	r3,168(sp)
 820776c:	dc401405 	stb	r17,80(sp)
 8207770:	d8002785 	stb	zero,158(sp)
 8207774:	003fec06 	br	8207728 <___vfprintf_internal_r+0xd70>
 8207778:	01420974 	movhi	r5,2085
 820777c:	2976cc04 	addi	r5,r5,-9424
 8207780:	d9403915 	stw	r5,228(sp)
 8207784:	d8c02d15 	stw	r3,180(sp)
 8207788:	1025883a 	mov	r18,r2
 820778c:	04401e04 	movi	r17,120
 8207790:	9d84b03a 	or	r2,r19,r22
 8207794:	1000fc1e 	bne	r2,zero,8207b88 <___vfprintf_internal_r+0x11d0>
 8207798:	0039883a 	mov	fp,zero
 820779c:	00800084 	movi	r2,2
 82077a0:	10803fcc 	andi	r2,r2,255
 82077a4:	00c00044 	movi	r3,1
 82077a8:	10c20f26 	beq	r2,r3,8207fe8 <___vfprintf_internal_r+0x1630>
 82077ac:	00c00084 	movi	r3,2
 82077b0:	10fd6326 	beq	r2,r3,8206d40 <___vfprintf_internal_r+0x388>
 82077b4:	003e2d06 	br	820706c <___vfprintf_internal_r+0x6b4>
 82077b8:	d8c02017 	ldw	r3,128(sp)
 82077bc:	003e9306 	br	820720c <___vfprintf_internal_r+0x854>
 82077c0:	00801944 	movi	r2,101
 82077c4:	14407e0e 	bge	r2,r17,82079c0 <___vfprintf_internal_r+0x1008>
 82077c8:	d9003617 	ldw	r4,216(sp)
 82077cc:	d9403817 	ldw	r5,224(sp)
 82077d0:	000d883a 	mov	r6,zero
 82077d4:	000f883a 	mov	r7,zero
 82077d8:	d8c03c15 	stw	r3,240(sp)
 82077dc:	da003d15 	stw	r8,244(sp)
 82077e0:	8212e780 	call	8212e78 <__eqdf2>
 82077e4:	d8c03c17 	ldw	r3,240(sp)
 82077e8:	da003d17 	ldw	r8,244(sp)
 82077ec:	1000f71e 	bne	r2,zero,8207bcc <___vfprintf_internal_r+0x1214>
 82077f0:	d8801f17 	ldw	r2,124(sp)
 82077f4:	01020974 	movhi	r4,2085
 82077f8:	2136d304 	addi	r4,r4,-9396
 82077fc:	18c00044 	addi	r3,r3,1
 8207800:	10800044 	addi	r2,r2,1
 8207804:	41000015 	stw	r4,0(r8)
 8207808:	01000044 	movi	r4,1
 820780c:	41000115 	stw	r4,4(r8)
 8207810:	d8c02015 	stw	r3,128(sp)
 8207814:	d8801f15 	stw	r2,124(sp)
 8207818:	010001c4 	movi	r4,7
 820781c:	2082b816 	blt	r4,r2,8208300 <___vfprintf_internal_r+0x1948>
 8207820:	42000204 	addi	r8,r8,8
 8207824:	d8802617 	ldw	r2,152(sp)
 8207828:	d9403317 	ldw	r5,204(sp)
 820782c:	11400216 	blt	r2,r5,8207838 <___vfprintf_internal_r+0xe80>
 8207830:	9080004c 	andi	r2,r18,1
 8207834:	103ed526 	beq	r2,zero,820738c <___vfprintf_internal_r+0x9d4>
 8207838:	d8803717 	ldw	r2,220(sp)
 820783c:	d9003417 	ldw	r4,208(sp)
 8207840:	d9403717 	ldw	r5,220(sp)
 8207844:	1887883a 	add	r3,r3,r2
 8207848:	d8801f17 	ldw	r2,124(sp)
 820784c:	41000015 	stw	r4,0(r8)
 8207850:	41400115 	stw	r5,4(r8)
 8207854:	10800044 	addi	r2,r2,1
 8207858:	d8c02015 	stw	r3,128(sp)
 820785c:	d8801f15 	stw	r2,124(sp)
 8207860:	010001c4 	movi	r4,7
 8207864:	20832916 	blt	r4,r2,820850c <___vfprintf_internal_r+0x1b54>
 8207868:	42000204 	addi	r8,r8,8
 820786c:	d8803317 	ldw	r2,204(sp)
 8207870:	143fffc4 	addi	r16,r2,-1
 8207874:	043ec50e 	bge	zero,r16,820738c <___vfprintf_internal_r+0x9d4>
 8207878:	04400404 	movi	r17,16
 820787c:	d8801f17 	ldw	r2,124(sp)
 8207880:	8c00880e 	bge	r17,r16,8207aa4 <___vfprintf_internal_r+0x10ec>
 8207884:	01420974 	movhi	r5,2085
 8207888:	2976db84 	addi	r5,r5,-9362
 820788c:	d9402b15 	stw	r5,172(sp)
 8207890:	058001c4 	movi	r22,7
 8207894:	dcc02c17 	ldw	r19,176(sp)
 8207898:	00000306 	br	82078a8 <___vfprintf_internal_r+0xef0>
 820789c:	42000204 	addi	r8,r8,8
 82078a0:	843ffc04 	addi	r16,r16,-16
 82078a4:	8c00820e 	bge	r17,r16,8207ab0 <___vfprintf_internal_r+0x10f8>
 82078a8:	18c00404 	addi	r3,r3,16
 82078ac:	10800044 	addi	r2,r2,1
 82078b0:	45000015 	stw	r20,0(r8)
 82078b4:	44400115 	stw	r17,4(r8)
 82078b8:	d8c02015 	stw	r3,128(sp)
 82078bc:	d8801f15 	stw	r2,124(sp)
 82078c0:	b0bff60e 	bge	r22,r2,820789c <___vfprintf_internal_r+0xee4>
 82078c4:	d9801e04 	addi	r6,sp,120
 82078c8:	b80b883a 	mov	r5,r23
 82078cc:	9809883a 	mov	r4,r19
 82078d0:	820f50c0 	call	820f50c <__sprint_r>
 82078d4:	103d3a1e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 82078d8:	d8c02017 	ldw	r3,128(sp)
 82078dc:	d8801f17 	ldw	r2,124(sp)
 82078e0:	da000404 	addi	r8,sp,16
 82078e4:	003fee06 	br	82078a0 <___vfprintf_internal_r+0xee8>
 82078e8:	d9403117 	ldw	r5,196(sp)
 82078ec:	d8802a17 	ldw	r2,168(sp)
 82078f0:	28adc83a 	sub	r22,r5,r2
 82078f4:	05be630e 	bge	zero,r22,8207284 <___vfprintf_internal_r+0x8cc>
 82078f8:	07000404 	movi	fp,16
 82078fc:	d8801f17 	ldw	r2,124(sp)
 8207900:	e5838f0e 	bge	fp,r22,8208740 <___vfprintf_internal_r+0x1d88>
 8207904:	01420974 	movhi	r5,2085
 8207908:	2976db84 	addi	r5,r5,-9362
 820790c:	dc403015 	stw	r17,192(sp)
 8207910:	d9402b15 	stw	r5,172(sp)
 8207914:	b023883a 	mov	r17,r22
 8207918:	04c001c4 	movi	r19,7
 820791c:	a82d883a 	mov	r22,r21
 8207920:	902b883a 	mov	r21,r18
 8207924:	8025883a 	mov	r18,r16
 8207928:	dc002c17 	ldw	r16,176(sp)
 820792c:	00000306 	br	820793c <___vfprintf_internal_r+0xf84>
 8207930:	8c7ffc04 	addi	r17,r17,-16
 8207934:	42000204 	addi	r8,r8,8
 8207938:	e440110e 	bge	fp,r17,8207980 <___vfprintf_internal_r+0xfc8>
 820793c:	18c00404 	addi	r3,r3,16
 8207940:	10800044 	addi	r2,r2,1
 8207944:	45000015 	stw	r20,0(r8)
 8207948:	47000115 	stw	fp,4(r8)
 820794c:	d8c02015 	stw	r3,128(sp)
 8207950:	d8801f15 	stw	r2,124(sp)
 8207954:	98bff60e 	bge	r19,r2,8207930 <___vfprintf_internal_r+0xf78>
 8207958:	d9801e04 	addi	r6,sp,120
 820795c:	b80b883a 	mov	r5,r23
 8207960:	8009883a 	mov	r4,r16
 8207964:	820f50c0 	call	820f50c <__sprint_r>
 8207968:	103d151e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 820796c:	8c7ffc04 	addi	r17,r17,-16
 8207970:	d8c02017 	ldw	r3,128(sp)
 8207974:	d8801f17 	ldw	r2,124(sp)
 8207978:	da000404 	addi	r8,sp,16
 820797c:	e47fef16 	blt	fp,r17,820793c <___vfprintf_internal_r+0xf84>
 8207980:	9021883a 	mov	r16,r18
 8207984:	a825883a 	mov	r18,r21
 8207988:	b02b883a 	mov	r21,r22
 820798c:	882d883a 	mov	r22,r17
 8207990:	dc403017 	ldw	r17,192(sp)
 8207994:	d9002b17 	ldw	r4,172(sp)
 8207998:	1d87883a 	add	r3,r3,r22
 820799c:	10800044 	addi	r2,r2,1
 82079a0:	41000015 	stw	r4,0(r8)
 82079a4:	45800115 	stw	r22,4(r8)
 82079a8:	d8c02015 	stw	r3,128(sp)
 82079ac:	d8801f15 	stw	r2,124(sp)
 82079b0:	010001c4 	movi	r4,7
 82079b4:	20818e16 	blt	r4,r2,8207ff0 <___vfprintf_internal_r+0x1638>
 82079b8:	42000204 	addi	r8,r8,8
 82079bc:	003e3106 	br	8207284 <___vfprintf_internal_r+0x8cc>
 82079c0:	d9403317 	ldw	r5,204(sp)
 82079c4:	00800044 	movi	r2,1
 82079c8:	18c00044 	addi	r3,r3,1
 82079cc:	1141530e 	bge	r2,r5,8207f1c <___vfprintf_internal_r+0x1564>
 82079d0:	dc401f17 	ldw	r17,124(sp)
 82079d4:	00800044 	movi	r2,1
 82079d8:	40800115 	stw	r2,4(r8)
 82079dc:	8c400044 	addi	r17,r17,1
 82079e0:	44000015 	stw	r16,0(r8)
 82079e4:	d8c02015 	stw	r3,128(sp)
 82079e8:	dc401f15 	stw	r17,124(sp)
 82079ec:	008001c4 	movi	r2,7
 82079f0:	14416b16 	blt	r2,r17,8207fa0 <___vfprintf_internal_r+0x15e8>
 82079f4:	42000204 	addi	r8,r8,8
 82079f8:	d8803717 	ldw	r2,220(sp)
 82079fc:	d9003417 	ldw	r4,208(sp)
 8207a00:	8c400044 	addi	r17,r17,1
 8207a04:	10c7883a 	add	r3,r2,r3
 8207a08:	40800115 	stw	r2,4(r8)
 8207a0c:	41000015 	stw	r4,0(r8)
 8207a10:	d8c02015 	stw	r3,128(sp)
 8207a14:	dc401f15 	stw	r17,124(sp)
 8207a18:	008001c4 	movi	r2,7
 8207a1c:	14416916 	blt	r2,r17,8207fc4 <___vfprintf_internal_r+0x160c>
 8207a20:	45800204 	addi	r22,r8,8
 8207a24:	d9003617 	ldw	r4,216(sp)
 8207a28:	d9403817 	ldw	r5,224(sp)
 8207a2c:	000d883a 	mov	r6,zero
 8207a30:	000f883a 	mov	r7,zero
 8207a34:	d8c03c15 	stw	r3,240(sp)
 8207a38:	8212e780 	call	8212e78 <__eqdf2>
 8207a3c:	d8c03c17 	ldw	r3,240(sp)
 8207a40:	1000bc26 	beq	r2,zero,8207d34 <___vfprintf_internal_r+0x137c>
 8207a44:	d9403317 	ldw	r5,204(sp)
 8207a48:	84000044 	addi	r16,r16,1
 8207a4c:	8c400044 	addi	r17,r17,1
 8207a50:	28bfffc4 	addi	r2,r5,-1
 8207a54:	1887883a 	add	r3,r3,r2
 8207a58:	b0800115 	stw	r2,4(r22)
 8207a5c:	b4000015 	stw	r16,0(r22)
 8207a60:	d8c02015 	stw	r3,128(sp)
 8207a64:	dc401f15 	stw	r17,124(sp)
 8207a68:	008001c4 	movi	r2,7
 8207a6c:	14414316 	blt	r2,r17,8207f7c <___vfprintf_internal_r+0x15c4>
 8207a70:	b5800204 	addi	r22,r22,8
 8207a74:	d9003a17 	ldw	r4,232(sp)
 8207a78:	df0022c4 	addi	fp,sp,139
 8207a7c:	8c400044 	addi	r17,r17,1
 8207a80:	20c7883a 	add	r3,r4,r3
 8207a84:	b7000015 	stw	fp,0(r22)
 8207a88:	b1000115 	stw	r4,4(r22)
 8207a8c:	d8c02015 	stw	r3,128(sp)
 8207a90:	dc401f15 	stw	r17,124(sp)
 8207a94:	008001c4 	movi	r2,7
 8207a98:	14400e16 	blt	r2,r17,8207ad4 <___vfprintf_internal_r+0x111c>
 8207a9c:	b2000204 	addi	r8,r22,8
 8207aa0:	003e3a06 	br	820738c <___vfprintf_internal_r+0x9d4>
 8207aa4:	01020974 	movhi	r4,2085
 8207aa8:	2136db84 	addi	r4,r4,-9362
 8207aac:	d9002b15 	stw	r4,172(sp)
 8207ab0:	d9002b17 	ldw	r4,172(sp)
 8207ab4:	1c07883a 	add	r3,r3,r16
 8207ab8:	44000115 	stw	r16,4(r8)
 8207abc:	41000015 	stw	r4,0(r8)
 8207ac0:	10800044 	addi	r2,r2,1
 8207ac4:	d8c02015 	stw	r3,128(sp)
 8207ac8:	d8801f15 	stw	r2,124(sp)
 8207acc:	010001c4 	movi	r4,7
 8207ad0:	20be2d0e 	bge	r4,r2,8207388 <___vfprintf_internal_r+0x9d0>
 8207ad4:	d9002c17 	ldw	r4,176(sp)
 8207ad8:	d9801e04 	addi	r6,sp,120
 8207adc:	b80b883a 	mov	r5,r23
 8207ae0:	820f50c0 	call	820f50c <__sprint_r>
 8207ae4:	103cb61e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8207ae8:	d8c02017 	ldw	r3,128(sp)
 8207aec:	da000404 	addi	r8,sp,16
 8207af0:	003e2606 	br	820738c <___vfprintf_internal_r+0x9d4>
 8207af4:	d9002c17 	ldw	r4,176(sp)
 8207af8:	d9801e04 	addi	r6,sp,120
 8207afc:	b80b883a 	mov	r5,r23
 8207b00:	820f50c0 	call	820f50c <__sprint_r>
 8207b04:	103e5d26 	beq	r2,zero,820747c <___vfprintf_internal_r+0xac4>
 8207b08:	003cad06 	br	8206dc0 <___vfprintf_internal_r+0x408>
 8207b0c:	d9002c17 	ldw	r4,176(sp)
 8207b10:	d9801e04 	addi	r6,sp,120
 8207b14:	b80b883a 	mov	r5,r23
 8207b18:	820f50c0 	call	820f50c <__sprint_r>
 8207b1c:	103ca81e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8207b20:	d8c02017 	ldw	r3,128(sp)
 8207b24:	da000404 	addi	r8,sp,16
 8207b28:	003e0b06 	br	8207358 <___vfprintf_internal_r+0x9a0>
 8207b2c:	d9002c17 	ldw	r4,176(sp)
 8207b30:	d9801e04 	addi	r6,sp,120
 8207b34:	b80b883a 	mov	r5,r23
 8207b38:	820f50c0 	call	820f50c <__sprint_r>
 8207b3c:	103ca01e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8207b40:	d8c02017 	ldw	r3,128(sp)
 8207b44:	da000404 	addi	r8,sp,16
 8207b48:	003dbd06 	br	8207240 <___vfprintf_internal_r+0x888>
 8207b4c:	d9002c17 	ldw	r4,176(sp)
 8207b50:	d9801e04 	addi	r6,sp,120
 8207b54:	b80b883a 	mov	r5,r23
 8207b58:	820f50c0 	call	820f50c <__sprint_r>
 8207b5c:	103c981e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8207b60:	d8c02017 	ldw	r3,128(sp)
 8207b64:	da000404 	addi	r8,sp,16
 8207b68:	003dc306 	br	8207278 <___vfprintf_internal_r+0x8c0>
 8207b6c:	d8802917 	ldw	r2,164(sp)
 8207b70:	d8002785 	stb	zero,158(sp)
 8207b74:	103f0616 	blt	r2,zero,8207790 <___vfprintf_internal_r+0xdd8>
 8207b78:	00ffdfc4 	movi	r3,-129
 8207b7c:	9d84b03a 	or	r2,r19,r22
 8207b80:	90e4703a 	and	r18,r18,r3
 8207b84:	103c6b26 	beq	r2,zero,8206d34 <___vfprintf_internal_r+0x37c>
 8207b88:	0039883a 	mov	fp,zero
 8207b8c:	003e7406 	br	8207560 <___vfprintf_internal_r+0xba8>
 8207b90:	9080040c 	andi	r2,r18,16
 8207b94:	1001b326 	beq	r2,zero,8208264 <___vfprintf_internal_r+0x18ac>
 8207b98:	d9002d17 	ldw	r4,180(sp)
 8207b9c:	d9402917 	ldw	r5,164(sp)
 8207ba0:	d8002785 	stb	zero,158(sp)
 8207ba4:	20800104 	addi	r2,r4,4
 8207ba8:	24c00017 	ldw	r19,0(r4)
 8207bac:	002d883a 	mov	r22,zero
 8207bb0:	2801b516 	blt	r5,zero,8208288 <___vfprintf_internal_r+0x18d0>
 8207bb4:	00ffdfc4 	movi	r3,-129
 8207bb8:	d8802d15 	stw	r2,180(sp)
 8207bbc:	90e4703a 	and	r18,r18,r3
 8207bc0:	983d2726 	beq	r19,zero,8207060 <___vfprintf_internal_r+0x6a8>
 8207bc4:	0039883a 	mov	fp,zero
 8207bc8:	003d2a06 	br	8207074 <___vfprintf_internal_r+0x6bc>
 8207bcc:	dc402617 	ldw	r17,152(sp)
 8207bd0:	0441d30e 	bge	zero,r17,8208320 <___vfprintf_internal_r+0x1968>
 8207bd4:	dc403217 	ldw	r17,200(sp)
 8207bd8:	d8803317 	ldw	r2,204(sp)
 8207bdc:	1440010e 	bge	r2,r17,8207be4 <___vfprintf_internal_r+0x122c>
 8207be0:	1023883a 	mov	r17,r2
 8207be4:	04400a0e 	bge	zero,r17,8207c10 <___vfprintf_internal_r+0x1258>
 8207be8:	d8801f17 	ldw	r2,124(sp)
 8207bec:	1c47883a 	add	r3,r3,r17
 8207bf0:	44000015 	stw	r16,0(r8)
 8207bf4:	10800044 	addi	r2,r2,1
 8207bf8:	44400115 	stw	r17,4(r8)
 8207bfc:	d8c02015 	stw	r3,128(sp)
 8207c00:	d8801f15 	stw	r2,124(sp)
 8207c04:	010001c4 	movi	r4,7
 8207c08:	20826516 	blt	r4,r2,82085a0 <___vfprintf_internal_r+0x1be8>
 8207c0c:	42000204 	addi	r8,r8,8
 8207c10:	88026116 	blt	r17,zero,8208598 <___vfprintf_internal_r+0x1be0>
 8207c14:	d9003217 	ldw	r4,200(sp)
 8207c18:	2463c83a 	sub	r17,r4,r17
 8207c1c:	04407b0e 	bge	zero,r17,8207e0c <___vfprintf_internal_r+0x1454>
 8207c20:	05800404 	movi	r22,16
 8207c24:	d8801f17 	ldw	r2,124(sp)
 8207c28:	b4419d0e 	bge	r22,r17,82082a0 <___vfprintf_internal_r+0x18e8>
 8207c2c:	01020974 	movhi	r4,2085
 8207c30:	2136db84 	addi	r4,r4,-9362
 8207c34:	d9002b15 	stw	r4,172(sp)
 8207c38:	070001c4 	movi	fp,7
 8207c3c:	dcc02c17 	ldw	r19,176(sp)
 8207c40:	00000306 	br	8207c50 <___vfprintf_internal_r+0x1298>
 8207c44:	42000204 	addi	r8,r8,8
 8207c48:	8c7ffc04 	addi	r17,r17,-16
 8207c4c:	b441970e 	bge	r22,r17,82082ac <___vfprintf_internal_r+0x18f4>
 8207c50:	18c00404 	addi	r3,r3,16
 8207c54:	10800044 	addi	r2,r2,1
 8207c58:	45000015 	stw	r20,0(r8)
 8207c5c:	45800115 	stw	r22,4(r8)
 8207c60:	d8c02015 	stw	r3,128(sp)
 8207c64:	d8801f15 	stw	r2,124(sp)
 8207c68:	e0bff60e 	bge	fp,r2,8207c44 <___vfprintf_internal_r+0x128c>
 8207c6c:	d9801e04 	addi	r6,sp,120
 8207c70:	b80b883a 	mov	r5,r23
 8207c74:	9809883a 	mov	r4,r19
 8207c78:	820f50c0 	call	820f50c <__sprint_r>
 8207c7c:	103c501e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8207c80:	d8c02017 	ldw	r3,128(sp)
 8207c84:	d8801f17 	ldw	r2,124(sp)
 8207c88:	da000404 	addi	r8,sp,16
 8207c8c:	003fee06 	br	8207c48 <___vfprintf_internal_r+0x1290>
 8207c90:	d9002c17 	ldw	r4,176(sp)
 8207c94:	d9801e04 	addi	r6,sp,120
 8207c98:	b80b883a 	mov	r5,r23
 8207c9c:	820f50c0 	call	820f50c <__sprint_r>
 8207ca0:	103c471e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8207ca4:	d8c02017 	ldw	r3,128(sp)
 8207ca8:	df002787 	ldb	fp,158(sp)
 8207cac:	da000404 	addi	r8,sp,16
 8207cb0:	003d5606 	br	820720c <___vfprintf_internal_r+0x854>
 8207cb4:	9080040c 	andi	r2,r18,16
 8207cb8:	10016126 	beq	r2,zero,8208240 <___vfprintf_internal_r+0x1888>
 8207cbc:	d8802d17 	ldw	r2,180(sp)
 8207cc0:	14c00017 	ldw	r19,0(r2)
 8207cc4:	10800104 	addi	r2,r2,4
 8207cc8:	d8802d15 	stw	r2,180(sp)
 8207ccc:	982dd7fa 	srai	r22,r19,31
 8207cd0:	b005883a 	mov	r2,r22
 8207cd4:	003c8206 	br	8206ee0 <___vfprintf_internal_r+0x528>
 8207cd8:	9080040c 	andi	r2,r18,16
 8207cdc:	10003526 	beq	r2,zero,8207db4 <___vfprintf_internal_r+0x13fc>
 8207ce0:	d9402d17 	ldw	r5,180(sp)
 8207ce4:	d8c02917 	ldw	r3,164(sp)
 8207ce8:	d8002785 	stb	zero,158(sp)
 8207cec:	28800104 	addi	r2,r5,4
 8207cf0:	2cc00017 	ldw	r19,0(r5)
 8207cf4:	002d883a 	mov	r22,zero
 8207cf8:	18003716 	blt	r3,zero,8207dd8 <___vfprintf_internal_r+0x1420>
 8207cfc:	00ffdfc4 	movi	r3,-129
 8207d00:	d8802d15 	stw	r2,180(sp)
 8207d04:	90e4703a 	and	r18,r18,r3
 8207d08:	0039883a 	mov	fp,zero
 8207d0c:	983df326 	beq	r19,zero,82074dc <___vfprintf_internal_r+0xb24>
 8207d10:	00800244 	movi	r2,9
 8207d14:	14fc7b36 	bltu	r2,r19,8206f04 <___vfprintf_internal_r+0x54c>
 8207d18:	d8c02817 	ldw	r3,160(sp)
 8207d1c:	dc001dc4 	addi	r16,sp,119
 8207d20:	9cc00c04 	addi	r19,r19,48
 8207d24:	1c07c83a 	sub	r3,r3,r16
 8207d28:	dcc01dc5 	stb	r19,119(sp)
 8207d2c:	d8c02e15 	stw	r3,184(sp)
 8207d30:	003ce806 	br	82070d4 <___vfprintf_internal_r+0x71c>
 8207d34:	d8803317 	ldw	r2,204(sp)
 8207d38:	143fffc4 	addi	r16,r2,-1
 8207d3c:	043f4d0e 	bge	zero,r16,8207a74 <___vfprintf_internal_r+0x10bc>
 8207d40:	07000404 	movi	fp,16
 8207d44:	e400810e 	bge	fp,r16,8207f4c <___vfprintf_internal_r+0x1594>
 8207d48:	01420974 	movhi	r5,2085
 8207d4c:	2976db84 	addi	r5,r5,-9362
 8207d50:	d9402b15 	stw	r5,172(sp)
 8207d54:	01c001c4 	movi	r7,7
 8207d58:	dcc02c17 	ldw	r19,176(sp)
 8207d5c:	00000306 	br	8207d6c <___vfprintf_internal_r+0x13b4>
 8207d60:	b5800204 	addi	r22,r22,8
 8207d64:	843ffc04 	addi	r16,r16,-16
 8207d68:	e4007b0e 	bge	fp,r16,8207f58 <___vfprintf_internal_r+0x15a0>
 8207d6c:	18c00404 	addi	r3,r3,16
 8207d70:	8c400044 	addi	r17,r17,1
 8207d74:	b5000015 	stw	r20,0(r22)
 8207d78:	b7000115 	stw	fp,4(r22)
 8207d7c:	d8c02015 	stw	r3,128(sp)
 8207d80:	dc401f15 	stw	r17,124(sp)
 8207d84:	3c7ff60e 	bge	r7,r17,8207d60 <___vfprintf_internal_r+0x13a8>
 8207d88:	d9801e04 	addi	r6,sp,120
 8207d8c:	b80b883a 	mov	r5,r23
 8207d90:	9809883a 	mov	r4,r19
 8207d94:	d9c03c15 	stw	r7,240(sp)
 8207d98:	820f50c0 	call	820f50c <__sprint_r>
 8207d9c:	d9c03c17 	ldw	r7,240(sp)
 8207da0:	103c071e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8207da4:	d8c02017 	ldw	r3,128(sp)
 8207da8:	dc401f17 	ldw	r17,124(sp)
 8207dac:	dd800404 	addi	r22,sp,16
 8207db0:	003fec06 	br	8207d64 <___vfprintf_internal_r+0x13ac>
 8207db4:	9080100c 	andi	r2,r18,64
 8207db8:	d8002785 	stb	zero,158(sp)
 8207dbc:	10010e26 	beq	r2,zero,82081f8 <___vfprintf_internal_r+0x1840>
 8207dc0:	d9002d17 	ldw	r4,180(sp)
 8207dc4:	d9402917 	ldw	r5,164(sp)
 8207dc8:	002d883a 	mov	r22,zero
 8207dcc:	20800104 	addi	r2,r4,4
 8207dd0:	24c0000b 	ldhu	r19,0(r4)
 8207dd4:	283fc90e 	bge	r5,zero,8207cfc <___vfprintf_internal_r+0x1344>
 8207dd8:	d8802d15 	stw	r2,180(sp)
 8207ddc:	0039883a 	mov	fp,zero
 8207de0:	9d84b03a 	or	r2,r19,r22
 8207de4:	103c461e 	bne	r2,zero,8206f00 <___vfprintf_internal_r+0x548>
 8207de8:	00800044 	movi	r2,1
 8207dec:	003e6c06 	br	82077a0 <___vfprintf_internal_r+0xde8>
 8207df0:	d9002c17 	ldw	r4,176(sp)
 8207df4:	d9801e04 	addi	r6,sp,120
 8207df8:	b80b883a 	mov	r5,r23
 8207dfc:	820f50c0 	call	820f50c <__sprint_r>
 8207e00:	103bef1e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8207e04:	d8c02017 	ldw	r3,128(sp)
 8207e08:	da000404 	addi	r8,sp,16
 8207e0c:	d9003217 	ldw	r4,200(sp)
 8207e10:	d8802617 	ldw	r2,152(sp)
 8207e14:	d9403317 	ldw	r5,204(sp)
 8207e18:	8123883a 	add	r17,r16,r4
 8207e1c:	11400216 	blt	r2,r5,8207e28 <___vfprintf_internal_r+0x1470>
 8207e20:	9100004c 	andi	r4,r18,1
 8207e24:	20000d26 	beq	r4,zero,8207e5c <___vfprintf_internal_r+0x14a4>
 8207e28:	d9003717 	ldw	r4,220(sp)
 8207e2c:	d9403417 	ldw	r5,208(sp)
 8207e30:	1907883a 	add	r3,r3,r4
 8207e34:	d9001f17 	ldw	r4,124(sp)
 8207e38:	41400015 	stw	r5,0(r8)
 8207e3c:	d9403717 	ldw	r5,220(sp)
 8207e40:	21000044 	addi	r4,r4,1
 8207e44:	d8c02015 	stw	r3,128(sp)
 8207e48:	41400115 	stw	r5,4(r8)
 8207e4c:	d9001f15 	stw	r4,124(sp)
 8207e50:	014001c4 	movi	r5,7
 8207e54:	2901e816 	blt	r5,r4,82085f8 <___vfprintf_internal_r+0x1c40>
 8207e58:	42000204 	addi	r8,r8,8
 8207e5c:	d9003317 	ldw	r4,204(sp)
 8207e60:	8121883a 	add	r16,r16,r4
 8207e64:	2085c83a 	sub	r2,r4,r2
 8207e68:	8461c83a 	sub	r16,r16,r17
 8207e6c:	1400010e 	bge	r2,r16,8207e74 <___vfprintf_internal_r+0x14bc>
 8207e70:	1021883a 	mov	r16,r2
 8207e74:	04000a0e 	bge	zero,r16,8207ea0 <___vfprintf_internal_r+0x14e8>
 8207e78:	d9001f17 	ldw	r4,124(sp)
 8207e7c:	1c07883a 	add	r3,r3,r16
 8207e80:	44400015 	stw	r17,0(r8)
 8207e84:	21000044 	addi	r4,r4,1
 8207e88:	44000115 	stw	r16,4(r8)
 8207e8c:	d8c02015 	stw	r3,128(sp)
 8207e90:	d9001f15 	stw	r4,124(sp)
 8207e94:	014001c4 	movi	r5,7
 8207e98:	2901fb16 	blt	r5,r4,8208688 <___vfprintf_internal_r+0x1cd0>
 8207e9c:	42000204 	addi	r8,r8,8
 8207ea0:	8001f716 	blt	r16,zero,8208680 <___vfprintf_internal_r+0x1cc8>
 8207ea4:	1421c83a 	sub	r16,r2,r16
 8207ea8:	043d380e 	bge	zero,r16,820738c <___vfprintf_internal_r+0x9d4>
 8207eac:	04400404 	movi	r17,16
 8207eb0:	d8801f17 	ldw	r2,124(sp)
 8207eb4:	8c3efb0e 	bge	r17,r16,8207aa4 <___vfprintf_internal_r+0x10ec>
 8207eb8:	01420974 	movhi	r5,2085
 8207ebc:	2976db84 	addi	r5,r5,-9362
 8207ec0:	d9402b15 	stw	r5,172(sp)
 8207ec4:	058001c4 	movi	r22,7
 8207ec8:	dcc02c17 	ldw	r19,176(sp)
 8207ecc:	00000306 	br	8207edc <___vfprintf_internal_r+0x1524>
 8207ed0:	42000204 	addi	r8,r8,8
 8207ed4:	843ffc04 	addi	r16,r16,-16
 8207ed8:	8c3ef50e 	bge	r17,r16,8207ab0 <___vfprintf_internal_r+0x10f8>
 8207edc:	18c00404 	addi	r3,r3,16
 8207ee0:	10800044 	addi	r2,r2,1
 8207ee4:	45000015 	stw	r20,0(r8)
 8207ee8:	44400115 	stw	r17,4(r8)
 8207eec:	d8c02015 	stw	r3,128(sp)
 8207ef0:	d8801f15 	stw	r2,124(sp)
 8207ef4:	b0bff60e 	bge	r22,r2,8207ed0 <___vfprintf_internal_r+0x1518>
 8207ef8:	d9801e04 	addi	r6,sp,120
 8207efc:	b80b883a 	mov	r5,r23
 8207f00:	9809883a 	mov	r4,r19
 8207f04:	820f50c0 	call	820f50c <__sprint_r>
 8207f08:	103bad1e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8207f0c:	d8c02017 	ldw	r3,128(sp)
 8207f10:	d8801f17 	ldw	r2,124(sp)
 8207f14:	da000404 	addi	r8,sp,16
 8207f18:	003fee06 	br	8207ed4 <___vfprintf_internal_r+0x151c>
 8207f1c:	9088703a 	and	r4,r18,r2
 8207f20:	203eab1e 	bne	r4,zero,82079d0 <___vfprintf_internal_r+0x1018>
 8207f24:	dc401f17 	ldw	r17,124(sp)
 8207f28:	40800115 	stw	r2,4(r8)
 8207f2c:	44000015 	stw	r16,0(r8)
 8207f30:	8c400044 	addi	r17,r17,1
 8207f34:	d8c02015 	stw	r3,128(sp)
 8207f38:	dc401f15 	stw	r17,124(sp)
 8207f3c:	008001c4 	movi	r2,7
 8207f40:	14400e16 	blt	r2,r17,8207f7c <___vfprintf_internal_r+0x15c4>
 8207f44:	45800204 	addi	r22,r8,8
 8207f48:	003eca06 	br	8207a74 <___vfprintf_internal_r+0x10bc>
 8207f4c:	01020974 	movhi	r4,2085
 8207f50:	2136db84 	addi	r4,r4,-9362
 8207f54:	d9002b15 	stw	r4,172(sp)
 8207f58:	d8802b17 	ldw	r2,172(sp)
 8207f5c:	1c07883a 	add	r3,r3,r16
 8207f60:	8c400044 	addi	r17,r17,1
 8207f64:	b0800015 	stw	r2,0(r22)
 8207f68:	b4000115 	stw	r16,4(r22)
 8207f6c:	d8c02015 	stw	r3,128(sp)
 8207f70:	dc401f15 	stw	r17,124(sp)
 8207f74:	008001c4 	movi	r2,7
 8207f78:	147ebd0e 	bge	r2,r17,8207a70 <___vfprintf_internal_r+0x10b8>
 8207f7c:	d9002c17 	ldw	r4,176(sp)
 8207f80:	d9801e04 	addi	r6,sp,120
 8207f84:	b80b883a 	mov	r5,r23
 8207f88:	820f50c0 	call	820f50c <__sprint_r>
 8207f8c:	103b8c1e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8207f90:	d8c02017 	ldw	r3,128(sp)
 8207f94:	dc401f17 	ldw	r17,124(sp)
 8207f98:	dd800404 	addi	r22,sp,16
 8207f9c:	003eb506 	br	8207a74 <___vfprintf_internal_r+0x10bc>
 8207fa0:	d9002c17 	ldw	r4,176(sp)
 8207fa4:	d9801e04 	addi	r6,sp,120
 8207fa8:	b80b883a 	mov	r5,r23
 8207fac:	820f50c0 	call	820f50c <__sprint_r>
 8207fb0:	103b831e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8207fb4:	d8c02017 	ldw	r3,128(sp)
 8207fb8:	dc401f17 	ldw	r17,124(sp)
 8207fbc:	da000404 	addi	r8,sp,16
 8207fc0:	003e8d06 	br	82079f8 <___vfprintf_internal_r+0x1040>
 8207fc4:	d9002c17 	ldw	r4,176(sp)
 8207fc8:	d9801e04 	addi	r6,sp,120
 8207fcc:	b80b883a 	mov	r5,r23
 8207fd0:	820f50c0 	call	820f50c <__sprint_r>
 8207fd4:	103b7a1e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8207fd8:	d8c02017 	ldw	r3,128(sp)
 8207fdc:	dc401f17 	ldw	r17,124(sp)
 8207fe0:	dd800404 	addi	r22,sp,16
 8207fe4:	003e8f06 	br	8207a24 <___vfprintf_internal_r+0x106c>
 8207fe8:	0027883a 	mov	r19,zero
 8207fec:	003f4a06 	br	8207d18 <___vfprintf_internal_r+0x1360>
 8207ff0:	d9002c17 	ldw	r4,176(sp)
 8207ff4:	d9801e04 	addi	r6,sp,120
 8207ff8:	b80b883a 	mov	r5,r23
 8207ffc:	820f50c0 	call	820f50c <__sprint_r>
 8208000:	103b6f1e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8208004:	d8c02017 	ldw	r3,128(sp)
 8208008:	da000404 	addi	r8,sp,16
 820800c:	003c9d06 	br	8207284 <___vfprintf_internal_r+0x8cc>
 8208010:	04e7c83a 	sub	r19,zero,r19
 8208014:	9804c03a 	cmpne	r2,r19,zero
 8208018:	05adc83a 	sub	r22,zero,r22
 820801c:	b0adc83a 	sub	r22,r22,r2
 8208020:	d8802917 	ldw	r2,164(sp)
 8208024:	07000b44 	movi	fp,45
 8208028:	df002785 	stb	fp,158(sp)
 820802c:	10017b16 	blt	r2,zero,820861c <___vfprintf_internal_r+0x1c64>
 8208030:	00bfdfc4 	movi	r2,-129
 8208034:	90a4703a 	and	r18,r18,r2
 8208038:	003bb106 	br	8206f00 <___vfprintf_internal_r+0x548>
 820803c:	d9003617 	ldw	r4,216(sp)
 8208040:	d9403817 	ldw	r5,224(sp)
 8208044:	da003d15 	stw	r8,244(sp)
 8208048:	820dd240 	call	820dd24 <__fpclassifyd>
 820804c:	da003d17 	ldw	r8,244(sp)
 8208050:	1000f026 	beq	r2,zero,8208414 <___vfprintf_internal_r+0x1a5c>
 8208054:	d9002917 	ldw	r4,164(sp)
 8208058:	05bff7c4 	movi	r22,-33
 820805c:	00bfffc4 	movi	r2,-1
 8208060:	8dac703a 	and	r22,r17,r22
 8208064:	20820026 	beq	r4,r2,8208868 <___vfprintf_internal_r+0x1eb0>
 8208068:	008011c4 	movi	r2,71
 820806c:	b081f726 	beq	r22,r2,820884c <___vfprintf_internal_r+0x1e94>
 8208070:	d9003817 	ldw	r4,224(sp)
 8208074:	90c04014 	ori	r3,r18,256
 8208078:	d8c02b15 	stw	r3,172(sp)
 820807c:	20021516 	blt	r4,zero,82088d4 <___vfprintf_internal_r+0x1f1c>
 8208080:	dcc03817 	ldw	r19,224(sp)
 8208084:	d8002a05 	stb	zero,168(sp)
 8208088:	00801984 	movi	r2,102
 820808c:	8881f926 	beq	r17,r2,8208874 <___vfprintf_internal_r+0x1ebc>
 8208090:	00801184 	movi	r2,70
 8208094:	88821c26 	beq	r17,r2,8208908 <___vfprintf_internal_r+0x1f50>
 8208098:	00801144 	movi	r2,69
 820809c:	b081ef26 	beq	r22,r2,820885c <___vfprintf_internal_r+0x1ea4>
 82080a0:	d8c02917 	ldw	r3,164(sp)
 82080a4:	d8802104 	addi	r2,sp,132
 82080a8:	d8800315 	stw	r2,12(sp)
 82080ac:	d9403617 	ldw	r5,216(sp)
 82080b0:	d8802504 	addi	r2,sp,148
 82080b4:	d9002c17 	ldw	r4,176(sp)
 82080b8:	d8800215 	stw	r2,8(sp)
 82080bc:	d8802604 	addi	r2,sp,152
 82080c0:	d8c00015 	stw	r3,0(sp)
 82080c4:	d8800115 	stw	r2,4(sp)
 82080c8:	01c00084 	movi	r7,2
 82080cc:	980d883a 	mov	r6,r19
 82080d0:	d8c03c15 	stw	r3,240(sp)
 82080d4:	da003d15 	stw	r8,244(sp)
 82080d8:	82091340 	call	8209134 <_dtoa_r>
 82080dc:	1021883a 	mov	r16,r2
 82080e0:	008019c4 	movi	r2,103
 82080e4:	d8c03c17 	ldw	r3,240(sp)
 82080e8:	da003d17 	ldw	r8,244(sp)
 82080ec:	88817126 	beq	r17,r2,82086b4 <___vfprintf_internal_r+0x1cfc>
 82080f0:	008011c4 	movi	r2,71
 82080f4:	88829226 	beq	r17,r2,8208b40 <___vfprintf_internal_r+0x2188>
 82080f8:	80f9883a 	add	fp,r16,r3
 82080fc:	d9003617 	ldw	r4,216(sp)
 8208100:	000d883a 	mov	r6,zero
 8208104:	000f883a 	mov	r7,zero
 8208108:	980b883a 	mov	r5,r19
 820810c:	da003d15 	stw	r8,244(sp)
 8208110:	8212e780 	call	8212e78 <__eqdf2>
 8208114:	da003d17 	ldw	r8,244(sp)
 8208118:	10018d26 	beq	r2,zero,8208750 <___vfprintf_internal_r+0x1d98>
 820811c:	d8802117 	ldw	r2,132(sp)
 8208120:	1700062e 	bgeu	r2,fp,820813c <___vfprintf_internal_r+0x1784>
 8208124:	01000c04 	movi	r4,48
 8208128:	10c00044 	addi	r3,r2,1
 820812c:	d8c02115 	stw	r3,132(sp)
 8208130:	11000005 	stb	r4,0(r2)
 8208134:	d8802117 	ldw	r2,132(sp)
 8208138:	173ffb36 	bltu	r2,fp,8208128 <___vfprintf_internal_r+0x1770>
 820813c:	1405c83a 	sub	r2,r2,r16
 8208140:	d8803315 	stw	r2,204(sp)
 8208144:	008011c4 	movi	r2,71
 8208148:	b0817626 	beq	r22,r2,8208724 <___vfprintf_internal_r+0x1d6c>
 820814c:	00801944 	movi	r2,101
 8208150:	1442810e 	bge	r2,r17,8208b58 <___vfprintf_internal_r+0x21a0>
 8208154:	d8c02617 	ldw	r3,152(sp)
 8208158:	00801984 	movi	r2,102
 820815c:	d8c03215 	stw	r3,200(sp)
 8208160:	8881fe26 	beq	r17,r2,820895c <___vfprintf_internal_r+0x1fa4>
 8208164:	d8c03217 	ldw	r3,200(sp)
 8208168:	d9003317 	ldw	r4,204(sp)
 820816c:	1901dd16 	blt	r3,r4,82088e4 <___vfprintf_internal_r+0x1f2c>
 8208170:	9480004c 	andi	r18,r18,1
 8208174:	90022b1e 	bne	r18,zero,8208a24 <___vfprintf_internal_r+0x206c>
 8208178:	1805883a 	mov	r2,r3
 820817c:	18028016 	blt	r3,zero,8208b80 <___vfprintf_internal_r+0x21c8>
 8208180:	d8c03217 	ldw	r3,200(sp)
 8208184:	044019c4 	movi	r17,103
 8208188:	d8c02e15 	stw	r3,184(sp)
 820818c:	df002a07 	ldb	fp,168(sp)
 8208190:	e001531e 	bne	fp,zero,82086e0 <___vfprintf_internal_r+0x1d28>
 8208194:	df002783 	ldbu	fp,158(sp)
 8208198:	d8802a15 	stw	r2,168(sp)
 820819c:	dc802b17 	ldw	r18,172(sp)
 82081a0:	d8002915 	stw	zero,164(sp)
 82081a4:	003bd106 	br	82070ec <___vfprintf_internal_r+0x734>
 82081a8:	d8802d17 	ldw	r2,180(sp)
 82081ac:	d8c02d17 	ldw	r3,180(sp)
 82081b0:	d9002d17 	ldw	r4,180(sp)
 82081b4:	10800017 	ldw	r2,0(r2)
 82081b8:	18c00117 	ldw	r3,4(r3)
 82081bc:	21000204 	addi	r4,r4,8
 82081c0:	d8803615 	stw	r2,216(sp)
 82081c4:	d8c03815 	stw	r3,224(sp)
 82081c8:	d9002d15 	stw	r4,180(sp)
 82081cc:	003b7506 	br	8206fa4 <___vfprintf_internal_r+0x5ec>
 82081d0:	ac400007 	ldb	r17,0(r21)
 82081d4:	003a5906 	br	8206b3c <___vfprintf_internal_r+0x184>
 82081d8:	9080100c 	andi	r2,r18,64
 82081dc:	1000a826 	beq	r2,zero,8208480 <___vfprintf_internal_r+0x1ac8>
 82081e0:	d9002d17 	ldw	r4,180(sp)
 82081e4:	002d883a 	mov	r22,zero
 82081e8:	24c0000b 	ldhu	r19,0(r4)
 82081ec:	21000104 	addi	r4,r4,4
 82081f0:	d9002d15 	stw	r4,180(sp)
 82081f4:	003ccb06 	br	8207524 <___vfprintf_internal_r+0xb6c>
 82081f8:	d8c02d17 	ldw	r3,180(sp)
 82081fc:	d9002917 	ldw	r4,164(sp)
 8208200:	002d883a 	mov	r22,zero
 8208204:	18800104 	addi	r2,r3,4
 8208208:	1cc00017 	ldw	r19,0(r3)
 820820c:	203ebb0e 	bge	r4,zero,8207cfc <___vfprintf_internal_r+0x1344>
 8208210:	003ef106 	br	8207dd8 <___vfprintf_internal_r+0x1420>
 8208214:	9080040c 	andi	r2,r18,16
 8208218:	1000921e 	bne	r2,zero,8208464 <___vfprintf_internal_r+0x1aac>
 820821c:	9480100c 	andi	r18,r18,64
 8208220:	90013926 	beq	r18,zero,8208708 <___vfprintf_internal_r+0x1d50>
 8208224:	d9002d17 	ldw	r4,180(sp)
 8208228:	d9402f17 	ldw	r5,188(sp)
 820822c:	20800017 	ldw	r2,0(r4)
 8208230:	21000104 	addi	r4,r4,4
 8208234:	d9002d15 	stw	r4,180(sp)
 8208238:	1140000d 	sth	r5,0(r2)
 820823c:	003a1606 	br	8206a98 <___vfprintf_internal_r+0xe0>
 8208240:	9080100c 	andi	r2,r18,64
 8208244:	10008026 	beq	r2,zero,8208448 <___vfprintf_internal_r+0x1a90>
 8208248:	d8c02d17 	ldw	r3,180(sp)
 820824c:	1cc0000f 	ldh	r19,0(r3)
 8208250:	18c00104 	addi	r3,r3,4
 8208254:	d8c02d15 	stw	r3,180(sp)
 8208258:	982dd7fa 	srai	r22,r19,31
 820825c:	b005883a 	mov	r2,r22
 8208260:	003b1f06 	br	8206ee0 <___vfprintf_internal_r+0x528>
 8208264:	9080100c 	andi	r2,r18,64
 8208268:	d8002785 	stb	zero,158(sp)
 820826c:	10008a1e 	bne	r2,zero,8208498 <___vfprintf_internal_r+0x1ae0>
 8208270:	d9402d17 	ldw	r5,180(sp)
 8208274:	d8c02917 	ldw	r3,164(sp)
 8208278:	002d883a 	mov	r22,zero
 820827c:	28800104 	addi	r2,r5,4
 8208280:	2cc00017 	ldw	r19,0(r5)
 8208284:	183e4b0e 	bge	r3,zero,8207bb4 <___vfprintf_internal_r+0x11fc>
 8208288:	9d86b03a 	or	r3,r19,r22
 820828c:	d8802d15 	stw	r2,180(sp)
 8208290:	183e4c1e 	bne	r3,zero,8207bc4 <___vfprintf_internal_r+0x120c>
 8208294:	0039883a 	mov	fp,zero
 8208298:	0005883a 	mov	r2,zero
 820829c:	003d4006 	br	82077a0 <___vfprintf_internal_r+0xde8>
 82082a0:	01420974 	movhi	r5,2085
 82082a4:	2976db84 	addi	r5,r5,-9362
 82082a8:	d9402b15 	stw	r5,172(sp)
 82082ac:	d9402b17 	ldw	r5,172(sp)
 82082b0:	1c47883a 	add	r3,r3,r17
 82082b4:	10800044 	addi	r2,r2,1
 82082b8:	41400015 	stw	r5,0(r8)
 82082bc:	44400115 	stw	r17,4(r8)
 82082c0:	d8c02015 	stw	r3,128(sp)
 82082c4:	d8801f15 	stw	r2,124(sp)
 82082c8:	010001c4 	movi	r4,7
 82082cc:	20bec816 	blt	r4,r2,8207df0 <___vfprintf_internal_r+0x1438>
 82082d0:	42000204 	addi	r8,r8,8
 82082d4:	003ecd06 	br	8207e0c <___vfprintf_internal_r+0x1454>
 82082d8:	d9002917 	ldw	r4,164(sp)
 82082dc:	d8002785 	stb	zero,158(sp)
 82082e0:	203d2d16 	blt	r4,zero,8207798 <___vfprintf_internal_r+0xde0>
 82082e4:	00bfdfc4 	movi	r2,-129
 82082e8:	90a4703a 	and	r18,r18,r2
 82082ec:	003a9106 	br	8206d34 <___vfprintf_internal_r+0x37c>
 82082f0:	01020974 	movhi	r4,2085
 82082f4:	2136db84 	addi	r4,r4,-9362
 82082f8:	d9002b15 	stw	r4,172(sp)
 82082fc:	003c0c06 	br	8207330 <___vfprintf_internal_r+0x978>
 8208300:	d9002c17 	ldw	r4,176(sp)
 8208304:	d9801e04 	addi	r6,sp,120
 8208308:	b80b883a 	mov	r5,r23
 820830c:	820f50c0 	call	820f50c <__sprint_r>
 8208310:	103aab1e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8208314:	d8c02017 	ldw	r3,128(sp)
 8208318:	da000404 	addi	r8,sp,16
 820831c:	003d4106 	br	8207824 <___vfprintf_internal_r+0xe6c>
 8208320:	d8801f17 	ldw	r2,124(sp)
 8208324:	01420974 	movhi	r5,2085
 8208328:	01000044 	movi	r4,1
 820832c:	18c00044 	addi	r3,r3,1
 8208330:	10800044 	addi	r2,r2,1
 8208334:	2976d304 	addi	r5,r5,-9396
 8208338:	41000115 	stw	r4,4(r8)
 820833c:	41400015 	stw	r5,0(r8)
 8208340:	d8c02015 	stw	r3,128(sp)
 8208344:	d8801f15 	stw	r2,124(sp)
 8208348:	010001c4 	movi	r4,7
 820834c:	20805c16 	blt	r4,r2,82084c0 <___vfprintf_internal_r+0x1b08>
 8208350:	42000204 	addi	r8,r8,8
 8208354:	8800041e 	bne	r17,zero,8208368 <___vfprintf_internal_r+0x19b0>
 8208358:	d8803317 	ldw	r2,204(sp)
 820835c:	1000021e 	bne	r2,zero,8208368 <___vfprintf_internal_r+0x19b0>
 8208360:	9080004c 	andi	r2,r18,1
 8208364:	103c0926 	beq	r2,zero,820738c <___vfprintf_internal_r+0x9d4>
 8208368:	d9003717 	ldw	r4,220(sp)
 820836c:	d8801f17 	ldw	r2,124(sp)
 8208370:	d9403417 	ldw	r5,208(sp)
 8208374:	20c7883a 	add	r3,r4,r3
 8208378:	10800044 	addi	r2,r2,1
 820837c:	41000115 	stw	r4,4(r8)
 8208380:	41400015 	stw	r5,0(r8)
 8208384:	d8c02015 	stw	r3,128(sp)
 8208388:	d8801f15 	stw	r2,124(sp)
 820838c:	010001c4 	movi	r4,7
 8208390:	20812116 	blt	r4,r2,8208818 <___vfprintf_internal_r+0x1e60>
 8208394:	42000204 	addi	r8,r8,8
 8208398:	0463c83a 	sub	r17,zero,r17
 820839c:	0440730e 	bge	zero,r17,820856c <___vfprintf_internal_r+0x1bb4>
 82083a0:	05800404 	movi	r22,16
 82083a4:	b440860e 	bge	r22,r17,82085c0 <___vfprintf_internal_r+0x1c08>
 82083a8:	01420974 	movhi	r5,2085
 82083ac:	2976db84 	addi	r5,r5,-9362
 82083b0:	d9402b15 	stw	r5,172(sp)
 82083b4:	070001c4 	movi	fp,7
 82083b8:	dcc02c17 	ldw	r19,176(sp)
 82083bc:	00000306 	br	82083cc <___vfprintf_internal_r+0x1a14>
 82083c0:	42000204 	addi	r8,r8,8
 82083c4:	8c7ffc04 	addi	r17,r17,-16
 82083c8:	b440800e 	bge	r22,r17,82085cc <___vfprintf_internal_r+0x1c14>
 82083cc:	18c00404 	addi	r3,r3,16
 82083d0:	10800044 	addi	r2,r2,1
 82083d4:	45000015 	stw	r20,0(r8)
 82083d8:	45800115 	stw	r22,4(r8)
 82083dc:	d8c02015 	stw	r3,128(sp)
 82083e0:	d8801f15 	stw	r2,124(sp)
 82083e4:	e0bff60e 	bge	fp,r2,82083c0 <___vfprintf_internal_r+0x1a08>
 82083e8:	d9801e04 	addi	r6,sp,120
 82083ec:	b80b883a 	mov	r5,r23
 82083f0:	9809883a 	mov	r4,r19
 82083f4:	820f50c0 	call	820f50c <__sprint_r>
 82083f8:	103a711e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 82083fc:	d8c02017 	ldw	r3,128(sp)
 8208400:	d8801f17 	ldw	r2,124(sp)
 8208404:	da000404 	addi	r8,sp,16
 8208408:	003fee06 	br	82083c4 <___vfprintf_internal_r+0x1a0c>
 820840c:	00bfffc4 	movi	r2,-1
 8208410:	003a6f06 	br	8206dd0 <___vfprintf_internal_r+0x418>
 8208414:	008011c4 	movi	r2,71
 8208418:	1440b816 	blt	r2,r17,82086fc <___vfprintf_internal_r+0x1d44>
 820841c:	04020974 	movhi	r16,2085
 8208420:	8436c504 	addi	r16,r16,-9452
 8208424:	00c000c4 	movi	r3,3
 8208428:	00bfdfc4 	movi	r2,-129
 820842c:	d8c02a15 	stw	r3,168(sp)
 8208430:	90a4703a 	and	r18,r18,r2
 8208434:	df002783 	ldbu	fp,158(sp)
 8208438:	d8c02e15 	stw	r3,184(sp)
 820843c:	d8002915 	stw	zero,164(sp)
 8208440:	d8003215 	stw	zero,200(sp)
 8208444:	003b2906 	br	82070ec <___vfprintf_internal_r+0x734>
 8208448:	d9002d17 	ldw	r4,180(sp)
 820844c:	24c00017 	ldw	r19,0(r4)
 8208450:	21000104 	addi	r4,r4,4
 8208454:	d9002d15 	stw	r4,180(sp)
 8208458:	982dd7fa 	srai	r22,r19,31
 820845c:	b005883a 	mov	r2,r22
 8208460:	003a9f06 	br	8206ee0 <___vfprintf_internal_r+0x528>
 8208464:	d9402d17 	ldw	r5,180(sp)
 8208468:	d8c02f17 	ldw	r3,188(sp)
 820846c:	28800017 	ldw	r2,0(r5)
 8208470:	29400104 	addi	r5,r5,4
 8208474:	d9402d15 	stw	r5,180(sp)
 8208478:	10c00015 	stw	r3,0(r2)
 820847c:	00398606 	br	8206a98 <___vfprintf_internal_r+0xe0>
 8208480:	d9402d17 	ldw	r5,180(sp)
 8208484:	002d883a 	mov	r22,zero
 8208488:	2cc00017 	ldw	r19,0(r5)
 820848c:	29400104 	addi	r5,r5,4
 8208490:	d9402d15 	stw	r5,180(sp)
 8208494:	003c2306 	br	8207524 <___vfprintf_internal_r+0xb6c>
 8208498:	d8c02d17 	ldw	r3,180(sp)
 820849c:	d9002917 	ldw	r4,164(sp)
 82084a0:	002d883a 	mov	r22,zero
 82084a4:	18800104 	addi	r2,r3,4
 82084a8:	1cc0000b 	ldhu	r19,0(r3)
 82084ac:	203dc10e 	bge	r4,zero,8207bb4 <___vfprintf_internal_r+0x11fc>
 82084b0:	003f7506 	br	8208288 <___vfprintf_internal_r+0x18d0>
 82084b4:	04020974 	movhi	r16,2085
 82084b8:	8436c304 	addi	r16,r16,-9460
 82084bc:	003acc06 	br	8206ff0 <___vfprintf_internal_r+0x638>
 82084c0:	d9002c17 	ldw	r4,176(sp)
 82084c4:	d9801e04 	addi	r6,sp,120
 82084c8:	b80b883a 	mov	r5,r23
 82084cc:	820f50c0 	call	820f50c <__sprint_r>
 82084d0:	103a3b1e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 82084d4:	dc402617 	ldw	r17,152(sp)
 82084d8:	d8c02017 	ldw	r3,128(sp)
 82084dc:	da000404 	addi	r8,sp,16
 82084e0:	003f9c06 	br	8208354 <___vfprintf_internal_r+0x199c>
 82084e4:	ac400043 	ldbu	r17,1(r21)
 82084e8:	94800814 	ori	r18,r18,32
 82084ec:	ad400044 	addi	r21,r21,1
 82084f0:	8c403fcc 	andi	r17,r17,255
 82084f4:	8c40201c 	xori	r17,r17,128
 82084f8:	8c7fe004 	addi	r17,r17,-128
 82084fc:	00398f06 	br	8206b3c <___vfprintf_internal_r+0x184>
 8208500:	d8c02d15 	stw	r3,180(sp)
 8208504:	0039883a 	mov	fp,zero
 8208508:	003e3506 	br	8207de0 <___vfprintf_internal_r+0x1428>
 820850c:	d9002c17 	ldw	r4,176(sp)
 8208510:	d9801e04 	addi	r6,sp,120
 8208514:	b80b883a 	mov	r5,r23
 8208518:	820f50c0 	call	820f50c <__sprint_r>
 820851c:	103a281e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8208520:	d8c02017 	ldw	r3,128(sp)
 8208524:	da000404 	addi	r8,sp,16
 8208528:	003cd006 	br	820786c <___vfprintf_internal_r+0xeb4>
 820852c:	8009883a 	mov	r4,r16
 8208530:	da003d15 	stw	r8,244(sp)
 8208534:	8203edc0 	call	8203edc <strlen>
 8208538:	d8802e15 	stw	r2,184(sp)
 820853c:	da003d17 	ldw	r8,244(sp)
 8208540:	103c340e 	bge	r2,zero,8207614 <___vfprintf_internal_r+0xc5c>
 8208544:	0005883a 	mov	r2,zero
 8208548:	003c3206 	br	8207614 <___vfprintf_internal_r+0xc5c>
 820854c:	d9002c17 	ldw	r4,176(sp)
 8208550:	d9801e04 	addi	r6,sp,120
 8208554:	b80b883a 	mov	r5,r23
 8208558:	820f50c0 	call	820f50c <__sprint_r>
 820855c:	103a181e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 8208560:	d8c02017 	ldw	r3,128(sp)
 8208564:	d8801f17 	ldw	r2,124(sp)
 8208568:	da000404 	addi	r8,sp,16
 820856c:	d9403317 	ldw	r5,204(sp)
 8208570:	10800044 	addi	r2,r2,1
 8208574:	44000015 	stw	r16,0(r8)
 8208578:	28c7883a 	add	r3,r5,r3
 820857c:	003b7d06 	br	8207374 <___vfprintf_internal_r+0x9bc>
 8208580:	01020974 	movhi	r4,2085
 8208584:	2136df84 	addi	r4,r4,-9346
 8208588:	d9003515 	stw	r4,212(sp)
 820858c:	003b1406 	br	82071e0 <___vfprintf_internal_r+0x828>
 8208590:	013fffc4 	movi	r4,-1
 8208594:	003a3506 	br	8206e6c <___vfprintf_internal_r+0x4b4>
 8208598:	0023883a 	mov	r17,zero
 820859c:	003d9d06 	br	8207c14 <___vfprintf_internal_r+0x125c>
 82085a0:	d9002c17 	ldw	r4,176(sp)
 82085a4:	d9801e04 	addi	r6,sp,120
 82085a8:	b80b883a 	mov	r5,r23
 82085ac:	820f50c0 	call	820f50c <__sprint_r>
 82085b0:	103a031e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 82085b4:	d8c02017 	ldw	r3,128(sp)
 82085b8:	da000404 	addi	r8,sp,16
 82085bc:	003d9406 	br	8207c10 <___vfprintf_internal_r+0x1258>
 82085c0:	01020974 	movhi	r4,2085
 82085c4:	2136db84 	addi	r4,r4,-9362
 82085c8:	d9002b15 	stw	r4,172(sp)
 82085cc:	d9002b17 	ldw	r4,172(sp)
 82085d0:	1c47883a 	add	r3,r3,r17
 82085d4:	10800044 	addi	r2,r2,1
 82085d8:	41000015 	stw	r4,0(r8)
 82085dc:	44400115 	stw	r17,4(r8)
 82085e0:	d8c02015 	stw	r3,128(sp)
 82085e4:	d8801f15 	stw	r2,124(sp)
 82085e8:	010001c4 	movi	r4,7
 82085ec:	20bfd716 	blt	r4,r2,820854c <___vfprintf_internal_r+0x1b94>
 82085f0:	42000204 	addi	r8,r8,8
 82085f4:	003fdd06 	br	820856c <___vfprintf_internal_r+0x1bb4>
 82085f8:	d9002c17 	ldw	r4,176(sp)
 82085fc:	d9801e04 	addi	r6,sp,120
 8208600:	b80b883a 	mov	r5,r23
 8208604:	820f50c0 	call	820f50c <__sprint_r>
 8208608:	1039ed1e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 820860c:	d8802617 	ldw	r2,152(sp)
 8208610:	d8c02017 	ldw	r3,128(sp)
 8208614:	da000404 	addi	r8,sp,16
 8208618:	003e1006 	br	8207e5c <___vfprintf_internal_r+0x14a4>
 820861c:	00800044 	movi	r2,1
 8208620:	10803fcc 	andi	r2,r2,255
 8208624:	00c00044 	movi	r3,1
 8208628:	10fa3526 	beq	r2,r3,8206f00 <___vfprintf_internal_r+0x548>
 820862c:	00c00084 	movi	r3,2
 8208630:	10fbcb26 	beq	r2,r3,8207560 <___vfprintf_internal_r+0xba8>
 8208634:	003a8f06 	br	8207074 <___vfprintf_internal_r+0x6bc>
 8208638:	01020974 	movhi	r4,2085
 820863c:	2136df84 	addi	r4,r4,-9346
 8208640:	d9003515 	stw	r4,212(sp)
 8208644:	003b7606 	br	8207420 <___vfprintf_internal_r+0xa68>
 8208648:	d8802917 	ldw	r2,164(sp)
 820864c:	00c00184 	movi	r3,6
 8208650:	1880012e 	bgeu	r3,r2,8208658 <___vfprintf_internal_r+0x1ca0>
 8208654:	1805883a 	mov	r2,r3
 8208658:	d8802e15 	stw	r2,184(sp)
 820865c:	1000ef16 	blt	r2,zero,8208a1c <___vfprintf_internal_r+0x2064>
 8208660:	04020974 	movhi	r16,2085
 8208664:	d8802a15 	stw	r2,168(sp)
 8208668:	dcc02d15 	stw	r19,180(sp)
 820866c:	d8002915 	stw	zero,164(sp)
 8208670:	d8003215 	stw	zero,200(sp)
 8208674:	8436d104 	addi	r16,r16,-9404
 8208678:	0039883a 	mov	fp,zero
 820867c:	003aa206 	br	8207108 <___vfprintf_internal_r+0x750>
 8208680:	0021883a 	mov	r16,zero
 8208684:	003e0706 	br	8207ea4 <___vfprintf_internal_r+0x14ec>
 8208688:	d9002c17 	ldw	r4,176(sp)
 820868c:	d9801e04 	addi	r6,sp,120
 8208690:	b80b883a 	mov	r5,r23
 8208694:	820f50c0 	call	820f50c <__sprint_r>
 8208698:	1039c91e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 820869c:	d8802617 	ldw	r2,152(sp)
 82086a0:	d9403317 	ldw	r5,204(sp)
 82086a4:	d8c02017 	ldw	r3,128(sp)
 82086a8:	da000404 	addi	r8,sp,16
 82086ac:	2885c83a 	sub	r2,r5,r2
 82086b0:	003dfb06 	br	8207ea0 <___vfprintf_internal_r+0x14e8>
 82086b4:	9080004c 	andi	r2,r18,1
 82086b8:	103e8f1e 	bne	r2,zero,82080f8 <___vfprintf_internal_r+0x1740>
 82086bc:	d8802117 	ldw	r2,132(sp)
 82086c0:	003e9e06 	br	820813c <___vfprintf_internal_r+0x1784>
 82086c4:	1025883a 	mov	r18,r2
 82086c8:	0039883a 	mov	fp,zero
 82086cc:	00800084 	movi	r2,2
 82086d0:	003fd306 	br	8208620 <___vfprintf_internal_r+0x1c68>
 82086d4:	07000b44 	movi	fp,45
 82086d8:	df002785 	stb	fp,158(sp)
 82086dc:	003a4006 	br	8206fe0 <___vfprintf_internal_r+0x628>
 82086e0:	00c00b44 	movi	r3,45
 82086e4:	d8c02785 	stb	r3,158(sp)
 82086e8:	d8802a15 	stw	r2,168(sp)
 82086ec:	dc802b17 	ldw	r18,172(sp)
 82086f0:	d8002915 	stw	zero,164(sp)
 82086f4:	07000b44 	movi	fp,45
 82086f8:	003a8006 	br	82070fc <___vfprintf_internal_r+0x744>
 82086fc:	04020974 	movhi	r16,2085
 8208700:	8436c604 	addi	r16,r16,-9448
 8208704:	003f4706 	br	8208424 <___vfprintf_internal_r+0x1a6c>
 8208708:	d8c02d17 	ldw	r3,180(sp)
 820870c:	d9002f17 	ldw	r4,188(sp)
 8208710:	18800017 	ldw	r2,0(r3)
 8208714:	18c00104 	addi	r3,r3,4
 8208718:	d8c02d15 	stw	r3,180(sp)
 820871c:	11000015 	stw	r4,0(r2)
 8208720:	0038dd06 	br	8206a98 <___vfprintf_internal_r+0xe0>
 8208724:	dd802617 	ldw	r22,152(sp)
 8208728:	00bfff44 	movi	r2,-3
 820872c:	b0801c16 	blt	r22,r2,82087a0 <___vfprintf_internal_r+0x1de8>
 8208730:	d9402917 	ldw	r5,164(sp)
 8208734:	2d801a16 	blt	r5,r22,82087a0 <___vfprintf_internal_r+0x1de8>
 8208738:	dd803215 	stw	r22,200(sp)
 820873c:	003e8906 	br	8208164 <___vfprintf_internal_r+0x17ac>
 8208740:	01020974 	movhi	r4,2085
 8208744:	2136db84 	addi	r4,r4,-9362
 8208748:	d9002b15 	stw	r4,172(sp)
 820874c:	003c9106 	br	8207994 <___vfprintf_internal_r+0xfdc>
 8208750:	e005883a 	mov	r2,fp
 8208754:	003e7906 	br	820813c <___vfprintf_internal_r+0x1784>
 8208758:	d9402917 	ldw	r5,164(sp)
 820875c:	df002783 	ldbu	fp,158(sp)
 8208760:	dcc02d15 	stw	r19,180(sp)
 8208764:	d9402a15 	stw	r5,168(sp)
 8208768:	d9402e15 	stw	r5,184(sp)
 820876c:	d8002915 	stw	zero,164(sp)
 8208770:	d8003215 	stw	zero,200(sp)
 8208774:	003a5d06 	br	82070ec <___vfprintf_internal_r+0x734>
 8208778:	9080004c 	andi	r2,r18,1
 820877c:	0039883a 	mov	fp,zero
 8208780:	10000426 	beq	r2,zero,8208794 <___vfprintf_internal_r+0x1ddc>
 8208784:	00800c04 	movi	r2,48
 8208788:	dc001dc4 	addi	r16,sp,119
 820878c:	d8801dc5 	stb	r2,119(sp)
 8208790:	003b8006 	br	8207594 <___vfprintf_internal_r+0xbdc>
 8208794:	d8002e15 	stw	zero,184(sp)
 8208798:	dc001e04 	addi	r16,sp,120
 820879c:	003a4d06 	br	82070d4 <___vfprintf_internal_r+0x71c>
 82087a0:	8c7fff84 	addi	r17,r17,-2
 82087a4:	b5bfffc4 	addi	r22,r22,-1
 82087a8:	dd802615 	stw	r22,152(sp)
 82087ac:	dc4022c5 	stb	r17,139(sp)
 82087b0:	b000bf16 	blt	r22,zero,8208ab0 <___vfprintf_internal_r+0x20f8>
 82087b4:	00800ac4 	movi	r2,43
 82087b8:	d8802305 	stb	r2,140(sp)
 82087bc:	00800244 	movi	r2,9
 82087c0:	15807016 	blt	r2,r22,8208984 <___vfprintf_internal_r+0x1fcc>
 82087c4:	00800c04 	movi	r2,48
 82087c8:	b5800c04 	addi	r22,r22,48
 82087cc:	d8802345 	stb	r2,141(sp)
 82087d0:	dd802385 	stb	r22,142(sp)
 82087d4:	d88023c4 	addi	r2,sp,143
 82087d8:	df0022c4 	addi	fp,sp,139
 82087dc:	d8c03317 	ldw	r3,204(sp)
 82087e0:	1739c83a 	sub	fp,r2,fp
 82087e4:	d9003317 	ldw	r4,204(sp)
 82087e8:	e0c7883a 	add	r3,fp,r3
 82087ec:	df003a15 	stw	fp,232(sp)
 82087f0:	d8c02e15 	stw	r3,184(sp)
 82087f4:	00800044 	movi	r2,1
 82087f8:	1100b30e 	bge	r2,r4,8208ac8 <___vfprintf_internal_r+0x2110>
 82087fc:	d8c02e17 	ldw	r3,184(sp)
 8208800:	18c00044 	addi	r3,r3,1
 8208804:	d8c02e15 	stw	r3,184(sp)
 8208808:	1805883a 	mov	r2,r3
 820880c:	1800ac16 	blt	r3,zero,8208ac0 <___vfprintf_internal_r+0x2108>
 8208810:	d8003215 	stw	zero,200(sp)
 8208814:	003e5d06 	br	820818c <___vfprintf_internal_r+0x17d4>
 8208818:	d9002c17 	ldw	r4,176(sp)
 820881c:	d9801e04 	addi	r6,sp,120
 8208820:	b80b883a 	mov	r5,r23
 8208824:	820f50c0 	call	820f50c <__sprint_r>
 8208828:	1039651e 	bne	r2,zero,8206dc0 <___vfprintf_internal_r+0x408>
 820882c:	dc402617 	ldw	r17,152(sp)
 8208830:	d8c02017 	ldw	r3,128(sp)
 8208834:	d8801f17 	ldw	r2,124(sp)
 8208838:	da000404 	addi	r8,sp,16
 820883c:	003ed606 	br	8208398 <___vfprintf_internal_r+0x19e0>
 8208840:	582b883a 	mov	r21,r11
 8208844:	d8002915 	stw	zero,164(sp)
 8208848:	0038bd06 	br	8206b40 <___vfprintf_internal_r+0x188>
 820884c:	d8802917 	ldw	r2,164(sp)
 8208850:	103e071e 	bne	r2,zero,8208070 <___vfprintf_internal_r+0x16b8>
 8208854:	dc002915 	stw	r16,164(sp)
 8208858:	003e0506 	br	8208070 <___vfprintf_internal_r+0x16b8>
 820885c:	d9002917 	ldw	r4,164(sp)
 8208860:	20c00044 	addi	r3,r4,1
 8208864:	003e0f06 	br	82080a4 <___vfprintf_internal_r+0x16ec>
 8208868:	01400184 	movi	r5,6
 820886c:	d9402915 	stw	r5,164(sp)
 8208870:	003dff06 	br	8208070 <___vfprintf_internal_r+0x16b8>
 8208874:	d8802104 	addi	r2,sp,132
 8208878:	d8800315 	stw	r2,12(sp)
 820887c:	d8802504 	addi	r2,sp,148
 8208880:	d8800215 	stw	r2,8(sp)
 8208884:	d8802604 	addi	r2,sp,152
 8208888:	d8800115 	stw	r2,4(sp)
 820888c:	d8802917 	ldw	r2,164(sp)
 8208890:	d9403617 	ldw	r5,216(sp)
 8208894:	d9002c17 	ldw	r4,176(sp)
 8208898:	d8800015 	stw	r2,0(sp)
 820889c:	01c000c4 	movi	r7,3
 82088a0:	980d883a 	mov	r6,r19
 82088a4:	da003d15 	stw	r8,244(sp)
 82088a8:	82091340 	call	8209134 <_dtoa_r>
 82088ac:	d8c02917 	ldw	r3,164(sp)
 82088b0:	da003d17 	ldw	r8,244(sp)
 82088b4:	1021883a 	mov	r16,r2
 82088b8:	10f9883a 	add	fp,r2,r3
 82088bc:	81000007 	ldb	r4,0(r16)
 82088c0:	00800c04 	movi	r2,48
 82088c4:	20805e26 	beq	r4,r2,8208a40 <___vfprintf_internal_r+0x2088>
 82088c8:	d8c02617 	ldw	r3,152(sp)
 82088cc:	e0f9883a 	add	fp,fp,r3
 82088d0:	003e0a06 	br	82080fc <___vfprintf_internal_r+0x1744>
 82088d4:	00c00b44 	movi	r3,45
 82088d8:	24e0003c 	xorhi	r19,r4,32768
 82088dc:	d8c02a05 	stb	r3,168(sp)
 82088e0:	003de906 	br	8208088 <___vfprintf_internal_r+0x16d0>
 82088e4:	d8c03217 	ldw	r3,200(sp)
 82088e8:	00c07a0e 	bge	zero,r3,8208ad4 <___vfprintf_internal_r+0x211c>
 82088ec:	00800044 	movi	r2,1
 82088f0:	d9003317 	ldw	r4,204(sp)
 82088f4:	1105883a 	add	r2,r2,r4
 82088f8:	d8802e15 	stw	r2,184(sp)
 82088fc:	10004e16 	blt	r2,zero,8208a38 <___vfprintf_internal_r+0x2080>
 8208900:	044019c4 	movi	r17,103
 8208904:	003e2106 	br	820818c <___vfprintf_internal_r+0x17d4>
 8208908:	d9002917 	ldw	r4,164(sp)
 820890c:	d8802104 	addi	r2,sp,132
 8208910:	d8800315 	stw	r2,12(sp)
 8208914:	d9000015 	stw	r4,0(sp)
 8208918:	d8802504 	addi	r2,sp,148
 820891c:	d9403617 	ldw	r5,216(sp)
 8208920:	d9002c17 	ldw	r4,176(sp)
 8208924:	d8800215 	stw	r2,8(sp)
 8208928:	d8802604 	addi	r2,sp,152
 820892c:	d8800115 	stw	r2,4(sp)
 8208930:	01c000c4 	movi	r7,3
 8208934:	980d883a 	mov	r6,r19
 8208938:	da003d15 	stw	r8,244(sp)
 820893c:	82091340 	call	8209134 <_dtoa_r>
 8208940:	d8c02917 	ldw	r3,164(sp)
 8208944:	da003d17 	ldw	r8,244(sp)
 8208948:	1021883a 	mov	r16,r2
 820894c:	00801184 	movi	r2,70
 8208950:	80f9883a 	add	fp,r16,r3
 8208954:	88bfd926 	beq	r17,r2,82088bc <___vfprintf_internal_r+0x1f04>
 8208958:	003de806 	br	82080fc <___vfprintf_internal_r+0x1744>
 820895c:	d9002917 	ldw	r4,164(sp)
 8208960:	00c04d0e 	bge	zero,r3,8208a98 <___vfprintf_internal_r+0x20e0>
 8208964:	2000441e 	bne	r4,zero,8208a78 <___vfprintf_internal_r+0x20c0>
 8208968:	9480004c 	andi	r18,r18,1
 820896c:	9000421e 	bne	r18,zero,8208a78 <___vfprintf_internal_r+0x20c0>
 8208970:	1805883a 	mov	r2,r3
 8208974:	18007016 	blt	r3,zero,8208b38 <___vfprintf_internal_r+0x2180>
 8208978:	d8c03217 	ldw	r3,200(sp)
 820897c:	d8c02e15 	stw	r3,184(sp)
 8208980:	003e0206 	br	820818c <___vfprintf_internal_r+0x17d4>
 8208984:	df0022c4 	addi	fp,sp,139
 8208988:	dc002915 	stw	r16,164(sp)
 820898c:	4027883a 	mov	r19,r8
 8208990:	e021883a 	mov	r16,fp
 8208994:	b009883a 	mov	r4,r22
 8208998:	01400284 	movi	r5,10
 820899c:	8202b180 	call	8202b18 <__modsi3>
 82089a0:	10800c04 	addi	r2,r2,48
 82089a4:	843fffc4 	addi	r16,r16,-1
 82089a8:	b009883a 	mov	r4,r22
 82089ac:	01400284 	movi	r5,10
 82089b0:	80800005 	stb	r2,0(r16)
 82089b4:	8202a940 	call	8202a94 <__divsi3>
 82089b8:	102d883a 	mov	r22,r2
 82089bc:	00800244 	movi	r2,9
 82089c0:	15bff416 	blt	r2,r22,8208994 <___vfprintf_internal_r+0x1fdc>
 82089c4:	9811883a 	mov	r8,r19
 82089c8:	b0800c04 	addi	r2,r22,48
 82089cc:	8027883a 	mov	r19,r16
 82089d0:	997fffc4 	addi	r5,r19,-1
 82089d4:	98bfffc5 	stb	r2,-1(r19)
 82089d8:	dc002917 	ldw	r16,164(sp)
 82089dc:	2f006a2e 	bgeu	r5,fp,8208b88 <___vfprintf_internal_r+0x21d0>
 82089e0:	d9c02384 	addi	r7,sp,142
 82089e4:	3ccfc83a 	sub	r7,r7,r19
 82089e8:	d9002344 	addi	r4,sp,141
 82089ec:	e1cf883a 	add	r7,fp,r7
 82089f0:	00000106 	br	82089f8 <___vfprintf_internal_r+0x2040>
 82089f4:	28800003 	ldbu	r2,0(r5)
 82089f8:	20800005 	stb	r2,0(r4)
 82089fc:	21000044 	addi	r4,r4,1
 8208a00:	29400044 	addi	r5,r5,1
 8208a04:	393ffb1e 	bne	r7,r4,82089f4 <___vfprintf_internal_r+0x203c>
 8208a08:	d8802304 	addi	r2,sp,140
 8208a0c:	14c5c83a 	sub	r2,r2,r19
 8208a10:	d8c02344 	addi	r3,sp,141
 8208a14:	1885883a 	add	r2,r3,r2
 8208a18:	003f7006 	br	82087dc <___vfprintf_internal_r+0x1e24>
 8208a1c:	0005883a 	mov	r2,zero
 8208a20:	003f0f06 	br	8208660 <___vfprintf_internal_r+0x1ca8>
 8208a24:	d8c03217 	ldw	r3,200(sp)
 8208a28:	18c00044 	addi	r3,r3,1
 8208a2c:	d8c02e15 	stw	r3,184(sp)
 8208a30:	1805883a 	mov	r2,r3
 8208a34:	183fb20e 	bge	r3,zero,8208900 <___vfprintf_internal_r+0x1f48>
 8208a38:	0005883a 	mov	r2,zero
 8208a3c:	003fb006 	br	8208900 <___vfprintf_internal_r+0x1f48>
 8208a40:	d9003617 	ldw	r4,216(sp)
 8208a44:	000d883a 	mov	r6,zero
 8208a48:	000f883a 	mov	r7,zero
 8208a4c:	980b883a 	mov	r5,r19
 8208a50:	d8c03c15 	stw	r3,240(sp)
 8208a54:	da003d15 	stw	r8,244(sp)
 8208a58:	8212e780 	call	8212e78 <__eqdf2>
 8208a5c:	d8c03c17 	ldw	r3,240(sp)
 8208a60:	da003d17 	ldw	r8,244(sp)
 8208a64:	103f9826 	beq	r2,zero,82088c8 <___vfprintf_internal_r+0x1f10>
 8208a68:	00800044 	movi	r2,1
 8208a6c:	10c7c83a 	sub	r3,r2,r3
 8208a70:	d8c02615 	stw	r3,152(sp)
 8208a74:	003f9506 	br	82088cc <___vfprintf_internal_r+0x1f14>
 8208a78:	d9002917 	ldw	r4,164(sp)
 8208a7c:	d8c03217 	ldw	r3,200(sp)
 8208a80:	20800044 	addi	r2,r4,1
 8208a84:	1885883a 	add	r2,r3,r2
 8208a88:	d8802e15 	stw	r2,184(sp)
 8208a8c:	103dbf0e 	bge	r2,zero,820818c <___vfprintf_internal_r+0x17d4>
 8208a90:	0005883a 	mov	r2,zero
 8208a94:	003dbd06 	br	820818c <___vfprintf_internal_r+0x17d4>
 8208a98:	2000211e 	bne	r4,zero,8208b20 <___vfprintf_internal_r+0x2168>
 8208a9c:	9480004c 	andi	r18,r18,1
 8208aa0:	90001f1e 	bne	r18,zero,8208b20 <___vfprintf_internal_r+0x2168>
 8208aa4:	00800044 	movi	r2,1
 8208aa8:	d8802e15 	stw	r2,184(sp)
 8208aac:	003db706 	br	820818c <___vfprintf_internal_r+0x17d4>
 8208ab0:	00800b44 	movi	r2,45
 8208ab4:	05adc83a 	sub	r22,zero,r22
 8208ab8:	d8802305 	stb	r2,140(sp)
 8208abc:	003f3f06 	br	82087bc <___vfprintf_internal_r+0x1e04>
 8208ac0:	0005883a 	mov	r2,zero
 8208ac4:	003f5206 	br	8208810 <___vfprintf_internal_r+0x1e58>
 8208ac8:	90a4703a 	and	r18,r18,r2
 8208acc:	903f4e26 	beq	r18,zero,8208808 <___vfprintf_internal_r+0x1e50>
 8208ad0:	003f4a06 	br	82087fc <___vfprintf_internal_r+0x1e44>
 8208ad4:	00800084 	movi	r2,2
 8208ad8:	10c5c83a 	sub	r2,r2,r3
 8208adc:	003f8406 	br	82088f0 <___vfprintf_internal_r+0x1f38>
 8208ae0:	d8802d17 	ldw	r2,180(sp)
 8208ae4:	d9002d17 	ldw	r4,180(sp)
 8208ae8:	ac400043 	ldbu	r17,1(r21)
 8208aec:	10800017 	ldw	r2,0(r2)
 8208af0:	582b883a 	mov	r21,r11
 8208af4:	d8802915 	stw	r2,164(sp)
 8208af8:	20800104 	addi	r2,r4,4
 8208afc:	d9002917 	ldw	r4,164(sp)
 8208b00:	d8802d15 	stw	r2,180(sp)
 8208b04:	203e7a0e 	bge	r4,zero,82084f0 <___vfprintf_internal_r+0x1b38>
 8208b08:	8c403fcc 	andi	r17,r17,255
 8208b0c:	00bfffc4 	movi	r2,-1
 8208b10:	8c40201c 	xori	r17,r17,128
 8208b14:	d8802915 	stw	r2,164(sp)
 8208b18:	8c7fe004 	addi	r17,r17,-128
 8208b1c:	00380706 	br	8206b3c <___vfprintf_internal_r+0x184>
 8208b20:	d8c02917 	ldw	r3,164(sp)
 8208b24:	18c00084 	addi	r3,r3,2
 8208b28:	d8c02e15 	stw	r3,184(sp)
 8208b2c:	1805883a 	mov	r2,r3
 8208b30:	183d960e 	bge	r3,zero,820818c <___vfprintf_internal_r+0x17d4>
 8208b34:	003fd606 	br	8208a90 <___vfprintf_internal_r+0x20d8>
 8208b38:	0005883a 	mov	r2,zero
 8208b3c:	003f8e06 	br	8208978 <___vfprintf_internal_r+0x1fc0>
 8208b40:	9080004c 	andi	r2,r18,1
 8208b44:	103f811e 	bne	r2,zero,820894c <___vfprintf_internal_r+0x1f94>
 8208b48:	d8802117 	ldw	r2,132(sp)
 8208b4c:	1405c83a 	sub	r2,r2,r16
 8208b50:	d8803315 	stw	r2,204(sp)
 8208b54:	b47ef326 	beq	r22,r17,8208724 <___vfprintf_internal_r+0x1d6c>
 8208b58:	dd802617 	ldw	r22,152(sp)
 8208b5c:	003f1106 	br	82087a4 <___vfprintf_internal_r+0x1dec>
 8208b60:	d9c02785 	stb	r7,158(sp)
 8208b64:	00390406 	br	8206f78 <___vfprintf_internal_r+0x5c0>
 8208b68:	d9c02785 	stb	r7,158(sp)
 8208b6c:	0038d306 	br	8206ebc <___vfprintf_internal_r+0x504>
 8208b70:	d9c02785 	stb	r7,158(sp)
 8208b74:	003a6106 	br	82074fc <___vfprintf_internal_r+0xb44>
 8208b78:	d9c02785 	stb	r7,158(sp)
 8208b7c:	003af806 	br	8207760 <___vfprintf_internal_r+0xda8>
 8208b80:	0005883a 	mov	r2,zero
 8208b84:	003d7e06 	br	8208180 <___vfprintf_internal_r+0x17c8>
 8208b88:	d8802344 	addi	r2,sp,141
 8208b8c:	003f1306 	br	82087dc <___vfprintf_internal_r+0x1e24>
 8208b90:	d9c02785 	stb	r7,158(sp)
 8208b94:	00392306 	br	8207024 <___vfprintf_internal_r+0x66c>
 8208b98:	d9c02785 	stb	r7,158(sp)
 8208b9c:	003aa906 	br	8207644 <___vfprintf_internal_r+0xc8c>
 8208ba0:	d9c02785 	stb	r7,158(sp)
 8208ba4:	003a3d06 	br	820749c <___vfprintf_internal_r+0xae4>
 8208ba8:	d9c02785 	stb	r7,158(sp)
 8208bac:	003aca06 	br	82076d8 <___vfprintf_internal_r+0xd20>

08208bb0 <__vfprintf_internal>:
 8208bb0:	00820974 	movhi	r2,2085
 8208bb4:	108fa204 	addi	r2,r2,16008
 8208bb8:	300f883a 	mov	r7,r6
 8208bbc:	280d883a 	mov	r6,r5
 8208bc0:	200b883a 	mov	r5,r4
 8208bc4:	11000017 	ldw	r4,0(r2)
 8208bc8:	82069b81 	jmpi	82069b8 <___vfprintf_internal_r>

08208bcc <__sbprintf>:
 8208bcc:	2880030b 	ldhu	r2,12(r5)
 8208bd0:	2ac01917 	ldw	r11,100(r5)
 8208bd4:	2a80038b 	ldhu	r10,14(r5)
 8208bd8:	2a400717 	ldw	r9,28(r5)
 8208bdc:	2a000917 	ldw	r8,36(r5)
 8208be0:	defee204 	addi	sp,sp,-1144
 8208be4:	00c10004 	movi	r3,1024
 8208be8:	dc011a15 	stw	r16,1128(sp)
 8208bec:	10bfff4c 	andi	r2,r2,65533
 8208bf0:	2821883a 	mov	r16,r5
 8208bf4:	d8cb883a 	add	r5,sp,r3
 8208bf8:	dc811c15 	stw	r18,1136(sp)
 8208bfc:	dc411b15 	stw	r17,1132(sp)
 8208c00:	dfc11d15 	stw	ra,1140(sp)
 8208c04:	2025883a 	mov	r18,r4
 8208c08:	d881030d 	sth	r2,1036(sp)
 8208c0c:	dac11915 	stw	r11,1124(sp)
 8208c10:	da81038d 	sth	r10,1038(sp)
 8208c14:	da410715 	stw	r9,1052(sp)
 8208c18:	da010915 	stw	r8,1060(sp)
 8208c1c:	dec10015 	stw	sp,1024(sp)
 8208c20:	dec10415 	stw	sp,1040(sp)
 8208c24:	d8c10215 	stw	r3,1032(sp)
 8208c28:	d8c10515 	stw	r3,1044(sp)
 8208c2c:	d8010615 	stw	zero,1048(sp)
 8208c30:	82069b80 	call	82069b8 <___vfprintf_internal_r>
 8208c34:	1023883a 	mov	r17,r2
 8208c38:	10000416 	blt	r2,zero,8208c4c <__sbprintf+0x80>
 8208c3c:	d9410004 	addi	r5,sp,1024
 8208c40:	9009883a 	mov	r4,r18
 8208c44:	820a9d80 	call	820a9d8 <_fflush_r>
 8208c48:	10000d1e 	bne	r2,zero,8208c80 <__sbprintf+0xb4>
 8208c4c:	d881030b 	ldhu	r2,1036(sp)
 8208c50:	1080100c 	andi	r2,r2,64
 8208c54:	10000326 	beq	r2,zero,8208c64 <__sbprintf+0x98>
 8208c58:	8080030b 	ldhu	r2,12(r16)
 8208c5c:	10801014 	ori	r2,r2,64
 8208c60:	8080030d 	sth	r2,12(r16)
 8208c64:	8805883a 	mov	r2,r17
 8208c68:	dfc11d17 	ldw	ra,1140(sp)
 8208c6c:	dc811c17 	ldw	r18,1136(sp)
 8208c70:	dc411b17 	ldw	r17,1132(sp)
 8208c74:	dc011a17 	ldw	r16,1128(sp)
 8208c78:	dec11e04 	addi	sp,sp,1144
 8208c7c:	f800283a 	ret
 8208c80:	047fffc4 	movi	r17,-1
 8208c84:	003ff106 	br	8208c4c <__sbprintf+0x80>

08208c88 <__swbuf_r>:
 8208c88:	defffb04 	addi	sp,sp,-20
 8208c8c:	dcc00315 	stw	r19,12(sp)
 8208c90:	dc800215 	stw	r18,8(sp)
 8208c94:	dc000015 	stw	r16,0(sp)
 8208c98:	dfc00415 	stw	ra,16(sp)
 8208c9c:	dc400115 	stw	r17,4(sp)
 8208ca0:	2025883a 	mov	r18,r4
 8208ca4:	2827883a 	mov	r19,r5
 8208ca8:	3021883a 	mov	r16,r6
 8208cac:	20000226 	beq	r4,zero,8208cb8 <__swbuf_r+0x30>
 8208cb0:	20800e17 	ldw	r2,56(r4)
 8208cb4:	10004226 	beq	r2,zero,8208dc0 <__swbuf_r+0x138>
 8208cb8:	80800617 	ldw	r2,24(r16)
 8208cbc:	8100030b 	ldhu	r4,12(r16)
 8208cc0:	80800215 	stw	r2,8(r16)
 8208cc4:	2080020c 	andi	r2,r4,8
 8208cc8:	10003626 	beq	r2,zero,8208da4 <__swbuf_r+0x11c>
 8208ccc:	80c00417 	ldw	r3,16(r16)
 8208cd0:	18003426 	beq	r3,zero,8208da4 <__swbuf_r+0x11c>
 8208cd4:	2088000c 	andi	r2,r4,8192
 8208cd8:	9c403fcc 	andi	r17,r19,255
 8208cdc:	10001a26 	beq	r2,zero,8208d48 <__swbuf_r+0xc0>
 8208ce0:	80800017 	ldw	r2,0(r16)
 8208ce4:	81000517 	ldw	r4,20(r16)
 8208ce8:	10c7c83a 	sub	r3,r2,r3
 8208cec:	1900200e 	bge	r3,r4,8208d70 <__swbuf_r+0xe8>
 8208cf0:	18c00044 	addi	r3,r3,1
 8208cf4:	81000217 	ldw	r4,8(r16)
 8208cf8:	11400044 	addi	r5,r2,1
 8208cfc:	81400015 	stw	r5,0(r16)
 8208d00:	213fffc4 	addi	r4,r4,-1
 8208d04:	81000215 	stw	r4,8(r16)
 8208d08:	14c00005 	stb	r19,0(r2)
 8208d0c:	80800517 	ldw	r2,20(r16)
 8208d10:	10c01e26 	beq	r2,r3,8208d8c <__swbuf_r+0x104>
 8208d14:	8080030b 	ldhu	r2,12(r16)
 8208d18:	1080004c 	andi	r2,r2,1
 8208d1c:	10000226 	beq	r2,zero,8208d28 <__swbuf_r+0xa0>
 8208d20:	00800284 	movi	r2,10
 8208d24:	88801926 	beq	r17,r2,8208d8c <__swbuf_r+0x104>
 8208d28:	8805883a 	mov	r2,r17
 8208d2c:	dfc00417 	ldw	ra,16(sp)
 8208d30:	dcc00317 	ldw	r19,12(sp)
 8208d34:	dc800217 	ldw	r18,8(sp)
 8208d38:	dc400117 	ldw	r17,4(sp)
 8208d3c:	dc000017 	ldw	r16,0(sp)
 8208d40:	dec00504 	addi	sp,sp,20
 8208d44:	f800283a 	ret
 8208d48:	81401917 	ldw	r5,100(r16)
 8208d4c:	00b7ffc4 	movi	r2,-8193
 8208d50:	21080014 	ori	r4,r4,8192
 8208d54:	2884703a 	and	r2,r5,r2
 8208d58:	80801915 	stw	r2,100(r16)
 8208d5c:	80800017 	ldw	r2,0(r16)
 8208d60:	8100030d 	sth	r4,12(r16)
 8208d64:	81000517 	ldw	r4,20(r16)
 8208d68:	10c7c83a 	sub	r3,r2,r3
 8208d6c:	193fe016 	blt	r3,r4,8208cf0 <__swbuf_r+0x68>
 8208d70:	800b883a 	mov	r5,r16
 8208d74:	9009883a 	mov	r4,r18
 8208d78:	820a9d80 	call	820a9d8 <_fflush_r>
 8208d7c:	1000071e 	bne	r2,zero,8208d9c <__swbuf_r+0x114>
 8208d80:	80800017 	ldw	r2,0(r16)
 8208d84:	00c00044 	movi	r3,1
 8208d88:	003fda06 	br	8208cf4 <__swbuf_r+0x6c>
 8208d8c:	800b883a 	mov	r5,r16
 8208d90:	9009883a 	mov	r4,r18
 8208d94:	820a9d80 	call	820a9d8 <_fflush_r>
 8208d98:	103fe326 	beq	r2,zero,8208d28 <__swbuf_r+0xa0>
 8208d9c:	00bfffc4 	movi	r2,-1
 8208da0:	003fe206 	br	8208d2c <__swbuf_r+0xa4>
 8208da4:	800b883a 	mov	r5,r16
 8208da8:	9009883a 	mov	r4,r18
 8208dac:	8208de00 	call	8208de0 <__swsetup_r>
 8208db0:	103ffa1e 	bne	r2,zero,8208d9c <__swbuf_r+0x114>
 8208db4:	8100030b 	ldhu	r4,12(r16)
 8208db8:	80c00417 	ldw	r3,16(r16)
 8208dbc:	003fc506 	br	8208cd4 <__swbuf_r+0x4c>
 8208dc0:	820adb40 	call	820adb4 <__sinit>
 8208dc4:	003fbc06 	br	8208cb8 <__swbuf_r+0x30>

08208dc8 <__swbuf>:
 8208dc8:	00820974 	movhi	r2,2085
 8208dcc:	108fa204 	addi	r2,r2,16008
 8208dd0:	280d883a 	mov	r6,r5
 8208dd4:	200b883a 	mov	r5,r4
 8208dd8:	11000017 	ldw	r4,0(r2)
 8208ddc:	8208c881 	jmpi	8208c88 <__swbuf_r>

08208de0 <__swsetup_r>:
 8208de0:	00820974 	movhi	r2,2085
 8208de4:	defffd04 	addi	sp,sp,-12
 8208de8:	108fa204 	addi	r2,r2,16008
 8208dec:	dc400115 	stw	r17,4(sp)
 8208df0:	2023883a 	mov	r17,r4
 8208df4:	11000017 	ldw	r4,0(r2)
 8208df8:	dc000015 	stw	r16,0(sp)
 8208dfc:	dfc00215 	stw	ra,8(sp)
 8208e00:	2821883a 	mov	r16,r5
 8208e04:	20000226 	beq	r4,zero,8208e10 <__swsetup_r+0x30>
 8208e08:	20800e17 	ldw	r2,56(r4)
 8208e0c:	10003126 	beq	r2,zero,8208ed4 <__swsetup_r+0xf4>
 8208e10:	8080030b 	ldhu	r2,12(r16)
 8208e14:	10c0020c 	andi	r3,r2,8
 8208e18:	1009883a 	mov	r4,r2
 8208e1c:	18000f26 	beq	r3,zero,8208e5c <__swsetup_r+0x7c>
 8208e20:	80c00417 	ldw	r3,16(r16)
 8208e24:	18001526 	beq	r3,zero,8208e7c <__swsetup_r+0x9c>
 8208e28:	1100004c 	andi	r4,r2,1
 8208e2c:	20001c1e 	bne	r4,zero,8208ea0 <__swsetup_r+0xc0>
 8208e30:	1080008c 	andi	r2,r2,2
 8208e34:	1000291e 	bne	r2,zero,8208edc <__swsetup_r+0xfc>
 8208e38:	80800517 	ldw	r2,20(r16)
 8208e3c:	80800215 	stw	r2,8(r16)
 8208e40:	18001c26 	beq	r3,zero,8208eb4 <__swsetup_r+0xd4>
 8208e44:	0005883a 	mov	r2,zero
 8208e48:	dfc00217 	ldw	ra,8(sp)
 8208e4c:	dc400117 	ldw	r17,4(sp)
 8208e50:	dc000017 	ldw	r16,0(sp)
 8208e54:	dec00304 	addi	sp,sp,12
 8208e58:	f800283a 	ret
 8208e5c:	2080040c 	andi	r2,r4,16
 8208e60:	10002e26 	beq	r2,zero,8208f1c <__swsetup_r+0x13c>
 8208e64:	2080010c 	andi	r2,r4,4
 8208e68:	10001e1e 	bne	r2,zero,8208ee4 <__swsetup_r+0x104>
 8208e6c:	80c00417 	ldw	r3,16(r16)
 8208e70:	20800214 	ori	r2,r4,8
 8208e74:	8080030d 	sth	r2,12(r16)
 8208e78:	183feb1e 	bne	r3,zero,8208e28 <__swsetup_r+0x48>
 8208e7c:	1100a00c 	andi	r4,r2,640
 8208e80:	01408004 	movi	r5,512
 8208e84:	217fe826 	beq	r4,r5,8208e28 <__swsetup_r+0x48>
 8208e88:	800b883a 	mov	r5,r16
 8208e8c:	8809883a 	mov	r4,r17
 8208e90:	820baac0 	call	820baac <__smakebuf_r>
 8208e94:	8080030b 	ldhu	r2,12(r16)
 8208e98:	80c00417 	ldw	r3,16(r16)
 8208e9c:	003fe206 	br	8208e28 <__swsetup_r+0x48>
 8208ea0:	80800517 	ldw	r2,20(r16)
 8208ea4:	80000215 	stw	zero,8(r16)
 8208ea8:	0085c83a 	sub	r2,zero,r2
 8208eac:	80800615 	stw	r2,24(r16)
 8208eb0:	183fe41e 	bne	r3,zero,8208e44 <__swsetup_r+0x64>
 8208eb4:	80c0030b 	ldhu	r3,12(r16)
 8208eb8:	0005883a 	mov	r2,zero
 8208ebc:	1900200c 	andi	r4,r3,128
 8208ec0:	203fe126 	beq	r4,zero,8208e48 <__swsetup_r+0x68>
 8208ec4:	18c01014 	ori	r3,r3,64
 8208ec8:	80c0030d 	sth	r3,12(r16)
 8208ecc:	00bfffc4 	movi	r2,-1
 8208ed0:	003fdd06 	br	8208e48 <__swsetup_r+0x68>
 8208ed4:	820adb40 	call	820adb4 <__sinit>
 8208ed8:	003fcd06 	br	8208e10 <__swsetup_r+0x30>
 8208edc:	0005883a 	mov	r2,zero
 8208ee0:	003fd606 	br	8208e3c <__swsetup_r+0x5c>
 8208ee4:	81400c17 	ldw	r5,48(r16)
 8208ee8:	28000626 	beq	r5,zero,8208f04 <__swsetup_r+0x124>
 8208eec:	80801004 	addi	r2,r16,64
 8208ef0:	28800326 	beq	r5,r2,8208f00 <__swsetup_r+0x120>
 8208ef4:	8809883a 	mov	r4,r17
 8208ef8:	820b07c0 	call	820b07c <_free_r>
 8208efc:	8100030b 	ldhu	r4,12(r16)
 8208f00:	80000c15 	stw	zero,48(r16)
 8208f04:	80c00417 	ldw	r3,16(r16)
 8208f08:	00bff6c4 	movi	r2,-37
 8208f0c:	1108703a 	and	r4,r2,r4
 8208f10:	80000115 	stw	zero,4(r16)
 8208f14:	80c00015 	stw	r3,0(r16)
 8208f18:	003fd506 	br	8208e70 <__swsetup_r+0x90>
 8208f1c:	00800244 	movi	r2,9
 8208f20:	88800015 	stw	r2,0(r17)
 8208f24:	20801014 	ori	r2,r4,64
 8208f28:	8080030d 	sth	r2,12(r16)
 8208f2c:	00bfffc4 	movi	r2,-1
 8208f30:	003fc506 	br	8208e48 <__swsetup_r+0x68>

08208f34 <quorem>:
 8208f34:	defff704 	addi	sp,sp,-36
 8208f38:	dc800215 	stw	r18,8(sp)
 8208f3c:	20800417 	ldw	r2,16(r4)
 8208f40:	2c800417 	ldw	r18,16(r5)
 8208f44:	dfc00815 	stw	ra,32(sp)
 8208f48:	ddc00715 	stw	r23,28(sp)
 8208f4c:	dd800615 	stw	r22,24(sp)
 8208f50:	dd400515 	stw	r21,20(sp)
 8208f54:	dd000415 	stw	r20,16(sp)
 8208f58:	dcc00315 	stw	r19,12(sp)
 8208f5c:	dc400115 	stw	r17,4(sp)
 8208f60:	dc000015 	stw	r16,0(sp)
 8208f64:	14807116 	blt	r2,r18,820912c <quorem+0x1f8>
 8208f68:	94bfffc4 	addi	r18,r18,-1
 8208f6c:	94ad883a 	add	r22,r18,r18
 8208f70:	b5ad883a 	add	r22,r22,r22
 8208f74:	2c400504 	addi	r17,r5,20
 8208f78:	8da9883a 	add	r20,r17,r22
 8208f7c:	25400504 	addi	r21,r4,20
 8208f80:	282f883a 	mov	r23,r5
 8208f84:	adad883a 	add	r22,r21,r22
 8208f88:	a1400017 	ldw	r5,0(r20)
 8208f8c:	2021883a 	mov	r16,r4
 8208f90:	b1000017 	ldw	r4,0(r22)
 8208f94:	29400044 	addi	r5,r5,1
 8208f98:	8202b8c0 	call	8202b8c <__udivsi3>
 8208f9c:	1027883a 	mov	r19,r2
 8208fa0:	10002c26 	beq	r2,zero,8209054 <quorem+0x120>
 8208fa4:	a813883a 	mov	r9,r21
 8208fa8:	880b883a 	mov	r5,r17
 8208fac:	0009883a 	mov	r4,zero
 8208fb0:	000d883a 	mov	r6,zero
 8208fb4:	2a000017 	ldw	r8,0(r5)
 8208fb8:	49c00017 	ldw	r7,0(r9)
 8208fbc:	29400104 	addi	r5,r5,4
 8208fc0:	40bfffcc 	andi	r2,r8,65535
 8208fc4:	14c5383a 	mul	r2,r2,r19
 8208fc8:	4010d43a 	srli	r8,r8,16
 8208fcc:	38ffffcc 	andi	r3,r7,65535
 8208fd0:	1105883a 	add	r2,r2,r4
 8208fd4:	1008d43a 	srli	r4,r2,16
 8208fd8:	44d1383a 	mul	r8,r8,r19
 8208fdc:	198d883a 	add	r6,r3,r6
 8208fe0:	10ffffcc 	andi	r3,r2,65535
 8208fe4:	30c7c83a 	sub	r3,r6,r3
 8208fe8:	380ed43a 	srli	r7,r7,16
 8208fec:	4105883a 	add	r2,r8,r4
 8208ff0:	180dd43a 	srai	r6,r3,16
 8208ff4:	113fffcc 	andi	r4,r2,65535
 8208ff8:	390fc83a 	sub	r7,r7,r4
 8208ffc:	398d883a 	add	r6,r7,r6
 8209000:	300e943a 	slli	r7,r6,16
 8209004:	18ffffcc 	andi	r3,r3,65535
 8209008:	1008d43a 	srli	r4,r2,16
 820900c:	38ceb03a 	or	r7,r7,r3
 8209010:	49c00015 	stw	r7,0(r9)
 8209014:	300dd43a 	srai	r6,r6,16
 8209018:	4a400104 	addi	r9,r9,4
 820901c:	a17fe52e 	bgeu	r20,r5,8208fb4 <quorem+0x80>
 8209020:	b0800017 	ldw	r2,0(r22)
 8209024:	10000b1e 	bne	r2,zero,8209054 <quorem+0x120>
 8209028:	b0bfff04 	addi	r2,r22,-4
 820902c:	a880082e 	bgeu	r21,r2,8209050 <quorem+0x11c>
 8209030:	b0ffff17 	ldw	r3,-4(r22)
 8209034:	18000326 	beq	r3,zero,8209044 <quorem+0x110>
 8209038:	00000506 	br	8209050 <quorem+0x11c>
 820903c:	10c00017 	ldw	r3,0(r2)
 8209040:	1800031e 	bne	r3,zero,8209050 <quorem+0x11c>
 8209044:	10bfff04 	addi	r2,r2,-4
 8209048:	94bfffc4 	addi	r18,r18,-1
 820904c:	a8bffb36 	bltu	r21,r2,820903c <quorem+0x108>
 8209050:	84800415 	stw	r18,16(r16)
 8209054:	b80b883a 	mov	r5,r23
 8209058:	8009883a 	mov	r4,r16
 820905c:	820ce9c0 	call	820ce9c <__mcmp>
 8209060:	10002616 	blt	r2,zero,82090fc <quorem+0x1c8>
 8209064:	9cc00044 	addi	r19,r19,1
 8209068:	a805883a 	mov	r2,r21
 820906c:	000b883a 	mov	r5,zero
 8209070:	11000017 	ldw	r4,0(r2)
 8209074:	89800017 	ldw	r6,0(r17)
 8209078:	10800104 	addi	r2,r2,4
 820907c:	20ffffcc 	andi	r3,r4,65535
 8209080:	194b883a 	add	r5,r3,r5
 8209084:	30ffffcc 	andi	r3,r6,65535
 8209088:	28c7c83a 	sub	r3,r5,r3
 820908c:	300cd43a 	srli	r6,r6,16
 8209090:	2008d43a 	srli	r4,r4,16
 8209094:	180bd43a 	srai	r5,r3,16
 8209098:	18ffffcc 	andi	r3,r3,65535
 820909c:	2189c83a 	sub	r4,r4,r6
 82090a0:	2149883a 	add	r4,r4,r5
 82090a4:	200c943a 	slli	r6,r4,16
 82090a8:	8c400104 	addi	r17,r17,4
 82090ac:	200bd43a 	srai	r5,r4,16
 82090b0:	30c6b03a 	or	r3,r6,r3
 82090b4:	10ffff15 	stw	r3,-4(r2)
 82090b8:	a47fed2e 	bgeu	r20,r17,8209070 <quorem+0x13c>
 82090bc:	9485883a 	add	r2,r18,r18
 82090c0:	1085883a 	add	r2,r2,r2
 82090c4:	a887883a 	add	r3,r21,r2
 82090c8:	18800017 	ldw	r2,0(r3)
 82090cc:	10000b1e 	bne	r2,zero,82090fc <quorem+0x1c8>
 82090d0:	18bfff04 	addi	r2,r3,-4
 82090d4:	a880082e 	bgeu	r21,r2,82090f8 <quorem+0x1c4>
 82090d8:	18ffff17 	ldw	r3,-4(r3)
 82090dc:	18000326 	beq	r3,zero,82090ec <quorem+0x1b8>
 82090e0:	00000506 	br	82090f8 <quorem+0x1c4>
 82090e4:	10c00017 	ldw	r3,0(r2)
 82090e8:	1800031e 	bne	r3,zero,82090f8 <quorem+0x1c4>
 82090ec:	10bfff04 	addi	r2,r2,-4
 82090f0:	94bfffc4 	addi	r18,r18,-1
 82090f4:	a8bffb36 	bltu	r21,r2,82090e4 <quorem+0x1b0>
 82090f8:	84800415 	stw	r18,16(r16)
 82090fc:	9805883a 	mov	r2,r19
 8209100:	dfc00817 	ldw	ra,32(sp)
 8209104:	ddc00717 	ldw	r23,28(sp)
 8209108:	dd800617 	ldw	r22,24(sp)
 820910c:	dd400517 	ldw	r21,20(sp)
 8209110:	dd000417 	ldw	r20,16(sp)
 8209114:	dcc00317 	ldw	r19,12(sp)
 8209118:	dc800217 	ldw	r18,8(sp)
 820911c:	dc400117 	ldw	r17,4(sp)
 8209120:	dc000017 	ldw	r16,0(sp)
 8209124:	dec00904 	addi	sp,sp,36
 8209128:	f800283a 	ret
 820912c:	0005883a 	mov	r2,zero
 8209130:	003ff306 	br	8209100 <quorem+0x1cc>

08209134 <_dtoa_r>:
 8209134:	20801017 	ldw	r2,64(r4)
 8209138:	deffde04 	addi	sp,sp,-136
 820913c:	df002015 	stw	fp,128(sp)
 8209140:	dcc01b15 	stw	r19,108(sp)
 8209144:	dc801a15 	stw	r18,104(sp)
 8209148:	dc401915 	stw	r17,100(sp)
 820914c:	dc001815 	stw	r16,96(sp)
 8209150:	dfc02115 	stw	ra,132(sp)
 8209154:	ddc01f15 	stw	r23,124(sp)
 8209158:	dd801e15 	stw	r22,120(sp)
 820915c:	dd401d15 	stw	r21,116(sp)
 8209160:	dd001c15 	stw	r20,112(sp)
 8209164:	d9c00315 	stw	r7,12(sp)
 8209168:	2039883a 	mov	fp,r4
 820916c:	3023883a 	mov	r17,r6
 8209170:	2825883a 	mov	r18,r5
 8209174:	dc002417 	ldw	r16,144(sp)
 8209178:	3027883a 	mov	r19,r6
 820917c:	10000826 	beq	r2,zero,82091a0 <_dtoa_r+0x6c>
 8209180:	21801117 	ldw	r6,68(r4)
 8209184:	00c00044 	movi	r3,1
 8209188:	100b883a 	mov	r5,r2
 820918c:	1986983a 	sll	r3,r3,r6
 8209190:	11800115 	stw	r6,4(r2)
 8209194:	10c00215 	stw	r3,8(r2)
 8209198:	820c67c0 	call	820c67c <_Bfree>
 820919c:	e0001015 	stw	zero,64(fp)
 82091a0:	88002e16 	blt	r17,zero,820925c <_dtoa_r+0x128>
 82091a4:	80000015 	stw	zero,0(r16)
 82091a8:	889ffc2c 	andhi	r2,r17,32752
 82091ac:	00dffc34 	movhi	r3,32752
 82091b0:	10c01c26 	beq	r2,r3,8209224 <_dtoa_r+0xf0>
 82091b4:	000d883a 	mov	r6,zero
 82091b8:	000f883a 	mov	r7,zero
 82091bc:	9009883a 	mov	r4,r18
 82091c0:	980b883a 	mov	r5,r19
 82091c4:	8212e780 	call	8212e78 <__eqdf2>
 82091c8:	10002b1e 	bne	r2,zero,8209278 <_dtoa_r+0x144>
 82091cc:	d9c02317 	ldw	r7,140(sp)
 82091d0:	00800044 	movi	r2,1
 82091d4:	38800015 	stw	r2,0(r7)
 82091d8:	d8802517 	ldw	r2,148(sp)
 82091dc:	10019e26 	beq	r2,zero,8209858 <_dtoa_r+0x724>
 82091e0:	d8c02517 	ldw	r3,148(sp)
 82091e4:	00820974 	movhi	r2,2085
 82091e8:	10b6d344 	addi	r2,r2,-9395
 82091ec:	18800015 	stw	r2,0(r3)
 82091f0:	10bfffc4 	addi	r2,r2,-1
 82091f4:	dfc02117 	ldw	ra,132(sp)
 82091f8:	df002017 	ldw	fp,128(sp)
 82091fc:	ddc01f17 	ldw	r23,124(sp)
 8209200:	dd801e17 	ldw	r22,120(sp)
 8209204:	dd401d17 	ldw	r21,116(sp)
 8209208:	dd001c17 	ldw	r20,112(sp)
 820920c:	dcc01b17 	ldw	r19,108(sp)
 8209210:	dc801a17 	ldw	r18,104(sp)
 8209214:	dc401917 	ldw	r17,100(sp)
 8209218:	dc001817 	ldw	r16,96(sp)
 820921c:	dec02204 	addi	sp,sp,136
 8209220:	f800283a 	ret
 8209224:	d8c02317 	ldw	r3,140(sp)
 8209228:	0089c3c4 	movi	r2,9999
 820922c:	18800015 	stw	r2,0(r3)
 8209230:	90017726 	beq	r18,zero,8209810 <_dtoa_r+0x6dc>
 8209234:	00820974 	movhi	r2,2085
 8209238:	10b6e704 	addi	r2,r2,-9316
 820923c:	d9002517 	ldw	r4,148(sp)
 8209240:	203fec26 	beq	r4,zero,82091f4 <_dtoa_r+0xc0>
 8209244:	10c000c7 	ldb	r3,3(r2)
 8209248:	1801781e 	bne	r3,zero,820982c <_dtoa_r+0x6f8>
 820924c:	10c000c4 	addi	r3,r2,3
 8209250:	d9802517 	ldw	r6,148(sp)
 8209254:	30c00015 	stw	r3,0(r6)
 8209258:	003fe606 	br	82091f4 <_dtoa_r+0xc0>
 820925c:	04e00034 	movhi	r19,32768
 8209260:	9cffffc4 	addi	r19,r19,-1
 8209264:	00800044 	movi	r2,1
 8209268:	8ce6703a 	and	r19,r17,r19
 820926c:	80800015 	stw	r2,0(r16)
 8209270:	9823883a 	mov	r17,r19
 8209274:	003fcc06 	br	82091a8 <_dtoa_r+0x74>
 8209278:	d8800204 	addi	r2,sp,8
 820927c:	d8800015 	stw	r2,0(sp)
 8209280:	d9c00104 	addi	r7,sp,4
 8209284:	900b883a 	mov	r5,r18
 8209288:	980d883a 	mov	r6,r19
 820928c:	e009883a 	mov	r4,fp
 8209290:	8820d53a 	srli	r16,r17,20
 8209294:	820d2680 	call	820d268 <__d2b>
 8209298:	d8800915 	stw	r2,36(sp)
 820929c:	8001651e 	bne	r16,zero,8209834 <_dtoa_r+0x700>
 82092a0:	dd800217 	ldw	r22,8(sp)
 82092a4:	dc000117 	ldw	r16,4(sp)
 82092a8:	00800804 	movi	r2,32
 82092ac:	b421883a 	add	r16,r22,r16
 82092b0:	80c10c84 	addi	r3,r16,1074
 82092b4:	10c2d10e 	bge	r2,r3,8209dfc <_dtoa_r+0xcc8>
 82092b8:	00801004 	movi	r2,64
 82092bc:	81010484 	addi	r4,r16,1042
 82092c0:	10c7c83a 	sub	r3,r2,r3
 82092c4:	9108d83a 	srl	r4,r18,r4
 82092c8:	88e2983a 	sll	r17,r17,r3
 82092cc:	2448b03a 	or	r4,r4,r17
 82092d0:	82142400 	call	8214240 <__floatunsidf>
 82092d4:	017f8434 	movhi	r5,65040
 82092d8:	01800044 	movi	r6,1
 82092dc:	1009883a 	mov	r4,r2
 82092e0:	194b883a 	add	r5,r3,r5
 82092e4:	843fffc4 	addi	r16,r16,-1
 82092e8:	d9801115 	stw	r6,68(sp)
 82092ec:	000d883a 	mov	r6,zero
 82092f0:	01cffe34 	movhi	r7,16376
 82092f4:	82137e80 	call	82137e8 <__subdf3>
 82092f8:	0198dbf4 	movhi	r6,25455
 82092fc:	01cff4f4 	movhi	r7,16339
 8209300:	3190d844 	addi	r6,r6,17249
 8209304:	39e1e9c4 	addi	r7,r7,-30809
 8209308:	1009883a 	mov	r4,r2
 820930c:	180b883a 	mov	r5,r3
 8209310:	82130d00 	call	82130d0 <__muldf3>
 8209314:	01a2d874 	movhi	r6,35681
 8209318:	01cff1f4 	movhi	r7,16327
 820931c:	31b22cc4 	addi	r6,r6,-14157
 8209320:	39e28a04 	addi	r7,r7,-30168
 8209324:	180b883a 	mov	r5,r3
 8209328:	1009883a 	mov	r4,r2
 820932c:	8211ce40 	call	8211ce4 <__adddf3>
 8209330:	8009883a 	mov	r4,r16
 8209334:	1029883a 	mov	r20,r2
 8209338:	1823883a 	mov	r17,r3
 820933c:	82141640 	call	8214164 <__floatsidf>
 8209340:	019427f4 	movhi	r6,20639
 8209344:	01cff4f4 	movhi	r7,16339
 8209348:	319e7ec4 	addi	r6,r6,31227
 820934c:	39d104c4 	addi	r7,r7,17427
 8209350:	1009883a 	mov	r4,r2
 8209354:	180b883a 	mov	r5,r3
 8209358:	82130d00 	call	82130d0 <__muldf3>
 820935c:	100d883a 	mov	r6,r2
 8209360:	180f883a 	mov	r7,r3
 8209364:	a009883a 	mov	r4,r20
 8209368:	880b883a 	mov	r5,r17
 820936c:	8211ce40 	call	8211ce4 <__adddf3>
 8209370:	1009883a 	mov	r4,r2
 8209374:	180b883a 	mov	r5,r3
 8209378:	1029883a 	mov	r20,r2
 820937c:	1823883a 	mov	r17,r3
 8209380:	82140e40 	call	82140e4 <__fixdfsi>
 8209384:	000d883a 	mov	r6,zero
 8209388:	000f883a 	mov	r7,zero
 820938c:	a009883a 	mov	r4,r20
 8209390:	880b883a 	mov	r5,r17
 8209394:	d8800515 	stw	r2,20(sp)
 8209398:	8212fdc0 	call	8212fdc <__ledf2>
 820939c:	10028716 	blt	r2,zero,8209dbc <_dtoa_r+0xc88>
 82093a0:	d8c00517 	ldw	r3,20(sp)
 82093a4:	00800584 	movi	r2,22
 82093a8:	10c27536 	bltu	r2,r3,8209d80 <_dtoa_r+0xc4c>
 82093ac:	180490fa 	slli	r2,r3,3
 82093b0:	00c20974 	movhi	r3,2085
 82093b4:	18f70204 	addi	r3,r3,-9208
 82093b8:	1885883a 	add	r2,r3,r2
 82093bc:	11000017 	ldw	r4,0(r2)
 82093c0:	11400117 	ldw	r5,4(r2)
 82093c4:	900d883a 	mov	r6,r18
 82093c8:	980f883a 	mov	r7,r19
 82093cc:	8212f000 	call	8212f00 <__gedf2>
 82093d0:	00828d0e 	bge	zero,r2,8209e08 <_dtoa_r+0xcd4>
 82093d4:	d9000517 	ldw	r4,20(sp)
 82093d8:	d8000e15 	stw	zero,56(sp)
 82093dc:	213fffc4 	addi	r4,r4,-1
 82093e0:	d9000515 	stw	r4,20(sp)
 82093e4:	b42dc83a 	sub	r22,r22,r16
 82093e8:	b5bfffc4 	addi	r22,r22,-1
 82093ec:	b0026f16 	blt	r22,zero,8209dac <_dtoa_r+0xc78>
 82093f0:	d8000815 	stw	zero,32(sp)
 82093f4:	d9c00517 	ldw	r7,20(sp)
 82093f8:	38026416 	blt	r7,zero,8209d8c <_dtoa_r+0xc58>
 82093fc:	b1ed883a 	add	r22,r22,r7
 8209400:	d9c00d15 	stw	r7,52(sp)
 8209404:	d8000a15 	stw	zero,40(sp)
 8209408:	d9800317 	ldw	r6,12(sp)
 820940c:	00800244 	movi	r2,9
 8209410:	11811436 	bltu	r2,r6,8209864 <_dtoa_r+0x730>
 8209414:	00800144 	movi	r2,5
 8209418:	1184e10e 	bge	r2,r6,820a7a0 <_dtoa_r+0x166c>
 820941c:	31bfff04 	addi	r6,r6,-4
 8209420:	d9800315 	stw	r6,12(sp)
 8209424:	0023883a 	mov	r17,zero
 8209428:	d9800317 	ldw	r6,12(sp)
 820942c:	008000c4 	movi	r2,3
 8209430:	30836726 	beq	r6,r2,820a1d0 <_dtoa_r+0x109c>
 8209434:	1183410e 	bge	r2,r6,820a13c <_dtoa_r+0x1008>
 8209438:	d9c00317 	ldw	r7,12(sp)
 820943c:	00800104 	movi	r2,4
 8209440:	38827c26 	beq	r7,r2,8209e34 <_dtoa_r+0xd00>
 8209444:	00800144 	movi	r2,5
 8209448:	3884c41e 	bne	r7,r2,820a75c <_dtoa_r+0x1628>
 820944c:	00800044 	movi	r2,1
 8209450:	d8800b15 	stw	r2,44(sp)
 8209454:	d8c00517 	ldw	r3,20(sp)
 8209458:	d9002217 	ldw	r4,136(sp)
 820945c:	1907883a 	add	r3,r3,r4
 8209460:	19800044 	addi	r6,r3,1
 8209464:	d8c00c15 	stw	r3,48(sp)
 8209468:	d9800615 	stw	r6,24(sp)
 820946c:	0183a40e 	bge	zero,r6,820a300 <_dtoa_r+0x11cc>
 8209470:	d9800617 	ldw	r6,24(sp)
 8209474:	3021883a 	mov	r16,r6
 8209478:	e0001115 	stw	zero,68(fp)
 820947c:	008005c4 	movi	r2,23
 8209480:	1184c92e 	bgeu	r2,r6,820a7a8 <_dtoa_r+0x1674>
 8209484:	00c00044 	movi	r3,1
 8209488:	00800104 	movi	r2,4
 820948c:	1085883a 	add	r2,r2,r2
 8209490:	11000504 	addi	r4,r2,20
 8209494:	180b883a 	mov	r5,r3
 8209498:	18c00044 	addi	r3,r3,1
 820949c:	313ffb2e 	bgeu	r6,r4,820948c <_dtoa_r+0x358>
 82094a0:	e1401115 	stw	r5,68(fp)
 82094a4:	e009883a 	mov	r4,fp
 82094a8:	820c5d40 	call	820c5d4 <_Balloc>
 82094ac:	d8800715 	stw	r2,28(sp)
 82094b0:	e0801015 	stw	r2,64(fp)
 82094b4:	00800384 	movi	r2,14
 82094b8:	1400f736 	bltu	r2,r16,8209898 <_dtoa_r+0x764>
 82094bc:	8800f626 	beq	r17,zero,8209898 <_dtoa_r+0x764>
 82094c0:	d9c00517 	ldw	r7,20(sp)
 82094c4:	01c39a0e 	bge	zero,r7,820a330 <_dtoa_r+0x11fc>
 82094c8:	388003cc 	andi	r2,r7,15
 82094cc:	100490fa 	slli	r2,r2,3
 82094d0:	382bd13a 	srai	r21,r7,4
 82094d4:	00c20974 	movhi	r3,2085
 82094d8:	18f70204 	addi	r3,r3,-9208
 82094dc:	1885883a 	add	r2,r3,r2
 82094e0:	a8c0040c 	andi	r3,r21,16
 82094e4:	12400017 	ldw	r9,0(r2)
 82094e8:	12000117 	ldw	r8,4(r2)
 82094ec:	18037926 	beq	r3,zero,820a2d4 <_dtoa_r+0x11a0>
 82094f0:	00820974 	movhi	r2,2085
 82094f4:	10b6f804 	addi	r2,r2,-9248
 82094f8:	11800817 	ldw	r6,32(r2)
 82094fc:	11c00917 	ldw	r7,36(r2)
 8209500:	9009883a 	mov	r4,r18
 8209504:	980b883a 	mov	r5,r19
 8209508:	da001715 	stw	r8,92(sp)
 820950c:	da401615 	stw	r9,88(sp)
 8209510:	82125900 	call	8212590 <__divdf3>
 8209514:	da001717 	ldw	r8,92(sp)
 8209518:	da401617 	ldw	r9,88(sp)
 820951c:	ad4003cc 	andi	r21,r21,15
 8209520:	040000c4 	movi	r16,3
 8209524:	1023883a 	mov	r17,r2
 8209528:	1829883a 	mov	r20,r3
 820952c:	a8001126 	beq	r21,zero,8209574 <_dtoa_r+0x440>
 8209530:	05c20974 	movhi	r23,2085
 8209534:	bdf6f804 	addi	r23,r23,-9248
 8209538:	4805883a 	mov	r2,r9
 820953c:	4007883a 	mov	r3,r8
 8209540:	a980004c 	andi	r6,r21,1
 8209544:	1009883a 	mov	r4,r2
 8209548:	a82bd07a 	srai	r21,r21,1
 820954c:	180b883a 	mov	r5,r3
 8209550:	30000426 	beq	r6,zero,8209564 <_dtoa_r+0x430>
 8209554:	b9800017 	ldw	r6,0(r23)
 8209558:	b9c00117 	ldw	r7,4(r23)
 820955c:	84000044 	addi	r16,r16,1
 8209560:	82130d00 	call	82130d0 <__muldf3>
 8209564:	bdc00204 	addi	r23,r23,8
 8209568:	a83ff51e 	bne	r21,zero,8209540 <_dtoa_r+0x40c>
 820956c:	1013883a 	mov	r9,r2
 8209570:	1811883a 	mov	r8,r3
 8209574:	480d883a 	mov	r6,r9
 8209578:	400f883a 	mov	r7,r8
 820957c:	8809883a 	mov	r4,r17
 8209580:	a00b883a 	mov	r5,r20
 8209584:	82125900 	call	8212590 <__divdf3>
 8209588:	d8800f15 	stw	r2,60(sp)
 820958c:	d8c01015 	stw	r3,64(sp)
 8209590:	d8c00e17 	ldw	r3,56(sp)
 8209594:	18000626 	beq	r3,zero,82095b0 <_dtoa_r+0x47c>
 8209598:	d9000f17 	ldw	r4,60(sp)
 820959c:	d9401017 	ldw	r5,64(sp)
 82095a0:	000d883a 	mov	r6,zero
 82095a4:	01cffc34 	movhi	r7,16368
 82095a8:	8212fdc0 	call	8212fdc <__ledf2>
 82095ac:	10040b16 	blt	r2,zero,820a5dc <_dtoa_r+0x14a8>
 82095b0:	8009883a 	mov	r4,r16
 82095b4:	82141640 	call	8214164 <__floatsidf>
 82095b8:	d9800f17 	ldw	r6,60(sp)
 82095bc:	d9c01017 	ldw	r7,64(sp)
 82095c0:	1009883a 	mov	r4,r2
 82095c4:	180b883a 	mov	r5,r3
 82095c8:	82130d00 	call	82130d0 <__muldf3>
 82095cc:	000d883a 	mov	r6,zero
 82095d0:	01d00734 	movhi	r7,16412
 82095d4:	1009883a 	mov	r4,r2
 82095d8:	180b883a 	mov	r5,r3
 82095dc:	8211ce40 	call	8211ce4 <__adddf3>
 82095e0:	1021883a 	mov	r16,r2
 82095e4:	d8800617 	ldw	r2,24(sp)
 82095e8:	047f3034 	movhi	r17,64704
 82095ec:	1c63883a 	add	r17,r3,r17
 82095f0:	10031826 	beq	r2,zero,820a254 <_dtoa_r+0x1120>
 82095f4:	d8c00517 	ldw	r3,20(sp)
 82095f8:	db000617 	ldw	r12,24(sp)
 82095fc:	d8c01315 	stw	r3,76(sp)
 8209600:	d9000b17 	ldw	r4,44(sp)
 8209604:	20038f26 	beq	r4,zero,820a444 <_dtoa_r+0x1310>
 8209608:	60bfffc4 	addi	r2,r12,-1
 820960c:	100490fa 	slli	r2,r2,3
 8209610:	00c20974 	movhi	r3,2085
 8209614:	18f70204 	addi	r3,r3,-9208
 8209618:	1885883a 	add	r2,r3,r2
 820961c:	11800017 	ldw	r6,0(r2)
 8209620:	11c00117 	ldw	r7,4(r2)
 8209624:	d8800717 	ldw	r2,28(sp)
 8209628:	0009883a 	mov	r4,zero
 820962c:	014ff834 	movhi	r5,16352
 8209630:	db001615 	stw	r12,88(sp)
 8209634:	15c00044 	addi	r23,r2,1
 8209638:	82125900 	call	8212590 <__divdf3>
 820963c:	800d883a 	mov	r6,r16
 8209640:	880f883a 	mov	r7,r17
 8209644:	1009883a 	mov	r4,r2
 8209648:	180b883a 	mov	r5,r3
 820964c:	82137e80 	call	82137e8 <__subdf3>
 8209650:	d9401017 	ldw	r5,64(sp)
 8209654:	d9000f17 	ldw	r4,60(sp)
 8209658:	102b883a 	mov	r21,r2
 820965c:	d8c01215 	stw	r3,72(sp)
 8209660:	82140e40 	call	82140e4 <__fixdfsi>
 8209664:	1009883a 	mov	r4,r2
 8209668:	1029883a 	mov	r20,r2
 820966c:	82141640 	call	8214164 <__floatsidf>
 8209670:	d9000f17 	ldw	r4,60(sp)
 8209674:	d9401017 	ldw	r5,64(sp)
 8209678:	100d883a 	mov	r6,r2
 820967c:	180f883a 	mov	r7,r3
 8209680:	82137e80 	call	82137e8 <__subdf3>
 8209684:	1823883a 	mov	r17,r3
 8209688:	d8c00717 	ldw	r3,28(sp)
 820968c:	d9401217 	ldw	r5,72(sp)
 8209690:	a2000c04 	addi	r8,r20,48
 8209694:	1021883a 	mov	r16,r2
 8209698:	1a000005 	stb	r8,0(r3)
 820969c:	800d883a 	mov	r6,r16
 82096a0:	880f883a 	mov	r7,r17
 82096a4:	a809883a 	mov	r4,r21
 82096a8:	4029883a 	mov	r20,r8
 82096ac:	8212f000 	call	8212f00 <__gedf2>
 82096b0:	00841d16 	blt	zero,r2,820a728 <_dtoa_r+0x15f4>
 82096b4:	800d883a 	mov	r6,r16
 82096b8:	880f883a 	mov	r7,r17
 82096bc:	0009883a 	mov	r4,zero
 82096c0:	014ffc34 	movhi	r5,16368
 82096c4:	82137e80 	call	82137e8 <__subdf3>
 82096c8:	d9401217 	ldw	r5,72(sp)
 82096cc:	100d883a 	mov	r6,r2
 82096d0:	180f883a 	mov	r7,r3
 82096d4:	a809883a 	mov	r4,r21
 82096d8:	8212f000 	call	8212f00 <__gedf2>
 82096dc:	db001617 	ldw	r12,88(sp)
 82096e0:	00840e16 	blt	zero,r2,820a71c <_dtoa_r+0x15e8>
 82096e4:	00800044 	movi	r2,1
 82096e8:	13006b0e 	bge	r2,r12,8209898 <_dtoa_r+0x764>
 82096ec:	d9000717 	ldw	r4,28(sp)
 82096f0:	dd800f15 	stw	r22,60(sp)
 82096f4:	dcc01015 	stw	r19,64(sp)
 82096f8:	2319883a 	add	r12,r4,r12
 82096fc:	dcc01217 	ldw	r19,72(sp)
 8209700:	602d883a 	mov	r22,r12
 8209704:	dc801215 	stw	r18,72(sp)
 8209708:	b825883a 	mov	r18,r23
 820970c:	00000906 	br	8209734 <_dtoa_r+0x600>
 8209710:	82137e80 	call	82137e8 <__subdf3>
 8209714:	a80d883a 	mov	r6,r21
 8209718:	980f883a 	mov	r7,r19
 820971c:	1009883a 	mov	r4,r2
 8209720:	180b883a 	mov	r5,r3
 8209724:	8212fdc0 	call	8212fdc <__ledf2>
 8209728:	1003e816 	blt	r2,zero,820a6cc <_dtoa_r+0x1598>
 820972c:	b825883a 	mov	r18,r23
 8209730:	bd83e926 	beq	r23,r22,820a6d8 <_dtoa_r+0x15a4>
 8209734:	a809883a 	mov	r4,r21
 8209738:	980b883a 	mov	r5,r19
 820973c:	000d883a 	mov	r6,zero
 8209740:	01d00934 	movhi	r7,16420
 8209744:	82130d00 	call	82130d0 <__muldf3>
 8209748:	000d883a 	mov	r6,zero
 820974c:	01d00934 	movhi	r7,16420
 8209750:	8009883a 	mov	r4,r16
 8209754:	880b883a 	mov	r5,r17
 8209758:	102b883a 	mov	r21,r2
 820975c:	1827883a 	mov	r19,r3
 8209760:	82130d00 	call	82130d0 <__muldf3>
 8209764:	180b883a 	mov	r5,r3
 8209768:	1009883a 	mov	r4,r2
 820976c:	1821883a 	mov	r16,r3
 8209770:	1023883a 	mov	r17,r2
 8209774:	82140e40 	call	82140e4 <__fixdfsi>
 8209778:	1009883a 	mov	r4,r2
 820977c:	1029883a 	mov	r20,r2
 8209780:	82141640 	call	8214164 <__floatsidf>
 8209784:	8809883a 	mov	r4,r17
 8209788:	800b883a 	mov	r5,r16
 820978c:	100d883a 	mov	r6,r2
 8209790:	180f883a 	mov	r7,r3
 8209794:	82137e80 	call	82137e8 <__subdf3>
 8209798:	a5000c04 	addi	r20,r20,48
 820979c:	a80d883a 	mov	r6,r21
 82097a0:	980f883a 	mov	r7,r19
 82097a4:	1009883a 	mov	r4,r2
 82097a8:	180b883a 	mov	r5,r3
 82097ac:	95000005 	stb	r20,0(r18)
 82097b0:	1021883a 	mov	r16,r2
 82097b4:	1823883a 	mov	r17,r3
 82097b8:	8212fdc0 	call	8212fdc <__ledf2>
 82097bc:	bdc00044 	addi	r23,r23,1
 82097c0:	800d883a 	mov	r6,r16
 82097c4:	880f883a 	mov	r7,r17
 82097c8:	0009883a 	mov	r4,zero
 82097cc:	014ffc34 	movhi	r5,16368
 82097d0:	103fcf0e 	bge	r2,zero,8209710 <_dtoa_r+0x5dc>
 82097d4:	d8c01317 	ldw	r3,76(sp)
 82097d8:	d8c00515 	stw	r3,20(sp)
 82097dc:	d9400917 	ldw	r5,36(sp)
 82097e0:	e009883a 	mov	r4,fp
 82097e4:	820c67c0 	call	820c67c <_Bfree>
 82097e8:	d9000517 	ldw	r4,20(sp)
 82097ec:	d9802317 	ldw	r6,140(sp)
 82097f0:	d9c02517 	ldw	r7,148(sp)
 82097f4:	b8000005 	stb	zero,0(r23)
 82097f8:	20800044 	addi	r2,r4,1
 82097fc:	30800015 	stw	r2,0(r6)
 8209800:	3802aa26 	beq	r7,zero,820a2ac <_dtoa_r+0x1178>
 8209804:	3dc00015 	stw	r23,0(r7)
 8209808:	d8800717 	ldw	r2,28(sp)
 820980c:	003e7906 	br	82091f4 <_dtoa_r+0xc0>
 8209810:	00800434 	movhi	r2,16
 8209814:	10bfffc4 	addi	r2,r2,-1
 8209818:	88a2703a 	and	r17,r17,r2
 820981c:	883e851e 	bne	r17,zero,8209234 <_dtoa_r+0x100>
 8209820:	00820974 	movhi	r2,2085
 8209824:	10b6e404 	addi	r2,r2,-9328
 8209828:	003e8406 	br	820923c <_dtoa_r+0x108>
 820982c:	10c00204 	addi	r3,r2,8
 8209830:	003e8706 	br	8209250 <_dtoa_r+0x11c>
 8209834:	01400434 	movhi	r5,16
 8209838:	297fffc4 	addi	r5,r5,-1
 820983c:	994a703a 	and	r5,r19,r5
 8209840:	9009883a 	mov	r4,r18
 8209844:	843f0044 	addi	r16,r16,-1023
 8209848:	294ffc34 	orhi	r5,r5,16368
 820984c:	dd800217 	ldw	r22,8(sp)
 8209850:	d8001115 	stw	zero,68(sp)
 8209854:	003ea506 	br	82092ec <_dtoa_r+0x1b8>
 8209858:	00820974 	movhi	r2,2085
 820985c:	10b6d304 	addi	r2,r2,-9396
 8209860:	003e6406 	br	82091f4 <_dtoa_r+0xc0>
 8209864:	e0001115 	stw	zero,68(fp)
 8209868:	000b883a 	mov	r5,zero
 820986c:	e009883a 	mov	r4,fp
 8209870:	820c5d40 	call	820c5d4 <_Balloc>
 8209874:	01bfffc4 	movi	r6,-1
 8209878:	01c00044 	movi	r7,1
 820987c:	d8800715 	stw	r2,28(sp)
 8209880:	d9800c15 	stw	r6,48(sp)
 8209884:	e0801015 	stw	r2,64(fp)
 8209888:	d8000315 	stw	zero,12(sp)
 820988c:	d9c00b15 	stw	r7,44(sp)
 8209890:	d9800615 	stw	r6,24(sp)
 8209894:	d8002215 	stw	zero,136(sp)
 8209898:	d8800117 	ldw	r2,4(sp)
 820989c:	10008916 	blt	r2,zero,8209ac4 <_dtoa_r+0x990>
 82098a0:	d9000517 	ldw	r4,20(sp)
 82098a4:	00c00384 	movi	r3,14
 82098a8:	19008616 	blt	r3,r4,8209ac4 <_dtoa_r+0x990>
 82098ac:	200490fa 	slli	r2,r4,3
 82098b0:	00c20974 	movhi	r3,2085
 82098b4:	d9802217 	ldw	r6,136(sp)
 82098b8:	18f70204 	addi	r3,r3,-9208
 82098bc:	1885883a 	add	r2,r3,r2
 82098c0:	14000017 	ldw	r16,0(r2)
 82098c4:	14400117 	ldw	r17,4(r2)
 82098c8:	30016316 	blt	r6,zero,8209e58 <_dtoa_r+0xd24>
 82098cc:	800d883a 	mov	r6,r16
 82098d0:	880f883a 	mov	r7,r17
 82098d4:	9009883a 	mov	r4,r18
 82098d8:	980b883a 	mov	r5,r19
 82098dc:	82125900 	call	8212590 <__divdf3>
 82098e0:	180b883a 	mov	r5,r3
 82098e4:	1009883a 	mov	r4,r2
 82098e8:	82140e40 	call	82140e4 <__fixdfsi>
 82098ec:	1009883a 	mov	r4,r2
 82098f0:	102b883a 	mov	r21,r2
 82098f4:	82141640 	call	8214164 <__floatsidf>
 82098f8:	800d883a 	mov	r6,r16
 82098fc:	880f883a 	mov	r7,r17
 8209900:	1009883a 	mov	r4,r2
 8209904:	180b883a 	mov	r5,r3
 8209908:	82130d00 	call	82130d0 <__muldf3>
 820990c:	100d883a 	mov	r6,r2
 8209910:	180f883a 	mov	r7,r3
 8209914:	9009883a 	mov	r4,r18
 8209918:	980b883a 	mov	r5,r19
 820991c:	82137e80 	call	82137e8 <__subdf3>
 8209920:	d9c00717 	ldw	r7,28(sp)
 8209924:	1009883a 	mov	r4,r2
 8209928:	a8800c04 	addi	r2,r21,48
 820992c:	38800005 	stb	r2,0(r7)
 8209930:	3dc00044 	addi	r23,r7,1
 8209934:	d9c00617 	ldw	r7,24(sp)
 8209938:	01800044 	movi	r6,1
 820993c:	180b883a 	mov	r5,r3
 8209940:	2005883a 	mov	r2,r4
 8209944:	39803826 	beq	r7,r6,8209a28 <_dtoa_r+0x8f4>
 8209948:	000d883a 	mov	r6,zero
 820994c:	01d00934 	movhi	r7,16420
 8209950:	82130d00 	call	82130d0 <__muldf3>
 8209954:	000d883a 	mov	r6,zero
 8209958:	000f883a 	mov	r7,zero
 820995c:	1009883a 	mov	r4,r2
 8209960:	180b883a 	mov	r5,r3
 8209964:	1025883a 	mov	r18,r2
 8209968:	1827883a 	mov	r19,r3
 820996c:	8212e780 	call	8212e78 <__eqdf2>
 8209970:	103f9a26 	beq	r2,zero,82097dc <_dtoa_r+0x6a8>
 8209974:	d9c00617 	ldw	r7,24(sp)
 8209978:	d8c00717 	ldw	r3,28(sp)
 820997c:	b829883a 	mov	r20,r23
 8209980:	38bfffc4 	addi	r2,r7,-1
 8209984:	18ad883a 	add	r22,r3,r2
 8209988:	00000a06 	br	82099b4 <_dtoa_r+0x880>
 820998c:	82130d00 	call	82130d0 <__muldf3>
 8209990:	000d883a 	mov	r6,zero
 8209994:	000f883a 	mov	r7,zero
 8209998:	1009883a 	mov	r4,r2
 820999c:	180b883a 	mov	r5,r3
 82099a0:	1025883a 	mov	r18,r2
 82099a4:	1827883a 	mov	r19,r3
 82099a8:	b829883a 	mov	r20,r23
 82099ac:	8212e780 	call	8212e78 <__eqdf2>
 82099b0:	103f8a26 	beq	r2,zero,82097dc <_dtoa_r+0x6a8>
 82099b4:	800d883a 	mov	r6,r16
 82099b8:	880f883a 	mov	r7,r17
 82099bc:	9009883a 	mov	r4,r18
 82099c0:	980b883a 	mov	r5,r19
 82099c4:	82125900 	call	8212590 <__divdf3>
 82099c8:	180b883a 	mov	r5,r3
 82099cc:	1009883a 	mov	r4,r2
 82099d0:	82140e40 	call	82140e4 <__fixdfsi>
 82099d4:	1009883a 	mov	r4,r2
 82099d8:	102b883a 	mov	r21,r2
 82099dc:	82141640 	call	8214164 <__floatsidf>
 82099e0:	800d883a 	mov	r6,r16
 82099e4:	880f883a 	mov	r7,r17
 82099e8:	1009883a 	mov	r4,r2
 82099ec:	180b883a 	mov	r5,r3
 82099f0:	82130d00 	call	82130d0 <__muldf3>
 82099f4:	100d883a 	mov	r6,r2
 82099f8:	180f883a 	mov	r7,r3
 82099fc:	9009883a 	mov	r4,r18
 8209a00:	980b883a 	mov	r5,r19
 8209a04:	82137e80 	call	82137e8 <__subdf3>
 8209a08:	aa000c04 	addi	r8,r21,48
 8209a0c:	a2000005 	stb	r8,0(r20)
 8209a10:	000d883a 	mov	r6,zero
 8209a14:	01d00934 	movhi	r7,16420
 8209a18:	1009883a 	mov	r4,r2
 8209a1c:	180b883a 	mov	r5,r3
 8209a20:	a5c00044 	addi	r23,r20,1
 8209a24:	b53fd91e 	bne	r22,r20,820998c <_dtoa_r+0x858>
 8209a28:	100d883a 	mov	r6,r2
 8209a2c:	180f883a 	mov	r7,r3
 8209a30:	1009883a 	mov	r4,r2
 8209a34:	180b883a 	mov	r5,r3
 8209a38:	8211ce40 	call	8211ce4 <__adddf3>
 8209a3c:	100d883a 	mov	r6,r2
 8209a40:	180f883a 	mov	r7,r3
 8209a44:	8009883a 	mov	r4,r16
 8209a48:	880b883a 	mov	r5,r17
 8209a4c:	1027883a 	mov	r19,r2
 8209a50:	1825883a 	mov	r18,r3
 8209a54:	8212fdc0 	call	8212fdc <__ledf2>
 8209a58:	10000816 	blt	r2,zero,8209a7c <_dtoa_r+0x948>
 8209a5c:	980d883a 	mov	r6,r19
 8209a60:	900f883a 	mov	r7,r18
 8209a64:	8009883a 	mov	r4,r16
 8209a68:	880b883a 	mov	r5,r17
 8209a6c:	8212e780 	call	8212e78 <__eqdf2>
 8209a70:	103f5a1e 	bne	r2,zero,82097dc <_dtoa_r+0x6a8>
 8209a74:	ad40004c 	andi	r21,r21,1
 8209a78:	a83f5826 	beq	r21,zero,82097dc <_dtoa_r+0x6a8>
 8209a7c:	bd3fffc3 	ldbu	r20,-1(r23)
 8209a80:	b8bfffc4 	addi	r2,r23,-1
 8209a84:	1007883a 	mov	r3,r2
 8209a88:	01400e44 	movi	r5,57
 8209a8c:	d9800717 	ldw	r6,28(sp)
 8209a90:	00000506 	br	8209aa8 <_dtoa_r+0x974>
 8209a94:	18ffffc4 	addi	r3,r3,-1
 8209a98:	11824726 	beq	r2,r6,820a3b8 <_dtoa_r+0x1284>
 8209a9c:	1d000003 	ldbu	r20,0(r3)
 8209aa0:	102f883a 	mov	r23,r2
 8209aa4:	10bfffc4 	addi	r2,r2,-1
 8209aa8:	a1003fcc 	andi	r4,r20,255
 8209aac:	2100201c 	xori	r4,r4,128
 8209ab0:	213fe004 	addi	r4,r4,-128
 8209ab4:	217ff726 	beq	r4,r5,8209a94 <_dtoa_r+0x960>
 8209ab8:	a2000044 	addi	r8,r20,1
 8209abc:	12000005 	stb	r8,0(r2)
 8209ac0:	003f4606 	br	82097dc <_dtoa_r+0x6a8>
 8209ac4:	d9000b17 	ldw	r4,44(sp)
 8209ac8:	2000c826 	beq	r4,zero,8209dec <_dtoa_r+0xcb8>
 8209acc:	d9800317 	ldw	r6,12(sp)
 8209ad0:	00c00044 	movi	r3,1
 8209ad4:	1980f90e 	bge	r3,r6,8209ebc <_dtoa_r+0xd88>
 8209ad8:	d8800617 	ldw	r2,24(sp)
 8209adc:	d8c00a17 	ldw	r3,40(sp)
 8209ae0:	157fffc4 	addi	r21,r2,-1
 8209ae4:	1d41f316 	blt	r3,r21,820a2b4 <_dtoa_r+0x1180>
 8209ae8:	1d6bc83a 	sub	r21,r3,r21
 8209aec:	d9c00617 	ldw	r7,24(sp)
 8209af0:	3802aa16 	blt	r7,zero,820a59c <_dtoa_r+0x1468>
 8209af4:	dd000817 	ldw	r20,32(sp)
 8209af8:	d8800617 	ldw	r2,24(sp)
 8209afc:	d8c00817 	ldw	r3,32(sp)
 8209b00:	01400044 	movi	r5,1
 8209b04:	e009883a 	mov	r4,fp
 8209b08:	1887883a 	add	r3,r3,r2
 8209b0c:	d8c00815 	stw	r3,32(sp)
 8209b10:	b0ad883a 	add	r22,r22,r2
 8209b14:	820c9e00 	call	820c9e0 <__i2b>
 8209b18:	1023883a 	mov	r17,r2
 8209b1c:	a0000826 	beq	r20,zero,8209b40 <_dtoa_r+0xa0c>
 8209b20:	0580070e 	bge	zero,r22,8209b40 <_dtoa_r+0xa0c>
 8209b24:	a005883a 	mov	r2,r20
 8209b28:	b500b916 	blt	r22,r20,8209e10 <_dtoa_r+0xcdc>
 8209b2c:	d9000817 	ldw	r4,32(sp)
 8209b30:	a0a9c83a 	sub	r20,r20,r2
 8209b34:	b0adc83a 	sub	r22,r22,r2
 8209b38:	2089c83a 	sub	r4,r4,r2
 8209b3c:	d9000815 	stw	r4,32(sp)
 8209b40:	d9800a17 	ldw	r6,40(sp)
 8209b44:	0181810e 	bge	zero,r6,820a14c <_dtoa_r+0x1018>
 8209b48:	d9c00b17 	ldw	r7,44(sp)
 8209b4c:	3800b326 	beq	r7,zero,8209e1c <_dtoa_r+0xce8>
 8209b50:	a800b226 	beq	r21,zero,8209e1c <_dtoa_r+0xce8>
 8209b54:	880b883a 	mov	r5,r17
 8209b58:	a80d883a 	mov	r6,r21
 8209b5c:	e009883a 	mov	r4,fp
 8209b60:	820cc140 	call	820cc14 <__pow5mult>
 8209b64:	d9800917 	ldw	r6,36(sp)
 8209b68:	100b883a 	mov	r5,r2
 8209b6c:	e009883a 	mov	r4,fp
 8209b70:	1023883a 	mov	r17,r2
 8209b74:	820ca1c0 	call	820ca1c <__multiply>
 8209b78:	1021883a 	mov	r16,r2
 8209b7c:	d8800a17 	ldw	r2,40(sp)
 8209b80:	d9400917 	ldw	r5,36(sp)
 8209b84:	e009883a 	mov	r4,fp
 8209b88:	1545c83a 	sub	r2,r2,r21
 8209b8c:	d8800a15 	stw	r2,40(sp)
 8209b90:	820c67c0 	call	820c67c <_Bfree>
 8209b94:	d8c00a17 	ldw	r3,40(sp)
 8209b98:	18009f1e 	bne	r3,zero,8209e18 <_dtoa_r+0xce4>
 8209b9c:	05c00044 	movi	r23,1
 8209ba0:	e009883a 	mov	r4,fp
 8209ba4:	b80b883a 	mov	r5,r23
 8209ba8:	820c9e00 	call	820c9e0 <__i2b>
 8209bac:	d9000d17 	ldw	r4,52(sp)
 8209bb0:	102b883a 	mov	r21,r2
 8209bb4:	2000ce26 	beq	r4,zero,8209ef0 <_dtoa_r+0xdbc>
 8209bb8:	200d883a 	mov	r6,r4
 8209bbc:	100b883a 	mov	r5,r2
 8209bc0:	e009883a 	mov	r4,fp
 8209bc4:	820cc140 	call	820cc14 <__pow5mult>
 8209bc8:	d9800317 	ldw	r6,12(sp)
 8209bcc:	102b883a 	mov	r21,r2
 8209bd0:	b981810e 	bge	r23,r6,820a1d8 <_dtoa_r+0x10a4>
 8209bd4:	0027883a 	mov	r19,zero
 8209bd8:	a8800417 	ldw	r2,16(r21)
 8209bdc:	05c00804 	movi	r23,32
 8209be0:	10800104 	addi	r2,r2,4
 8209be4:	1085883a 	add	r2,r2,r2
 8209be8:	1085883a 	add	r2,r2,r2
 8209bec:	a885883a 	add	r2,r21,r2
 8209bf0:	11000017 	ldw	r4,0(r2)
 8209bf4:	820c8c80 	call	820c8c8 <__hi0bits>
 8209bf8:	b885c83a 	sub	r2,r23,r2
 8209bfc:	1585883a 	add	r2,r2,r22
 8209c00:	108007cc 	andi	r2,r2,31
 8209c04:	1000b326 	beq	r2,zero,8209ed4 <_dtoa_r+0xda0>
 8209c08:	00c00804 	movi	r3,32
 8209c0c:	1887c83a 	sub	r3,r3,r2
 8209c10:	01000104 	movi	r4,4
 8209c14:	20c2cd0e 	bge	r4,r3,820a74c <_dtoa_r+0x1618>
 8209c18:	00c00704 	movi	r3,28
 8209c1c:	1885c83a 	sub	r2,r3,r2
 8209c20:	d8c00817 	ldw	r3,32(sp)
 8209c24:	a0a9883a 	add	r20,r20,r2
 8209c28:	b0ad883a 	add	r22,r22,r2
 8209c2c:	1887883a 	add	r3,r3,r2
 8209c30:	d8c00815 	stw	r3,32(sp)
 8209c34:	d9800817 	ldw	r6,32(sp)
 8209c38:	0180040e 	bge	zero,r6,8209c4c <_dtoa_r+0xb18>
 8209c3c:	800b883a 	mov	r5,r16
 8209c40:	e009883a 	mov	r4,fp
 8209c44:	820cd540 	call	820cd54 <__lshift>
 8209c48:	1021883a 	mov	r16,r2
 8209c4c:	0580050e 	bge	zero,r22,8209c64 <_dtoa_r+0xb30>
 8209c50:	a80b883a 	mov	r5,r21
 8209c54:	b00d883a 	mov	r6,r22
 8209c58:	e009883a 	mov	r4,fp
 8209c5c:	820cd540 	call	820cd54 <__lshift>
 8209c60:	102b883a 	mov	r21,r2
 8209c64:	d9c00e17 	ldw	r7,56(sp)
 8209c68:	3801211e 	bne	r7,zero,820a0f0 <_dtoa_r+0xfbc>
 8209c6c:	d9800617 	ldw	r6,24(sp)
 8209c70:	0181380e 	bge	zero,r6,820a154 <_dtoa_r+0x1020>
 8209c74:	d8c00b17 	ldw	r3,44(sp)
 8209c78:	1800ab1e 	bne	r3,zero,8209f28 <_dtoa_r+0xdf4>
 8209c7c:	dc800717 	ldw	r18,28(sp)
 8209c80:	dcc00617 	ldw	r19,24(sp)
 8209c84:	9029883a 	mov	r20,r18
 8209c88:	00000206 	br	8209c94 <_dtoa_r+0xb60>
 8209c8c:	820c6a40 	call	820c6a4 <__multadd>
 8209c90:	1021883a 	mov	r16,r2
 8209c94:	a80b883a 	mov	r5,r21
 8209c98:	8009883a 	mov	r4,r16
 8209c9c:	8208f340 	call	8208f34 <quorem>
 8209ca0:	10800c04 	addi	r2,r2,48
 8209ca4:	90800005 	stb	r2,0(r18)
 8209ca8:	94800044 	addi	r18,r18,1
 8209cac:	9507c83a 	sub	r3,r18,r20
 8209cb0:	000f883a 	mov	r7,zero
 8209cb4:	01800284 	movi	r6,10
 8209cb8:	800b883a 	mov	r5,r16
 8209cbc:	e009883a 	mov	r4,fp
 8209cc0:	1cfff216 	blt	r3,r19,8209c8c <_dtoa_r+0xb58>
 8209cc4:	1011883a 	mov	r8,r2
 8209cc8:	d8800617 	ldw	r2,24(sp)
 8209ccc:	0082370e 	bge	zero,r2,820a5ac <_dtoa_r+0x1478>
 8209cd0:	d9000717 	ldw	r4,28(sp)
 8209cd4:	0025883a 	mov	r18,zero
 8209cd8:	20af883a 	add	r23,r4,r2
 8209cdc:	01800044 	movi	r6,1
 8209ce0:	800b883a 	mov	r5,r16
 8209ce4:	e009883a 	mov	r4,fp
 8209ce8:	da001715 	stw	r8,92(sp)
 8209cec:	820cd540 	call	820cd54 <__lshift>
 8209cf0:	a80b883a 	mov	r5,r21
 8209cf4:	1009883a 	mov	r4,r2
 8209cf8:	d8800915 	stw	r2,36(sp)
 8209cfc:	820ce9c0 	call	820ce9c <__mcmp>
 8209d00:	da001717 	ldw	r8,92(sp)
 8209d04:	0081800e 	bge	zero,r2,820a308 <_dtoa_r+0x11d4>
 8209d08:	b93fffc3 	ldbu	r4,-1(r23)
 8209d0c:	b8bfffc4 	addi	r2,r23,-1
 8209d10:	1007883a 	mov	r3,r2
 8209d14:	01800e44 	movi	r6,57
 8209d18:	d9c00717 	ldw	r7,28(sp)
 8209d1c:	00000506 	br	8209d34 <_dtoa_r+0xc00>
 8209d20:	18ffffc4 	addi	r3,r3,-1
 8209d24:	11c12326 	beq	r2,r7,820a1b4 <_dtoa_r+0x1080>
 8209d28:	19000003 	ldbu	r4,0(r3)
 8209d2c:	102f883a 	mov	r23,r2
 8209d30:	10bfffc4 	addi	r2,r2,-1
 8209d34:	21403fcc 	andi	r5,r4,255
 8209d38:	2940201c 	xori	r5,r5,128
 8209d3c:	297fe004 	addi	r5,r5,-128
 8209d40:	29bff726 	beq	r5,r6,8209d20 <_dtoa_r+0xbec>
 8209d44:	21000044 	addi	r4,r4,1
 8209d48:	11000005 	stb	r4,0(r2)
 8209d4c:	a80b883a 	mov	r5,r21
 8209d50:	e009883a 	mov	r4,fp
 8209d54:	820c67c0 	call	820c67c <_Bfree>
 8209d58:	883ea026 	beq	r17,zero,82097dc <_dtoa_r+0x6a8>
 8209d5c:	90000426 	beq	r18,zero,8209d70 <_dtoa_r+0xc3c>
 8209d60:	94400326 	beq	r18,r17,8209d70 <_dtoa_r+0xc3c>
 8209d64:	900b883a 	mov	r5,r18
 8209d68:	e009883a 	mov	r4,fp
 8209d6c:	820c67c0 	call	820c67c <_Bfree>
 8209d70:	880b883a 	mov	r5,r17
 8209d74:	e009883a 	mov	r4,fp
 8209d78:	820c67c0 	call	820c67c <_Bfree>
 8209d7c:	003e9706 	br	82097dc <_dtoa_r+0x6a8>
 8209d80:	01800044 	movi	r6,1
 8209d84:	d9800e15 	stw	r6,56(sp)
 8209d88:	003d9606 	br	82093e4 <_dtoa_r+0x2b0>
 8209d8c:	d8800817 	ldw	r2,32(sp)
 8209d90:	d8c00517 	ldw	r3,20(sp)
 8209d94:	d8000d15 	stw	zero,52(sp)
 8209d98:	10c5c83a 	sub	r2,r2,r3
 8209d9c:	00c9c83a 	sub	r4,zero,r3
 8209da0:	d8800815 	stw	r2,32(sp)
 8209da4:	d9000a15 	stw	r4,40(sp)
 8209da8:	003d9706 	br	8209408 <_dtoa_r+0x2d4>
 8209dac:	05adc83a 	sub	r22,zero,r22
 8209db0:	dd800815 	stw	r22,32(sp)
 8209db4:	002d883a 	mov	r22,zero
 8209db8:	003d8e06 	br	82093f4 <_dtoa_r+0x2c0>
 8209dbc:	d9000517 	ldw	r4,20(sp)
 8209dc0:	82141640 	call	8214164 <__floatsidf>
 8209dc4:	100d883a 	mov	r6,r2
 8209dc8:	180f883a 	mov	r7,r3
 8209dcc:	a009883a 	mov	r4,r20
 8209dd0:	880b883a 	mov	r5,r17
 8209dd4:	8212e780 	call	8212e78 <__eqdf2>
 8209dd8:	103d7126 	beq	r2,zero,82093a0 <_dtoa_r+0x26c>
 8209ddc:	d9c00517 	ldw	r7,20(sp)
 8209de0:	39ffffc4 	addi	r7,r7,-1
 8209de4:	d9c00515 	stw	r7,20(sp)
 8209de8:	003d6d06 	br	82093a0 <_dtoa_r+0x26c>
 8209dec:	dd400a17 	ldw	r21,40(sp)
 8209df0:	dd000817 	ldw	r20,32(sp)
 8209df4:	0023883a 	mov	r17,zero
 8209df8:	003f4806 	br	8209b1c <_dtoa_r+0x9e8>
 8209dfc:	10e3c83a 	sub	r17,r2,r3
 8209e00:	9448983a 	sll	r4,r18,r17
 8209e04:	003d3206 	br	82092d0 <_dtoa_r+0x19c>
 8209e08:	d8000e15 	stw	zero,56(sp)
 8209e0c:	003d7506 	br	82093e4 <_dtoa_r+0x2b0>
 8209e10:	b005883a 	mov	r2,r22
 8209e14:	003f4506 	br	8209b2c <_dtoa_r+0x9f8>
 8209e18:	dc000915 	stw	r16,36(sp)
 8209e1c:	d9800a17 	ldw	r6,40(sp)
 8209e20:	d9400917 	ldw	r5,36(sp)
 8209e24:	e009883a 	mov	r4,fp
 8209e28:	820cc140 	call	820cc14 <__pow5mult>
 8209e2c:	1021883a 	mov	r16,r2
 8209e30:	003f5a06 	br	8209b9c <_dtoa_r+0xa68>
 8209e34:	01c00044 	movi	r7,1
 8209e38:	d9c00b15 	stw	r7,44(sp)
 8209e3c:	d8802217 	ldw	r2,136(sp)
 8209e40:	0081280e 	bge	zero,r2,820a2e4 <_dtoa_r+0x11b0>
 8209e44:	100d883a 	mov	r6,r2
 8209e48:	1021883a 	mov	r16,r2
 8209e4c:	d8800c15 	stw	r2,48(sp)
 8209e50:	d8800615 	stw	r2,24(sp)
 8209e54:	003d8806 	br	8209478 <_dtoa_r+0x344>
 8209e58:	d8800617 	ldw	r2,24(sp)
 8209e5c:	00be9b16 	blt	zero,r2,82098cc <_dtoa_r+0x798>
 8209e60:	10010f1e 	bne	r2,zero,820a2a0 <_dtoa_r+0x116c>
 8209e64:	880b883a 	mov	r5,r17
 8209e68:	000d883a 	mov	r6,zero
 8209e6c:	01d00534 	movhi	r7,16404
 8209e70:	8009883a 	mov	r4,r16
 8209e74:	82130d00 	call	82130d0 <__muldf3>
 8209e78:	900d883a 	mov	r6,r18
 8209e7c:	980f883a 	mov	r7,r19
 8209e80:	1009883a 	mov	r4,r2
 8209e84:	180b883a 	mov	r5,r3
 8209e88:	8212f000 	call	8212f00 <__gedf2>
 8209e8c:	002b883a 	mov	r21,zero
 8209e90:	0023883a 	mov	r17,zero
 8209e94:	1000bf16 	blt	r2,zero,820a194 <_dtoa_r+0x1060>
 8209e98:	d9802217 	ldw	r6,136(sp)
 8209e9c:	ddc00717 	ldw	r23,28(sp)
 8209ea0:	018c303a 	nor	r6,zero,r6
 8209ea4:	d9800515 	stw	r6,20(sp)
 8209ea8:	a80b883a 	mov	r5,r21
 8209eac:	e009883a 	mov	r4,fp
 8209eb0:	820c67c0 	call	820c67c <_Bfree>
 8209eb4:	883e4926 	beq	r17,zero,82097dc <_dtoa_r+0x6a8>
 8209eb8:	003fad06 	br	8209d70 <_dtoa_r+0xc3c>
 8209ebc:	d9c01117 	ldw	r7,68(sp)
 8209ec0:	3801bc26 	beq	r7,zero,820a5b4 <_dtoa_r+0x1480>
 8209ec4:	10810cc4 	addi	r2,r2,1075
 8209ec8:	dd400a17 	ldw	r21,40(sp)
 8209ecc:	dd000817 	ldw	r20,32(sp)
 8209ed0:	003f0a06 	br	8209afc <_dtoa_r+0x9c8>
 8209ed4:	00800704 	movi	r2,28
 8209ed8:	d9000817 	ldw	r4,32(sp)
 8209edc:	a0a9883a 	add	r20,r20,r2
 8209ee0:	b0ad883a 	add	r22,r22,r2
 8209ee4:	2089883a 	add	r4,r4,r2
 8209ee8:	d9000815 	stw	r4,32(sp)
 8209eec:	003f5106 	br	8209c34 <_dtoa_r+0xb00>
 8209ef0:	d8c00317 	ldw	r3,12(sp)
 8209ef4:	b8c1fc0e 	bge	r23,r3,820a6e8 <_dtoa_r+0x15b4>
 8209ef8:	0027883a 	mov	r19,zero
 8209efc:	b805883a 	mov	r2,r23
 8209f00:	003f3e06 	br	8209bfc <_dtoa_r+0xac8>
 8209f04:	880b883a 	mov	r5,r17
 8209f08:	e009883a 	mov	r4,fp
 8209f0c:	000f883a 	mov	r7,zero
 8209f10:	01800284 	movi	r6,10
 8209f14:	820c6a40 	call	820c6a4 <__multadd>
 8209f18:	d9000c17 	ldw	r4,48(sp)
 8209f1c:	1023883a 	mov	r17,r2
 8209f20:	0102040e 	bge	zero,r4,820a734 <_dtoa_r+0x1600>
 8209f24:	d9000615 	stw	r4,24(sp)
 8209f28:	0500050e 	bge	zero,r20,8209f40 <_dtoa_r+0xe0c>
 8209f2c:	880b883a 	mov	r5,r17
 8209f30:	a00d883a 	mov	r6,r20
 8209f34:	e009883a 	mov	r4,fp
 8209f38:	820cd540 	call	820cd54 <__lshift>
 8209f3c:	1023883a 	mov	r17,r2
 8209f40:	9801241e 	bne	r19,zero,820a3d4 <_dtoa_r+0x12a0>
 8209f44:	8829883a 	mov	r20,r17
 8209f48:	d9000617 	ldw	r4,24(sp)
 8209f4c:	dcc00717 	ldw	r19,28(sp)
 8209f50:	9480004c 	andi	r18,r18,1
 8209f54:	20bfffc4 	addi	r2,r4,-1
 8209f58:	9885883a 	add	r2,r19,r2
 8209f5c:	d8800415 	stw	r2,16(sp)
 8209f60:	dc800615 	stw	r18,24(sp)
 8209f64:	a80b883a 	mov	r5,r21
 8209f68:	8009883a 	mov	r4,r16
 8209f6c:	8208f340 	call	8208f34 <quorem>
 8209f70:	880b883a 	mov	r5,r17
 8209f74:	8009883a 	mov	r4,r16
 8209f78:	102f883a 	mov	r23,r2
 8209f7c:	820ce9c0 	call	820ce9c <__mcmp>
 8209f80:	a80b883a 	mov	r5,r21
 8209f84:	a00d883a 	mov	r6,r20
 8209f88:	e009883a 	mov	r4,fp
 8209f8c:	102d883a 	mov	r22,r2
 8209f90:	820cefc0 	call	820cefc <__mdiff>
 8209f94:	1007883a 	mov	r3,r2
 8209f98:	10800317 	ldw	r2,12(r2)
 8209f9c:	bc800c04 	addi	r18,r23,48
 8209fa0:	180b883a 	mov	r5,r3
 8209fa4:	10004e1e 	bne	r2,zero,820a0e0 <_dtoa_r+0xfac>
 8209fa8:	8009883a 	mov	r4,r16
 8209fac:	d8c01615 	stw	r3,88(sp)
 8209fb0:	820ce9c0 	call	820ce9c <__mcmp>
 8209fb4:	d8c01617 	ldw	r3,88(sp)
 8209fb8:	e009883a 	mov	r4,fp
 8209fbc:	d8801615 	stw	r2,88(sp)
 8209fc0:	180b883a 	mov	r5,r3
 8209fc4:	820c67c0 	call	820c67c <_Bfree>
 8209fc8:	d8801617 	ldw	r2,88(sp)
 8209fcc:	1000041e 	bne	r2,zero,8209fe0 <_dtoa_r+0xeac>
 8209fd0:	d9800317 	ldw	r6,12(sp)
 8209fd4:	3000021e 	bne	r6,zero,8209fe0 <_dtoa_r+0xeac>
 8209fd8:	d8c00617 	ldw	r3,24(sp)
 8209fdc:	18003726 	beq	r3,zero,820a0bc <_dtoa_r+0xf88>
 8209fe0:	b0002016 	blt	r22,zero,820a064 <_dtoa_r+0xf30>
 8209fe4:	b000041e 	bne	r22,zero,8209ff8 <_dtoa_r+0xec4>
 8209fe8:	d9000317 	ldw	r4,12(sp)
 8209fec:	2000021e 	bne	r4,zero,8209ff8 <_dtoa_r+0xec4>
 8209ff0:	d8c00617 	ldw	r3,24(sp)
 8209ff4:	18001b26 	beq	r3,zero,820a064 <_dtoa_r+0xf30>
 8209ff8:	00810716 	blt	zero,r2,820a418 <_dtoa_r+0x12e4>
 8209ffc:	d8c00417 	ldw	r3,16(sp)
 820a000:	9d800044 	addi	r22,r19,1
 820a004:	9c800005 	stb	r18,0(r19)
 820a008:	b02f883a 	mov	r23,r22
 820a00c:	98c10626 	beq	r19,r3,820a428 <_dtoa_r+0x12f4>
 820a010:	800b883a 	mov	r5,r16
 820a014:	000f883a 	mov	r7,zero
 820a018:	01800284 	movi	r6,10
 820a01c:	e009883a 	mov	r4,fp
 820a020:	820c6a40 	call	820c6a4 <__multadd>
 820a024:	1021883a 	mov	r16,r2
 820a028:	000f883a 	mov	r7,zero
 820a02c:	01800284 	movi	r6,10
 820a030:	880b883a 	mov	r5,r17
 820a034:	e009883a 	mov	r4,fp
 820a038:	8d002526 	beq	r17,r20,820a0d0 <_dtoa_r+0xf9c>
 820a03c:	820c6a40 	call	820c6a4 <__multadd>
 820a040:	a00b883a 	mov	r5,r20
 820a044:	000f883a 	mov	r7,zero
 820a048:	01800284 	movi	r6,10
 820a04c:	e009883a 	mov	r4,fp
 820a050:	1023883a 	mov	r17,r2
 820a054:	820c6a40 	call	820c6a4 <__multadd>
 820a058:	1029883a 	mov	r20,r2
 820a05c:	b027883a 	mov	r19,r22
 820a060:	003fc006 	br	8209f64 <_dtoa_r+0xe30>
 820a064:	9011883a 	mov	r8,r18
 820a068:	00800e0e 	bge	zero,r2,820a0a4 <_dtoa_r+0xf70>
 820a06c:	800b883a 	mov	r5,r16
 820a070:	01800044 	movi	r6,1
 820a074:	e009883a 	mov	r4,fp
 820a078:	da001715 	stw	r8,92(sp)
 820a07c:	820cd540 	call	820cd54 <__lshift>
 820a080:	a80b883a 	mov	r5,r21
 820a084:	1009883a 	mov	r4,r2
 820a088:	1021883a 	mov	r16,r2
 820a08c:	820ce9c0 	call	820ce9c <__mcmp>
 820a090:	da001717 	ldw	r8,92(sp)
 820a094:	0081960e 	bge	zero,r2,820a6f0 <_dtoa_r+0x15bc>
 820a098:	00800e44 	movi	r2,57
 820a09c:	40817026 	beq	r8,r2,820a660 <_dtoa_r+0x152c>
 820a0a0:	ba000c44 	addi	r8,r23,49
 820a0a4:	8825883a 	mov	r18,r17
 820a0a8:	9dc00044 	addi	r23,r19,1
 820a0ac:	9a000005 	stb	r8,0(r19)
 820a0b0:	a023883a 	mov	r17,r20
 820a0b4:	dc000915 	stw	r16,36(sp)
 820a0b8:	003f2406 	br	8209d4c <_dtoa_r+0xc18>
 820a0bc:	00800e44 	movi	r2,57
 820a0c0:	9011883a 	mov	r8,r18
 820a0c4:	90816626 	beq	r18,r2,820a660 <_dtoa_r+0x152c>
 820a0c8:	05bff516 	blt	zero,r22,820a0a0 <_dtoa_r+0xf6c>
 820a0cc:	003ff506 	br	820a0a4 <_dtoa_r+0xf70>
 820a0d0:	820c6a40 	call	820c6a4 <__multadd>
 820a0d4:	1023883a 	mov	r17,r2
 820a0d8:	1029883a 	mov	r20,r2
 820a0dc:	003fdf06 	br	820a05c <_dtoa_r+0xf28>
 820a0e0:	e009883a 	mov	r4,fp
 820a0e4:	820c67c0 	call	820c67c <_Bfree>
 820a0e8:	00800044 	movi	r2,1
 820a0ec:	003fbc06 	br	8209fe0 <_dtoa_r+0xeac>
 820a0f0:	a80b883a 	mov	r5,r21
 820a0f4:	8009883a 	mov	r4,r16
 820a0f8:	820ce9c0 	call	820ce9c <__mcmp>
 820a0fc:	103edb0e 	bge	r2,zero,8209c6c <_dtoa_r+0xb38>
 820a100:	800b883a 	mov	r5,r16
 820a104:	000f883a 	mov	r7,zero
 820a108:	01800284 	movi	r6,10
 820a10c:	e009883a 	mov	r4,fp
 820a110:	820c6a40 	call	820c6a4 <__multadd>
 820a114:	1021883a 	mov	r16,r2
 820a118:	d8800517 	ldw	r2,20(sp)
 820a11c:	d8c00b17 	ldw	r3,44(sp)
 820a120:	10bfffc4 	addi	r2,r2,-1
 820a124:	d8800515 	stw	r2,20(sp)
 820a128:	183f761e 	bne	r3,zero,8209f04 <_dtoa_r+0xdd0>
 820a12c:	d9000c17 	ldw	r4,48(sp)
 820a130:	0101730e 	bge	zero,r4,820a700 <_dtoa_r+0x15cc>
 820a134:	d9000615 	stw	r4,24(sp)
 820a138:	003ed006 	br	8209c7c <_dtoa_r+0xb48>
 820a13c:	00800084 	movi	r2,2
 820a140:	3081861e 	bne	r6,r2,820a75c <_dtoa_r+0x1628>
 820a144:	d8000b15 	stw	zero,44(sp)
 820a148:	003f3c06 	br	8209e3c <_dtoa_r+0xd08>
 820a14c:	dc000917 	ldw	r16,36(sp)
 820a150:	003e9206 	br	8209b9c <_dtoa_r+0xa68>
 820a154:	d9c00317 	ldw	r7,12(sp)
 820a158:	00800084 	movi	r2,2
 820a15c:	11fec50e 	bge	r2,r7,8209c74 <_dtoa_r+0xb40>
 820a160:	d9000617 	ldw	r4,24(sp)
 820a164:	20013c1e 	bne	r4,zero,820a658 <_dtoa_r+0x1524>
 820a168:	a80b883a 	mov	r5,r21
 820a16c:	000f883a 	mov	r7,zero
 820a170:	01800144 	movi	r6,5
 820a174:	e009883a 	mov	r4,fp
 820a178:	820c6a40 	call	820c6a4 <__multadd>
 820a17c:	100b883a 	mov	r5,r2
 820a180:	8009883a 	mov	r4,r16
 820a184:	102b883a 	mov	r21,r2
 820a188:	820ce9c0 	call	820ce9c <__mcmp>
 820a18c:	dc000915 	stw	r16,36(sp)
 820a190:	00bf410e 	bge	zero,r2,8209e98 <_dtoa_r+0xd64>
 820a194:	d9c00717 	ldw	r7,28(sp)
 820a198:	00800c44 	movi	r2,49
 820a19c:	38800005 	stb	r2,0(r7)
 820a1a0:	d8800517 	ldw	r2,20(sp)
 820a1a4:	3dc00044 	addi	r23,r7,1
 820a1a8:	10800044 	addi	r2,r2,1
 820a1ac:	d8800515 	stw	r2,20(sp)
 820a1b0:	003f3d06 	br	8209ea8 <_dtoa_r+0xd74>
 820a1b4:	d9800517 	ldw	r6,20(sp)
 820a1b8:	d9c00717 	ldw	r7,28(sp)
 820a1bc:	00800c44 	movi	r2,49
 820a1c0:	31800044 	addi	r6,r6,1
 820a1c4:	d9800515 	stw	r6,20(sp)
 820a1c8:	38800005 	stb	r2,0(r7)
 820a1cc:	003edf06 	br	8209d4c <_dtoa_r+0xc18>
 820a1d0:	d8000b15 	stw	zero,44(sp)
 820a1d4:	003c9f06 	br	8209454 <_dtoa_r+0x320>
 820a1d8:	903e7e1e 	bne	r18,zero,8209bd4 <_dtoa_r+0xaa0>
 820a1dc:	00800434 	movhi	r2,16
 820a1e0:	10bfffc4 	addi	r2,r2,-1
 820a1e4:	9884703a 	and	r2,r19,r2
 820a1e8:	1000ea1e 	bne	r2,zero,820a594 <_dtoa_r+0x1460>
 820a1ec:	9cdffc2c 	andhi	r19,r19,32752
 820a1f0:	9800e826 	beq	r19,zero,820a594 <_dtoa_r+0x1460>
 820a1f4:	d9c00817 	ldw	r7,32(sp)
 820a1f8:	b5800044 	addi	r22,r22,1
 820a1fc:	04c00044 	movi	r19,1
 820a200:	39c00044 	addi	r7,r7,1
 820a204:	d9c00815 	stw	r7,32(sp)
 820a208:	d8800d17 	ldw	r2,52(sp)
 820a20c:	103e721e 	bne	r2,zero,8209bd8 <_dtoa_r+0xaa4>
 820a210:	00800044 	movi	r2,1
 820a214:	003e7906 	br	8209bfc <_dtoa_r+0xac8>
 820a218:	8009883a 	mov	r4,r16
 820a21c:	82141640 	call	8214164 <__floatsidf>
 820a220:	d9800f17 	ldw	r6,60(sp)
 820a224:	d9c01017 	ldw	r7,64(sp)
 820a228:	1009883a 	mov	r4,r2
 820a22c:	180b883a 	mov	r5,r3
 820a230:	82130d00 	call	82130d0 <__muldf3>
 820a234:	000d883a 	mov	r6,zero
 820a238:	01d00734 	movhi	r7,16412
 820a23c:	1009883a 	mov	r4,r2
 820a240:	180b883a 	mov	r5,r3
 820a244:	8211ce40 	call	8211ce4 <__adddf3>
 820a248:	047f3034 	movhi	r17,64704
 820a24c:	1021883a 	mov	r16,r2
 820a250:	1c63883a 	add	r17,r3,r17
 820a254:	d9000f17 	ldw	r4,60(sp)
 820a258:	d9401017 	ldw	r5,64(sp)
 820a25c:	000d883a 	mov	r6,zero
 820a260:	01d00534 	movhi	r7,16404
 820a264:	82137e80 	call	82137e8 <__subdf3>
 820a268:	800d883a 	mov	r6,r16
 820a26c:	880f883a 	mov	r7,r17
 820a270:	1009883a 	mov	r4,r2
 820a274:	180b883a 	mov	r5,r3
 820a278:	102b883a 	mov	r21,r2
 820a27c:	1829883a 	mov	r20,r3
 820a280:	8212f000 	call	8212f00 <__gedf2>
 820a284:	00806c16 	blt	zero,r2,820a438 <_dtoa_r+0x1304>
 820a288:	89e0003c 	xorhi	r7,r17,32768
 820a28c:	800d883a 	mov	r6,r16
 820a290:	a809883a 	mov	r4,r21
 820a294:	a00b883a 	mov	r5,r20
 820a298:	8212fdc0 	call	8212fdc <__ledf2>
 820a29c:	103d7e0e 	bge	r2,zero,8209898 <_dtoa_r+0x764>
 820a2a0:	002b883a 	mov	r21,zero
 820a2a4:	0023883a 	mov	r17,zero
 820a2a8:	003efb06 	br	8209e98 <_dtoa_r+0xd64>
 820a2ac:	d8800717 	ldw	r2,28(sp)
 820a2b0:	003bd006 	br	82091f4 <_dtoa_r+0xc0>
 820a2b4:	d9000a17 	ldw	r4,40(sp)
 820a2b8:	d9800d17 	ldw	r6,52(sp)
 820a2bc:	dd400a15 	stw	r21,40(sp)
 820a2c0:	a905c83a 	sub	r2,r21,r4
 820a2c4:	308d883a 	add	r6,r6,r2
 820a2c8:	d9800d15 	stw	r6,52(sp)
 820a2cc:	002b883a 	mov	r21,zero
 820a2d0:	003e0606 	br	8209aec <_dtoa_r+0x9b8>
 820a2d4:	9023883a 	mov	r17,r18
 820a2d8:	9829883a 	mov	r20,r19
 820a2dc:	04000084 	movi	r16,2
 820a2e0:	003c9206 	br	820952c <_dtoa_r+0x3f8>
 820a2e4:	04000044 	movi	r16,1
 820a2e8:	dc000c15 	stw	r16,48(sp)
 820a2ec:	dc000615 	stw	r16,24(sp)
 820a2f0:	dc002215 	stw	r16,136(sp)
 820a2f4:	e0001115 	stw	zero,68(fp)
 820a2f8:	000b883a 	mov	r5,zero
 820a2fc:	003c6906 	br	82094a4 <_dtoa_r+0x370>
 820a300:	3021883a 	mov	r16,r6
 820a304:	003ffb06 	br	820a2f4 <_dtoa_r+0x11c0>
 820a308:	1000021e 	bne	r2,zero,820a314 <_dtoa_r+0x11e0>
 820a30c:	4200004c 	andi	r8,r8,1
 820a310:	403e7d1e 	bne	r8,zero,8209d08 <_dtoa_r+0xbd4>
 820a314:	01000c04 	movi	r4,48
 820a318:	00000106 	br	820a320 <_dtoa_r+0x11ec>
 820a31c:	102f883a 	mov	r23,r2
 820a320:	b8bfffc4 	addi	r2,r23,-1
 820a324:	10c00007 	ldb	r3,0(r2)
 820a328:	193ffc26 	beq	r3,r4,820a31c <_dtoa_r+0x11e8>
 820a32c:	003e8706 	br	8209d4c <_dtoa_r+0xc18>
 820a330:	d8800517 	ldw	r2,20(sp)
 820a334:	00a3c83a 	sub	r17,zero,r2
 820a338:	8800a426 	beq	r17,zero,820a5cc <_dtoa_r+0x1498>
 820a33c:	888003cc 	andi	r2,r17,15
 820a340:	100490fa 	slli	r2,r2,3
 820a344:	00c20974 	movhi	r3,2085
 820a348:	18f70204 	addi	r3,r3,-9208
 820a34c:	1885883a 	add	r2,r3,r2
 820a350:	11800017 	ldw	r6,0(r2)
 820a354:	11c00117 	ldw	r7,4(r2)
 820a358:	9009883a 	mov	r4,r18
 820a35c:	980b883a 	mov	r5,r19
 820a360:	8823d13a 	srai	r17,r17,4
 820a364:	82130d00 	call	82130d0 <__muldf3>
 820a368:	d8800f15 	stw	r2,60(sp)
 820a36c:	d8c01015 	stw	r3,64(sp)
 820a370:	8800e826 	beq	r17,zero,820a714 <_dtoa_r+0x15e0>
 820a374:	05020974 	movhi	r20,2085
 820a378:	a536f804 	addi	r20,r20,-9248
 820a37c:	04000084 	movi	r16,2
 820a380:	8980004c 	andi	r6,r17,1
 820a384:	1009883a 	mov	r4,r2
 820a388:	8823d07a 	srai	r17,r17,1
 820a38c:	180b883a 	mov	r5,r3
 820a390:	30000426 	beq	r6,zero,820a3a4 <_dtoa_r+0x1270>
 820a394:	a1800017 	ldw	r6,0(r20)
 820a398:	a1c00117 	ldw	r7,4(r20)
 820a39c:	84000044 	addi	r16,r16,1
 820a3a0:	82130d00 	call	82130d0 <__muldf3>
 820a3a4:	a5000204 	addi	r20,r20,8
 820a3a8:	883ff51e 	bne	r17,zero,820a380 <_dtoa_r+0x124c>
 820a3ac:	d8800f15 	stw	r2,60(sp)
 820a3b0:	d8c01015 	stw	r3,64(sp)
 820a3b4:	003c7606 	br	8209590 <_dtoa_r+0x45c>
 820a3b8:	00c00c04 	movi	r3,48
 820a3bc:	10c00005 	stb	r3,0(r2)
 820a3c0:	d8c00517 	ldw	r3,20(sp)
 820a3c4:	bd3fffc3 	ldbu	r20,-1(r23)
 820a3c8:	18c00044 	addi	r3,r3,1
 820a3cc:	d8c00515 	stw	r3,20(sp)
 820a3d0:	003db906 	br	8209ab8 <_dtoa_r+0x984>
 820a3d4:	89400117 	ldw	r5,4(r17)
 820a3d8:	e009883a 	mov	r4,fp
 820a3dc:	820c5d40 	call	820c5d4 <_Balloc>
 820a3e0:	89800417 	ldw	r6,16(r17)
 820a3e4:	89400304 	addi	r5,r17,12
 820a3e8:	11000304 	addi	r4,r2,12
 820a3ec:	31800084 	addi	r6,r6,2
 820a3f0:	318d883a 	add	r6,r6,r6
 820a3f4:	318d883a 	add	r6,r6,r6
 820a3f8:	1027883a 	mov	r19,r2
 820a3fc:	8202e8c0 	call	8202e8c <memcpy>
 820a400:	01800044 	movi	r6,1
 820a404:	980b883a 	mov	r5,r19
 820a408:	e009883a 	mov	r4,fp
 820a40c:	820cd540 	call	820cd54 <__lshift>
 820a410:	1029883a 	mov	r20,r2
 820a414:	003ecc06 	br	8209f48 <_dtoa_r+0xe14>
 820a418:	00800e44 	movi	r2,57
 820a41c:	90809026 	beq	r18,r2,820a660 <_dtoa_r+0x152c>
 820a420:	92000044 	addi	r8,r18,1
 820a424:	003f1f06 	br	820a0a4 <_dtoa_r+0xf70>
 820a428:	9011883a 	mov	r8,r18
 820a42c:	8825883a 	mov	r18,r17
 820a430:	a023883a 	mov	r17,r20
 820a434:	003e2906 	br	8209cdc <_dtoa_r+0xba8>
 820a438:	002b883a 	mov	r21,zero
 820a43c:	0023883a 	mov	r17,zero
 820a440:	003f5406 	br	820a194 <_dtoa_r+0x1060>
 820a444:	61bfffc4 	addi	r6,r12,-1
 820a448:	300490fa 	slli	r2,r6,3
 820a44c:	00c20974 	movhi	r3,2085
 820a450:	18f70204 	addi	r3,r3,-9208
 820a454:	1885883a 	add	r2,r3,r2
 820a458:	11000017 	ldw	r4,0(r2)
 820a45c:	11400117 	ldw	r5,4(r2)
 820a460:	d8800717 	ldw	r2,28(sp)
 820a464:	880f883a 	mov	r7,r17
 820a468:	d9801215 	stw	r6,72(sp)
 820a46c:	800d883a 	mov	r6,r16
 820a470:	db001615 	stw	r12,88(sp)
 820a474:	15c00044 	addi	r23,r2,1
 820a478:	82130d00 	call	82130d0 <__muldf3>
 820a47c:	d9401017 	ldw	r5,64(sp)
 820a480:	d9000f17 	ldw	r4,60(sp)
 820a484:	d8c01515 	stw	r3,84(sp)
 820a488:	d8801415 	stw	r2,80(sp)
 820a48c:	82140e40 	call	82140e4 <__fixdfsi>
 820a490:	1009883a 	mov	r4,r2
 820a494:	1021883a 	mov	r16,r2
 820a498:	82141640 	call	8214164 <__floatsidf>
 820a49c:	d9000f17 	ldw	r4,60(sp)
 820a4a0:	d9401017 	ldw	r5,64(sp)
 820a4a4:	100d883a 	mov	r6,r2
 820a4a8:	180f883a 	mov	r7,r3
 820a4ac:	82137e80 	call	82137e8 <__subdf3>
 820a4b0:	1829883a 	mov	r20,r3
 820a4b4:	d8c00717 	ldw	r3,28(sp)
 820a4b8:	84000c04 	addi	r16,r16,48
 820a4bc:	1023883a 	mov	r17,r2
 820a4c0:	1c000005 	stb	r16,0(r3)
 820a4c4:	db001617 	ldw	r12,88(sp)
 820a4c8:	00800044 	movi	r2,1
 820a4cc:	60802226 	beq	r12,r2,820a558 <_dtoa_r+0x1424>
 820a4d0:	d9c00717 	ldw	r7,28(sp)
 820a4d4:	8805883a 	mov	r2,r17
 820a4d8:	b82b883a 	mov	r21,r23
 820a4dc:	3b19883a 	add	r12,r7,r12
 820a4e0:	6023883a 	mov	r17,r12
 820a4e4:	a007883a 	mov	r3,r20
 820a4e8:	dc800f15 	stw	r18,60(sp)
 820a4ec:	000d883a 	mov	r6,zero
 820a4f0:	01d00934 	movhi	r7,16420
 820a4f4:	1009883a 	mov	r4,r2
 820a4f8:	180b883a 	mov	r5,r3
 820a4fc:	82130d00 	call	82130d0 <__muldf3>
 820a500:	180b883a 	mov	r5,r3
 820a504:	1009883a 	mov	r4,r2
 820a508:	1829883a 	mov	r20,r3
 820a50c:	1025883a 	mov	r18,r2
 820a510:	82140e40 	call	82140e4 <__fixdfsi>
 820a514:	1009883a 	mov	r4,r2
 820a518:	1021883a 	mov	r16,r2
 820a51c:	82141640 	call	8214164 <__floatsidf>
 820a520:	100d883a 	mov	r6,r2
 820a524:	180f883a 	mov	r7,r3
 820a528:	9009883a 	mov	r4,r18
 820a52c:	a00b883a 	mov	r5,r20
 820a530:	84000c04 	addi	r16,r16,48
 820a534:	82137e80 	call	82137e8 <__subdf3>
 820a538:	ad400044 	addi	r21,r21,1
 820a53c:	ac3fffc5 	stb	r16,-1(r21)
 820a540:	ac7fea1e 	bne	r21,r17,820a4ec <_dtoa_r+0x13b8>
 820a544:	1023883a 	mov	r17,r2
 820a548:	d8801217 	ldw	r2,72(sp)
 820a54c:	dc800f17 	ldw	r18,60(sp)
 820a550:	1829883a 	mov	r20,r3
 820a554:	b8af883a 	add	r23,r23,r2
 820a558:	d9001417 	ldw	r4,80(sp)
 820a55c:	d9401517 	ldw	r5,84(sp)
 820a560:	000d883a 	mov	r6,zero
 820a564:	01cff834 	movhi	r7,16352
 820a568:	8211ce40 	call	8211ce4 <__adddf3>
 820a56c:	880d883a 	mov	r6,r17
 820a570:	a00f883a 	mov	r7,r20
 820a574:	1009883a 	mov	r4,r2
 820a578:	180b883a 	mov	r5,r3
 820a57c:	8212fdc0 	call	8212fdc <__ledf2>
 820a580:	10003e0e 	bge	r2,zero,820a67c <_dtoa_r+0x1548>
 820a584:	d9001317 	ldw	r4,76(sp)
 820a588:	bd3fffc3 	ldbu	r20,-1(r23)
 820a58c:	d9000515 	stw	r4,20(sp)
 820a590:	003d3b06 	br	8209a80 <_dtoa_r+0x94c>
 820a594:	0027883a 	mov	r19,zero
 820a598:	003f1b06 	br	820a208 <_dtoa_r+0x10d4>
 820a59c:	d8800817 	ldw	r2,32(sp)
 820a5a0:	11e9c83a 	sub	r20,r2,r7
 820a5a4:	0005883a 	mov	r2,zero
 820a5a8:	003d5406 	br	8209afc <_dtoa_r+0x9c8>
 820a5ac:	00800044 	movi	r2,1
 820a5b0:	003dc706 	br	8209cd0 <_dtoa_r+0xb9c>
 820a5b4:	d8c00217 	ldw	r3,8(sp)
 820a5b8:	00800d84 	movi	r2,54
 820a5bc:	dd400a17 	ldw	r21,40(sp)
 820a5c0:	10c5c83a 	sub	r2,r2,r3
 820a5c4:	dd000817 	ldw	r20,32(sp)
 820a5c8:	003d4c06 	br	8209afc <_dtoa_r+0x9c8>
 820a5cc:	dc800f15 	stw	r18,60(sp)
 820a5d0:	dcc01015 	stw	r19,64(sp)
 820a5d4:	04000084 	movi	r16,2
 820a5d8:	003bed06 	br	8209590 <_dtoa_r+0x45c>
 820a5dc:	d9000617 	ldw	r4,24(sp)
 820a5e0:	203f0d26 	beq	r4,zero,820a218 <_dtoa_r+0x10e4>
 820a5e4:	d9800c17 	ldw	r6,48(sp)
 820a5e8:	01bcab0e 	bge	zero,r6,8209898 <_dtoa_r+0x764>
 820a5ec:	d9401017 	ldw	r5,64(sp)
 820a5f0:	d9000f17 	ldw	r4,60(sp)
 820a5f4:	000d883a 	mov	r6,zero
 820a5f8:	01d00934 	movhi	r7,16420
 820a5fc:	82130d00 	call	82130d0 <__muldf3>
 820a600:	81000044 	addi	r4,r16,1
 820a604:	d8800f15 	stw	r2,60(sp)
 820a608:	d8c01015 	stw	r3,64(sp)
 820a60c:	82141640 	call	8214164 <__floatsidf>
 820a610:	d9800f17 	ldw	r6,60(sp)
 820a614:	d9c01017 	ldw	r7,64(sp)
 820a618:	1009883a 	mov	r4,r2
 820a61c:	180b883a 	mov	r5,r3
 820a620:	82130d00 	call	82130d0 <__muldf3>
 820a624:	01d00734 	movhi	r7,16412
 820a628:	000d883a 	mov	r6,zero
 820a62c:	1009883a 	mov	r4,r2
 820a630:	180b883a 	mov	r5,r3
 820a634:	8211ce40 	call	8211ce4 <__adddf3>
 820a638:	d9c00517 	ldw	r7,20(sp)
 820a63c:	047f3034 	movhi	r17,64704
 820a640:	1021883a 	mov	r16,r2
 820a644:	39ffffc4 	addi	r7,r7,-1
 820a648:	d9c01315 	stw	r7,76(sp)
 820a64c:	1c63883a 	add	r17,r3,r17
 820a650:	db000c17 	ldw	r12,48(sp)
 820a654:	003bea06 	br	8209600 <_dtoa_r+0x4cc>
 820a658:	dc000915 	stw	r16,36(sp)
 820a65c:	003e0e06 	br	8209e98 <_dtoa_r+0xd64>
 820a660:	01000e44 	movi	r4,57
 820a664:	8825883a 	mov	r18,r17
 820a668:	9dc00044 	addi	r23,r19,1
 820a66c:	99000005 	stb	r4,0(r19)
 820a670:	a023883a 	mov	r17,r20
 820a674:	dc000915 	stw	r16,36(sp)
 820a678:	003da406 	br	8209d0c <_dtoa_r+0xbd8>
 820a67c:	d9801417 	ldw	r6,80(sp)
 820a680:	d9c01517 	ldw	r7,84(sp)
 820a684:	0009883a 	mov	r4,zero
 820a688:	014ff834 	movhi	r5,16352
 820a68c:	82137e80 	call	82137e8 <__subdf3>
 820a690:	880d883a 	mov	r6,r17
 820a694:	a00f883a 	mov	r7,r20
 820a698:	1009883a 	mov	r4,r2
 820a69c:	180b883a 	mov	r5,r3
 820a6a0:	8212f000 	call	8212f00 <__gedf2>
 820a6a4:	00bc7c0e 	bge	zero,r2,8209898 <_dtoa_r+0x764>
 820a6a8:	01000c04 	movi	r4,48
 820a6ac:	00000106 	br	820a6b4 <_dtoa_r+0x1580>
 820a6b0:	102f883a 	mov	r23,r2
 820a6b4:	b8bfffc4 	addi	r2,r23,-1
 820a6b8:	10c00007 	ldb	r3,0(r2)
 820a6bc:	193ffc26 	beq	r3,r4,820a6b0 <_dtoa_r+0x157c>
 820a6c0:	d9801317 	ldw	r6,76(sp)
 820a6c4:	d9800515 	stw	r6,20(sp)
 820a6c8:	003c4406 	br	82097dc <_dtoa_r+0x6a8>
 820a6cc:	d9801317 	ldw	r6,76(sp)
 820a6d0:	d9800515 	stw	r6,20(sp)
 820a6d4:	003cea06 	br	8209a80 <_dtoa_r+0x94c>
 820a6d8:	dd800f17 	ldw	r22,60(sp)
 820a6dc:	dcc01017 	ldw	r19,64(sp)
 820a6e0:	dc801217 	ldw	r18,72(sp)
 820a6e4:	003c6c06 	br	8209898 <_dtoa_r+0x764>
 820a6e8:	903e031e 	bne	r18,zero,8209ef8 <_dtoa_r+0xdc4>
 820a6ec:	003ebb06 	br	820a1dc <_dtoa_r+0x10a8>
 820a6f0:	103e6c1e 	bne	r2,zero,820a0a4 <_dtoa_r+0xf70>
 820a6f4:	4080004c 	andi	r2,r8,1
 820a6f8:	103e6a26 	beq	r2,zero,820a0a4 <_dtoa_r+0xf70>
 820a6fc:	003e6606 	br	820a098 <_dtoa_r+0xf64>
 820a700:	d8c00317 	ldw	r3,12(sp)
 820a704:	00800084 	movi	r2,2
 820a708:	10c02916 	blt	r2,r3,820a7b0 <_dtoa_r+0x167c>
 820a70c:	d9000c17 	ldw	r4,48(sp)
 820a710:	003e8806 	br	820a134 <_dtoa_r+0x1000>
 820a714:	04000084 	movi	r16,2
 820a718:	003b9d06 	br	8209590 <_dtoa_r+0x45c>
 820a71c:	d9001317 	ldw	r4,76(sp)
 820a720:	d9000515 	stw	r4,20(sp)
 820a724:	003cd606 	br	8209a80 <_dtoa_r+0x94c>
 820a728:	d8801317 	ldw	r2,76(sp)
 820a72c:	d8800515 	stw	r2,20(sp)
 820a730:	003c2a06 	br	82097dc <_dtoa_r+0x6a8>
 820a734:	d9800317 	ldw	r6,12(sp)
 820a738:	00800084 	movi	r2,2
 820a73c:	11801516 	blt	r2,r6,820a794 <_dtoa_r+0x1660>
 820a740:	d9c00c17 	ldw	r7,48(sp)
 820a744:	d9c00615 	stw	r7,24(sp)
 820a748:	003df706 	br	8209f28 <_dtoa_r+0xdf4>
 820a74c:	193d3926 	beq	r3,r4,8209c34 <_dtoa_r+0xb00>
 820a750:	00c00f04 	movi	r3,60
 820a754:	1885c83a 	sub	r2,r3,r2
 820a758:	003ddf06 	br	8209ed8 <_dtoa_r+0xda4>
 820a75c:	e009883a 	mov	r4,fp
 820a760:	e0001115 	stw	zero,68(fp)
 820a764:	000b883a 	mov	r5,zero
 820a768:	820c5d40 	call	820c5d4 <_Balloc>
 820a76c:	d8800715 	stw	r2,28(sp)
 820a770:	d8c00717 	ldw	r3,28(sp)
 820a774:	00bfffc4 	movi	r2,-1
 820a778:	01000044 	movi	r4,1
 820a77c:	d8800c15 	stw	r2,48(sp)
 820a780:	e0c01015 	stw	r3,64(fp)
 820a784:	d9000b15 	stw	r4,44(sp)
 820a788:	d8800615 	stw	r2,24(sp)
 820a78c:	d8002215 	stw	zero,136(sp)
 820a790:	003c4106 	br	8209898 <_dtoa_r+0x764>
 820a794:	d8c00c17 	ldw	r3,48(sp)
 820a798:	d8c00615 	stw	r3,24(sp)
 820a79c:	003e7006 	br	820a160 <_dtoa_r+0x102c>
 820a7a0:	04400044 	movi	r17,1
 820a7a4:	003b2006 	br	8209428 <_dtoa_r+0x2f4>
 820a7a8:	000b883a 	mov	r5,zero
 820a7ac:	003b3d06 	br	82094a4 <_dtoa_r+0x370>
 820a7b0:	d8800c17 	ldw	r2,48(sp)
 820a7b4:	d8800615 	stw	r2,24(sp)
 820a7b8:	003e6906 	br	820a160 <_dtoa_r+0x102c>

0820a7bc <__sflush_r>:
 820a7bc:	2880030b 	ldhu	r2,12(r5)
 820a7c0:	defffb04 	addi	sp,sp,-20
 820a7c4:	dcc00315 	stw	r19,12(sp)
 820a7c8:	dc400115 	stw	r17,4(sp)
 820a7cc:	dfc00415 	stw	ra,16(sp)
 820a7d0:	dc800215 	stw	r18,8(sp)
 820a7d4:	dc000015 	stw	r16,0(sp)
 820a7d8:	10c0020c 	andi	r3,r2,8
 820a7dc:	2823883a 	mov	r17,r5
 820a7e0:	2027883a 	mov	r19,r4
 820a7e4:	1800311e 	bne	r3,zero,820a8ac <__sflush_r+0xf0>
 820a7e8:	28c00117 	ldw	r3,4(r5)
 820a7ec:	10820014 	ori	r2,r2,2048
 820a7f0:	2880030d 	sth	r2,12(r5)
 820a7f4:	00c04b0e 	bge	zero,r3,820a924 <__sflush_r+0x168>
 820a7f8:	8a000a17 	ldw	r8,40(r17)
 820a7fc:	40002326 	beq	r8,zero,820a88c <__sflush_r+0xd0>
 820a800:	9c000017 	ldw	r16,0(r19)
 820a804:	10c4000c 	andi	r3,r2,4096
 820a808:	98000015 	stw	zero,0(r19)
 820a80c:	18004826 	beq	r3,zero,820a930 <__sflush_r+0x174>
 820a810:	89801417 	ldw	r6,80(r17)
 820a814:	10c0010c 	andi	r3,r2,4
 820a818:	18000626 	beq	r3,zero,820a834 <__sflush_r+0x78>
 820a81c:	88c00117 	ldw	r3,4(r17)
 820a820:	88800c17 	ldw	r2,48(r17)
 820a824:	30cdc83a 	sub	r6,r6,r3
 820a828:	10000226 	beq	r2,zero,820a834 <__sflush_r+0x78>
 820a82c:	88800f17 	ldw	r2,60(r17)
 820a830:	308dc83a 	sub	r6,r6,r2
 820a834:	89400717 	ldw	r5,28(r17)
 820a838:	000f883a 	mov	r7,zero
 820a83c:	9809883a 	mov	r4,r19
 820a840:	403ee83a 	callr	r8
 820a844:	00ffffc4 	movi	r3,-1
 820a848:	10c04426 	beq	r2,r3,820a95c <__sflush_r+0x1a0>
 820a84c:	88c0030b 	ldhu	r3,12(r17)
 820a850:	89000417 	ldw	r4,16(r17)
 820a854:	88000115 	stw	zero,4(r17)
 820a858:	197dffcc 	andi	r5,r3,63487
 820a85c:	8940030d 	sth	r5,12(r17)
 820a860:	89000015 	stw	r4,0(r17)
 820a864:	18c4000c 	andi	r3,r3,4096
 820a868:	18002c1e 	bne	r3,zero,820a91c <__sflush_r+0x160>
 820a86c:	89400c17 	ldw	r5,48(r17)
 820a870:	9c000015 	stw	r16,0(r19)
 820a874:	28000526 	beq	r5,zero,820a88c <__sflush_r+0xd0>
 820a878:	88801004 	addi	r2,r17,64
 820a87c:	28800226 	beq	r5,r2,820a888 <__sflush_r+0xcc>
 820a880:	9809883a 	mov	r4,r19
 820a884:	820b07c0 	call	820b07c <_free_r>
 820a888:	88000c15 	stw	zero,48(r17)
 820a88c:	0005883a 	mov	r2,zero
 820a890:	dfc00417 	ldw	ra,16(sp)
 820a894:	dcc00317 	ldw	r19,12(sp)
 820a898:	dc800217 	ldw	r18,8(sp)
 820a89c:	dc400117 	ldw	r17,4(sp)
 820a8a0:	dc000017 	ldw	r16,0(sp)
 820a8a4:	dec00504 	addi	sp,sp,20
 820a8a8:	f800283a 	ret
 820a8ac:	2c800417 	ldw	r18,16(r5)
 820a8b0:	903ff626 	beq	r18,zero,820a88c <__sflush_r+0xd0>
 820a8b4:	2c000017 	ldw	r16,0(r5)
 820a8b8:	108000cc 	andi	r2,r2,3
 820a8bc:	2c800015 	stw	r18,0(r5)
 820a8c0:	84a1c83a 	sub	r16,r16,r18
 820a8c4:	1000131e 	bne	r2,zero,820a914 <__sflush_r+0x158>
 820a8c8:	28800517 	ldw	r2,20(r5)
 820a8cc:	88800215 	stw	r2,8(r17)
 820a8d0:	04000316 	blt	zero,r16,820a8e0 <__sflush_r+0x124>
 820a8d4:	003fed06 	br	820a88c <__sflush_r+0xd0>
 820a8d8:	90a5883a 	add	r18,r18,r2
 820a8dc:	043feb0e 	bge	zero,r16,820a88c <__sflush_r+0xd0>
 820a8e0:	88800917 	ldw	r2,36(r17)
 820a8e4:	89400717 	ldw	r5,28(r17)
 820a8e8:	800f883a 	mov	r7,r16
 820a8ec:	900d883a 	mov	r6,r18
 820a8f0:	9809883a 	mov	r4,r19
 820a8f4:	103ee83a 	callr	r2
 820a8f8:	80a1c83a 	sub	r16,r16,r2
 820a8fc:	00bff616 	blt	zero,r2,820a8d8 <__sflush_r+0x11c>
 820a900:	88c0030b 	ldhu	r3,12(r17)
 820a904:	00bfffc4 	movi	r2,-1
 820a908:	18c01014 	ori	r3,r3,64
 820a90c:	88c0030d 	sth	r3,12(r17)
 820a910:	003fdf06 	br	820a890 <__sflush_r+0xd4>
 820a914:	0005883a 	mov	r2,zero
 820a918:	003fec06 	br	820a8cc <__sflush_r+0x110>
 820a91c:	88801415 	stw	r2,80(r17)
 820a920:	003fd206 	br	820a86c <__sflush_r+0xb0>
 820a924:	28c00f17 	ldw	r3,60(r5)
 820a928:	00ffb316 	blt	zero,r3,820a7f8 <__sflush_r+0x3c>
 820a92c:	003fd706 	br	820a88c <__sflush_r+0xd0>
 820a930:	89400717 	ldw	r5,28(r17)
 820a934:	000d883a 	mov	r6,zero
 820a938:	01c00044 	movi	r7,1
 820a93c:	9809883a 	mov	r4,r19
 820a940:	403ee83a 	callr	r8
 820a944:	100d883a 	mov	r6,r2
 820a948:	00bfffc4 	movi	r2,-1
 820a94c:	30801426 	beq	r6,r2,820a9a0 <__sflush_r+0x1e4>
 820a950:	8880030b 	ldhu	r2,12(r17)
 820a954:	8a000a17 	ldw	r8,40(r17)
 820a958:	003fae06 	br	820a814 <__sflush_r+0x58>
 820a95c:	98c00017 	ldw	r3,0(r19)
 820a960:	183fba26 	beq	r3,zero,820a84c <__sflush_r+0x90>
 820a964:	01000744 	movi	r4,29
 820a968:	19000626 	beq	r3,r4,820a984 <__sflush_r+0x1c8>
 820a96c:	01000584 	movi	r4,22
 820a970:	19000426 	beq	r3,r4,820a984 <__sflush_r+0x1c8>
 820a974:	88c0030b 	ldhu	r3,12(r17)
 820a978:	18c01014 	ori	r3,r3,64
 820a97c:	88c0030d 	sth	r3,12(r17)
 820a980:	003fc306 	br	820a890 <__sflush_r+0xd4>
 820a984:	8880030b 	ldhu	r2,12(r17)
 820a988:	88c00417 	ldw	r3,16(r17)
 820a98c:	88000115 	stw	zero,4(r17)
 820a990:	10bdffcc 	andi	r2,r2,63487
 820a994:	8880030d 	sth	r2,12(r17)
 820a998:	88c00015 	stw	r3,0(r17)
 820a99c:	003fb306 	br	820a86c <__sflush_r+0xb0>
 820a9a0:	98800017 	ldw	r2,0(r19)
 820a9a4:	103fea26 	beq	r2,zero,820a950 <__sflush_r+0x194>
 820a9a8:	00c00744 	movi	r3,29
 820a9ac:	10c00226 	beq	r2,r3,820a9b8 <__sflush_r+0x1fc>
 820a9b0:	00c00584 	movi	r3,22
 820a9b4:	10c0031e 	bne	r2,r3,820a9c4 <__sflush_r+0x208>
 820a9b8:	9c000015 	stw	r16,0(r19)
 820a9bc:	0005883a 	mov	r2,zero
 820a9c0:	003fb306 	br	820a890 <__sflush_r+0xd4>
 820a9c4:	88c0030b 	ldhu	r3,12(r17)
 820a9c8:	3005883a 	mov	r2,r6
 820a9cc:	18c01014 	ori	r3,r3,64
 820a9d0:	88c0030d 	sth	r3,12(r17)
 820a9d4:	003fae06 	br	820a890 <__sflush_r+0xd4>

0820a9d8 <_fflush_r>:
 820a9d8:	defffd04 	addi	sp,sp,-12
 820a9dc:	dc000115 	stw	r16,4(sp)
 820a9e0:	dfc00215 	stw	ra,8(sp)
 820a9e4:	2021883a 	mov	r16,r4
 820a9e8:	20000226 	beq	r4,zero,820a9f4 <_fflush_r+0x1c>
 820a9ec:	20800e17 	ldw	r2,56(r4)
 820a9f0:	10000c26 	beq	r2,zero,820aa24 <_fflush_r+0x4c>
 820a9f4:	2880030f 	ldh	r2,12(r5)
 820a9f8:	1000051e 	bne	r2,zero,820aa10 <_fflush_r+0x38>
 820a9fc:	0005883a 	mov	r2,zero
 820aa00:	dfc00217 	ldw	ra,8(sp)
 820aa04:	dc000117 	ldw	r16,4(sp)
 820aa08:	dec00304 	addi	sp,sp,12
 820aa0c:	f800283a 	ret
 820aa10:	8009883a 	mov	r4,r16
 820aa14:	dfc00217 	ldw	ra,8(sp)
 820aa18:	dc000117 	ldw	r16,4(sp)
 820aa1c:	dec00304 	addi	sp,sp,12
 820aa20:	820a7bc1 	jmpi	820a7bc <__sflush_r>
 820aa24:	d9400015 	stw	r5,0(sp)
 820aa28:	820adb40 	call	820adb4 <__sinit>
 820aa2c:	d9400017 	ldw	r5,0(sp)
 820aa30:	003ff006 	br	820a9f4 <_fflush_r+0x1c>

0820aa34 <fflush>:
 820aa34:	20000526 	beq	r4,zero,820aa4c <fflush+0x18>
 820aa38:	00820974 	movhi	r2,2085
 820aa3c:	108fa204 	addi	r2,r2,16008
 820aa40:	200b883a 	mov	r5,r4
 820aa44:	11000017 	ldw	r4,0(r2)
 820aa48:	820a9d81 	jmpi	820a9d8 <_fflush_r>
 820aa4c:	00820974 	movhi	r2,2085
 820aa50:	108fa104 	addi	r2,r2,16004
 820aa54:	11000017 	ldw	r4,0(r2)
 820aa58:	01420874 	movhi	r5,2081
 820aa5c:	296a7604 	addi	r5,r5,-22056
 820aa60:	820b90c1 	jmpi	820b90c <_fwalk_reent>

0820aa64 <__fp_unlock>:
 820aa64:	0005883a 	mov	r2,zero
 820aa68:	f800283a 	ret

0820aa6c <_cleanup_r>:
 820aa6c:	01420874 	movhi	r5,2081
 820aa70:	2942f404 	addi	r5,r5,3024
 820aa74:	820b90c1 	jmpi	820b90c <_fwalk_reent>

0820aa78 <__sinit.part.1>:
 820aa78:	defff704 	addi	sp,sp,-36
 820aa7c:	00c20874 	movhi	r3,2081
 820aa80:	dfc00815 	stw	ra,32(sp)
 820aa84:	ddc00715 	stw	r23,28(sp)
 820aa88:	dd800615 	stw	r22,24(sp)
 820aa8c:	dd400515 	stw	r21,20(sp)
 820aa90:	dd000415 	stw	r20,16(sp)
 820aa94:	dcc00315 	stw	r19,12(sp)
 820aa98:	dc800215 	stw	r18,8(sp)
 820aa9c:	dc400115 	stw	r17,4(sp)
 820aaa0:	dc000015 	stw	r16,0(sp)
 820aaa4:	18ea9b04 	addi	r3,r3,-21908
 820aaa8:	24000117 	ldw	r16,4(r4)
 820aaac:	20c00f15 	stw	r3,60(r4)
 820aab0:	2080bb04 	addi	r2,r4,748
 820aab4:	00c000c4 	movi	r3,3
 820aab8:	20c0b915 	stw	r3,740(r4)
 820aabc:	2080ba15 	stw	r2,744(r4)
 820aac0:	2000b815 	stw	zero,736(r4)
 820aac4:	05c00204 	movi	r23,8
 820aac8:	00800104 	movi	r2,4
 820aacc:	2025883a 	mov	r18,r4
 820aad0:	b80d883a 	mov	r6,r23
 820aad4:	81001704 	addi	r4,r16,92
 820aad8:	000b883a 	mov	r5,zero
 820aadc:	80000015 	stw	zero,0(r16)
 820aae0:	80000115 	stw	zero,4(r16)
 820aae4:	80000215 	stw	zero,8(r16)
 820aae8:	8080030d 	sth	r2,12(r16)
 820aaec:	80001915 	stw	zero,100(r16)
 820aaf0:	8000038d 	sth	zero,14(r16)
 820aaf4:	80000415 	stw	zero,16(r16)
 820aaf8:	80000515 	stw	zero,20(r16)
 820aafc:	80000615 	stw	zero,24(r16)
 820ab00:	82031300 	call	8203130 <memset>
 820ab04:	05820874 	movhi	r22,2081
 820ab08:	94400217 	ldw	r17,8(r18)
 820ab0c:	05420874 	movhi	r21,2081
 820ab10:	05020874 	movhi	r20,2081
 820ab14:	04c20874 	movhi	r19,2081
 820ab18:	b5b77b04 	addi	r22,r22,-8724
 820ab1c:	ad779204 	addi	r21,r21,-8632
 820ab20:	a537b104 	addi	r20,r20,-8508
 820ab24:	9cf7c804 	addi	r19,r19,-8416
 820ab28:	85800815 	stw	r22,32(r16)
 820ab2c:	85400915 	stw	r21,36(r16)
 820ab30:	85000a15 	stw	r20,40(r16)
 820ab34:	84c00b15 	stw	r19,44(r16)
 820ab38:	84000715 	stw	r16,28(r16)
 820ab3c:	00800284 	movi	r2,10
 820ab40:	8880030d 	sth	r2,12(r17)
 820ab44:	00800044 	movi	r2,1
 820ab48:	b80d883a 	mov	r6,r23
 820ab4c:	89001704 	addi	r4,r17,92
 820ab50:	000b883a 	mov	r5,zero
 820ab54:	88000015 	stw	zero,0(r17)
 820ab58:	88000115 	stw	zero,4(r17)
 820ab5c:	88000215 	stw	zero,8(r17)
 820ab60:	88001915 	stw	zero,100(r17)
 820ab64:	8880038d 	sth	r2,14(r17)
 820ab68:	88000415 	stw	zero,16(r17)
 820ab6c:	88000515 	stw	zero,20(r17)
 820ab70:	88000615 	stw	zero,24(r17)
 820ab74:	82031300 	call	8203130 <memset>
 820ab78:	94000317 	ldw	r16,12(r18)
 820ab7c:	00800484 	movi	r2,18
 820ab80:	8c400715 	stw	r17,28(r17)
 820ab84:	8d800815 	stw	r22,32(r17)
 820ab88:	8d400915 	stw	r21,36(r17)
 820ab8c:	8d000a15 	stw	r20,40(r17)
 820ab90:	8cc00b15 	stw	r19,44(r17)
 820ab94:	8080030d 	sth	r2,12(r16)
 820ab98:	00800084 	movi	r2,2
 820ab9c:	80000015 	stw	zero,0(r16)
 820aba0:	80000115 	stw	zero,4(r16)
 820aba4:	80000215 	stw	zero,8(r16)
 820aba8:	80001915 	stw	zero,100(r16)
 820abac:	8080038d 	sth	r2,14(r16)
 820abb0:	80000415 	stw	zero,16(r16)
 820abb4:	80000515 	stw	zero,20(r16)
 820abb8:	80000615 	stw	zero,24(r16)
 820abbc:	b80d883a 	mov	r6,r23
 820abc0:	000b883a 	mov	r5,zero
 820abc4:	81001704 	addi	r4,r16,92
 820abc8:	82031300 	call	8203130 <memset>
 820abcc:	00800044 	movi	r2,1
 820abd0:	84000715 	stw	r16,28(r16)
 820abd4:	85800815 	stw	r22,32(r16)
 820abd8:	85400915 	stw	r21,36(r16)
 820abdc:	85000a15 	stw	r20,40(r16)
 820abe0:	84c00b15 	stw	r19,44(r16)
 820abe4:	90800e15 	stw	r2,56(r18)
 820abe8:	dfc00817 	ldw	ra,32(sp)
 820abec:	ddc00717 	ldw	r23,28(sp)
 820abf0:	dd800617 	ldw	r22,24(sp)
 820abf4:	dd400517 	ldw	r21,20(sp)
 820abf8:	dd000417 	ldw	r20,16(sp)
 820abfc:	dcc00317 	ldw	r19,12(sp)
 820ac00:	dc800217 	ldw	r18,8(sp)
 820ac04:	dc400117 	ldw	r17,4(sp)
 820ac08:	dc000017 	ldw	r16,0(sp)
 820ac0c:	dec00904 	addi	sp,sp,36
 820ac10:	f800283a 	ret

0820ac14 <__fp_lock>:
 820ac14:	0005883a 	mov	r2,zero
 820ac18:	f800283a 	ret

0820ac1c <__sfmoreglue>:
 820ac1c:	defffc04 	addi	sp,sp,-16
 820ac20:	dc400115 	stw	r17,4(sp)
 820ac24:	2c7fffc4 	addi	r17,r5,-1
 820ac28:	8c401a24 	muli	r17,r17,104
 820ac2c:	dc800215 	stw	r18,8(sp)
 820ac30:	2825883a 	mov	r18,r5
 820ac34:	89401d04 	addi	r5,r17,116
 820ac38:	dc000015 	stw	r16,0(sp)
 820ac3c:	dfc00315 	stw	ra,12(sp)
 820ac40:	820bc680 	call	820bc68 <_malloc_r>
 820ac44:	1021883a 	mov	r16,r2
 820ac48:	10000726 	beq	r2,zero,820ac68 <__sfmoreglue+0x4c>
 820ac4c:	11000304 	addi	r4,r2,12
 820ac50:	10000015 	stw	zero,0(r2)
 820ac54:	14800115 	stw	r18,4(r2)
 820ac58:	11000215 	stw	r4,8(r2)
 820ac5c:	89801a04 	addi	r6,r17,104
 820ac60:	000b883a 	mov	r5,zero
 820ac64:	82031300 	call	8203130 <memset>
 820ac68:	8005883a 	mov	r2,r16
 820ac6c:	dfc00317 	ldw	ra,12(sp)
 820ac70:	dc800217 	ldw	r18,8(sp)
 820ac74:	dc400117 	ldw	r17,4(sp)
 820ac78:	dc000017 	ldw	r16,0(sp)
 820ac7c:	dec00404 	addi	sp,sp,16
 820ac80:	f800283a 	ret

0820ac84 <__sfp>:
 820ac84:	defffb04 	addi	sp,sp,-20
 820ac88:	dc000015 	stw	r16,0(sp)
 820ac8c:	04020974 	movhi	r16,2085
 820ac90:	840fa104 	addi	r16,r16,16004
 820ac94:	dcc00315 	stw	r19,12(sp)
 820ac98:	2027883a 	mov	r19,r4
 820ac9c:	81000017 	ldw	r4,0(r16)
 820aca0:	dfc00415 	stw	ra,16(sp)
 820aca4:	dc800215 	stw	r18,8(sp)
 820aca8:	20800e17 	ldw	r2,56(r4)
 820acac:	dc400115 	stw	r17,4(sp)
 820acb0:	1000021e 	bne	r2,zero,820acbc <__sfp+0x38>
 820acb4:	820aa780 	call	820aa78 <__sinit.part.1>
 820acb8:	81000017 	ldw	r4,0(r16)
 820acbc:	2480b804 	addi	r18,r4,736
 820acc0:	047fffc4 	movi	r17,-1
 820acc4:	91000117 	ldw	r4,4(r18)
 820acc8:	94000217 	ldw	r16,8(r18)
 820accc:	213fffc4 	addi	r4,r4,-1
 820acd0:	20000a16 	blt	r4,zero,820acfc <__sfp+0x78>
 820acd4:	8080030f 	ldh	r2,12(r16)
 820acd8:	10000c26 	beq	r2,zero,820ad0c <__sfp+0x88>
 820acdc:	80c01d04 	addi	r3,r16,116
 820ace0:	00000206 	br	820acec <__sfp+0x68>
 820ace4:	18bfe60f 	ldh	r2,-104(r3)
 820ace8:	10000826 	beq	r2,zero,820ad0c <__sfp+0x88>
 820acec:	213fffc4 	addi	r4,r4,-1
 820acf0:	1c3ffd04 	addi	r16,r3,-12
 820acf4:	18c01a04 	addi	r3,r3,104
 820acf8:	247ffa1e 	bne	r4,r17,820ace4 <__sfp+0x60>
 820acfc:	90800017 	ldw	r2,0(r18)
 820ad00:	10001d26 	beq	r2,zero,820ad78 <__sfp+0xf4>
 820ad04:	1025883a 	mov	r18,r2
 820ad08:	003fee06 	br	820acc4 <__sfp+0x40>
 820ad0c:	00bfffc4 	movi	r2,-1
 820ad10:	8080038d 	sth	r2,14(r16)
 820ad14:	00800044 	movi	r2,1
 820ad18:	8080030d 	sth	r2,12(r16)
 820ad1c:	80001915 	stw	zero,100(r16)
 820ad20:	80000015 	stw	zero,0(r16)
 820ad24:	80000215 	stw	zero,8(r16)
 820ad28:	80000115 	stw	zero,4(r16)
 820ad2c:	80000415 	stw	zero,16(r16)
 820ad30:	80000515 	stw	zero,20(r16)
 820ad34:	80000615 	stw	zero,24(r16)
 820ad38:	01800204 	movi	r6,8
 820ad3c:	000b883a 	mov	r5,zero
 820ad40:	81001704 	addi	r4,r16,92
 820ad44:	82031300 	call	8203130 <memset>
 820ad48:	8005883a 	mov	r2,r16
 820ad4c:	80000c15 	stw	zero,48(r16)
 820ad50:	80000d15 	stw	zero,52(r16)
 820ad54:	80001115 	stw	zero,68(r16)
 820ad58:	80001215 	stw	zero,72(r16)
 820ad5c:	dfc00417 	ldw	ra,16(sp)
 820ad60:	dcc00317 	ldw	r19,12(sp)
 820ad64:	dc800217 	ldw	r18,8(sp)
 820ad68:	dc400117 	ldw	r17,4(sp)
 820ad6c:	dc000017 	ldw	r16,0(sp)
 820ad70:	dec00504 	addi	sp,sp,20
 820ad74:	f800283a 	ret
 820ad78:	01400104 	movi	r5,4
 820ad7c:	9809883a 	mov	r4,r19
 820ad80:	820ac1c0 	call	820ac1c <__sfmoreglue>
 820ad84:	90800015 	stw	r2,0(r18)
 820ad88:	103fde1e 	bne	r2,zero,820ad04 <__sfp+0x80>
 820ad8c:	00800304 	movi	r2,12
 820ad90:	98800015 	stw	r2,0(r19)
 820ad94:	0005883a 	mov	r2,zero
 820ad98:	003ff006 	br	820ad5c <__sfp+0xd8>

0820ad9c <_cleanup>:
 820ad9c:	00820974 	movhi	r2,2085
 820ada0:	108fa104 	addi	r2,r2,16004
 820ada4:	11000017 	ldw	r4,0(r2)
 820ada8:	01420874 	movhi	r5,2081
 820adac:	2942f404 	addi	r5,r5,3024
 820adb0:	820b90c1 	jmpi	820b90c <_fwalk_reent>

0820adb4 <__sinit>:
 820adb4:	20800e17 	ldw	r2,56(r4)
 820adb8:	10000126 	beq	r2,zero,820adc0 <__sinit+0xc>
 820adbc:	f800283a 	ret
 820adc0:	820aa781 	jmpi	820aa78 <__sinit.part.1>

0820adc4 <__sfp_lock_acquire>:
 820adc4:	f800283a 	ret

0820adc8 <__sfp_lock_release>:
 820adc8:	f800283a 	ret

0820adcc <__sinit_lock_acquire>:
 820adcc:	f800283a 	ret

0820add0 <__sinit_lock_release>:
 820add0:	f800283a 	ret

0820add4 <__fp_lock_all>:
 820add4:	00820974 	movhi	r2,2085
 820add8:	108fa204 	addi	r2,r2,16008
 820addc:	11000017 	ldw	r4,0(r2)
 820ade0:	01420874 	movhi	r5,2081
 820ade4:	296b0504 	addi	r5,r5,-21484
 820ade8:	820b8481 	jmpi	820b848 <_fwalk>

0820adec <__fp_unlock_all>:
 820adec:	00820974 	movhi	r2,2085
 820adf0:	108fa204 	addi	r2,r2,16008
 820adf4:	11000017 	ldw	r4,0(r2)
 820adf8:	01420874 	movhi	r5,2081
 820adfc:	296a9904 	addi	r5,r5,-21916
 820ae00:	820b8481 	jmpi	820b848 <_fwalk>

0820ae04 <_fputc_r>:
 820ae04:	defffc04 	addi	sp,sp,-16
 820ae08:	dc000215 	stw	r16,8(sp)
 820ae0c:	dfc00315 	stw	ra,12(sp)
 820ae10:	2021883a 	mov	r16,r4
 820ae14:	20000726 	beq	r4,zero,820ae34 <_fputc_r+0x30>
 820ae18:	20800e17 	ldw	r2,56(r4)
 820ae1c:	1000051e 	bne	r2,zero,820ae34 <_fputc_r+0x30>
 820ae20:	d9400015 	stw	r5,0(sp)
 820ae24:	d9800115 	stw	r6,4(sp)
 820ae28:	820adb40 	call	820adb4 <__sinit>
 820ae2c:	d9800117 	ldw	r6,4(sp)
 820ae30:	d9400017 	ldw	r5,0(sp)
 820ae34:	8009883a 	mov	r4,r16
 820ae38:	dfc00317 	ldw	ra,12(sp)
 820ae3c:	dc000217 	ldw	r16,8(sp)
 820ae40:	dec00404 	addi	sp,sp,16
 820ae44:	82033581 	jmpi	8203358 <_putc_r>

0820ae48 <fputc>:
 820ae48:	00820974 	movhi	r2,2085
 820ae4c:	defffc04 	addi	sp,sp,-16
 820ae50:	108fa204 	addi	r2,r2,16008
 820ae54:	dc000115 	stw	r16,4(sp)
 820ae58:	14000017 	ldw	r16,0(r2)
 820ae5c:	dc400215 	stw	r17,8(sp)
 820ae60:	dfc00315 	stw	ra,12(sp)
 820ae64:	2023883a 	mov	r17,r4
 820ae68:	80000626 	beq	r16,zero,820ae84 <fputc+0x3c>
 820ae6c:	80800e17 	ldw	r2,56(r16)
 820ae70:	1000041e 	bne	r2,zero,820ae84 <fputc+0x3c>
 820ae74:	8009883a 	mov	r4,r16
 820ae78:	d9400015 	stw	r5,0(sp)
 820ae7c:	820adb40 	call	820adb4 <__sinit>
 820ae80:	d9400017 	ldw	r5,0(sp)
 820ae84:	280d883a 	mov	r6,r5
 820ae88:	8009883a 	mov	r4,r16
 820ae8c:	880b883a 	mov	r5,r17
 820ae90:	dfc00317 	ldw	ra,12(sp)
 820ae94:	dc400217 	ldw	r17,8(sp)
 820ae98:	dc000117 	ldw	r16,4(sp)
 820ae9c:	dec00404 	addi	sp,sp,16
 820aea0:	82033581 	jmpi	8203358 <_putc_r>

0820aea4 <_fputs_r>:
 820aea4:	defff804 	addi	sp,sp,-32
 820aea8:	dc400615 	stw	r17,24(sp)
 820aeac:	2023883a 	mov	r17,r4
 820aeb0:	2809883a 	mov	r4,r5
 820aeb4:	dc000515 	stw	r16,20(sp)
 820aeb8:	dfc00715 	stw	ra,28(sp)
 820aebc:	3021883a 	mov	r16,r6
 820aec0:	d9400315 	stw	r5,12(sp)
 820aec4:	8203edc0 	call	8203edc <strlen>
 820aec8:	d8800215 	stw	r2,8(sp)
 820aecc:	d8800415 	stw	r2,16(sp)
 820aed0:	d8800304 	addi	r2,sp,12
 820aed4:	d8800015 	stw	r2,0(sp)
 820aed8:	00800044 	movi	r2,1
 820aedc:	d8800115 	stw	r2,4(sp)
 820aee0:	88000226 	beq	r17,zero,820aeec <_fputs_r+0x48>
 820aee4:	88800e17 	ldw	r2,56(r17)
 820aee8:	10001226 	beq	r2,zero,820af34 <_fputs_r+0x90>
 820aeec:	8080030b 	ldhu	r2,12(r16)
 820aef0:	10c8000c 	andi	r3,r2,8192
 820aef4:	1800061e 	bne	r3,zero,820af10 <_fputs_r+0x6c>
 820aef8:	81001917 	ldw	r4,100(r16)
 820aefc:	00f7ffc4 	movi	r3,-8193
 820af00:	10880014 	ori	r2,r2,8192
 820af04:	20c6703a 	and	r3,r4,r3
 820af08:	8080030d 	sth	r2,12(r16)
 820af0c:	80c01915 	stw	r3,100(r16)
 820af10:	d80d883a 	mov	r6,sp
 820af14:	800b883a 	mov	r5,r16
 820af18:	8809883a 	mov	r4,r17
 820af1c:	820b38c0 	call	820b38c <__sfvwrite_r>
 820af20:	dfc00717 	ldw	ra,28(sp)
 820af24:	dc400617 	ldw	r17,24(sp)
 820af28:	dc000517 	ldw	r16,20(sp)
 820af2c:	dec00804 	addi	sp,sp,32
 820af30:	f800283a 	ret
 820af34:	8809883a 	mov	r4,r17
 820af38:	820adb40 	call	820adb4 <__sinit>
 820af3c:	003feb06 	br	820aeec <_fputs_r+0x48>

0820af40 <fputs>:
 820af40:	00820974 	movhi	r2,2085
 820af44:	108fa204 	addi	r2,r2,16008
 820af48:	280d883a 	mov	r6,r5
 820af4c:	200b883a 	mov	r5,r4
 820af50:	11000017 	ldw	r4,0(r2)
 820af54:	820aea41 	jmpi	820aea4 <_fputs_r>

0820af58 <_malloc_trim_r>:
 820af58:	defffb04 	addi	sp,sp,-20
 820af5c:	dcc00315 	stw	r19,12(sp)
 820af60:	04c20974 	movhi	r19,2085
 820af64:	dc800215 	stw	r18,8(sp)
 820af68:	dc400115 	stw	r17,4(sp)
 820af6c:	dc000015 	stw	r16,0(sp)
 820af70:	dfc00415 	stw	ra,16(sp)
 820af74:	2821883a 	mov	r16,r5
 820af78:	9cc93004 	addi	r19,r19,9408
 820af7c:	2025883a 	mov	r18,r4
 820af80:	82149740 	call	8214974 <__malloc_lock>
 820af84:	98800217 	ldw	r2,8(r19)
 820af88:	14400117 	ldw	r17,4(r2)
 820af8c:	00bfff04 	movi	r2,-4
 820af90:	88a2703a 	and	r17,r17,r2
 820af94:	8c21c83a 	sub	r16,r17,r16
 820af98:	8403fbc4 	addi	r16,r16,4079
 820af9c:	8020d33a 	srli	r16,r16,12
 820afa0:	0083ffc4 	movi	r2,4095
 820afa4:	843fffc4 	addi	r16,r16,-1
 820afa8:	8020933a 	slli	r16,r16,12
 820afac:	1400060e 	bge	r2,r16,820afc8 <_malloc_trim_r+0x70>
 820afb0:	000b883a 	mov	r5,zero
 820afb4:	9009883a 	mov	r4,r18
 820afb8:	820dd980 	call	820dd98 <_sbrk_r>
 820afbc:	98c00217 	ldw	r3,8(r19)
 820afc0:	1c47883a 	add	r3,r3,r17
 820afc4:	10c00a26 	beq	r2,r3,820aff0 <_malloc_trim_r+0x98>
 820afc8:	9009883a 	mov	r4,r18
 820afcc:	8214a940 	call	8214a94 <__malloc_unlock>
 820afd0:	0005883a 	mov	r2,zero
 820afd4:	dfc00417 	ldw	ra,16(sp)
 820afd8:	dcc00317 	ldw	r19,12(sp)
 820afdc:	dc800217 	ldw	r18,8(sp)
 820afe0:	dc400117 	ldw	r17,4(sp)
 820afe4:	dc000017 	ldw	r16,0(sp)
 820afe8:	dec00504 	addi	sp,sp,20
 820afec:	f800283a 	ret
 820aff0:	040bc83a 	sub	r5,zero,r16
 820aff4:	9009883a 	mov	r4,r18
 820aff8:	820dd980 	call	820dd98 <_sbrk_r>
 820affc:	00ffffc4 	movi	r3,-1
 820b000:	10c00d26 	beq	r2,r3,820b038 <_malloc_trim_r+0xe0>
 820b004:	00c20974 	movhi	r3,2085
 820b008:	18d1f904 	addi	r3,r3,18404
 820b00c:	18800017 	ldw	r2,0(r3)
 820b010:	99000217 	ldw	r4,8(r19)
 820b014:	8c23c83a 	sub	r17,r17,r16
 820b018:	8c400054 	ori	r17,r17,1
 820b01c:	1421c83a 	sub	r16,r2,r16
 820b020:	24400115 	stw	r17,4(r4)
 820b024:	9009883a 	mov	r4,r18
 820b028:	1c000015 	stw	r16,0(r3)
 820b02c:	8214a940 	call	8214a94 <__malloc_unlock>
 820b030:	00800044 	movi	r2,1
 820b034:	003fe706 	br	820afd4 <_malloc_trim_r+0x7c>
 820b038:	000b883a 	mov	r5,zero
 820b03c:	9009883a 	mov	r4,r18
 820b040:	820dd980 	call	820dd98 <_sbrk_r>
 820b044:	99000217 	ldw	r4,8(r19)
 820b048:	014003c4 	movi	r5,15
 820b04c:	1107c83a 	sub	r3,r2,r4
 820b050:	28ffdd0e 	bge	r5,r3,820afc8 <_malloc_trim_r+0x70>
 820b054:	01420974 	movhi	r5,2085
 820b058:	294fa404 	addi	r5,r5,16016
 820b05c:	29400017 	ldw	r5,0(r5)
 820b060:	18c00054 	ori	r3,r3,1
 820b064:	20c00115 	stw	r3,4(r4)
 820b068:	00c20974 	movhi	r3,2085
 820b06c:	1145c83a 	sub	r2,r2,r5
 820b070:	18d1f904 	addi	r3,r3,18404
 820b074:	18800015 	stw	r2,0(r3)
 820b078:	003fd306 	br	820afc8 <_malloc_trim_r+0x70>

0820b07c <_free_r>:
 820b07c:	28004126 	beq	r5,zero,820b184 <_free_r+0x108>
 820b080:	defffd04 	addi	sp,sp,-12
 820b084:	dc400115 	stw	r17,4(sp)
 820b088:	dc000015 	stw	r16,0(sp)
 820b08c:	2023883a 	mov	r17,r4
 820b090:	2821883a 	mov	r16,r5
 820b094:	dfc00215 	stw	ra,8(sp)
 820b098:	82149740 	call	8214974 <__malloc_lock>
 820b09c:	81ffff17 	ldw	r7,-4(r16)
 820b0a0:	00bfff84 	movi	r2,-2
 820b0a4:	01020974 	movhi	r4,2085
 820b0a8:	81bffe04 	addi	r6,r16,-8
 820b0ac:	3884703a 	and	r2,r7,r2
 820b0b0:	21093004 	addi	r4,r4,9408
 820b0b4:	308b883a 	add	r5,r6,r2
 820b0b8:	2a400117 	ldw	r9,4(r5)
 820b0bc:	22000217 	ldw	r8,8(r4)
 820b0c0:	00ffff04 	movi	r3,-4
 820b0c4:	48c6703a 	and	r3,r9,r3
 820b0c8:	2a005726 	beq	r5,r8,820b228 <_free_r+0x1ac>
 820b0cc:	28c00115 	stw	r3,4(r5)
 820b0d0:	39c0004c 	andi	r7,r7,1
 820b0d4:	3800091e 	bne	r7,zero,820b0fc <_free_r+0x80>
 820b0d8:	823ffe17 	ldw	r8,-8(r16)
 820b0dc:	22400204 	addi	r9,r4,8
 820b0e0:	320dc83a 	sub	r6,r6,r8
 820b0e4:	31c00217 	ldw	r7,8(r6)
 820b0e8:	1205883a 	add	r2,r2,r8
 820b0ec:	3a406526 	beq	r7,r9,820b284 <_free_r+0x208>
 820b0f0:	32000317 	ldw	r8,12(r6)
 820b0f4:	3a000315 	stw	r8,12(r7)
 820b0f8:	41c00215 	stw	r7,8(r8)
 820b0fc:	28cf883a 	add	r7,r5,r3
 820b100:	39c00117 	ldw	r7,4(r7)
 820b104:	39c0004c 	andi	r7,r7,1
 820b108:	38003a26 	beq	r7,zero,820b1f4 <_free_r+0x178>
 820b10c:	10c00054 	ori	r3,r2,1
 820b110:	30c00115 	stw	r3,4(r6)
 820b114:	3087883a 	add	r3,r6,r2
 820b118:	18800015 	stw	r2,0(r3)
 820b11c:	00c07fc4 	movi	r3,511
 820b120:	18801936 	bltu	r3,r2,820b188 <_free_r+0x10c>
 820b124:	1004d0fa 	srli	r2,r2,3
 820b128:	01c00044 	movi	r7,1
 820b12c:	21400117 	ldw	r5,4(r4)
 820b130:	10c00044 	addi	r3,r2,1
 820b134:	18c7883a 	add	r3,r3,r3
 820b138:	1005d0ba 	srai	r2,r2,2
 820b13c:	18c7883a 	add	r3,r3,r3
 820b140:	18c7883a 	add	r3,r3,r3
 820b144:	1907883a 	add	r3,r3,r4
 820b148:	3884983a 	sll	r2,r7,r2
 820b14c:	19c00017 	ldw	r7,0(r3)
 820b150:	1a3ffe04 	addi	r8,r3,-8
 820b154:	1144b03a 	or	r2,r2,r5
 820b158:	32000315 	stw	r8,12(r6)
 820b15c:	31c00215 	stw	r7,8(r6)
 820b160:	20800115 	stw	r2,4(r4)
 820b164:	19800015 	stw	r6,0(r3)
 820b168:	39800315 	stw	r6,12(r7)
 820b16c:	8809883a 	mov	r4,r17
 820b170:	dfc00217 	ldw	ra,8(sp)
 820b174:	dc400117 	ldw	r17,4(sp)
 820b178:	dc000017 	ldw	r16,0(sp)
 820b17c:	dec00304 	addi	sp,sp,12
 820b180:	8214a941 	jmpi	8214a94 <__malloc_unlock>
 820b184:	f800283a 	ret
 820b188:	100ad27a 	srli	r5,r2,9
 820b18c:	00c00104 	movi	r3,4
 820b190:	19404a36 	bltu	r3,r5,820b2bc <_free_r+0x240>
 820b194:	100ad1ba 	srli	r5,r2,6
 820b198:	28c00e44 	addi	r3,r5,57
 820b19c:	18c7883a 	add	r3,r3,r3
 820b1a0:	29400e04 	addi	r5,r5,56
 820b1a4:	18c7883a 	add	r3,r3,r3
 820b1a8:	18c7883a 	add	r3,r3,r3
 820b1ac:	1909883a 	add	r4,r3,r4
 820b1b0:	20c00017 	ldw	r3,0(r4)
 820b1b4:	01c20974 	movhi	r7,2085
 820b1b8:	213ffe04 	addi	r4,r4,-8
 820b1bc:	39c93004 	addi	r7,r7,9408
 820b1c0:	20c04426 	beq	r4,r3,820b2d4 <_free_r+0x258>
 820b1c4:	01ffff04 	movi	r7,-4
 820b1c8:	19400117 	ldw	r5,4(r3)
 820b1cc:	29ca703a 	and	r5,r5,r7
 820b1d0:	1140022e 	bgeu	r2,r5,820b1dc <_free_r+0x160>
 820b1d4:	18c00217 	ldw	r3,8(r3)
 820b1d8:	20fffb1e 	bne	r4,r3,820b1c8 <_free_r+0x14c>
 820b1dc:	19000317 	ldw	r4,12(r3)
 820b1e0:	31000315 	stw	r4,12(r6)
 820b1e4:	30c00215 	stw	r3,8(r6)
 820b1e8:	21800215 	stw	r6,8(r4)
 820b1ec:	19800315 	stw	r6,12(r3)
 820b1f0:	003fde06 	br	820b16c <_free_r+0xf0>
 820b1f4:	29c00217 	ldw	r7,8(r5)
 820b1f8:	10c5883a 	add	r2,r2,r3
 820b1fc:	00c20974 	movhi	r3,2085
 820b200:	18c93204 	addi	r3,r3,9416
 820b204:	38c03b26 	beq	r7,r3,820b2f4 <_free_r+0x278>
 820b208:	2a000317 	ldw	r8,12(r5)
 820b20c:	11400054 	ori	r5,r2,1
 820b210:	3087883a 	add	r3,r6,r2
 820b214:	3a000315 	stw	r8,12(r7)
 820b218:	41c00215 	stw	r7,8(r8)
 820b21c:	31400115 	stw	r5,4(r6)
 820b220:	18800015 	stw	r2,0(r3)
 820b224:	003fbd06 	br	820b11c <_free_r+0xa0>
 820b228:	39c0004c 	andi	r7,r7,1
 820b22c:	10c5883a 	add	r2,r2,r3
 820b230:	3800071e 	bne	r7,zero,820b250 <_free_r+0x1d4>
 820b234:	81fffe17 	ldw	r7,-8(r16)
 820b238:	31cdc83a 	sub	r6,r6,r7
 820b23c:	30c00317 	ldw	r3,12(r6)
 820b240:	31400217 	ldw	r5,8(r6)
 820b244:	11c5883a 	add	r2,r2,r7
 820b248:	28c00315 	stw	r3,12(r5)
 820b24c:	19400215 	stw	r5,8(r3)
 820b250:	10c00054 	ori	r3,r2,1
 820b254:	30c00115 	stw	r3,4(r6)
 820b258:	00c20974 	movhi	r3,2085
 820b25c:	18cfa504 	addi	r3,r3,16020
 820b260:	18c00017 	ldw	r3,0(r3)
 820b264:	21800215 	stw	r6,8(r4)
 820b268:	10ffc036 	bltu	r2,r3,820b16c <_free_r+0xf0>
 820b26c:	00820974 	movhi	r2,2085
 820b270:	10900204 	addi	r2,r2,16392
 820b274:	11400017 	ldw	r5,0(r2)
 820b278:	8809883a 	mov	r4,r17
 820b27c:	820af580 	call	820af58 <_malloc_trim_r>
 820b280:	003fba06 	br	820b16c <_free_r+0xf0>
 820b284:	28c9883a 	add	r4,r5,r3
 820b288:	21000117 	ldw	r4,4(r4)
 820b28c:	2100004c 	andi	r4,r4,1
 820b290:	2000391e 	bne	r4,zero,820b378 <_free_r+0x2fc>
 820b294:	29c00217 	ldw	r7,8(r5)
 820b298:	29000317 	ldw	r4,12(r5)
 820b29c:	1885883a 	add	r2,r3,r2
 820b2a0:	10c00054 	ori	r3,r2,1
 820b2a4:	39000315 	stw	r4,12(r7)
 820b2a8:	21c00215 	stw	r7,8(r4)
 820b2ac:	30c00115 	stw	r3,4(r6)
 820b2b0:	308d883a 	add	r6,r6,r2
 820b2b4:	30800015 	stw	r2,0(r6)
 820b2b8:	003fac06 	br	820b16c <_free_r+0xf0>
 820b2bc:	00c00504 	movi	r3,20
 820b2c0:	19401536 	bltu	r3,r5,820b318 <_free_r+0x29c>
 820b2c4:	28c01704 	addi	r3,r5,92
 820b2c8:	18c7883a 	add	r3,r3,r3
 820b2cc:	294016c4 	addi	r5,r5,91
 820b2d0:	003fb406 	br	820b1a4 <_free_r+0x128>
 820b2d4:	280bd0ba 	srai	r5,r5,2
 820b2d8:	00c00044 	movi	r3,1
 820b2dc:	38800117 	ldw	r2,4(r7)
 820b2e0:	194a983a 	sll	r5,r3,r5
 820b2e4:	2007883a 	mov	r3,r4
 820b2e8:	2884b03a 	or	r2,r5,r2
 820b2ec:	38800115 	stw	r2,4(r7)
 820b2f0:	003fbb06 	br	820b1e0 <_free_r+0x164>
 820b2f4:	21800515 	stw	r6,20(r4)
 820b2f8:	21800415 	stw	r6,16(r4)
 820b2fc:	10c00054 	ori	r3,r2,1
 820b300:	31c00315 	stw	r7,12(r6)
 820b304:	31c00215 	stw	r7,8(r6)
 820b308:	30c00115 	stw	r3,4(r6)
 820b30c:	308d883a 	add	r6,r6,r2
 820b310:	30800015 	stw	r2,0(r6)
 820b314:	003f9506 	br	820b16c <_free_r+0xf0>
 820b318:	00c01504 	movi	r3,84
 820b31c:	19400536 	bltu	r3,r5,820b334 <_free_r+0x2b8>
 820b320:	100ad33a 	srli	r5,r2,12
 820b324:	28c01bc4 	addi	r3,r5,111
 820b328:	18c7883a 	add	r3,r3,r3
 820b32c:	29401b84 	addi	r5,r5,110
 820b330:	003f9c06 	br	820b1a4 <_free_r+0x128>
 820b334:	00c05504 	movi	r3,340
 820b338:	19400536 	bltu	r3,r5,820b350 <_free_r+0x2d4>
 820b33c:	100ad3fa 	srli	r5,r2,15
 820b340:	28c01e04 	addi	r3,r5,120
 820b344:	18c7883a 	add	r3,r3,r3
 820b348:	29401dc4 	addi	r5,r5,119
 820b34c:	003f9506 	br	820b1a4 <_free_r+0x128>
 820b350:	00c15504 	movi	r3,1364
 820b354:	19400536 	bltu	r3,r5,820b36c <_free_r+0x2f0>
 820b358:	100ad4ba 	srli	r5,r2,18
 820b35c:	28c01f44 	addi	r3,r5,125
 820b360:	18c7883a 	add	r3,r3,r3
 820b364:	29401f04 	addi	r5,r5,124
 820b368:	003f8e06 	br	820b1a4 <_free_r+0x128>
 820b36c:	00c03f84 	movi	r3,254
 820b370:	01401f84 	movi	r5,126
 820b374:	003f8b06 	br	820b1a4 <_free_r+0x128>
 820b378:	10c00054 	ori	r3,r2,1
 820b37c:	30c00115 	stw	r3,4(r6)
 820b380:	308d883a 	add	r6,r6,r2
 820b384:	30800015 	stw	r2,0(r6)
 820b388:	003f7806 	br	820b16c <_free_r+0xf0>

0820b38c <__sfvwrite_r>:
 820b38c:	30800217 	ldw	r2,8(r6)
 820b390:	10006726 	beq	r2,zero,820b530 <__sfvwrite_r+0x1a4>
 820b394:	28c0030b 	ldhu	r3,12(r5)
 820b398:	defff404 	addi	sp,sp,-48
 820b39c:	dd400715 	stw	r21,28(sp)
 820b3a0:	dd000615 	stw	r20,24(sp)
 820b3a4:	dc000215 	stw	r16,8(sp)
 820b3a8:	dfc00b15 	stw	ra,44(sp)
 820b3ac:	df000a15 	stw	fp,40(sp)
 820b3b0:	ddc00915 	stw	r23,36(sp)
 820b3b4:	dd800815 	stw	r22,32(sp)
 820b3b8:	dcc00515 	stw	r19,20(sp)
 820b3bc:	dc800415 	stw	r18,16(sp)
 820b3c0:	dc400315 	stw	r17,12(sp)
 820b3c4:	1880020c 	andi	r2,r3,8
 820b3c8:	2821883a 	mov	r16,r5
 820b3cc:	202b883a 	mov	r21,r4
 820b3d0:	3029883a 	mov	r20,r6
 820b3d4:	10002726 	beq	r2,zero,820b474 <__sfvwrite_r+0xe8>
 820b3d8:	28800417 	ldw	r2,16(r5)
 820b3dc:	10002526 	beq	r2,zero,820b474 <__sfvwrite_r+0xe8>
 820b3e0:	1880008c 	andi	r2,r3,2
 820b3e4:	a4400017 	ldw	r17,0(r20)
 820b3e8:	10002a26 	beq	r2,zero,820b494 <__sfvwrite_r+0x108>
 820b3ec:	05a00034 	movhi	r22,32768
 820b3f0:	0027883a 	mov	r19,zero
 820b3f4:	0025883a 	mov	r18,zero
 820b3f8:	b5bf0004 	addi	r22,r22,-1024
 820b3fc:	980d883a 	mov	r6,r19
 820b400:	a809883a 	mov	r4,r21
 820b404:	90004626 	beq	r18,zero,820b520 <__sfvwrite_r+0x194>
 820b408:	900f883a 	mov	r7,r18
 820b40c:	b480022e 	bgeu	r22,r18,820b418 <__sfvwrite_r+0x8c>
 820b410:	01e00034 	movhi	r7,32768
 820b414:	39ff0004 	addi	r7,r7,-1024
 820b418:	80800917 	ldw	r2,36(r16)
 820b41c:	81400717 	ldw	r5,28(r16)
 820b420:	103ee83a 	callr	r2
 820b424:	0080570e 	bge	zero,r2,820b584 <__sfvwrite_r+0x1f8>
 820b428:	a0c00217 	ldw	r3,8(r20)
 820b42c:	98a7883a 	add	r19,r19,r2
 820b430:	90a5c83a 	sub	r18,r18,r2
 820b434:	1885c83a 	sub	r2,r3,r2
 820b438:	a0800215 	stw	r2,8(r20)
 820b43c:	103fef1e 	bne	r2,zero,820b3fc <__sfvwrite_r+0x70>
 820b440:	0005883a 	mov	r2,zero
 820b444:	dfc00b17 	ldw	ra,44(sp)
 820b448:	df000a17 	ldw	fp,40(sp)
 820b44c:	ddc00917 	ldw	r23,36(sp)
 820b450:	dd800817 	ldw	r22,32(sp)
 820b454:	dd400717 	ldw	r21,28(sp)
 820b458:	dd000617 	ldw	r20,24(sp)
 820b45c:	dcc00517 	ldw	r19,20(sp)
 820b460:	dc800417 	ldw	r18,16(sp)
 820b464:	dc400317 	ldw	r17,12(sp)
 820b468:	dc000217 	ldw	r16,8(sp)
 820b46c:	dec00c04 	addi	sp,sp,48
 820b470:	f800283a 	ret
 820b474:	800b883a 	mov	r5,r16
 820b478:	a809883a 	mov	r4,r21
 820b47c:	8208de00 	call	8208de0 <__swsetup_r>
 820b480:	1000eb1e 	bne	r2,zero,820b830 <__sfvwrite_r+0x4a4>
 820b484:	80c0030b 	ldhu	r3,12(r16)
 820b488:	a4400017 	ldw	r17,0(r20)
 820b48c:	1880008c 	andi	r2,r3,2
 820b490:	103fd61e 	bne	r2,zero,820b3ec <__sfvwrite_r+0x60>
 820b494:	1880004c 	andi	r2,r3,1
 820b498:	10003f1e 	bne	r2,zero,820b598 <__sfvwrite_r+0x20c>
 820b49c:	0039883a 	mov	fp,zero
 820b4a0:	0025883a 	mov	r18,zero
 820b4a4:	90001a26 	beq	r18,zero,820b510 <__sfvwrite_r+0x184>
 820b4a8:	1880800c 	andi	r2,r3,512
 820b4ac:	84c00217 	ldw	r19,8(r16)
 820b4b0:	10002126 	beq	r2,zero,820b538 <__sfvwrite_r+0x1ac>
 820b4b4:	982f883a 	mov	r23,r19
 820b4b8:	94c09336 	bltu	r18,r19,820b708 <__sfvwrite_r+0x37c>
 820b4bc:	1881200c 	andi	r2,r3,1152
 820b4c0:	10009e1e 	bne	r2,zero,820b73c <__sfvwrite_r+0x3b0>
 820b4c4:	81000017 	ldw	r4,0(r16)
 820b4c8:	b80d883a 	mov	r6,r23
 820b4cc:	e00b883a 	mov	r5,fp
 820b4d0:	8202fd40 	call	8202fd4 <memmove>
 820b4d4:	80c00217 	ldw	r3,8(r16)
 820b4d8:	81000017 	ldw	r4,0(r16)
 820b4dc:	9005883a 	mov	r2,r18
 820b4e0:	1ce7c83a 	sub	r19,r3,r19
 820b4e4:	25cf883a 	add	r7,r4,r23
 820b4e8:	84c00215 	stw	r19,8(r16)
 820b4ec:	81c00015 	stw	r7,0(r16)
 820b4f0:	a0c00217 	ldw	r3,8(r20)
 820b4f4:	e0b9883a 	add	fp,fp,r2
 820b4f8:	90a5c83a 	sub	r18,r18,r2
 820b4fc:	18a7c83a 	sub	r19,r3,r2
 820b500:	a4c00215 	stw	r19,8(r20)
 820b504:	983fce26 	beq	r19,zero,820b440 <__sfvwrite_r+0xb4>
 820b508:	80c0030b 	ldhu	r3,12(r16)
 820b50c:	903fe61e 	bne	r18,zero,820b4a8 <__sfvwrite_r+0x11c>
 820b510:	8f000017 	ldw	fp,0(r17)
 820b514:	8c800117 	ldw	r18,4(r17)
 820b518:	8c400204 	addi	r17,r17,8
 820b51c:	003fe106 	br	820b4a4 <__sfvwrite_r+0x118>
 820b520:	8cc00017 	ldw	r19,0(r17)
 820b524:	8c800117 	ldw	r18,4(r17)
 820b528:	8c400204 	addi	r17,r17,8
 820b52c:	003fb306 	br	820b3fc <__sfvwrite_r+0x70>
 820b530:	0005883a 	mov	r2,zero
 820b534:	f800283a 	ret
 820b538:	81000017 	ldw	r4,0(r16)
 820b53c:	80800417 	ldw	r2,16(r16)
 820b540:	11005736 	bltu	r2,r4,820b6a0 <__sfvwrite_r+0x314>
 820b544:	85c00517 	ldw	r23,20(r16)
 820b548:	95c05536 	bltu	r18,r23,820b6a0 <__sfvwrite_r+0x314>
 820b54c:	00a00034 	movhi	r2,32768
 820b550:	10bfffc4 	addi	r2,r2,-1
 820b554:	9009883a 	mov	r4,r18
 820b558:	1480012e 	bgeu	r2,r18,820b560 <__sfvwrite_r+0x1d4>
 820b55c:	1009883a 	mov	r4,r2
 820b560:	b80b883a 	mov	r5,r23
 820b564:	8202a940 	call	8202a94 <__divsi3>
 820b568:	15cf383a 	mul	r7,r2,r23
 820b56c:	81400717 	ldw	r5,28(r16)
 820b570:	80800917 	ldw	r2,36(r16)
 820b574:	e00d883a 	mov	r6,fp
 820b578:	a809883a 	mov	r4,r21
 820b57c:	103ee83a 	callr	r2
 820b580:	00bfdb16 	blt	zero,r2,820b4f0 <__sfvwrite_r+0x164>
 820b584:	8080030b 	ldhu	r2,12(r16)
 820b588:	10801014 	ori	r2,r2,64
 820b58c:	8080030d 	sth	r2,12(r16)
 820b590:	00bfffc4 	movi	r2,-1
 820b594:	003fab06 	br	820b444 <__sfvwrite_r+0xb8>
 820b598:	0027883a 	mov	r19,zero
 820b59c:	0011883a 	mov	r8,zero
 820b5a0:	0039883a 	mov	fp,zero
 820b5a4:	0025883a 	mov	r18,zero
 820b5a8:	90001f26 	beq	r18,zero,820b628 <__sfvwrite_r+0x29c>
 820b5ac:	40005a26 	beq	r8,zero,820b718 <__sfvwrite_r+0x38c>
 820b5b0:	982d883a 	mov	r22,r19
 820b5b4:	94c0012e 	bgeu	r18,r19,820b5bc <__sfvwrite_r+0x230>
 820b5b8:	902d883a 	mov	r22,r18
 820b5bc:	81000017 	ldw	r4,0(r16)
 820b5c0:	80800417 	ldw	r2,16(r16)
 820b5c4:	b02f883a 	mov	r23,r22
 820b5c8:	81c00517 	ldw	r7,20(r16)
 820b5cc:	1100032e 	bgeu	r2,r4,820b5dc <__sfvwrite_r+0x250>
 820b5d0:	80c00217 	ldw	r3,8(r16)
 820b5d4:	38c7883a 	add	r3,r7,r3
 820b5d8:	1d801816 	blt	r3,r22,820b63c <__sfvwrite_r+0x2b0>
 820b5dc:	b1c03e16 	blt	r22,r7,820b6d8 <__sfvwrite_r+0x34c>
 820b5e0:	80800917 	ldw	r2,36(r16)
 820b5e4:	81400717 	ldw	r5,28(r16)
 820b5e8:	e00d883a 	mov	r6,fp
 820b5ec:	da000115 	stw	r8,4(sp)
 820b5f0:	a809883a 	mov	r4,r21
 820b5f4:	103ee83a 	callr	r2
 820b5f8:	102f883a 	mov	r23,r2
 820b5fc:	da000117 	ldw	r8,4(sp)
 820b600:	00bfe00e 	bge	zero,r2,820b584 <__sfvwrite_r+0x1f8>
 820b604:	9de7c83a 	sub	r19,r19,r23
 820b608:	98001f26 	beq	r19,zero,820b688 <__sfvwrite_r+0x2fc>
 820b60c:	a0800217 	ldw	r2,8(r20)
 820b610:	e5f9883a 	add	fp,fp,r23
 820b614:	95e5c83a 	sub	r18,r18,r23
 820b618:	15efc83a 	sub	r23,r2,r23
 820b61c:	a5c00215 	stw	r23,8(r20)
 820b620:	b83f8726 	beq	r23,zero,820b440 <__sfvwrite_r+0xb4>
 820b624:	903fe11e 	bne	r18,zero,820b5ac <__sfvwrite_r+0x220>
 820b628:	8f000017 	ldw	fp,0(r17)
 820b62c:	8c800117 	ldw	r18,4(r17)
 820b630:	0011883a 	mov	r8,zero
 820b634:	8c400204 	addi	r17,r17,8
 820b638:	003fdb06 	br	820b5a8 <__sfvwrite_r+0x21c>
 820b63c:	180d883a 	mov	r6,r3
 820b640:	e00b883a 	mov	r5,fp
 820b644:	da000115 	stw	r8,4(sp)
 820b648:	d8c00015 	stw	r3,0(sp)
 820b64c:	8202fd40 	call	8202fd4 <memmove>
 820b650:	d8c00017 	ldw	r3,0(sp)
 820b654:	80800017 	ldw	r2,0(r16)
 820b658:	800b883a 	mov	r5,r16
 820b65c:	a809883a 	mov	r4,r21
 820b660:	10c5883a 	add	r2,r2,r3
 820b664:	80800015 	stw	r2,0(r16)
 820b668:	d8c00015 	stw	r3,0(sp)
 820b66c:	820a9d80 	call	820a9d8 <_fflush_r>
 820b670:	d8c00017 	ldw	r3,0(sp)
 820b674:	da000117 	ldw	r8,4(sp)
 820b678:	103fc21e 	bne	r2,zero,820b584 <__sfvwrite_r+0x1f8>
 820b67c:	182f883a 	mov	r23,r3
 820b680:	9de7c83a 	sub	r19,r19,r23
 820b684:	983fe11e 	bne	r19,zero,820b60c <__sfvwrite_r+0x280>
 820b688:	800b883a 	mov	r5,r16
 820b68c:	a809883a 	mov	r4,r21
 820b690:	820a9d80 	call	820a9d8 <_fflush_r>
 820b694:	103fbb1e 	bne	r2,zero,820b584 <__sfvwrite_r+0x1f8>
 820b698:	0011883a 	mov	r8,zero
 820b69c:	003fdb06 	br	820b60c <__sfvwrite_r+0x280>
 820b6a0:	94c0012e 	bgeu	r18,r19,820b6a8 <__sfvwrite_r+0x31c>
 820b6a4:	9027883a 	mov	r19,r18
 820b6a8:	980d883a 	mov	r6,r19
 820b6ac:	e00b883a 	mov	r5,fp
 820b6b0:	8202fd40 	call	8202fd4 <memmove>
 820b6b4:	80800217 	ldw	r2,8(r16)
 820b6b8:	80c00017 	ldw	r3,0(r16)
 820b6bc:	14c5c83a 	sub	r2,r2,r19
 820b6c0:	1cc7883a 	add	r3,r3,r19
 820b6c4:	80800215 	stw	r2,8(r16)
 820b6c8:	80c00015 	stw	r3,0(r16)
 820b6cc:	10004326 	beq	r2,zero,820b7dc <__sfvwrite_r+0x450>
 820b6d0:	9805883a 	mov	r2,r19
 820b6d4:	003f8606 	br	820b4f0 <__sfvwrite_r+0x164>
 820b6d8:	b00d883a 	mov	r6,r22
 820b6dc:	e00b883a 	mov	r5,fp
 820b6e0:	da000115 	stw	r8,4(sp)
 820b6e4:	8202fd40 	call	8202fd4 <memmove>
 820b6e8:	80800217 	ldw	r2,8(r16)
 820b6ec:	80c00017 	ldw	r3,0(r16)
 820b6f0:	da000117 	ldw	r8,4(sp)
 820b6f4:	1585c83a 	sub	r2,r2,r22
 820b6f8:	1dad883a 	add	r22,r3,r22
 820b6fc:	80800215 	stw	r2,8(r16)
 820b700:	85800015 	stw	r22,0(r16)
 820b704:	003fbf06 	br	820b604 <__sfvwrite_r+0x278>
 820b708:	81000017 	ldw	r4,0(r16)
 820b70c:	9027883a 	mov	r19,r18
 820b710:	902f883a 	mov	r23,r18
 820b714:	003f6c06 	br	820b4c8 <__sfvwrite_r+0x13c>
 820b718:	900d883a 	mov	r6,r18
 820b71c:	01400284 	movi	r5,10
 820b720:	e009883a 	mov	r4,fp
 820b724:	820c4740 	call	820c474 <memchr>
 820b728:	10003e26 	beq	r2,zero,820b824 <__sfvwrite_r+0x498>
 820b72c:	10800044 	addi	r2,r2,1
 820b730:	1727c83a 	sub	r19,r2,fp
 820b734:	02000044 	movi	r8,1
 820b738:	003f9d06 	br	820b5b0 <__sfvwrite_r+0x224>
 820b73c:	80800517 	ldw	r2,20(r16)
 820b740:	81400417 	ldw	r5,16(r16)
 820b744:	81c00017 	ldw	r7,0(r16)
 820b748:	10a7883a 	add	r19,r2,r2
 820b74c:	9885883a 	add	r2,r19,r2
 820b750:	1026d7fa 	srli	r19,r2,31
 820b754:	396dc83a 	sub	r22,r7,r5
 820b758:	b1000044 	addi	r4,r22,1
 820b75c:	9885883a 	add	r2,r19,r2
 820b760:	1027d07a 	srai	r19,r2,1
 820b764:	2485883a 	add	r2,r4,r18
 820b768:	980d883a 	mov	r6,r19
 820b76c:	9880022e 	bgeu	r19,r2,820b778 <__sfvwrite_r+0x3ec>
 820b770:	1027883a 	mov	r19,r2
 820b774:	100d883a 	mov	r6,r2
 820b778:	18c1000c 	andi	r3,r3,1024
 820b77c:	18001c26 	beq	r3,zero,820b7f0 <__sfvwrite_r+0x464>
 820b780:	300b883a 	mov	r5,r6
 820b784:	a809883a 	mov	r4,r21
 820b788:	820bc680 	call	820bc68 <_malloc_r>
 820b78c:	102f883a 	mov	r23,r2
 820b790:	10002926 	beq	r2,zero,820b838 <__sfvwrite_r+0x4ac>
 820b794:	81400417 	ldw	r5,16(r16)
 820b798:	b00d883a 	mov	r6,r22
 820b79c:	1009883a 	mov	r4,r2
 820b7a0:	8202e8c0 	call	8202e8c <memcpy>
 820b7a4:	8080030b 	ldhu	r2,12(r16)
 820b7a8:	00fedfc4 	movi	r3,-1153
 820b7ac:	10c4703a 	and	r2,r2,r3
 820b7b0:	10802014 	ori	r2,r2,128
 820b7b4:	8080030d 	sth	r2,12(r16)
 820b7b8:	bd89883a 	add	r4,r23,r22
 820b7bc:	9d8fc83a 	sub	r7,r19,r22
 820b7c0:	85c00415 	stw	r23,16(r16)
 820b7c4:	84c00515 	stw	r19,20(r16)
 820b7c8:	81000015 	stw	r4,0(r16)
 820b7cc:	9027883a 	mov	r19,r18
 820b7d0:	81c00215 	stw	r7,8(r16)
 820b7d4:	902f883a 	mov	r23,r18
 820b7d8:	003f3b06 	br	820b4c8 <__sfvwrite_r+0x13c>
 820b7dc:	800b883a 	mov	r5,r16
 820b7e0:	a809883a 	mov	r4,r21
 820b7e4:	820a9d80 	call	820a9d8 <_fflush_r>
 820b7e8:	103fb926 	beq	r2,zero,820b6d0 <__sfvwrite_r+0x344>
 820b7ec:	003f6506 	br	820b584 <__sfvwrite_r+0x1f8>
 820b7f0:	a809883a 	mov	r4,r21
 820b7f4:	820d5d00 	call	820d5d0 <_realloc_r>
 820b7f8:	102f883a 	mov	r23,r2
 820b7fc:	103fee1e 	bne	r2,zero,820b7b8 <__sfvwrite_r+0x42c>
 820b800:	81400417 	ldw	r5,16(r16)
 820b804:	a809883a 	mov	r4,r21
 820b808:	820b07c0 	call	820b07c <_free_r>
 820b80c:	8080030b 	ldhu	r2,12(r16)
 820b810:	00ffdfc4 	movi	r3,-129
 820b814:	1884703a 	and	r2,r3,r2
 820b818:	00c00304 	movi	r3,12
 820b81c:	a8c00015 	stw	r3,0(r21)
 820b820:	003f5906 	br	820b588 <__sfvwrite_r+0x1fc>
 820b824:	94c00044 	addi	r19,r18,1
 820b828:	02000044 	movi	r8,1
 820b82c:	003f6006 	br	820b5b0 <__sfvwrite_r+0x224>
 820b830:	00bfffc4 	movi	r2,-1
 820b834:	003f0306 	br	820b444 <__sfvwrite_r+0xb8>
 820b838:	00800304 	movi	r2,12
 820b83c:	a8800015 	stw	r2,0(r21)
 820b840:	8080030b 	ldhu	r2,12(r16)
 820b844:	003f5006 	br	820b588 <__sfvwrite_r+0x1fc>

0820b848 <_fwalk>:
 820b848:	defff704 	addi	sp,sp,-36
 820b84c:	dd000415 	stw	r20,16(sp)
 820b850:	dfc00815 	stw	ra,32(sp)
 820b854:	ddc00715 	stw	r23,28(sp)
 820b858:	dd800615 	stw	r22,24(sp)
 820b85c:	dd400515 	stw	r21,20(sp)
 820b860:	dcc00315 	stw	r19,12(sp)
 820b864:	dc800215 	stw	r18,8(sp)
 820b868:	dc400115 	stw	r17,4(sp)
 820b86c:	dc000015 	stw	r16,0(sp)
 820b870:	2500b804 	addi	r20,r4,736
 820b874:	a0002326 	beq	r20,zero,820b904 <_fwalk+0xbc>
 820b878:	282b883a 	mov	r21,r5
 820b87c:	002f883a 	mov	r23,zero
 820b880:	05800044 	movi	r22,1
 820b884:	04ffffc4 	movi	r19,-1
 820b888:	a4400117 	ldw	r17,4(r20)
 820b88c:	a4800217 	ldw	r18,8(r20)
 820b890:	8c7fffc4 	addi	r17,r17,-1
 820b894:	88000d16 	blt	r17,zero,820b8cc <_fwalk+0x84>
 820b898:	94000304 	addi	r16,r18,12
 820b89c:	94800384 	addi	r18,r18,14
 820b8a0:	8080000b 	ldhu	r2,0(r16)
 820b8a4:	8c7fffc4 	addi	r17,r17,-1
 820b8a8:	813ffd04 	addi	r4,r16,-12
 820b8ac:	b080042e 	bgeu	r22,r2,820b8c0 <_fwalk+0x78>
 820b8b0:	9080000f 	ldh	r2,0(r18)
 820b8b4:	14c00226 	beq	r2,r19,820b8c0 <_fwalk+0x78>
 820b8b8:	a83ee83a 	callr	r21
 820b8bc:	b8aeb03a 	or	r23,r23,r2
 820b8c0:	84001a04 	addi	r16,r16,104
 820b8c4:	94801a04 	addi	r18,r18,104
 820b8c8:	8cfff51e 	bne	r17,r19,820b8a0 <_fwalk+0x58>
 820b8cc:	a5000017 	ldw	r20,0(r20)
 820b8d0:	a03fed1e 	bne	r20,zero,820b888 <_fwalk+0x40>
 820b8d4:	b805883a 	mov	r2,r23
 820b8d8:	dfc00817 	ldw	ra,32(sp)
 820b8dc:	ddc00717 	ldw	r23,28(sp)
 820b8e0:	dd800617 	ldw	r22,24(sp)
 820b8e4:	dd400517 	ldw	r21,20(sp)
 820b8e8:	dd000417 	ldw	r20,16(sp)
 820b8ec:	dcc00317 	ldw	r19,12(sp)
 820b8f0:	dc800217 	ldw	r18,8(sp)
 820b8f4:	dc400117 	ldw	r17,4(sp)
 820b8f8:	dc000017 	ldw	r16,0(sp)
 820b8fc:	dec00904 	addi	sp,sp,36
 820b900:	f800283a 	ret
 820b904:	002f883a 	mov	r23,zero
 820b908:	003ff206 	br	820b8d4 <_fwalk+0x8c>

0820b90c <_fwalk_reent>:
 820b90c:	defff704 	addi	sp,sp,-36
 820b910:	dd000415 	stw	r20,16(sp)
 820b914:	dfc00815 	stw	ra,32(sp)
 820b918:	ddc00715 	stw	r23,28(sp)
 820b91c:	dd800615 	stw	r22,24(sp)
 820b920:	dd400515 	stw	r21,20(sp)
 820b924:	dcc00315 	stw	r19,12(sp)
 820b928:	dc800215 	stw	r18,8(sp)
 820b92c:	dc400115 	stw	r17,4(sp)
 820b930:	dc000015 	stw	r16,0(sp)
 820b934:	2500b804 	addi	r20,r4,736
 820b938:	a0002326 	beq	r20,zero,820b9c8 <_fwalk_reent+0xbc>
 820b93c:	282b883a 	mov	r21,r5
 820b940:	2027883a 	mov	r19,r4
 820b944:	002f883a 	mov	r23,zero
 820b948:	05800044 	movi	r22,1
 820b94c:	04bfffc4 	movi	r18,-1
 820b950:	a4400117 	ldw	r17,4(r20)
 820b954:	a4000217 	ldw	r16,8(r20)
 820b958:	8c7fffc4 	addi	r17,r17,-1
 820b95c:	88000c16 	blt	r17,zero,820b990 <_fwalk_reent+0x84>
 820b960:	84000304 	addi	r16,r16,12
 820b964:	8080000b 	ldhu	r2,0(r16)
 820b968:	8c7fffc4 	addi	r17,r17,-1
 820b96c:	817ffd04 	addi	r5,r16,-12
 820b970:	b080052e 	bgeu	r22,r2,820b988 <_fwalk_reent+0x7c>
 820b974:	8080008f 	ldh	r2,2(r16)
 820b978:	9809883a 	mov	r4,r19
 820b97c:	14800226 	beq	r2,r18,820b988 <_fwalk_reent+0x7c>
 820b980:	a83ee83a 	callr	r21
 820b984:	b8aeb03a 	or	r23,r23,r2
 820b988:	84001a04 	addi	r16,r16,104
 820b98c:	8cbff51e 	bne	r17,r18,820b964 <_fwalk_reent+0x58>
 820b990:	a5000017 	ldw	r20,0(r20)
 820b994:	a03fee1e 	bne	r20,zero,820b950 <_fwalk_reent+0x44>
 820b998:	b805883a 	mov	r2,r23
 820b99c:	dfc00817 	ldw	ra,32(sp)
 820b9a0:	ddc00717 	ldw	r23,28(sp)
 820b9a4:	dd800617 	ldw	r22,24(sp)
 820b9a8:	dd400517 	ldw	r21,20(sp)
 820b9ac:	dd000417 	ldw	r20,16(sp)
 820b9b0:	dcc00317 	ldw	r19,12(sp)
 820b9b4:	dc800217 	ldw	r18,8(sp)
 820b9b8:	dc400117 	ldw	r17,4(sp)
 820b9bc:	dc000017 	ldw	r16,0(sp)
 820b9c0:	dec00904 	addi	sp,sp,36
 820b9c4:	f800283a 	ret
 820b9c8:	002f883a 	mov	r23,zero
 820b9cc:	003ff206 	br	820b998 <_fwalk_reent+0x8c>

0820b9d0 <_setlocale_r>:
 820b9d0:	30001b26 	beq	r6,zero,820ba40 <_setlocale_r+0x70>
 820b9d4:	01420974 	movhi	r5,2085
 820b9d8:	defffe04 	addi	sp,sp,-8
 820b9dc:	2976e804 	addi	r5,r5,-9312
 820b9e0:	3009883a 	mov	r4,r6
 820b9e4:	dc000015 	stw	r16,0(sp)
 820b9e8:	dfc00115 	stw	ra,4(sp)
 820b9ec:	3021883a 	mov	r16,r6
 820b9f0:	820df280 	call	820df28 <strcmp>
 820b9f4:	1000061e 	bne	r2,zero,820ba10 <_setlocale_r+0x40>
 820b9f8:	00820974 	movhi	r2,2085
 820b9fc:	10b50004 	addi	r2,r2,-11264
 820ba00:	dfc00117 	ldw	ra,4(sp)
 820ba04:	dc000017 	ldw	r16,0(sp)
 820ba08:	dec00204 	addi	sp,sp,8
 820ba0c:	f800283a 	ret
 820ba10:	01420974 	movhi	r5,2085
 820ba14:	29750004 	addi	r5,r5,-11264
 820ba18:	8009883a 	mov	r4,r16
 820ba1c:	820df280 	call	820df28 <strcmp>
 820ba20:	103ff526 	beq	r2,zero,820b9f8 <_setlocale_r+0x28>
 820ba24:	01420974 	movhi	r5,2085
 820ba28:	2976cb04 	addi	r5,r5,-9428
 820ba2c:	8009883a 	mov	r4,r16
 820ba30:	820df280 	call	820df28 <strcmp>
 820ba34:	103ff026 	beq	r2,zero,820b9f8 <_setlocale_r+0x28>
 820ba38:	0005883a 	mov	r2,zero
 820ba3c:	003ff006 	br	820ba00 <_setlocale_r+0x30>
 820ba40:	00820974 	movhi	r2,2085
 820ba44:	10b50004 	addi	r2,r2,-11264
 820ba48:	f800283a 	ret

0820ba4c <__locale_charset>:
 820ba4c:	00820974 	movhi	r2,2085
 820ba50:	10891a04 	addi	r2,r2,9320
 820ba54:	f800283a 	ret

0820ba58 <__locale_mb_cur_max>:
 820ba58:	00820974 	movhi	r2,2085
 820ba5c:	108fa304 	addi	r2,r2,16012
 820ba60:	10800017 	ldw	r2,0(r2)
 820ba64:	f800283a 	ret

0820ba68 <__locale_msgcharset>:
 820ba68:	00820974 	movhi	r2,2085
 820ba6c:	10891204 	addi	r2,r2,9288
 820ba70:	f800283a 	ret

0820ba74 <__locale_cjk_lang>:
 820ba74:	0005883a 	mov	r2,zero
 820ba78:	f800283a 	ret

0820ba7c <_localeconv_r>:
 820ba7c:	00820974 	movhi	r2,2085
 820ba80:	10892204 	addi	r2,r2,9352
 820ba84:	f800283a 	ret

0820ba88 <setlocale>:
 820ba88:	00820974 	movhi	r2,2085
 820ba8c:	108fa204 	addi	r2,r2,16008
 820ba90:	280d883a 	mov	r6,r5
 820ba94:	200b883a 	mov	r5,r4
 820ba98:	11000017 	ldw	r4,0(r2)
 820ba9c:	820b9d01 	jmpi	820b9d0 <_setlocale_r>

0820baa0 <localeconv>:
 820baa0:	00820974 	movhi	r2,2085
 820baa4:	10892204 	addi	r2,r2,9352
 820baa8:	f800283a 	ret

0820baac <__smakebuf_r>:
 820baac:	2880030b 	ldhu	r2,12(r5)
 820bab0:	10c0008c 	andi	r3,r2,2
 820bab4:	1800411e 	bne	r3,zero,820bbbc <__smakebuf_r+0x110>
 820bab8:	deffec04 	addi	sp,sp,-80
 820babc:	dc000f15 	stw	r16,60(sp)
 820bac0:	2821883a 	mov	r16,r5
 820bac4:	2940038f 	ldh	r5,14(r5)
 820bac8:	dc401015 	stw	r17,64(sp)
 820bacc:	dfc01315 	stw	ra,76(sp)
 820bad0:	dcc01215 	stw	r19,72(sp)
 820bad4:	dc801115 	stw	r18,68(sp)
 820bad8:	2023883a 	mov	r17,r4
 820badc:	28001c16 	blt	r5,zero,820bb50 <__smakebuf_r+0xa4>
 820bae0:	d80d883a 	mov	r6,sp
 820bae4:	8210edc0 	call	8210edc <_fstat_r>
 820bae8:	10001816 	blt	r2,zero,820bb4c <__smakebuf_r+0xa0>
 820baec:	d8800117 	ldw	r2,4(sp)
 820baf0:	00e00014 	movui	r3,32768
 820baf4:	10bc000c 	andi	r2,r2,61440
 820baf8:	14c80020 	cmpeqi	r19,r2,8192
 820bafc:	10c03726 	beq	r2,r3,820bbdc <__smakebuf_r+0x130>
 820bb00:	80c0030b 	ldhu	r3,12(r16)
 820bb04:	18c20014 	ori	r3,r3,2048
 820bb08:	80c0030d 	sth	r3,12(r16)
 820bb0c:	00c80004 	movi	r3,8192
 820bb10:	10c0521e 	bne	r2,r3,820bc5c <__smakebuf_r+0x1b0>
 820bb14:	8140038f 	ldh	r5,14(r16)
 820bb18:	8809883a 	mov	r4,r17
 820bb1c:	8210f380 	call	8210f38 <_isatty_r>
 820bb20:	10004c26 	beq	r2,zero,820bc54 <__smakebuf_r+0x1a8>
 820bb24:	8080030b 	ldhu	r2,12(r16)
 820bb28:	80c010c4 	addi	r3,r16,67
 820bb2c:	80c00015 	stw	r3,0(r16)
 820bb30:	10800054 	ori	r2,r2,1
 820bb34:	8080030d 	sth	r2,12(r16)
 820bb38:	00800044 	movi	r2,1
 820bb3c:	80c00415 	stw	r3,16(r16)
 820bb40:	80800515 	stw	r2,20(r16)
 820bb44:	04810004 	movi	r18,1024
 820bb48:	00000706 	br	820bb68 <__smakebuf_r+0xbc>
 820bb4c:	8080030b 	ldhu	r2,12(r16)
 820bb50:	10c0200c 	andi	r3,r2,128
 820bb54:	18001f1e 	bne	r3,zero,820bbd4 <__smakebuf_r+0x128>
 820bb58:	04810004 	movi	r18,1024
 820bb5c:	10820014 	ori	r2,r2,2048
 820bb60:	8080030d 	sth	r2,12(r16)
 820bb64:	0027883a 	mov	r19,zero
 820bb68:	900b883a 	mov	r5,r18
 820bb6c:	8809883a 	mov	r4,r17
 820bb70:	820bc680 	call	820bc68 <_malloc_r>
 820bb74:	10002c26 	beq	r2,zero,820bc28 <__smakebuf_r+0x17c>
 820bb78:	80c0030b 	ldhu	r3,12(r16)
 820bb7c:	01020874 	movhi	r4,2081
 820bb80:	212a9b04 	addi	r4,r4,-21908
 820bb84:	89000f15 	stw	r4,60(r17)
 820bb88:	18c02014 	ori	r3,r3,128
 820bb8c:	80c0030d 	sth	r3,12(r16)
 820bb90:	80800015 	stw	r2,0(r16)
 820bb94:	80800415 	stw	r2,16(r16)
 820bb98:	84800515 	stw	r18,20(r16)
 820bb9c:	98001a1e 	bne	r19,zero,820bc08 <__smakebuf_r+0x15c>
 820bba0:	dfc01317 	ldw	ra,76(sp)
 820bba4:	dcc01217 	ldw	r19,72(sp)
 820bba8:	dc801117 	ldw	r18,68(sp)
 820bbac:	dc401017 	ldw	r17,64(sp)
 820bbb0:	dc000f17 	ldw	r16,60(sp)
 820bbb4:	dec01404 	addi	sp,sp,80
 820bbb8:	f800283a 	ret
 820bbbc:	288010c4 	addi	r2,r5,67
 820bbc0:	28800015 	stw	r2,0(r5)
 820bbc4:	28800415 	stw	r2,16(r5)
 820bbc8:	00800044 	movi	r2,1
 820bbcc:	28800515 	stw	r2,20(r5)
 820bbd0:	f800283a 	ret
 820bbd4:	04801004 	movi	r18,64
 820bbd8:	003fe006 	br	820bb5c <__smakebuf_r+0xb0>
 820bbdc:	81000a17 	ldw	r4,40(r16)
 820bbe0:	00c20874 	movhi	r3,2081
 820bbe4:	18f7b104 	addi	r3,r3,-8508
 820bbe8:	20ffc51e 	bne	r4,r3,820bb00 <__smakebuf_r+0x54>
 820bbec:	8080030b 	ldhu	r2,12(r16)
 820bbf0:	04810004 	movi	r18,1024
 820bbf4:	84801315 	stw	r18,76(r16)
 820bbf8:	1484b03a 	or	r2,r2,r18
 820bbfc:	8080030d 	sth	r2,12(r16)
 820bc00:	0027883a 	mov	r19,zero
 820bc04:	003fd806 	br	820bb68 <__smakebuf_r+0xbc>
 820bc08:	8140038f 	ldh	r5,14(r16)
 820bc0c:	8809883a 	mov	r4,r17
 820bc10:	8210f380 	call	8210f38 <_isatty_r>
 820bc14:	103fe226 	beq	r2,zero,820bba0 <__smakebuf_r+0xf4>
 820bc18:	8080030b 	ldhu	r2,12(r16)
 820bc1c:	10800054 	ori	r2,r2,1
 820bc20:	8080030d 	sth	r2,12(r16)
 820bc24:	003fde06 	br	820bba0 <__smakebuf_r+0xf4>
 820bc28:	8080030b 	ldhu	r2,12(r16)
 820bc2c:	10c0800c 	andi	r3,r2,512
 820bc30:	183fdb1e 	bne	r3,zero,820bba0 <__smakebuf_r+0xf4>
 820bc34:	10800094 	ori	r2,r2,2
 820bc38:	80c010c4 	addi	r3,r16,67
 820bc3c:	8080030d 	sth	r2,12(r16)
 820bc40:	00800044 	movi	r2,1
 820bc44:	80c00015 	stw	r3,0(r16)
 820bc48:	80c00415 	stw	r3,16(r16)
 820bc4c:	80800515 	stw	r2,20(r16)
 820bc50:	003fd306 	br	820bba0 <__smakebuf_r+0xf4>
 820bc54:	04810004 	movi	r18,1024
 820bc58:	003fc306 	br	820bb68 <__smakebuf_r+0xbc>
 820bc5c:	0027883a 	mov	r19,zero
 820bc60:	04810004 	movi	r18,1024
 820bc64:	003fc006 	br	820bb68 <__smakebuf_r+0xbc>

0820bc68 <_malloc_r>:
 820bc68:	defff504 	addi	sp,sp,-44
 820bc6c:	dc800315 	stw	r18,12(sp)
 820bc70:	dfc00a15 	stw	ra,40(sp)
 820bc74:	df000915 	stw	fp,36(sp)
 820bc78:	ddc00815 	stw	r23,32(sp)
 820bc7c:	dd800715 	stw	r22,28(sp)
 820bc80:	dd400615 	stw	r21,24(sp)
 820bc84:	dd000515 	stw	r20,20(sp)
 820bc88:	dcc00415 	stw	r19,16(sp)
 820bc8c:	dc400215 	stw	r17,8(sp)
 820bc90:	dc000115 	stw	r16,4(sp)
 820bc94:	288002c4 	addi	r2,r5,11
 820bc98:	00c00584 	movi	r3,22
 820bc9c:	2025883a 	mov	r18,r4
 820bca0:	18807f2e 	bgeu	r3,r2,820bea0 <_malloc_r+0x238>
 820bca4:	047ffe04 	movi	r17,-8
 820bca8:	1462703a 	and	r17,r2,r17
 820bcac:	8800a316 	blt	r17,zero,820bf3c <_malloc_r+0x2d4>
 820bcb0:	8940a236 	bltu	r17,r5,820bf3c <_malloc_r+0x2d4>
 820bcb4:	82149740 	call	8214974 <__malloc_lock>
 820bcb8:	00807dc4 	movi	r2,503
 820bcbc:	1441e92e 	bgeu	r2,r17,820c464 <_malloc_r+0x7fc>
 820bcc0:	8804d27a 	srli	r2,r17,9
 820bcc4:	1000a126 	beq	r2,zero,820bf4c <_malloc_r+0x2e4>
 820bcc8:	00c00104 	movi	r3,4
 820bccc:	18811e36 	bltu	r3,r2,820c148 <_malloc_r+0x4e0>
 820bcd0:	8804d1ba 	srli	r2,r17,6
 820bcd4:	12000e44 	addi	r8,r2,57
 820bcd8:	11c00e04 	addi	r7,r2,56
 820bcdc:	4209883a 	add	r4,r8,r8
 820bce0:	04c20974 	movhi	r19,2085
 820bce4:	2109883a 	add	r4,r4,r4
 820bce8:	9cc93004 	addi	r19,r19,9408
 820bcec:	2109883a 	add	r4,r4,r4
 820bcf0:	9909883a 	add	r4,r19,r4
 820bcf4:	24000117 	ldw	r16,4(r4)
 820bcf8:	213ffe04 	addi	r4,r4,-8
 820bcfc:	24009726 	beq	r4,r16,820bf5c <_malloc_r+0x2f4>
 820bd00:	80800117 	ldw	r2,4(r16)
 820bd04:	01bfff04 	movi	r6,-4
 820bd08:	014003c4 	movi	r5,15
 820bd0c:	1184703a 	and	r2,r2,r6
 820bd10:	1447c83a 	sub	r3,r2,r17
 820bd14:	28c00716 	blt	r5,r3,820bd34 <_malloc_r+0xcc>
 820bd18:	1800920e 	bge	r3,zero,820bf64 <_malloc_r+0x2fc>
 820bd1c:	84000317 	ldw	r16,12(r16)
 820bd20:	24008e26 	beq	r4,r16,820bf5c <_malloc_r+0x2f4>
 820bd24:	80800117 	ldw	r2,4(r16)
 820bd28:	1184703a 	and	r2,r2,r6
 820bd2c:	1447c83a 	sub	r3,r2,r17
 820bd30:	28fff90e 	bge	r5,r3,820bd18 <_malloc_r+0xb0>
 820bd34:	3809883a 	mov	r4,r7
 820bd38:	01820974 	movhi	r6,2085
 820bd3c:	9c000417 	ldw	r16,16(r19)
 820bd40:	31893004 	addi	r6,r6,9408
 820bd44:	32000204 	addi	r8,r6,8
 820bd48:	82013426 	beq	r16,r8,820c21c <_malloc_r+0x5b4>
 820bd4c:	80c00117 	ldw	r3,4(r16)
 820bd50:	00bfff04 	movi	r2,-4
 820bd54:	188e703a 	and	r7,r3,r2
 820bd58:	3c45c83a 	sub	r2,r7,r17
 820bd5c:	00c003c4 	movi	r3,15
 820bd60:	18811f16 	blt	r3,r2,820c1e0 <_malloc_r+0x578>
 820bd64:	32000515 	stw	r8,20(r6)
 820bd68:	32000415 	stw	r8,16(r6)
 820bd6c:	10007f0e 	bge	r2,zero,820bf6c <_malloc_r+0x304>
 820bd70:	00807fc4 	movi	r2,511
 820bd74:	11c0fd36 	bltu	r2,r7,820c16c <_malloc_r+0x504>
 820bd78:	3806d0fa 	srli	r3,r7,3
 820bd7c:	01c00044 	movi	r7,1
 820bd80:	30800117 	ldw	r2,4(r6)
 820bd84:	19400044 	addi	r5,r3,1
 820bd88:	294b883a 	add	r5,r5,r5
 820bd8c:	1807d0ba 	srai	r3,r3,2
 820bd90:	294b883a 	add	r5,r5,r5
 820bd94:	294b883a 	add	r5,r5,r5
 820bd98:	298b883a 	add	r5,r5,r6
 820bd9c:	38c6983a 	sll	r3,r7,r3
 820bda0:	29c00017 	ldw	r7,0(r5)
 820bda4:	2a7ffe04 	addi	r9,r5,-8
 820bda8:	1886b03a 	or	r3,r3,r2
 820bdac:	82400315 	stw	r9,12(r16)
 820bdb0:	81c00215 	stw	r7,8(r16)
 820bdb4:	30c00115 	stw	r3,4(r6)
 820bdb8:	2c000015 	stw	r16,0(r5)
 820bdbc:	3c000315 	stw	r16,12(r7)
 820bdc0:	2005d0ba 	srai	r2,r4,2
 820bdc4:	01400044 	movi	r5,1
 820bdc8:	288a983a 	sll	r5,r5,r2
 820bdcc:	19406f36 	bltu	r3,r5,820bf8c <_malloc_r+0x324>
 820bdd0:	28c4703a 	and	r2,r5,r3
 820bdd4:	10000a1e 	bne	r2,zero,820be00 <_malloc_r+0x198>
 820bdd8:	00bfff04 	movi	r2,-4
 820bddc:	294b883a 	add	r5,r5,r5
 820bde0:	2088703a 	and	r4,r4,r2
 820bde4:	28c4703a 	and	r2,r5,r3
 820bde8:	21000104 	addi	r4,r4,4
 820bdec:	1000041e 	bne	r2,zero,820be00 <_malloc_r+0x198>
 820bdf0:	294b883a 	add	r5,r5,r5
 820bdf4:	28c4703a 	and	r2,r5,r3
 820bdf8:	21000104 	addi	r4,r4,4
 820bdfc:	103ffc26 	beq	r2,zero,820bdf0 <_malloc_r+0x188>
 820be00:	02bfff04 	movi	r10,-4
 820be04:	024003c4 	movi	r9,15
 820be08:	21800044 	addi	r6,r4,1
 820be0c:	318d883a 	add	r6,r6,r6
 820be10:	318d883a 	add	r6,r6,r6
 820be14:	318d883a 	add	r6,r6,r6
 820be18:	998d883a 	add	r6,r19,r6
 820be1c:	333ffe04 	addi	r12,r6,-8
 820be20:	2017883a 	mov	r11,r4
 820be24:	31800104 	addi	r6,r6,4
 820be28:	34000017 	ldw	r16,0(r6)
 820be2c:	31fffd04 	addi	r7,r6,-12
 820be30:	81c0041e 	bne	r16,r7,820be44 <_malloc_r+0x1dc>
 820be34:	0000fb06 	br	820c224 <_malloc_r+0x5bc>
 820be38:	1801030e 	bge	r3,zero,820c248 <_malloc_r+0x5e0>
 820be3c:	84000317 	ldw	r16,12(r16)
 820be40:	81c0f826 	beq	r16,r7,820c224 <_malloc_r+0x5bc>
 820be44:	80800117 	ldw	r2,4(r16)
 820be48:	1284703a 	and	r2,r2,r10
 820be4c:	1447c83a 	sub	r3,r2,r17
 820be50:	48fff90e 	bge	r9,r3,820be38 <_malloc_r+0x1d0>
 820be54:	80800317 	ldw	r2,12(r16)
 820be58:	81000217 	ldw	r4,8(r16)
 820be5c:	89400054 	ori	r5,r17,1
 820be60:	81400115 	stw	r5,4(r16)
 820be64:	20800315 	stw	r2,12(r4)
 820be68:	11000215 	stw	r4,8(r2)
 820be6c:	8463883a 	add	r17,r16,r17
 820be70:	9c400515 	stw	r17,20(r19)
 820be74:	9c400415 	stw	r17,16(r19)
 820be78:	18800054 	ori	r2,r3,1
 820be7c:	88800115 	stw	r2,4(r17)
 820be80:	8a000315 	stw	r8,12(r17)
 820be84:	8a000215 	stw	r8,8(r17)
 820be88:	88e3883a 	add	r17,r17,r3
 820be8c:	88c00015 	stw	r3,0(r17)
 820be90:	9009883a 	mov	r4,r18
 820be94:	8214a940 	call	8214a94 <__malloc_unlock>
 820be98:	80800204 	addi	r2,r16,8
 820be9c:	00001b06 	br	820bf0c <_malloc_r+0x2a4>
 820bea0:	04400404 	movi	r17,16
 820bea4:	89402536 	bltu	r17,r5,820bf3c <_malloc_r+0x2d4>
 820bea8:	82149740 	call	8214974 <__malloc_lock>
 820beac:	00800184 	movi	r2,6
 820beb0:	01000084 	movi	r4,2
 820beb4:	04c20974 	movhi	r19,2085
 820beb8:	1085883a 	add	r2,r2,r2
 820bebc:	9cc93004 	addi	r19,r19,9408
 820bec0:	1085883a 	add	r2,r2,r2
 820bec4:	9885883a 	add	r2,r19,r2
 820bec8:	14000117 	ldw	r16,4(r2)
 820becc:	10fffe04 	addi	r3,r2,-8
 820bed0:	80c0d926 	beq	r16,r3,820c238 <_malloc_r+0x5d0>
 820bed4:	80c00117 	ldw	r3,4(r16)
 820bed8:	81000317 	ldw	r4,12(r16)
 820bedc:	00bfff04 	movi	r2,-4
 820bee0:	1884703a 	and	r2,r3,r2
 820bee4:	81400217 	ldw	r5,8(r16)
 820bee8:	8085883a 	add	r2,r16,r2
 820beec:	10c00117 	ldw	r3,4(r2)
 820bef0:	29000315 	stw	r4,12(r5)
 820bef4:	21400215 	stw	r5,8(r4)
 820bef8:	18c00054 	ori	r3,r3,1
 820befc:	10c00115 	stw	r3,4(r2)
 820bf00:	9009883a 	mov	r4,r18
 820bf04:	8214a940 	call	8214a94 <__malloc_unlock>
 820bf08:	80800204 	addi	r2,r16,8
 820bf0c:	dfc00a17 	ldw	ra,40(sp)
 820bf10:	df000917 	ldw	fp,36(sp)
 820bf14:	ddc00817 	ldw	r23,32(sp)
 820bf18:	dd800717 	ldw	r22,28(sp)
 820bf1c:	dd400617 	ldw	r21,24(sp)
 820bf20:	dd000517 	ldw	r20,20(sp)
 820bf24:	dcc00417 	ldw	r19,16(sp)
 820bf28:	dc800317 	ldw	r18,12(sp)
 820bf2c:	dc400217 	ldw	r17,8(sp)
 820bf30:	dc000117 	ldw	r16,4(sp)
 820bf34:	dec00b04 	addi	sp,sp,44
 820bf38:	f800283a 	ret
 820bf3c:	00800304 	movi	r2,12
 820bf40:	90800015 	stw	r2,0(r18)
 820bf44:	0005883a 	mov	r2,zero
 820bf48:	003ff006 	br	820bf0c <_malloc_r+0x2a4>
 820bf4c:	01002004 	movi	r4,128
 820bf50:	02001004 	movi	r8,64
 820bf54:	01c00fc4 	movi	r7,63
 820bf58:	003f6106 	br	820bce0 <_malloc_r+0x78>
 820bf5c:	4009883a 	mov	r4,r8
 820bf60:	003f7506 	br	820bd38 <_malloc_r+0xd0>
 820bf64:	81000317 	ldw	r4,12(r16)
 820bf68:	003fde06 	br	820bee4 <_malloc_r+0x27c>
 820bf6c:	81c5883a 	add	r2,r16,r7
 820bf70:	11400117 	ldw	r5,4(r2)
 820bf74:	9009883a 	mov	r4,r18
 820bf78:	29400054 	ori	r5,r5,1
 820bf7c:	11400115 	stw	r5,4(r2)
 820bf80:	8214a940 	call	8214a94 <__malloc_unlock>
 820bf84:	80800204 	addi	r2,r16,8
 820bf88:	003fe006 	br	820bf0c <_malloc_r+0x2a4>
 820bf8c:	9c000217 	ldw	r16,8(r19)
 820bf90:	00bfff04 	movi	r2,-4
 820bf94:	85800117 	ldw	r22,4(r16)
 820bf98:	b0ac703a 	and	r22,r22,r2
 820bf9c:	b4400336 	bltu	r22,r17,820bfac <_malloc_r+0x344>
 820bfa0:	b445c83a 	sub	r2,r22,r17
 820bfa4:	00c003c4 	movi	r3,15
 820bfa8:	18805d16 	blt	r3,r2,820c120 <_malloc_r+0x4b8>
 820bfac:	05c20974 	movhi	r23,2085
 820bfb0:	00820974 	movhi	r2,2085
 820bfb4:	10900204 	addi	r2,r2,16392
 820bfb8:	bdcfa404 	addi	r23,r23,16016
 820bfbc:	15400017 	ldw	r21,0(r2)
 820bfc0:	b8c00017 	ldw	r3,0(r23)
 820bfc4:	00bfffc4 	movi	r2,-1
 820bfc8:	858d883a 	add	r6,r16,r22
 820bfcc:	8d6b883a 	add	r21,r17,r21
 820bfd0:	1880ea26 	beq	r3,r2,820c37c <_malloc_r+0x714>
 820bfd4:	ad4403c4 	addi	r21,r21,4111
 820bfd8:	00bc0004 	movi	r2,-4096
 820bfdc:	a8aa703a 	and	r21,r21,r2
 820bfe0:	a80b883a 	mov	r5,r21
 820bfe4:	9009883a 	mov	r4,r18
 820bfe8:	d9800015 	stw	r6,0(sp)
 820bfec:	820dd980 	call	820dd98 <_sbrk_r>
 820bff0:	1029883a 	mov	r20,r2
 820bff4:	00bfffc4 	movi	r2,-1
 820bff8:	d9800017 	ldw	r6,0(sp)
 820bffc:	a080e826 	beq	r20,r2,820c3a0 <_malloc_r+0x738>
 820c000:	a180a636 	bltu	r20,r6,820c29c <_malloc_r+0x634>
 820c004:	07020974 	movhi	fp,2085
 820c008:	e711f904 	addi	fp,fp,18404
 820c00c:	e0800017 	ldw	r2,0(fp)
 820c010:	a887883a 	add	r3,r21,r2
 820c014:	e0c00015 	stw	r3,0(fp)
 820c018:	3500e626 	beq	r6,r20,820c3b4 <_malloc_r+0x74c>
 820c01c:	b9000017 	ldw	r4,0(r23)
 820c020:	00bfffc4 	movi	r2,-1
 820c024:	2080ee26 	beq	r4,r2,820c3e0 <_malloc_r+0x778>
 820c028:	a185c83a 	sub	r2,r20,r6
 820c02c:	10c5883a 	add	r2,r2,r3
 820c030:	e0800015 	stw	r2,0(fp)
 820c034:	a0c001cc 	andi	r3,r20,7
 820c038:	1800bc26 	beq	r3,zero,820c32c <_malloc_r+0x6c4>
 820c03c:	a0e9c83a 	sub	r20,r20,r3
 820c040:	00840204 	movi	r2,4104
 820c044:	a5000204 	addi	r20,r20,8
 820c048:	10c7c83a 	sub	r3,r2,r3
 820c04c:	a545883a 	add	r2,r20,r21
 820c050:	1083ffcc 	andi	r2,r2,4095
 820c054:	18abc83a 	sub	r21,r3,r2
 820c058:	a80b883a 	mov	r5,r21
 820c05c:	9009883a 	mov	r4,r18
 820c060:	820dd980 	call	820dd98 <_sbrk_r>
 820c064:	00ffffc4 	movi	r3,-1
 820c068:	10c0e126 	beq	r2,r3,820c3f0 <_malloc_r+0x788>
 820c06c:	1505c83a 	sub	r2,r2,r20
 820c070:	1545883a 	add	r2,r2,r21
 820c074:	10800054 	ori	r2,r2,1
 820c078:	e0c00017 	ldw	r3,0(fp)
 820c07c:	9d000215 	stw	r20,8(r19)
 820c080:	a0800115 	stw	r2,4(r20)
 820c084:	a8c7883a 	add	r3,r21,r3
 820c088:	e0c00015 	stw	r3,0(fp)
 820c08c:	84c00e26 	beq	r16,r19,820c0c8 <_malloc_r+0x460>
 820c090:	018003c4 	movi	r6,15
 820c094:	3580a72e 	bgeu	r6,r22,820c334 <_malloc_r+0x6cc>
 820c098:	81400117 	ldw	r5,4(r16)
 820c09c:	013ffe04 	movi	r4,-8
 820c0a0:	b0bffd04 	addi	r2,r22,-12
 820c0a4:	1104703a 	and	r2,r2,r4
 820c0a8:	2900004c 	andi	r4,r5,1
 820c0ac:	2088b03a 	or	r4,r4,r2
 820c0b0:	81000115 	stw	r4,4(r16)
 820c0b4:	01400144 	movi	r5,5
 820c0b8:	8089883a 	add	r4,r16,r2
 820c0bc:	21400115 	stw	r5,4(r4)
 820c0c0:	21400215 	stw	r5,8(r4)
 820c0c4:	3080cd36 	bltu	r6,r2,820c3fc <_malloc_r+0x794>
 820c0c8:	00820974 	movhi	r2,2085
 820c0cc:	10900104 	addi	r2,r2,16388
 820c0d0:	11000017 	ldw	r4,0(r2)
 820c0d4:	20c0012e 	bgeu	r4,r3,820c0dc <_malloc_r+0x474>
 820c0d8:	10c00015 	stw	r3,0(r2)
 820c0dc:	00820974 	movhi	r2,2085
 820c0e0:	10900004 	addi	r2,r2,16384
 820c0e4:	11000017 	ldw	r4,0(r2)
 820c0e8:	9c000217 	ldw	r16,8(r19)
 820c0ec:	20c0012e 	bgeu	r4,r3,820c0f4 <_malloc_r+0x48c>
 820c0f0:	10c00015 	stw	r3,0(r2)
 820c0f4:	80c00117 	ldw	r3,4(r16)
 820c0f8:	00bfff04 	movi	r2,-4
 820c0fc:	1886703a 	and	r3,r3,r2
 820c100:	1c45c83a 	sub	r2,r3,r17
 820c104:	1c400236 	bltu	r3,r17,820c110 <_malloc_r+0x4a8>
 820c108:	00c003c4 	movi	r3,15
 820c10c:	18800416 	blt	r3,r2,820c120 <_malloc_r+0x4b8>
 820c110:	9009883a 	mov	r4,r18
 820c114:	8214a940 	call	8214a94 <__malloc_unlock>
 820c118:	0005883a 	mov	r2,zero
 820c11c:	003f7b06 	br	820bf0c <_malloc_r+0x2a4>
 820c120:	88c00054 	ori	r3,r17,1
 820c124:	80c00115 	stw	r3,4(r16)
 820c128:	8463883a 	add	r17,r16,r17
 820c12c:	10800054 	ori	r2,r2,1
 820c130:	9c400215 	stw	r17,8(r19)
 820c134:	88800115 	stw	r2,4(r17)
 820c138:	9009883a 	mov	r4,r18
 820c13c:	8214a940 	call	8214a94 <__malloc_unlock>
 820c140:	80800204 	addi	r2,r16,8
 820c144:	003f7106 	br	820bf0c <_malloc_r+0x2a4>
 820c148:	00c00504 	movi	r3,20
 820c14c:	18804a2e 	bgeu	r3,r2,820c278 <_malloc_r+0x610>
 820c150:	00c01504 	movi	r3,84
 820c154:	18806e36 	bltu	r3,r2,820c310 <_malloc_r+0x6a8>
 820c158:	8804d33a 	srli	r2,r17,12
 820c15c:	12001bc4 	addi	r8,r2,111
 820c160:	11c01b84 	addi	r7,r2,110
 820c164:	4209883a 	add	r4,r8,r8
 820c168:	003edd06 	br	820bce0 <_malloc_r+0x78>
 820c16c:	3804d27a 	srli	r2,r7,9
 820c170:	00c00104 	movi	r3,4
 820c174:	1880442e 	bgeu	r3,r2,820c288 <_malloc_r+0x620>
 820c178:	00c00504 	movi	r3,20
 820c17c:	18808136 	bltu	r3,r2,820c384 <_malloc_r+0x71c>
 820c180:	11401704 	addi	r5,r2,92
 820c184:	10c016c4 	addi	r3,r2,91
 820c188:	294b883a 	add	r5,r5,r5
 820c18c:	294b883a 	add	r5,r5,r5
 820c190:	294b883a 	add	r5,r5,r5
 820c194:	994b883a 	add	r5,r19,r5
 820c198:	28800017 	ldw	r2,0(r5)
 820c19c:	01820974 	movhi	r6,2085
 820c1a0:	297ffe04 	addi	r5,r5,-8
 820c1a4:	31893004 	addi	r6,r6,9408
 820c1a8:	28806526 	beq	r5,r2,820c340 <_malloc_r+0x6d8>
 820c1ac:	01bfff04 	movi	r6,-4
 820c1b0:	10c00117 	ldw	r3,4(r2)
 820c1b4:	1986703a 	and	r3,r3,r6
 820c1b8:	38c0022e 	bgeu	r7,r3,820c1c4 <_malloc_r+0x55c>
 820c1bc:	10800217 	ldw	r2,8(r2)
 820c1c0:	28bffb1e 	bne	r5,r2,820c1b0 <_malloc_r+0x548>
 820c1c4:	11400317 	ldw	r5,12(r2)
 820c1c8:	98c00117 	ldw	r3,4(r19)
 820c1cc:	81400315 	stw	r5,12(r16)
 820c1d0:	80800215 	stw	r2,8(r16)
 820c1d4:	2c000215 	stw	r16,8(r5)
 820c1d8:	14000315 	stw	r16,12(r2)
 820c1dc:	003ef806 	br	820bdc0 <_malloc_r+0x158>
 820c1e0:	88c00054 	ori	r3,r17,1
 820c1e4:	80c00115 	stw	r3,4(r16)
 820c1e8:	8463883a 	add	r17,r16,r17
 820c1ec:	34400515 	stw	r17,20(r6)
 820c1f0:	34400415 	stw	r17,16(r6)
 820c1f4:	10c00054 	ori	r3,r2,1
 820c1f8:	8a000315 	stw	r8,12(r17)
 820c1fc:	8a000215 	stw	r8,8(r17)
 820c200:	88c00115 	stw	r3,4(r17)
 820c204:	88a3883a 	add	r17,r17,r2
 820c208:	88800015 	stw	r2,0(r17)
 820c20c:	9009883a 	mov	r4,r18
 820c210:	8214a940 	call	8214a94 <__malloc_unlock>
 820c214:	80800204 	addi	r2,r16,8
 820c218:	003f3c06 	br	820bf0c <_malloc_r+0x2a4>
 820c21c:	30c00117 	ldw	r3,4(r6)
 820c220:	003ee706 	br	820bdc0 <_malloc_r+0x158>
 820c224:	5ac00044 	addi	r11,r11,1
 820c228:	588000cc 	andi	r2,r11,3
 820c22c:	31800204 	addi	r6,r6,8
 820c230:	103efd1e 	bne	r2,zero,820be28 <_malloc_r+0x1c0>
 820c234:	00002406 	br	820c2c8 <_malloc_r+0x660>
 820c238:	14000317 	ldw	r16,12(r2)
 820c23c:	143f251e 	bne	r2,r16,820bed4 <_malloc_r+0x26c>
 820c240:	21000084 	addi	r4,r4,2
 820c244:	003ebc06 	br	820bd38 <_malloc_r+0xd0>
 820c248:	8085883a 	add	r2,r16,r2
 820c24c:	10c00117 	ldw	r3,4(r2)
 820c250:	81000317 	ldw	r4,12(r16)
 820c254:	81400217 	ldw	r5,8(r16)
 820c258:	18c00054 	ori	r3,r3,1
 820c25c:	10c00115 	stw	r3,4(r2)
 820c260:	29000315 	stw	r4,12(r5)
 820c264:	21400215 	stw	r5,8(r4)
 820c268:	9009883a 	mov	r4,r18
 820c26c:	8214a940 	call	8214a94 <__malloc_unlock>
 820c270:	80800204 	addi	r2,r16,8
 820c274:	003f2506 	br	820bf0c <_malloc_r+0x2a4>
 820c278:	12001704 	addi	r8,r2,92
 820c27c:	11c016c4 	addi	r7,r2,91
 820c280:	4209883a 	add	r4,r8,r8
 820c284:	003e9606 	br	820bce0 <_malloc_r+0x78>
 820c288:	3804d1ba 	srli	r2,r7,6
 820c28c:	11400e44 	addi	r5,r2,57
 820c290:	10c00e04 	addi	r3,r2,56
 820c294:	294b883a 	add	r5,r5,r5
 820c298:	003fbc06 	br	820c18c <_malloc_r+0x524>
 820c29c:	84ff5926 	beq	r16,r19,820c004 <_malloc_r+0x39c>
 820c2a0:	00820974 	movhi	r2,2085
 820c2a4:	10893004 	addi	r2,r2,9408
 820c2a8:	14000217 	ldw	r16,8(r2)
 820c2ac:	00bfff04 	movi	r2,-4
 820c2b0:	80c00117 	ldw	r3,4(r16)
 820c2b4:	1886703a 	and	r3,r3,r2
 820c2b8:	003f9106 	br	820c100 <_malloc_r+0x498>
 820c2bc:	60800217 	ldw	r2,8(r12)
 820c2c0:	213fffc4 	addi	r4,r4,-1
 820c2c4:	1300651e 	bne	r2,r12,820c45c <_malloc_r+0x7f4>
 820c2c8:	208000cc 	andi	r2,r4,3
 820c2cc:	633ffe04 	addi	r12,r12,-8
 820c2d0:	103ffa1e 	bne	r2,zero,820c2bc <_malloc_r+0x654>
 820c2d4:	98800117 	ldw	r2,4(r19)
 820c2d8:	0146303a 	nor	r3,zero,r5
 820c2dc:	1884703a 	and	r2,r3,r2
 820c2e0:	98800115 	stw	r2,4(r19)
 820c2e4:	294b883a 	add	r5,r5,r5
 820c2e8:	117f2836 	bltu	r2,r5,820bf8c <_malloc_r+0x324>
 820c2ec:	283f2726 	beq	r5,zero,820bf8c <_malloc_r+0x324>
 820c2f0:	2886703a 	and	r3,r5,r2
 820c2f4:	5809883a 	mov	r4,r11
 820c2f8:	183ec31e 	bne	r3,zero,820be08 <_malloc_r+0x1a0>
 820c2fc:	294b883a 	add	r5,r5,r5
 820c300:	2886703a 	and	r3,r5,r2
 820c304:	21000104 	addi	r4,r4,4
 820c308:	183ffc26 	beq	r3,zero,820c2fc <_malloc_r+0x694>
 820c30c:	003ebe06 	br	820be08 <_malloc_r+0x1a0>
 820c310:	00c05504 	movi	r3,340
 820c314:	18801236 	bltu	r3,r2,820c360 <_malloc_r+0x6f8>
 820c318:	8804d3fa 	srli	r2,r17,15
 820c31c:	12001e04 	addi	r8,r2,120
 820c320:	11c01dc4 	addi	r7,r2,119
 820c324:	4209883a 	add	r4,r8,r8
 820c328:	003e6d06 	br	820bce0 <_malloc_r+0x78>
 820c32c:	00c40004 	movi	r3,4096
 820c330:	003f4606 	br	820c04c <_malloc_r+0x3e4>
 820c334:	00800044 	movi	r2,1
 820c338:	a0800115 	stw	r2,4(r20)
 820c33c:	003f7406 	br	820c110 <_malloc_r+0x4a8>
 820c340:	1805d0ba 	srai	r2,r3,2
 820c344:	01c00044 	movi	r7,1
 820c348:	30c00117 	ldw	r3,4(r6)
 820c34c:	388e983a 	sll	r7,r7,r2
 820c350:	2805883a 	mov	r2,r5
 820c354:	38c6b03a 	or	r3,r7,r3
 820c358:	30c00115 	stw	r3,4(r6)
 820c35c:	003f9b06 	br	820c1cc <_malloc_r+0x564>
 820c360:	00c15504 	movi	r3,1364
 820c364:	18801a36 	bltu	r3,r2,820c3d0 <_malloc_r+0x768>
 820c368:	8804d4ba 	srli	r2,r17,18
 820c36c:	12001f44 	addi	r8,r2,125
 820c370:	11c01f04 	addi	r7,r2,124
 820c374:	4209883a 	add	r4,r8,r8
 820c378:	003e5906 	br	820bce0 <_malloc_r+0x78>
 820c37c:	ad400404 	addi	r21,r21,16
 820c380:	003f1706 	br	820bfe0 <_malloc_r+0x378>
 820c384:	00c01504 	movi	r3,84
 820c388:	18802336 	bltu	r3,r2,820c418 <_malloc_r+0x7b0>
 820c38c:	3804d33a 	srli	r2,r7,12
 820c390:	11401bc4 	addi	r5,r2,111
 820c394:	10c01b84 	addi	r3,r2,110
 820c398:	294b883a 	add	r5,r5,r5
 820c39c:	003f7b06 	br	820c18c <_malloc_r+0x524>
 820c3a0:	9c000217 	ldw	r16,8(r19)
 820c3a4:	00bfff04 	movi	r2,-4
 820c3a8:	80c00117 	ldw	r3,4(r16)
 820c3ac:	1886703a 	and	r3,r3,r2
 820c3b0:	003f5306 	br	820c100 <_malloc_r+0x498>
 820c3b4:	3083ffcc 	andi	r2,r6,4095
 820c3b8:	103f181e 	bne	r2,zero,820c01c <_malloc_r+0x3b4>
 820c3bc:	99000217 	ldw	r4,8(r19)
 820c3c0:	b545883a 	add	r2,r22,r21
 820c3c4:	10800054 	ori	r2,r2,1
 820c3c8:	20800115 	stw	r2,4(r4)
 820c3cc:	003f3e06 	br	820c0c8 <_malloc_r+0x460>
 820c3d0:	01003f84 	movi	r4,254
 820c3d4:	02001fc4 	movi	r8,127
 820c3d8:	01c01f84 	movi	r7,126
 820c3dc:	003e4006 	br	820bce0 <_malloc_r+0x78>
 820c3e0:	00820974 	movhi	r2,2085
 820c3e4:	108fa404 	addi	r2,r2,16016
 820c3e8:	15000015 	stw	r20,0(r2)
 820c3ec:	003f1106 	br	820c034 <_malloc_r+0x3cc>
 820c3f0:	00800044 	movi	r2,1
 820c3f4:	002b883a 	mov	r21,zero
 820c3f8:	003f1f06 	br	820c078 <_malloc_r+0x410>
 820c3fc:	81400204 	addi	r5,r16,8
 820c400:	9009883a 	mov	r4,r18
 820c404:	820b07c0 	call	820b07c <_free_r>
 820c408:	00820974 	movhi	r2,2085
 820c40c:	1091f904 	addi	r2,r2,18404
 820c410:	10c00017 	ldw	r3,0(r2)
 820c414:	003f2c06 	br	820c0c8 <_malloc_r+0x460>
 820c418:	00c05504 	movi	r3,340
 820c41c:	18800536 	bltu	r3,r2,820c434 <_malloc_r+0x7cc>
 820c420:	3804d3fa 	srli	r2,r7,15
 820c424:	11401e04 	addi	r5,r2,120
 820c428:	10c01dc4 	addi	r3,r2,119
 820c42c:	294b883a 	add	r5,r5,r5
 820c430:	003f5606 	br	820c18c <_malloc_r+0x524>
 820c434:	00c15504 	movi	r3,1364
 820c438:	18800536 	bltu	r3,r2,820c450 <_malloc_r+0x7e8>
 820c43c:	3804d4ba 	srli	r2,r7,18
 820c440:	11401f44 	addi	r5,r2,125
 820c444:	10c01f04 	addi	r3,r2,124
 820c448:	294b883a 	add	r5,r5,r5
 820c44c:	003f4f06 	br	820c18c <_malloc_r+0x524>
 820c450:	01403f84 	movi	r5,254
 820c454:	00c01f84 	movi	r3,126
 820c458:	003f4c06 	br	820c18c <_malloc_r+0x524>
 820c45c:	98800117 	ldw	r2,4(r19)
 820c460:	003fa006 	br	820c2e4 <_malloc_r+0x67c>
 820c464:	8808d0fa 	srli	r4,r17,3
 820c468:	20800044 	addi	r2,r4,1
 820c46c:	1085883a 	add	r2,r2,r2
 820c470:	003e9006 	br	820beb4 <_malloc_r+0x24c>

0820c474 <memchr>:
 820c474:	208000cc 	andi	r2,r4,3
 820c478:	280f883a 	mov	r7,r5
 820c47c:	10003426 	beq	r2,zero,820c550 <memchr+0xdc>
 820c480:	30bfffc4 	addi	r2,r6,-1
 820c484:	30001a26 	beq	r6,zero,820c4f0 <memchr+0x7c>
 820c488:	20c00003 	ldbu	r3,0(r4)
 820c48c:	29803fcc 	andi	r6,r5,255
 820c490:	30c0051e 	bne	r6,r3,820c4a8 <memchr+0x34>
 820c494:	00001806 	br	820c4f8 <memchr+0x84>
 820c498:	10001526 	beq	r2,zero,820c4f0 <memchr+0x7c>
 820c49c:	20c00003 	ldbu	r3,0(r4)
 820c4a0:	10bfffc4 	addi	r2,r2,-1
 820c4a4:	30c01426 	beq	r6,r3,820c4f8 <memchr+0x84>
 820c4a8:	21000044 	addi	r4,r4,1
 820c4ac:	20c000cc 	andi	r3,r4,3
 820c4b0:	183ff91e 	bne	r3,zero,820c498 <memchr+0x24>
 820c4b4:	020000c4 	movi	r8,3
 820c4b8:	40801136 	bltu	r8,r2,820c500 <memchr+0x8c>
 820c4bc:	10000c26 	beq	r2,zero,820c4f0 <memchr+0x7c>
 820c4c0:	20c00003 	ldbu	r3,0(r4)
 820c4c4:	29403fcc 	andi	r5,r5,255
 820c4c8:	28c00b26 	beq	r5,r3,820c4f8 <memchr+0x84>
 820c4cc:	20c00044 	addi	r3,r4,1
 820c4d0:	39803fcc 	andi	r6,r7,255
 820c4d4:	2089883a 	add	r4,r4,r2
 820c4d8:	00000306 	br	820c4e8 <memchr+0x74>
 820c4dc:	18c00044 	addi	r3,r3,1
 820c4e0:	197fffc3 	ldbu	r5,-1(r3)
 820c4e4:	31400526 	beq	r6,r5,820c4fc <memchr+0x88>
 820c4e8:	1805883a 	mov	r2,r3
 820c4ec:	20fffb1e 	bne	r4,r3,820c4dc <memchr+0x68>
 820c4f0:	0005883a 	mov	r2,zero
 820c4f4:	f800283a 	ret
 820c4f8:	2005883a 	mov	r2,r4
 820c4fc:	f800283a 	ret
 820c500:	28c03fcc 	andi	r3,r5,255
 820c504:	1812923a 	slli	r9,r3,8
 820c508:	02ffbff4 	movhi	r11,65279
 820c50c:	02a02074 	movhi	r10,32897
 820c510:	48d2b03a 	or	r9,r9,r3
 820c514:	4806943a 	slli	r3,r9,16
 820c518:	5affbfc4 	addi	r11,r11,-257
 820c51c:	52a02004 	addi	r10,r10,-32640
 820c520:	48d2b03a 	or	r9,r9,r3
 820c524:	20c00017 	ldw	r3,0(r4)
 820c528:	48c6f03a 	xor	r3,r9,r3
 820c52c:	1acd883a 	add	r6,r3,r11
 820c530:	00c6303a 	nor	r3,zero,r3
 820c534:	30c6703a 	and	r3,r6,r3
 820c538:	1a86703a 	and	r3,r3,r10
 820c53c:	183fe01e 	bne	r3,zero,820c4c0 <memchr+0x4c>
 820c540:	10bfff04 	addi	r2,r2,-4
 820c544:	21000104 	addi	r4,r4,4
 820c548:	40bff636 	bltu	r8,r2,820c524 <memchr+0xb0>
 820c54c:	003fdb06 	br	820c4bc <memchr+0x48>
 820c550:	3005883a 	mov	r2,r6
 820c554:	003fd706 	br	820c4b4 <memchr+0x40>

0820c558 <memcmp>:
 820c558:	01c000c4 	movi	r7,3
 820c55c:	3980192e 	bgeu	r7,r6,820c5c4 <memcmp+0x6c>
 820c560:	2144b03a 	or	r2,r4,r5
 820c564:	11c4703a 	and	r2,r2,r7
 820c568:	10000f26 	beq	r2,zero,820c5a8 <memcmp+0x50>
 820c56c:	20800003 	ldbu	r2,0(r4)
 820c570:	28c00003 	ldbu	r3,0(r5)
 820c574:	10c0151e 	bne	r2,r3,820c5cc <memcmp+0x74>
 820c578:	31bfff84 	addi	r6,r6,-2
 820c57c:	01ffffc4 	movi	r7,-1
 820c580:	00000406 	br	820c594 <memcmp+0x3c>
 820c584:	20800003 	ldbu	r2,0(r4)
 820c588:	28c00003 	ldbu	r3,0(r5)
 820c58c:	31bfffc4 	addi	r6,r6,-1
 820c590:	10c00e1e 	bne	r2,r3,820c5cc <memcmp+0x74>
 820c594:	21000044 	addi	r4,r4,1
 820c598:	29400044 	addi	r5,r5,1
 820c59c:	31fff91e 	bne	r6,r7,820c584 <memcmp+0x2c>
 820c5a0:	0005883a 	mov	r2,zero
 820c5a4:	f800283a 	ret
 820c5a8:	20c00017 	ldw	r3,0(r4)
 820c5ac:	28800017 	ldw	r2,0(r5)
 820c5b0:	18bfee1e 	bne	r3,r2,820c56c <memcmp+0x14>
 820c5b4:	31bfff04 	addi	r6,r6,-4
 820c5b8:	21000104 	addi	r4,r4,4
 820c5bc:	29400104 	addi	r5,r5,4
 820c5c0:	39bff936 	bltu	r7,r6,820c5a8 <memcmp+0x50>
 820c5c4:	303fe91e 	bne	r6,zero,820c56c <memcmp+0x14>
 820c5c8:	003ff506 	br	820c5a0 <memcmp+0x48>
 820c5cc:	10c5c83a 	sub	r2,r2,r3
 820c5d0:	f800283a 	ret

0820c5d4 <_Balloc>:
 820c5d4:	20801317 	ldw	r2,76(r4)
 820c5d8:	defffc04 	addi	sp,sp,-16
 820c5dc:	dc400115 	stw	r17,4(sp)
 820c5e0:	dc000015 	stw	r16,0(sp)
 820c5e4:	dfc00315 	stw	ra,12(sp)
 820c5e8:	dc800215 	stw	r18,8(sp)
 820c5ec:	2023883a 	mov	r17,r4
 820c5f0:	2821883a 	mov	r16,r5
 820c5f4:	10000f26 	beq	r2,zero,820c634 <_Balloc+0x60>
 820c5f8:	8407883a 	add	r3,r16,r16
 820c5fc:	18c7883a 	add	r3,r3,r3
 820c600:	10c7883a 	add	r3,r2,r3
 820c604:	18800017 	ldw	r2,0(r3)
 820c608:	10001126 	beq	r2,zero,820c650 <_Balloc+0x7c>
 820c60c:	11000017 	ldw	r4,0(r2)
 820c610:	19000015 	stw	r4,0(r3)
 820c614:	10000415 	stw	zero,16(r2)
 820c618:	10000315 	stw	zero,12(r2)
 820c61c:	dfc00317 	ldw	ra,12(sp)
 820c620:	dc800217 	ldw	r18,8(sp)
 820c624:	dc400117 	ldw	r17,4(sp)
 820c628:	dc000017 	ldw	r16,0(sp)
 820c62c:	dec00404 	addi	sp,sp,16
 820c630:	f800283a 	ret
 820c634:	01800844 	movi	r6,33
 820c638:	01400104 	movi	r5,4
 820c63c:	8210b0c0 	call	8210b0c <_calloc_r>
 820c640:	88801315 	stw	r2,76(r17)
 820c644:	103fec1e 	bne	r2,zero,820c5f8 <_Balloc+0x24>
 820c648:	0005883a 	mov	r2,zero
 820c64c:	003ff306 	br	820c61c <_Balloc+0x48>
 820c650:	01400044 	movi	r5,1
 820c654:	2c24983a 	sll	r18,r5,r16
 820c658:	8809883a 	mov	r4,r17
 820c65c:	91800144 	addi	r6,r18,5
 820c660:	318d883a 	add	r6,r6,r6
 820c664:	318d883a 	add	r6,r6,r6
 820c668:	8210b0c0 	call	8210b0c <_calloc_r>
 820c66c:	103ff626 	beq	r2,zero,820c648 <_Balloc+0x74>
 820c670:	14000115 	stw	r16,4(r2)
 820c674:	14800215 	stw	r18,8(r2)
 820c678:	003fe606 	br	820c614 <_Balloc+0x40>

0820c67c <_Bfree>:
 820c67c:	28000826 	beq	r5,zero,820c6a0 <_Bfree+0x24>
 820c680:	28c00117 	ldw	r3,4(r5)
 820c684:	20801317 	ldw	r2,76(r4)
 820c688:	18c7883a 	add	r3,r3,r3
 820c68c:	18c7883a 	add	r3,r3,r3
 820c690:	10c5883a 	add	r2,r2,r3
 820c694:	10c00017 	ldw	r3,0(r2)
 820c698:	28c00015 	stw	r3,0(r5)
 820c69c:	11400015 	stw	r5,0(r2)
 820c6a0:	f800283a 	ret

0820c6a4 <__multadd>:
 820c6a4:	defffa04 	addi	sp,sp,-24
 820c6a8:	dc800315 	stw	r18,12(sp)
 820c6ac:	dc400215 	stw	r17,8(sp)
 820c6b0:	dc000115 	stw	r16,4(sp)
 820c6b4:	2823883a 	mov	r17,r5
 820c6b8:	2c000417 	ldw	r16,16(r5)
 820c6bc:	dfc00515 	stw	ra,20(sp)
 820c6c0:	dcc00415 	stw	r19,16(sp)
 820c6c4:	2025883a 	mov	r18,r4
 820c6c8:	29400504 	addi	r5,r5,20
 820c6cc:	0011883a 	mov	r8,zero
 820c6d0:	28c00017 	ldw	r3,0(r5)
 820c6d4:	29400104 	addi	r5,r5,4
 820c6d8:	42000044 	addi	r8,r8,1
 820c6dc:	18bfffcc 	andi	r2,r3,65535
 820c6e0:	1185383a 	mul	r2,r2,r6
 820c6e4:	1806d43a 	srli	r3,r3,16
 820c6e8:	11cf883a 	add	r7,r2,r7
 820c6ec:	3808d43a 	srli	r4,r7,16
 820c6f0:	1987383a 	mul	r3,r3,r6
 820c6f4:	38bfffcc 	andi	r2,r7,65535
 820c6f8:	1907883a 	add	r3,r3,r4
 820c6fc:	1808943a 	slli	r4,r3,16
 820c700:	180ed43a 	srli	r7,r3,16
 820c704:	2085883a 	add	r2,r4,r2
 820c708:	28bfff15 	stw	r2,-4(r5)
 820c70c:	443ff016 	blt	r8,r16,820c6d0 <__multadd+0x2c>
 820c710:	38000926 	beq	r7,zero,820c738 <__multadd+0x94>
 820c714:	88800217 	ldw	r2,8(r17)
 820c718:	80800f0e 	bge	r16,r2,820c758 <__multadd+0xb4>
 820c71c:	80800144 	addi	r2,r16,5
 820c720:	1085883a 	add	r2,r2,r2
 820c724:	1085883a 	add	r2,r2,r2
 820c728:	8885883a 	add	r2,r17,r2
 820c72c:	11c00015 	stw	r7,0(r2)
 820c730:	84000044 	addi	r16,r16,1
 820c734:	8c000415 	stw	r16,16(r17)
 820c738:	8805883a 	mov	r2,r17
 820c73c:	dfc00517 	ldw	ra,20(sp)
 820c740:	dcc00417 	ldw	r19,16(sp)
 820c744:	dc800317 	ldw	r18,12(sp)
 820c748:	dc400217 	ldw	r17,8(sp)
 820c74c:	dc000117 	ldw	r16,4(sp)
 820c750:	dec00604 	addi	sp,sp,24
 820c754:	f800283a 	ret
 820c758:	89400117 	ldw	r5,4(r17)
 820c75c:	9009883a 	mov	r4,r18
 820c760:	d9c00015 	stw	r7,0(sp)
 820c764:	29400044 	addi	r5,r5,1
 820c768:	820c5d40 	call	820c5d4 <_Balloc>
 820c76c:	89800417 	ldw	r6,16(r17)
 820c770:	89400304 	addi	r5,r17,12
 820c774:	11000304 	addi	r4,r2,12
 820c778:	31800084 	addi	r6,r6,2
 820c77c:	318d883a 	add	r6,r6,r6
 820c780:	318d883a 	add	r6,r6,r6
 820c784:	1027883a 	mov	r19,r2
 820c788:	8202e8c0 	call	8202e8c <memcpy>
 820c78c:	d9c00017 	ldw	r7,0(sp)
 820c790:	88000a26 	beq	r17,zero,820c7bc <__multadd+0x118>
 820c794:	88c00117 	ldw	r3,4(r17)
 820c798:	90801317 	ldw	r2,76(r18)
 820c79c:	18c7883a 	add	r3,r3,r3
 820c7a0:	18c7883a 	add	r3,r3,r3
 820c7a4:	10c5883a 	add	r2,r2,r3
 820c7a8:	10c00017 	ldw	r3,0(r2)
 820c7ac:	88c00015 	stw	r3,0(r17)
 820c7b0:	14400015 	stw	r17,0(r2)
 820c7b4:	9823883a 	mov	r17,r19
 820c7b8:	003fd806 	br	820c71c <__multadd+0x78>
 820c7bc:	9823883a 	mov	r17,r19
 820c7c0:	003fd606 	br	820c71c <__multadd+0x78>

0820c7c4 <__s2b>:
 820c7c4:	defff904 	addi	sp,sp,-28
 820c7c8:	dc400115 	stw	r17,4(sp)
 820c7cc:	dc000015 	stw	r16,0(sp)
 820c7d0:	2023883a 	mov	r17,r4
 820c7d4:	2821883a 	mov	r16,r5
 820c7d8:	39000204 	addi	r4,r7,8
 820c7dc:	01400244 	movi	r5,9
 820c7e0:	dcc00315 	stw	r19,12(sp)
 820c7e4:	dc800215 	stw	r18,8(sp)
 820c7e8:	dfc00615 	stw	ra,24(sp)
 820c7ec:	dd400515 	stw	r21,20(sp)
 820c7f0:	dd000415 	stw	r20,16(sp)
 820c7f4:	3825883a 	mov	r18,r7
 820c7f8:	3027883a 	mov	r19,r6
 820c7fc:	8202a940 	call	8202a94 <__divsi3>
 820c800:	00c00044 	movi	r3,1
 820c804:	000b883a 	mov	r5,zero
 820c808:	1880030e 	bge	r3,r2,820c818 <__s2b+0x54>
 820c80c:	18c7883a 	add	r3,r3,r3
 820c810:	29400044 	addi	r5,r5,1
 820c814:	18bffd16 	blt	r3,r2,820c80c <__s2b+0x48>
 820c818:	8809883a 	mov	r4,r17
 820c81c:	820c5d40 	call	820c5d4 <_Balloc>
 820c820:	d8c00717 	ldw	r3,28(sp)
 820c824:	10c00515 	stw	r3,20(r2)
 820c828:	00c00044 	movi	r3,1
 820c82c:	10c00415 	stw	r3,16(r2)
 820c830:	00c00244 	movi	r3,9
 820c834:	1cc0210e 	bge	r3,r19,820c8bc <__s2b+0xf8>
 820c838:	80eb883a 	add	r21,r16,r3
 820c83c:	a829883a 	mov	r20,r21
 820c840:	84e1883a 	add	r16,r16,r19
 820c844:	a1c00007 	ldb	r7,0(r20)
 820c848:	01800284 	movi	r6,10
 820c84c:	a5000044 	addi	r20,r20,1
 820c850:	100b883a 	mov	r5,r2
 820c854:	39fff404 	addi	r7,r7,-48
 820c858:	8809883a 	mov	r4,r17
 820c85c:	820c6a40 	call	820c6a4 <__multadd>
 820c860:	a43ff81e 	bne	r20,r16,820c844 <__s2b+0x80>
 820c864:	ace1883a 	add	r16,r21,r19
 820c868:	843ffe04 	addi	r16,r16,-8
 820c86c:	9c800a0e 	bge	r19,r18,820c898 <__s2b+0xd4>
 820c870:	94e5c83a 	sub	r18,r18,r19
 820c874:	84a5883a 	add	r18,r16,r18
 820c878:	81c00007 	ldb	r7,0(r16)
 820c87c:	01800284 	movi	r6,10
 820c880:	84000044 	addi	r16,r16,1
 820c884:	100b883a 	mov	r5,r2
 820c888:	39fff404 	addi	r7,r7,-48
 820c88c:	8809883a 	mov	r4,r17
 820c890:	820c6a40 	call	820c6a4 <__multadd>
 820c894:	84bff81e 	bne	r16,r18,820c878 <__s2b+0xb4>
 820c898:	dfc00617 	ldw	ra,24(sp)
 820c89c:	dd400517 	ldw	r21,20(sp)
 820c8a0:	dd000417 	ldw	r20,16(sp)
 820c8a4:	dcc00317 	ldw	r19,12(sp)
 820c8a8:	dc800217 	ldw	r18,8(sp)
 820c8ac:	dc400117 	ldw	r17,4(sp)
 820c8b0:	dc000017 	ldw	r16,0(sp)
 820c8b4:	dec00704 	addi	sp,sp,28
 820c8b8:	f800283a 	ret
 820c8bc:	84000284 	addi	r16,r16,10
 820c8c0:	1827883a 	mov	r19,r3
 820c8c4:	003fe906 	br	820c86c <__s2b+0xa8>

0820c8c8 <__hi0bits>:
 820c8c8:	20bfffec 	andhi	r2,r4,65535
 820c8cc:	1000141e 	bne	r2,zero,820c920 <__hi0bits+0x58>
 820c8d0:	2008943a 	slli	r4,r4,16
 820c8d4:	00800404 	movi	r2,16
 820c8d8:	20ffc02c 	andhi	r3,r4,65280
 820c8dc:	1800021e 	bne	r3,zero,820c8e8 <__hi0bits+0x20>
 820c8e0:	2008923a 	slli	r4,r4,8
 820c8e4:	10800204 	addi	r2,r2,8
 820c8e8:	20fc002c 	andhi	r3,r4,61440
 820c8ec:	1800021e 	bne	r3,zero,820c8f8 <__hi0bits+0x30>
 820c8f0:	2008913a 	slli	r4,r4,4
 820c8f4:	10800104 	addi	r2,r2,4
 820c8f8:	20f0002c 	andhi	r3,r4,49152
 820c8fc:	1800031e 	bne	r3,zero,820c90c <__hi0bits+0x44>
 820c900:	2109883a 	add	r4,r4,r4
 820c904:	10800084 	addi	r2,r2,2
 820c908:	2109883a 	add	r4,r4,r4
 820c90c:	20000316 	blt	r4,zero,820c91c <__hi0bits+0x54>
 820c910:	2110002c 	andhi	r4,r4,16384
 820c914:	2000041e 	bne	r4,zero,820c928 <__hi0bits+0x60>
 820c918:	00800804 	movi	r2,32
 820c91c:	f800283a 	ret
 820c920:	0005883a 	mov	r2,zero
 820c924:	003fec06 	br	820c8d8 <__hi0bits+0x10>
 820c928:	10800044 	addi	r2,r2,1
 820c92c:	f800283a 	ret

0820c930 <__lo0bits>:
 820c930:	20c00017 	ldw	r3,0(r4)
 820c934:	188001cc 	andi	r2,r3,7
 820c938:	10000826 	beq	r2,zero,820c95c <__lo0bits+0x2c>
 820c93c:	1880004c 	andi	r2,r3,1
 820c940:	1000211e 	bne	r2,zero,820c9c8 <__lo0bits+0x98>
 820c944:	1880008c 	andi	r2,r3,2
 820c948:	1000211e 	bne	r2,zero,820c9d0 <__lo0bits+0xa0>
 820c94c:	1806d0ba 	srli	r3,r3,2
 820c950:	00800084 	movi	r2,2
 820c954:	20c00015 	stw	r3,0(r4)
 820c958:	f800283a 	ret
 820c95c:	18bfffcc 	andi	r2,r3,65535
 820c960:	10001326 	beq	r2,zero,820c9b0 <__lo0bits+0x80>
 820c964:	0005883a 	mov	r2,zero
 820c968:	19403fcc 	andi	r5,r3,255
 820c96c:	2800021e 	bne	r5,zero,820c978 <__lo0bits+0x48>
 820c970:	1806d23a 	srli	r3,r3,8
 820c974:	10800204 	addi	r2,r2,8
 820c978:	194003cc 	andi	r5,r3,15
 820c97c:	2800021e 	bne	r5,zero,820c988 <__lo0bits+0x58>
 820c980:	1806d13a 	srli	r3,r3,4
 820c984:	10800104 	addi	r2,r2,4
 820c988:	194000cc 	andi	r5,r3,3
 820c98c:	2800021e 	bne	r5,zero,820c998 <__lo0bits+0x68>
 820c990:	1806d0ba 	srli	r3,r3,2
 820c994:	10800084 	addi	r2,r2,2
 820c998:	1940004c 	andi	r5,r3,1
 820c99c:	2800081e 	bne	r5,zero,820c9c0 <__lo0bits+0x90>
 820c9a0:	1806d07a 	srli	r3,r3,1
 820c9a4:	1800051e 	bne	r3,zero,820c9bc <__lo0bits+0x8c>
 820c9a8:	00800804 	movi	r2,32
 820c9ac:	f800283a 	ret
 820c9b0:	1806d43a 	srli	r3,r3,16
 820c9b4:	00800404 	movi	r2,16
 820c9b8:	003feb06 	br	820c968 <__lo0bits+0x38>
 820c9bc:	10800044 	addi	r2,r2,1
 820c9c0:	20c00015 	stw	r3,0(r4)
 820c9c4:	f800283a 	ret
 820c9c8:	0005883a 	mov	r2,zero
 820c9cc:	f800283a 	ret
 820c9d0:	1806d07a 	srli	r3,r3,1
 820c9d4:	00800044 	movi	r2,1
 820c9d8:	20c00015 	stw	r3,0(r4)
 820c9dc:	f800283a 	ret

0820c9e0 <__i2b>:
 820c9e0:	defffd04 	addi	sp,sp,-12
 820c9e4:	dc000015 	stw	r16,0(sp)
 820c9e8:	04000044 	movi	r16,1
 820c9ec:	dc400115 	stw	r17,4(sp)
 820c9f0:	2823883a 	mov	r17,r5
 820c9f4:	800b883a 	mov	r5,r16
 820c9f8:	dfc00215 	stw	ra,8(sp)
 820c9fc:	820c5d40 	call	820c5d4 <_Balloc>
 820ca00:	14400515 	stw	r17,20(r2)
 820ca04:	14000415 	stw	r16,16(r2)
 820ca08:	dfc00217 	ldw	ra,8(sp)
 820ca0c:	dc400117 	ldw	r17,4(sp)
 820ca10:	dc000017 	ldw	r16,0(sp)
 820ca14:	dec00304 	addi	sp,sp,12
 820ca18:	f800283a 	ret

0820ca1c <__multiply>:
 820ca1c:	defffa04 	addi	sp,sp,-24
 820ca20:	dcc00315 	stw	r19,12(sp)
 820ca24:	dc800215 	stw	r18,8(sp)
 820ca28:	34c00417 	ldw	r19,16(r6)
 820ca2c:	2c800417 	ldw	r18,16(r5)
 820ca30:	dd000415 	stw	r20,16(sp)
 820ca34:	dc400115 	stw	r17,4(sp)
 820ca38:	dfc00515 	stw	ra,20(sp)
 820ca3c:	dc000015 	stw	r16,0(sp)
 820ca40:	2829883a 	mov	r20,r5
 820ca44:	3023883a 	mov	r17,r6
 820ca48:	94c0050e 	bge	r18,r19,820ca60 <__multiply+0x44>
 820ca4c:	9007883a 	mov	r3,r18
 820ca50:	3029883a 	mov	r20,r6
 820ca54:	9825883a 	mov	r18,r19
 820ca58:	2823883a 	mov	r17,r5
 820ca5c:	1827883a 	mov	r19,r3
 820ca60:	a0800217 	ldw	r2,8(r20)
 820ca64:	94e1883a 	add	r16,r18,r19
 820ca68:	a1400117 	ldw	r5,4(r20)
 820ca6c:	1400010e 	bge	r2,r16,820ca74 <__multiply+0x58>
 820ca70:	29400044 	addi	r5,r5,1
 820ca74:	820c5d40 	call	820c5d4 <_Balloc>
 820ca78:	8415883a 	add	r10,r16,r16
 820ca7c:	12c00504 	addi	r11,r2,20
 820ca80:	5295883a 	add	r10,r10,r10
 820ca84:	5a95883a 	add	r10,r11,r10
 820ca88:	5807883a 	mov	r3,r11
 820ca8c:	5a80032e 	bgeu	r11,r10,820ca9c <__multiply+0x80>
 820ca90:	18000015 	stw	zero,0(r3)
 820ca94:	18c00104 	addi	r3,r3,4
 820ca98:	1abffd36 	bltu	r3,r10,820ca90 <__multiply+0x74>
 820ca9c:	9ce7883a 	add	r19,r19,r19
 820caa0:	94a5883a 	add	r18,r18,r18
 820caa4:	89800504 	addi	r6,r17,20
 820caa8:	9ce7883a 	add	r19,r19,r19
 820caac:	a3400504 	addi	r13,r20,20
 820cab0:	94a5883a 	add	r18,r18,r18
 820cab4:	34d9883a 	add	r12,r6,r19
 820cab8:	6c93883a 	add	r9,r13,r18
 820cabc:	3300422e 	bgeu	r6,r12,820cbc8 <__multiply+0x1ac>
 820cac0:	37c00017 	ldw	ra,0(r6)
 820cac4:	fbffffcc 	andi	r15,ra,65535
 820cac8:	78001b26 	beq	r15,zero,820cb38 <__multiply+0x11c>
 820cacc:	5811883a 	mov	r8,r11
 820cad0:	681d883a 	mov	r14,r13
 820cad4:	000f883a 	mov	r7,zero
 820cad8:	71000017 	ldw	r4,0(r14)
 820cadc:	40c00017 	ldw	r3,0(r8)
 820cae0:	73800104 	addi	r14,r14,4
 820cae4:	217fffcc 	andi	r5,r4,65535
 820cae8:	2bcb383a 	mul	r5,r5,r15
 820caec:	2008d43a 	srli	r4,r4,16
 820caf0:	1c7fffcc 	andi	r17,r3,65535
 820caf4:	2c4b883a 	add	r5,r5,r17
 820caf8:	29cb883a 	add	r5,r5,r7
 820cafc:	23c9383a 	mul	r4,r4,r15
 820cb00:	1806d43a 	srli	r3,r3,16
 820cb04:	280ed43a 	srli	r7,r5,16
 820cb08:	297fffcc 	andi	r5,r5,65535
 820cb0c:	20c7883a 	add	r3,r4,r3
 820cb10:	19c7883a 	add	r3,r3,r7
 820cb14:	1808943a 	slli	r4,r3,16
 820cb18:	4023883a 	mov	r17,r8
 820cb1c:	180ed43a 	srli	r7,r3,16
 820cb20:	214ab03a 	or	r5,r4,r5
 820cb24:	41400015 	stw	r5,0(r8)
 820cb28:	42000104 	addi	r8,r8,4
 820cb2c:	727fea36 	bltu	r14,r9,820cad8 <__multiply+0xbc>
 820cb30:	89c00115 	stw	r7,4(r17)
 820cb34:	37c00017 	ldw	ra,0(r6)
 820cb38:	f83ed43a 	srli	ra,ra,16
 820cb3c:	f8001f26 	beq	ra,zero,820cbbc <__multiply+0x1a0>
 820cb40:	58c00017 	ldw	r3,0(r11)
 820cb44:	681d883a 	mov	r14,r13
 820cb48:	581f883a 	mov	r15,r11
 820cb4c:	1811883a 	mov	r8,r3
 820cb50:	5825883a 	mov	r18,r11
 820cb54:	000f883a 	mov	r7,zero
 820cb58:	00000106 	br	820cb60 <__multiply+0x144>
 820cb5c:	8825883a 	mov	r18,r17
 820cb60:	7140000b 	ldhu	r5,0(r14)
 820cb64:	4010d43a 	srli	r8,r8,16
 820cb68:	193fffcc 	andi	r4,r3,65535
 820cb6c:	2fcb383a 	mul	r5,r5,ra
 820cb70:	7bc00104 	addi	r15,r15,4
 820cb74:	73800104 	addi	r14,r14,4
 820cb78:	2a0b883a 	add	r5,r5,r8
 820cb7c:	29cb883a 	add	r5,r5,r7
 820cb80:	2806943a 	slli	r3,r5,16
 820cb84:	94400104 	addi	r17,r18,4
 820cb88:	280ad43a 	srli	r5,r5,16
 820cb8c:	1908b03a 	or	r4,r3,r4
 820cb90:	793fff15 	stw	r4,-4(r15)
 820cb94:	70ffff17 	ldw	r3,-4(r14)
 820cb98:	8a000017 	ldw	r8,0(r17)
 820cb9c:	1806d43a 	srli	r3,r3,16
 820cba0:	413fffcc 	andi	r4,r8,65535
 820cba4:	1fc7383a 	mul	r3,r3,ra
 820cba8:	1907883a 	add	r3,r3,r4
 820cbac:	1947883a 	add	r3,r3,r5
 820cbb0:	180ed43a 	srli	r7,r3,16
 820cbb4:	727fe936 	bltu	r14,r9,820cb5c <__multiply+0x140>
 820cbb8:	90c00115 	stw	r3,4(r18)
 820cbbc:	31800104 	addi	r6,r6,4
 820cbc0:	5ac00104 	addi	r11,r11,4
 820cbc4:	333fbe36 	bltu	r6,r12,820cac0 <__multiply+0xa4>
 820cbc8:	0400090e 	bge	zero,r16,820cbf0 <__multiply+0x1d4>
 820cbcc:	50ffff17 	ldw	r3,-4(r10)
 820cbd0:	52bfff04 	addi	r10,r10,-4
 820cbd4:	18000326 	beq	r3,zero,820cbe4 <__multiply+0x1c8>
 820cbd8:	00000506 	br	820cbf0 <__multiply+0x1d4>
 820cbdc:	50c00017 	ldw	r3,0(r10)
 820cbe0:	1800031e 	bne	r3,zero,820cbf0 <__multiply+0x1d4>
 820cbe4:	843fffc4 	addi	r16,r16,-1
 820cbe8:	52bfff04 	addi	r10,r10,-4
 820cbec:	803ffb1e 	bne	r16,zero,820cbdc <__multiply+0x1c0>
 820cbf0:	14000415 	stw	r16,16(r2)
 820cbf4:	dfc00517 	ldw	ra,20(sp)
 820cbf8:	dd000417 	ldw	r20,16(sp)
 820cbfc:	dcc00317 	ldw	r19,12(sp)
 820cc00:	dc800217 	ldw	r18,8(sp)
 820cc04:	dc400117 	ldw	r17,4(sp)
 820cc08:	dc000017 	ldw	r16,0(sp)
 820cc0c:	dec00604 	addi	sp,sp,24
 820cc10:	f800283a 	ret

0820cc14 <__pow5mult>:
 820cc14:	defffa04 	addi	sp,sp,-24
 820cc18:	dcc00315 	stw	r19,12(sp)
 820cc1c:	dc000015 	stw	r16,0(sp)
 820cc20:	dfc00515 	stw	ra,20(sp)
 820cc24:	dd000415 	stw	r20,16(sp)
 820cc28:	dc800215 	stw	r18,8(sp)
 820cc2c:	dc400115 	stw	r17,4(sp)
 820cc30:	308000cc 	andi	r2,r6,3
 820cc34:	3021883a 	mov	r16,r6
 820cc38:	2027883a 	mov	r19,r4
 820cc3c:	10002f1e 	bne	r2,zero,820ccfc <__pow5mult+0xe8>
 820cc40:	2825883a 	mov	r18,r5
 820cc44:	8021d0ba 	srai	r16,r16,2
 820cc48:	80001a26 	beq	r16,zero,820ccb4 <__pow5mult+0xa0>
 820cc4c:	9c401217 	ldw	r17,72(r19)
 820cc50:	8800061e 	bne	r17,zero,820cc6c <__pow5mult+0x58>
 820cc54:	00003406 	br	820cd28 <__pow5mult+0x114>
 820cc58:	8021d07a 	srai	r16,r16,1
 820cc5c:	80001526 	beq	r16,zero,820ccb4 <__pow5mult+0xa0>
 820cc60:	88800017 	ldw	r2,0(r17)
 820cc64:	10001c26 	beq	r2,zero,820ccd8 <__pow5mult+0xc4>
 820cc68:	1023883a 	mov	r17,r2
 820cc6c:	8080004c 	andi	r2,r16,1
 820cc70:	103ff926 	beq	r2,zero,820cc58 <__pow5mult+0x44>
 820cc74:	880d883a 	mov	r6,r17
 820cc78:	900b883a 	mov	r5,r18
 820cc7c:	9809883a 	mov	r4,r19
 820cc80:	820ca1c0 	call	820ca1c <__multiply>
 820cc84:	90001b26 	beq	r18,zero,820ccf4 <__pow5mult+0xe0>
 820cc88:	91000117 	ldw	r4,4(r18)
 820cc8c:	98c01317 	ldw	r3,76(r19)
 820cc90:	8021d07a 	srai	r16,r16,1
 820cc94:	2109883a 	add	r4,r4,r4
 820cc98:	2109883a 	add	r4,r4,r4
 820cc9c:	1907883a 	add	r3,r3,r4
 820cca0:	19000017 	ldw	r4,0(r3)
 820cca4:	91000015 	stw	r4,0(r18)
 820cca8:	1c800015 	stw	r18,0(r3)
 820ccac:	1025883a 	mov	r18,r2
 820ccb0:	803feb1e 	bne	r16,zero,820cc60 <__pow5mult+0x4c>
 820ccb4:	9005883a 	mov	r2,r18
 820ccb8:	dfc00517 	ldw	ra,20(sp)
 820ccbc:	dd000417 	ldw	r20,16(sp)
 820ccc0:	dcc00317 	ldw	r19,12(sp)
 820ccc4:	dc800217 	ldw	r18,8(sp)
 820ccc8:	dc400117 	ldw	r17,4(sp)
 820cccc:	dc000017 	ldw	r16,0(sp)
 820ccd0:	dec00604 	addi	sp,sp,24
 820ccd4:	f800283a 	ret
 820ccd8:	880d883a 	mov	r6,r17
 820ccdc:	880b883a 	mov	r5,r17
 820cce0:	9809883a 	mov	r4,r19
 820cce4:	820ca1c0 	call	820ca1c <__multiply>
 820cce8:	88800015 	stw	r2,0(r17)
 820ccec:	10000015 	stw	zero,0(r2)
 820ccf0:	003fdd06 	br	820cc68 <__pow5mult+0x54>
 820ccf4:	1025883a 	mov	r18,r2
 820ccf8:	003fd706 	br	820cc58 <__pow5mult+0x44>
 820ccfc:	10bfffc4 	addi	r2,r2,-1
 820cd00:	1085883a 	add	r2,r2,r2
 820cd04:	00c20974 	movhi	r3,2085
 820cd08:	18f6eb04 	addi	r3,r3,-9300
 820cd0c:	1085883a 	add	r2,r2,r2
 820cd10:	1885883a 	add	r2,r3,r2
 820cd14:	11800017 	ldw	r6,0(r2)
 820cd18:	000f883a 	mov	r7,zero
 820cd1c:	820c6a40 	call	820c6a4 <__multadd>
 820cd20:	1025883a 	mov	r18,r2
 820cd24:	003fc706 	br	820cc44 <__pow5mult+0x30>
 820cd28:	05000044 	movi	r20,1
 820cd2c:	a00b883a 	mov	r5,r20
 820cd30:	9809883a 	mov	r4,r19
 820cd34:	820c5d40 	call	820c5d4 <_Balloc>
 820cd38:	1023883a 	mov	r17,r2
 820cd3c:	00809c44 	movi	r2,625
 820cd40:	88800515 	stw	r2,20(r17)
 820cd44:	8d000415 	stw	r20,16(r17)
 820cd48:	9c401215 	stw	r17,72(r19)
 820cd4c:	88000015 	stw	zero,0(r17)
 820cd50:	003fc606 	br	820cc6c <__pow5mult+0x58>

0820cd54 <__lshift>:
 820cd54:	defff904 	addi	sp,sp,-28
 820cd58:	dd400515 	stw	r21,20(sp)
 820cd5c:	dcc00315 	stw	r19,12(sp)
 820cd60:	302bd17a 	srai	r21,r6,5
 820cd64:	2cc00417 	ldw	r19,16(r5)
 820cd68:	28800217 	ldw	r2,8(r5)
 820cd6c:	dd000415 	stw	r20,16(sp)
 820cd70:	ace7883a 	add	r19,r21,r19
 820cd74:	dc800215 	stw	r18,8(sp)
 820cd78:	dc400115 	stw	r17,4(sp)
 820cd7c:	dc000015 	stw	r16,0(sp)
 820cd80:	dfc00615 	stw	ra,24(sp)
 820cd84:	9c000044 	addi	r16,r19,1
 820cd88:	2823883a 	mov	r17,r5
 820cd8c:	3029883a 	mov	r20,r6
 820cd90:	2025883a 	mov	r18,r4
 820cd94:	29400117 	ldw	r5,4(r5)
 820cd98:	1400030e 	bge	r2,r16,820cda8 <__lshift+0x54>
 820cd9c:	1085883a 	add	r2,r2,r2
 820cda0:	29400044 	addi	r5,r5,1
 820cda4:	143ffd16 	blt	r2,r16,820cd9c <__lshift+0x48>
 820cda8:	9009883a 	mov	r4,r18
 820cdac:	820c5d40 	call	820c5d4 <_Balloc>
 820cdb0:	10c00504 	addi	r3,r2,20
 820cdb4:	0540070e 	bge	zero,r21,820cdd4 <__lshift+0x80>
 820cdb8:	ad6b883a 	add	r21,r21,r21
 820cdbc:	ad6b883a 	add	r21,r21,r21
 820cdc0:	1809883a 	mov	r4,r3
 820cdc4:	1d47883a 	add	r3,r3,r21
 820cdc8:	20000015 	stw	zero,0(r4)
 820cdcc:	21000104 	addi	r4,r4,4
 820cdd0:	193ffd1e 	bne	r3,r4,820cdc8 <__lshift+0x74>
 820cdd4:	8a000417 	ldw	r8,16(r17)
 820cdd8:	89000504 	addi	r4,r17,20
 820cddc:	a18007cc 	andi	r6,r20,31
 820cde0:	4211883a 	add	r8,r8,r8
 820cde4:	4211883a 	add	r8,r8,r8
 820cde8:	2211883a 	add	r8,r4,r8
 820cdec:	30002326 	beq	r6,zero,820ce7c <__lshift+0x128>
 820cdf0:	02400804 	movi	r9,32
 820cdf4:	4993c83a 	sub	r9,r9,r6
 820cdf8:	000b883a 	mov	r5,zero
 820cdfc:	21c00017 	ldw	r7,0(r4)
 820ce00:	1815883a 	mov	r10,r3
 820ce04:	18c00104 	addi	r3,r3,4
 820ce08:	398e983a 	sll	r7,r7,r6
 820ce0c:	21000104 	addi	r4,r4,4
 820ce10:	394ab03a 	or	r5,r7,r5
 820ce14:	197fff15 	stw	r5,-4(r3)
 820ce18:	217fff17 	ldw	r5,-4(r4)
 820ce1c:	2a4ad83a 	srl	r5,r5,r9
 820ce20:	223ff636 	bltu	r4,r8,820cdfc <__lshift+0xa8>
 820ce24:	51400115 	stw	r5,4(r10)
 820ce28:	28001a1e 	bne	r5,zero,820ce94 <__lshift+0x140>
 820ce2c:	843fffc4 	addi	r16,r16,-1
 820ce30:	14000415 	stw	r16,16(r2)
 820ce34:	88000826 	beq	r17,zero,820ce58 <__lshift+0x104>
 820ce38:	89000117 	ldw	r4,4(r17)
 820ce3c:	90c01317 	ldw	r3,76(r18)
 820ce40:	2109883a 	add	r4,r4,r4
 820ce44:	2109883a 	add	r4,r4,r4
 820ce48:	1907883a 	add	r3,r3,r4
 820ce4c:	19000017 	ldw	r4,0(r3)
 820ce50:	89000015 	stw	r4,0(r17)
 820ce54:	1c400015 	stw	r17,0(r3)
 820ce58:	dfc00617 	ldw	ra,24(sp)
 820ce5c:	dd400517 	ldw	r21,20(sp)
 820ce60:	dd000417 	ldw	r20,16(sp)
 820ce64:	dcc00317 	ldw	r19,12(sp)
 820ce68:	dc800217 	ldw	r18,8(sp)
 820ce6c:	dc400117 	ldw	r17,4(sp)
 820ce70:	dc000017 	ldw	r16,0(sp)
 820ce74:	dec00704 	addi	sp,sp,28
 820ce78:	f800283a 	ret
 820ce7c:	21400017 	ldw	r5,0(r4)
 820ce80:	18c00104 	addi	r3,r3,4
 820ce84:	21000104 	addi	r4,r4,4
 820ce88:	197fff15 	stw	r5,-4(r3)
 820ce8c:	223ffb36 	bltu	r4,r8,820ce7c <__lshift+0x128>
 820ce90:	003fe606 	br	820ce2c <__lshift+0xd8>
 820ce94:	9c000084 	addi	r16,r19,2
 820ce98:	003fe406 	br	820ce2c <__lshift+0xd8>

0820ce9c <__mcmp>:
 820ce9c:	20800417 	ldw	r2,16(r4)
 820cea0:	28c00417 	ldw	r3,16(r5)
 820cea4:	10c5c83a 	sub	r2,r2,r3
 820cea8:	1000111e 	bne	r2,zero,820cef0 <__mcmp+0x54>
 820ceac:	18c7883a 	add	r3,r3,r3
 820ceb0:	18c7883a 	add	r3,r3,r3
 820ceb4:	21000504 	addi	r4,r4,20
 820ceb8:	29400504 	addi	r5,r5,20
 820cebc:	20c5883a 	add	r2,r4,r3
 820cec0:	28cb883a 	add	r5,r5,r3
 820cec4:	00000106 	br	820cecc <__mcmp+0x30>
 820cec8:	20800a2e 	bgeu	r4,r2,820cef4 <__mcmp+0x58>
 820cecc:	10bfff04 	addi	r2,r2,-4
 820ced0:	297fff04 	addi	r5,r5,-4
 820ced4:	11800017 	ldw	r6,0(r2)
 820ced8:	28c00017 	ldw	r3,0(r5)
 820cedc:	30fffa26 	beq	r6,r3,820cec8 <__mcmp+0x2c>
 820cee0:	30c00236 	bltu	r6,r3,820ceec <__mcmp+0x50>
 820cee4:	00800044 	movi	r2,1
 820cee8:	f800283a 	ret
 820ceec:	00bfffc4 	movi	r2,-1
 820cef0:	f800283a 	ret
 820cef4:	0005883a 	mov	r2,zero
 820cef8:	f800283a 	ret

0820cefc <__mdiff>:
 820cefc:	28c00417 	ldw	r3,16(r5)
 820cf00:	30800417 	ldw	r2,16(r6)
 820cf04:	defffa04 	addi	sp,sp,-24
 820cf08:	dcc00315 	stw	r19,12(sp)
 820cf0c:	dc800215 	stw	r18,8(sp)
 820cf10:	dfc00515 	stw	ra,20(sp)
 820cf14:	dd000415 	stw	r20,16(sp)
 820cf18:	dc400115 	stw	r17,4(sp)
 820cf1c:	dc000015 	stw	r16,0(sp)
 820cf20:	1887c83a 	sub	r3,r3,r2
 820cf24:	2825883a 	mov	r18,r5
 820cf28:	3027883a 	mov	r19,r6
 820cf2c:	1800141e 	bne	r3,zero,820cf80 <__mdiff+0x84>
 820cf30:	1085883a 	add	r2,r2,r2
 820cf34:	1085883a 	add	r2,r2,r2
 820cf38:	2a000504 	addi	r8,r5,20
 820cf3c:	34000504 	addi	r16,r6,20
 820cf40:	4087883a 	add	r3,r8,r2
 820cf44:	8085883a 	add	r2,r16,r2
 820cf48:	00000106 	br	820cf50 <__mdiff+0x54>
 820cf4c:	40c0592e 	bgeu	r8,r3,820d0b4 <__mdiff+0x1b8>
 820cf50:	18ffff04 	addi	r3,r3,-4
 820cf54:	10bfff04 	addi	r2,r2,-4
 820cf58:	19c00017 	ldw	r7,0(r3)
 820cf5c:	11400017 	ldw	r5,0(r2)
 820cf60:	397ffa26 	beq	r7,r5,820cf4c <__mdiff+0x50>
 820cf64:	3940592e 	bgeu	r7,r5,820d0cc <__mdiff+0x1d0>
 820cf68:	9005883a 	mov	r2,r18
 820cf6c:	4023883a 	mov	r17,r8
 820cf70:	9825883a 	mov	r18,r19
 820cf74:	05000044 	movi	r20,1
 820cf78:	1027883a 	mov	r19,r2
 820cf7c:	00000406 	br	820cf90 <__mdiff+0x94>
 820cf80:	18005616 	blt	r3,zero,820d0dc <__mdiff+0x1e0>
 820cf84:	34400504 	addi	r17,r6,20
 820cf88:	2c000504 	addi	r16,r5,20
 820cf8c:	0029883a 	mov	r20,zero
 820cf90:	91400117 	ldw	r5,4(r18)
 820cf94:	820c5d40 	call	820c5d4 <_Balloc>
 820cf98:	92400417 	ldw	r9,16(r18)
 820cf9c:	9b000417 	ldw	r12,16(r19)
 820cfa0:	12c00504 	addi	r11,r2,20
 820cfa4:	4a51883a 	add	r8,r9,r9
 820cfa8:	6319883a 	add	r12,r12,r12
 820cfac:	4211883a 	add	r8,r8,r8
 820cfb0:	6319883a 	add	r12,r12,r12
 820cfb4:	15000315 	stw	r20,12(r2)
 820cfb8:	8211883a 	add	r8,r16,r8
 820cfbc:	8b19883a 	add	r12,r17,r12
 820cfc0:	0007883a 	mov	r3,zero
 820cfc4:	81400017 	ldw	r5,0(r16)
 820cfc8:	89c00017 	ldw	r7,0(r17)
 820cfcc:	59800104 	addi	r6,r11,4
 820cfd0:	293fffcc 	andi	r4,r5,65535
 820cfd4:	20c7883a 	add	r3,r4,r3
 820cfd8:	393fffcc 	andi	r4,r7,65535
 820cfdc:	1909c83a 	sub	r4,r3,r4
 820cfe0:	280ad43a 	srli	r5,r5,16
 820cfe4:	380ed43a 	srli	r7,r7,16
 820cfe8:	2007d43a 	srai	r3,r4,16
 820cfec:	213fffcc 	andi	r4,r4,65535
 820cff0:	29cbc83a 	sub	r5,r5,r7
 820cff4:	28c7883a 	add	r3,r5,r3
 820cff8:	180a943a 	slli	r5,r3,16
 820cffc:	8c400104 	addi	r17,r17,4
 820d000:	84000104 	addi	r16,r16,4
 820d004:	2908b03a 	or	r4,r5,r4
 820d008:	59000015 	stw	r4,0(r11)
 820d00c:	1807d43a 	srai	r3,r3,16
 820d010:	3015883a 	mov	r10,r6
 820d014:	3017883a 	mov	r11,r6
 820d018:	8b3fea36 	bltu	r17,r12,820cfc4 <__mdiff+0xc8>
 820d01c:	8200162e 	bgeu	r16,r8,820d078 <__mdiff+0x17c>
 820d020:	8017883a 	mov	r11,r16
 820d024:	59400017 	ldw	r5,0(r11)
 820d028:	31800104 	addi	r6,r6,4
 820d02c:	5ac00104 	addi	r11,r11,4
 820d030:	293fffcc 	andi	r4,r5,65535
 820d034:	20c7883a 	add	r3,r4,r3
 820d038:	280ed43a 	srli	r7,r5,16
 820d03c:	180bd43a 	srai	r5,r3,16
 820d040:	193fffcc 	andi	r4,r3,65535
 820d044:	3947883a 	add	r3,r7,r5
 820d048:	180a943a 	slli	r5,r3,16
 820d04c:	1807d43a 	srai	r3,r3,16
 820d050:	2908b03a 	or	r4,r5,r4
 820d054:	313fff15 	stw	r4,-4(r6)
 820d058:	5a3ff236 	bltu	r11,r8,820d024 <__mdiff+0x128>
 820d05c:	0406303a 	nor	r3,zero,r16
 820d060:	1a07883a 	add	r3,r3,r8
 820d064:	1806d0ba 	srli	r3,r3,2
 820d068:	18c00044 	addi	r3,r3,1
 820d06c:	18c7883a 	add	r3,r3,r3
 820d070:	18c7883a 	add	r3,r3,r3
 820d074:	50d5883a 	add	r10,r10,r3
 820d078:	50ffff04 	addi	r3,r10,-4
 820d07c:	2000041e 	bne	r4,zero,820d090 <__mdiff+0x194>
 820d080:	18ffff04 	addi	r3,r3,-4
 820d084:	19000017 	ldw	r4,0(r3)
 820d088:	4a7fffc4 	addi	r9,r9,-1
 820d08c:	203ffc26 	beq	r4,zero,820d080 <__mdiff+0x184>
 820d090:	12400415 	stw	r9,16(r2)
 820d094:	dfc00517 	ldw	ra,20(sp)
 820d098:	dd000417 	ldw	r20,16(sp)
 820d09c:	dcc00317 	ldw	r19,12(sp)
 820d0a0:	dc800217 	ldw	r18,8(sp)
 820d0a4:	dc400117 	ldw	r17,4(sp)
 820d0a8:	dc000017 	ldw	r16,0(sp)
 820d0ac:	dec00604 	addi	sp,sp,24
 820d0b0:	f800283a 	ret
 820d0b4:	000b883a 	mov	r5,zero
 820d0b8:	820c5d40 	call	820c5d4 <_Balloc>
 820d0bc:	00c00044 	movi	r3,1
 820d0c0:	10c00415 	stw	r3,16(r2)
 820d0c4:	10000515 	stw	zero,20(r2)
 820d0c8:	003ff206 	br	820d094 <__mdiff+0x198>
 820d0cc:	8023883a 	mov	r17,r16
 820d0d0:	0029883a 	mov	r20,zero
 820d0d4:	4021883a 	mov	r16,r8
 820d0d8:	003fad06 	br	820cf90 <__mdiff+0x94>
 820d0dc:	9005883a 	mov	r2,r18
 820d0e0:	94400504 	addi	r17,r18,20
 820d0e4:	9c000504 	addi	r16,r19,20
 820d0e8:	9825883a 	mov	r18,r19
 820d0ec:	05000044 	movi	r20,1
 820d0f0:	1027883a 	mov	r19,r2
 820d0f4:	003fa606 	br	820cf90 <__mdiff+0x94>

0820d0f8 <__ulp>:
 820d0f8:	295ffc2c 	andhi	r5,r5,32752
 820d0fc:	00bf3034 	movhi	r2,64704
 820d100:	2887883a 	add	r3,r5,r2
 820d104:	00c0020e 	bge	zero,r3,820d110 <__ulp+0x18>
 820d108:	0005883a 	mov	r2,zero
 820d10c:	f800283a 	ret
 820d110:	00c7c83a 	sub	r3,zero,r3
 820d114:	1807d53a 	srai	r3,r3,20
 820d118:	008004c4 	movi	r2,19
 820d11c:	10c00b0e 	bge	r2,r3,820d14c <__ulp+0x54>
 820d120:	18bffb04 	addi	r2,r3,-20
 820d124:	01000784 	movi	r4,30
 820d128:	0007883a 	mov	r3,zero
 820d12c:	20800516 	blt	r4,r2,820d144 <__ulp+0x4c>
 820d130:	010007c4 	movi	r4,31
 820d134:	2089c83a 	sub	r4,r4,r2
 820d138:	00800044 	movi	r2,1
 820d13c:	1104983a 	sll	r2,r2,r4
 820d140:	f800283a 	ret
 820d144:	00800044 	movi	r2,1
 820d148:	f800283a 	ret
 820d14c:	01400234 	movhi	r5,8
 820d150:	28c7d83a 	sra	r3,r5,r3
 820d154:	0005883a 	mov	r2,zero
 820d158:	f800283a 	ret

0820d15c <__b2d>:
 820d15c:	defffa04 	addi	sp,sp,-24
 820d160:	dc000015 	stw	r16,0(sp)
 820d164:	24000417 	ldw	r16,16(r4)
 820d168:	dc400115 	stw	r17,4(sp)
 820d16c:	24400504 	addi	r17,r4,20
 820d170:	8421883a 	add	r16,r16,r16
 820d174:	8421883a 	add	r16,r16,r16
 820d178:	8c21883a 	add	r16,r17,r16
 820d17c:	dc800215 	stw	r18,8(sp)
 820d180:	84bfff17 	ldw	r18,-4(r16)
 820d184:	dd000415 	stw	r20,16(sp)
 820d188:	dcc00315 	stw	r19,12(sp)
 820d18c:	9009883a 	mov	r4,r18
 820d190:	2829883a 	mov	r20,r5
 820d194:	dfc00515 	stw	ra,20(sp)
 820d198:	820c8c80 	call	820c8c8 <__hi0bits>
 820d19c:	00c00804 	movi	r3,32
 820d1a0:	1889c83a 	sub	r4,r3,r2
 820d1a4:	a1000015 	stw	r4,0(r20)
 820d1a8:	01000284 	movi	r4,10
 820d1ac:	84ffff04 	addi	r19,r16,-4
 820d1b0:	20801216 	blt	r4,r2,820d1fc <__b2d+0xa0>
 820d1b4:	018002c4 	movi	r6,11
 820d1b8:	308dc83a 	sub	r6,r6,r2
 820d1bc:	9186d83a 	srl	r3,r18,r6
 820d1c0:	18cffc34 	orhi	r3,r3,16368
 820d1c4:	8cc0212e 	bgeu	r17,r19,820d24c <__b2d+0xf0>
 820d1c8:	813ffe17 	ldw	r4,-8(r16)
 820d1cc:	218cd83a 	srl	r6,r4,r6
 820d1d0:	10800544 	addi	r2,r2,21
 820d1d4:	9084983a 	sll	r2,r18,r2
 820d1d8:	1184b03a 	or	r2,r2,r6
 820d1dc:	dfc00517 	ldw	ra,20(sp)
 820d1e0:	dd000417 	ldw	r20,16(sp)
 820d1e4:	dcc00317 	ldw	r19,12(sp)
 820d1e8:	dc800217 	ldw	r18,8(sp)
 820d1ec:	dc400117 	ldw	r17,4(sp)
 820d1f0:	dc000017 	ldw	r16,0(sp)
 820d1f4:	dec00604 	addi	sp,sp,24
 820d1f8:	f800283a 	ret
 820d1fc:	8cc00f2e 	bgeu	r17,r19,820d23c <__b2d+0xe0>
 820d200:	117ffd44 	addi	r5,r2,-11
 820d204:	80bffe17 	ldw	r2,-8(r16)
 820d208:	28000e26 	beq	r5,zero,820d244 <__b2d+0xe8>
 820d20c:	1949c83a 	sub	r4,r3,r5
 820d210:	9164983a 	sll	r18,r18,r5
 820d214:	1106d83a 	srl	r3,r2,r4
 820d218:	81bffe04 	addi	r6,r16,-8
 820d21c:	948ffc34 	orhi	r18,r18,16368
 820d220:	90c6b03a 	or	r3,r18,r3
 820d224:	89800e2e 	bgeu	r17,r6,820d260 <__b2d+0x104>
 820d228:	81bffd17 	ldw	r6,-12(r16)
 820d22c:	1144983a 	sll	r2,r2,r5
 820d230:	310ad83a 	srl	r5,r6,r4
 820d234:	2884b03a 	or	r2,r5,r2
 820d238:	003fe806 	br	820d1dc <__b2d+0x80>
 820d23c:	10bffd44 	addi	r2,r2,-11
 820d240:	1000041e 	bne	r2,zero,820d254 <__b2d+0xf8>
 820d244:	90cffc34 	orhi	r3,r18,16368
 820d248:	003fe406 	br	820d1dc <__b2d+0x80>
 820d24c:	000d883a 	mov	r6,zero
 820d250:	003fdf06 	br	820d1d0 <__b2d+0x74>
 820d254:	90a4983a 	sll	r18,r18,r2
 820d258:	0005883a 	mov	r2,zero
 820d25c:	003ff906 	br	820d244 <__b2d+0xe8>
 820d260:	1144983a 	sll	r2,r2,r5
 820d264:	003fdd06 	br	820d1dc <__b2d+0x80>

0820d268 <__d2b>:
 820d268:	defff804 	addi	sp,sp,-32
 820d26c:	dc000215 	stw	r16,8(sp)
 820d270:	3021883a 	mov	r16,r6
 820d274:	dc400315 	stw	r17,12(sp)
 820d278:	8022907a 	slli	r17,r16,1
 820d27c:	dd000615 	stw	r20,24(sp)
 820d280:	2829883a 	mov	r20,r5
 820d284:	01400044 	movi	r5,1
 820d288:	dcc00515 	stw	r19,20(sp)
 820d28c:	dc800415 	stw	r18,16(sp)
 820d290:	dfc00715 	stw	ra,28(sp)
 820d294:	3825883a 	mov	r18,r7
 820d298:	8822d57a 	srli	r17,r17,21
 820d29c:	820c5d40 	call	820c5d4 <_Balloc>
 820d2a0:	1027883a 	mov	r19,r2
 820d2a4:	00800434 	movhi	r2,16
 820d2a8:	10bfffc4 	addi	r2,r2,-1
 820d2ac:	808c703a 	and	r6,r16,r2
 820d2b0:	88000126 	beq	r17,zero,820d2b8 <__d2b+0x50>
 820d2b4:	31800434 	orhi	r6,r6,16
 820d2b8:	d9800015 	stw	r6,0(sp)
 820d2bc:	a0002426 	beq	r20,zero,820d350 <__d2b+0xe8>
 820d2c0:	d9000104 	addi	r4,sp,4
 820d2c4:	dd000115 	stw	r20,4(sp)
 820d2c8:	820c9300 	call	820c930 <__lo0bits>
 820d2cc:	d8c00017 	ldw	r3,0(sp)
 820d2d0:	10002f1e 	bne	r2,zero,820d390 <__d2b+0x128>
 820d2d4:	d9000117 	ldw	r4,4(sp)
 820d2d8:	99000515 	stw	r4,20(r19)
 820d2dc:	1821003a 	cmpeq	r16,r3,zero
 820d2e0:	01000084 	movi	r4,2
 820d2e4:	2421c83a 	sub	r16,r4,r16
 820d2e8:	98c00615 	stw	r3,24(r19)
 820d2ec:	9c000415 	stw	r16,16(r19)
 820d2f0:	88001f1e 	bne	r17,zero,820d370 <__d2b+0x108>
 820d2f4:	10bef384 	addi	r2,r2,-1074
 820d2f8:	90800015 	stw	r2,0(r18)
 820d2fc:	00900034 	movhi	r2,16384
 820d300:	10bfffc4 	addi	r2,r2,-1
 820d304:	8085883a 	add	r2,r16,r2
 820d308:	1085883a 	add	r2,r2,r2
 820d30c:	1085883a 	add	r2,r2,r2
 820d310:	9885883a 	add	r2,r19,r2
 820d314:	11000517 	ldw	r4,20(r2)
 820d318:	8020917a 	slli	r16,r16,5
 820d31c:	820c8c80 	call	820c8c8 <__hi0bits>
 820d320:	d8c00817 	ldw	r3,32(sp)
 820d324:	8085c83a 	sub	r2,r16,r2
 820d328:	18800015 	stw	r2,0(r3)
 820d32c:	9805883a 	mov	r2,r19
 820d330:	dfc00717 	ldw	ra,28(sp)
 820d334:	dd000617 	ldw	r20,24(sp)
 820d338:	dcc00517 	ldw	r19,20(sp)
 820d33c:	dc800417 	ldw	r18,16(sp)
 820d340:	dc400317 	ldw	r17,12(sp)
 820d344:	dc000217 	ldw	r16,8(sp)
 820d348:	dec00804 	addi	sp,sp,32
 820d34c:	f800283a 	ret
 820d350:	d809883a 	mov	r4,sp
 820d354:	820c9300 	call	820c930 <__lo0bits>
 820d358:	d8c00017 	ldw	r3,0(sp)
 820d35c:	04000044 	movi	r16,1
 820d360:	9c000415 	stw	r16,16(r19)
 820d364:	98c00515 	stw	r3,20(r19)
 820d368:	10800804 	addi	r2,r2,32
 820d36c:	883fe126 	beq	r17,zero,820d2f4 <__d2b+0x8c>
 820d370:	00c00d44 	movi	r3,53
 820d374:	8c7ef344 	addi	r17,r17,-1075
 820d378:	88a3883a 	add	r17,r17,r2
 820d37c:	1885c83a 	sub	r2,r3,r2
 820d380:	d8c00817 	ldw	r3,32(sp)
 820d384:	94400015 	stw	r17,0(r18)
 820d388:	18800015 	stw	r2,0(r3)
 820d38c:	003fe706 	br	820d32c <__d2b+0xc4>
 820d390:	01000804 	movi	r4,32
 820d394:	2089c83a 	sub	r4,r4,r2
 820d398:	1908983a 	sll	r4,r3,r4
 820d39c:	d9400117 	ldw	r5,4(sp)
 820d3a0:	1886d83a 	srl	r3,r3,r2
 820d3a4:	2148b03a 	or	r4,r4,r5
 820d3a8:	99000515 	stw	r4,20(r19)
 820d3ac:	d8c00015 	stw	r3,0(sp)
 820d3b0:	003fca06 	br	820d2dc <__d2b+0x74>

0820d3b4 <__ratio>:
 820d3b4:	defff904 	addi	sp,sp,-28
 820d3b8:	dc400315 	stw	r17,12(sp)
 820d3bc:	2823883a 	mov	r17,r5
 820d3c0:	d9400104 	addi	r5,sp,4
 820d3c4:	dfc00615 	stw	ra,24(sp)
 820d3c8:	dcc00515 	stw	r19,20(sp)
 820d3cc:	dc800415 	stw	r18,16(sp)
 820d3d0:	2027883a 	mov	r19,r4
 820d3d4:	dc000215 	stw	r16,8(sp)
 820d3d8:	820d15c0 	call	820d15c <__b2d>
 820d3dc:	d80b883a 	mov	r5,sp
 820d3e0:	8809883a 	mov	r4,r17
 820d3e4:	1025883a 	mov	r18,r2
 820d3e8:	1821883a 	mov	r16,r3
 820d3ec:	820d15c0 	call	820d15c <__b2d>
 820d3f0:	8a000417 	ldw	r8,16(r17)
 820d3f4:	99000417 	ldw	r4,16(r19)
 820d3f8:	d9400117 	ldw	r5,4(sp)
 820d3fc:	2209c83a 	sub	r4,r4,r8
 820d400:	2010917a 	slli	r8,r4,5
 820d404:	d9000017 	ldw	r4,0(sp)
 820d408:	2909c83a 	sub	r4,r5,r4
 820d40c:	4109883a 	add	r4,r8,r4
 820d410:	01000e0e 	bge	zero,r4,820d44c <__ratio+0x98>
 820d414:	2008953a 	slli	r4,r4,20
 820d418:	2421883a 	add	r16,r4,r16
 820d41c:	100d883a 	mov	r6,r2
 820d420:	180f883a 	mov	r7,r3
 820d424:	9009883a 	mov	r4,r18
 820d428:	800b883a 	mov	r5,r16
 820d42c:	82125900 	call	8212590 <__divdf3>
 820d430:	dfc00617 	ldw	ra,24(sp)
 820d434:	dcc00517 	ldw	r19,20(sp)
 820d438:	dc800417 	ldw	r18,16(sp)
 820d43c:	dc400317 	ldw	r17,12(sp)
 820d440:	dc000217 	ldw	r16,8(sp)
 820d444:	dec00704 	addi	sp,sp,28
 820d448:	f800283a 	ret
 820d44c:	2008953a 	slli	r4,r4,20
 820d450:	1907c83a 	sub	r3,r3,r4
 820d454:	003ff106 	br	820d41c <__ratio+0x68>

0820d458 <_mprec_log10>:
 820d458:	defffe04 	addi	sp,sp,-8
 820d45c:	dc000015 	stw	r16,0(sp)
 820d460:	dfc00115 	stw	ra,4(sp)
 820d464:	008005c4 	movi	r2,23
 820d468:	2021883a 	mov	r16,r4
 820d46c:	11000d0e 	bge	r2,r4,820d4a4 <_mprec_log10+0x4c>
 820d470:	0005883a 	mov	r2,zero
 820d474:	00cffc34 	movhi	r3,16368
 820d478:	843fffc4 	addi	r16,r16,-1
 820d47c:	000d883a 	mov	r6,zero
 820d480:	01d00934 	movhi	r7,16420
 820d484:	1009883a 	mov	r4,r2
 820d488:	180b883a 	mov	r5,r3
 820d48c:	82130d00 	call	82130d0 <__muldf3>
 820d490:	803ff91e 	bne	r16,zero,820d478 <_mprec_log10+0x20>
 820d494:	dfc00117 	ldw	ra,4(sp)
 820d498:	dc000017 	ldw	r16,0(sp)
 820d49c:	dec00204 	addi	sp,sp,8
 820d4a0:	f800283a 	ret
 820d4a4:	202090fa 	slli	r16,r4,3
 820d4a8:	00820974 	movhi	r2,2085
 820d4ac:	10b70204 	addi	r2,r2,-9208
 820d4b0:	1421883a 	add	r16,r2,r16
 820d4b4:	80800017 	ldw	r2,0(r16)
 820d4b8:	80c00117 	ldw	r3,4(r16)
 820d4bc:	dfc00117 	ldw	ra,4(sp)
 820d4c0:	dc000017 	ldw	r16,0(sp)
 820d4c4:	dec00204 	addi	sp,sp,8
 820d4c8:	f800283a 	ret

0820d4cc <__copybits>:
 820d4cc:	297fffc4 	addi	r5,r5,-1
 820d4d0:	280fd17a 	srai	r7,r5,5
 820d4d4:	30c00417 	ldw	r3,16(r6)
 820d4d8:	30800504 	addi	r2,r6,20
 820d4dc:	39c00044 	addi	r7,r7,1
 820d4e0:	18c7883a 	add	r3,r3,r3
 820d4e4:	39cf883a 	add	r7,r7,r7
 820d4e8:	18c7883a 	add	r3,r3,r3
 820d4ec:	39cf883a 	add	r7,r7,r7
 820d4f0:	10c7883a 	add	r3,r2,r3
 820d4f4:	21cf883a 	add	r7,r4,r7
 820d4f8:	10c00d2e 	bgeu	r2,r3,820d530 <__copybits+0x64>
 820d4fc:	200b883a 	mov	r5,r4
 820d500:	12000017 	ldw	r8,0(r2)
 820d504:	29400104 	addi	r5,r5,4
 820d508:	10800104 	addi	r2,r2,4
 820d50c:	2a3fff15 	stw	r8,-4(r5)
 820d510:	10fffb36 	bltu	r2,r3,820d500 <__copybits+0x34>
 820d514:	1985c83a 	sub	r2,r3,r6
 820d518:	10bffac4 	addi	r2,r2,-21
 820d51c:	1004d0ba 	srli	r2,r2,2
 820d520:	10800044 	addi	r2,r2,1
 820d524:	1085883a 	add	r2,r2,r2
 820d528:	1085883a 	add	r2,r2,r2
 820d52c:	2089883a 	add	r4,r4,r2
 820d530:	21c0032e 	bgeu	r4,r7,820d540 <__copybits+0x74>
 820d534:	20000015 	stw	zero,0(r4)
 820d538:	21000104 	addi	r4,r4,4
 820d53c:	21fffd36 	bltu	r4,r7,820d534 <__copybits+0x68>
 820d540:	f800283a 	ret

0820d544 <__any_on>:
 820d544:	20c00417 	ldw	r3,16(r4)
 820d548:	2805d17a 	srai	r2,r5,5
 820d54c:	21000504 	addi	r4,r4,20
 820d550:	18800d0e 	bge	r3,r2,820d588 <__any_on+0x44>
 820d554:	18c7883a 	add	r3,r3,r3
 820d558:	18c7883a 	add	r3,r3,r3
 820d55c:	20c7883a 	add	r3,r4,r3
 820d560:	20c0192e 	bgeu	r4,r3,820d5c8 <__any_on+0x84>
 820d564:	18bfff17 	ldw	r2,-4(r3)
 820d568:	18ffff04 	addi	r3,r3,-4
 820d56c:	1000041e 	bne	r2,zero,820d580 <__any_on+0x3c>
 820d570:	20c0142e 	bgeu	r4,r3,820d5c4 <__any_on+0x80>
 820d574:	18ffff04 	addi	r3,r3,-4
 820d578:	19400017 	ldw	r5,0(r3)
 820d57c:	283ffc26 	beq	r5,zero,820d570 <__any_on+0x2c>
 820d580:	00800044 	movi	r2,1
 820d584:	f800283a 	ret
 820d588:	10c00a0e 	bge	r2,r3,820d5b4 <__any_on+0x70>
 820d58c:	1085883a 	add	r2,r2,r2
 820d590:	1085883a 	add	r2,r2,r2
 820d594:	294007cc 	andi	r5,r5,31
 820d598:	2087883a 	add	r3,r4,r2
 820d59c:	283ff026 	beq	r5,zero,820d560 <__any_on+0x1c>
 820d5a0:	19800017 	ldw	r6,0(r3)
 820d5a4:	3144d83a 	srl	r2,r6,r5
 820d5a8:	114a983a 	sll	r5,r2,r5
 820d5ac:	317ff41e 	bne	r6,r5,820d580 <__any_on+0x3c>
 820d5b0:	003feb06 	br	820d560 <__any_on+0x1c>
 820d5b4:	1085883a 	add	r2,r2,r2
 820d5b8:	1085883a 	add	r2,r2,r2
 820d5bc:	2087883a 	add	r3,r4,r2
 820d5c0:	003fe706 	br	820d560 <__any_on+0x1c>
 820d5c4:	f800283a 	ret
 820d5c8:	0005883a 	mov	r2,zero
 820d5cc:	f800283a 	ret

0820d5d0 <_realloc_r>:
 820d5d0:	defff604 	addi	sp,sp,-40
 820d5d4:	dc800215 	stw	r18,8(sp)
 820d5d8:	dfc00915 	stw	ra,36(sp)
 820d5dc:	df000815 	stw	fp,32(sp)
 820d5e0:	ddc00715 	stw	r23,28(sp)
 820d5e4:	dd800615 	stw	r22,24(sp)
 820d5e8:	dd400515 	stw	r21,20(sp)
 820d5ec:	dd000415 	stw	r20,16(sp)
 820d5f0:	dcc00315 	stw	r19,12(sp)
 820d5f4:	dc400115 	stw	r17,4(sp)
 820d5f8:	dc000015 	stw	r16,0(sp)
 820d5fc:	3025883a 	mov	r18,r6
 820d600:	2800b726 	beq	r5,zero,820d8e0 <_realloc_r+0x310>
 820d604:	282b883a 	mov	r21,r5
 820d608:	2029883a 	mov	r20,r4
 820d60c:	82149740 	call	8214974 <__malloc_lock>
 820d610:	a8bfff17 	ldw	r2,-4(r21)
 820d614:	043fff04 	movi	r16,-4
 820d618:	90c002c4 	addi	r3,r18,11
 820d61c:	01000584 	movi	r4,22
 820d620:	acfffe04 	addi	r19,r21,-8
 820d624:	1420703a 	and	r16,r2,r16
 820d628:	20c0332e 	bgeu	r4,r3,820d6f8 <_realloc_r+0x128>
 820d62c:	047ffe04 	movi	r17,-8
 820d630:	1c62703a 	and	r17,r3,r17
 820d634:	8807883a 	mov	r3,r17
 820d638:	88005816 	blt	r17,zero,820d79c <_realloc_r+0x1cc>
 820d63c:	8c805736 	bltu	r17,r18,820d79c <_realloc_r+0x1cc>
 820d640:	80c0300e 	bge	r16,r3,820d704 <_realloc_r+0x134>
 820d644:	07020974 	movhi	fp,2085
 820d648:	e7093004 	addi	fp,fp,9408
 820d64c:	e1c00217 	ldw	r7,8(fp)
 820d650:	9c09883a 	add	r4,r19,r16
 820d654:	22000117 	ldw	r8,4(r4)
 820d658:	21c06326 	beq	r4,r7,820d7e8 <_realloc_r+0x218>
 820d65c:	017fff84 	movi	r5,-2
 820d660:	414a703a 	and	r5,r8,r5
 820d664:	214b883a 	add	r5,r4,r5
 820d668:	29800117 	ldw	r6,4(r5)
 820d66c:	3180004c 	andi	r6,r6,1
 820d670:	30003f26 	beq	r6,zero,820d770 <_realloc_r+0x1a0>
 820d674:	1080004c 	andi	r2,r2,1
 820d678:	10008326 	beq	r2,zero,820d888 <_realloc_r+0x2b8>
 820d67c:	900b883a 	mov	r5,r18
 820d680:	a009883a 	mov	r4,r20
 820d684:	820bc680 	call	820bc68 <_malloc_r>
 820d688:	1025883a 	mov	r18,r2
 820d68c:	10011e26 	beq	r2,zero,820db08 <_realloc_r+0x538>
 820d690:	a93fff17 	ldw	r4,-4(r21)
 820d694:	10fffe04 	addi	r3,r2,-8
 820d698:	00bfff84 	movi	r2,-2
 820d69c:	2084703a 	and	r2,r4,r2
 820d6a0:	9885883a 	add	r2,r19,r2
 820d6a4:	1880ee26 	beq	r3,r2,820da60 <_realloc_r+0x490>
 820d6a8:	81bfff04 	addi	r6,r16,-4
 820d6ac:	00800904 	movi	r2,36
 820d6b0:	1180b836 	bltu	r2,r6,820d994 <_realloc_r+0x3c4>
 820d6b4:	00c004c4 	movi	r3,19
 820d6b8:	19809636 	bltu	r3,r6,820d914 <_realloc_r+0x344>
 820d6bc:	9005883a 	mov	r2,r18
 820d6c0:	a807883a 	mov	r3,r21
 820d6c4:	19000017 	ldw	r4,0(r3)
 820d6c8:	11000015 	stw	r4,0(r2)
 820d6cc:	19000117 	ldw	r4,4(r3)
 820d6d0:	11000115 	stw	r4,4(r2)
 820d6d4:	18c00217 	ldw	r3,8(r3)
 820d6d8:	10c00215 	stw	r3,8(r2)
 820d6dc:	a80b883a 	mov	r5,r21
 820d6e0:	a009883a 	mov	r4,r20
 820d6e4:	820b07c0 	call	820b07c <_free_r>
 820d6e8:	a009883a 	mov	r4,r20
 820d6ec:	8214a940 	call	8214a94 <__malloc_unlock>
 820d6f0:	9005883a 	mov	r2,r18
 820d6f4:	00001206 	br	820d740 <_realloc_r+0x170>
 820d6f8:	00c00404 	movi	r3,16
 820d6fc:	1823883a 	mov	r17,r3
 820d700:	003fce06 	br	820d63c <_realloc_r+0x6c>
 820d704:	a825883a 	mov	r18,r21
 820d708:	8445c83a 	sub	r2,r16,r17
 820d70c:	00c003c4 	movi	r3,15
 820d710:	18802636 	bltu	r3,r2,820d7ac <_realloc_r+0x1dc>
 820d714:	99800117 	ldw	r6,4(r19)
 820d718:	9c07883a 	add	r3,r19,r16
 820d71c:	3180004c 	andi	r6,r6,1
 820d720:	3420b03a 	or	r16,r6,r16
 820d724:	9c000115 	stw	r16,4(r19)
 820d728:	18800117 	ldw	r2,4(r3)
 820d72c:	10800054 	ori	r2,r2,1
 820d730:	18800115 	stw	r2,4(r3)
 820d734:	a009883a 	mov	r4,r20
 820d738:	8214a940 	call	8214a94 <__malloc_unlock>
 820d73c:	9005883a 	mov	r2,r18
 820d740:	dfc00917 	ldw	ra,36(sp)
 820d744:	df000817 	ldw	fp,32(sp)
 820d748:	ddc00717 	ldw	r23,28(sp)
 820d74c:	dd800617 	ldw	r22,24(sp)
 820d750:	dd400517 	ldw	r21,20(sp)
 820d754:	dd000417 	ldw	r20,16(sp)
 820d758:	dcc00317 	ldw	r19,12(sp)
 820d75c:	dc800217 	ldw	r18,8(sp)
 820d760:	dc400117 	ldw	r17,4(sp)
 820d764:	dc000017 	ldw	r16,0(sp)
 820d768:	dec00a04 	addi	sp,sp,40
 820d76c:	f800283a 	ret
 820d770:	017fff04 	movi	r5,-4
 820d774:	414a703a 	and	r5,r8,r5
 820d778:	814d883a 	add	r6,r16,r5
 820d77c:	30c01f16 	blt	r6,r3,820d7fc <_realloc_r+0x22c>
 820d780:	20800317 	ldw	r2,12(r4)
 820d784:	20c00217 	ldw	r3,8(r4)
 820d788:	a825883a 	mov	r18,r21
 820d78c:	3021883a 	mov	r16,r6
 820d790:	18800315 	stw	r2,12(r3)
 820d794:	10c00215 	stw	r3,8(r2)
 820d798:	003fdb06 	br	820d708 <_realloc_r+0x138>
 820d79c:	00800304 	movi	r2,12
 820d7a0:	a0800015 	stw	r2,0(r20)
 820d7a4:	0005883a 	mov	r2,zero
 820d7a8:	003fe506 	br	820d740 <_realloc_r+0x170>
 820d7ac:	98c00117 	ldw	r3,4(r19)
 820d7b0:	9c4b883a 	add	r5,r19,r17
 820d7b4:	11000054 	ori	r4,r2,1
 820d7b8:	18c0004c 	andi	r3,r3,1
 820d7bc:	1c62b03a 	or	r17,r3,r17
 820d7c0:	9c400115 	stw	r17,4(r19)
 820d7c4:	29000115 	stw	r4,4(r5)
 820d7c8:	2885883a 	add	r2,r5,r2
 820d7cc:	10c00117 	ldw	r3,4(r2)
 820d7d0:	29400204 	addi	r5,r5,8
 820d7d4:	a009883a 	mov	r4,r20
 820d7d8:	18c00054 	ori	r3,r3,1
 820d7dc:	10c00115 	stw	r3,4(r2)
 820d7e0:	820b07c0 	call	820b07c <_free_r>
 820d7e4:	003fd306 	br	820d734 <_realloc_r+0x164>
 820d7e8:	017fff04 	movi	r5,-4
 820d7ec:	414a703a 	and	r5,r8,r5
 820d7f0:	89800404 	addi	r6,r17,16
 820d7f4:	8151883a 	add	r8,r16,r5
 820d7f8:	4180590e 	bge	r8,r6,820d960 <_realloc_r+0x390>
 820d7fc:	1080004c 	andi	r2,r2,1
 820d800:	103f9e1e 	bne	r2,zero,820d67c <_realloc_r+0xac>
 820d804:	adbffe17 	ldw	r22,-8(r21)
 820d808:	00bfff04 	movi	r2,-4
 820d80c:	9dadc83a 	sub	r22,r19,r22
 820d810:	b1800117 	ldw	r6,4(r22)
 820d814:	3084703a 	and	r2,r6,r2
 820d818:	20002026 	beq	r4,zero,820d89c <_realloc_r+0x2cc>
 820d81c:	80af883a 	add	r23,r16,r2
 820d820:	b96f883a 	add	r23,r23,r5
 820d824:	21c05f26 	beq	r4,r7,820d9a4 <_realloc_r+0x3d4>
 820d828:	b8c01c16 	blt	r23,r3,820d89c <_realloc_r+0x2cc>
 820d82c:	20800317 	ldw	r2,12(r4)
 820d830:	20c00217 	ldw	r3,8(r4)
 820d834:	81bfff04 	addi	r6,r16,-4
 820d838:	01000904 	movi	r4,36
 820d83c:	18800315 	stw	r2,12(r3)
 820d840:	10c00215 	stw	r3,8(r2)
 820d844:	b0c00217 	ldw	r3,8(r22)
 820d848:	b0800317 	ldw	r2,12(r22)
 820d84c:	b4800204 	addi	r18,r22,8
 820d850:	18800315 	stw	r2,12(r3)
 820d854:	10c00215 	stw	r3,8(r2)
 820d858:	21801b36 	bltu	r4,r6,820d8c8 <_realloc_r+0x2f8>
 820d85c:	008004c4 	movi	r2,19
 820d860:	1180352e 	bgeu	r2,r6,820d938 <_realloc_r+0x368>
 820d864:	a8800017 	ldw	r2,0(r21)
 820d868:	b0800215 	stw	r2,8(r22)
 820d86c:	a8800117 	ldw	r2,4(r21)
 820d870:	b0800315 	stw	r2,12(r22)
 820d874:	008006c4 	movi	r2,27
 820d878:	11807f36 	bltu	r2,r6,820da78 <_realloc_r+0x4a8>
 820d87c:	b0800404 	addi	r2,r22,16
 820d880:	ad400204 	addi	r21,r21,8
 820d884:	00002d06 	br	820d93c <_realloc_r+0x36c>
 820d888:	adbffe17 	ldw	r22,-8(r21)
 820d88c:	00bfff04 	movi	r2,-4
 820d890:	9dadc83a 	sub	r22,r19,r22
 820d894:	b1000117 	ldw	r4,4(r22)
 820d898:	2084703a 	and	r2,r4,r2
 820d89c:	b03f7726 	beq	r22,zero,820d67c <_realloc_r+0xac>
 820d8a0:	80af883a 	add	r23,r16,r2
 820d8a4:	b8ff7516 	blt	r23,r3,820d67c <_realloc_r+0xac>
 820d8a8:	b0800317 	ldw	r2,12(r22)
 820d8ac:	b0c00217 	ldw	r3,8(r22)
 820d8b0:	81bfff04 	addi	r6,r16,-4
 820d8b4:	01000904 	movi	r4,36
 820d8b8:	18800315 	stw	r2,12(r3)
 820d8bc:	10c00215 	stw	r3,8(r2)
 820d8c0:	b4800204 	addi	r18,r22,8
 820d8c4:	21bfe52e 	bgeu	r4,r6,820d85c <_realloc_r+0x28c>
 820d8c8:	a80b883a 	mov	r5,r21
 820d8cc:	9009883a 	mov	r4,r18
 820d8d0:	8202fd40 	call	8202fd4 <memmove>
 820d8d4:	b821883a 	mov	r16,r23
 820d8d8:	b027883a 	mov	r19,r22
 820d8dc:	003f8a06 	br	820d708 <_realloc_r+0x138>
 820d8e0:	300b883a 	mov	r5,r6
 820d8e4:	dfc00917 	ldw	ra,36(sp)
 820d8e8:	df000817 	ldw	fp,32(sp)
 820d8ec:	ddc00717 	ldw	r23,28(sp)
 820d8f0:	dd800617 	ldw	r22,24(sp)
 820d8f4:	dd400517 	ldw	r21,20(sp)
 820d8f8:	dd000417 	ldw	r20,16(sp)
 820d8fc:	dcc00317 	ldw	r19,12(sp)
 820d900:	dc800217 	ldw	r18,8(sp)
 820d904:	dc400117 	ldw	r17,4(sp)
 820d908:	dc000017 	ldw	r16,0(sp)
 820d90c:	dec00a04 	addi	sp,sp,40
 820d910:	820bc681 	jmpi	820bc68 <_malloc_r>
 820d914:	a8c00017 	ldw	r3,0(r21)
 820d918:	90c00015 	stw	r3,0(r18)
 820d91c:	a8c00117 	ldw	r3,4(r21)
 820d920:	90c00115 	stw	r3,4(r18)
 820d924:	00c006c4 	movi	r3,27
 820d928:	19804536 	bltu	r3,r6,820da40 <_realloc_r+0x470>
 820d92c:	90800204 	addi	r2,r18,8
 820d930:	a8c00204 	addi	r3,r21,8
 820d934:	003f6306 	br	820d6c4 <_realloc_r+0xf4>
 820d938:	9005883a 	mov	r2,r18
 820d93c:	a8c00017 	ldw	r3,0(r21)
 820d940:	b821883a 	mov	r16,r23
 820d944:	b027883a 	mov	r19,r22
 820d948:	10c00015 	stw	r3,0(r2)
 820d94c:	a8c00117 	ldw	r3,4(r21)
 820d950:	10c00115 	stw	r3,4(r2)
 820d954:	a8c00217 	ldw	r3,8(r21)
 820d958:	10c00215 	stw	r3,8(r2)
 820d95c:	003f6a06 	br	820d708 <_realloc_r+0x138>
 820d960:	9c67883a 	add	r19,r19,r17
 820d964:	4445c83a 	sub	r2,r8,r17
 820d968:	e4c00215 	stw	r19,8(fp)
 820d96c:	10800054 	ori	r2,r2,1
 820d970:	98800115 	stw	r2,4(r19)
 820d974:	a8bfff17 	ldw	r2,-4(r21)
 820d978:	a009883a 	mov	r4,r20
 820d97c:	1080004c 	andi	r2,r2,1
 820d980:	1462b03a 	or	r17,r2,r17
 820d984:	ac7fff15 	stw	r17,-4(r21)
 820d988:	8214a940 	call	8214a94 <__malloc_unlock>
 820d98c:	a805883a 	mov	r2,r21
 820d990:	003f6b06 	br	820d740 <_realloc_r+0x170>
 820d994:	a80b883a 	mov	r5,r21
 820d998:	9009883a 	mov	r4,r18
 820d99c:	8202fd40 	call	8202fd4 <memmove>
 820d9a0:	003f4e06 	br	820d6dc <_realloc_r+0x10c>
 820d9a4:	89000404 	addi	r4,r17,16
 820d9a8:	b93fbc16 	blt	r23,r4,820d89c <_realloc_r+0x2cc>
 820d9ac:	b0800317 	ldw	r2,12(r22)
 820d9b0:	b0c00217 	ldw	r3,8(r22)
 820d9b4:	81bfff04 	addi	r6,r16,-4
 820d9b8:	01000904 	movi	r4,36
 820d9bc:	18800315 	stw	r2,12(r3)
 820d9c0:	10c00215 	stw	r3,8(r2)
 820d9c4:	b4800204 	addi	r18,r22,8
 820d9c8:	21804336 	bltu	r4,r6,820dad8 <_realloc_r+0x508>
 820d9cc:	008004c4 	movi	r2,19
 820d9d0:	11803f2e 	bgeu	r2,r6,820dad0 <_realloc_r+0x500>
 820d9d4:	a8800017 	ldw	r2,0(r21)
 820d9d8:	b0800215 	stw	r2,8(r22)
 820d9dc:	a8800117 	ldw	r2,4(r21)
 820d9e0:	b0800315 	stw	r2,12(r22)
 820d9e4:	008006c4 	movi	r2,27
 820d9e8:	11803f36 	bltu	r2,r6,820dae8 <_realloc_r+0x518>
 820d9ec:	b0800404 	addi	r2,r22,16
 820d9f0:	ad400204 	addi	r21,r21,8
 820d9f4:	a8c00017 	ldw	r3,0(r21)
 820d9f8:	10c00015 	stw	r3,0(r2)
 820d9fc:	a8c00117 	ldw	r3,4(r21)
 820da00:	10c00115 	stw	r3,4(r2)
 820da04:	a8c00217 	ldw	r3,8(r21)
 820da08:	10c00215 	stw	r3,8(r2)
 820da0c:	b447883a 	add	r3,r22,r17
 820da10:	bc45c83a 	sub	r2,r23,r17
 820da14:	e0c00215 	stw	r3,8(fp)
 820da18:	10800054 	ori	r2,r2,1
 820da1c:	18800115 	stw	r2,4(r3)
 820da20:	b0800117 	ldw	r2,4(r22)
 820da24:	a009883a 	mov	r4,r20
 820da28:	1080004c 	andi	r2,r2,1
 820da2c:	1462b03a 	or	r17,r2,r17
 820da30:	b4400115 	stw	r17,4(r22)
 820da34:	8214a940 	call	8214a94 <__malloc_unlock>
 820da38:	9005883a 	mov	r2,r18
 820da3c:	003f4006 	br	820d740 <_realloc_r+0x170>
 820da40:	a8c00217 	ldw	r3,8(r21)
 820da44:	90c00215 	stw	r3,8(r18)
 820da48:	a8c00317 	ldw	r3,12(r21)
 820da4c:	90c00315 	stw	r3,12(r18)
 820da50:	30801126 	beq	r6,r2,820da98 <_realloc_r+0x4c8>
 820da54:	90800404 	addi	r2,r18,16
 820da58:	a8c00404 	addi	r3,r21,16
 820da5c:	003f1906 	br	820d6c4 <_realloc_r+0xf4>
 820da60:	90ffff17 	ldw	r3,-4(r18)
 820da64:	00bfff04 	movi	r2,-4
 820da68:	a825883a 	mov	r18,r21
 820da6c:	1884703a 	and	r2,r3,r2
 820da70:	80a1883a 	add	r16,r16,r2
 820da74:	003f2406 	br	820d708 <_realloc_r+0x138>
 820da78:	a8800217 	ldw	r2,8(r21)
 820da7c:	b0800415 	stw	r2,16(r22)
 820da80:	a8800317 	ldw	r2,12(r21)
 820da84:	b0800515 	stw	r2,20(r22)
 820da88:	31000a26 	beq	r6,r4,820dab4 <_realloc_r+0x4e4>
 820da8c:	b0800604 	addi	r2,r22,24
 820da90:	ad400404 	addi	r21,r21,16
 820da94:	003fa906 	br	820d93c <_realloc_r+0x36c>
 820da98:	a9000417 	ldw	r4,16(r21)
 820da9c:	90800604 	addi	r2,r18,24
 820daa0:	a8c00604 	addi	r3,r21,24
 820daa4:	91000415 	stw	r4,16(r18)
 820daa8:	a9000517 	ldw	r4,20(r21)
 820daac:	91000515 	stw	r4,20(r18)
 820dab0:	003f0406 	br	820d6c4 <_realloc_r+0xf4>
 820dab4:	a8c00417 	ldw	r3,16(r21)
 820dab8:	ad400604 	addi	r21,r21,24
 820dabc:	b0800804 	addi	r2,r22,32
 820dac0:	b0c00615 	stw	r3,24(r22)
 820dac4:	a8ffff17 	ldw	r3,-4(r21)
 820dac8:	b0c00715 	stw	r3,28(r22)
 820dacc:	003f9b06 	br	820d93c <_realloc_r+0x36c>
 820dad0:	9005883a 	mov	r2,r18
 820dad4:	003fc706 	br	820d9f4 <_realloc_r+0x424>
 820dad8:	a80b883a 	mov	r5,r21
 820dadc:	9009883a 	mov	r4,r18
 820dae0:	8202fd40 	call	8202fd4 <memmove>
 820dae4:	003fc906 	br	820da0c <_realloc_r+0x43c>
 820dae8:	a8800217 	ldw	r2,8(r21)
 820daec:	b0800415 	stw	r2,16(r22)
 820daf0:	a8800317 	ldw	r2,12(r21)
 820daf4:	b0800515 	stw	r2,20(r22)
 820daf8:	31000726 	beq	r6,r4,820db18 <_realloc_r+0x548>
 820dafc:	b0800604 	addi	r2,r22,24
 820db00:	ad400404 	addi	r21,r21,16
 820db04:	003fbb06 	br	820d9f4 <_realloc_r+0x424>
 820db08:	a009883a 	mov	r4,r20
 820db0c:	8214a940 	call	8214a94 <__malloc_unlock>
 820db10:	0005883a 	mov	r2,zero
 820db14:	003f0a06 	br	820d740 <_realloc_r+0x170>
 820db18:	a8c00417 	ldw	r3,16(r21)
 820db1c:	ad400604 	addi	r21,r21,24
 820db20:	b0800804 	addi	r2,r22,32
 820db24:	b0c00615 	stw	r3,24(r22)
 820db28:	a8ffff17 	ldw	r3,-4(r21)
 820db2c:	b0c00715 	stw	r3,28(r22)
 820db30:	003fb006 	br	820d9f4 <_realloc_r+0x424>

0820db34 <lflush>:
 820db34:	2080030b 	ldhu	r2,12(r4)
 820db38:	00c00244 	movi	r3,9
 820db3c:	1080024c 	andi	r2,r2,9
 820db40:	10c00226 	beq	r2,r3,820db4c <lflush+0x18>
 820db44:	0005883a 	mov	r2,zero
 820db48:	f800283a 	ret
 820db4c:	820aa341 	jmpi	820aa34 <fflush>

0820db50 <__srefill_r>:
 820db50:	defffc04 	addi	sp,sp,-16
 820db54:	dc400115 	stw	r17,4(sp)
 820db58:	dc000015 	stw	r16,0(sp)
 820db5c:	dfc00315 	stw	ra,12(sp)
 820db60:	dc800215 	stw	r18,8(sp)
 820db64:	2023883a 	mov	r17,r4
 820db68:	2821883a 	mov	r16,r5
 820db6c:	20000226 	beq	r4,zero,820db78 <__srefill_r+0x28>
 820db70:	20800e17 	ldw	r2,56(r4)
 820db74:	10003c26 	beq	r2,zero,820dc68 <__srefill_r+0x118>
 820db78:	80c0030b 	ldhu	r3,12(r16)
 820db7c:	1908000c 	andi	r4,r3,8192
 820db80:	1805883a 	mov	r2,r3
 820db84:	2000071e 	bne	r4,zero,820dba4 <__srefill_r+0x54>
 820db88:	81001917 	ldw	r4,100(r16)
 820db8c:	18880014 	ori	r2,r3,8192
 820db90:	00f7ffc4 	movi	r3,-8193
 820db94:	20c8703a 	and	r4,r4,r3
 820db98:	8080030d 	sth	r2,12(r16)
 820db9c:	1007883a 	mov	r3,r2
 820dba0:	81001915 	stw	r4,100(r16)
 820dba4:	80000115 	stw	zero,4(r16)
 820dba8:	1100080c 	andi	r4,r2,32
 820dbac:	2000571e 	bne	r4,zero,820dd0c <__srefill_r+0x1bc>
 820dbb0:	1100010c 	andi	r4,r2,4
 820dbb4:	20001f26 	beq	r4,zero,820dc34 <__srefill_r+0xe4>
 820dbb8:	81400c17 	ldw	r5,48(r16)
 820dbbc:	28000826 	beq	r5,zero,820dbe0 <__srefill_r+0x90>
 820dbc0:	80801004 	addi	r2,r16,64
 820dbc4:	28800226 	beq	r5,r2,820dbd0 <__srefill_r+0x80>
 820dbc8:	8809883a 	mov	r4,r17
 820dbcc:	820b07c0 	call	820b07c <_free_r>
 820dbd0:	80800f17 	ldw	r2,60(r16)
 820dbd4:	80000c15 	stw	zero,48(r16)
 820dbd8:	80800115 	stw	r2,4(r16)
 820dbdc:	1000391e 	bne	r2,zero,820dcc4 <__srefill_r+0x174>
 820dbe0:	80800417 	ldw	r2,16(r16)
 820dbe4:	10004b26 	beq	r2,zero,820dd14 <__srefill_r+0x1c4>
 820dbe8:	8480030b 	ldhu	r18,12(r16)
 820dbec:	908000cc 	andi	r2,r18,3
 820dbf0:	10001f1e 	bne	r2,zero,820dc70 <__srefill_r+0x120>
 820dbf4:	81800417 	ldw	r6,16(r16)
 820dbf8:	80800817 	ldw	r2,32(r16)
 820dbfc:	81c00517 	ldw	r7,20(r16)
 820dc00:	81400717 	ldw	r5,28(r16)
 820dc04:	81800015 	stw	r6,0(r16)
 820dc08:	8809883a 	mov	r4,r17
 820dc0c:	103ee83a 	callr	r2
 820dc10:	80800115 	stw	r2,4(r16)
 820dc14:	00800e0e 	bge	zero,r2,820dc50 <__srefill_r+0x100>
 820dc18:	0005883a 	mov	r2,zero
 820dc1c:	dfc00317 	ldw	ra,12(sp)
 820dc20:	dc800217 	ldw	r18,8(sp)
 820dc24:	dc400117 	ldw	r17,4(sp)
 820dc28:	dc000017 	ldw	r16,0(sp)
 820dc2c:	dec00404 	addi	sp,sp,16
 820dc30:	f800283a 	ret
 820dc34:	1100040c 	andi	r4,r2,16
 820dc38:	20003026 	beq	r4,zero,820dcfc <__srefill_r+0x1ac>
 820dc3c:	1080020c 	andi	r2,r2,8
 820dc40:	1000241e 	bne	r2,zero,820dcd4 <__srefill_r+0x184>
 820dc44:	18c00114 	ori	r3,r3,4
 820dc48:	80c0030d 	sth	r3,12(r16)
 820dc4c:	003fe406 	br	820dbe0 <__srefill_r+0x90>
 820dc50:	80c0030b 	ldhu	r3,12(r16)
 820dc54:	1000161e 	bne	r2,zero,820dcb0 <__srefill_r+0x160>
 820dc58:	18c00814 	ori	r3,r3,32
 820dc5c:	00bfffc4 	movi	r2,-1
 820dc60:	80c0030d 	sth	r3,12(r16)
 820dc64:	003fed06 	br	820dc1c <__srefill_r+0xcc>
 820dc68:	820adb40 	call	820adb4 <__sinit>
 820dc6c:	003fc206 	br	820db78 <__srefill_r+0x28>
 820dc70:	00820974 	movhi	r2,2085
 820dc74:	108fa104 	addi	r2,r2,16004
 820dc78:	11000017 	ldw	r4,0(r2)
 820dc7c:	01420874 	movhi	r5,2081
 820dc80:	00800044 	movi	r2,1
 820dc84:	2976cd04 	addi	r5,r5,-9420
 820dc88:	8080030d 	sth	r2,12(r16)
 820dc8c:	820b8480 	call	820b848 <_fwalk>
 820dc90:	00800244 	movi	r2,9
 820dc94:	8480030d 	sth	r18,12(r16)
 820dc98:	9480024c 	andi	r18,r18,9
 820dc9c:	90bfd51e 	bne	r18,r2,820dbf4 <__srefill_r+0xa4>
 820dca0:	800b883a 	mov	r5,r16
 820dca4:	8809883a 	mov	r4,r17
 820dca8:	820a7bc0 	call	820a7bc <__sflush_r>
 820dcac:	003fd106 	br	820dbf4 <__srefill_r+0xa4>
 820dcb0:	18c01014 	ori	r3,r3,64
 820dcb4:	80000115 	stw	zero,4(r16)
 820dcb8:	00bfffc4 	movi	r2,-1
 820dcbc:	80c0030d 	sth	r3,12(r16)
 820dcc0:	003fd606 	br	820dc1c <__srefill_r+0xcc>
 820dcc4:	80c00e17 	ldw	r3,56(r16)
 820dcc8:	0005883a 	mov	r2,zero
 820dccc:	80c00015 	stw	r3,0(r16)
 820dcd0:	003fd206 	br	820dc1c <__srefill_r+0xcc>
 820dcd4:	800b883a 	mov	r5,r16
 820dcd8:	8809883a 	mov	r4,r17
 820dcdc:	820a9d80 	call	820a9d8 <_fflush_r>
 820dce0:	10000a1e 	bne	r2,zero,820dd0c <__srefill_r+0x1bc>
 820dce4:	8080030b 	ldhu	r2,12(r16)
 820dce8:	00fffdc4 	movi	r3,-9
 820dcec:	80000215 	stw	zero,8(r16)
 820dcf0:	1886703a 	and	r3,r3,r2
 820dcf4:	80000615 	stw	zero,24(r16)
 820dcf8:	003fd206 	br	820dc44 <__srefill_r+0xf4>
 820dcfc:	00800244 	movi	r2,9
 820dd00:	88800015 	stw	r2,0(r17)
 820dd04:	18c01014 	ori	r3,r3,64
 820dd08:	80c0030d 	sth	r3,12(r16)
 820dd0c:	00bfffc4 	movi	r2,-1
 820dd10:	003fc206 	br	820dc1c <__srefill_r+0xcc>
 820dd14:	800b883a 	mov	r5,r16
 820dd18:	8809883a 	mov	r4,r17
 820dd1c:	820baac0 	call	820baac <__smakebuf_r>
 820dd20:	003fb106 	br	820dbe8 <__srefill_r+0x98>

0820dd24 <__fpclassifyd>:
 820dd24:	00a00034 	movhi	r2,32768
 820dd28:	10bfffc4 	addi	r2,r2,-1
 820dd2c:	2884703a 	and	r2,r5,r2
 820dd30:	10000726 	beq	r2,zero,820dd50 <__fpclassifyd+0x2c>
 820dd34:	00fffc34 	movhi	r3,65520
 820dd38:	019ff834 	movhi	r6,32736
 820dd3c:	28c7883a 	add	r3,r5,r3
 820dd40:	31bfffc4 	addi	r6,r6,-1
 820dd44:	30c00536 	bltu	r6,r3,820dd5c <__fpclassifyd+0x38>
 820dd48:	00800104 	movi	r2,4
 820dd4c:	f800283a 	ret
 820dd50:	2000021e 	bne	r4,zero,820dd5c <__fpclassifyd+0x38>
 820dd54:	00800084 	movi	r2,2
 820dd58:	f800283a 	ret
 820dd5c:	00dffc34 	movhi	r3,32752
 820dd60:	019ff834 	movhi	r6,32736
 820dd64:	28cb883a 	add	r5,r5,r3
 820dd68:	31bfffc4 	addi	r6,r6,-1
 820dd6c:	317ff62e 	bgeu	r6,r5,820dd48 <__fpclassifyd+0x24>
 820dd70:	01400434 	movhi	r5,16
 820dd74:	297fffc4 	addi	r5,r5,-1
 820dd78:	28800236 	bltu	r5,r2,820dd84 <__fpclassifyd+0x60>
 820dd7c:	008000c4 	movi	r2,3
 820dd80:	f800283a 	ret
 820dd84:	10c00226 	beq	r2,r3,820dd90 <__fpclassifyd+0x6c>
 820dd88:	0005883a 	mov	r2,zero
 820dd8c:	f800283a 	ret
 820dd90:	2005003a 	cmpeq	r2,r4,zero
 820dd94:	f800283a 	ret

0820dd98 <_sbrk_r>:
 820dd98:	defffd04 	addi	sp,sp,-12
 820dd9c:	dc000015 	stw	r16,0(sp)
 820dda0:	04020974 	movhi	r16,2085
 820dda4:	dc400115 	stw	r17,4(sp)
 820dda8:	84100304 	addi	r16,r16,16396
 820ddac:	2023883a 	mov	r17,r4
 820ddb0:	2809883a 	mov	r4,r5
 820ddb4:	dfc00215 	stw	ra,8(sp)
 820ddb8:	80000015 	stw	zero,0(r16)
 820ddbc:	82147a00 	call	82147a0 <sbrk>
 820ddc0:	00ffffc4 	movi	r3,-1
 820ddc4:	10c00526 	beq	r2,r3,820dddc <_sbrk_r+0x44>
 820ddc8:	dfc00217 	ldw	ra,8(sp)
 820ddcc:	dc400117 	ldw	r17,4(sp)
 820ddd0:	dc000017 	ldw	r16,0(sp)
 820ddd4:	dec00304 	addi	sp,sp,12
 820ddd8:	f800283a 	ret
 820dddc:	80c00017 	ldw	r3,0(r16)
 820dde0:	183ff926 	beq	r3,zero,820ddc8 <_sbrk_r+0x30>
 820dde4:	88c00015 	stw	r3,0(r17)
 820dde8:	003ff706 	br	820ddc8 <_sbrk_r+0x30>

0820ddec <__sread>:
 820ddec:	defffe04 	addi	sp,sp,-8
 820ddf0:	dc000015 	stw	r16,0(sp)
 820ddf4:	2821883a 	mov	r16,r5
 820ddf8:	2940038f 	ldh	r5,14(r5)
 820ddfc:	dfc00115 	stw	ra,4(sp)
 820de00:	8210fec0 	call	8210fec <_read_r>
 820de04:	10000716 	blt	r2,zero,820de24 <__sread+0x38>
 820de08:	80c01417 	ldw	r3,80(r16)
 820de0c:	1887883a 	add	r3,r3,r2
 820de10:	80c01415 	stw	r3,80(r16)
 820de14:	dfc00117 	ldw	ra,4(sp)
 820de18:	dc000017 	ldw	r16,0(sp)
 820de1c:	dec00204 	addi	sp,sp,8
 820de20:	f800283a 	ret
 820de24:	80c0030b 	ldhu	r3,12(r16)
 820de28:	18fbffcc 	andi	r3,r3,61439
 820de2c:	80c0030d 	sth	r3,12(r16)
 820de30:	dfc00117 	ldw	ra,4(sp)
 820de34:	dc000017 	ldw	r16,0(sp)
 820de38:	dec00204 	addi	sp,sp,8
 820de3c:	f800283a 	ret

0820de40 <__seofread>:
 820de40:	0005883a 	mov	r2,zero
 820de44:	f800283a 	ret

0820de48 <__swrite>:
 820de48:	2880030b 	ldhu	r2,12(r5)
 820de4c:	defffb04 	addi	sp,sp,-20
 820de50:	dcc00315 	stw	r19,12(sp)
 820de54:	dc800215 	stw	r18,8(sp)
 820de58:	dc400115 	stw	r17,4(sp)
 820de5c:	dc000015 	stw	r16,0(sp)
 820de60:	dfc00415 	stw	ra,16(sp)
 820de64:	10c0400c 	andi	r3,r2,256
 820de68:	2821883a 	mov	r16,r5
 820de6c:	2023883a 	mov	r17,r4
 820de70:	3025883a 	mov	r18,r6
 820de74:	3827883a 	mov	r19,r7
 820de78:	18000526 	beq	r3,zero,820de90 <__swrite+0x48>
 820de7c:	2940038f 	ldh	r5,14(r5)
 820de80:	01c00084 	movi	r7,2
 820de84:	000d883a 	mov	r6,zero
 820de88:	8210f8c0 	call	8210f8c <_lseek_r>
 820de8c:	8080030b 	ldhu	r2,12(r16)
 820de90:	8140038f 	ldh	r5,14(r16)
 820de94:	10bbffcc 	andi	r2,r2,61439
 820de98:	980f883a 	mov	r7,r19
 820de9c:	900d883a 	mov	r6,r18
 820dea0:	8809883a 	mov	r4,r17
 820dea4:	8080030d 	sth	r2,12(r16)
 820dea8:	dfc00417 	ldw	ra,16(sp)
 820deac:	dcc00317 	ldw	r19,12(sp)
 820deb0:	dc800217 	ldw	r18,8(sp)
 820deb4:	dc400117 	ldw	r17,4(sp)
 820deb8:	dc000017 	ldw	r16,0(sp)
 820debc:	dec00504 	addi	sp,sp,20
 820dec0:	8210a581 	jmpi	8210a58 <_write_r>

0820dec4 <__sseek>:
 820dec4:	defffe04 	addi	sp,sp,-8
 820dec8:	dc000015 	stw	r16,0(sp)
 820decc:	2821883a 	mov	r16,r5
 820ded0:	2940038f 	ldh	r5,14(r5)
 820ded4:	dfc00115 	stw	ra,4(sp)
 820ded8:	8210f8c0 	call	8210f8c <_lseek_r>
 820dedc:	00ffffc4 	movi	r3,-1
 820dee0:	10c00826 	beq	r2,r3,820df04 <__sseek+0x40>
 820dee4:	80c0030b 	ldhu	r3,12(r16)
 820dee8:	80801415 	stw	r2,80(r16)
 820deec:	18c40014 	ori	r3,r3,4096
 820def0:	80c0030d 	sth	r3,12(r16)
 820def4:	dfc00117 	ldw	ra,4(sp)
 820def8:	dc000017 	ldw	r16,0(sp)
 820defc:	dec00204 	addi	sp,sp,8
 820df00:	f800283a 	ret
 820df04:	80c0030b 	ldhu	r3,12(r16)
 820df08:	18fbffcc 	andi	r3,r3,61439
 820df0c:	80c0030d 	sth	r3,12(r16)
 820df10:	dfc00117 	ldw	ra,4(sp)
 820df14:	dc000017 	ldw	r16,0(sp)
 820df18:	dec00204 	addi	sp,sp,8
 820df1c:	f800283a 	ret

0820df20 <__sclose>:
 820df20:	2940038f 	ldh	r5,14(r5)
 820df24:	8210ab81 	jmpi	8210ab8 <_close_r>

0820df28 <strcmp>:
 820df28:	2144b03a 	or	r2,r4,r5
 820df2c:	108000cc 	andi	r2,r2,3
 820df30:	1000171e 	bne	r2,zero,820df90 <strcmp+0x68>
 820df34:	20800017 	ldw	r2,0(r4)
 820df38:	28c00017 	ldw	r3,0(r5)
 820df3c:	10c0141e 	bne	r2,r3,820df90 <strcmp+0x68>
 820df40:	027fbff4 	movhi	r9,65279
 820df44:	4a7fbfc4 	addi	r9,r9,-257
 820df48:	0086303a 	nor	r3,zero,r2
 820df4c:	02202074 	movhi	r8,32897
 820df50:	1245883a 	add	r2,r2,r9
 820df54:	42202004 	addi	r8,r8,-32640
 820df58:	10c4703a 	and	r2,r2,r3
 820df5c:	1204703a 	and	r2,r2,r8
 820df60:	10000226 	beq	r2,zero,820df6c <strcmp+0x44>
 820df64:	00002306 	br	820dff4 <strcmp+0xcc>
 820df68:	1000221e 	bne	r2,zero,820dff4 <strcmp+0xcc>
 820df6c:	21000104 	addi	r4,r4,4
 820df70:	20c00017 	ldw	r3,0(r4)
 820df74:	29400104 	addi	r5,r5,4
 820df78:	29800017 	ldw	r6,0(r5)
 820df7c:	1a4f883a 	add	r7,r3,r9
 820df80:	00c4303a 	nor	r2,zero,r3
 820df84:	3884703a 	and	r2,r7,r2
 820df88:	1204703a 	and	r2,r2,r8
 820df8c:	19bff626 	beq	r3,r6,820df68 <strcmp+0x40>
 820df90:	20800003 	ldbu	r2,0(r4)
 820df94:	10c03fcc 	andi	r3,r2,255
 820df98:	18c0201c 	xori	r3,r3,128
 820df9c:	18ffe004 	addi	r3,r3,-128
 820dfa0:	18000c26 	beq	r3,zero,820dfd4 <strcmp+0xac>
 820dfa4:	29800007 	ldb	r6,0(r5)
 820dfa8:	19800326 	beq	r3,r6,820dfb8 <strcmp+0x90>
 820dfac:	00001306 	br	820dffc <strcmp+0xd4>
 820dfb0:	29800007 	ldb	r6,0(r5)
 820dfb4:	11800b1e 	bne	r2,r6,820dfe4 <strcmp+0xbc>
 820dfb8:	21000044 	addi	r4,r4,1
 820dfbc:	20c00003 	ldbu	r3,0(r4)
 820dfc0:	29400044 	addi	r5,r5,1
 820dfc4:	18803fcc 	andi	r2,r3,255
 820dfc8:	1080201c 	xori	r2,r2,128
 820dfcc:	10bfe004 	addi	r2,r2,-128
 820dfd0:	103ff71e 	bne	r2,zero,820dfb0 <strcmp+0x88>
 820dfd4:	0007883a 	mov	r3,zero
 820dfd8:	28800003 	ldbu	r2,0(r5)
 820dfdc:	1885c83a 	sub	r2,r3,r2
 820dfe0:	f800283a 	ret
 820dfe4:	28800003 	ldbu	r2,0(r5)
 820dfe8:	18c03fcc 	andi	r3,r3,255
 820dfec:	1885c83a 	sub	r2,r3,r2
 820dff0:	f800283a 	ret
 820dff4:	0005883a 	mov	r2,zero
 820dff8:	f800283a 	ret
 820dffc:	10c03fcc 	andi	r3,r2,255
 820e000:	003ff506 	br	820dfd8 <strcmp+0xb0>

0820e004 <__ssprint_r>:
 820e004:	30800217 	ldw	r2,8(r6)
 820e008:	defff604 	addi	sp,sp,-40
 820e00c:	dc800215 	stw	r18,8(sp)
 820e010:	dfc00915 	stw	ra,36(sp)
 820e014:	df000815 	stw	fp,32(sp)
 820e018:	ddc00715 	stw	r23,28(sp)
 820e01c:	dd800615 	stw	r22,24(sp)
 820e020:	dd400515 	stw	r21,20(sp)
 820e024:	dd000415 	stw	r20,16(sp)
 820e028:	dcc00315 	stw	r19,12(sp)
 820e02c:	dc400115 	stw	r17,4(sp)
 820e030:	dc000015 	stw	r16,0(sp)
 820e034:	3025883a 	mov	r18,r6
 820e038:	10005826 	beq	r2,zero,820e19c <__ssprint_r+0x198>
 820e03c:	2027883a 	mov	r19,r4
 820e040:	35c00017 	ldw	r23,0(r6)
 820e044:	29000017 	ldw	r4,0(r5)
 820e048:	28800217 	ldw	r2,8(r5)
 820e04c:	2823883a 	mov	r17,r5
 820e050:	0039883a 	mov	fp,zero
 820e054:	0021883a 	mov	r16,zero
 820e058:	80003926 	beq	r16,zero,820e140 <__ssprint_r+0x13c>
 820e05c:	102b883a 	mov	r21,r2
 820e060:	102d883a 	mov	r22,r2
 820e064:	80803a36 	bltu	r16,r2,820e150 <__ssprint_r+0x14c>
 820e068:	88c0030b 	ldhu	r3,12(r17)
 820e06c:	1881200c 	andi	r2,r3,1152
 820e070:	10002626 	beq	r2,zero,820e10c <__ssprint_r+0x108>
 820e074:	88800517 	ldw	r2,20(r17)
 820e078:	89400417 	ldw	r5,16(r17)
 820e07c:	81800044 	addi	r6,r16,1
 820e080:	108f883a 	add	r7,r2,r2
 820e084:	3885883a 	add	r2,r7,r2
 820e088:	100ed7fa 	srli	r7,r2,31
 820e08c:	216dc83a 	sub	r22,r4,r5
 820e090:	3589883a 	add	r4,r6,r22
 820e094:	3885883a 	add	r2,r7,r2
 820e098:	102bd07a 	srai	r21,r2,1
 820e09c:	a80d883a 	mov	r6,r21
 820e0a0:	a900022e 	bgeu	r21,r4,820e0ac <__ssprint_r+0xa8>
 820e0a4:	202b883a 	mov	r21,r4
 820e0a8:	200d883a 	mov	r6,r4
 820e0ac:	18c1000c 	andi	r3,r3,1024
 820e0b0:	18002a26 	beq	r3,zero,820e15c <__ssprint_r+0x158>
 820e0b4:	300b883a 	mov	r5,r6
 820e0b8:	9809883a 	mov	r4,r19
 820e0bc:	820bc680 	call	820bc68 <_malloc_r>
 820e0c0:	1029883a 	mov	r20,r2
 820e0c4:	10002c26 	beq	r2,zero,820e178 <__ssprint_r+0x174>
 820e0c8:	89400417 	ldw	r5,16(r17)
 820e0cc:	b00d883a 	mov	r6,r22
 820e0d0:	1009883a 	mov	r4,r2
 820e0d4:	8202e8c0 	call	8202e8c <memcpy>
 820e0d8:	8880030b 	ldhu	r2,12(r17)
 820e0dc:	00fedfc4 	movi	r3,-1153
 820e0e0:	10c4703a 	and	r2,r2,r3
 820e0e4:	10802014 	ori	r2,r2,128
 820e0e8:	8880030d 	sth	r2,12(r17)
 820e0ec:	a589883a 	add	r4,r20,r22
 820e0f0:	adadc83a 	sub	r22,r21,r22
 820e0f4:	8d400515 	stw	r21,20(r17)
 820e0f8:	8d800215 	stw	r22,8(r17)
 820e0fc:	8d000415 	stw	r20,16(r17)
 820e100:	89000015 	stw	r4,0(r17)
 820e104:	802b883a 	mov	r21,r16
 820e108:	802d883a 	mov	r22,r16
 820e10c:	b00d883a 	mov	r6,r22
 820e110:	e00b883a 	mov	r5,fp
 820e114:	8202fd40 	call	8202fd4 <memmove>
 820e118:	88800217 	ldw	r2,8(r17)
 820e11c:	89000017 	ldw	r4,0(r17)
 820e120:	90c00217 	ldw	r3,8(r18)
 820e124:	1545c83a 	sub	r2,r2,r21
 820e128:	2589883a 	add	r4,r4,r22
 820e12c:	88800215 	stw	r2,8(r17)
 820e130:	89000015 	stw	r4,0(r17)
 820e134:	1c21c83a 	sub	r16,r3,r16
 820e138:	94000215 	stw	r16,8(r18)
 820e13c:	80001726 	beq	r16,zero,820e19c <__ssprint_r+0x198>
 820e140:	bf000017 	ldw	fp,0(r23)
 820e144:	bc000117 	ldw	r16,4(r23)
 820e148:	bdc00204 	addi	r23,r23,8
 820e14c:	003fc206 	br	820e058 <__ssprint_r+0x54>
 820e150:	802b883a 	mov	r21,r16
 820e154:	802d883a 	mov	r22,r16
 820e158:	003fec06 	br	820e10c <__ssprint_r+0x108>
 820e15c:	9809883a 	mov	r4,r19
 820e160:	820d5d00 	call	820d5d0 <_realloc_r>
 820e164:	1029883a 	mov	r20,r2
 820e168:	103fe01e 	bne	r2,zero,820e0ec <__ssprint_r+0xe8>
 820e16c:	89400417 	ldw	r5,16(r17)
 820e170:	9809883a 	mov	r4,r19
 820e174:	820b07c0 	call	820b07c <_free_r>
 820e178:	88c0030b 	ldhu	r3,12(r17)
 820e17c:	00800304 	movi	r2,12
 820e180:	98800015 	stw	r2,0(r19)
 820e184:	18c01014 	ori	r3,r3,64
 820e188:	88c0030d 	sth	r3,12(r17)
 820e18c:	00bfffc4 	movi	r2,-1
 820e190:	90000215 	stw	zero,8(r18)
 820e194:	90000115 	stw	zero,4(r18)
 820e198:	00000206 	br	820e1a4 <__ssprint_r+0x1a0>
 820e19c:	90000115 	stw	zero,4(r18)
 820e1a0:	0005883a 	mov	r2,zero
 820e1a4:	dfc00917 	ldw	ra,36(sp)
 820e1a8:	df000817 	ldw	fp,32(sp)
 820e1ac:	ddc00717 	ldw	r23,28(sp)
 820e1b0:	dd800617 	ldw	r22,24(sp)
 820e1b4:	dd400517 	ldw	r21,20(sp)
 820e1b8:	dd000417 	ldw	r20,16(sp)
 820e1bc:	dcc00317 	ldw	r19,12(sp)
 820e1c0:	dc800217 	ldw	r18,8(sp)
 820e1c4:	dc400117 	ldw	r17,4(sp)
 820e1c8:	dc000017 	ldw	r16,0(sp)
 820e1cc:	dec00a04 	addi	sp,sp,40
 820e1d0:	f800283a 	ret

0820e1d4 <___svfiprintf_internal_r>:
 820e1d4:	2880030b 	ldhu	r2,12(r5)
 820e1d8:	deffc804 	addi	sp,sp,-224
 820e1dc:	dcc03115 	stw	r19,196(sp)
 820e1e0:	dfc03715 	stw	ra,220(sp)
 820e1e4:	df003615 	stw	fp,216(sp)
 820e1e8:	ddc03515 	stw	r23,212(sp)
 820e1ec:	dd803415 	stw	r22,208(sp)
 820e1f0:	dd403315 	stw	r21,204(sp)
 820e1f4:	dd003215 	stw	r20,200(sp)
 820e1f8:	dc803015 	stw	r18,192(sp)
 820e1fc:	dc402f15 	stw	r17,188(sp)
 820e200:	dc002e15 	stw	r16,184(sp)
 820e204:	d9402715 	stw	r5,156(sp)
 820e208:	d9002a15 	stw	r4,168(sp)
 820e20c:	1080200c 	andi	r2,r2,128
 820e210:	d9c02315 	stw	r7,140(sp)
 820e214:	3027883a 	mov	r19,r6
 820e218:	10000226 	beq	r2,zero,820e224 <___svfiprintf_internal_r+0x50>
 820e21c:	28800417 	ldw	r2,16(r5)
 820e220:	10041d26 	beq	r2,zero,820f298 <___svfiprintf_internal_r+0x10c4>
 820e224:	dac01a04 	addi	r11,sp,104
 820e228:	dac01e15 	stw	r11,120(sp)
 820e22c:	d8801e17 	ldw	r2,120(sp)
 820e230:	dac019c4 	addi	r11,sp,103
 820e234:	dd402a17 	ldw	r21,168(sp)
 820e238:	ddc02717 	ldw	r23,156(sp)
 820e23c:	05820974 	movhi	r22,2085
 820e240:	05020974 	movhi	r20,2085
 820e244:	dac01f15 	stw	r11,124(sp)
 820e248:	12d7c83a 	sub	r11,r2,r11
 820e24c:	b5b73804 	addi	r22,r22,-8992
 820e250:	a5373404 	addi	r20,r20,-9008
 820e254:	dec01a15 	stw	sp,104(sp)
 820e258:	d8001c15 	stw	zero,112(sp)
 820e25c:	d8001b15 	stw	zero,108(sp)
 820e260:	d811883a 	mov	r8,sp
 820e264:	d8002915 	stw	zero,164(sp)
 820e268:	d8002515 	stw	zero,148(sp)
 820e26c:	dac02b15 	stw	r11,172(sp)
 820e270:	98800007 	ldb	r2,0(r19)
 820e274:	1002dd26 	beq	r2,zero,820edec <___svfiprintf_internal_r+0xc18>
 820e278:	00c00944 	movi	r3,37
 820e27c:	9823883a 	mov	r17,r19
 820e280:	10c0021e 	bne	r2,r3,820e28c <___svfiprintf_internal_r+0xb8>
 820e284:	00001406 	br	820e2d8 <___svfiprintf_internal_r+0x104>
 820e288:	10c00326 	beq	r2,r3,820e298 <___svfiprintf_internal_r+0xc4>
 820e28c:	8c400044 	addi	r17,r17,1
 820e290:	88800007 	ldb	r2,0(r17)
 820e294:	103ffc1e 	bne	r2,zero,820e288 <___svfiprintf_internal_r+0xb4>
 820e298:	8ce1c83a 	sub	r16,r17,r19
 820e29c:	80000e26 	beq	r16,zero,820e2d8 <___svfiprintf_internal_r+0x104>
 820e2a0:	d8c01c17 	ldw	r3,112(sp)
 820e2a4:	d8801b17 	ldw	r2,108(sp)
 820e2a8:	44c00015 	stw	r19,0(r8)
 820e2ac:	1c07883a 	add	r3,r3,r16
 820e2b0:	10800044 	addi	r2,r2,1
 820e2b4:	d8c01c15 	stw	r3,112(sp)
 820e2b8:	44000115 	stw	r16,4(r8)
 820e2bc:	d8801b15 	stw	r2,108(sp)
 820e2c0:	00c001c4 	movi	r3,7
 820e2c4:	18831e16 	blt	r3,r2,820ef40 <___svfiprintf_internal_r+0xd6c>
 820e2c8:	42000204 	addi	r8,r8,8
 820e2cc:	dac02517 	ldw	r11,148(sp)
 820e2d0:	5c17883a 	add	r11,r11,r16
 820e2d4:	dac02515 	stw	r11,148(sp)
 820e2d8:	88800007 	ldb	r2,0(r17)
 820e2dc:	1002c526 	beq	r2,zero,820edf4 <___svfiprintf_internal_r+0xc20>
 820e2e0:	88c00047 	ldb	r3,1(r17)
 820e2e4:	8cc00044 	addi	r19,r17,1
 820e2e8:	d8001d85 	stb	zero,118(sp)
 820e2ec:	0009883a 	mov	r4,zero
 820e2f0:	000f883a 	mov	r7,zero
 820e2f4:	043fffc4 	movi	r16,-1
 820e2f8:	d8002415 	stw	zero,144(sp)
 820e2fc:	0025883a 	mov	r18,zero
 820e300:	01401604 	movi	r5,88
 820e304:	01800244 	movi	r6,9
 820e308:	02800a84 	movi	r10,42
 820e30c:	02401b04 	movi	r9,108
 820e310:	9cc00044 	addi	r19,r19,1
 820e314:	18bff804 	addi	r2,r3,-32
 820e318:	2881dd36 	bltu	r5,r2,820ea90 <___svfiprintf_internal_r+0x8bc>
 820e31c:	100490ba 	slli	r2,r2,2
 820e320:	02c20874 	movhi	r11,2081
 820e324:	5af8cd04 	addi	r11,r11,-7372
 820e328:	12c5883a 	add	r2,r2,r11
 820e32c:	10800017 	ldw	r2,0(r2)
 820e330:	1000683a 	jmp	r2
 820e334:	0820e530 	cmpltui	zero,at,33684
 820e338:	0820ea90 	cmplti	zero,at,-31830
 820e33c:	0820ea90 	cmplti	zero,at,-31830
 820e340:	0820e524 	muli	zero,at,-31852
 820e344:	0820ea90 	cmplti	zero,at,-31830
 820e348:	0820ea90 	cmplti	zero,at,-31830
 820e34c:	0820ea90 	cmplti	zero,at,-31830
 820e350:	0820ea90 	cmplti	zero,at,-31830
 820e354:	0820ea90 	cmplti	zero,at,-31830
 820e358:	0820ea90 	cmplti	zero,at,-31830
 820e35c:	0820e498 	cmpnei	zero,at,-31854
 820e360:	0820e674 	orhi	zero,at,33689
 820e364:	0820ea90 	cmplti	zero,at,-31830
 820e368:	0820e4c4 	addi	zero,at,-31853
 820e36c:	0820eac4 	addi	zero,at,-31829
 820e370:	0820ea90 	cmplti	zero,at,-31830
 820e374:	0820eab8 	rdprs	zero,at,-31830
 820e378:	0820ea58 	cmpnei	zero,at,-31831
 820e37c:	0820ea58 	cmpnei	zero,at,-31831
 820e380:	0820ea58 	cmpnei	zero,at,-31831
 820e384:	0820ea58 	cmpnei	zero,at,-31831
 820e388:	0820ea58 	cmpnei	zero,at,-31831
 820e38c:	0820ea58 	cmpnei	zero,at,-31831
 820e390:	0820ea58 	cmpnei	zero,at,-31831
 820e394:	0820ea58 	cmpnei	zero,at,-31831
 820e398:	0820ea58 	cmpnei	zero,at,-31831
 820e39c:	0820ea90 	cmplti	zero,at,-31830
 820e3a0:	0820ea90 	cmplti	zero,at,-31830
 820e3a4:	0820ea90 	cmplti	zero,at,-31830
 820e3a8:	0820ea90 	cmplti	zero,at,-31830
 820e3ac:	0820ea90 	cmplti	zero,at,-31830
 820e3b0:	0820ea90 	cmplti	zero,at,-31830
 820e3b4:	0820ea90 	cmplti	zero,at,-31830
 820e3b8:	0820ea90 	cmplti	zero,at,-31830
 820e3bc:	0820ea90 	cmplti	zero,at,-31830
 820e3c0:	0820ea90 	cmplti	zero,at,-31830
 820e3c4:	0820e9f4 	orhi	zero,at,33703
 820e3c8:	0820ea90 	cmplti	zero,at,-31830
 820e3cc:	0820ea90 	cmplti	zero,at,-31830
 820e3d0:	0820ea90 	cmplti	zero,at,-31830
 820e3d4:	0820ea90 	cmplti	zero,at,-31830
 820e3d8:	0820ea90 	cmplti	zero,at,-31830
 820e3dc:	0820ea90 	cmplti	zero,at,-31830
 820e3e0:	0820ea90 	cmplti	zero,at,-31830
 820e3e4:	0820ea90 	cmplti	zero,at,-31830
 820e3e8:	0820ea90 	cmplti	zero,at,-31830
 820e3ec:	0820ea90 	cmplti	zero,at,-31830
 820e3f0:	0820eb6c 	andhi	zero,at,33709
 820e3f4:	0820ea90 	cmplti	zero,at,-31830
 820e3f8:	0820ea90 	cmplti	zero,at,-31830
 820e3fc:	0820ea90 	cmplti	zero,at,-31830
 820e400:	0820ea90 	cmplti	zero,at,-31830
 820e404:	0820ea90 	cmplti	zero,at,-31830
 820e408:	0820eb04 	addi	zero,at,-31828
 820e40c:	0820ea90 	cmplti	zero,at,-31830
 820e410:	0820ea90 	cmplti	zero,at,-31830
 820e414:	0820e838 	rdprs	zero,at,-31840
 820e418:	0820ea90 	cmplti	zero,at,-31830
 820e41c:	0820ea90 	cmplti	zero,at,-31830
 820e420:	0820ea90 	cmplti	zero,at,-31830
 820e424:	0820ea90 	cmplti	zero,at,-31830
 820e428:	0820ea90 	cmplti	zero,at,-31830
 820e42c:	0820ea90 	cmplti	zero,at,-31830
 820e430:	0820ea90 	cmplti	zero,at,-31830
 820e434:	0820ea90 	cmplti	zero,at,-31830
 820e438:	0820ea90 	cmplti	zero,at,-31830
 820e43c:	0820ea90 	cmplti	zero,at,-31830
 820e440:	0820e728 	cmpgeui	zero,at,33692
 820e444:	0820e8d4 	ori	zero,at,33699
 820e448:	0820ea90 	cmplti	zero,at,-31830
 820e44c:	0820ea90 	cmplti	zero,at,-31830
 820e450:	0820ea90 	cmplti	zero,at,-31830
 820e454:	0820e8c8 	cmpgei	zero,at,-31837
 820e458:	0820e8d4 	ori	zero,at,33699
 820e45c:	0820ea90 	cmplti	zero,at,-31830
 820e460:	0820ea90 	cmplti	zero,at,-31830
 820e464:	0820e8b8 	rdprs	zero,at,-31838
 820e468:	0820ea90 	cmplti	zero,at,-31830
 820e46c:	0820e87c 	xorhi	zero,at,33697
 820e470:	0820e684 	addi	zero,at,-31846
 820e474:	0820e4d0 	cmplti	zero,at,-31853
 820e478:	0820e9e8 	cmpgeui	zero,at,33703
 820e47c:	0820ea90 	cmplti	zero,at,-31830
 820e480:	0820e99c 	xori	zero,at,33702
 820e484:	0820ea90 	cmplti	zero,at,-31830
 820e488:	0820e5f4 	orhi	zero,at,33687
 820e48c:	0820ea90 	cmplti	zero,at,-31830
 820e490:	0820ea90 	cmplti	zero,at,-31830
 820e494:	0820e550 	cmplti	zero,at,-31851
 820e498:	dac02317 	ldw	r11,140(sp)
 820e49c:	5ac00017 	ldw	r11,0(r11)
 820e4a0:	dac02415 	stw	r11,144(sp)
 820e4a4:	dac02317 	ldw	r11,140(sp)
 820e4a8:	58800104 	addi	r2,r11,4
 820e4ac:	dac02417 	ldw	r11,144(sp)
 820e4b0:	5802e90e 	bge	r11,zero,820f058 <___svfiprintf_internal_r+0xe84>
 820e4b4:	dac02417 	ldw	r11,144(sp)
 820e4b8:	d8802315 	stw	r2,140(sp)
 820e4bc:	02d7c83a 	sub	r11,zero,r11
 820e4c0:	dac02415 	stw	r11,144(sp)
 820e4c4:	94800114 	ori	r18,r18,4
 820e4c8:	98c00007 	ldb	r3,0(r19)
 820e4cc:	003f9006 	br	820e310 <___svfiprintf_internal_r+0x13c>
 820e4d0:	00800c04 	movi	r2,48
 820e4d4:	dac02317 	ldw	r11,140(sp)
 820e4d8:	d8801d05 	stb	r2,116(sp)
 820e4dc:	00801e04 	movi	r2,120
 820e4e0:	d8801d45 	stb	r2,117(sp)
 820e4e4:	d8001d85 	stb	zero,118(sp)
 820e4e8:	58c00104 	addi	r3,r11,4
 820e4ec:	5f000017 	ldw	fp,0(r11)
 820e4f0:	0013883a 	mov	r9,zero
 820e4f4:	90800094 	ori	r2,r18,2
 820e4f8:	80032b16 	blt	r16,zero,820f1a8 <___svfiprintf_internal_r+0xfd4>
 820e4fc:	00bfdfc4 	movi	r2,-129
 820e500:	90a4703a 	and	r18,r18,r2
 820e504:	d8c02315 	stw	r3,140(sp)
 820e508:	94800094 	ori	r18,r18,2
 820e50c:	e002dc26 	beq	fp,zero,820f080 <___svfiprintf_internal_r+0xeac>
 820e510:	01020974 	movhi	r4,2085
 820e514:	2136cc04 	addi	r4,r4,-9424
 820e518:	0015883a 	mov	r10,zero
 820e51c:	d9002915 	stw	r4,164(sp)
 820e520:	00002306 	br	820e5b0 <___svfiprintf_internal_r+0x3dc>
 820e524:	94800054 	ori	r18,r18,1
 820e528:	98c00007 	ldb	r3,0(r19)
 820e52c:	003f7806 	br	820e310 <___svfiprintf_internal_r+0x13c>
 820e530:	38803fcc 	andi	r2,r7,255
 820e534:	1080201c 	xori	r2,r2,128
 820e538:	10bfe004 	addi	r2,r2,-128
 820e53c:	1002f31e 	bne	r2,zero,820f10c <___svfiprintf_internal_r+0xf38>
 820e540:	01000044 	movi	r4,1
 820e544:	01c00804 	movi	r7,32
 820e548:	98c00007 	ldb	r3,0(r19)
 820e54c:	003f7006 	br	820e310 <___svfiprintf_internal_r+0x13c>
 820e550:	21003fcc 	andi	r4,r4,255
 820e554:	2003aa1e 	bne	r4,zero,820f400 <___svfiprintf_internal_r+0x122c>
 820e558:	00820974 	movhi	r2,2085
 820e55c:	10b6cc04 	addi	r2,r2,-9424
 820e560:	d8802915 	stw	r2,164(sp)
 820e564:	9080080c 	andi	r2,r18,32
 820e568:	1000ba26 	beq	r2,zero,820e854 <___svfiprintf_internal_r+0x680>
 820e56c:	dac02317 	ldw	r11,140(sp)
 820e570:	5f000017 	ldw	fp,0(r11)
 820e574:	5a400117 	ldw	r9,4(r11)
 820e578:	5ac00204 	addi	r11,r11,8
 820e57c:	dac02315 	stw	r11,140(sp)
 820e580:	9080004c 	andi	r2,r18,1
 820e584:	10029026 	beq	r2,zero,820efc8 <___svfiprintf_internal_r+0xdf4>
 820e588:	e244b03a 	or	r2,fp,r9
 820e58c:	1002d41e 	bne	r2,zero,820f0e0 <___svfiprintf_internal_r+0xf0c>
 820e590:	d8001d85 	stb	zero,118(sp)
 820e594:	80030b16 	blt	r16,zero,820f1c4 <___svfiprintf_internal_r+0xff0>
 820e598:	00bfdfc4 	movi	r2,-129
 820e59c:	90a4703a 	and	r18,r18,r2
 820e5a0:	0015883a 	mov	r10,zero
 820e5a4:	80002426 	beq	r16,zero,820e638 <___svfiprintf_internal_r+0x464>
 820e5a8:	0039883a 	mov	fp,zero
 820e5ac:	0013883a 	mov	r9,zero
 820e5b0:	d9002917 	ldw	r4,164(sp)
 820e5b4:	dc401a04 	addi	r17,sp,104
 820e5b8:	e08003cc 	andi	r2,fp,15
 820e5bc:	4806973a 	slli	r3,r9,28
 820e5c0:	2085883a 	add	r2,r4,r2
 820e5c4:	e038d13a 	srli	fp,fp,4
 820e5c8:	10800003 	ldbu	r2,0(r2)
 820e5cc:	4812d13a 	srli	r9,r9,4
 820e5d0:	8c7fffc4 	addi	r17,r17,-1
 820e5d4:	1f38b03a 	or	fp,r3,fp
 820e5d8:	88800005 	stb	r2,0(r17)
 820e5dc:	e244b03a 	or	r2,fp,r9
 820e5e0:	103ff51e 	bne	r2,zero,820e5b8 <___svfiprintf_internal_r+0x3e4>
 820e5e4:	dac01e17 	ldw	r11,120(sp)
 820e5e8:	5c57c83a 	sub	r11,r11,r17
 820e5ec:	dac02115 	stw	r11,132(sp)
 820e5f0:	00001406 	br	820e644 <___svfiprintf_internal_r+0x470>
 820e5f4:	21003fcc 	andi	r4,r4,255
 820e5f8:	2003741e 	bne	r4,zero,820f3cc <___svfiprintf_internal_r+0x11f8>
 820e5fc:	9080080c 	andi	r2,r18,32
 820e600:	10014526 	beq	r2,zero,820eb18 <___svfiprintf_internal_r+0x944>
 820e604:	dac02317 	ldw	r11,140(sp)
 820e608:	d8001d85 	stb	zero,118(sp)
 820e60c:	58c00204 	addi	r3,r11,8
 820e610:	5f000017 	ldw	fp,0(r11)
 820e614:	5a400117 	ldw	r9,4(r11)
 820e618:	8002d916 	blt	r16,zero,820f180 <___svfiprintf_internal_r+0xfac>
 820e61c:	013fdfc4 	movi	r4,-129
 820e620:	e244b03a 	or	r2,fp,r9
 820e624:	d8c02315 	stw	r3,140(sp)
 820e628:	9124703a 	and	r18,r18,r4
 820e62c:	0015883a 	mov	r10,zero
 820e630:	1000b91e 	bne	r2,zero,820e918 <___svfiprintf_internal_r+0x744>
 820e634:	8002e61e 	bne	r16,zero,820f1d0 <___svfiprintf_internal_r+0xffc>
 820e638:	0021883a 	mov	r16,zero
 820e63c:	d8002115 	stw	zero,132(sp)
 820e640:	dc401a04 	addi	r17,sp,104
 820e644:	d8c02117 	ldw	r3,132(sp)
 820e648:	dc002015 	stw	r16,128(sp)
 820e64c:	80c0010e 	bge	r16,r3,820e654 <___svfiprintf_internal_r+0x480>
 820e650:	d8c02015 	stw	r3,128(sp)
 820e654:	52803fcc 	andi	r10,r10,255
 820e658:	5280201c 	xori	r10,r10,128
 820e65c:	52bfe004 	addi	r10,r10,-128
 820e660:	50003c26 	beq	r10,zero,820e754 <___svfiprintf_internal_r+0x580>
 820e664:	dac02017 	ldw	r11,128(sp)
 820e668:	5ac00044 	addi	r11,r11,1
 820e66c:	dac02015 	stw	r11,128(sp)
 820e670:	00003806 	br	820e754 <___svfiprintf_internal_r+0x580>
 820e674:	01000044 	movi	r4,1
 820e678:	01c00ac4 	movi	r7,43
 820e67c:	98c00007 	ldb	r3,0(r19)
 820e680:	003f2306 	br	820e310 <___svfiprintf_internal_r+0x13c>
 820e684:	21003fcc 	andi	r4,r4,255
 820e688:	2003481e 	bne	r4,zero,820f3ac <___svfiprintf_internal_r+0x11d8>
 820e68c:	9080080c 	andi	r2,r18,32
 820e690:	10013b26 	beq	r2,zero,820eb80 <___svfiprintf_internal_r+0x9ac>
 820e694:	dac02317 	ldw	r11,140(sp)
 820e698:	d8001d85 	stb	zero,118(sp)
 820e69c:	58800204 	addi	r2,r11,8
 820e6a0:	5f000017 	ldw	fp,0(r11)
 820e6a4:	5a400117 	ldw	r9,4(r11)
 820e6a8:	8002a816 	blt	r16,zero,820f14c <___svfiprintf_internal_r+0xf78>
 820e6ac:	013fdfc4 	movi	r4,-129
 820e6b0:	e246b03a 	or	r3,fp,r9
 820e6b4:	d8802315 	stw	r2,140(sp)
 820e6b8:	9124703a 	and	r18,r18,r4
 820e6bc:	18013c26 	beq	r3,zero,820ebb0 <___svfiprintf_internal_r+0x9dc>
 820e6c0:	0015883a 	mov	r10,zero
 820e6c4:	dc401a04 	addi	r17,sp,104
 820e6c8:	e006d0fa 	srli	r3,fp,3
 820e6cc:	4808977a 	slli	r4,r9,29
 820e6d0:	4812d0fa 	srli	r9,r9,3
 820e6d4:	e70001cc 	andi	fp,fp,7
 820e6d8:	e0800c04 	addi	r2,fp,48
 820e6dc:	8c7fffc4 	addi	r17,r17,-1
 820e6e0:	20f8b03a 	or	fp,r4,r3
 820e6e4:	88800005 	stb	r2,0(r17)
 820e6e8:	e246b03a 	or	r3,fp,r9
 820e6ec:	183ff61e 	bne	r3,zero,820e6c8 <___svfiprintf_internal_r+0x4f4>
 820e6f0:	90c0004c 	andi	r3,r18,1
 820e6f4:	1800a526 	beq	r3,zero,820e98c <___svfiprintf_internal_r+0x7b8>
 820e6f8:	10803fcc 	andi	r2,r2,255
 820e6fc:	1080201c 	xori	r2,r2,128
 820e700:	10bfe004 	addi	r2,r2,-128
 820e704:	00c00c04 	movi	r3,48
 820e708:	10ffb626 	beq	r2,r3,820e5e4 <___svfiprintf_internal_r+0x410>
 820e70c:	88ffffc5 	stb	r3,-1(r17)
 820e710:	d8c01e17 	ldw	r3,120(sp)
 820e714:	88bfffc4 	addi	r2,r17,-1
 820e718:	1023883a 	mov	r17,r2
 820e71c:	1887c83a 	sub	r3,r3,r2
 820e720:	d8c02115 	stw	r3,132(sp)
 820e724:	003fc706 	br	820e644 <___svfiprintf_internal_r+0x470>
 820e728:	dac02317 	ldw	r11,140(sp)
 820e72c:	00c00044 	movi	r3,1
 820e730:	d8c02015 	stw	r3,128(sp)
 820e734:	58800017 	ldw	r2,0(r11)
 820e738:	5ac00104 	addi	r11,r11,4
 820e73c:	d8001d85 	stb	zero,118(sp)
 820e740:	d8801005 	stb	r2,64(sp)
 820e744:	dac02315 	stw	r11,140(sp)
 820e748:	d8c02115 	stw	r3,132(sp)
 820e74c:	dc401004 	addi	r17,sp,64
 820e750:	0021883a 	mov	r16,zero
 820e754:	90c0008c 	andi	r3,r18,2
 820e758:	d8c02215 	stw	r3,136(sp)
 820e75c:	18000326 	beq	r3,zero,820e76c <___svfiprintf_internal_r+0x598>
 820e760:	dac02017 	ldw	r11,128(sp)
 820e764:	5ac00084 	addi	r11,r11,2
 820e768:	dac02015 	stw	r11,128(sp)
 820e76c:	90c0210c 	andi	r3,r18,132
 820e770:	d8c02615 	stw	r3,152(sp)
 820e774:	1801131e 	bne	r3,zero,820ebc4 <___svfiprintf_internal_r+0x9f0>
 820e778:	dac02417 	ldw	r11,144(sp)
 820e77c:	d8c02017 	ldw	r3,128(sp)
 820e780:	58f9c83a 	sub	fp,r11,r3
 820e784:	07010f0e 	bge	zero,fp,820ebc4 <___svfiprintf_internal_r+0x9f0>
 820e788:	02400404 	movi	r9,16
 820e78c:	d8c01c17 	ldw	r3,112(sp)
 820e790:	d8801b17 	ldw	r2,108(sp)
 820e794:	4f02d60e 	bge	r9,fp,820f2f0 <___svfiprintf_internal_r+0x111c>
 820e798:	01420974 	movhi	r5,2085
 820e79c:	29773804 	addi	r5,r5,-8992
 820e7a0:	d9402815 	stw	r5,160(sp)
 820e7a4:	028001c4 	movi	r10,7
 820e7a8:	00000306 	br	820e7b8 <___svfiprintf_internal_r+0x5e4>
 820e7ac:	e73ffc04 	addi	fp,fp,-16
 820e7b0:	42000204 	addi	r8,r8,8
 820e7b4:	4f00150e 	bge	r9,fp,820e80c <___svfiprintf_internal_r+0x638>
 820e7b8:	18c00404 	addi	r3,r3,16
 820e7bc:	10800044 	addi	r2,r2,1
 820e7c0:	45800015 	stw	r22,0(r8)
 820e7c4:	42400115 	stw	r9,4(r8)
 820e7c8:	d8c01c15 	stw	r3,112(sp)
 820e7cc:	d8801b15 	stw	r2,108(sp)
 820e7d0:	50bff60e 	bge	r10,r2,820e7ac <___svfiprintf_internal_r+0x5d8>
 820e7d4:	d9801a04 	addi	r6,sp,104
 820e7d8:	b80b883a 	mov	r5,r23
 820e7dc:	a809883a 	mov	r4,r21
 820e7e0:	da402c15 	stw	r9,176(sp)
 820e7e4:	da802d15 	stw	r10,180(sp)
 820e7e8:	820e0040 	call	820e004 <__ssprint_r>
 820e7ec:	da402c17 	ldw	r9,176(sp)
 820e7f0:	da802d17 	ldw	r10,180(sp)
 820e7f4:	1001851e 	bne	r2,zero,820ee0c <___svfiprintf_internal_r+0xc38>
 820e7f8:	e73ffc04 	addi	fp,fp,-16
 820e7fc:	d8c01c17 	ldw	r3,112(sp)
 820e800:	d8801b17 	ldw	r2,108(sp)
 820e804:	d811883a 	mov	r8,sp
 820e808:	4f3feb16 	blt	r9,fp,820e7b8 <___svfiprintf_internal_r+0x5e4>
 820e80c:	dac02817 	ldw	r11,160(sp)
 820e810:	e0c7883a 	add	r3,fp,r3
 820e814:	10800044 	addi	r2,r2,1
 820e818:	42c00015 	stw	r11,0(r8)
 820e81c:	47000115 	stw	fp,4(r8)
 820e820:	d8c01c15 	stw	r3,112(sp)
 820e824:	d8801b15 	stw	r2,108(sp)
 820e828:	010001c4 	movi	r4,7
 820e82c:	2081ee16 	blt	r4,r2,820efe8 <___svfiprintf_internal_r+0xe14>
 820e830:	42000204 	addi	r8,r8,8
 820e834:	0000e506 	br	820ebcc <___svfiprintf_internal_r+0x9f8>
 820e838:	21003fcc 	andi	r4,r4,255
 820e83c:	2002dd1e 	bne	r4,zero,820f3b4 <___svfiprintf_internal_r+0x11e0>
 820e840:	00820974 	movhi	r2,2085
 820e844:	10b6c704 	addi	r2,r2,-9444
 820e848:	d8802915 	stw	r2,164(sp)
 820e84c:	9080080c 	andi	r2,r18,32
 820e850:	103f461e 	bne	r2,zero,820e56c <___svfiprintf_internal_r+0x398>
 820e854:	9080040c 	andi	r2,r18,16
 820e858:	10022e1e 	bne	r2,zero,820f114 <___svfiprintf_internal_r+0xf40>
 820e85c:	9080100c 	andi	r2,r18,64
 820e860:	dac02317 	ldw	r11,140(sp)
 820e864:	10027326 	beq	r2,zero,820f234 <___svfiprintf_internal_r+0x1060>
 820e868:	5f00000b 	ldhu	fp,0(r11)
 820e86c:	5ac00104 	addi	r11,r11,4
 820e870:	0013883a 	mov	r9,zero
 820e874:	dac02315 	stw	r11,140(sp)
 820e878:	003f4106 	br	820e580 <___svfiprintf_internal_r+0x3ac>
 820e87c:	21003fcc 	andi	r4,r4,255
 820e880:	2002e11e 	bne	r4,zero,820f408 <___svfiprintf_internal_r+0x1234>
 820e884:	9080080c 	andi	r2,r18,32
 820e888:	1002011e 	bne	r2,zero,820f090 <___svfiprintf_internal_r+0xebc>
 820e88c:	9080040c 	andi	r2,r18,16
 820e890:	10023e1e 	bne	r2,zero,820f18c <___svfiprintf_internal_r+0xfb8>
 820e894:	9480100c 	andi	r18,r18,64
 820e898:	90023c26 	beq	r18,zero,820f18c <___svfiprintf_internal_r+0xfb8>
 820e89c:	dac02317 	ldw	r11,140(sp)
 820e8a0:	58800017 	ldw	r2,0(r11)
 820e8a4:	5ac00104 	addi	r11,r11,4
 820e8a8:	dac02315 	stw	r11,140(sp)
 820e8ac:	dac02517 	ldw	r11,148(sp)
 820e8b0:	12c0000d 	sth	r11,0(r2)
 820e8b4:	003e6e06 	br	820e270 <___svfiprintf_internal_r+0x9c>
 820e8b8:	98c00007 	ldb	r3,0(r19)
 820e8bc:	1a422926 	beq	r3,r9,820f164 <___svfiprintf_internal_r+0xf90>
 820e8c0:	94800414 	ori	r18,r18,16
 820e8c4:	003e9206 	br	820e310 <___svfiprintf_internal_r+0x13c>
 820e8c8:	94801014 	ori	r18,r18,64
 820e8cc:	98c00007 	ldb	r3,0(r19)
 820e8d0:	003e8f06 	br	820e310 <___svfiprintf_internal_r+0x13c>
 820e8d4:	21003fcc 	andi	r4,r4,255
 820e8d8:	2002c71e 	bne	r4,zero,820f3f8 <___svfiprintf_internal_r+0x1224>
 820e8dc:	9080080c 	andi	r2,r18,32
 820e8e0:	10004926 	beq	r2,zero,820ea08 <___svfiprintf_internal_r+0x834>
 820e8e4:	dac02317 	ldw	r11,140(sp)
 820e8e8:	58800117 	ldw	r2,4(r11)
 820e8ec:	5f000017 	ldw	fp,0(r11)
 820e8f0:	5ac00204 	addi	r11,r11,8
 820e8f4:	dac02315 	stw	r11,140(sp)
 820e8f8:	1013883a 	mov	r9,r2
 820e8fc:	10004b16 	blt	r2,zero,820ea2c <___svfiprintf_internal_r+0x858>
 820e900:	da801d83 	ldbu	r10,118(sp)
 820e904:	8001cb16 	blt	r16,zero,820f034 <___svfiprintf_internal_r+0xe60>
 820e908:	00ffdfc4 	movi	r3,-129
 820e90c:	e244b03a 	or	r2,fp,r9
 820e910:	90e4703a 	and	r18,r18,r3
 820e914:	103f4726 	beq	r2,zero,820e634 <___svfiprintf_internal_r+0x460>
 820e918:	48008c26 	beq	r9,zero,820eb4c <___svfiprintf_internal_r+0x978>
 820e91c:	dc802015 	stw	r18,128(sp)
 820e920:	dc002115 	stw	r16,132(sp)
 820e924:	dc401a04 	addi	r17,sp,104
 820e928:	e021883a 	mov	r16,fp
 820e92c:	da002215 	stw	r8,136(sp)
 820e930:	5039883a 	mov	fp,r10
 820e934:	4825883a 	mov	r18,r9
 820e938:	8009883a 	mov	r4,r16
 820e93c:	900b883a 	mov	r5,r18
 820e940:	01800284 	movi	r6,10
 820e944:	000f883a 	mov	r7,zero
 820e948:	82117ac0 	call	82117ac <__umoddi3>
 820e94c:	10800c04 	addi	r2,r2,48
 820e950:	8c7fffc4 	addi	r17,r17,-1
 820e954:	8009883a 	mov	r4,r16
 820e958:	900b883a 	mov	r5,r18
 820e95c:	88800005 	stb	r2,0(r17)
 820e960:	01800284 	movi	r6,10
 820e964:	000f883a 	mov	r7,zero
 820e968:	82112340 	call	8211234 <__udivdi3>
 820e96c:	1021883a 	mov	r16,r2
 820e970:	10c4b03a 	or	r2,r2,r3
 820e974:	1825883a 	mov	r18,r3
 820e978:	103fef1e 	bne	r2,zero,820e938 <___svfiprintf_internal_r+0x764>
 820e97c:	dc802017 	ldw	r18,128(sp)
 820e980:	dc002117 	ldw	r16,132(sp)
 820e984:	da002217 	ldw	r8,136(sp)
 820e988:	e015883a 	mov	r10,fp
 820e98c:	d8c01e17 	ldw	r3,120(sp)
 820e990:	1c47c83a 	sub	r3,r3,r17
 820e994:	d8c02115 	stw	r3,132(sp)
 820e998:	003f2a06 	br	820e644 <___svfiprintf_internal_r+0x470>
 820e99c:	dac02317 	ldw	r11,140(sp)
 820e9a0:	d8001d85 	stb	zero,118(sp)
 820e9a4:	5c400017 	ldw	r17,0(r11)
 820e9a8:	5f000104 	addi	fp,r11,4
 820e9ac:	88022f26 	beq	r17,zero,820f26c <___svfiprintf_internal_r+0x1098>
 820e9b0:	80022516 	blt	r16,zero,820f248 <___svfiprintf_internal_r+0x1074>
 820e9b4:	800d883a 	mov	r6,r16
 820e9b8:	000b883a 	mov	r5,zero
 820e9bc:	8809883a 	mov	r4,r17
 820e9c0:	da002c15 	stw	r8,176(sp)
 820e9c4:	820c4740 	call	820c474 <memchr>
 820e9c8:	da002c17 	ldw	r8,176(sp)
 820e9cc:	10026426 	beq	r2,zero,820f360 <___svfiprintf_internal_r+0x118c>
 820e9d0:	1445c83a 	sub	r2,r2,r17
 820e9d4:	d8802115 	stw	r2,132(sp)
 820e9d8:	da801d83 	ldbu	r10,118(sp)
 820e9dc:	df002315 	stw	fp,140(sp)
 820e9e0:	0021883a 	mov	r16,zero
 820e9e4:	003f1706 	br	820e644 <___svfiprintf_internal_r+0x470>
 820e9e8:	94800814 	ori	r18,r18,32
 820e9ec:	98c00007 	ldb	r3,0(r19)
 820e9f0:	003e4706 	br	820e310 <___svfiprintf_internal_r+0x13c>
 820e9f4:	21003fcc 	andi	r4,r4,255
 820e9f8:	2002701e 	bne	r4,zero,820f3bc <___svfiprintf_internal_r+0x11e8>
 820e9fc:	94800414 	ori	r18,r18,16
 820ea00:	9080080c 	andi	r2,r18,32
 820ea04:	103fb71e 	bne	r2,zero,820e8e4 <___svfiprintf_internal_r+0x710>
 820ea08:	9080040c 	andi	r2,r18,16
 820ea0c:	1001ab26 	beq	r2,zero,820f0bc <___svfiprintf_internal_r+0xee8>
 820ea10:	dac02317 	ldw	r11,140(sp)
 820ea14:	5f000017 	ldw	fp,0(r11)
 820ea18:	5ac00104 	addi	r11,r11,4
 820ea1c:	dac02315 	stw	r11,140(sp)
 820ea20:	e013d7fa 	srai	r9,fp,31
 820ea24:	4805883a 	mov	r2,r9
 820ea28:	103fb50e 	bge	r2,zero,820e900 <___svfiprintf_internal_r+0x72c>
 820ea2c:	0739c83a 	sub	fp,zero,fp
 820ea30:	02800b44 	movi	r10,45
 820ea34:	e004c03a 	cmpne	r2,fp,zero
 820ea38:	0253c83a 	sub	r9,zero,r9
 820ea3c:	da801d85 	stb	r10,118(sp)
 820ea40:	4893c83a 	sub	r9,r9,r2
 820ea44:	80023016 	blt	r16,zero,820f308 <___svfiprintf_internal_r+0x1134>
 820ea48:	00bfdfc4 	movi	r2,-129
 820ea4c:	90a4703a 	and	r18,r18,r2
 820ea50:	483fb21e 	bne	r9,zero,820e91c <___svfiprintf_internal_r+0x748>
 820ea54:	00003d06 	br	820eb4c <___svfiprintf_internal_r+0x978>
 820ea58:	9817883a 	mov	r11,r19
 820ea5c:	d8002415 	stw	zero,144(sp)
 820ea60:	18bff404 	addi	r2,r3,-48
 820ea64:	0019883a 	mov	r12,zero
 820ea68:	58c00007 	ldb	r3,0(r11)
 820ea6c:	630002a4 	muli	r12,r12,10
 820ea70:	9cc00044 	addi	r19,r19,1
 820ea74:	9817883a 	mov	r11,r19
 820ea78:	1319883a 	add	r12,r2,r12
 820ea7c:	18bff404 	addi	r2,r3,-48
 820ea80:	30bff92e 	bgeu	r6,r2,820ea68 <___svfiprintf_internal_r+0x894>
 820ea84:	db002415 	stw	r12,144(sp)
 820ea88:	18bff804 	addi	r2,r3,-32
 820ea8c:	28be232e 	bgeu	r5,r2,820e31c <___svfiprintf_internal_r+0x148>
 820ea90:	21003fcc 	andi	r4,r4,255
 820ea94:	20024b1e 	bne	r4,zero,820f3c4 <___svfiprintf_internal_r+0x11f0>
 820ea98:	1800d626 	beq	r3,zero,820edf4 <___svfiprintf_internal_r+0xc20>
 820ea9c:	02c00044 	movi	r11,1
 820eaa0:	dac02015 	stw	r11,128(sp)
 820eaa4:	d8c01005 	stb	r3,64(sp)
 820eaa8:	d8001d85 	stb	zero,118(sp)
 820eaac:	dac02115 	stw	r11,132(sp)
 820eab0:	dc401004 	addi	r17,sp,64
 820eab4:	003f2606 	br	820e750 <___svfiprintf_internal_r+0x57c>
 820eab8:	94802014 	ori	r18,r18,128
 820eabc:	98c00007 	ldb	r3,0(r19)
 820eac0:	003e1306 	br	820e310 <___svfiprintf_internal_r+0x13c>
 820eac4:	98c00007 	ldb	r3,0(r19)
 820eac8:	9ac00044 	addi	r11,r19,1
 820eacc:	1a822b26 	beq	r3,r10,820f37c <___svfiprintf_internal_r+0x11a8>
 820ead0:	18bff404 	addi	r2,r3,-48
 820ead4:	0021883a 	mov	r16,zero
 820ead8:	30821e36 	bltu	r6,r2,820f354 <___svfiprintf_internal_r+0x1180>
 820eadc:	58c00007 	ldb	r3,0(r11)
 820eae0:	840002a4 	muli	r16,r16,10
 820eae4:	5cc00044 	addi	r19,r11,1
 820eae8:	9817883a 	mov	r11,r19
 820eaec:	80a1883a 	add	r16,r16,r2
 820eaf0:	18bff404 	addi	r2,r3,-48
 820eaf4:	30bff92e 	bgeu	r6,r2,820eadc <___svfiprintf_internal_r+0x908>
 820eaf8:	803e060e 	bge	r16,zero,820e314 <___svfiprintf_internal_r+0x140>
 820eafc:	043fffc4 	movi	r16,-1
 820eb00:	003e0406 	br	820e314 <___svfiprintf_internal_r+0x140>
 820eb04:	21003fcc 	andi	r4,r4,255
 820eb08:	2002371e 	bne	r4,zero,820f3e8 <___svfiprintf_internal_r+0x1214>
 820eb0c:	94800414 	ori	r18,r18,16
 820eb10:	9080080c 	andi	r2,r18,32
 820eb14:	103ebb1e 	bne	r2,zero,820e604 <___svfiprintf_internal_r+0x430>
 820eb18:	9080040c 	andi	r2,r18,16
 820eb1c:	10013b26 	beq	r2,zero,820f00c <___svfiprintf_internal_r+0xe38>
 820eb20:	dac02317 	ldw	r11,140(sp)
 820eb24:	d8001d85 	stb	zero,118(sp)
 820eb28:	0013883a 	mov	r9,zero
 820eb2c:	58800104 	addi	r2,r11,4
 820eb30:	5f000017 	ldw	fp,0(r11)
 820eb34:	80013d16 	blt	r16,zero,820f02c <___svfiprintf_internal_r+0xe58>
 820eb38:	00ffdfc4 	movi	r3,-129
 820eb3c:	d8802315 	stw	r2,140(sp)
 820eb40:	90e4703a 	and	r18,r18,r3
 820eb44:	0015883a 	mov	r10,zero
 820eb48:	e03eba26 	beq	fp,zero,820e634 <___svfiprintf_internal_r+0x460>
 820eb4c:	00800244 	movi	r2,9
 820eb50:	173f7236 	bltu	r2,fp,820e91c <___svfiprintf_internal_r+0x748>
 820eb54:	dac02b17 	ldw	r11,172(sp)
 820eb58:	e7000c04 	addi	fp,fp,48
 820eb5c:	df0019c5 	stb	fp,103(sp)
 820eb60:	dac02115 	stw	r11,132(sp)
 820eb64:	dc4019c4 	addi	r17,sp,103
 820eb68:	003eb606 	br	820e644 <___svfiprintf_internal_r+0x470>
 820eb6c:	21003fcc 	andi	r4,r4,255
 820eb70:	20021f1e 	bne	r4,zero,820f3f0 <___svfiprintf_internal_r+0x121c>
 820eb74:	94800414 	ori	r18,r18,16
 820eb78:	9080080c 	andi	r2,r18,32
 820eb7c:	103ec51e 	bne	r2,zero,820e694 <___svfiprintf_internal_r+0x4c0>
 820eb80:	9080040c 	andi	r2,r18,16
 820eb84:	10016926 	beq	r2,zero,820f12c <___svfiprintf_internal_r+0xf58>
 820eb88:	dac02317 	ldw	r11,140(sp)
 820eb8c:	d8001d85 	stb	zero,118(sp)
 820eb90:	0013883a 	mov	r9,zero
 820eb94:	58800104 	addi	r2,r11,4
 820eb98:	5f000017 	ldw	fp,0(r11)
 820eb9c:	80016b16 	blt	r16,zero,820f14c <___svfiprintf_internal_r+0xf78>
 820eba0:	00ffdfc4 	movi	r3,-129
 820eba4:	d8802315 	stw	r2,140(sp)
 820eba8:	90e4703a 	and	r18,r18,r3
 820ebac:	e03ec41e 	bne	fp,zero,820e6c0 <___svfiprintf_internal_r+0x4ec>
 820ebb0:	0015883a 	mov	r10,zero
 820ebb4:	8001c226 	beq	r16,zero,820f2c0 <___svfiprintf_internal_r+0x10ec>
 820ebb8:	0039883a 	mov	fp,zero
 820ebbc:	0013883a 	mov	r9,zero
 820ebc0:	003ec006 	br	820e6c4 <___svfiprintf_internal_r+0x4f0>
 820ebc4:	d8c01c17 	ldw	r3,112(sp)
 820ebc8:	d8801b17 	ldw	r2,108(sp)
 820ebcc:	d9001d87 	ldb	r4,118(sp)
 820ebd0:	20000b26 	beq	r4,zero,820ec00 <___svfiprintf_internal_r+0xa2c>
 820ebd4:	d9001d84 	addi	r4,sp,118
 820ebd8:	18c00044 	addi	r3,r3,1
 820ebdc:	10800044 	addi	r2,r2,1
 820ebe0:	41000015 	stw	r4,0(r8)
 820ebe4:	01000044 	movi	r4,1
 820ebe8:	41000115 	stw	r4,4(r8)
 820ebec:	d8c01c15 	stw	r3,112(sp)
 820ebf0:	d8801b15 	stw	r2,108(sp)
 820ebf4:	010001c4 	movi	r4,7
 820ebf8:	2080e116 	blt	r4,r2,820ef80 <___svfiprintf_internal_r+0xdac>
 820ebfc:	42000204 	addi	r8,r8,8
 820ec00:	dac02217 	ldw	r11,136(sp)
 820ec04:	58000b26 	beq	r11,zero,820ec34 <___svfiprintf_internal_r+0xa60>
 820ec08:	d9001d04 	addi	r4,sp,116
 820ec0c:	18c00084 	addi	r3,r3,2
 820ec10:	10800044 	addi	r2,r2,1
 820ec14:	41000015 	stw	r4,0(r8)
 820ec18:	01000084 	movi	r4,2
 820ec1c:	41000115 	stw	r4,4(r8)
 820ec20:	d8c01c15 	stw	r3,112(sp)
 820ec24:	d8801b15 	stw	r2,108(sp)
 820ec28:	010001c4 	movi	r4,7
 820ec2c:	2080dd16 	blt	r4,r2,820efa4 <___svfiprintf_internal_r+0xdd0>
 820ec30:	42000204 	addi	r8,r8,8
 820ec34:	dac02617 	ldw	r11,152(sp)
 820ec38:	01002004 	movi	r4,128
 820ec3c:	59008426 	beq	r11,r4,820ee50 <___svfiprintf_internal_r+0xc7c>
 820ec40:	dac02117 	ldw	r11,132(sp)
 820ec44:	82e1c83a 	sub	r16,r16,r11
 820ec48:	0400270e 	bge	zero,r16,820ece8 <___svfiprintf_internal_r+0xb14>
 820ec4c:	01c00404 	movi	r7,16
 820ec50:	3c016a0e 	bge	r7,r16,820f1fc <___svfiprintf_internal_r+0x1028>
 820ec54:	01420974 	movhi	r5,2085
 820ec58:	29773404 	addi	r5,r5,-9008
 820ec5c:	d9402215 	stw	r5,136(sp)
 820ec60:	070001c4 	movi	fp,7
 820ec64:	00000306 	br	820ec74 <___svfiprintf_internal_r+0xaa0>
 820ec68:	843ffc04 	addi	r16,r16,-16
 820ec6c:	42000204 	addi	r8,r8,8
 820ec70:	3c00130e 	bge	r7,r16,820ecc0 <___svfiprintf_internal_r+0xaec>
 820ec74:	18c00404 	addi	r3,r3,16
 820ec78:	10800044 	addi	r2,r2,1
 820ec7c:	45000015 	stw	r20,0(r8)
 820ec80:	41c00115 	stw	r7,4(r8)
 820ec84:	d8c01c15 	stw	r3,112(sp)
 820ec88:	d8801b15 	stw	r2,108(sp)
 820ec8c:	e0bff60e 	bge	fp,r2,820ec68 <___svfiprintf_internal_r+0xa94>
 820ec90:	d9801a04 	addi	r6,sp,104
 820ec94:	b80b883a 	mov	r5,r23
 820ec98:	a809883a 	mov	r4,r21
 820ec9c:	d9c02c15 	stw	r7,176(sp)
 820eca0:	820e0040 	call	820e004 <__ssprint_r>
 820eca4:	d9c02c17 	ldw	r7,176(sp)
 820eca8:	1000581e 	bne	r2,zero,820ee0c <___svfiprintf_internal_r+0xc38>
 820ecac:	843ffc04 	addi	r16,r16,-16
 820ecb0:	d8c01c17 	ldw	r3,112(sp)
 820ecb4:	d8801b17 	ldw	r2,108(sp)
 820ecb8:	d811883a 	mov	r8,sp
 820ecbc:	3c3fed16 	blt	r7,r16,820ec74 <___svfiprintf_internal_r+0xaa0>
 820ecc0:	dac02217 	ldw	r11,136(sp)
 820ecc4:	1c07883a 	add	r3,r3,r16
 820ecc8:	10800044 	addi	r2,r2,1
 820eccc:	42c00015 	stw	r11,0(r8)
 820ecd0:	44000115 	stw	r16,4(r8)
 820ecd4:	d8c01c15 	stw	r3,112(sp)
 820ecd8:	d8801b15 	stw	r2,108(sp)
 820ecdc:	010001c4 	movi	r4,7
 820ece0:	20809e16 	blt	r4,r2,820ef5c <___svfiprintf_internal_r+0xd88>
 820ece4:	42000204 	addi	r8,r8,8
 820ece8:	dac02117 	ldw	r11,132(sp)
 820ecec:	10800044 	addi	r2,r2,1
 820ecf0:	44400015 	stw	r17,0(r8)
 820ecf4:	58c7883a 	add	r3,r11,r3
 820ecf8:	42c00115 	stw	r11,4(r8)
 820ecfc:	d8c01c15 	stw	r3,112(sp)
 820ed00:	d8801b15 	stw	r2,108(sp)
 820ed04:	010001c4 	movi	r4,7
 820ed08:	20807f16 	blt	r4,r2,820ef08 <___svfiprintf_internal_r+0xd34>
 820ed0c:	42000204 	addi	r8,r8,8
 820ed10:	9480010c 	andi	r18,r18,4
 820ed14:	90002926 	beq	r18,zero,820edbc <___svfiprintf_internal_r+0xbe8>
 820ed18:	dac02417 	ldw	r11,144(sp)
 820ed1c:	d8802017 	ldw	r2,128(sp)
 820ed20:	58a1c83a 	sub	r16,r11,r2
 820ed24:	0400250e 	bge	zero,r16,820edbc <___svfiprintf_internal_r+0xbe8>
 820ed28:	04400404 	movi	r17,16
 820ed2c:	d8801b17 	ldw	r2,108(sp)
 820ed30:	8c017c0e 	bge	r17,r16,820f324 <___svfiprintf_internal_r+0x1150>
 820ed34:	01420974 	movhi	r5,2085
 820ed38:	29773804 	addi	r5,r5,-8992
 820ed3c:	d9402815 	stw	r5,160(sp)
 820ed40:	048001c4 	movi	r18,7
 820ed44:	00000306 	br	820ed54 <___svfiprintf_internal_r+0xb80>
 820ed48:	843ffc04 	addi	r16,r16,-16
 820ed4c:	42000204 	addi	r8,r8,8
 820ed50:	8c00110e 	bge	r17,r16,820ed98 <___svfiprintf_internal_r+0xbc4>
 820ed54:	18c00404 	addi	r3,r3,16
 820ed58:	10800044 	addi	r2,r2,1
 820ed5c:	45800015 	stw	r22,0(r8)
 820ed60:	44400115 	stw	r17,4(r8)
 820ed64:	d8c01c15 	stw	r3,112(sp)
 820ed68:	d8801b15 	stw	r2,108(sp)
 820ed6c:	90bff60e 	bge	r18,r2,820ed48 <___svfiprintf_internal_r+0xb74>
 820ed70:	d9801a04 	addi	r6,sp,104
 820ed74:	b80b883a 	mov	r5,r23
 820ed78:	a809883a 	mov	r4,r21
 820ed7c:	820e0040 	call	820e004 <__ssprint_r>
 820ed80:	1000221e 	bne	r2,zero,820ee0c <___svfiprintf_internal_r+0xc38>
 820ed84:	843ffc04 	addi	r16,r16,-16
 820ed88:	d8c01c17 	ldw	r3,112(sp)
 820ed8c:	d8801b17 	ldw	r2,108(sp)
 820ed90:	d811883a 	mov	r8,sp
 820ed94:	8c3fef16 	blt	r17,r16,820ed54 <___svfiprintf_internal_r+0xb80>
 820ed98:	dac02817 	ldw	r11,160(sp)
 820ed9c:	1c07883a 	add	r3,r3,r16
 820eda0:	10800044 	addi	r2,r2,1
 820eda4:	42c00015 	stw	r11,0(r8)
 820eda8:	44000115 	stw	r16,4(r8)
 820edac:	d8c01c15 	stw	r3,112(sp)
 820edb0:	d8801b15 	stw	r2,108(sp)
 820edb4:	010001c4 	movi	r4,7
 820edb8:	2080aa16 	blt	r4,r2,820f064 <___svfiprintf_internal_r+0xe90>
 820edbc:	d8802417 	ldw	r2,144(sp)
 820edc0:	dac02017 	ldw	r11,128(sp)
 820edc4:	12c0010e 	bge	r2,r11,820edcc <___svfiprintf_internal_r+0xbf8>
 820edc8:	5805883a 	mov	r2,r11
 820edcc:	dac02517 	ldw	r11,148(sp)
 820edd0:	5897883a 	add	r11,r11,r2
 820edd4:	dac02515 	stw	r11,148(sp)
 820edd8:	1800531e 	bne	r3,zero,820ef28 <___svfiprintf_internal_r+0xd54>
 820eddc:	98800007 	ldb	r2,0(r19)
 820ede0:	d8001b15 	stw	zero,108(sp)
 820ede4:	d811883a 	mov	r8,sp
 820ede8:	103d231e 	bne	r2,zero,820e278 <___svfiprintf_internal_r+0xa4>
 820edec:	9823883a 	mov	r17,r19
 820edf0:	003d3906 	br	820e2d8 <___svfiprintf_internal_r+0x104>
 820edf4:	d8801c17 	ldw	r2,112(sp)
 820edf8:	10000426 	beq	r2,zero,820ee0c <___svfiprintf_internal_r+0xc38>
 820edfc:	d9402717 	ldw	r5,156(sp)
 820ee00:	d9002a17 	ldw	r4,168(sp)
 820ee04:	d9801a04 	addi	r6,sp,104
 820ee08:	820e0040 	call	820e004 <__ssprint_r>
 820ee0c:	dac02717 	ldw	r11,156(sp)
 820ee10:	d8802517 	ldw	r2,148(sp)
 820ee14:	58c0030b 	ldhu	r3,12(r11)
 820ee18:	18c0100c 	andi	r3,r3,64
 820ee1c:	1801381e 	bne	r3,zero,820f300 <___svfiprintf_internal_r+0x112c>
 820ee20:	dfc03717 	ldw	ra,220(sp)
 820ee24:	df003617 	ldw	fp,216(sp)
 820ee28:	ddc03517 	ldw	r23,212(sp)
 820ee2c:	dd803417 	ldw	r22,208(sp)
 820ee30:	dd403317 	ldw	r21,204(sp)
 820ee34:	dd003217 	ldw	r20,200(sp)
 820ee38:	dcc03117 	ldw	r19,196(sp)
 820ee3c:	dc803017 	ldw	r18,192(sp)
 820ee40:	dc402f17 	ldw	r17,188(sp)
 820ee44:	dc002e17 	ldw	r16,184(sp)
 820ee48:	dec03804 	addi	sp,sp,224
 820ee4c:	f800283a 	ret
 820ee50:	dac02417 	ldw	r11,144(sp)
 820ee54:	d9002017 	ldw	r4,128(sp)
 820ee58:	5939c83a 	sub	fp,r11,r4
 820ee5c:	073f780e 	bge	zero,fp,820ec40 <___svfiprintf_internal_r+0xa6c>
 820ee60:	02400404 	movi	r9,16
 820ee64:	4f01370e 	bge	r9,fp,820f344 <___svfiprintf_internal_r+0x1170>
 820ee68:	02c20974 	movhi	r11,2085
 820ee6c:	5af73404 	addi	r11,r11,-9008
 820ee70:	dac02215 	stw	r11,136(sp)
 820ee74:	028001c4 	movi	r10,7
 820ee78:	00000306 	br	820ee88 <___svfiprintf_internal_r+0xcb4>
 820ee7c:	e73ffc04 	addi	fp,fp,-16
 820ee80:	42000204 	addi	r8,r8,8
 820ee84:	4f00150e 	bge	r9,fp,820eedc <___svfiprintf_internal_r+0xd08>
 820ee88:	18c00404 	addi	r3,r3,16
 820ee8c:	10800044 	addi	r2,r2,1
 820ee90:	45000015 	stw	r20,0(r8)
 820ee94:	42400115 	stw	r9,4(r8)
 820ee98:	d8c01c15 	stw	r3,112(sp)
 820ee9c:	d8801b15 	stw	r2,108(sp)
 820eea0:	50bff60e 	bge	r10,r2,820ee7c <___svfiprintf_internal_r+0xca8>
 820eea4:	d9801a04 	addi	r6,sp,104
 820eea8:	b80b883a 	mov	r5,r23
 820eeac:	a809883a 	mov	r4,r21
 820eeb0:	da402c15 	stw	r9,176(sp)
 820eeb4:	da802d15 	stw	r10,180(sp)
 820eeb8:	820e0040 	call	820e004 <__ssprint_r>
 820eebc:	da402c17 	ldw	r9,176(sp)
 820eec0:	da802d17 	ldw	r10,180(sp)
 820eec4:	103fd11e 	bne	r2,zero,820ee0c <___svfiprintf_internal_r+0xc38>
 820eec8:	e73ffc04 	addi	fp,fp,-16
 820eecc:	d8c01c17 	ldw	r3,112(sp)
 820eed0:	d8801b17 	ldw	r2,108(sp)
 820eed4:	d811883a 	mov	r8,sp
 820eed8:	4f3feb16 	blt	r9,fp,820ee88 <___svfiprintf_internal_r+0xcb4>
 820eedc:	dac02217 	ldw	r11,136(sp)
 820eee0:	1f07883a 	add	r3,r3,fp
 820eee4:	10800044 	addi	r2,r2,1
 820eee8:	42c00015 	stw	r11,0(r8)
 820eeec:	47000115 	stw	fp,4(r8)
 820eef0:	d8c01c15 	stw	r3,112(sp)
 820eef4:	d8801b15 	stw	r2,108(sp)
 820eef8:	010001c4 	movi	r4,7
 820eefc:	2080b616 	blt	r4,r2,820f1d8 <___svfiprintf_internal_r+0x1004>
 820ef00:	42000204 	addi	r8,r8,8
 820ef04:	003f4e06 	br	820ec40 <___svfiprintf_internal_r+0xa6c>
 820ef08:	d9801a04 	addi	r6,sp,104
 820ef0c:	b80b883a 	mov	r5,r23
 820ef10:	a809883a 	mov	r4,r21
 820ef14:	820e0040 	call	820e004 <__ssprint_r>
 820ef18:	103fbc1e 	bne	r2,zero,820ee0c <___svfiprintf_internal_r+0xc38>
 820ef1c:	d8c01c17 	ldw	r3,112(sp)
 820ef20:	d811883a 	mov	r8,sp
 820ef24:	003f7a06 	br	820ed10 <___svfiprintf_internal_r+0xb3c>
 820ef28:	d9801a04 	addi	r6,sp,104
 820ef2c:	b80b883a 	mov	r5,r23
 820ef30:	a809883a 	mov	r4,r21
 820ef34:	820e0040 	call	820e004 <__ssprint_r>
 820ef38:	103fa826 	beq	r2,zero,820eddc <___svfiprintf_internal_r+0xc08>
 820ef3c:	003fb306 	br	820ee0c <___svfiprintf_internal_r+0xc38>
 820ef40:	d9801a04 	addi	r6,sp,104
 820ef44:	b80b883a 	mov	r5,r23
 820ef48:	a809883a 	mov	r4,r21
 820ef4c:	820e0040 	call	820e004 <__ssprint_r>
 820ef50:	103fae1e 	bne	r2,zero,820ee0c <___svfiprintf_internal_r+0xc38>
 820ef54:	d811883a 	mov	r8,sp
 820ef58:	003cdc06 	br	820e2cc <___svfiprintf_internal_r+0xf8>
 820ef5c:	d9801a04 	addi	r6,sp,104
 820ef60:	b80b883a 	mov	r5,r23
 820ef64:	a809883a 	mov	r4,r21
 820ef68:	820e0040 	call	820e004 <__ssprint_r>
 820ef6c:	103fa71e 	bne	r2,zero,820ee0c <___svfiprintf_internal_r+0xc38>
 820ef70:	d8c01c17 	ldw	r3,112(sp)
 820ef74:	d8801b17 	ldw	r2,108(sp)
 820ef78:	d811883a 	mov	r8,sp
 820ef7c:	003f5a06 	br	820ece8 <___svfiprintf_internal_r+0xb14>
 820ef80:	d9801a04 	addi	r6,sp,104
 820ef84:	b80b883a 	mov	r5,r23
 820ef88:	a809883a 	mov	r4,r21
 820ef8c:	820e0040 	call	820e004 <__ssprint_r>
 820ef90:	103f9e1e 	bne	r2,zero,820ee0c <___svfiprintf_internal_r+0xc38>
 820ef94:	d8c01c17 	ldw	r3,112(sp)
 820ef98:	d8801b17 	ldw	r2,108(sp)
 820ef9c:	d811883a 	mov	r8,sp
 820efa0:	003f1706 	br	820ec00 <___svfiprintf_internal_r+0xa2c>
 820efa4:	d9801a04 	addi	r6,sp,104
 820efa8:	b80b883a 	mov	r5,r23
 820efac:	a809883a 	mov	r4,r21
 820efb0:	820e0040 	call	820e004 <__ssprint_r>
 820efb4:	103f951e 	bne	r2,zero,820ee0c <___svfiprintf_internal_r+0xc38>
 820efb8:	d8c01c17 	ldw	r3,112(sp)
 820efbc:	d8801b17 	ldw	r2,108(sp)
 820efc0:	d811883a 	mov	r8,sp
 820efc4:	003f1b06 	br	820ec34 <___svfiprintf_internal_r+0xa60>
 820efc8:	d8001d85 	stb	zero,118(sp)
 820efcc:	80007b16 	blt	r16,zero,820f1bc <___svfiprintf_internal_r+0xfe8>
 820efd0:	00ffdfc4 	movi	r3,-129
 820efd4:	e244b03a 	or	r2,fp,r9
 820efd8:	90e4703a 	and	r18,r18,r3
 820efdc:	103d7026 	beq	r2,zero,820e5a0 <___svfiprintf_internal_r+0x3cc>
 820efe0:	0015883a 	mov	r10,zero
 820efe4:	003d7206 	br	820e5b0 <___svfiprintf_internal_r+0x3dc>
 820efe8:	d9801a04 	addi	r6,sp,104
 820efec:	b80b883a 	mov	r5,r23
 820eff0:	a809883a 	mov	r4,r21
 820eff4:	820e0040 	call	820e004 <__ssprint_r>
 820eff8:	103f841e 	bne	r2,zero,820ee0c <___svfiprintf_internal_r+0xc38>
 820effc:	d8c01c17 	ldw	r3,112(sp)
 820f000:	d8801b17 	ldw	r2,108(sp)
 820f004:	d811883a 	mov	r8,sp
 820f008:	003ef006 	br	820ebcc <___svfiprintf_internal_r+0x9f8>
 820f00c:	9080100c 	andi	r2,r18,64
 820f010:	d8001d85 	stb	zero,118(sp)
 820f014:	dac02317 	ldw	r11,140(sp)
 820f018:	10008126 	beq	r2,zero,820f220 <___svfiprintf_internal_r+0x104c>
 820f01c:	58800104 	addi	r2,r11,4
 820f020:	5f00000b 	ldhu	fp,0(r11)
 820f024:	0013883a 	mov	r9,zero
 820f028:	803ec30e 	bge	r16,zero,820eb38 <___svfiprintf_internal_r+0x964>
 820f02c:	d8802315 	stw	r2,140(sp)
 820f030:	0015883a 	mov	r10,zero
 820f034:	e244b03a 	or	r2,fp,r9
 820f038:	103e371e 	bne	r2,zero,820e918 <___svfiprintf_internal_r+0x744>
 820f03c:	00800044 	movi	r2,1
 820f040:	10803fcc 	andi	r2,r2,255
 820f044:	00c00044 	movi	r3,1
 820f048:	10c06126 	beq	r2,r3,820f1d0 <___svfiprintf_internal_r+0xffc>
 820f04c:	00c00084 	movi	r3,2
 820f050:	10fd5526 	beq	r2,r3,820e5a8 <___svfiprintf_internal_r+0x3d4>
 820f054:	003ed806 	br	820ebb8 <___svfiprintf_internal_r+0x9e4>
 820f058:	d8802315 	stw	r2,140(sp)
 820f05c:	98c00007 	ldb	r3,0(r19)
 820f060:	003cab06 	br	820e310 <___svfiprintf_internal_r+0x13c>
 820f064:	d9801a04 	addi	r6,sp,104
 820f068:	b80b883a 	mov	r5,r23
 820f06c:	a809883a 	mov	r4,r21
 820f070:	820e0040 	call	820e004 <__ssprint_r>
 820f074:	103f651e 	bne	r2,zero,820ee0c <___svfiprintf_internal_r+0xc38>
 820f078:	d8c01c17 	ldw	r3,112(sp)
 820f07c:	003f4f06 	br	820edbc <___svfiprintf_internal_r+0xbe8>
 820f080:	00820974 	movhi	r2,2085
 820f084:	10b6cc04 	addi	r2,r2,-9424
 820f088:	d8802915 	stw	r2,164(sp)
 820f08c:	003d4406 	br	820e5a0 <___svfiprintf_internal_r+0x3cc>
 820f090:	dac02317 	ldw	r11,140(sp)
 820f094:	58800017 	ldw	r2,0(r11)
 820f098:	dac02517 	ldw	r11,148(sp)
 820f09c:	5807d7fa 	srai	r3,r11,31
 820f0a0:	dac02317 	ldw	r11,140(sp)
 820f0a4:	10c00115 	stw	r3,4(r2)
 820f0a8:	5ac00104 	addi	r11,r11,4
 820f0ac:	dac02315 	stw	r11,140(sp)
 820f0b0:	dac02517 	ldw	r11,148(sp)
 820f0b4:	12c00015 	stw	r11,0(r2)
 820f0b8:	003c6d06 	br	820e270 <___svfiprintf_internal_r+0x9c>
 820f0bc:	9080100c 	andi	r2,r18,64
 820f0c0:	dac02317 	ldw	r11,140(sp)
 820f0c4:	103e5326 	beq	r2,zero,820ea14 <___svfiprintf_internal_r+0x840>
 820f0c8:	5f00000f 	ldh	fp,0(r11)
 820f0cc:	5ac00104 	addi	r11,r11,4
 820f0d0:	dac02315 	stw	r11,140(sp)
 820f0d4:	e013d7fa 	srai	r9,fp,31
 820f0d8:	4805883a 	mov	r2,r9
 820f0dc:	003e0706 	br	820e8fc <___svfiprintf_internal_r+0x728>
 820f0e0:	00800c04 	movi	r2,48
 820f0e4:	d8801d05 	stb	r2,116(sp)
 820f0e8:	d8c01d45 	stb	r3,117(sp)
 820f0ec:	d8001d85 	stb	zero,118(sp)
 820f0f0:	90800094 	ori	r2,r18,2
 820f0f4:	80008f16 	blt	r16,zero,820f334 <___svfiprintf_internal_r+0x1160>
 820f0f8:	00bfdfc4 	movi	r2,-129
 820f0fc:	90a4703a 	and	r18,r18,r2
 820f100:	94800094 	ori	r18,r18,2
 820f104:	0015883a 	mov	r10,zero
 820f108:	003d2906 	br	820e5b0 <___svfiprintf_internal_r+0x3dc>
 820f10c:	98c00007 	ldb	r3,0(r19)
 820f110:	003c7f06 	br	820e310 <___svfiprintf_internal_r+0x13c>
 820f114:	dac02317 	ldw	r11,140(sp)
 820f118:	0013883a 	mov	r9,zero
 820f11c:	5f000017 	ldw	fp,0(r11)
 820f120:	5ac00104 	addi	r11,r11,4
 820f124:	dac02315 	stw	r11,140(sp)
 820f128:	003d1506 	br	820e580 <___svfiprintf_internal_r+0x3ac>
 820f12c:	9080100c 	andi	r2,r18,64
 820f130:	d8001d85 	stb	zero,118(sp)
 820f134:	dac02317 	ldw	r11,140(sp)
 820f138:	10003426 	beq	r2,zero,820f20c <___svfiprintf_internal_r+0x1038>
 820f13c:	58800104 	addi	r2,r11,4
 820f140:	5f00000b 	ldhu	fp,0(r11)
 820f144:	0013883a 	mov	r9,zero
 820f148:	803e950e 	bge	r16,zero,820eba0 <___svfiprintf_internal_r+0x9cc>
 820f14c:	e246b03a 	or	r3,fp,r9
 820f150:	d8802315 	stw	r2,140(sp)
 820f154:	183d5a1e 	bne	r3,zero,820e6c0 <___svfiprintf_internal_r+0x4ec>
 820f158:	0015883a 	mov	r10,zero
 820f15c:	0005883a 	mov	r2,zero
 820f160:	003fb706 	br	820f040 <___svfiprintf_internal_r+0xe6c>
 820f164:	98c00043 	ldbu	r3,1(r19)
 820f168:	94800814 	ori	r18,r18,32
 820f16c:	9cc00044 	addi	r19,r19,1
 820f170:	18c03fcc 	andi	r3,r3,255
 820f174:	18c0201c 	xori	r3,r3,128
 820f178:	18ffe004 	addi	r3,r3,-128
 820f17c:	003c6406 	br	820e310 <___svfiprintf_internal_r+0x13c>
 820f180:	d8c02315 	stw	r3,140(sp)
 820f184:	0015883a 	mov	r10,zero
 820f188:	003faa06 	br	820f034 <___svfiprintf_internal_r+0xe60>
 820f18c:	dac02317 	ldw	r11,140(sp)
 820f190:	58800017 	ldw	r2,0(r11)
 820f194:	5ac00104 	addi	r11,r11,4
 820f198:	dac02315 	stw	r11,140(sp)
 820f19c:	dac02517 	ldw	r11,148(sp)
 820f1a0:	12c00015 	stw	r11,0(r2)
 820f1a4:	003c3206 	br	820e270 <___svfiprintf_internal_r+0x9c>
 820f1a8:	01020974 	movhi	r4,2085
 820f1ac:	2136cc04 	addi	r4,r4,-9424
 820f1b0:	d9002915 	stw	r4,164(sp)
 820f1b4:	d8c02315 	stw	r3,140(sp)
 820f1b8:	1025883a 	mov	r18,r2
 820f1bc:	e244b03a 	or	r2,fp,r9
 820f1c0:	103f871e 	bne	r2,zero,820efe0 <___svfiprintf_internal_r+0xe0c>
 820f1c4:	0015883a 	mov	r10,zero
 820f1c8:	00800084 	movi	r2,2
 820f1cc:	003f9c06 	br	820f040 <___svfiprintf_internal_r+0xe6c>
 820f1d0:	0039883a 	mov	fp,zero
 820f1d4:	003e5f06 	br	820eb54 <___svfiprintf_internal_r+0x980>
 820f1d8:	d9801a04 	addi	r6,sp,104
 820f1dc:	b80b883a 	mov	r5,r23
 820f1e0:	a809883a 	mov	r4,r21
 820f1e4:	820e0040 	call	820e004 <__ssprint_r>
 820f1e8:	103f081e 	bne	r2,zero,820ee0c <___svfiprintf_internal_r+0xc38>
 820f1ec:	d8c01c17 	ldw	r3,112(sp)
 820f1f0:	d8801b17 	ldw	r2,108(sp)
 820f1f4:	d811883a 	mov	r8,sp
 820f1f8:	003e9106 	br	820ec40 <___svfiprintf_internal_r+0xa6c>
 820f1fc:	01020974 	movhi	r4,2085
 820f200:	21373404 	addi	r4,r4,-9008
 820f204:	d9002215 	stw	r4,136(sp)
 820f208:	003ead06 	br	820ecc0 <___svfiprintf_internal_r+0xaec>
 820f20c:	58800104 	addi	r2,r11,4
 820f210:	5f000017 	ldw	fp,0(r11)
 820f214:	0013883a 	mov	r9,zero
 820f218:	803e610e 	bge	r16,zero,820eba0 <___svfiprintf_internal_r+0x9cc>
 820f21c:	003fcb06 	br	820f14c <___svfiprintf_internal_r+0xf78>
 820f220:	58800104 	addi	r2,r11,4
 820f224:	5f000017 	ldw	fp,0(r11)
 820f228:	0013883a 	mov	r9,zero
 820f22c:	803e420e 	bge	r16,zero,820eb38 <___svfiprintf_internal_r+0x964>
 820f230:	003f7e06 	br	820f02c <___svfiprintf_internal_r+0xe58>
 820f234:	5f000017 	ldw	fp,0(r11)
 820f238:	5ac00104 	addi	r11,r11,4
 820f23c:	0013883a 	mov	r9,zero
 820f240:	dac02315 	stw	r11,140(sp)
 820f244:	003cce06 	br	820e580 <___svfiprintf_internal_r+0x3ac>
 820f248:	8809883a 	mov	r4,r17
 820f24c:	da002c15 	stw	r8,176(sp)
 820f250:	8203edc0 	call	8203edc <strlen>
 820f254:	d8802115 	stw	r2,132(sp)
 820f258:	da801d83 	ldbu	r10,118(sp)
 820f25c:	df002315 	stw	fp,140(sp)
 820f260:	0021883a 	mov	r16,zero
 820f264:	da002c17 	ldw	r8,176(sp)
 820f268:	003cf606 	br	820e644 <___svfiprintf_internal_r+0x470>
 820f26c:	00800184 	movi	r2,6
 820f270:	1400012e 	bgeu	r2,r16,820f278 <___svfiprintf_internal_r+0x10a4>
 820f274:	1021883a 	mov	r16,r2
 820f278:	dc002115 	stw	r16,132(sp)
 820f27c:	8005883a 	mov	r2,r16
 820f280:	80003c16 	blt	r16,zero,820f374 <___svfiprintf_internal_r+0x11a0>
 820f284:	04420974 	movhi	r17,2085
 820f288:	d8802015 	stw	r2,128(sp)
 820f28c:	df002315 	stw	fp,140(sp)
 820f290:	8c76d104 	addi	r17,r17,-9404
 820f294:	003d2e06 	br	820e750 <___svfiprintf_internal_r+0x57c>
 820f298:	04001004 	movi	r16,64
 820f29c:	800b883a 	mov	r5,r16
 820f2a0:	820bc680 	call	820bc68 <_malloc_r>
 820f2a4:	dac02717 	ldw	r11,156(sp)
 820f2a8:	58800015 	stw	r2,0(r11)
 820f2ac:	58800415 	stw	r2,16(r11)
 820f2b0:	10004826 	beq	r2,zero,820f3d4 <___svfiprintf_internal_r+0x1200>
 820f2b4:	dac02717 	ldw	r11,156(sp)
 820f2b8:	5c000515 	stw	r16,20(r11)
 820f2bc:	003bd906 	br	820e224 <___svfiprintf_internal_r+0x50>
 820f2c0:	9080004c 	andi	r2,r18,1
 820f2c4:	0015883a 	mov	r10,zero
 820f2c8:	10000626 	beq	r2,zero,820f2e4 <___svfiprintf_internal_r+0x1110>
 820f2cc:	dac02b17 	ldw	r11,172(sp)
 820f2d0:	00800c04 	movi	r2,48
 820f2d4:	d88019c5 	stb	r2,103(sp)
 820f2d8:	dac02115 	stw	r11,132(sp)
 820f2dc:	dc4019c4 	addi	r17,sp,103
 820f2e0:	003cd806 	br	820e644 <___svfiprintf_internal_r+0x470>
 820f2e4:	d8002115 	stw	zero,132(sp)
 820f2e8:	dc401a04 	addi	r17,sp,104
 820f2ec:	003cd506 	br	820e644 <___svfiprintf_internal_r+0x470>
 820f2f0:	01020974 	movhi	r4,2085
 820f2f4:	21373804 	addi	r4,r4,-8992
 820f2f8:	d9002815 	stw	r4,160(sp)
 820f2fc:	003d4306 	br	820e80c <___svfiprintf_internal_r+0x638>
 820f300:	00bfffc4 	movi	r2,-1
 820f304:	003ec606 	br	820ee20 <___svfiprintf_internal_r+0xc4c>
 820f308:	00800044 	movi	r2,1
 820f30c:	10803fcc 	andi	r2,r2,255
 820f310:	00c00044 	movi	r3,1
 820f314:	10fd8026 	beq	r2,r3,820e918 <___svfiprintf_internal_r+0x744>
 820f318:	00c00084 	movi	r3,2
 820f31c:	10fca426 	beq	r2,r3,820e5b0 <___svfiprintf_internal_r+0x3dc>
 820f320:	003ce806 	br	820e6c4 <___svfiprintf_internal_r+0x4f0>
 820f324:	01020974 	movhi	r4,2085
 820f328:	21373804 	addi	r4,r4,-8992
 820f32c:	d9002815 	stw	r4,160(sp)
 820f330:	003e9906 	br	820ed98 <___svfiprintf_internal_r+0xbc4>
 820f334:	1025883a 	mov	r18,r2
 820f338:	0015883a 	mov	r10,zero
 820f33c:	00800084 	movi	r2,2
 820f340:	003ff206 	br	820f30c <___svfiprintf_internal_r+0x1138>
 820f344:	01420974 	movhi	r5,2085
 820f348:	29773404 	addi	r5,r5,-9008
 820f34c:	d9402215 	stw	r5,136(sp)
 820f350:	003ee206 	br	820eedc <___svfiprintf_internal_r+0xd08>
 820f354:	5827883a 	mov	r19,r11
 820f358:	0021883a 	mov	r16,zero
 820f35c:	003bed06 	br	820e314 <___svfiprintf_internal_r+0x140>
 820f360:	dc002115 	stw	r16,132(sp)
 820f364:	da801d83 	ldbu	r10,118(sp)
 820f368:	df002315 	stw	fp,140(sp)
 820f36c:	0021883a 	mov	r16,zero
 820f370:	003cb406 	br	820e644 <___svfiprintf_internal_r+0x470>
 820f374:	0005883a 	mov	r2,zero
 820f378:	003fc206 	br	820f284 <___svfiprintf_internal_r+0x10b0>
 820f37c:	d8802317 	ldw	r2,140(sp)
 820f380:	98c00043 	ldbu	r3,1(r19)
 820f384:	5827883a 	mov	r19,r11
 820f388:	14000017 	ldw	r16,0(r2)
 820f38c:	10800104 	addi	r2,r2,4
 820f390:	d8802315 	stw	r2,140(sp)
 820f394:	803f760e 	bge	r16,zero,820f170 <___svfiprintf_internal_r+0xf9c>
 820f398:	18c03fcc 	andi	r3,r3,255
 820f39c:	18c0201c 	xori	r3,r3,128
 820f3a0:	043fffc4 	movi	r16,-1
 820f3a4:	18ffe004 	addi	r3,r3,-128
 820f3a8:	003bd906 	br	820e310 <___svfiprintf_internal_r+0x13c>
 820f3ac:	d9c01d85 	stb	r7,118(sp)
 820f3b0:	003cb606 	br	820e68c <___svfiprintf_internal_r+0x4b8>
 820f3b4:	d9c01d85 	stb	r7,118(sp)
 820f3b8:	003d2106 	br	820e840 <___svfiprintf_internal_r+0x66c>
 820f3bc:	d9c01d85 	stb	r7,118(sp)
 820f3c0:	003d8e06 	br	820e9fc <___svfiprintf_internal_r+0x828>
 820f3c4:	d9c01d85 	stb	r7,118(sp)
 820f3c8:	003db306 	br	820ea98 <___svfiprintf_internal_r+0x8c4>
 820f3cc:	d9c01d85 	stb	r7,118(sp)
 820f3d0:	003c8a06 	br	820e5fc <___svfiprintf_internal_r+0x428>
 820f3d4:	dac02a17 	ldw	r11,168(sp)
 820f3d8:	00800304 	movi	r2,12
 820f3dc:	58800015 	stw	r2,0(r11)
 820f3e0:	00bfffc4 	movi	r2,-1
 820f3e4:	003e8e06 	br	820ee20 <___svfiprintf_internal_r+0xc4c>
 820f3e8:	d9c01d85 	stb	r7,118(sp)
 820f3ec:	003dc706 	br	820eb0c <___svfiprintf_internal_r+0x938>
 820f3f0:	d9c01d85 	stb	r7,118(sp)
 820f3f4:	003ddf06 	br	820eb74 <___svfiprintf_internal_r+0x9a0>
 820f3f8:	d9c01d85 	stb	r7,118(sp)
 820f3fc:	003d3706 	br	820e8dc <___svfiprintf_internal_r+0x708>
 820f400:	d9c01d85 	stb	r7,118(sp)
 820f404:	003c5406 	br	820e558 <___svfiprintf_internal_r+0x384>
 820f408:	d9c01d85 	stb	r7,118(sp)
 820f40c:	003d1d06 	br	820e884 <___svfiprintf_internal_r+0x6b0>

0820f410 <__sprint_r.part.0>:
 820f410:	28801917 	ldw	r2,100(r5)
 820f414:	defff604 	addi	sp,sp,-40
 820f418:	dd400515 	stw	r21,20(sp)
 820f41c:	dfc00915 	stw	ra,36(sp)
 820f420:	df000815 	stw	fp,32(sp)
 820f424:	ddc00715 	stw	r23,28(sp)
 820f428:	dd800615 	stw	r22,24(sp)
 820f42c:	dd000415 	stw	r20,16(sp)
 820f430:	dcc00315 	stw	r19,12(sp)
 820f434:	dc800215 	stw	r18,8(sp)
 820f438:	dc400115 	stw	r17,4(sp)
 820f43c:	dc000015 	stw	r16,0(sp)
 820f440:	1088000c 	andi	r2,r2,8192
 820f444:	302b883a 	mov	r21,r6
 820f448:	10002e26 	beq	r2,zero,820f504 <__sprint_r.part.0+0xf4>
 820f44c:	30800217 	ldw	r2,8(r6)
 820f450:	35800017 	ldw	r22,0(r6)
 820f454:	10002926 	beq	r2,zero,820f4fc <__sprint_r.part.0+0xec>
 820f458:	2827883a 	mov	r19,r5
 820f45c:	2029883a 	mov	r20,r4
 820f460:	b5c00104 	addi	r23,r22,4
 820f464:	04bfffc4 	movi	r18,-1
 820f468:	bc400017 	ldw	r17,0(r23)
 820f46c:	b4000017 	ldw	r16,0(r22)
 820f470:	0039883a 	mov	fp,zero
 820f474:	8822d0ba 	srli	r17,r17,2
 820f478:	8800031e 	bne	r17,zero,820f488 <__sprint_r.part.0+0x78>
 820f47c:	00001806 	br	820f4e0 <__sprint_r.part.0+0xd0>
 820f480:	84000104 	addi	r16,r16,4
 820f484:	8f001526 	beq	r17,fp,820f4dc <__sprint_r.part.0+0xcc>
 820f488:	81400017 	ldw	r5,0(r16)
 820f48c:	980d883a 	mov	r6,r19
 820f490:	a009883a 	mov	r4,r20
 820f494:	8210e380 	call	8210e38 <_fputwc_r>
 820f498:	e7000044 	addi	fp,fp,1
 820f49c:	14bff81e 	bne	r2,r18,820f480 <__sprint_r.part.0+0x70>
 820f4a0:	9005883a 	mov	r2,r18
 820f4a4:	a8000215 	stw	zero,8(r21)
 820f4a8:	a8000115 	stw	zero,4(r21)
 820f4ac:	dfc00917 	ldw	ra,36(sp)
 820f4b0:	df000817 	ldw	fp,32(sp)
 820f4b4:	ddc00717 	ldw	r23,28(sp)
 820f4b8:	dd800617 	ldw	r22,24(sp)
 820f4bc:	dd400517 	ldw	r21,20(sp)
 820f4c0:	dd000417 	ldw	r20,16(sp)
 820f4c4:	dcc00317 	ldw	r19,12(sp)
 820f4c8:	dc800217 	ldw	r18,8(sp)
 820f4cc:	dc400117 	ldw	r17,4(sp)
 820f4d0:	dc000017 	ldw	r16,0(sp)
 820f4d4:	dec00a04 	addi	sp,sp,40
 820f4d8:	f800283a 	ret
 820f4dc:	a8800217 	ldw	r2,8(r21)
 820f4e0:	8c63883a 	add	r17,r17,r17
 820f4e4:	8c63883a 	add	r17,r17,r17
 820f4e8:	1445c83a 	sub	r2,r2,r17
 820f4ec:	a8800215 	stw	r2,8(r21)
 820f4f0:	b5800204 	addi	r22,r22,8
 820f4f4:	bdc00204 	addi	r23,r23,8
 820f4f8:	103fdb1e 	bne	r2,zero,820f468 <__sprint_r.part.0+0x58>
 820f4fc:	0005883a 	mov	r2,zero
 820f500:	003fe806 	br	820f4a4 <__sprint_r.part.0+0x94>
 820f504:	820b38c0 	call	820b38c <__sfvwrite_r>
 820f508:	003fe606 	br	820f4a4 <__sprint_r.part.0+0x94>

0820f50c <__sprint_r>:
 820f50c:	30c00217 	ldw	r3,8(r6)
 820f510:	18000126 	beq	r3,zero,820f518 <__sprint_r+0xc>
 820f514:	820f4101 	jmpi	820f410 <__sprint_r.part.0>
 820f518:	30000115 	stw	zero,4(r6)
 820f51c:	0005883a 	mov	r2,zero
 820f520:	f800283a 	ret

0820f524 <___vfiprintf_internal_r>:
 820f524:	deffc904 	addi	sp,sp,-220
 820f528:	df003515 	stw	fp,212(sp)
 820f52c:	dd003115 	stw	r20,196(sp)
 820f530:	dfc03615 	stw	ra,216(sp)
 820f534:	ddc03415 	stw	r23,208(sp)
 820f538:	dd803315 	stw	r22,204(sp)
 820f53c:	dd403215 	stw	r21,200(sp)
 820f540:	dcc03015 	stw	r19,192(sp)
 820f544:	dc802f15 	stw	r18,188(sp)
 820f548:	dc402e15 	stw	r17,184(sp)
 820f54c:	dc002d15 	stw	r16,180(sp)
 820f550:	d9002015 	stw	r4,128(sp)
 820f554:	d9c02215 	stw	r7,136(sp)
 820f558:	2829883a 	mov	r20,r5
 820f55c:	3039883a 	mov	fp,r6
 820f560:	20000226 	beq	r4,zero,820f56c <___vfiprintf_internal_r+0x48>
 820f564:	20800e17 	ldw	r2,56(r4)
 820f568:	1000cf26 	beq	r2,zero,820f8a8 <___vfiprintf_internal_r+0x384>
 820f56c:	a080030b 	ldhu	r2,12(r20)
 820f570:	10c8000c 	andi	r3,r2,8192
 820f574:	1800061e 	bne	r3,zero,820f590 <___vfiprintf_internal_r+0x6c>
 820f578:	a1001917 	ldw	r4,100(r20)
 820f57c:	00f7ffc4 	movi	r3,-8193
 820f580:	10880014 	ori	r2,r2,8192
 820f584:	20c6703a 	and	r3,r4,r3
 820f588:	a080030d 	sth	r2,12(r20)
 820f58c:	a0c01915 	stw	r3,100(r20)
 820f590:	10c0020c 	andi	r3,r2,8
 820f594:	1800a926 	beq	r3,zero,820f83c <___vfiprintf_internal_r+0x318>
 820f598:	a0c00417 	ldw	r3,16(r20)
 820f59c:	1800a726 	beq	r3,zero,820f83c <___vfiprintf_internal_r+0x318>
 820f5a0:	1080068c 	andi	r2,r2,26
 820f5a4:	00c00284 	movi	r3,10
 820f5a8:	10c0ac26 	beq	r2,r3,820f85c <___vfiprintf_internal_r+0x338>
 820f5ac:	da801a04 	addi	r10,sp,104
 820f5b0:	da801e15 	stw	r10,120(sp)
 820f5b4:	d8801e17 	ldw	r2,120(sp)
 820f5b8:	da8019c4 	addi	r10,sp,103
 820f5bc:	05820974 	movhi	r22,2085
 820f5c0:	05c20974 	movhi	r23,2085
 820f5c4:	da801f15 	stw	r10,124(sp)
 820f5c8:	1295c83a 	sub	r10,r2,r10
 820f5cc:	b5b74004 	addi	r22,r22,-8960
 820f5d0:	bdf73c04 	addi	r23,r23,-8976
 820f5d4:	dec01a15 	stw	sp,104(sp)
 820f5d8:	d8001c15 	stw	zero,112(sp)
 820f5dc:	d8001b15 	stw	zero,108(sp)
 820f5e0:	d8002615 	stw	zero,152(sp)
 820f5e4:	d8002315 	stw	zero,140(sp)
 820f5e8:	da802715 	stw	r10,156(sp)
 820f5ec:	d811883a 	mov	r8,sp
 820f5f0:	dd002115 	stw	r20,132(sp)
 820f5f4:	e021883a 	mov	r16,fp
 820f5f8:	80800007 	ldb	r2,0(r16)
 820f5fc:	1003ea26 	beq	r2,zero,82105a8 <___vfiprintf_internal_r+0x1084>
 820f600:	00c00944 	movi	r3,37
 820f604:	8025883a 	mov	r18,r16
 820f608:	10c0021e 	bne	r2,r3,820f614 <___vfiprintf_internal_r+0xf0>
 820f60c:	00001606 	br	820f668 <___vfiprintf_internal_r+0x144>
 820f610:	10c00326 	beq	r2,r3,820f620 <___vfiprintf_internal_r+0xfc>
 820f614:	94800044 	addi	r18,r18,1
 820f618:	90800007 	ldb	r2,0(r18)
 820f61c:	103ffc1e 	bne	r2,zero,820f610 <___vfiprintf_internal_r+0xec>
 820f620:	9423c83a 	sub	r17,r18,r16
 820f624:	88001026 	beq	r17,zero,820f668 <___vfiprintf_internal_r+0x144>
 820f628:	d8c01c17 	ldw	r3,112(sp)
 820f62c:	d8801b17 	ldw	r2,108(sp)
 820f630:	44000015 	stw	r16,0(r8)
 820f634:	88c7883a 	add	r3,r17,r3
 820f638:	10800044 	addi	r2,r2,1
 820f63c:	44400115 	stw	r17,4(r8)
 820f640:	d8c01c15 	stw	r3,112(sp)
 820f644:	d8801b15 	stw	r2,108(sp)
 820f648:	010001c4 	movi	r4,7
 820f64c:	2080760e 	bge	r4,r2,820f828 <___vfiprintf_internal_r+0x304>
 820f650:	1803821e 	bne	r3,zero,821045c <___vfiprintf_internal_r+0xf38>
 820f654:	da802317 	ldw	r10,140(sp)
 820f658:	d8001b15 	stw	zero,108(sp)
 820f65c:	d811883a 	mov	r8,sp
 820f660:	5455883a 	add	r10,r10,r17
 820f664:	da802315 	stw	r10,140(sp)
 820f668:	90800007 	ldb	r2,0(r18)
 820f66c:	10044626 	beq	r2,zero,8210788 <___vfiprintf_internal_r+0x1264>
 820f670:	90c00047 	ldb	r3,1(r18)
 820f674:	94000044 	addi	r16,r18,1
 820f678:	d8001d85 	stb	zero,118(sp)
 820f67c:	0009883a 	mov	r4,zero
 820f680:	000f883a 	mov	r7,zero
 820f684:	027fffc4 	movi	r9,-1
 820f688:	0023883a 	mov	r17,zero
 820f68c:	0029883a 	mov	r20,zero
 820f690:	01401604 	movi	r5,88
 820f694:	01800244 	movi	r6,9
 820f698:	03400a84 	movi	r13,42
 820f69c:	03001b04 	movi	r12,108
 820f6a0:	84000044 	addi	r16,r16,1
 820f6a4:	18bff804 	addi	r2,r3,-32
 820f6a8:	28827336 	bltu	r5,r2,8210078 <___vfiprintf_internal_r+0xb54>
 820f6ac:	100490ba 	slli	r2,r2,2
 820f6b0:	02820874 	movhi	r10,2081
 820f6b4:	52bdb104 	addi	r10,r10,-2364
 820f6b8:	1285883a 	add	r2,r2,r10
 820f6bc:	10800017 	ldw	r2,0(r2)
 820f6c0:	1000683a 	jmp	r2
 820f6c4:	0820fdac 	andhi	zero,at,33782
 820f6c8:	08210078 	rdprs	zero,at,-31743
 820f6cc:	08210078 	rdprs	zero,at,-31743
 820f6d0:	0820fdcc 	andi	zero,at,33783
 820f6d4:	08210078 	rdprs	zero,at,-31743
 820f6d8:	08210078 	rdprs	zero,at,-31743
 820f6dc:	08210078 	rdprs	zero,at,-31743
 820f6e0:	08210078 	rdprs	zero,at,-31743
 820f6e4:	08210078 	rdprs	zero,at,-31743
 820f6e8:	08210078 	rdprs	zero,at,-31743
 820f6ec:	0820ffb4 	orhi	zero,at,33790
 820f6f0:	0820ffd0 	cmplti	zero,at,-31745
 820f6f4:	08210078 	rdprs	zero,at,-31743
 820f6f8:	0820f8b8 	rdprs	zero,at,-31774
 820f6fc:	0820ffe0 	cmpeqi	zero,at,-31745
 820f700:	08210078 	rdprs	zero,at,-31743
 820f704:	0820fdd8 	cmpnei	zero,at,-31753
 820f708:	0820fde4 	muli	zero,at,-31753
 820f70c:	0820fde4 	muli	zero,at,-31753
 820f710:	0820fde4 	muli	zero,at,-31753
 820f714:	0820fde4 	muli	zero,at,-31753
 820f718:	0820fde4 	muli	zero,at,-31753
 820f71c:	0820fde4 	muli	zero,at,-31753
 820f720:	0820fde4 	muli	zero,at,-31753
 820f724:	0820fde4 	muli	zero,at,-31753
 820f728:	0820fde4 	muli	zero,at,-31753
 820f72c:	08210078 	rdprs	zero,at,-31743
 820f730:	08210078 	rdprs	zero,at,-31743
 820f734:	08210078 	rdprs	zero,at,-31743
 820f738:	08210078 	rdprs	zero,at,-31743
 820f73c:	08210078 	rdprs	zero,at,-31743
 820f740:	08210078 	rdprs	zero,at,-31743
 820f744:	08210078 	rdprs	zero,at,-31743
 820f748:	08210078 	rdprs	zero,at,-31743
 820f74c:	08210078 	rdprs	zero,at,-31743
 820f750:	08210078 	rdprs	zero,at,-31743
 820f754:	0820fe10 	cmplti	zero,at,-31752
 820f758:	08210078 	rdprs	zero,at,-31743
 820f75c:	08210078 	rdprs	zero,at,-31743
 820f760:	08210078 	rdprs	zero,at,-31743
 820f764:	08210078 	rdprs	zero,at,-31743
 820f768:	08210078 	rdprs	zero,at,-31743
 820f76c:	08210078 	rdprs	zero,at,-31743
 820f770:	08210078 	rdprs	zero,at,-31743
 820f774:	08210078 	rdprs	zero,at,-31743
 820f778:	08210078 	rdprs	zero,at,-31743
 820f77c:	08210078 	rdprs	zero,at,-31743
 820f780:	0820fe48 	cmpgei	zero,at,-31751
 820f784:	08210078 	rdprs	zero,at,-31743
 820f788:	08210078 	rdprs	zero,at,-31743
 820f78c:	08210078 	rdprs	zero,at,-31743
 820f790:	08210078 	rdprs	zero,at,-31743
 820f794:	08210078 	rdprs	zero,at,-31743
 820f798:	0820fea0 	cmpeqi	zero,at,-31750
 820f79c:	08210078 	rdprs	zero,at,-31743
 820f7a0:	08210078 	rdprs	zero,at,-31743
 820f7a4:	0820ff10 	cmplti	zero,at,-31748
 820f7a8:	08210078 	rdprs	zero,at,-31743
 820f7ac:	08210078 	rdprs	zero,at,-31743
 820f7b0:	08210078 	rdprs	zero,at,-31743
 820f7b4:	08210078 	rdprs	zero,at,-31743
 820f7b8:	08210078 	rdprs	zero,at,-31743
 820f7bc:	08210078 	rdprs	zero,at,-31743
 820f7c0:	08210078 	rdprs	zero,at,-31743
 820f7c4:	08210078 	rdprs	zero,at,-31743
 820f7c8:	08210078 	rdprs	zero,at,-31743
 820f7cc:	08210078 	rdprs	zero,at,-31743
 820f7d0:	0820fcbc 	xorhi	zero,at,33778
 820f7d4:	0820fce8 	cmpgeui	zero,at,33779
 820f7d8:	08210078 	rdprs	zero,at,-31743
 820f7dc:	08210078 	rdprs	zero,at,-31743
 820f7e0:	08210078 	rdprs	zero,at,-31743
 820f7e4:	08210020 	cmpeqi	zero,at,-31744
 820f7e8:	0820fce8 	cmpgeui	zero,at,33779
 820f7ec:	08210078 	rdprs	zero,at,-31743
 820f7f0:	08210078 	rdprs	zero,at,-31743
 820f7f4:	0820fb7c 	xorhi	zero,at,33773
 820f7f8:	08210078 	rdprs	zero,at,-31743
 820f7fc:	0820fb8c 	andi	zero,at,33774
 820f800:	0820fbc8 	cmpgei	zero,at,-31761
 820f804:	0820f8c4 	addi	zero,at,-31773
 820f808:	0820fb70 	cmpltui	zero,at,33773
 820f80c:	08210078 	rdprs	zero,at,-31743
 820f810:	0820ff4c 	andi	zero,at,33789
 820f814:	08210078 	rdprs	zero,at,-31743
 820f818:	0820ffa4 	muli	zero,at,-31746
 820f81c:	08210078 	rdprs	zero,at,-31743
 820f820:	08210078 	rdprs	zero,at,-31743
 820f824:	0820fc68 	cmpgeui	zero,at,33777
 820f828:	42000204 	addi	r8,r8,8
 820f82c:	da802317 	ldw	r10,140(sp)
 820f830:	5455883a 	add	r10,r10,r17
 820f834:	da802315 	stw	r10,140(sp)
 820f838:	003f8b06 	br	820f668 <___vfiprintf_internal_r+0x144>
 820f83c:	d9002017 	ldw	r4,128(sp)
 820f840:	a00b883a 	mov	r5,r20
 820f844:	8208de00 	call	8208de0 <__swsetup_r>
 820f848:	1003b11e 	bne	r2,zero,8210710 <___vfiprintf_internal_r+0x11ec>
 820f84c:	a080030b 	ldhu	r2,12(r20)
 820f850:	00c00284 	movi	r3,10
 820f854:	1080068c 	andi	r2,r2,26
 820f858:	10ff541e 	bne	r2,r3,820f5ac <___vfiprintf_internal_r+0x88>
 820f85c:	a080038f 	ldh	r2,14(r20)
 820f860:	103f5216 	blt	r2,zero,820f5ac <___vfiprintf_internal_r+0x88>
 820f864:	d9c02217 	ldw	r7,136(sp)
 820f868:	d9002017 	ldw	r4,128(sp)
 820f86c:	e00d883a 	mov	r6,fp
 820f870:	a00b883a 	mov	r5,r20
 820f874:	821099c0 	call	821099c <__sbprintf>
 820f878:	dfc03617 	ldw	ra,216(sp)
 820f87c:	df003517 	ldw	fp,212(sp)
 820f880:	ddc03417 	ldw	r23,208(sp)
 820f884:	dd803317 	ldw	r22,204(sp)
 820f888:	dd403217 	ldw	r21,200(sp)
 820f88c:	dd003117 	ldw	r20,196(sp)
 820f890:	dcc03017 	ldw	r19,192(sp)
 820f894:	dc802f17 	ldw	r18,188(sp)
 820f898:	dc402e17 	ldw	r17,184(sp)
 820f89c:	dc002d17 	ldw	r16,180(sp)
 820f8a0:	dec03704 	addi	sp,sp,220
 820f8a4:	f800283a 	ret
 820f8a8:	820adb40 	call	820adb4 <__sinit>
 820f8ac:	003f2f06 	br	820f56c <___vfiprintf_internal_r+0x48>
 820f8b0:	0463c83a 	sub	r17,zero,r17
 820f8b4:	d8802215 	stw	r2,136(sp)
 820f8b8:	a5000114 	ori	r20,r20,4
 820f8bc:	80c00007 	ldb	r3,0(r16)
 820f8c0:	003f7706 	br	820f6a0 <___vfiprintf_internal_r+0x17c>
 820f8c4:	00800c04 	movi	r2,48
 820f8c8:	da802217 	ldw	r10,136(sp)
 820f8cc:	d8801d05 	stb	r2,116(sp)
 820f8d0:	00801e04 	movi	r2,120
 820f8d4:	d8801d45 	stb	r2,117(sp)
 820f8d8:	d8001d85 	stb	zero,118(sp)
 820f8dc:	50c00104 	addi	r3,r10,4
 820f8e0:	54800017 	ldw	r18,0(r10)
 820f8e4:	0027883a 	mov	r19,zero
 820f8e8:	a0800094 	ori	r2,r20,2
 820f8ec:	48030b16 	blt	r9,zero,821051c <___vfiprintf_internal_r+0xff8>
 820f8f0:	00bfdfc4 	movi	r2,-129
 820f8f4:	a096703a 	and	r11,r20,r2
 820f8f8:	d8c02215 	stw	r3,136(sp)
 820f8fc:	5d000094 	ori	r20,r11,2
 820f900:	90032b1e 	bne	r18,zero,82105b0 <___vfiprintf_internal_r+0x108c>
 820f904:	00820974 	movhi	r2,2085
 820f908:	10b6cc04 	addi	r2,r2,-9424
 820f90c:	d8802615 	stw	r2,152(sp)
 820f910:	0039883a 	mov	fp,zero
 820f914:	48017b1e 	bne	r9,zero,820ff04 <___vfiprintf_internal_r+0x9e0>
 820f918:	0013883a 	mov	r9,zero
 820f91c:	0027883a 	mov	r19,zero
 820f920:	dd401a04 	addi	r21,sp,104
 820f924:	4825883a 	mov	r18,r9
 820f928:	4cc0010e 	bge	r9,r19,820f930 <___vfiprintf_internal_r+0x40c>
 820f92c:	9825883a 	mov	r18,r19
 820f930:	e7003fcc 	andi	fp,fp,255
 820f934:	e700201c 	xori	fp,fp,128
 820f938:	e73fe004 	addi	fp,fp,-128
 820f93c:	e0000126 	beq	fp,zero,820f944 <___vfiprintf_internal_r+0x420>
 820f940:	94800044 	addi	r18,r18,1
 820f944:	a380008c 	andi	r14,r20,2
 820f948:	70000126 	beq	r14,zero,820f950 <___vfiprintf_internal_r+0x42c>
 820f94c:	94800084 	addi	r18,r18,2
 820f950:	a700210c 	andi	fp,r20,132
 820f954:	e001df1e 	bne	fp,zero,82100d4 <___vfiprintf_internal_r+0xbb0>
 820f958:	8c87c83a 	sub	r3,r17,r18
 820f95c:	00c1dd0e 	bge	zero,r3,82100d4 <___vfiprintf_internal_r+0xbb0>
 820f960:	01c00404 	movi	r7,16
 820f964:	d8801c17 	ldw	r2,112(sp)
 820f968:	38c3ad0e 	bge	r7,r3,8210820 <___vfiprintf_internal_r+0x12fc>
 820f96c:	02820974 	movhi	r10,2085
 820f970:	52b74004 	addi	r10,r10,-8960
 820f974:	dc002915 	stw	r16,164(sp)
 820f978:	d9801b17 	ldw	r6,108(sp)
 820f97c:	da802415 	stw	r10,144(sp)
 820f980:	03c001c4 	movi	r15,7
 820f984:	da402515 	stw	r9,148(sp)
 820f988:	db802815 	stw	r14,160(sp)
 820f98c:	1821883a 	mov	r16,r3
 820f990:	00000506 	br	820f9a8 <___vfiprintf_internal_r+0x484>
 820f994:	31400084 	addi	r5,r6,2
 820f998:	42000204 	addi	r8,r8,8
 820f99c:	200d883a 	mov	r6,r4
 820f9a0:	843ffc04 	addi	r16,r16,-16
 820f9a4:	3c000d0e 	bge	r7,r16,820f9dc <___vfiprintf_internal_r+0x4b8>
 820f9a8:	10800404 	addi	r2,r2,16
 820f9ac:	31000044 	addi	r4,r6,1
 820f9b0:	45800015 	stw	r22,0(r8)
 820f9b4:	41c00115 	stw	r7,4(r8)
 820f9b8:	d8801c15 	stw	r2,112(sp)
 820f9bc:	d9001b15 	stw	r4,108(sp)
 820f9c0:	793ff40e 	bge	r15,r4,820f994 <___vfiprintf_internal_r+0x470>
 820f9c4:	1001b51e 	bne	r2,zero,821009c <___vfiprintf_internal_r+0xb78>
 820f9c8:	843ffc04 	addi	r16,r16,-16
 820f9cc:	000d883a 	mov	r6,zero
 820f9d0:	01400044 	movi	r5,1
 820f9d4:	d811883a 	mov	r8,sp
 820f9d8:	3c3ff316 	blt	r7,r16,820f9a8 <___vfiprintf_internal_r+0x484>
 820f9dc:	8007883a 	mov	r3,r16
 820f9e0:	da402517 	ldw	r9,148(sp)
 820f9e4:	db802817 	ldw	r14,160(sp)
 820f9e8:	dc002917 	ldw	r16,164(sp)
 820f9ec:	da802417 	ldw	r10,144(sp)
 820f9f0:	1885883a 	add	r2,r3,r2
 820f9f4:	40c00115 	stw	r3,4(r8)
 820f9f8:	42800015 	stw	r10,0(r8)
 820f9fc:	d8801c15 	stw	r2,112(sp)
 820fa00:	d9401b15 	stw	r5,108(sp)
 820fa04:	00c001c4 	movi	r3,7
 820fa08:	19426016 	blt	r3,r5,821038c <___vfiprintf_internal_r+0xe68>
 820fa0c:	d8c01d87 	ldb	r3,118(sp)
 820fa10:	42000204 	addi	r8,r8,8
 820fa14:	29000044 	addi	r4,r5,1
 820fa18:	1801b31e 	bne	r3,zero,82100e8 <___vfiprintf_internal_r+0xbc4>
 820fa1c:	7001c026 	beq	r14,zero,8210120 <___vfiprintf_internal_r+0xbfc>
 820fa20:	d8c01d04 	addi	r3,sp,116
 820fa24:	10800084 	addi	r2,r2,2
 820fa28:	40c00015 	stw	r3,0(r8)
 820fa2c:	00c00084 	movi	r3,2
 820fa30:	40c00115 	stw	r3,4(r8)
 820fa34:	d8801c15 	stw	r2,112(sp)
 820fa38:	d9001b15 	stw	r4,108(sp)
 820fa3c:	00c001c4 	movi	r3,7
 820fa40:	1902650e 	bge	r3,r4,82103d8 <___vfiprintf_internal_r+0xeb4>
 820fa44:	10029a1e 	bne	r2,zero,82104b0 <___vfiprintf_internal_r+0xf8c>
 820fa48:	00c02004 	movi	r3,128
 820fa4c:	01000044 	movi	r4,1
 820fa50:	000b883a 	mov	r5,zero
 820fa54:	d811883a 	mov	r8,sp
 820fa58:	e0c1b31e 	bne	fp,r3,8210128 <___vfiprintf_internal_r+0xc04>
 820fa5c:	8cb9c83a 	sub	fp,r17,r18
 820fa60:	0701b10e 	bge	zero,fp,8210128 <___vfiprintf_internal_r+0xc04>
 820fa64:	01c00404 	movi	r7,16
 820fa68:	3f03890e 	bge	r7,fp,8210890 <___vfiprintf_internal_r+0x136c>
 820fa6c:	00c20974 	movhi	r3,2085
 820fa70:	18f73c04 	addi	r3,r3,-8976
 820fa74:	d8c02415 	stw	r3,144(sp)
 820fa78:	8007883a 	mov	r3,r16
 820fa7c:	034001c4 	movi	r13,7
 820fa80:	e021883a 	mov	r16,fp
 820fa84:	da402515 	stw	r9,148(sp)
 820fa88:	1839883a 	mov	fp,r3
 820fa8c:	00000506 	br	820faa4 <___vfiprintf_internal_r+0x580>
 820fa90:	29800084 	addi	r6,r5,2
 820fa94:	42000204 	addi	r8,r8,8
 820fa98:	180b883a 	mov	r5,r3
 820fa9c:	843ffc04 	addi	r16,r16,-16
 820faa0:	3c000d0e 	bge	r7,r16,820fad8 <___vfiprintf_internal_r+0x5b4>
 820faa4:	10800404 	addi	r2,r2,16
 820faa8:	28c00044 	addi	r3,r5,1
 820faac:	45c00015 	stw	r23,0(r8)
 820fab0:	41c00115 	stw	r7,4(r8)
 820fab4:	d8801c15 	stw	r2,112(sp)
 820fab8:	d8c01b15 	stw	r3,108(sp)
 820fabc:	68fff40e 	bge	r13,r3,820fa90 <___vfiprintf_internal_r+0x56c>
 820fac0:	1002241e 	bne	r2,zero,8210354 <___vfiprintf_internal_r+0xe30>
 820fac4:	843ffc04 	addi	r16,r16,-16
 820fac8:	01800044 	movi	r6,1
 820facc:	000b883a 	mov	r5,zero
 820fad0:	d811883a 	mov	r8,sp
 820fad4:	3c3ff316 	blt	r7,r16,820faa4 <___vfiprintf_internal_r+0x580>
 820fad8:	da402517 	ldw	r9,148(sp)
 820fadc:	e007883a 	mov	r3,fp
 820fae0:	8039883a 	mov	fp,r16
 820fae4:	1821883a 	mov	r16,r3
 820fae8:	d8c02417 	ldw	r3,144(sp)
 820faec:	1705883a 	add	r2,r2,fp
 820faf0:	47000115 	stw	fp,4(r8)
 820faf4:	40c00015 	stw	r3,0(r8)
 820faf8:	d8801c15 	stw	r2,112(sp)
 820fafc:	d9801b15 	stw	r6,108(sp)
 820fb00:	00c001c4 	movi	r3,7
 820fb04:	19827616 	blt	r3,r6,82104e0 <___vfiprintf_internal_r+0xfbc>
 820fb08:	4cf9c83a 	sub	fp,r9,r19
 820fb0c:	42000204 	addi	r8,r8,8
 820fb10:	31000044 	addi	r4,r6,1
 820fb14:	300b883a 	mov	r5,r6
 820fb18:	07018516 	blt	zero,fp,8210130 <___vfiprintf_internal_r+0xc0c>
 820fb1c:	9885883a 	add	r2,r19,r2
 820fb20:	45400015 	stw	r21,0(r8)
 820fb24:	44c00115 	stw	r19,4(r8)
 820fb28:	d8801c15 	stw	r2,112(sp)
 820fb2c:	d9001b15 	stw	r4,108(sp)
 820fb30:	00c001c4 	movi	r3,7
 820fb34:	1901dd0e 	bge	r3,r4,82102ac <___vfiprintf_internal_r+0xd88>
 820fb38:	1002401e 	bne	r2,zero,821043c <___vfiprintf_internal_r+0xf18>
 820fb3c:	d8001b15 	stw	zero,108(sp)
 820fb40:	a2c0010c 	andi	r11,r20,4
 820fb44:	58000226 	beq	r11,zero,820fb50 <___vfiprintf_internal_r+0x62c>
 820fb48:	8ca7c83a 	sub	r19,r17,r18
 820fb4c:	04c2f216 	blt	zero,r19,8210718 <___vfiprintf_internal_r+0x11f4>
 820fb50:	8c80010e 	bge	r17,r18,820fb58 <___vfiprintf_internal_r+0x634>
 820fb54:	9023883a 	mov	r17,r18
 820fb58:	da802317 	ldw	r10,140(sp)
 820fb5c:	5455883a 	add	r10,r10,r17
 820fb60:	da802315 	stw	r10,140(sp)
 820fb64:	d8001b15 	stw	zero,108(sp)
 820fb68:	d811883a 	mov	r8,sp
 820fb6c:	003ea206 	br	820f5f8 <___vfiprintf_internal_r+0xd4>
 820fb70:	a5000814 	ori	r20,r20,32
 820fb74:	80c00007 	ldb	r3,0(r16)
 820fb78:	003ec906 	br	820f6a0 <___vfiprintf_internal_r+0x17c>
 820fb7c:	80c00007 	ldb	r3,0(r16)
 820fb80:	1b030926 	beq	r3,r12,82107a8 <___vfiprintf_internal_r+0x1284>
 820fb84:	a5000414 	ori	r20,r20,16
 820fb88:	003ec506 	br	820f6a0 <___vfiprintf_internal_r+0x17c>
 820fb8c:	21003fcc 	andi	r4,r4,255
 820fb90:	20035e1e 	bne	r4,zero,821090c <___vfiprintf_internal_r+0x13e8>
 820fb94:	a080080c 	andi	r2,r20,32
 820fb98:	1002a526 	beq	r2,zero,8210630 <___vfiprintf_internal_r+0x110c>
 820fb9c:	da802217 	ldw	r10,136(sp)
 820fba0:	50800017 	ldw	r2,0(r10)
 820fba4:	da802317 	ldw	r10,140(sp)
 820fba8:	5007d7fa 	srai	r3,r10,31
 820fbac:	da802217 	ldw	r10,136(sp)
 820fbb0:	10c00115 	stw	r3,4(r2)
 820fbb4:	52800104 	addi	r10,r10,4
 820fbb8:	da802215 	stw	r10,136(sp)
 820fbbc:	da802317 	ldw	r10,140(sp)
 820fbc0:	12800015 	stw	r10,0(r2)
 820fbc4:	003e8c06 	br	820f5f8 <___vfiprintf_internal_r+0xd4>
 820fbc8:	21003fcc 	andi	r4,r4,255
 820fbcc:	2003511e 	bne	r4,zero,8210914 <___vfiprintf_internal_r+0x13f0>
 820fbd0:	a080080c 	andi	r2,r20,32
 820fbd4:	1000a126 	beq	r2,zero,820fe5c <___vfiprintf_internal_r+0x938>
 820fbd8:	da802217 	ldw	r10,136(sp)
 820fbdc:	d8001d85 	stb	zero,118(sp)
 820fbe0:	50800204 	addi	r2,r10,8
 820fbe4:	54800017 	ldw	r18,0(r10)
 820fbe8:	54c00117 	ldw	r19,4(r10)
 820fbec:	4802b416 	blt	r9,zero,82106c0 <___vfiprintf_internal_r+0x119c>
 820fbf0:	013fdfc4 	movi	r4,-129
 820fbf4:	94c6b03a 	or	r3,r18,r19
 820fbf8:	d8802215 	stw	r2,136(sp)
 820fbfc:	a128703a 	and	r20,r20,r4
 820fc00:	1800a226 	beq	r3,zero,820fe8c <___vfiprintf_internal_r+0x968>
 820fc04:	0039883a 	mov	fp,zero
 820fc08:	dd401a04 	addi	r21,sp,104
 820fc0c:	9006d0fa 	srli	r3,r18,3
 820fc10:	9808977a 	slli	r4,r19,29
 820fc14:	9826d0fa 	srli	r19,r19,3
 820fc18:	948001cc 	andi	r18,r18,7
 820fc1c:	90800c04 	addi	r2,r18,48
 820fc20:	ad7fffc4 	addi	r21,r21,-1
 820fc24:	20e4b03a 	or	r18,r4,r3
 820fc28:	a8800005 	stb	r2,0(r21)
 820fc2c:	94c6b03a 	or	r3,r18,r19
 820fc30:	183ff61e 	bne	r3,zero,820fc0c <___vfiprintf_internal_r+0x6e8>
 820fc34:	a0c0004c 	andi	r3,r20,1
 820fc38:	18005926 	beq	r3,zero,820fda0 <___vfiprintf_internal_r+0x87c>
 820fc3c:	10803fcc 	andi	r2,r2,255
 820fc40:	1080201c 	xori	r2,r2,128
 820fc44:	10bfe004 	addi	r2,r2,-128
 820fc48:	00c00c04 	movi	r3,48
 820fc4c:	10c05426 	beq	r2,r3,820fda0 <___vfiprintf_internal_r+0x87c>
 820fc50:	da801e17 	ldw	r10,120(sp)
 820fc54:	a8bfffc4 	addi	r2,r21,-1
 820fc58:	a8ffffc5 	stb	r3,-1(r21)
 820fc5c:	50a7c83a 	sub	r19,r10,r2
 820fc60:	102b883a 	mov	r21,r2
 820fc64:	003f2f06 	br	820f924 <___vfiprintf_internal_r+0x400>
 820fc68:	21003fcc 	andi	r4,r4,255
 820fc6c:	2003421e 	bne	r4,zero,8210978 <___vfiprintf_internal_r+0x1454>
 820fc70:	00820974 	movhi	r2,2085
 820fc74:	10b6cc04 	addi	r2,r2,-9424
 820fc78:	d8802615 	stw	r2,152(sp)
 820fc7c:	a080080c 	andi	r2,r20,32
 820fc80:	1000aa26 	beq	r2,zero,820ff2c <___vfiprintf_internal_r+0xa08>
 820fc84:	da802217 	ldw	r10,136(sp)
 820fc88:	54800017 	ldw	r18,0(r10)
 820fc8c:	54c00117 	ldw	r19,4(r10)
 820fc90:	52800204 	addi	r10,r10,8
 820fc94:	da802215 	stw	r10,136(sp)
 820fc98:	a080004c 	andi	r2,r20,1
 820fc9c:	1001d226 	beq	r2,zero,82103e8 <___vfiprintf_internal_r+0xec4>
 820fca0:	94c4b03a 	or	r2,r18,r19
 820fca4:	1002351e 	bne	r2,zero,821057c <___vfiprintf_internal_r+0x1058>
 820fca8:	d8001d85 	stb	zero,118(sp)
 820fcac:	48022216 	blt	r9,zero,8210538 <___vfiprintf_internal_r+0x1014>
 820fcb0:	00bfdfc4 	movi	r2,-129
 820fcb4:	a0a8703a 	and	r20,r20,r2
 820fcb8:	003f1506 	br	820f910 <___vfiprintf_internal_r+0x3ec>
 820fcbc:	da802217 	ldw	r10,136(sp)
 820fcc0:	04800044 	movi	r18,1
 820fcc4:	d8001d85 	stb	zero,118(sp)
 820fcc8:	50800017 	ldw	r2,0(r10)
 820fccc:	52800104 	addi	r10,r10,4
 820fcd0:	da802215 	stw	r10,136(sp)
 820fcd4:	d8801005 	stb	r2,64(sp)
 820fcd8:	9027883a 	mov	r19,r18
 820fcdc:	dd401004 	addi	r21,sp,64
 820fce0:	0013883a 	mov	r9,zero
 820fce4:	003f1706 	br	820f944 <___vfiprintf_internal_r+0x420>
 820fce8:	21003fcc 	andi	r4,r4,255
 820fcec:	2003201e 	bne	r4,zero,8210970 <___vfiprintf_internal_r+0x144c>
 820fcf0:	a080080c 	andi	r2,r20,32
 820fcf4:	10004b26 	beq	r2,zero,820fe24 <___vfiprintf_internal_r+0x900>
 820fcf8:	da802217 	ldw	r10,136(sp)
 820fcfc:	50800117 	ldw	r2,4(r10)
 820fd00:	54800017 	ldw	r18,0(r10)
 820fd04:	52800204 	addi	r10,r10,8
 820fd08:	da802215 	stw	r10,136(sp)
 820fd0c:	1027883a 	mov	r19,r2
 820fd10:	10022c16 	blt	r2,zero,82105c4 <___vfiprintf_internal_r+0x10a0>
 820fd14:	df001d83 	ldbu	fp,118(sp)
 820fd18:	48007216 	blt	r9,zero,820fee4 <___vfiprintf_internal_r+0x9c0>
 820fd1c:	00ffdfc4 	movi	r3,-129
 820fd20:	94c4b03a 	or	r2,r18,r19
 820fd24:	a0e8703a 	and	r20,r20,r3
 820fd28:	1000cc26 	beq	r2,zero,821005c <___vfiprintf_internal_r+0xb38>
 820fd2c:	98021026 	beq	r19,zero,8210570 <___vfiprintf_internal_r+0x104c>
 820fd30:	dc402415 	stw	r17,144(sp)
 820fd34:	dc002515 	stw	r16,148(sp)
 820fd38:	9823883a 	mov	r17,r19
 820fd3c:	9021883a 	mov	r16,r18
 820fd40:	dd401a04 	addi	r21,sp,104
 820fd44:	4825883a 	mov	r18,r9
 820fd48:	4027883a 	mov	r19,r8
 820fd4c:	8009883a 	mov	r4,r16
 820fd50:	880b883a 	mov	r5,r17
 820fd54:	01800284 	movi	r6,10
 820fd58:	000f883a 	mov	r7,zero
 820fd5c:	82117ac0 	call	82117ac <__umoddi3>
 820fd60:	10800c04 	addi	r2,r2,48
 820fd64:	ad7fffc4 	addi	r21,r21,-1
 820fd68:	8009883a 	mov	r4,r16
 820fd6c:	880b883a 	mov	r5,r17
 820fd70:	a8800005 	stb	r2,0(r21)
 820fd74:	01800284 	movi	r6,10
 820fd78:	000f883a 	mov	r7,zero
 820fd7c:	82112340 	call	8211234 <__udivdi3>
 820fd80:	1021883a 	mov	r16,r2
 820fd84:	10c4b03a 	or	r2,r2,r3
 820fd88:	1823883a 	mov	r17,r3
 820fd8c:	103fef1e 	bne	r2,zero,820fd4c <___vfiprintf_internal_r+0x828>
 820fd90:	dc402417 	ldw	r17,144(sp)
 820fd94:	dc002517 	ldw	r16,148(sp)
 820fd98:	9013883a 	mov	r9,r18
 820fd9c:	9811883a 	mov	r8,r19
 820fda0:	da801e17 	ldw	r10,120(sp)
 820fda4:	5567c83a 	sub	r19,r10,r21
 820fda8:	003ede06 	br	820f924 <___vfiprintf_internal_r+0x400>
 820fdac:	38803fcc 	andi	r2,r7,255
 820fdb0:	1080201c 	xori	r2,r2,128
 820fdb4:	10bfe004 	addi	r2,r2,-128
 820fdb8:	1002371e 	bne	r2,zero,8210698 <___vfiprintf_internal_r+0x1174>
 820fdbc:	01000044 	movi	r4,1
 820fdc0:	01c00804 	movi	r7,32
 820fdc4:	80c00007 	ldb	r3,0(r16)
 820fdc8:	003e3506 	br	820f6a0 <___vfiprintf_internal_r+0x17c>
 820fdcc:	a5000054 	ori	r20,r20,1
 820fdd0:	80c00007 	ldb	r3,0(r16)
 820fdd4:	003e3206 	br	820f6a0 <___vfiprintf_internal_r+0x17c>
 820fdd8:	a5002014 	ori	r20,r20,128
 820fddc:	80c00007 	ldb	r3,0(r16)
 820fde0:	003e2f06 	br	820f6a0 <___vfiprintf_internal_r+0x17c>
 820fde4:	8015883a 	mov	r10,r16
 820fde8:	0023883a 	mov	r17,zero
 820fdec:	18bff404 	addi	r2,r3,-48
 820fdf0:	50c00007 	ldb	r3,0(r10)
 820fdf4:	8c4002a4 	muli	r17,r17,10
 820fdf8:	84000044 	addi	r16,r16,1
 820fdfc:	8015883a 	mov	r10,r16
 820fe00:	1463883a 	add	r17,r2,r17
 820fe04:	18bff404 	addi	r2,r3,-48
 820fe08:	30bff92e 	bgeu	r6,r2,820fdf0 <___vfiprintf_internal_r+0x8cc>
 820fe0c:	003e2506 	br	820f6a4 <___vfiprintf_internal_r+0x180>
 820fe10:	21003fcc 	andi	r4,r4,255
 820fe14:	2002d41e 	bne	r4,zero,8210968 <___vfiprintf_internal_r+0x1444>
 820fe18:	a5000414 	ori	r20,r20,16
 820fe1c:	a080080c 	andi	r2,r20,32
 820fe20:	103fb51e 	bne	r2,zero,820fcf8 <___vfiprintf_internal_r+0x7d4>
 820fe24:	a080040c 	andi	r2,r20,16
 820fe28:	1001f826 	beq	r2,zero,821060c <___vfiprintf_internal_r+0x10e8>
 820fe2c:	da802217 	ldw	r10,136(sp)
 820fe30:	54800017 	ldw	r18,0(r10)
 820fe34:	52800104 	addi	r10,r10,4
 820fe38:	da802215 	stw	r10,136(sp)
 820fe3c:	9027d7fa 	srai	r19,r18,31
 820fe40:	9805883a 	mov	r2,r19
 820fe44:	003fb206 	br	820fd10 <___vfiprintf_internal_r+0x7ec>
 820fe48:	21003fcc 	andi	r4,r4,255
 820fe4c:	2002c41e 	bne	r4,zero,8210960 <___vfiprintf_internal_r+0x143c>
 820fe50:	a5000414 	ori	r20,r20,16
 820fe54:	a080080c 	andi	r2,r20,32
 820fe58:	103f5f1e 	bne	r2,zero,820fbd8 <___vfiprintf_internal_r+0x6b4>
 820fe5c:	a080040c 	andi	r2,r20,16
 820fe60:	10020f26 	beq	r2,zero,82106a0 <___vfiprintf_internal_r+0x117c>
 820fe64:	da802217 	ldw	r10,136(sp)
 820fe68:	d8001d85 	stb	zero,118(sp)
 820fe6c:	0027883a 	mov	r19,zero
 820fe70:	50800104 	addi	r2,r10,4
 820fe74:	54800017 	ldw	r18,0(r10)
 820fe78:	48021116 	blt	r9,zero,82106c0 <___vfiprintf_internal_r+0x119c>
 820fe7c:	00ffdfc4 	movi	r3,-129
 820fe80:	d8802215 	stw	r2,136(sp)
 820fe84:	a0e8703a 	and	r20,r20,r3
 820fe88:	903f5e1e 	bne	r18,zero,820fc04 <___vfiprintf_internal_r+0x6e0>
 820fe8c:	0039883a 	mov	fp,zero
 820fe90:	4802a626 	beq	r9,zero,821092c <___vfiprintf_internal_r+0x1408>
 820fe94:	0025883a 	mov	r18,zero
 820fe98:	0027883a 	mov	r19,zero
 820fe9c:	003f5a06 	br	820fc08 <___vfiprintf_internal_r+0x6e4>
 820fea0:	21003fcc 	andi	r4,r4,255
 820fea4:	20029f1e 	bne	r4,zero,8210924 <___vfiprintf_internal_r+0x1400>
 820fea8:	a5000414 	ori	r20,r20,16
 820feac:	a080080c 	andi	r2,r20,32
 820feb0:	10005e1e 	bne	r2,zero,821002c <___vfiprintf_internal_r+0xb08>
 820feb4:	a080040c 	andi	r2,r20,16
 820feb8:	1001a21e 	bne	r2,zero,8210544 <___vfiprintf_internal_r+0x1020>
 820febc:	a080100c 	andi	r2,r20,64
 820fec0:	d8001d85 	stb	zero,118(sp)
 820fec4:	da802217 	ldw	r10,136(sp)
 820fec8:	1002231e 	bne	r2,zero,8210758 <___vfiprintf_internal_r+0x1234>
 820fecc:	50800104 	addi	r2,r10,4
 820fed0:	54800017 	ldw	r18,0(r10)
 820fed4:	0027883a 	mov	r19,zero
 820fed8:	4801a00e 	bge	r9,zero,821055c <___vfiprintf_internal_r+0x1038>
 820fedc:	d8802215 	stw	r2,136(sp)
 820fee0:	0039883a 	mov	fp,zero
 820fee4:	94c4b03a 	or	r2,r18,r19
 820fee8:	103f901e 	bne	r2,zero,820fd2c <___vfiprintf_internal_r+0x808>
 820feec:	00800044 	movi	r2,1
 820fef0:	10803fcc 	andi	r2,r2,255
 820fef4:	00c00044 	movi	r3,1
 820fef8:	10c05926 	beq	r2,r3,8210060 <___vfiprintf_internal_r+0xb3c>
 820fefc:	00c00084 	movi	r3,2
 820ff00:	10ffe41e 	bne	r2,r3,820fe94 <___vfiprintf_internal_r+0x970>
 820ff04:	0025883a 	mov	r18,zero
 820ff08:	0027883a 	mov	r19,zero
 820ff0c:	00013d06 	br	8210404 <___vfiprintf_internal_r+0xee0>
 820ff10:	21003fcc 	andi	r4,r4,255
 820ff14:	2002811e 	bne	r4,zero,821091c <___vfiprintf_internal_r+0x13f8>
 820ff18:	00820974 	movhi	r2,2085
 820ff1c:	10b6c704 	addi	r2,r2,-9444
 820ff20:	d8802615 	stw	r2,152(sp)
 820ff24:	a080080c 	andi	r2,r20,32
 820ff28:	103f561e 	bne	r2,zero,820fc84 <___vfiprintf_internal_r+0x760>
 820ff2c:	a080040c 	andi	r2,r20,16
 820ff30:	1001d126 	beq	r2,zero,8210678 <___vfiprintf_internal_r+0x1154>
 820ff34:	da802217 	ldw	r10,136(sp)
 820ff38:	0027883a 	mov	r19,zero
 820ff3c:	54800017 	ldw	r18,0(r10)
 820ff40:	52800104 	addi	r10,r10,4
 820ff44:	da802215 	stw	r10,136(sp)
 820ff48:	003f5306 	br	820fc98 <___vfiprintf_internal_r+0x774>
 820ff4c:	da802217 	ldw	r10,136(sp)
 820ff50:	d8001d85 	stb	zero,118(sp)
 820ff54:	55400017 	ldw	r21,0(r10)
 820ff58:	50c00104 	addi	r3,r10,4
 820ff5c:	a8024226 	beq	r21,zero,8210868 <___vfiprintf_internal_r+0x1344>
 820ff60:	48021816 	blt	r9,zero,82107c4 <___vfiprintf_internal_r+0x12a0>
 820ff64:	480d883a 	mov	r6,r9
 820ff68:	000b883a 	mov	r5,zero
 820ff6c:	a809883a 	mov	r4,r21
 820ff70:	d8c02a15 	stw	r3,168(sp)
 820ff74:	da002b15 	stw	r8,172(sp)
 820ff78:	da402c15 	stw	r9,176(sp)
 820ff7c:	820c4740 	call	820c474 <memchr>
 820ff80:	d8c02a17 	ldw	r3,168(sp)
 820ff84:	da002b17 	ldw	r8,172(sp)
 820ff88:	da402c17 	ldw	r9,176(sp)
 820ff8c:	10024826 	beq	r2,zero,82108b0 <___vfiprintf_internal_r+0x138c>
 820ff90:	1567c83a 	sub	r19,r2,r21
 820ff94:	df001d83 	ldbu	fp,118(sp)
 820ff98:	d8c02215 	stw	r3,136(sp)
 820ff9c:	0013883a 	mov	r9,zero
 820ffa0:	003e6006 	br	820f924 <___vfiprintf_internal_r+0x400>
 820ffa4:	21003fcc 	andi	r4,r4,255
 820ffa8:	203fc026 	beq	r4,zero,820feac <___vfiprintf_internal_r+0x988>
 820ffac:	d9c01d85 	stb	r7,118(sp)
 820ffb0:	003fbe06 	br	820feac <___vfiprintf_internal_r+0x988>
 820ffb4:	da802217 	ldw	r10,136(sp)
 820ffb8:	54400017 	ldw	r17,0(r10)
 820ffbc:	50800104 	addi	r2,r10,4
 820ffc0:	883e3b16 	blt	r17,zero,820f8b0 <___vfiprintf_internal_r+0x38c>
 820ffc4:	d8802215 	stw	r2,136(sp)
 820ffc8:	80c00007 	ldb	r3,0(r16)
 820ffcc:	003db406 	br	820f6a0 <___vfiprintf_internal_r+0x17c>
 820ffd0:	01000044 	movi	r4,1
 820ffd4:	01c00ac4 	movi	r7,43
 820ffd8:	80c00007 	ldb	r3,0(r16)
 820ffdc:	003db006 	br	820f6a0 <___vfiprintf_internal_r+0x17c>
 820ffe0:	80c00007 	ldb	r3,0(r16)
 820ffe4:	82800044 	addi	r10,r16,1
 820ffe8:	1b423c26 	beq	r3,r13,82108dc <___vfiprintf_internal_r+0x13b8>
 820ffec:	18bff404 	addi	r2,r3,-48
 820fff0:	0013883a 	mov	r9,zero
 820fff4:	30822b36 	bltu	r6,r2,82108a4 <___vfiprintf_internal_r+0x1380>
 820fff8:	50c00007 	ldb	r3,0(r10)
 820fffc:	4a4002a4 	muli	r9,r9,10
 8210000:	54000044 	addi	r16,r10,1
 8210004:	8015883a 	mov	r10,r16
 8210008:	4893883a 	add	r9,r9,r2
 821000c:	18bff404 	addi	r2,r3,-48
 8210010:	30bff92e 	bgeu	r6,r2,820fff8 <___vfiprintf_internal_r+0xad4>
 8210014:	483da30e 	bge	r9,zero,820f6a4 <___vfiprintf_internal_r+0x180>
 8210018:	027fffc4 	movi	r9,-1
 821001c:	003da106 	br	820f6a4 <___vfiprintf_internal_r+0x180>
 8210020:	a5001014 	ori	r20,r20,64
 8210024:	80c00007 	ldb	r3,0(r16)
 8210028:	003d9d06 	br	820f6a0 <___vfiprintf_internal_r+0x17c>
 821002c:	da802217 	ldw	r10,136(sp)
 8210030:	d8001d85 	stb	zero,118(sp)
 8210034:	50c00204 	addi	r3,r10,8
 8210038:	54800017 	ldw	r18,0(r10)
 821003c:	54c00117 	ldw	r19,4(r10)
 8210040:	4801ca16 	blt	r9,zero,821076c <___vfiprintf_internal_r+0x1248>
 8210044:	013fdfc4 	movi	r4,-129
 8210048:	94c4b03a 	or	r2,r18,r19
 821004c:	d8c02215 	stw	r3,136(sp)
 8210050:	a128703a 	and	r20,r20,r4
 8210054:	0039883a 	mov	fp,zero
 8210058:	103f341e 	bne	r2,zero,820fd2c <___vfiprintf_internal_r+0x808>
 821005c:	483e2e26 	beq	r9,zero,820f918 <___vfiprintf_internal_r+0x3f4>
 8210060:	0025883a 	mov	r18,zero
 8210064:	94800c04 	addi	r18,r18,48
 8210068:	dc8019c5 	stb	r18,103(sp)
 821006c:	dcc02717 	ldw	r19,156(sp)
 8210070:	dd4019c4 	addi	r21,sp,103
 8210074:	003e2b06 	br	820f924 <___vfiprintf_internal_r+0x400>
 8210078:	21003fcc 	andi	r4,r4,255
 821007c:	2002361e 	bne	r4,zero,8210958 <___vfiprintf_internal_r+0x1434>
 8210080:	1801c126 	beq	r3,zero,8210788 <___vfiprintf_internal_r+0x1264>
 8210084:	04800044 	movi	r18,1
 8210088:	d8c01005 	stb	r3,64(sp)
 821008c:	d8001d85 	stb	zero,118(sp)
 8210090:	9027883a 	mov	r19,r18
 8210094:	dd401004 	addi	r21,sp,64
 8210098:	003f1106 	br	820fce0 <___vfiprintf_internal_r+0x7bc>
 821009c:	d9402117 	ldw	r5,132(sp)
 82100a0:	d9002017 	ldw	r4,128(sp)
 82100a4:	d9801a04 	addi	r6,sp,104
 82100a8:	d9c02b15 	stw	r7,172(sp)
 82100ac:	dbc02a15 	stw	r15,168(sp)
 82100b0:	820f4100 	call	820f410 <__sprint_r.part.0>
 82100b4:	d9c02b17 	ldw	r7,172(sp)
 82100b8:	dbc02a17 	ldw	r15,168(sp)
 82100bc:	10006d1e 	bne	r2,zero,8210274 <___vfiprintf_internal_r+0xd50>
 82100c0:	d9801b17 	ldw	r6,108(sp)
 82100c4:	d8801c17 	ldw	r2,112(sp)
 82100c8:	d811883a 	mov	r8,sp
 82100cc:	31400044 	addi	r5,r6,1
 82100d0:	003e3306 	br	820f9a0 <___vfiprintf_internal_r+0x47c>
 82100d4:	d9401b17 	ldw	r5,108(sp)
 82100d8:	d8801c17 	ldw	r2,112(sp)
 82100dc:	29000044 	addi	r4,r5,1
 82100e0:	d8c01d87 	ldb	r3,118(sp)
 82100e4:	183e4d26 	beq	r3,zero,820fa1c <___vfiprintf_internal_r+0x4f8>
 82100e8:	00c00044 	movi	r3,1
 82100ec:	d9401d84 	addi	r5,sp,118
 82100f0:	10c5883a 	add	r2,r2,r3
 82100f4:	41400015 	stw	r5,0(r8)
 82100f8:	40c00115 	stw	r3,4(r8)
 82100fc:	d8801c15 	stw	r2,112(sp)
 8210100:	d9001b15 	stw	r4,108(sp)
 8210104:	014001c4 	movi	r5,7
 8210108:	2900a90e 	bge	r5,r4,82103b0 <___vfiprintf_internal_r+0xe8c>
 821010c:	1000da1e 	bne	r2,zero,8210478 <___vfiprintf_internal_r+0xf54>
 8210110:	7000ab1e 	bne	r14,zero,82103c0 <___vfiprintf_internal_r+0xe9c>
 8210114:	000b883a 	mov	r5,zero
 8210118:	1809883a 	mov	r4,r3
 821011c:	d811883a 	mov	r8,sp
 8210120:	00c02004 	movi	r3,128
 8210124:	e0fe4d26 	beq	fp,r3,820fa5c <___vfiprintf_internal_r+0x538>
 8210128:	4cf9c83a 	sub	fp,r9,r19
 821012c:	073e7b0e 	bge	zero,fp,820fb1c <___vfiprintf_internal_r+0x5f8>
 8210130:	01c00404 	movi	r7,16
 8210134:	3f01900e 	bge	r7,fp,8210778 <___vfiprintf_internal_r+0x1254>
 8210138:	00c20974 	movhi	r3,2085
 821013c:	18f73c04 	addi	r3,r3,-8976
 8210140:	d8c02415 	stw	r3,144(sp)
 8210144:	034001c4 	movi	r13,7
 8210148:	00000506 	br	8210160 <___vfiprintf_internal_r+0xc3c>
 821014c:	29000084 	addi	r4,r5,2
 8210150:	42000204 	addi	r8,r8,8
 8210154:	180b883a 	mov	r5,r3
 8210158:	e73ffc04 	addi	fp,fp,-16
 821015c:	3f000d0e 	bge	r7,fp,8210194 <___vfiprintf_internal_r+0xc70>
 8210160:	10800404 	addi	r2,r2,16
 8210164:	28c00044 	addi	r3,r5,1
 8210168:	45c00015 	stw	r23,0(r8)
 821016c:	41c00115 	stw	r7,4(r8)
 8210170:	d8801c15 	stw	r2,112(sp)
 8210174:	d8c01b15 	stw	r3,108(sp)
 8210178:	68fff40e 	bge	r13,r3,821014c <___vfiprintf_internal_r+0xc28>
 821017c:	1000101e 	bne	r2,zero,82101c0 <___vfiprintf_internal_r+0xc9c>
 8210180:	e73ffc04 	addi	fp,fp,-16
 8210184:	01000044 	movi	r4,1
 8210188:	000b883a 	mov	r5,zero
 821018c:	d811883a 	mov	r8,sp
 8210190:	3f3ff316 	blt	r7,fp,8210160 <___vfiprintf_internal_r+0xc3c>
 8210194:	da802417 	ldw	r10,144(sp)
 8210198:	1705883a 	add	r2,r2,fp
 821019c:	47000115 	stw	fp,4(r8)
 82101a0:	42800015 	stw	r10,0(r8)
 82101a4:	d8801c15 	stw	r2,112(sp)
 82101a8:	d9001b15 	stw	r4,108(sp)
 82101ac:	00c001c4 	movi	r3,7
 82101b0:	19003616 	blt	r3,r4,821028c <___vfiprintf_internal_r+0xd68>
 82101b4:	42000204 	addi	r8,r8,8
 82101b8:	21000044 	addi	r4,r4,1
 82101bc:	003e5706 	br	820fb1c <___vfiprintf_internal_r+0x5f8>
 82101c0:	d9402117 	ldw	r5,132(sp)
 82101c4:	d9002017 	ldw	r4,128(sp)
 82101c8:	d9801a04 	addi	r6,sp,104
 82101cc:	d9c02b15 	stw	r7,172(sp)
 82101d0:	db402a15 	stw	r13,168(sp)
 82101d4:	820f4100 	call	820f410 <__sprint_r.part.0>
 82101d8:	d9c02b17 	ldw	r7,172(sp)
 82101dc:	db402a17 	ldw	r13,168(sp)
 82101e0:	1000241e 	bne	r2,zero,8210274 <___vfiprintf_internal_r+0xd50>
 82101e4:	d9401b17 	ldw	r5,108(sp)
 82101e8:	d8801c17 	ldw	r2,112(sp)
 82101ec:	d811883a 	mov	r8,sp
 82101f0:	29000044 	addi	r4,r5,1
 82101f4:	003fd806 	br	8210158 <___vfiprintf_internal_r+0xc34>
 82101f8:	d9401b17 	ldw	r5,108(sp)
 82101fc:	00c20974 	movhi	r3,2085
 8210200:	18f74004 	addi	r3,r3,-8960
 8210204:	d8c02415 	stw	r3,144(sp)
 8210208:	29400044 	addi	r5,r5,1
 821020c:	d8c02417 	ldw	r3,144(sp)
 8210210:	14c5883a 	add	r2,r2,r19
 8210214:	44c00115 	stw	r19,4(r8)
 8210218:	40c00015 	stw	r3,0(r8)
 821021c:	d8801c15 	stw	r2,112(sp)
 8210220:	d9401b15 	stw	r5,108(sp)
 8210224:	00c001c4 	movi	r3,7
 8210228:	1940070e 	bge	r3,r5,8210248 <___vfiprintf_internal_r+0xd24>
 821022c:	103e4826 	beq	r2,zero,820fb50 <___vfiprintf_internal_r+0x62c>
 8210230:	d9402117 	ldw	r5,132(sp)
 8210234:	d9002017 	ldw	r4,128(sp)
 8210238:	d9801a04 	addi	r6,sp,104
 821023c:	820f4100 	call	820f410 <__sprint_r.part.0>
 8210240:	10000c1e 	bne	r2,zero,8210274 <___vfiprintf_internal_r+0xd50>
 8210244:	d8801c17 	ldw	r2,112(sp)
 8210248:	8c80010e 	bge	r17,r18,8210250 <___vfiprintf_internal_r+0xd2c>
 821024c:	9023883a 	mov	r17,r18
 8210250:	da802317 	ldw	r10,140(sp)
 8210254:	5455883a 	add	r10,r10,r17
 8210258:	da802315 	stw	r10,140(sp)
 821025c:	103e4126 	beq	r2,zero,820fb64 <___vfiprintf_internal_r+0x640>
 8210260:	d9402117 	ldw	r5,132(sp)
 8210264:	d9002017 	ldw	r4,128(sp)
 8210268:	d9801a04 	addi	r6,sp,104
 821026c:	820f4100 	call	820f410 <__sprint_r.part.0>
 8210270:	103e3c26 	beq	r2,zero,820fb64 <___vfiprintf_internal_r+0x640>
 8210274:	dd002117 	ldw	r20,132(sp)
 8210278:	a080030b 	ldhu	r2,12(r20)
 821027c:	1080100c 	andi	r2,r2,64
 8210280:	1001231e 	bne	r2,zero,8210710 <___vfiprintf_internal_r+0x11ec>
 8210284:	d8802317 	ldw	r2,140(sp)
 8210288:	003d7b06 	br	820f878 <___vfiprintf_internal_r+0x354>
 821028c:	1000991e 	bne	r2,zero,82104f4 <___vfiprintf_internal_r+0xfd0>
 8210290:	00c00044 	movi	r3,1
 8210294:	9805883a 	mov	r2,r19
 8210298:	dd400015 	stw	r21,0(sp)
 821029c:	dcc00115 	stw	r19,4(sp)
 82102a0:	dcc01c15 	stw	r19,112(sp)
 82102a4:	d8c01b15 	stw	r3,108(sp)
 82102a8:	d811883a 	mov	r8,sp
 82102ac:	42000204 	addi	r8,r8,8
 82102b0:	a2c0010c 	andi	r11,r20,4
 82102b4:	583fe426 	beq	r11,zero,8210248 <___vfiprintf_internal_r+0xd24>
 82102b8:	8ca7c83a 	sub	r19,r17,r18
 82102bc:	04ffe20e 	bge	zero,r19,8210248 <___vfiprintf_internal_r+0xd24>
 82102c0:	01c00404 	movi	r7,16
 82102c4:	3cffcc0e 	bge	r7,r19,82101f8 <___vfiprintf_internal_r+0xcd4>
 82102c8:	02820974 	movhi	r10,2085
 82102cc:	52b74004 	addi	r10,r10,-8960
 82102d0:	d9001b17 	ldw	r4,108(sp)
 82102d4:	da802415 	stw	r10,144(sp)
 82102d8:	382b883a 	mov	r21,r7
 82102dc:	050001c4 	movi	r20,7
 82102e0:	df002017 	ldw	fp,128(sp)
 82102e4:	00000506 	br	82102fc <___vfiprintf_internal_r+0xdd8>
 82102e8:	21400084 	addi	r5,r4,2
 82102ec:	42000204 	addi	r8,r8,8
 82102f0:	1809883a 	mov	r4,r3
 82102f4:	9cfffc04 	addi	r19,r19,-16
 82102f8:	acffc40e 	bge	r21,r19,821020c <___vfiprintf_internal_r+0xce8>
 82102fc:	10800404 	addi	r2,r2,16
 8210300:	20c00044 	addi	r3,r4,1
 8210304:	45800015 	stw	r22,0(r8)
 8210308:	45400115 	stw	r21,4(r8)
 821030c:	d8801c15 	stw	r2,112(sp)
 8210310:	d8c01b15 	stw	r3,108(sp)
 8210314:	a0fff40e 	bge	r20,r3,82102e8 <___vfiprintf_internal_r+0xdc4>
 8210318:	1000041e 	bne	r2,zero,821032c <___vfiprintf_internal_r+0xe08>
 821031c:	01400044 	movi	r5,1
 8210320:	0009883a 	mov	r4,zero
 8210324:	d811883a 	mov	r8,sp
 8210328:	003ff206 	br	82102f4 <___vfiprintf_internal_r+0xdd0>
 821032c:	d9402117 	ldw	r5,132(sp)
 8210330:	d9801a04 	addi	r6,sp,104
 8210334:	e009883a 	mov	r4,fp
 8210338:	820f4100 	call	820f410 <__sprint_r.part.0>
 821033c:	103fcd1e 	bne	r2,zero,8210274 <___vfiprintf_internal_r+0xd50>
 8210340:	d9001b17 	ldw	r4,108(sp)
 8210344:	d8801c17 	ldw	r2,112(sp)
 8210348:	d811883a 	mov	r8,sp
 821034c:	21400044 	addi	r5,r4,1
 8210350:	003fe806 	br	82102f4 <___vfiprintf_internal_r+0xdd0>
 8210354:	d9402117 	ldw	r5,132(sp)
 8210358:	d9002017 	ldw	r4,128(sp)
 821035c:	d9801a04 	addi	r6,sp,104
 8210360:	d9c02b15 	stw	r7,172(sp)
 8210364:	db402a15 	stw	r13,168(sp)
 8210368:	820f4100 	call	820f410 <__sprint_r.part.0>
 821036c:	d9c02b17 	ldw	r7,172(sp)
 8210370:	db402a17 	ldw	r13,168(sp)
 8210374:	103fbf1e 	bne	r2,zero,8210274 <___vfiprintf_internal_r+0xd50>
 8210378:	d9401b17 	ldw	r5,108(sp)
 821037c:	d8801c17 	ldw	r2,112(sp)
 8210380:	d811883a 	mov	r8,sp
 8210384:	29800044 	addi	r6,r5,1
 8210388:	003dc406 	br	820fa9c <___vfiprintf_internal_r+0x578>
 821038c:	1000d21e 	bne	r2,zero,82106d8 <___vfiprintf_internal_r+0x11b4>
 8210390:	d8c01d87 	ldb	r3,118(sp)
 8210394:	18009526 	beq	r3,zero,82105ec <___vfiprintf_internal_r+0x10c8>
 8210398:	00800044 	movi	r2,1
 821039c:	d8c01d84 	addi	r3,sp,118
 82103a0:	1009883a 	mov	r4,r2
 82103a4:	d8c00015 	stw	r3,0(sp)
 82103a8:	d8800115 	stw	r2,4(sp)
 82103ac:	d811883a 	mov	r8,sp
 82103b0:	200b883a 	mov	r5,r4
 82103b4:	42000204 	addi	r8,r8,8
 82103b8:	21000044 	addi	r4,r4,1
 82103bc:	003d9706 	br	820fa1c <___vfiprintf_internal_r+0x4f8>
 82103c0:	d9001d04 	addi	r4,sp,116
 82103c4:	00800084 	movi	r2,2
 82103c8:	d9000015 	stw	r4,0(sp)
 82103cc:	d8800115 	stw	r2,4(sp)
 82103d0:	1809883a 	mov	r4,r3
 82103d4:	d811883a 	mov	r8,sp
 82103d8:	200b883a 	mov	r5,r4
 82103dc:	42000204 	addi	r8,r8,8
 82103e0:	21000044 	addi	r4,r4,1
 82103e4:	003f4e06 	br	8210120 <___vfiprintf_internal_r+0xbfc>
 82103e8:	d8001d85 	stb	zero,118(sp)
 82103ec:	48005016 	blt	r9,zero,8210530 <___vfiprintf_internal_r+0x100c>
 82103f0:	00ffdfc4 	movi	r3,-129
 82103f4:	94c4b03a 	or	r2,r18,r19
 82103f8:	a0e8703a 	and	r20,r20,r3
 82103fc:	103d4426 	beq	r2,zero,820f910 <___vfiprintf_internal_r+0x3ec>
 8210400:	0039883a 	mov	fp,zero
 8210404:	d9002617 	ldw	r4,152(sp)
 8210408:	dd401a04 	addi	r21,sp,104
 821040c:	908003cc 	andi	r2,r18,15
 8210410:	9806973a 	slli	r3,r19,28
 8210414:	2085883a 	add	r2,r4,r2
 8210418:	9024d13a 	srli	r18,r18,4
 821041c:	10800003 	ldbu	r2,0(r2)
 8210420:	9826d13a 	srli	r19,r19,4
 8210424:	ad7fffc4 	addi	r21,r21,-1
 8210428:	1ca4b03a 	or	r18,r3,r18
 821042c:	a8800005 	stb	r2,0(r21)
 8210430:	94c4b03a 	or	r2,r18,r19
 8210434:	103ff51e 	bne	r2,zero,821040c <___vfiprintf_internal_r+0xee8>
 8210438:	003e5906 	br	820fda0 <___vfiprintf_internal_r+0x87c>
 821043c:	d9402117 	ldw	r5,132(sp)
 8210440:	d9002017 	ldw	r4,128(sp)
 8210444:	d9801a04 	addi	r6,sp,104
 8210448:	820f4100 	call	820f410 <__sprint_r.part.0>
 821044c:	103f891e 	bne	r2,zero,8210274 <___vfiprintf_internal_r+0xd50>
 8210450:	d8801c17 	ldw	r2,112(sp)
 8210454:	d811883a 	mov	r8,sp
 8210458:	003f9506 	br	82102b0 <___vfiprintf_internal_r+0xd8c>
 821045c:	d9402117 	ldw	r5,132(sp)
 8210460:	d9002017 	ldw	r4,128(sp)
 8210464:	d9801a04 	addi	r6,sp,104
 8210468:	820f4100 	call	820f410 <__sprint_r.part.0>
 821046c:	103f811e 	bne	r2,zero,8210274 <___vfiprintf_internal_r+0xd50>
 8210470:	d811883a 	mov	r8,sp
 8210474:	003ced06 	br	820f82c <___vfiprintf_internal_r+0x308>
 8210478:	d9402117 	ldw	r5,132(sp)
 821047c:	d9002017 	ldw	r4,128(sp)
 8210480:	d9801a04 	addi	r6,sp,104
 8210484:	da402c15 	stw	r9,176(sp)
 8210488:	db802a15 	stw	r14,168(sp)
 821048c:	820f4100 	call	820f410 <__sprint_r.part.0>
 8210490:	da402c17 	ldw	r9,176(sp)
 8210494:	db802a17 	ldw	r14,168(sp)
 8210498:	103f761e 	bne	r2,zero,8210274 <___vfiprintf_internal_r+0xd50>
 821049c:	d9401b17 	ldw	r5,108(sp)
 82104a0:	d8801c17 	ldw	r2,112(sp)
 82104a4:	d811883a 	mov	r8,sp
 82104a8:	29000044 	addi	r4,r5,1
 82104ac:	003d5b06 	br	820fa1c <___vfiprintf_internal_r+0x4f8>
 82104b0:	d9402117 	ldw	r5,132(sp)
 82104b4:	d9002017 	ldw	r4,128(sp)
 82104b8:	d9801a04 	addi	r6,sp,104
 82104bc:	da402c15 	stw	r9,176(sp)
 82104c0:	820f4100 	call	820f410 <__sprint_r.part.0>
 82104c4:	da402c17 	ldw	r9,176(sp)
 82104c8:	103f6a1e 	bne	r2,zero,8210274 <___vfiprintf_internal_r+0xd50>
 82104cc:	d9401b17 	ldw	r5,108(sp)
 82104d0:	d8801c17 	ldw	r2,112(sp)
 82104d4:	d811883a 	mov	r8,sp
 82104d8:	29000044 	addi	r4,r5,1
 82104dc:	003f1006 	br	8210120 <___vfiprintf_internal_r+0xbfc>
 82104e0:	1000c31e 	bne	r2,zero,82107f0 <___vfiprintf_internal_r+0x12cc>
 82104e4:	01000044 	movi	r4,1
 82104e8:	000b883a 	mov	r5,zero
 82104ec:	d811883a 	mov	r8,sp
 82104f0:	003f0d06 	br	8210128 <___vfiprintf_internal_r+0xc04>
 82104f4:	d9402117 	ldw	r5,132(sp)
 82104f8:	d9002017 	ldw	r4,128(sp)
 82104fc:	d9801a04 	addi	r6,sp,104
 8210500:	820f4100 	call	820f410 <__sprint_r.part.0>
 8210504:	103f5b1e 	bne	r2,zero,8210274 <___vfiprintf_internal_r+0xd50>
 8210508:	d9001b17 	ldw	r4,108(sp)
 821050c:	d8801c17 	ldw	r2,112(sp)
 8210510:	d811883a 	mov	r8,sp
 8210514:	21000044 	addi	r4,r4,1
 8210518:	003d8006 	br	820fb1c <___vfiprintf_internal_r+0x5f8>
 821051c:	01020974 	movhi	r4,2085
 8210520:	2136cc04 	addi	r4,r4,-9424
 8210524:	d9002615 	stw	r4,152(sp)
 8210528:	d8c02215 	stw	r3,136(sp)
 821052c:	1029883a 	mov	r20,r2
 8210530:	94c4b03a 	or	r2,r18,r19
 8210534:	103fb21e 	bne	r2,zero,8210400 <___vfiprintf_internal_r+0xedc>
 8210538:	0039883a 	mov	fp,zero
 821053c:	00800084 	movi	r2,2
 8210540:	003e6b06 	br	820fef0 <___vfiprintf_internal_r+0x9cc>
 8210544:	da802217 	ldw	r10,136(sp)
 8210548:	d8001d85 	stb	zero,118(sp)
 821054c:	0027883a 	mov	r19,zero
 8210550:	50800104 	addi	r2,r10,4
 8210554:	54800017 	ldw	r18,0(r10)
 8210558:	483e6016 	blt	r9,zero,820fedc <___vfiprintf_internal_r+0x9b8>
 821055c:	00ffdfc4 	movi	r3,-129
 8210560:	d8802215 	stw	r2,136(sp)
 8210564:	a0e8703a 	and	r20,r20,r3
 8210568:	0039883a 	mov	fp,zero
 821056c:	903ebb26 	beq	r18,zero,821005c <___vfiprintf_internal_r+0xb38>
 8210570:	00800244 	movi	r2,9
 8210574:	14bdee36 	bltu	r2,r18,820fd30 <___vfiprintf_internal_r+0x80c>
 8210578:	003eba06 	br	8210064 <___vfiprintf_internal_r+0xb40>
 821057c:	00800c04 	movi	r2,48
 8210580:	d8c01d45 	stb	r3,117(sp)
 8210584:	d8801d05 	stb	r2,116(sp)
 8210588:	d8001d85 	stb	zero,118(sp)
 821058c:	a0c00094 	ori	r3,r20,2
 8210590:	4800a916 	blt	r9,zero,8210838 <___vfiprintf_internal_r+0x1314>
 8210594:	00bfdfc4 	movi	r2,-129
 8210598:	a096703a 	and	r11,r20,r2
 821059c:	5d000094 	ori	r20,r11,2
 82105a0:	0039883a 	mov	fp,zero
 82105a4:	003f9706 	br	8210404 <___vfiprintf_internal_r+0xee0>
 82105a8:	8025883a 	mov	r18,r16
 82105ac:	003c2e06 	br	820f668 <___vfiprintf_internal_r+0x144>
 82105b0:	00820974 	movhi	r2,2085
 82105b4:	10b6cc04 	addi	r2,r2,-9424
 82105b8:	0039883a 	mov	fp,zero
 82105bc:	d8802615 	stw	r2,152(sp)
 82105c0:	003f9006 	br	8210404 <___vfiprintf_internal_r+0xee0>
 82105c4:	04a5c83a 	sub	r18,zero,r18
 82105c8:	07000b44 	movi	fp,45
 82105cc:	9004c03a 	cmpne	r2,r18,zero
 82105d0:	04e7c83a 	sub	r19,zero,r19
 82105d4:	df001d85 	stb	fp,118(sp)
 82105d8:	98a7c83a 	sub	r19,r19,r2
 82105dc:	48009f16 	blt	r9,zero,821085c <___vfiprintf_internal_r+0x1338>
 82105e0:	00bfdfc4 	movi	r2,-129
 82105e4:	a0a8703a 	and	r20,r20,r2
 82105e8:	003dd006 	br	820fd2c <___vfiprintf_internal_r+0x808>
 82105ec:	70004c26 	beq	r14,zero,8210720 <___vfiprintf_internal_r+0x11fc>
 82105f0:	00800084 	movi	r2,2
 82105f4:	d8c01d04 	addi	r3,sp,116
 82105f8:	d8c00015 	stw	r3,0(sp)
 82105fc:	d8800115 	stw	r2,4(sp)
 8210600:	01000044 	movi	r4,1
 8210604:	d811883a 	mov	r8,sp
 8210608:	003f7306 	br	82103d8 <___vfiprintf_internal_r+0xeb4>
 821060c:	a080100c 	andi	r2,r20,64
 8210610:	da802217 	ldw	r10,136(sp)
 8210614:	103e0626 	beq	r2,zero,820fe30 <___vfiprintf_internal_r+0x90c>
 8210618:	5480000f 	ldh	r18,0(r10)
 821061c:	52800104 	addi	r10,r10,4
 8210620:	da802215 	stw	r10,136(sp)
 8210624:	9027d7fa 	srai	r19,r18,31
 8210628:	9805883a 	mov	r2,r19
 821062c:	003db806 	br	820fd10 <___vfiprintf_internal_r+0x7ec>
 8210630:	a080040c 	andi	r2,r20,16
 8210634:	1000091e 	bne	r2,zero,821065c <___vfiprintf_internal_r+0x1138>
 8210638:	a2c0100c 	andi	r11,r20,64
 821063c:	58000726 	beq	r11,zero,821065c <___vfiprintf_internal_r+0x1138>
 8210640:	da802217 	ldw	r10,136(sp)
 8210644:	50800017 	ldw	r2,0(r10)
 8210648:	52800104 	addi	r10,r10,4
 821064c:	da802215 	stw	r10,136(sp)
 8210650:	da802317 	ldw	r10,140(sp)
 8210654:	1280000d 	sth	r10,0(r2)
 8210658:	003be706 	br	820f5f8 <___vfiprintf_internal_r+0xd4>
 821065c:	da802217 	ldw	r10,136(sp)
 8210660:	50800017 	ldw	r2,0(r10)
 8210664:	52800104 	addi	r10,r10,4
 8210668:	da802215 	stw	r10,136(sp)
 821066c:	da802317 	ldw	r10,140(sp)
 8210670:	12800015 	stw	r10,0(r2)
 8210674:	003be006 	br	820f5f8 <___vfiprintf_internal_r+0xd4>
 8210678:	a080100c 	andi	r2,r20,64
 821067c:	da802217 	ldw	r10,136(sp)
 8210680:	10003026 	beq	r2,zero,8210744 <___vfiprintf_internal_r+0x1220>
 8210684:	5480000b 	ldhu	r18,0(r10)
 8210688:	52800104 	addi	r10,r10,4
 821068c:	0027883a 	mov	r19,zero
 8210690:	da802215 	stw	r10,136(sp)
 8210694:	003d8006 	br	820fc98 <___vfiprintf_internal_r+0x774>
 8210698:	80c00007 	ldb	r3,0(r16)
 821069c:	003c0006 	br	820f6a0 <___vfiprintf_internal_r+0x17c>
 82106a0:	a080100c 	andi	r2,r20,64
 82106a4:	d8001d85 	stb	zero,118(sp)
 82106a8:	da802217 	ldw	r10,136(sp)
 82106ac:	1000201e 	bne	r2,zero,8210730 <___vfiprintf_internal_r+0x120c>
 82106b0:	50800104 	addi	r2,r10,4
 82106b4:	54800017 	ldw	r18,0(r10)
 82106b8:	0027883a 	mov	r19,zero
 82106bc:	483def0e 	bge	r9,zero,820fe7c <___vfiprintf_internal_r+0x958>
 82106c0:	94c6b03a 	or	r3,r18,r19
 82106c4:	d8802215 	stw	r2,136(sp)
 82106c8:	183d4e1e 	bne	r3,zero,820fc04 <___vfiprintf_internal_r+0x6e0>
 82106cc:	0039883a 	mov	fp,zero
 82106d0:	0005883a 	mov	r2,zero
 82106d4:	003e0606 	br	820fef0 <___vfiprintf_internal_r+0x9cc>
 82106d8:	d9402117 	ldw	r5,132(sp)
 82106dc:	d9002017 	ldw	r4,128(sp)
 82106e0:	d9801a04 	addi	r6,sp,104
 82106e4:	da402c15 	stw	r9,176(sp)
 82106e8:	db802a15 	stw	r14,168(sp)
 82106ec:	820f4100 	call	820f410 <__sprint_r.part.0>
 82106f0:	da402c17 	ldw	r9,176(sp)
 82106f4:	db802a17 	ldw	r14,168(sp)
 82106f8:	103ede1e 	bne	r2,zero,8210274 <___vfiprintf_internal_r+0xd50>
 82106fc:	d9401b17 	ldw	r5,108(sp)
 8210700:	d8801c17 	ldw	r2,112(sp)
 8210704:	d811883a 	mov	r8,sp
 8210708:	29000044 	addi	r4,r5,1
 821070c:	003e7406 	br	82100e0 <___vfiprintf_internal_r+0xbbc>
 8210710:	00bfffc4 	movi	r2,-1
 8210714:	003c5806 	br	820f878 <___vfiprintf_internal_r+0x354>
 8210718:	d811883a 	mov	r8,sp
 821071c:	003ee806 	br	82102c0 <___vfiprintf_internal_r+0xd9c>
 8210720:	000b883a 	mov	r5,zero
 8210724:	01000044 	movi	r4,1
 8210728:	d811883a 	mov	r8,sp
 821072c:	003e7c06 	br	8210120 <___vfiprintf_internal_r+0xbfc>
 8210730:	50800104 	addi	r2,r10,4
 8210734:	5480000b 	ldhu	r18,0(r10)
 8210738:	0027883a 	mov	r19,zero
 821073c:	483dcf0e 	bge	r9,zero,820fe7c <___vfiprintf_internal_r+0x958>
 8210740:	003fdf06 	br	82106c0 <___vfiprintf_internal_r+0x119c>
 8210744:	54800017 	ldw	r18,0(r10)
 8210748:	52800104 	addi	r10,r10,4
 821074c:	0027883a 	mov	r19,zero
 8210750:	da802215 	stw	r10,136(sp)
 8210754:	003d5006 	br	820fc98 <___vfiprintf_internal_r+0x774>
 8210758:	50800104 	addi	r2,r10,4
 821075c:	5480000b 	ldhu	r18,0(r10)
 8210760:	0027883a 	mov	r19,zero
 8210764:	483f7d0e 	bge	r9,zero,821055c <___vfiprintf_internal_r+0x1038>
 8210768:	003ddc06 	br	820fedc <___vfiprintf_internal_r+0x9b8>
 821076c:	d8c02215 	stw	r3,136(sp)
 8210770:	0039883a 	mov	fp,zero
 8210774:	003ddb06 	br	820fee4 <___vfiprintf_internal_r+0x9c0>
 8210778:	02820974 	movhi	r10,2085
 821077c:	52b73c04 	addi	r10,r10,-8976
 8210780:	da802415 	stw	r10,144(sp)
 8210784:	003e8306 	br	8210194 <___vfiprintf_internal_r+0xc70>
 8210788:	d8801c17 	ldw	r2,112(sp)
 821078c:	dd002117 	ldw	r20,132(sp)
 8210790:	103eb926 	beq	r2,zero,8210278 <___vfiprintf_internal_r+0xd54>
 8210794:	d9002017 	ldw	r4,128(sp)
 8210798:	d9801a04 	addi	r6,sp,104
 821079c:	a00b883a 	mov	r5,r20
 82107a0:	820f4100 	call	820f410 <__sprint_r.part.0>
 82107a4:	003eb406 	br	8210278 <___vfiprintf_internal_r+0xd54>
 82107a8:	80c00043 	ldbu	r3,1(r16)
 82107ac:	a5000814 	ori	r20,r20,32
 82107b0:	84000044 	addi	r16,r16,1
 82107b4:	18c03fcc 	andi	r3,r3,255
 82107b8:	18c0201c 	xori	r3,r3,128
 82107bc:	18ffe004 	addi	r3,r3,-128
 82107c0:	003bb706 	br	820f6a0 <___vfiprintf_internal_r+0x17c>
 82107c4:	a809883a 	mov	r4,r21
 82107c8:	d8c02a15 	stw	r3,168(sp)
 82107cc:	da002b15 	stw	r8,172(sp)
 82107d0:	8203edc0 	call	8203edc <strlen>
 82107d4:	d8c02a17 	ldw	r3,168(sp)
 82107d8:	1027883a 	mov	r19,r2
 82107dc:	df001d83 	ldbu	fp,118(sp)
 82107e0:	d8c02215 	stw	r3,136(sp)
 82107e4:	0013883a 	mov	r9,zero
 82107e8:	da002b17 	ldw	r8,172(sp)
 82107ec:	003c4d06 	br	820f924 <___vfiprintf_internal_r+0x400>
 82107f0:	d9402117 	ldw	r5,132(sp)
 82107f4:	d9002017 	ldw	r4,128(sp)
 82107f8:	d9801a04 	addi	r6,sp,104
 82107fc:	da402c15 	stw	r9,176(sp)
 8210800:	820f4100 	call	820f410 <__sprint_r.part.0>
 8210804:	da402c17 	ldw	r9,176(sp)
 8210808:	103e9a1e 	bne	r2,zero,8210274 <___vfiprintf_internal_r+0xd50>
 821080c:	d9401b17 	ldw	r5,108(sp)
 8210810:	d8801c17 	ldw	r2,112(sp)
 8210814:	d811883a 	mov	r8,sp
 8210818:	29000044 	addi	r4,r5,1
 821081c:	003e4206 	br	8210128 <___vfiprintf_internal_r+0xc04>
 8210820:	d9401b17 	ldw	r5,108(sp)
 8210824:	01020974 	movhi	r4,2085
 8210828:	21374004 	addi	r4,r4,-8960
 821082c:	d9002415 	stw	r4,144(sp)
 8210830:	29400044 	addi	r5,r5,1
 8210834:	003c6d06 	br	820f9ec <___vfiprintf_internal_r+0x4c8>
 8210838:	0039883a 	mov	fp,zero
 821083c:	00800084 	movi	r2,2
 8210840:	10803fcc 	andi	r2,r2,255
 8210844:	01000044 	movi	r4,1
 8210848:	11001e26 	beq	r2,r4,82108c4 <___vfiprintf_internal_r+0x13a0>
 821084c:	01000084 	movi	r4,2
 8210850:	11001e1e 	bne	r2,r4,82108cc <___vfiprintf_internal_r+0x13a8>
 8210854:	1829883a 	mov	r20,r3
 8210858:	003eea06 	br	8210404 <___vfiprintf_internal_r+0xee0>
 821085c:	a007883a 	mov	r3,r20
 8210860:	00800044 	movi	r2,1
 8210864:	003ff606 	br	8210840 <___vfiprintf_internal_r+0x131c>
 8210868:	00800184 	movi	r2,6
 821086c:	1240012e 	bgeu	r2,r9,8210874 <___vfiprintf_internal_r+0x1350>
 8210870:	1013883a 	mov	r9,r2
 8210874:	4827883a 	mov	r19,r9
 8210878:	4825883a 	mov	r18,r9
 821087c:	48001516 	blt	r9,zero,82108d4 <___vfiprintf_internal_r+0x13b0>
 8210880:	05420974 	movhi	r21,2085
 8210884:	d8c02215 	stw	r3,136(sp)
 8210888:	ad76d104 	addi	r21,r21,-9404
 821088c:	003d1406 	br	820fce0 <___vfiprintf_internal_r+0x7bc>
 8210890:	02820974 	movhi	r10,2085
 8210894:	52b73c04 	addi	r10,r10,-8976
 8210898:	da802415 	stw	r10,144(sp)
 821089c:	200d883a 	mov	r6,r4
 82108a0:	003c9106 	br	820fae8 <___vfiprintf_internal_r+0x5c4>
 82108a4:	5021883a 	mov	r16,r10
 82108a8:	0013883a 	mov	r9,zero
 82108ac:	003b7d06 	br	820f6a4 <___vfiprintf_internal_r+0x180>
 82108b0:	4827883a 	mov	r19,r9
 82108b4:	df001d83 	ldbu	fp,118(sp)
 82108b8:	d8c02215 	stw	r3,136(sp)
 82108bc:	0013883a 	mov	r9,zero
 82108c0:	003c1806 	br	820f924 <___vfiprintf_internal_r+0x400>
 82108c4:	1829883a 	mov	r20,r3
 82108c8:	003d1806 	br	820fd2c <___vfiprintf_internal_r+0x808>
 82108cc:	1829883a 	mov	r20,r3
 82108d0:	003ccd06 	br	820fc08 <___vfiprintf_internal_r+0x6e4>
 82108d4:	0025883a 	mov	r18,zero
 82108d8:	003fe906 	br	8210880 <___vfiprintf_internal_r+0x135c>
 82108dc:	d8802217 	ldw	r2,136(sp)
 82108e0:	80c00043 	ldbu	r3,1(r16)
 82108e4:	5021883a 	mov	r16,r10
 82108e8:	12400017 	ldw	r9,0(r2)
 82108ec:	10800104 	addi	r2,r2,4
 82108f0:	d8802215 	stw	r2,136(sp)
 82108f4:	483faf0e 	bge	r9,zero,82107b4 <___vfiprintf_internal_r+0x1290>
 82108f8:	18c03fcc 	andi	r3,r3,255
 82108fc:	18c0201c 	xori	r3,r3,128
 8210900:	027fffc4 	movi	r9,-1
 8210904:	18ffe004 	addi	r3,r3,-128
 8210908:	003b6506 	br	820f6a0 <___vfiprintf_internal_r+0x17c>
 821090c:	d9c01d85 	stb	r7,118(sp)
 8210910:	003ca006 	br	820fb94 <___vfiprintf_internal_r+0x670>
 8210914:	d9c01d85 	stb	r7,118(sp)
 8210918:	003cad06 	br	820fbd0 <___vfiprintf_internal_r+0x6ac>
 821091c:	d9c01d85 	stb	r7,118(sp)
 8210920:	003d7d06 	br	820ff18 <___vfiprintf_internal_r+0x9f4>
 8210924:	d9c01d85 	stb	r7,118(sp)
 8210928:	003d5f06 	br	820fea8 <___vfiprintf_internal_r+0x984>
 821092c:	a080004c 	andi	r2,r20,1
 8210930:	0039883a 	mov	fp,zero
 8210934:	10000526 	beq	r2,zero,821094c <___vfiprintf_internal_r+0x1428>
 8210938:	00800c04 	movi	r2,48
 821093c:	d88019c5 	stb	r2,103(sp)
 8210940:	dcc02717 	ldw	r19,156(sp)
 8210944:	dd4019c4 	addi	r21,sp,103
 8210948:	003bf606 	br	820f924 <___vfiprintf_internal_r+0x400>
 821094c:	0027883a 	mov	r19,zero
 8210950:	dd401a04 	addi	r21,sp,104
 8210954:	003bf306 	br	820f924 <___vfiprintf_internal_r+0x400>
 8210958:	d9c01d85 	stb	r7,118(sp)
 821095c:	003dc806 	br	8210080 <___vfiprintf_internal_r+0xb5c>
 8210960:	d9c01d85 	stb	r7,118(sp)
 8210964:	003d3a06 	br	820fe50 <___vfiprintf_internal_r+0x92c>
 8210968:	d9c01d85 	stb	r7,118(sp)
 821096c:	003d2a06 	br	820fe18 <___vfiprintf_internal_r+0x8f4>
 8210970:	d9c01d85 	stb	r7,118(sp)
 8210974:	003cde06 	br	820fcf0 <___vfiprintf_internal_r+0x7cc>
 8210978:	d9c01d85 	stb	r7,118(sp)
 821097c:	003cbc06 	br	820fc70 <___vfiprintf_internal_r+0x74c>

08210980 <__vfiprintf_internal>:
 8210980:	00820974 	movhi	r2,2085
 8210984:	108fa204 	addi	r2,r2,16008
 8210988:	300f883a 	mov	r7,r6
 821098c:	280d883a 	mov	r6,r5
 8210990:	200b883a 	mov	r5,r4
 8210994:	11000017 	ldw	r4,0(r2)
 8210998:	820f5241 	jmpi	820f524 <___vfiprintf_internal_r>

0821099c <__sbprintf>:
 821099c:	2880030b 	ldhu	r2,12(r5)
 82109a0:	2ac01917 	ldw	r11,100(r5)
 82109a4:	2a80038b 	ldhu	r10,14(r5)
 82109a8:	2a400717 	ldw	r9,28(r5)
 82109ac:	2a000917 	ldw	r8,36(r5)
 82109b0:	defee204 	addi	sp,sp,-1144
 82109b4:	00c10004 	movi	r3,1024
 82109b8:	dc011a15 	stw	r16,1128(sp)
 82109bc:	10bfff4c 	andi	r2,r2,65533
 82109c0:	2821883a 	mov	r16,r5
 82109c4:	d8cb883a 	add	r5,sp,r3
 82109c8:	dc811c15 	stw	r18,1136(sp)
 82109cc:	dc411b15 	stw	r17,1132(sp)
 82109d0:	dfc11d15 	stw	ra,1140(sp)
 82109d4:	2025883a 	mov	r18,r4
 82109d8:	d881030d 	sth	r2,1036(sp)
 82109dc:	dac11915 	stw	r11,1124(sp)
 82109e0:	da81038d 	sth	r10,1038(sp)
 82109e4:	da410715 	stw	r9,1052(sp)
 82109e8:	da010915 	stw	r8,1060(sp)
 82109ec:	dec10015 	stw	sp,1024(sp)
 82109f0:	dec10415 	stw	sp,1040(sp)
 82109f4:	d8c10215 	stw	r3,1032(sp)
 82109f8:	d8c10515 	stw	r3,1044(sp)
 82109fc:	d8010615 	stw	zero,1048(sp)
 8210a00:	820f5240 	call	820f524 <___vfiprintf_internal_r>
 8210a04:	1023883a 	mov	r17,r2
 8210a08:	10000416 	blt	r2,zero,8210a1c <__sbprintf+0x80>
 8210a0c:	d9410004 	addi	r5,sp,1024
 8210a10:	9009883a 	mov	r4,r18
 8210a14:	820a9d80 	call	820a9d8 <_fflush_r>
 8210a18:	10000d1e 	bne	r2,zero,8210a50 <__sbprintf+0xb4>
 8210a1c:	d881030b 	ldhu	r2,1036(sp)
 8210a20:	1080100c 	andi	r2,r2,64
 8210a24:	10000326 	beq	r2,zero,8210a34 <__sbprintf+0x98>
 8210a28:	8080030b 	ldhu	r2,12(r16)
 8210a2c:	10801014 	ori	r2,r2,64
 8210a30:	8080030d 	sth	r2,12(r16)
 8210a34:	8805883a 	mov	r2,r17
 8210a38:	dfc11d17 	ldw	ra,1140(sp)
 8210a3c:	dc811c17 	ldw	r18,1136(sp)
 8210a40:	dc411b17 	ldw	r17,1132(sp)
 8210a44:	dc011a17 	ldw	r16,1128(sp)
 8210a48:	dec11e04 	addi	sp,sp,1144
 8210a4c:	f800283a 	ret
 8210a50:	047fffc4 	movi	r17,-1
 8210a54:	003ff106 	br	8210a1c <__sbprintf+0x80>

08210a58 <_write_r>:
 8210a58:	defffd04 	addi	sp,sp,-12
 8210a5c:	2805883a 	mov	r2,r5
 8210a60:	dc000015 	stw	r16,0(sp)
 8210a64:	04020974 	movhi	r16,2085
 8210a68:	dc400115 	stw	r17,4(sp)
 8210a6c:	300b883a 	mov	r5,r6
 8210a70:	84100304 	addi	r16,r16,16396
 8210a74:	2023883a 	mov	r17,r4
 8210a78:	380d883a 	mov	r6,r7
 8210a7c:	1009883a 	mov	r4,r2
 8210a80:	dfc00215 	stw	ra,8(sp)
 8210a84:	80000015 	stw	zero,0(r16)
 8210a88:	82259740 	call	8225974 <write>
 8210a8c:	00ffffc4 	movi	r3,-1
 8210a90:	10c00526 	beq	r2,r3,8210aa8 <_write_r+0x50>
 8210a94:	dfc00217 	ldw	ra,8(sp)
 8210a98:	dc400117 	ldw	r17,4(sp)
 8210a9c:	dc000017 	ldw	r16,0(sp)
 8210aa0:	dec00304 	addi	sp,sp,12
 8210aa4:	f800283a 	ret
 8210aa8:	80c00017 	ldw	r3,0(r16)
 8210aac:	183ff926 	beq	r3,zero,8210a94 <_write_r+0x3c>
 8210ab0:	88c00015 	stw	r3,0(r17)
 8210ab4:	003ff706 	br	8210a94 <_write_r+0x3c>

08210ab8 <_close_r>:
 8210ab8:	defffd04 	addi	sp,sp,-12
 8210abc:	dc000015 	stw	r16,0(sp)
 8210ac0:	04020974 	movhi	r16,2085
 8210ac4:	dc400115 	stw	r17,4(sp)
 8210ac8:	84100304 	addi	r16,r16,16396
 8210acc:	2023883a 	mov	r17,r4
 8210ad0:	2809883a 	mov	r4,r5
 8210ad4:	dfc00215 	stw	ra,8(sp)
 8210ad8:	80000015 	stw	zero,0(r16)
 8210adc:	82257740 	call	8225774 <close>
 8210ae0:	00ffffc4 	movi	r3,-1
 8210ae4:	10c00526 	beq	r2,r3,8210afc <_close_r+0x44>
 8210ae8:	dfc00217 	ldw	ra,8(sp)
 8210aec:	dc400117 	ldw	r17,4(sp)
 8210af0:	dc000017 	ldw	r16,0(sp)
 8210af4:	dec00304 	addi	sp,sp,12
 8210af8:	f800283a 	ret
 8210afc:	80c00017 	ldw	r3,0(r16)
 8210b00:	183ff926 	beq	r3,zero,8210ae8 <_close_r+0x30>
 8210b04:	88c00015 	stw	r3,0(r17)
 8210b08:	003ff706 	br	8210ae8 <_close_r+0x30>

08210b0c <_calloc_r>:
 8210b0c:	298b383a 	mul	r5,r5,r6
 8210b10:	defffe04 	addi	sp,sp,-8
 8210b14:	dfc00115 	stw	ra,4(sp)
 8210b18:	dc000015 	stw	r16,0(sp)
 8210b1c:	820bc680 	call	820bc68 <_malloc_r>
 8210b20:	10002926 	beq	r2,zero,8210bc8 <_calloc_r+0xbc>
 8210b24:	11bfff17 	ldw	r6,-4(r2)
 8210b28:	1021883a 	mov	r16,r2
 8210b2c:	00bfff04 	movi	r2,-4
 8210b30:	308c703a 	and	r6,r6,r2
 8210b34:	00c00904 	movi	r3,36
 8210b38:	308d883a 	add	r6,r6,r2
 8210b3c:	19801636 	bltu	r3,r6,8210b98 <_calloc_r+0x8c>
 8210b40:	008004c4 	movi	r2,19
 8210b44:	11800b2e 	bgeu	r2,r6,8210b74 <_calloc_r+0x68>
 8210b48:	80000015 	stw	zero,0(r16)
 8210b4c:	80000115 	stw	zero,4(r16)
 8210b50:	008006c4 	movi	r2,27
 8210b54:	11801a2e 	bgeu	r2,r6,8210bc0 <_calloc_r+0xb4>
 8210b58:	80000215 	stw	zero,8(r16)
 8210b5c:	80000315 	stw	zero,12(r16)
 8210b60:	30c0151e 	bne	r6,r3,8210bb8 <_calloc_r+0xac>
 8210b64:	80000415 	stw	zero,16(r16)
 8210b68:	80800604 	addi	r2,r16,24
 8210b6c:	80000515 	stw	zero,20(r16)
 8210b70:	00000106 	br	8210b78 <_calloc_r+0x6c>
 8210b74:	8005883a 	mov	r2,r16
 8210b78:	10000015 	stw	zero,0(r2)
 8210b7c:	10000115 	stw	zero,4(r2)
 8210b80:	10000215 	stw	zero,8(r2)
 8210b84:	8005883a 	mov	r2,r16
 8210b88:	dfc00117 	ldw	ra,4(sp)
 8210b8c:	dc000017 	ldw	r16,0(sp)
 8210b90:	dec00204 	addi	sp,sp,8
 8210b94:	f800283a 	ret
 8210b98:	000b883a 	mov	r5,zero
 8210b9c:	8009883a 	mov	r4,r16
 8210ba0:	82031300 	call	8203130 <memset>
 8210ba4:	8005883a 	mov	r2,r16
 8210ba8:	dfc00117 	ldw	ra,4(sp)
 8210bac:	dc000017 	ldw	r16,0(sp)
 8210bb0:	dec00204 	addi	sp,sp,8
 8210bb4:	f800283a 	ret
 8210bb8:	80800404 	addi	r2,r16,16
 8210bbc:	003fee06 	br	8210b78 <_calloc_r+0x6c>
 8210bc0:	80800204 	addi	r2,r16,8
 8210bc4:	003fec06 	br	8210b78 <_calloc_r+0x6c>
 8210bc8:	0005883a 	mov	r2,zero
 8210bcc:	003fee06 	br	8210b88 <_calloc_r+0x7c>

08210bd0 <_fclose_r>:
 8210bd0:	28003926 	beq	r5,zero,8210cb8 <_fclose_r+0xe8>
 8210bd4:	defffc04 	addi	sp,sp,-16
 8210bd8:	dc400115 	stw	r17,4(sp)
 8210bdc:	dc000015 	stw	r16,0(sp)
 8210be0:	dfc00315 	stw	ra,12(sp)
 8210be4:	dc800215 	stw	r18,8(sp)
 8210be8:	2023883a 	mov	r17,r4
 8210bec:	2821883a 	mov	r16,r5
 8210bf0:	20000226 	beq	r4,zero,8210bfc <_fclose_r+0x2c>
 8210bf4:	20800e17 	ldw	r2,56(r4)
 8210bf8:	10002726 	beq	r2,zero,8210c98 <_fclose_r+0xc8>
 8210bfc:	8080030f 	ldh	r2,12(r16)
 8210c00:	1000071e 	bne	r2,zero,8210c20 <_fclose_r+0x50>
 8210c04:	0005883a 	mov	r2,zero
 8210c08:	dfc00317 	ldw	ra,12(sp)
 8210c0c:	dc800217 	ldw	r18,8(sp)
 8210c10:	dc400117 	ldw	r17,4(sp)
 8210c14:	dc000017 	ldw	r16,0(sp)
 8210c18:	dec00404 	addi	sp,sp,16
 8210c1c:	f800283a 	ret
 8210c20:	800b883a 	mov	r5,r16
 8210c24:	8809883a 	mov	r4,r17
 8210c28:	820a7bc0 	call	820a7bc <__sflush_r>
 8210c2c:	1025883a 	mov	r18,r2
 8210c30:	80800b17 	ldw	r2,44(r16)
 8210c34:	10000426 	beq	r2,zero,8210c48 <_fclose_r+0x78>
 8210c38:	81400717 	ldw	r5,28(r16)
 8210c3c:	8809883a 	mov	r4,r17
 8210c40:	103ee83a 	callr	r2
 8210c44:	10001616 	blt	r2,zero,8210ca0 <_fclose_r+0xd0>
 8210c48:	8080030b 	ldhu	r2,12(r16)
 8210c4c:	1080200c 	andi	r2,r2,128
 8210c50:	1000151e 	bne	r2,zero,8210ca8 <_fclose_r+0xd8>
 8210c54:	81400c17 	ldw	r5,48(r16)
 8210c58:	28000526 	beq	r5,zero,8210c70 <_fclose_r+0xa0>
 8210c5c:	80801004 	addi	r2,r16,64
 8210c60:	28800226 	beq	r5,r2,8210c6c <_fclose_r+0x9c>
 8210c64:	8809883a 	mov	r4,r17
 8210c68:	820b07c0 	call	820b07c <_free_r>
 8210c6c:	80000c15 	stw	zero,48(r16)
 8210c70:	81401117 	ldw	r5,68(r16)
 8210c74:	28000326 	beq	r5,zero,8210c84 <_fclose_r+0xb4>
 8210c78:	8809883a 	mov	r4,r17
 8210c7c:	820b07c0 	call	820b07c <_free_r>
 8210c80:	80001115 	stw	zero,68(r16)
 8210c84:	820adc40 	call	820adc4 <__sfp_lock_acquire>
 8210c88:	8000030d 	sth	zero,12(r16)
 8210c8c:	820adc80 	call	820adc8 <__sfp_lock_release>
 8210c90:	9005883a 	mov	r2,r18
 8210c94:	003fdc06 	br	8210c08 <_fclose_r+0x38>
 8210c98:	820adb40 	call	820adb4 <__sinit>
 8210c9c:	003fd706 	br	8210bfc <_fclose_r+0x2c>
 8210ca0:	04bfffc4 	movi	r18,-1
 8210ca4:	003fe806 	br	8210c48 <_fclose_r+0x78>
 8210ca8:	81400417 	ldw	r5,16(r16)
 8210cac:	8809883a 	mov	r4,r17
 8210cb0:	820b07c0 	call	820b07c <_free_r>
 8210cb4:	003fe706 	br	8210c54 <_fclose_r+0x84>
 8210cb8:	0005883a 	mov	r2,zero
 8210cbc:	f800283a 	ret

08210cc0 <fclose>:
 8210cc0:	00820974 	movhi	r2,2085
 8210cc4:	108fa204 	addi	r2,r2,16008
 8210cc8:	200b883a 	mov	r5,r4
 8210ccc:	11000017 	ldw	r4,0(r2)
 8210cd0:	8210bd01 	jmpi	8210bd0 <_fclose_r>

08210cd4 <__fputwc>:
 8210cd4:	defff804 	addi	sp,sp,-32
 8210cd8:	dcc00415 	stw	r19,16(sp)
 8210cdc:	dc800315 	stw	r18,12(sp)
 8210ce0:	dc000115 	stw	r16,4(sp)
 8210ce4:	dfc00715 	stw	ra,28(sp)
 8210ce8:	dd400615 	stw	r21,24(sp)
 8210cec:	dd000515 	stw	r20,20(sp)
 8210cf0:	dc400215 	stw	r17,8(sp)
 8210cf4:	2027883a 	mov	r19,r4
 8210cf8:	2825883a 	mov	r18,r5
 8210cfc:	3021883a 	mov	r16,r6
 8210d00:	820ba580 	call	820ba58 <__locale_mb_cur_max>
 8210d04:	00c00044 	movi	r3,1
 8210d08:	10c03e26 	beq	r2,r3,8210e04 <__fputwc+0x130>
 8210d0c:	81c01704 	addi	r7,r16,92
 8210d10:	900d883a 	mov	r6,r18
 8210d14:	d80b883a 	mov	r5,sp
 8210d18:	9809883a 	mov	r4,r19
 8210d1c:	821104c0 	call	821104c <_wcrtomb_r>
 8210d20:	1029883a 	mov	r20,r2
 8210d24:	00bfffc4 	movi	r2,-1
 8210d28:	a0802026 	beq	r20,r2,8210dac <__fputwc+0xd8>
 8210d2c:	d9400003 	ldbu	r5,0(sp)
 8210d30:	a0001c26 	beq	r20,zero,8210da4 <__fputwc+0xd0>
 8210d34:	0023883a 	mov	r17,zero
 8210d38:	05400284 	movi	r21,10
 8210d3c:	00000906 	br	8210d64 <__fputwc+0x90>
 8210d40:	80800017 	ldw	r2,0(r16)
 8210d44:	11400005 	stb	r5,0(r2)
 8210d48:	80c00017 	ldw	r3,0(r16)
 8210d4c:	18c00044 	addi	r3,r3,1
 8210d50:	80c00015 	stw	r3,0(r16)
 8210d54:	8c400044 	addi	r17,r17,1
 8210d58:	dc45883a 	add	r2,sp,r17
 8210d5c:	8d00112e 	bgeu	r17,r20,8210da4 <__fputwc+0xd0>
 8210d60:	11400003 	ldbu	r5,0(r2)
 8210d64:	80c00217 	ldw	r3,8(r16)
 8210d68:	18ffffc4 	addi	r3,r3,-1
 8210d6c:	80c00215 	stw	r3,8(r16)
 8210d70:	183ff30e 	bge	r3,zero,8210d40 <__fputwc+0x6c>
 8210d74:	80800617 	ldw	r2,24(r16)
 8210d78:	18801916 	blt	r3,r2,8210de0 <__fputwc+0x10c>
 8210d7c:	80800017 	ldw	r2,0(r16)
 8210d80:	11400005 	stb	r5,0(r2)
 8210d84:	80800017 	ldw	r2,0(r16)
 8210d88:	10c00003 	ldbu	r3,0(r2)
 8210d8c:	10800044 	addi	r2,r2,1
 8210d90:	1d402326 	beq	r3,r21,8210e20 <__fputwc+0x14c>
 8210d94:	80800015 	stw	r2,0(r16)
 8210d98:	8c400044 	addi	r17,r17,1
 8210d9c:	dc45883a 	add	r2,sp,r17
 8210da0:	8d3fef36 	bltu	r17,r20,8210d60 <__fputwc+0x8c>
 8210da4:	9005883a 	mov	r2,r18
 8210da8:	00000406 	br	8210dbc <__fputwc+0xe8>
 8210dac:	80c0030b 	ldhu	r3,12(r16)
 8210db0:	a005883a 	mov	r2,r20
 8210db4:	18c01014 	ori	r3,r3,64
 8210db8:	80c0030d 	sth	r3,12(r16)
 8210dbc:	dfc00717 	ldw	ra,28(sp)
 8210dc0:	dd400617 	ldw	r21,24(sp)
 8210dc4:	dd000517 	ldw	r20,20(sp)
 8210dc8:	dcc00417 	ldw	r19,16(sp)
 8210dcc:	dc800317 	ldw	r18,12(sp)
 8210dd0:	dc400217 	ldw	r17,8(sp)
 8210dd4:	dc000117 	ldw	r16,4(sp)
 8210dd8:	dec00804 	addi	sp,sp,32
 8210ddc:	f800283a 	ret
 8210de0:	800d883a 	mov	r6,r16
 8210de4:	29403fcc 	andi	r5,r5,255
 8210de8:	9809883a 	mov	r4,r19
 8210dec:	8208c880 	call	8208c88 <__swbuf_r>
 8210df0:	10bfffe0 	cmpeqi	r2,r2,-1
 8210df4:	10803fcc 	andi	r2,r2,255
 8210df8:	103fd626 	beq	r2,zero,8210d54 <__fputwc+0x80>
 8210dfc:	00bfffc4 	movi	r2,-1
 8210e00:	003fee06 	br	8210dbc <__fputwc+0xe8>
 8210e04:	90ffffc4 	addi	r3,r18,-1
 8210e08:	01003f84 	movi	r4,254
 8210e0c:	20ffbf36 	bltu	r4,r3,8210d0c <__fputwc+0x38>
 8210e10:	900b883a 	mov	r5,r18
 8210e14:	dc800005 	stb	r18,0(sp)
 8210e18:	1029883a 	mov	r20,r2
 8210e1c:	003fc506 	br	8210d34 <__fputwc+0x60>
 8210e20:	800d883a 	mov	r6,r16
 8210e24:	a80b883a 	mov	r5,r21
 8210e28:	9809883a 	mov	r4,r19
 8210e2c:	8208c880 	call	8208c88 <__swbuf_r>
 8210e30:	10bfffe0 	cmpeqi	r2,r2,-1
 8210e34:	003fef06 	br	8210df4 <__fputwc+0x120>

08210e38 <_fputwc_r>:
 8210e38:	3080030b 	ldhu	r2,12(r6)
 8210e3c:	10c8000c 	andi	r3,r2,8192
 8210e40:	1800051e 	bne	r3,zero,8210e58 <_fputwc_r+0x20>
 8210e44:	30c01917 	ldw	r3,100(r6)
 8210e48:	10880014 	ori	r2,r2,8192
 8210e4c:	3080030d 	sth	r2,12(r6)
 8210e50:	18880014 	ori	r2,r3,8192
 8210e54:	30801915 	stw	r2,100(r6)
 8210e58:	8210cd41 	jmpi	8210cd4 <__fputwc>

08210e5c <fputwc>:
 8210e5c:	00820974 	movhi	r2,2085
 8210e60:	defffc04 	addi	sp,sp,-16
 8210e64:	108fa204 	addi	r2,r2,16008
 8210e68:	dc000115 	stw	r16,4(sp)
 8210e6c:	14000017 	ldw	r16,0(r2)
 8210e70:	dc400215 	stw	r17,8(sp)
 8210e74:	dfc00315 	stw	ra,12(sp)
 8210e78:	2023883a 	mov	r17,r4
 8210e7c:	80000226 	beq	r16,zero,8210e88 <fputwc+0x2c>
 8210e80:	80800e17 	ldw	r2,56(r16)
 8210e84:	10001026 	beq	r2,zero,8210ec8 <fputwc+0x6c>
 8210e88:	2880030b 	ldhu	r2,12(r5)
 8210e8c:	10c8000c 	andi	r3,r2,8192
 8210e90:	1800051e 	bne	r3,zero,8210ea8 <fputwc+0x4c>
 8210e94:	28c01917 	ldw	r3,100(r5)
 8210e98:	10880014 	ori	r2,r2,8192
 8210e9c:	2880030d 	sth	r2,12(r5)
 8210ea0:	18880014 	ori	r2,r3,8192
 8210ea4:	28801915 	stw	r2,100(r5)
 8210ea8:	280d883a 	mov	r6,r5
 8210eac:	8009883a 	mov	r4,r16
 8210eb0:	880b883a 	mov	r5,r17
 8210eb4:	dfc00317 	ldw	ra,12(sp)
 8210eb8:	dc400217 	ldw	r17,8(sp)
 8210ebc:	dc000117 	ldw	r16,4(sp)
 8210ec0:	dec00404 	addi	sp,sp,16
 8210ec4:	8210cd41 	jmpi	8210cd4 <__fputwc>
 8210ec8:	8009883a 	mov	r4,r16
 8210ecc:	d9400015 	stw	r5,0(sp)
 8210ed0:	820adb40 	call	820adb4 <__sinit>
 8210ed4:	d9400017 	ldw	r5,0(sp)
 8210ed8:	003feb06 	br	8210e88 <fputwc+0x2c>

08210edc <_fstat_r>:
 8210edc:	defffd04 	addi	sp,sp,-12
 8210ee0:	2805883a 	mov	r2,r5
 8210ee4:	dc000015 	stw	r16,0(sp)
 8210ee8:	04020974 	movhi	r16,2085
 8210eec:	dc400115 	stw	r17,4(sp)
 8210ef0:	84100304 	addi	r16,r16,16396
 8210ef4:	2023883a 	mov	r17,r4
 8210ef8:	300b883a 	mov	r5,r6
 8210efc:	1009883a 	mov	r4,r2
 8210f00:	dfc00215 	stw	ra,8(sp)
 8210f04:	80000015 	stw	zero,0(r16)
 8210f08:	82144440 	call	8214444 <fstat>
 8210f0c:	00ffffc4 	movi	r3,-1
 8210f10:	10c00526 	beq	r2,r3,8210f28 <_fstat_r+0x4c>
 8210f14:	dfc00217 	ldw	ra,8(sp)
 8210f18:	dc400117 	ldw	r17,4(sp)
 8210f1c:	dc000017 	ldw	r16,0(sp)
 8210f20:	dec00304 	addi	sp,sp,12
 8210f24:	f800283a 	ret
 8210f28:	80c00017 	ldw	r3,0(r16)
 8210f2c:	183ff926 	beq	r3,zero,8210f14 <_fstat_r+0x38>
 8210f30:	88c00015 	stw	r3,0(r17)
 8210f34:	003ff706 	br	8210f14 <_fstat_r+0x38>

08210f38 <_isatty_r>:
 8210f38:	defffd04 	addi	sp,sp,-12
 8210f3c:	dc000015 	stw	r16,0(sp)
 8210f40:	04020974 	movhi	r16,2085
 8210f44:	dc400115 	stw	r17,4(sp)
 8210f48:	84100304 	addi	r16,r16,16396
 8210f4c:	2023883a 	mov	r17,r4
 8210f50:	2809883a 	mov	r4,r5
 8210f54:	dfc00215 	stw	ra,8(sp)
 8210f58:	80000015 	stw	zero,0(r16)
 8210f5c:	82145300 	call	8214530 <isatty>
 8210f60:	00ffffc4 	movi	r3,-1
 8210f64:	10c00526 	beq	r2,r3,8210f7c <_isatty_r+0x44>
 8210f68:	dfc00217 	ldw	ra,8(sp)
 8210f6c:	dc400117 	ldw	r17,4(sp)
 8210f70:	dc000017 	ldw	r16,0(sp)
 8210f74:	dec00304 	addi	sp,sp,12
 8210f78:	f800283a 	ret
 8210f7c:	80c00017 	ldw	r3,0(r16)
 8210f80:	183ff926 	beq	r3,zero,8210f68 <_isatty_r+0x30>
 8210f84:	88c00015 	stw	r3,0(r17)
 8210f88:	003ff706 	br	8210f68 <_isatty_r+0x30>

08210f8c <_lseek_r>:
 8210f8c:	defffd04 	addi	sp,sp,-12
 8210f90:	2805883a 	mov	r2,r5
 8210f94:	dc000015 	stw	r16,0(sp)
 8210f98:	04020974 	movhi	r16,2085
 8210f9c:	dc400115 	stw	r17,4(sp)
 8210fa0:	300b883a 	mov	r5,r6
 8210fa4:	84100304 	addi	r16,r16,16396
 8210fa8:	2023883a 	mov	r17,r4
 8210fac:	380d883a 	mov	r6,r7
 8210fb0:	1009883a 	mov	r4,r2
 8210fb4:	dfc00215 	stw	ra,8(sp)
 8210fb8:	80000015 	stw	zero,0(r16)
 8210fbc:	82146100 	call	8214610 <lseek>
 8210fc0:	00ffffc4 	movi	r3,-1
 8210fc4:	10c00526 	beq	r2,r3,8210fdc <_lseek_r+0x50>
 8210fc8:	dfc00217 	ldw	ra,8(sp)
 8210fcc:	dc400117 	ldw	r17,4(sp)
 8210fd0:	dc000017 	ldw	r16,0(sp)
 8210fd4:	dec00304 	addi	sp,sp,12
 8210fd8:	f800283a 	ret
 8210fdc:	80c00017 	ldw	r3,0(r16)
 8210fe0:	183ff926 	beq	r3,zero,8210fc8 <_lseek_r+0x3c>
 8210fe4:	88c00015 	stw	r3,0(r17)
 8210fe8:	003ff706 	br	8210fc8 <_lseek_r+0x3c>

08210fec <_read_r>:
 8210fec:	defffd04 	addi	sp,sp,-12
 8210ff0:	2805883a 	mov	r2,r5
 8210ff4:	dc000015 	stw	r16,0(sp)
 8210ff8:	04020974 	movhi	r16,2085
 8210ffc:	dc400115 	stw	r17,4(sp)
 8211000:	300b883a 	mov	r5,r6
 8211004:	84100304 	addi	r16,r16,16396
 8211008:	2023883a 	mov	r17,r4
 821100c:	380d883a 	mov	r6,r7
 8211010:	1009883a 	mov	r4,r2
 8211014:	dfc00215 	stw	ra,8(sp)
 8211018:	80000015 	stw	zero,0(r16)
 821101c:	82259040 	call	8225904 <read>
 8211020:	00ffffc4 	movi	r3,-1
 8211024:	10c00526 	beq	r2,r3,821103c <_read_r+0x50>
 8211028:	dfc00217 	ldw	ra,8(sp)
 821102c:	dc400117 	ldw	r17,4(sp)
 8211030:	dc000017 	ldw	r16,0(sp)
 8211034:	dec00304 	addi	sp,sp,12
 8211038:	f800283a 	ret
 821103c:	80c00017 	ldw	r3,0(r16)
 8211040:	183ff926 	beq	r3,zero,8211028 <_read_r+0x3c>
 8211044:	88c00015 	stw	r3,0(r17)
 8211048:	003ff706 	br	8211028 <_read_r+0x3c>

0821104c <_wcrtomb_r>:
 821104c:	defff604 	addi	sp,sp,-40
 8211050:	00820974 	movhi	r2,2085
 8211054:	dc800815 	stw	r18,32(sp)
 8211058:	dc400715 	stw	r17,28(sp)
 821105c:	dc000615 	stw	r16,24(sp)
 8211060:	108fa604 	addi	r2,r2,16024
 8211064:	dfc00915 	stw	ra,36(sp)
 8211068:	2021883a 	mov	r16,r4
 821106c:	3823883a 	mov	r17,r7
 8211070:	14800017 	ldw	r18,0(r2)
 8211074:	28001426 	beq	r5,zero,82110c8 <_wcrtomb_r+0x7c>
 8211078:	d9400415 	stw	r5,16(sp)
 821107c:	d9800515 	stw	r6,20(sp)
 8211080:	820ba4c0 	call	820ba4c <__locale_charset>
 8211084:	d9800517 	ldw	r6,20(sp)
 8211088:	d9400417 	ldw	r5,16(sp)
 821108c:	100f883a 	mov	r7,r2
 8211090:	dc400015 	stw	r17,0(sp)
 8211094:	8009883a 	mov	r4,r16
 8211098:	903ee83a 	callr	r18
 821109c:	00ffffc4 	movi	r3,-1
 82110a0:	10c0031e 	bne	r2,r3,82110b0 <_wcrtomb_r+0x64>
 82110a4:	88000015 	stw	zero,0(r17)
 82110a8:	00c02284 	movi	r3,138
 82110ac:	80c00015 	stw	r3,0(r16)
 82110b0:	dfc00917 	ldw	ra,36(sp)
 82110b4:	dc800817 	ldw	r18,32(sp)
 82110b8:	dc400717 	ldw	r17,28(sp)
 82110bc:	dc000617 	ldw	r16,24(sp)
 82110c0:	dec00a04 	addi	sp,sp,40
 82110c4:	f800283a 	ret
 82110c8:	820ba4c0 	call	820ba4c <__locale_charset>
 82110cc:	100f883a 	mov	r7,r2
 82110d0:	dc400015 	stw	r17,0(sp)
 82110d4:	000d883a 	mov	r6,zero
 82110d8:	d9400104 	addi	r5,sp,4
 82110dc:	8009883a 	mov	r4,r16
 82110e0:	903ee83a 	callr	r18
 82110e4:	003fed06 	br	821109c <_wcrtomb_r+0x50>

082110e8 <wcrtomb>:
 82110e8:	defff604 	addi	sp,sp,-40
 82110ec:	00820974 	movhi	r2,2085
 82110f0:	dc800615 	stw	r18,24(sp)
 82110f4:	dc400515 	stw	r17,20(sp)
 82110f8:	108fa204 	addi	r2,r2,16008
 82110fc:	dfc00915 	stw	ra,36(sp)
 8211100:	dd000815 	stw	r20,32(sp)
 8211104:	dcc00715 	stw	r19,28(sp)
 8211108:	dc000415 	stw	r16,16(sp)
 821110c:	3025883a 	mov	r18,r6
 8211110:	14400017 	ldw	r17,0(r2)
 8211114:	20001926 	beq	r4,zero,821117c <wcrtomb+0x94>
 8211118:	00820974 	movhi	r2,2085
 821111c:	108fa604 	addi	r2,r2,16024
 8211120:	15000017 	ldw	r20,0(r2)
 8211124:	2021883a 	mov	r16,r4
 8211128:	2827883a 	mov	r19,r5
 821112c:	820ba4c0 	call	820ba4c <__locale_charset>
 8211130:	100f883a 	mov	r7,r2
 8211134:	dc800015 	stw	r18,0(sp)
 8211138:	980d883a 	mov	r6,r19
 821113c:	800b883a 	mov	r5,r16
 8211140:	8809883a 	mov	r4,r17
 8211144:	a03ee83a 	callr	r20
 8211148:	00ffffc4 	movi	r3,-1
 821114c:	10c0031e 	bne	r2,r3,821115c <wcrtomb+0x74>
 8211150:	90000015 	stw	zero,0(r18)
 8211154:	00c02284 	movi	r3,138
 8211158:	88c00015 	stw	r3,0(r17)
 821115c:	dfc00917 	ldw	ra,36(sp)
 8211160:	dd000817 	ldw	r20,32(sp)
 8211164:	dcc00717 	ldw	r19,28(sp)
 8211168:	dc800617 	ldw	r18,24(sp)
 821116c:	dc400517 	ldw	r17,20(sp)
 8211170:	dc000417 	ldw	r16,16(sp)
 8211174:	dec00a04 	addi	sp,sp,40
 8211178:	f800283a 	ret
 821117c:	00820974 	movhi	r2,2085
 8211180:	108fa604 	addi	r2,r2,16024
 8211184:	14000017 	ldw	r16,0(r2)
 8211188:	820ba4c0 	call	820ba4c <__locale_charset>
 821118c:	100f883a 	mov	r7,r2
 8211190:	dc800015 	stw	r18,0(sp)
 8211194:	000d883a 	mov	r6,zero
 8211198:	d9400104 	addi	r5,sp,4
 821119c:	8809883a 	mov	r4,r17
 82111a0:	803ee83a 	callr	r16
 82111a4:	003fe806 	br	8211148 <wcrtomb+0x60>

082111a8 <__ascii_wctomb>:
 82111a8:	28000526 	beq	r5,zero,82111c0 <__ascii_wctomb+0x18>
 82111ac:	00803fc4 	movi	r2,255
 82111b0:	11800536 	bltu	r2,r6,82111c8 <__ascii_wctomb+0x20>
 82111b4:	29800005 	stb	r6,0(r5)
 82111b8:	00800044 	movi	r2,1
 82111bc:	f800283a 	ret
 82111c0:	0005883a 	mov	r2,zero
 82111c4:	f800283a 	ret
 82111c8:	00802284 	movi	r2,138
 82111cc:	20800015 	stw	r2,0(r4)
 82111d0:	00bfffc4 	movi	r2,-1
 82111d4:	f800283a 	ret

082111d8 <_wctomb_r>:
 82111d8:	00820974 	movhi	r2,2085
 82111dc:	defff904 	addi	sp,sp,-28
 82111e0:	108fa604 	addi	r2,r2,16024
 82111e4:	dfc00615 	stw	ra,24(sp)
 82111e8:	dc400515 	stw	r17,20(sp)
 82111ec:	dc000415 	stw	r16,16(sp)
 82111f0:	3823883a 	mov	r17,r7
 82111f4:	14000017 	ldw	r16,0(r2)
 82111f8:	d9000115 	stw	r4,4(sp)
 82111fc:	d9400215 	stw	r5,8(sp)
 8211200:	d9800315 	stw	r6,12(sp)
 8211204:	820ba4c0 	call	820ba4c <__locale_charset>
 8211208:	d9800317 	ldw	r6,12(sp)
 821120c:	d9400217 	ldw	r5,8(sp)
 8211210:	d9000117 	ldw	r4,4(sp)
 8211214:	100f883a 	mov	r7,r2
 8211218:	dc400015 	stw	r17,0(sp)
 821121c:	803ee83a 	callr	r16
 8211220:	dfc00617 	ldw	ra,24(sp)
 8211224:	dc400517 	ldw	r17,20(sp)
 8211228:	dc000417 	ldw	r16,16(sp)
 821122c:	dec00704 	addi	sp,sp,28
 8211230:	f800283a 	ret

08211234 <__udivdi3>:
 8211234:	defff504 	addi	sp,sp,-44
 8211238:	dcc00415 	stw	r19,16(sp)
 821123c:	dc000115 	stw	r16,4(sp)
 8211240:	dfc00a15 	stw	ra,40(sp)
 8211244:	df000915 	stw	fp,36(sp)
 8211248:	ddc00815 	stw	r23,32(sp)
 821124c:	dd800715 	stw	r22,28(sp)
 8211250:	dd400615 	stw	r21,24(sp)
 8211254:	dd000515 	stw	r20,20(sp)
 8211258:	dc800315 	stw	r18,12(sp)
 821125c:	dc400215 	stw	r17,8(sp)
 8211260:	2027883a 	mov	r19,r4
 8211264:	2821883a 	mov	r16,r5
 8211268:	3800411e 	bne	r7,zero,8211370 <__udivdi3+0x13c>
 821126c:	3023883a 	mov	r17,r6
 8211270:	2025883a 	mov	r18,r4
 8211274:	2980522e 	bgeu	r5,r6,82113c0 <__udivdi3+0x18c>
 8211278:	00bfffd4 	movui	r2,65535
 821127c:	282d883a 	mov	r22,r5
 8211280:	1180a836 	bltu	r2,r6,8211524 <__udivdi3+0x2f0>
 8211284:	00803fc4 	movi	r2,255
 8211288:	1185803a 	cmpltu	r2,r2,r6
 821128c:	100490fa 	slli	r2,r2,3
 8211290:	3086d83a 	srl	r3,r6,r2
 8211294:	01020974 	movhi	r4,2085
 8211298:	21374404 	addi	r4,r4,-8944
 821129c:	20c7883a 	add	r3,r4,r3
 82112a0:	18c00003 	ldbu	r3,0(r3)
 82112a4:	1885883a 	add	r2,r3,r2
 82112a8:	00c00804 	movi	r3,32
 82112ac:	1887c83a 	sub	r3,r3,r2
 82112b0:	18000526 	beq	r3,zero,82112c8 <__udivdi3+0x94>
 82112b4:	80e0983a 	sll	r16,r16,r3
 82112b8:	9884d83a 	srl	r2,r19,r2
 82112bc:	30e2983a 	sll	r17,r6,r3
 82112c0:	98e4983a 	sll	r18,r19,r3
 82112c4:	142cb03a 	or	r22,r2,r16
 82112c8:	882ad43a 	srli	r21,r17,16
 82112cc:	b009883a 	mov	r4,r22
 82112d0:	8d3fffcc 	andi	r20,r17,65535
 82112d4:	a80b883a 	mov	r5,r21
 82112d8:	8202bf00 	call	8202bf0 <__umodsi3>
 82112dc:	b009883a 	mov	r4,r22
 82112e0:	a80b883a 	mov	r5,r21
 82112e4:	1027883a 	mov	r19,r2
 82112e8:	8202b8c0 	call	8202b8c <__udivsi3>
 82112ec:	102d883a 	mov	r22,r2
 82112f0:	9826943a 	slli	r19,r19,16
 82112f4:	9004d43a 	srli	r2,r18,16
 82112f8:	a5a1383a 	mul	r16,r20,r22
 82112fc:	14c4b03a 	or	r2,r2,r19
 8211300:	1400052e 	bgeu	r2,r16,8211318 <__udivdi3+0xe4>
 8211304:	1445883a 	add	r2,r2,r17
 8211308:	b0ffffc4 	addi	r3,r22,-1
 821130c:	14400136 	bltu	r2,r17,8211314 <__udivdi3+0xe0>
 8211310:	14012336 	bltu	r2,r16,82117a0 <__udivdi3+0x56c>
 8211314:	182d883a 	mov	r22,r3
 8211318:	1421c83a 	sub	r16,r2,r16
 821131c:	a80b883a 	mov	r5,r21
 8211320:	8009883a 	mov	r4,r16
 8211324:	8202bf00 	call	8202bf0 <__umodsi3>
 8211328:	1027883a 	mov	r19,r2
 821132c:	a80b883a 	mov	r5,r21
 8211330:	8009883a 	mov	r4,r16
 8211334:	8202b8c0 	call	8202b8c <__udivsi3>
 8211338:	9826943a 	slli	r19,r19,16
 821133c:	a0a9383a 	mul	r20,r20,r2
 8211340:	94bfffcc 	andi	r18,r18,65535
 8211344:	94e4b03a 	or	r18,r18,r19
 8211348:	9500052e 	bgeu	r18,r20,8211360 <__udivdi3+0x12c>
 821134c:	8ca5883a 	add	r18,r17,r18
 8211350:	10ffffc4 	addi	r3,r2,-1
 8211354:	9440f136 	bltu	r18,r17,821171c <__udivdi3+0x4e8>
 8211358:	9500f02e 	bgeu	r18,r20,821171c <__udivdi3+0x4e8>
 821135c:	10bfff84 	addi	r2,r2,-2
 8211360:	b00c943a 	slli	r6,r22,16
 8211364:	0007883a 	mov	r3,zero
 8211368:	3084b03a 	or	r2,r6,r2
 821136c:	00005906 	br	82114d4 <__udivdi3+0x2a0>
 8211370:	29c05636 	bltu	r5,r7,82114cc <__udivdi3+0x298>
 8211374:	00bfffd4 	movui	r2,65535
 8211378:	11c0622e 	bgeu	r2,r7,8211504 <__udivdi3+0x2d0>
 821137c:	00804034 	movhi	r2,256
 8211380:	10bfffc4 	addi	r2,r2,-1
 8211384:	11c0ee36 	bltu	r2,r7,8211740 <__udivdi3+0x50c>
 8211388:	00800404 	movi	r2,16
 821138c:	3886d83a 	srl	r3,r7,r2
 8211390:	01020974 	movhi	r4,2085
 8211394:	21374404 	addi	r4,r4,-8944
 8211398:	20c7883a 	add	r3,r4,r3
 821139c:	18c00003 	ldbu	r3,0(r3)
 82113a0:	05400804 	movi	r21,32
 82113a4:	1885883a 	add	r2,r3,r2
 82113a8:	a8abc83a 	sub	r21,r21,r2
 82113ac:	a800621e 	bne	r21,zero,8211538 <__udivdi3+0x304>
 82113b0:	3c00e936 	bltu	r7,r16,8211758 <__udivdi3+0x524>
 82113b4:	9985403a 	cmpgeu	r2,r19,r6
 82113b8:	0007883a 	mov	r3,zero
 82113bc:	00004506 	br	82114d4 <__udivdi3+0x2a0>
 82113c0:	3000041e 	bne	r6,zero,82113d4 <__udivdi3+0x1a0>
 82113c4:	000b883a 	mov	r5,zero
 82113c8:	01000044 	movi	r4,1
 82113cc:	8202b8c0 	call	8202b8c <__udivsi3>
 82113d0:	1023883a 	mov	r17,r2
 82113d4:	00bfffd4 	movui	r2,65535
 82113d8:	14404e2e 	bgeu	r2,r17,8211514 <__udivdi3+0x2e0>
 82113dc:	00804034 	movhi	r2,256
 82113e0:	10bfffc4 	addi	r2,r2,-1
 82113e4:	1440d836 	bltu	r2,r17,8211748 <__udivdi3+0x514>
 82113e8:	00800404 	movi	r2,16
 82113ec:	8886d83a 	srl	r3,r17,r2
 82113f0:	01020974 	movhi	r4,2085
 82113f4:	21374404 	addi	r4,r4,-8944
 82113f8:	20c7883a 	add	r3,r4,r3
 82113fc:	18c00003 	ldbu	r3,0(r3)
 8211400:	1885883a 	add	r2,r3,r2
 8211404:	00c00804 	movi	r3,32
 8211408:	1887c83a 	sub	r3,r3,r2
 821140c:	18008f1e 	bne	r3,zero,821164c <__udivdi3+0x418>
 8211410:	882ad43a 	srli	r21,r17,16
 8211414:	8461c83a 	sub	r16,r16,r17
 8211418:	8d3fffcc 	andi	r20,r17,65535
 821141c:	00c00044 	movi	r3,1
 8211420:	8009883a 	mov	r4,r16
 8211424:	a80b883a 	mov	r5,r21
 8211428:	d8c00015 	stw	r3,0(sp)
 821142c:	8202bf00 	call	8202bf0 <__umodsi3>
 8211430:	8009883a 	mov	r4,r16
 8211434:	a80b883a 	mov	r5,r21
 8211438:	1027883a 	mov	r19,r2
 821143c:	8202b8c0 	call	8202b8c <__udivsi3>
 8211440:	9826943a 	slli	r19,r19,16
 8211444:	9008d43a 	srli	r4,r18,16
 8211448:	1521383a 	mul	r16,r2,r20
 821144c:	102d883a 	mov	r22,r2
 8211450:	24c8b03a 	or	r4,r4,r19
 8211454:	d8c00017 	ldw	r3,0(sp)
 8211458:	2400052e 	bgeu	r4,r16,8211470 <__udivdi3+0x23c>
 821145c:	2449883a 	add	r4,r4,r17
 8211460:	b0bfffc4 	addi	r2,r22,-1
 8211464:	24400136 	bltu	r4,r17,821146c <__udivdi3+0x238>
 8211468:	2400ca36 	bltu	r4,r16,8211794 <__udivdi3+0x560>
 821146c:	102d883a 	mov	r22,r2
 8211470:	2421c83a 	sub	r16,r4,r16
 8211474:	a80b883a 	mov	r5,r21
 8211478:	8009883a 	mov	r4,r16
 821147c:	d8c00015 	stw	r3,0(sp)
 8211480:	8202bf00 	call	8202bf0 <__umodsi3>
 8211484:	1027883a 	mov	r19,r2
 8211488:	a80b883a 	mov	r5,r21
 821148c:	8009883a 	mov	r4,r16
 8211490:	8202b8c0 	call	8202b8c <__udivsi3>
 8211494:	9826943a 	slli	r19,r19,16
 8211498:	1529383a 	mul	r20,r2,r20
 821149c:	94bfffcc 	andi	r18,r18,65535
 82114a0:	94e4b03a 	or	r18,r18,r19
 82114a4:	d8c00017 	ldw	r3,0(sp)
 82114a8:	9500052e 	bgeu	r18,r20,82114c0 <__udivdi3+0x28c>
 82114ac:	8ca5883a 	add	r18,r17,r18
 82114b0:	113fffc4 	addi	r4,r2,-1
 82114b4:	94409736 	bltu	r18,r17,8211714 <__udivdi3+0x4e0>
 82114b8:	9500962e 	bgeu	r18,r20,8211714 <__udivdi3+0x4e0>
 82114bc:	10bfff84 	addi	r2,r2,-2
 82114c0:	b00c943a 	slli	r6,r22,16
 82114c4:	3084b03a 	or	r2,r6,r2
 82114c8:	00000206 	br	82114d4 <__udivdi3+0x2a0>
 82114cc:	0007883a 	mov	r3,zero
 82114d0:	0005883a 	mov	r2,zero
 82114d4:	dfc00a17 	ldw	ra,40(sp)
 82114d8:	df000917 	ldw	fp,36(sp)
 82114dc:	ddc00817 	ldw	r23,32(sp)
 82114e0:	dd800717 	ldw	r22,28(sp)
 82114e4:	dd400617 	ldw	r21,24(sp)
 82114e8:	dd000517 	ldw	r20,20(sp)
 82114ec:	dcc00417 	ldw	r19,16(sp)
 82114f0:	dc800317 	ldw	r18,12(sp)
 82114f4:	dc400217 	ldw	r17,8(sp)
 82114f8:	dc000117 	ldw	r16,4(sp)
 82114fc:	dec00b04 	addi	sp,sp,44
 8211500:	f800283a 	ret
 8211504:	00803fc4 	movi	r2,255
 8211508:	11c5803a 	cmpltu	r2,r2,r7
 821150c:	100490fa 	slli	r2,r2,3
 8211510:	003f9e06 	br	821138c <__udivdi3+0x158>
 8211514:	00803fc4 	movi	r2,255
 8211518:	1445803a 	cmpltu	r2,r2,r17
 821151c:	100490fa 	slli	r2,r2,3
 8211520:	003fb206 	br	82113ec <__udivdi3+0x1b8>
 8211524:	00804034 	movhi	r2,256
 8211528:	10bfffc4 	addi	r2,r2,-1
 821152c:	11808836 	bltu	r2,r6,8211750 <__udivdi3+0x51c>
 8211530:	00800404 	movi	r2,16
 8211534:	003f5606 	br	8211290 <__udivdi3+0x5c>
 8211538:	30aed83a 	srl	r23,r6,r2
 821153c:	3d4e983a 	sll	r7,r7,r21
 8211540:	80acd83a 	srl	r22,r16,r2
 8211544:	9884d83a 	srl	r2,r19,r2
 8211548:	3deeb03a 	or	r23,r7,r23
 821154c:	b824d43a 	srli	r18,r23,16
 8211550:	8560983a 	sll	r16,r16,r21
 8211554:	b009883a 	mov	r4,r22
 8211558:	900b883a 	mov	r5,r18
 821155c:	3568983a 	sll	r20,r6,r21
 8211560:	1420b03a 	or	r16,r2,r16
 8211564:	8202bf00 	call	8202bf0 <__umodsi3>
 8211568:	b009883a 	mov	r4,r22
 821156c:	900b883a 	mov	r5,r18
 8211570:	1023883a 	mov	r17,r2
 8211574:	8202b8c0 	call	8202b8c <__udivsi3>
 8211578:	8808943a 	slli	r4,r17,16
 821157c:	bf3fffcc 	andi	fp,r23,65535
 8211580:	8006d43a 	srli	r3,r16,16
 8211584:	e0a3383a 	mul	r17,fp,r2
 8211588:	100d883a 	mov	r6,r2
 821158c:	1906b03a 	or	r3,r3,r4
 8211590:	1c40042e 	bgeu	r3,r17,82115a4 <__udivdi3+0x370>
 8211594:	1dc7883a 	add	r3,r3,r23
 8211598:	10bfffc4 	addi	r2,r2,-1
 821159c:	1dc0752e 	bgeu	r3,r23,8211774 <__udivdi3+0x540>
 82115a0:	100d883a 	mov	r6,r2
 82115a4:	1c63c83a 	sub	r17,r3,r17
 82115a8:	900b883a 	mov	r5,r18
 82115ac:	8809883a 	mov	r4,r17
 82115b0:	d9800015 	stw	r6,0(sp)
 82115b4:	8202bf00 	call	8202bf0 <__umodsi3>
 82115b8:	102d883a 	mov	r22,r2
 82115bc:	8809883a 	mov	r4,r17
 82115c0:	900b883a 	mov	r5,r18
 82115c4:	8202b8c0 	call	8202b8c <__udivsi3>
 82115c8:	b02c943a 	slli	r22,r22,16
 82115cc:	e089383a 	mul	r4,fp,r2
 82115d0:	843fffcc 	andi	r16,r16,65535
 82115d4:	85a0b03a 	or	r16,r16,r22
 82115d8:	d9800017 	ldw	r6,0(sp)
 82115dc:	8100042e 	bgeu	r16,r4,82115f0 <__udivdi3+0x3bc>
 82115e0:	85e1883a 	add	r16,r16,r23
 82115e4:	10ffffc4 	addi	r3,r2,-1
 82115e8:	85c05e2e 	bgeu	r16,r23,8211764 <__udivdi3+0x530>
 82115ec:	1805883a 	mov	r2,r3
 82115f0:	300c943a 	slli	r6,r6,16
 82115f4:	a17fffcc 	andi	r5,r20,65535
 82115f8:	a028d43a 	srli	r20,r20,16
 82115fc:	3084b03a 	or	r2,r6,r2
 8211600:	10ffffcc 	andi	r3,r2,65535
 8211604:	100cd43a 	srli	r6,r2,16
 8211608:	194f383a 	mul	r7,r3,r5
 821160c:	1d07383a 	mul	r3,r3,r20
 8211610:	314b383a 	mul	r5,r6,r5
 8211614:	3810d43a 	srli	r8,r7,16
 8211618:	8121c83a 	sub	r16,r16,r4
 821161c:	1947883a 	add	r3,r3,r5
 8211620:	40c7883a 	add	r3,r8,r3
 8211624:	350d383a 	mul	r6,r6,r20
 8211628:	1940022e 	bgeu	r3,r5,8211634 <__udivdi3+0x400>
 821162c:	01000074 	movhi	r4,1
 8211630:	310d883a 	add	r6,r6,r4
 8211634:	1828d43a 	srli	r20,r3,16
 8211638:	a18d883a 	add	r6,r20,r6
 821163c:	81803e36 	bltu	r16,r6,8211738 <__udivdi3+0x504>
 8211640:	81803826 	beq	r16,r6,8211724 <__udivdi3+0x4f0>
 8211644:	0007883a 	mov	r3,zero
 8211648:	003fa206 	br	82114d4 <__udivdi3+0x2a0>
 821164c:	88e2983a 	sll	r17,r17,r3
 8211650:	80a8d83a 	srl	r20,r16,r2
 8211654:	80e0983a 	sll	r16,r16,r3
 8211658:	882ad43a 	srli	r21,r17,16
 821165c:	9884d83a 	srl	r2,r19,r2
 8211660:	a009883a 	mov	r4,r20
 8211664:	a80b883a 	mov	r5,r21
 8211668:	142eb03a 	or	r23,r2,r16
 821166c:	98e4983a 	sll	r18,r19,r3
 8211670:	8202bf00 	call	8202bf0 <__umodsi3>
 8211674:	a009883a 	mov	r4,r20
 8211678:	a80b883a 	mov	r5,r21
 821167c:	1021883a 	mov	r16,r2
 8211680:	8202b8c0 	call	8202b8c <__udivsi3>
 8211684:	1039883a 	mov	fp,r2
 8211688:	8d3fffcc 	andi	r20,r17,65535
 821168c:	8020943a 	slli	r16,r16,16
 8211690:	b804d43a 	srli	r2,r23,16
 8211694:	a72d383a 	mul	r22,r20,fp
 8211698:	1404b03a 	or	r2,r2,r16
 821169c:	1580062e 	bgeu	r2,r22,82116b8 <__udivdi3+0x484>
 82116a0:	1445883a 	add	r2,r2,r17
 82116a4:	e0ffffc4 	addi	r3,fp,-1
 82116a8:	14403836 	bltu	r2,r17,821178c <__udivdi3+0x558>
 82116ac:	1580372e 	bgeu	r2,r22,821178c <__udivdi3+0x558>
 82116b0:	e73fff84 	addi	fp,fp,-2
 82116b4:	1445883a 	add	r2,r2,r17
 82116b8:	15adc83a 	sub	r22,r2,r22
 82116bc:	a80b883a 	mov	r5,r21
 82116c0:	b009883a 	mov	r4,r22
 82116c4:	8202bf00 	call	8202bf0 <__umodsi3>
 82116c8:	1027883a 	mov	r19,r2
 82116cc:	b009883a 	mov	r4,r22
 82116d0:	a80b883a 	mov	r5,r21
 82116d4:	8202b8c0 	call	8202b8c <__udivsi3>
 82116d8:	9826943a 	slli	r19,r19,16
 82116dc:	a0a1383a 	mul	r16,r20,r2
 82116e0:	b93fffcc 	andi	r4,r23,65535
 82116e4:	24c8b03a 	or	r4,r4,r19
 82116e8:	2400062e 	bgeu	r4,r16,8211704 <__udivdi3+0x4d0>
 82116ec:	2449883a 	add	r4,r4,r17
 82116f0:	10ffffc4 	addi	r3,r2,-1
 82116f4:	24402336 	bltu	r4,r17,8211784 <__udivdi3+0x550>
 82116f8:	2400222e 	bgeu	r4,r16,8211784 <__udivdi3+0x550>
 82116fc:	10bfff84 	addi	r2,r2,-2
 8211700:	2449883a 	add	r4,r4,r17
 8211704:	e038943a 	slli	fp,fp,16
 8211708:	2421c83a 	sub	r16,r4,r16
 821170c:	e086b03a 	or	r3,fp,r2
 8211710:	003f4306 	br	8211420 <__udivdi3+0x1ec>
 8211714:	2005883a 	mov	r2,r4
 8211718:	003f6906 	br	82114c0 <__udivdi3+0x28c>
 821171c:	1805883a 	mov	r2,r3
 8211720:	003f0f06 	br	8211360 <__udivdi3+0x12c>
 8211724:	1806943a 	slli	r3,r3,16
 8211728:	9d66983a 	sll	r19,r19,r21
 821172c:	39ffffcc 	andi	r7,r7,65535
 8211730:	19c7883a 	add	r3,r3,r7
 8211734:	98ffc32e 	bgeu	r19,r3,8211644 <__udivdi3+0x410>
 8211738:	10bfffc4 	addi	r2,r2,-1
 821173c:	003fc106 	br	8211644 <__udivdi3+0x410>
 8211740:	00800604 	movi	r2,24
 8211744:	003f1106 	br	821138c <__udivdi3+0x158>
 8211748:	00800604 	movi	r2,24
 821174c:	003f2706 	br	82113ec <__udivdi3+0x1b8>
 8211750:	00800604 	movi	r2,24
 8211754:	003ece06 	br	8211290 <__udivdi3+0x5c>
 8211758:	0007883a 	mov	r3,zero
 821175c:	00800044 	movi	r2,1
 8211760:	003f5c06 	br	82114d4 <__udivdi3+0x2a0>
 8211764:	813fa12e 	bgeu	r16,r4,82115ec <__udivdi3+0x3b8>
 8211768:	10bfff84 	addi	r2,r2,-2
 821176c:	85e1883a 	add	r16,r16,r23
 8211770:	003f9f06 	br	82115f0 <__udivdi3+0x3bc>
 8211774:	1c7f8a2e 	bgeu	r3,r17,82115a0 <__udivdi3+0x36c>
 8211778:	31bfff84 	addi	r6,r6,-2
 821177c:	1dc7883a 	add	r3,r3,r23
 8211780:	003f8806 	br	82115a4 <__udivdi3+0x370>
 8211784:	1805883a 	mov	r2,r3
 8211788:	003fde06 	br	8211704 <__udivdi3+0x4d0>
 821178c:	1839883a 	mov	fp,r3
 8211790:	003fc906 	br	82116b8 <__udivdi3+0x484>
 8211794:	b5bfff84 	addi	r22,r22,-2
 8211798:	2449883a 	add	r4,r4,r17
 821179c:	003f3406 	br	8211470 <__udivdi3+0x23c>
 82117a0:	b5bfff84 	addi	r22,r22,-2
 82117a4:	1445883a 	add	r2,r2,r17
 82117a8:	003edb06 	br	8211318 <__udivdi3+0xe4>

082117ac <__umoddi3>:
 82117ac:	defff404 	addi	sp,sp,-48
 82117b0:	df000a15 	stw	fp,40(sp)
 82117b4:	dc400315 	stw	r17,12(sp)
 82117b8:	dc000215 	stw	r16,8(sp)
 82117bc:	dfc00b15 	stw	ra,44(sp)
 82117c0:	ddc00915 	stw	r23,36(sp)
 82117c4:	dd800815 	stw	r22,32(sp)
 82117c8:	dd400715 	stw	r21,28(sp)
 82117cc:	dd000615 	stw	r20,24(sp)
 82117d0:	dcc00515 	stw	r19,20(sp)
 82117d4:	dc800415 	stw	r18,16(sp)
 82117d8:	2021883a 	mov	r16,r4
 82117dc:	2823883a 	mov	r17,r5
 82117e0:	2839883a 	mov	fp,r5
 82117e4:	38003c1e 	bne	r7,zero,82118d8 <__umoddi3+0x12c>
 82117e8:	3027883a 	mov	r19,r6
 82117ec:	2029883a 	mov	r20,r4
 82117f0:	2980512e 	bgeu	r5,r6,8211938 <__umoddi3+0x18c>
 82117f4:	00bfffd4 	movui	r2,65535
 82117f8:	11809a36 	bltu	r2,r6,8211a64 <__umoddi3+0x2b8>
 82117fc:	01003fc4 	movi	r4,255
 8211800:	2189803a 	cmpltu	r4,r4,r6
 8211804:	200890fa 	slli	r4,r4,3
 8211808:	3104d83a 	srl	r2,r6,r4
 821180c:	00c20974 	movhi	r3,2085
 8211810:	18f74404 	addi	r3,r3,-8944
 8211814:	1885883a 	add	r2,r3,r2
 8211818:	10c00003 	ldbu	r3,0(r2)
 821181c:	00800804 	movi	r2,32
 8211820:	1909883a 	add	r4,r3,r4
 8211824:	1125c83a 	sub	r18,r2,r4
 8211828:	90000526 	beq	r18,zero,8211840 <__umoddi3+0x94>
 821182c:	8ca2983a 	sll	r17,r17,r18
 8211830:	8108d83a 	srl	r4,r16,r4
 8211834:	34a6983a 	sll	r19,r6,r18
 8211838:	84a8983a 	sll	r20,r16,r18
 821183c:	2478b03a 	or	fp,r4,r17
 8211840:	982ed43a 	srli	r23,r19,16
 8211844:	e009883a 	mov	r4,fp
 8211848:	9dbfffcc 	andi	r22,r19,65535
 821184c:	b80b883a 	mov	r5,r23
 8211850:	8202bf00 	call	8202bf0 <__umodsi3>
 8211854:	e009883a 	mov	r4,fp
 8211858:	b80b883a 	mov	r5,r23
 821185c:	102b883a 	mov	r21,r2
 8211860:	8202b8c0 	call	8202b8c <__udivsi3>
 8211864:	a806943a 	slli	r3,r21,16
 8211868:	a008d43a 	srli	r4,r20,16
 821186c:	b085383a 	mul	r2,r22,r2
 8211870:	20c8b03a 	or	r4,r4,r3
 8211874:	2080032e 	bgeu	r4,r2,8211884 <__umoddi3+0xd8>
 8211878:	24c9883a 	add	r4,r4,r19
 821187c:	24c00136 	bltu	r4,r19,8211884 <__umoddi3+0xd8>
 8211880:	20811036 	bltu	r4,r2,8211cc4 <__umoddi3+0x518>
 8211884:	20abc83a 	sub	r21,r4,r2
 8211888:	b80b883a 	mov	r5,r23
 821188c:	a809883a 	mov	r4,r21
 8211890:	8202bf00 	call	8202bf0 <__umodsi3>
 8211894:	1023883a 	mov	r17,r2
 8211898:	b80b883a 	mov	r5,r23
 821189c:	a809883a 	mov	r4,r21
 82118a0:	8202b8c0 	call	8202b8c <__udivsi3>
 82118a4:	8822943a 	slli	r17,r17,16
 82118a8:	b085383a 	mul	r2,r22,r2
 82118ac:	a0ffffcc 	andi	r3,r20,65535
 82118b0:	1c46b03a 	or	r3,r3,r17
 82118b4:	1880042e 	bgeu	r3,r2,82118c8 <__umoddi3+0x11c>
 82118b8:	1cc7883a 	add	r3,r3,r19
 82118bc:	1cc00236 	bltu	r3,r19,82118c8 <__umoddi3+0x11c>
 82118c0:	1880012e 	bgeu	r3,r2,82118c8 <__umoddi3+0x11c>
 82118c4:	1cc7883a 	add	r3,r3,r19
 82118c8:	1885c83a 	sub	r2,r3,r2
 82118cc:	1484d83a 	srl	r2,r2,r18
 82118d0:	0007883a 	mov	r3,zero
 82118d4:	00004f06 	br	8211a14 <__umoddi3+0x268>
 82118d8:	29c04c36 	bltu	r5,r7,8211a0c <__umoddi3+0x260>
 82118dc:	00bfffd4 	movui	r2,65535
 82118e0:	11c0582e 	bgeu	r2,r7,8211a44 <__umoddi3+0x298>
 82118e4:	00804034 	movhi	r2,256
 82118e8:	10bfffc4 	addi	r2,r2,-1
 82118ec:	11c0e736 	bltu	r2,r7,8211c8c <__umoddi3+0x4e0>
 82118f0:	01000404 	movi	r4,16
 82118f4:	3904d83a 	srl	r2,r7,r4
 82118f8:	00c20974 	movhi	r3,2085
 82118fc:	18f74404 	addi	r3,r3,-8944
 8211900:	1885883a 	add	r2,r3,r2
 8211904:	14c00003 	ldbu	r19,0(r2)
 8211908:	00c00804 	movi	r3,32
 821190c:	9927883a 	add	r19,r19,r4
 8211910:	1ce9c83a 	sub	r20,r3,r19
 8211914:	a000581e 	bne	r20,zero,8211a78 <__umoddi3+0x2cc>
 8211918:	3c400136 	bltu	r7,r17,8211920 <__umoddi3+0x174>
 821191c:	8180eb36 	bltu	r16,r6,8211ccc <__umoddi3+0x520>
 8211920:	8185c83a 	sub	r2,r16,r6
 8211924:	89e3c83a 	sub	r17,r17,r7
 8211928:	8089803a 	cmpltu	r4,r16,r2
 821192c:	8939c83a 	sub	fp,r17,r4
 8211930:	e007883a 	mov	r3,fp
 8211934:	00003706 	br	8211a14 <__umoddi3+0x268>
 8211938:	3000041e 	bne	r6,zero,821194c <__umoddi3+0x1a0>
 821193c:	000b883a 	mov	r5,zero
 8211940:	01000044 	movi	r4,1
 8211944:	8202b8c0 	call	8202b8c <__udivsi3>
 8211948:	1027883a 	mov	r19,r2
 821194c:	00bfffd4 	movui	r2,65535
 8211950:	14c0402e 	bgeu	r2,r19,8211a54 <__umoddi3+0x2a8>
 8211954:	00804034 	movhi	r2,256
 8211958:	10bfffc4 	addi	r2,r2,-1
 821195c:	14c0cd36 	bltu	r2,r19,8211c94 <__umoddi3+0x4e8>
 8211960:	00800404 	movi	r2,16
 8211964:	9886d83a 	srl	r3,r19,r2
 8211968:	01020974 	movhi	r4,2085
 821196c:	21374404 	addi	r4,r4,-8944
 8211970:	20c7883a 	add	r3,r4,r3
 8211974:	18c00003 	ldbu	r3,0(r3)
 8211978:	1887883a 	add	r3,r3,r2
 821197c:	00800804 	movi	r2,32
 8211980:	10e5c83a 	sub	r18,r2,r3
 8211984:	9000901e 	bne	r18,zero,8211bc8 <__umoddi3+0x41c>
 8211988:	982cd43a 	srli	r22,r19,16
 821198c:	8ce3c83a 	sub	r17,r17,r19
 8211990:	9d7fffcc 	andi	r21,r19,65535
 8211994:	b00b883a 	mov	r5,r22
 8211998:	8809883a 	mov	r4,r17
 821199c:	8202bf00 	call	8202bf0 <__umodsi3>
 82119a0:	8809883a 	mov	r4,r17
 82119a4:	b00b883a 	mov	r5,r22
 82119a8:	1021883a 	mov	r16,r2
 82119ac:	8202b8c0 	call	8202b8c <__udivsi3>
 82119b0:	8006943a 	slli	r3,r16,16
 82119b4:	a008d43a 	srli	r4,r20,16
 82119b8:	1545383a 	mul	r2,r2,r21
 82119bc:	20c8b03a 	or	r4,r4,r3
 82119c0:	2080042e 	bgeu	r4,r2,82119d4 <__umoddi3+0x228>
 82119c4:	24c9883a 	add	r4,r4,r19
 82119c8:	24c00236 	bltu	r4,r19,82119d4 <__umoddi3+0x228>
 82119cc:	2080012e 	bgeu	r4,r2,82119d4 <__umoddi3+0x228>
 82119d0:	24c9883a 	add	r4,r4,r19
 82119d4:	20a1c83a 	sub	r16,r4,r2
 82119d8:	b00b883a 	mov	r5,r22
 82119dc:	8009883a 	mov	r4,r16
 82119e0:	8202bf00 	call	8202bf0 <__umodsi3>
 82119e4:	1023883a 	mov	r17,r2
 82119e8:	b00b883a 	mov	r5,r22
 82119ec:	8009883a 	mov	r4,r16
 82119f0:	8202b8c0 	call	8202b8c <__udivsi3>
 82119f4:	8822943a 	slli	r17,r17,16
 82119f8:	1545383a 	mul	r2,r2,r21
 82119fc:	a53fffcc 	andi	r20,r20,65535
 8211a00:	a446b03a 	or	r3,r20,r17
 8211a04:	18bfb02e 	bgeu	r3,r2,82118c8 <__umoddi3+0x11c>
 8211a08:	003fab06 	br	82118b8 <__umoddi3+0x10c>
 8211a0c:	2005883a 	mov	r2,r4
 8211a10:	2807883a 	mov	r3,r5
 8211a14:	dfc00b17 	ldw	ra,44(sp)
 8211a18:	df000a17 	ldw	fp,40(sp)
 8211a1c:	ddc00917 	ldw	r23,36(sp)
 8211a20:	dd800817 	ldw	r22,32(sp)
 8211a24:	dd400717 	ldw	r21,28(sp)
 8211a28:	dd000617 	ldw	r20,24(sp)
 8211a2c:	dcc00517 	ldw	r19,20(sp)
 8211a30:	dc800417 	ldw	r18,16(sp)
 8211a34:	dc400317 	ldw	r17,12(sp)
 8211a38:	dc000217 	ldw	r16,8(sp)
 8211a3c:	dec00c04 	addi	sp,sp,48
 8211a40:	f800283a 	ret
 8211a44:	04c03fc4 	movi	r19,255
 8211a48:	99c9803a 	cmpltu	r4,r19,r7
 8211a4c:	200890fa 	slli	r4,r4,3
 8211a50:	003fa806 	br	82118f4 <__umoddi3+0x148>
 8211a54:	00803fc4 	movi	r2,255
 8211a58:	14c5803a 	cmpltu	r2,r2,r19
 8211a5c:	100490fa 	slli	r2,r2,3
 8211a60:	003fc006 	br	8211964 <__umoddi3+0x1b8>
 8211a64:	00804034 	movhi	r2,256
 8211a68:	10bfffc4 	addi	r2,r2,-1
 8211a6c:	11808b36 	bltu	r2,r6,8211c9c <__umoddi3+0x4f0>
 8211a70:	01000404 	movi	r4,16
 8211a74:	003f6406 	br	8211808 <__umoddi3+0x5c>
 8211a78:	34c4d83a 	srl	r2,r6,r19
 8211a7c:	3d0e983a 	sll	r7,r7,r20
 8211a80:	8cf8d83a 	srl	fp,r17,r19
 8211a84:	8d10983a 	sll	r8,r17,r20
 8211a88:	38aab03a 	or	r21,r7,r2
 8211a8c:	a82cd43a 	srli	r22,r21,16
 8211a90:	84e2d83a 	srl	r17,r16,r19
 8211a94:	e009883a 	mov	r4,fp
 8211a98:	b00b883a 	mov	r5,r22
 8211a9c:	8a22b03a 	or	r17,r17,r8
 8211aa0:	3524983a 	sll	r18,r6,r20
 8211aa4:	8202bf00 	call	8202bf0 <__umodsi3>
 8211aa8:	e009883a 	mov	r4,fp
 8211aac:	b00b883a 	mov	r5,r22
 8211ab0:	102f883a 	mov	r23,r2
 8211ab4:	8202b8c0 	call	8202b8c <__udivsi3>
 8211ab8:	100d883a 	mov	r6,r2
 8211abc:	b808943a 	slli	r4,r23,16
 8211ac0:	aa3fffcc 	andi	r8,r21,65535
 8211ac4:	8804d43a 	srli	r2,r17,16
 8211ac8:	41af383a 	mul	r23,r8,r6
 8211acc:	8520983a 	sll	r16,r16,r20
 8211ad0:	1104b03a 	or	r2,r2,r4
 8211ad4:	15c0042e 	bgeu	r2,r23,8211ae8 <__umoddi3+0x33c>
 8211ad8:	1545883a 	add	r2,r2,r21
 8211adc:	30ffffc4 	addi	r3,r6,-1
 8211ae0:	1540742e 	bgeu	r2,r21,8211cb4 <__umoddi3+0x508>
 8211ae4:	180d883a 	mov	r6,r3
 8211ae8:	15efc83a 	sub	r23,r2,r23
 8211aec:	b00b883a 	mov	r5,r22
 8211af0:	b809883a 	mov	r4,r23
 8211af4:	d9800115 	stw	r6,4(sp)
 8211af8:	da000015 	stw	r8,0(sp)
 8211afc:	8202bf00 	call	8202bf0 <__umodsi3>
 8211b00:	b00b883a 	mov	r5,r22
 8211b04:	b809883a 	mov	r4,r23
 8211b08:	1039883a 	mov	fp,r2
 8211b0c:	8202b8c0 	call	8202b8c <__udivsi3>
 8211b10:	da000017 	ldw	r8,0(sp)
 8211b14:	e038943a 	slli	fp,fp,16
 8211b18:	100b883a 	mov	r5,r2
 8211b1c:	4089383a 	mul	r4,r8,r2
 8211b20:	8a3fffcc 	andi	r8,r17,65535
 8211b24:	4710b03a 	or	r8,r8,fp
 8211b28:	d9800117 	ldw	r6,4(sp)
 8211b2c:	4100042e 	bgeu	r8,r4,8211b40 <__umoddi3+0x394>
 8211b30:	4551883a 	add	r8,r8,r21
 8211b34:	10bfffc4 	addi	r2,r2,-1
 8211b38:	45405a2e 	bgeu	r8,r21,8211ca4 <__umoddi3+0x4f8>
 8211b3c:	100b883a 	mov	r5,r2
 8211b40:	300c943a 	slli	r6,r6,16
 8211b44:	91ffffcc 	andi	r7,r18,65535
 8211b48:	9004d43a 	srli	r2,r18,16
 8211b4c:	314cb03a 	or	r6,r6,r5
 8211b50:	317fffcc 	andi	r5,r6,65535
 8211b54:	300cd43a 	srli	r6,r6,16
 8211b58:	29d3383a 	mul	r9,r5,r7
 8211b5c:	288b383a 	mul	r5,r5,r2
 8211b60:	31cf383a 	mul	r7,r6,r7
 8211b64:	4806d43a 	srli	r3,r9,16
 8211b68:	4111c83a 	sub	r8,r8,r4
 8211b6c:	29cb883a 	add	r5,r5,r7
 8211b70:	194b883a 	add	r5,r3,r5
 8211b74:	3085383a 	mul	r2,r6,r2
 8211b78:	29c0022e 	bgeu	r5,r7,8211b84 <__umoddi3+0x3d8>
 8211b7c:	00c00074 	movhi	r3,1
 8211b80:	10c5883a 	add	r2,r2,r3
 8211b84:	2808d43a 	srli	r4,r5,16
 8211b88:	280a943a 	slli	r5,r5,16
 8211b8c:	4a7fffcc 	andi	r9,r9,65535
 8211b90:	2085883a 	add	r2,r4,r2
 8211b94:	2a4b883a 	add	r5,r5,r9
 8211b98:	40803636 	bltu	r8,r2,8211c74 <__umoddi3+0x4c8>
 8211b9c:	40804d26 	beq	r8,r2,8211cd4 <__umoddi3+0x528>
 8211ba0:	4089c83a 	sub	r4,r8,r2
 8211ba4:	280f883a 	mov	r7,r5
 8211ba8:	81cfc83a 	sub	r7,r16,r7
 8211bac:	81c7803a 	cmpltu	r3,r16,r7
 8211bb0:	20c7c83a 	sub	r3,r4,r3
 8211bb4:	1cc4983a 	sll	r2,r3,r19
 8211bb8:	3d0ed83a 	srl	r7,r7,r20
 8211bbc:	1d06d83a 	srl	r3,r3,r20
 8211bc0:	11c4b03a 	or	r2,r2,r7
 8211bc4:	003f9306 	br	8211a14 <__umoddi3+0x268>
 8211bc8:	9ca6983a 	sll	r19,r19,r18
 8211bcc:	88e8d83a 	srl	r20,r17,r3
 8211bd0:	80c4d83a 	srl	r2,r16,r3
 8211bd4:	982cd43a 	srli	r22,r19,16
 8211bd8:	8ca2983a 	sll	r17,r17,r18
 8211bdc:	a009883a 	mov	r4,r20
 8211be0:	b00b883a 	mov	r5,r22
 8211be4:	1478b03a 	or	fp,r2,r17
 8211be8:	8202bf00 	call	8202bf0 <__umodsi3>
 8211bec:	a009883a 	mov	r4,r20
 8211bf0:	b00b883a 	mov	r5,r22
 8211bf4:	1023883a 	mov	r17,r2
 8211bf8:	8202b8c0 	call	8202b8c <__udivsi3>
 8211bfc:	9d7fffcc 	andi	r21,r19,65535
 8211c00:	880a943a 	slli	r5,r17,16
 8211c04:	e008d43a 	srli	r4,fp,16
 8211c08:	a885383a 	mul	r2,r21,r2
 8211c0c:	84a8983a 	sll	r20,r16,r18
 8211c10:	2148b03a 	or	r4,r4,r5
 8211c14:	2080042e 	bgeu	r4,r2,8211c28 <__umoddi3+0x47c>
 8211c18:	24c9883a 	add	r4,r4,r19
 8211c1c:	24c00236 	bltu	r4,r19,8211c28 <__umoddi3+0x47c>
 8211c20:	2080012e 	bgeu	r4,r2,8211c28 <__umoddi3+0x47c>
 8211c24:	24c9883a 	add	r4,r4,r19
 8211c28:	20a3c83a 	sub	r17,r4,r2
 8211c2c:	b00b883a 	mov	r5,r22
 8211c30:	8809883a 	mov	r4,r17
 8211c34:	8202bf00 	call	8202bf0 <__umodsi3>
 8211c38:	102f883a 	mov	r23,r2
 8211c3c:	8809883a 	mov	r4,r17
 8211c40:	b00b883a 	mov	r5,r22
 8211c44:	8202b8c0 	call	8202b8c <__udivsi3>
 8211c48:	b82e943a 	slli	r23,r23,16
 8211c4c:	a885383a 	mul	r2,r21,r2
 8211c50:	e13fffcc 	andi	r4,fp,65535
 8211c54:	25c8b03a 	or	r4,r4,r23
 8211c58:	2080042e 	bgeu	r4,r2,8211c6c <__umoddi3+0x4c0>
 8211c5c:	24c9883a 	add	r4,r4,r19
 8211c60:	24c00236 	bltu	r4,r19,8211c6c <__umoddi3+0x4c0>
 8211c64:	2080012e 	bgeu	r4,r2,8211c6c <__umoddi3+0x4c0>
 8211c68:	24c9883a 	add	r4,r4,r19
 8211c6c:	20a3c83a 	sub	r17,r4,r2
 8211c70:	003f4806 	br	8211994 <__umoddi3+0x1e8>
 8211c74:	2c8fc83a 	sub	r7,r5,r18
 8211c78:	1545c83a 	sub	r2,r2,r21
 8211c7c:	29cb803a 	cmpltu	r5,r5,r7
 8211c80:	1145c83a 	sub	r2,r2,r5
 8211c84:	4089c83a 	sub	r4,r8,r2
 8211c88:	003fc706 	br	8211ba8 <__umoddi3+0x3fc>
 8211c8c:	01000604 	movi	r4,24
 8211c90:	003f1806 	br	82118f4 <__umoddi3+0x148>
 8211c94:	00800604 	movi	r2,24
 8211c98:	003f3206 	br	8211964 <__umoddi3+0x1b8>
 8211c9c:	01000604 	movi	r4,24
 8211ca0:	003ed906 	br	8211808 <__umoddi3+0x5c>
 8211ca4:	413fa52e 	bgeu	r8,r4,8211b3c <__umoddi3+0x390>
 8211ca8:	297fff84 	addi	r5,r5,-2
 8211cac:	4551883a 	add	r8,r8,r21
 8211cb0:	003fa306 	br	8211b40 <__umoddi3+0x394>
 8211cb4:	15ff8b2e 	bgeu	r2,r23,8211ae4 <__umoddi3+0x338>
 8211cb8:	31bfff84 	addi	r6,r6,-2
 8211cbc:	1545883a 	add	r2,r2,r21
 8211cc0:	003f8906 	br	8211ae8 <__umoddi3+0x33c>
 8211cc4:	24c9883a 	add	r4,r4,r19
 8211cc8:	003eee06 	br	8211884 <__umoddi3+0xd8>
 8211ccc:	8005883a 	mov	r2,r16
 8211cd0:	003f1706 	br	8211930 <__umoddi3+0x184>
 8211cd4:	817fe736 	bltu	r16,r5,8211c74 <__umoddi3+0x4c8>
 8211cd8:	280f883a 	mov	r7,r5
 8211cdc:	0009883a 	mov	r4,zero
 8211ce0:	003fb106 	br	8211ba8 <__umoddi3+0x3fc>

08211ce4 <__adddf3>:
 8211ce4:	02c00434 	movhi	r11,16
 8211ce8:	5affffc4 	addi	r11,r11,-1
 8211cec:	2806d7fa 	srli	r3,r5,31
 8211cf0:	2ad4703a 	and	r10,r5,r11
 8211cf4:	3ad2703a 	and	r9,r7,r11
 8211cf8:	3804d53a 	srli	r2,r7,20
 8211cfc:	3018d77a 	srli	r12,r6,29
 8211d00:	280ad53a 	srli	r5,r5,20
 8211d04:	501490fa 	slli	r10,r10,3
 8211d08:	2010d77a 	srli	r8,r4,29
 8211d0c:	481290fa 	slli	r9,r9,3
 8211d10:	380ed7fa 	srli	r7,r7,31
 8211d14:	defffb04 	addi	sp,sp,-20
 8211d18:	dc800215 	stw	r18,8(sp)
 8211d1c:	dc400115 	stw	r17,4(sp)
 8211d20:	dc000015 	stw	r16,0(sp)
 8211d24:	dfc00415 	stw	ra,16(sp)
 8211d28:	dcc00315 	stw	r19,12(sp)
 8211d2c:	1c803fcc 	andi	r18,r3,255
 8211d30:	2c01ffcc 	andi	r16,r5,2047
 8211d34:	5210b03a 	or	r8,r10,r8
 8211d38:	202290fa 	slli	r17,r4,3
 8211d3c:	1081ffcc 	andi	r2,r2,2047
 8211d40:	4b12b03a 	or	r9,r9,r12
 8211d44:	300c90fa 	slli	r6,r6,3
 8211d48:	91c07526 	beq	r18,r7,8211f20 <__adddf3+0x23c>
 8211d4c:	8087c83a 	sub	r3,r16,r2
 8211d50:	00c0ab0e 	bge	zero,r3,8212000 <__adddf3+0x31c>
 8211d54:	10002a1e 	bne	r2,zero,8211e00 <__adddf3+0x11c>
 8211d58:	4984b03a 	or	r2,r9,r6
 8211d5c:	1000961e 	bne	r2,zero,8211fb8 <__adddf3+0x2d4>
 8211d60:	888001cc 	andi	r2,r17,7
 8211d64:	10000726 	beq	r2,zero,8211d84 <__adddf3+0xa0>
 8211d68:	888003cc 	andi	r2,r17,15
 8211d6c:	00c00104 	movi	r3,4
 8211d70:	10c00426 	beq	r2,r3,8211d84 <__adddf3+0xa0>
 8211d74:	88c7883a 	add	r3,r17,r3
 8211d78:	1c63803a 	cmpltu	r17,r3,r17
 8211d7c:	4451883a 	add	r8,r8,r17
 8211d80:	1823883a 	mov	r17,r3
 8211d84:	4080202c 	andhi	r2,r8,128
 8211d88:	10005926 	beq	r2,zero,8211ef0 <__adddf3+0x20c>
 8211d8c:	84000044 	addi	r16,r16,1
 8211d90:	0081ffc4 	movi	r2,2047
 8211d94:	8080ba26 	beq	r16,r2,8212080 <__adddf3+0x39c>
 8211d98:	00bfe034 	movhi	r2,65408
 8211d9c:	10bfffc4 	addi	r2,r2,-1
 8211da0:	4090703a 	and	r8,r8,r2
 8211da4:	4004977a 	slli	r2,r8,29
 8211da8:	4010927a 	slli	r8,r8,9
 8211dac:	8822d0fa 	srli	r17,r17,3
 8211db0:	8401ffcc 	andi	r16,r16,2047
 8211db4:	4010d33a 	srli	r8,r8,12
 8211db8:	9007883a 	mov	r3,r18
 8211dbc:	1444b03a 	or	r2,r2,r17
 8211dc0:	8401ffcc 	andi	r16,r16,2047
 8211dc4:	8020953a 	slli	r16,r16,20
 8211dc8:	18c03fcc 	andi	r3,r3,255
 8211dcc:	01000434 	movhi	r4,16
 8211dd0:	213fffc4 	addi	r4,r4,-1
 8211dd4:	180697fa 	slli	r3,r3,31
 8211dd8:	4110703a 	and	r8,r8,r4
 8211ddc:	4410b03a 	or	r8,r8,r16
 8211de0:	40c6b03a 	or	r3,r8,r3
 8211de4:	dfc00417 	ldw	ra,16(sp)
 8211de8:	dcc00317 	ldw	r19,12(sp)
 8211dec:	dc800217 	ldw	r18,8(sp)
 8211df0:	dc400117 	ldw	r17,4(sp)
 8211df4:	dc000017 	ldw	r16,0(sp)
 8211df8:	dec00504 	addi	sp,sp,20
 8211dfc:	f800283a 	ret
 8211e00:	0081ffc4 	movi	r2,2047
 8211e04:	80bfd626 	beq	r16,r2,8211d60 <__adddf3+0x7c>
 8211e08:	4a402034 	orhi	r9,r9,128
 8211e0c:	00800e04 	movi	r2,56
 8211e10:	10c09f16 	blt	r2,r3,8212090 <__adddf3+0x3ac>
 8211e14:	008007c4 	movi	r2,31
 8211e18:	10c0c216 	blt	r2,r3,8212124 <__adddf3+0x440>
 8211e1c:	00800804 	movi	r2,32
 8211e20:	10c5c83a 	sub	r2,r2,r3
 8211e24:	488a983a 	sll	r5,r9,r2
 8211e28:	30c8d83a 	srl	r4,r6,r3
 8211e2c:	3084983a 	sll	r2,r6,r2
 8211e30:	48c6d83a 	srl	r3,r9,r3
 8211e34:	290cb03a 	or	r6,r5,r4
 8211e38:	1004c03a 	cmpne	r2,r2,zero
 8211e3c:	308cb03a 	or	r6,r6,r2
 8211e40:	898dc83a 	sub	r6,r17,r6
 8211e44:	89a3803a 	cmpltu	r17,r17,r6
 8211e48:	40d1c83a 	sub	r8,r8,r3
 8211e4c:	4451c83a 	sub	r8,r8,r17
 8211e50:	3023883a 	mov	r17,r6
 8211e54:	4080202c 	andhi	r2,r8,128
 8211e58:	10002326 	beq	r2,zero,8211ee8 <__adddf3+0x204>
 8211e5c:	04c02034 	movhi	r19,128
 8211e60:	9cffffc4 	addi	r19,r19,-1
 8211e64:	44e6703a 	and	r19,r8,r19
 8211e68:	98007626 	beq	r19,zero,8212044 <__adddf3+0x360>
 8211e6c:	9809883a 	mov	r4,r19
 8211e70:	82142e80 	call	82142e8 <__clzsi2>
 8211e74:	10fffe04 	addi	r3,r2,-8
 8211e78:	010007c4 	movi	r4,31
 8211e7c:	20c07716 	blt	r4,r3,821205c <__adddf3+0x378>
 8211e80:	00800804 	movi	r2,32
 8211e84:	10c5c83a 	sub	r2,r2,r3
 8211e88:	8884d83a 	srl	r2,r17,r2
 8211e8c:	98d0983a 	sll	r8,r19,r3
 8211e90:	88e2983a 	sll	r17,r17,r3
 8211e94:	1204b03a 	or	r2,r2,r8
 8211e98:	1c007416 	blt	r3,r16,821206c <__adddf3+0x388>
 8211e9c:	1c21c83a 	sub	r16,r3,r16
 8211ea0:	82000044 	addi	r8,r16,1
 8211ea4:	00c007c4 	movi	r3,31
 8211ea8:	1a009116 	blt	r3,r8,82120f0 <__adddf3+0x40c>
 8211eac:	00c00804 	movi	r3,32
 8211eb0:	1a07c83a 	sub	r3,r3,r8
 8211eb4:	8a08d83a 	srl	r4,r17,r8
 8211eb8:	88e2983a 	sll	r17,r17,r3
 8211ebc:	10c6983a 	sll	r3,r2,r3
 8211ec0:	1210d83a 	srl	r8,r2,r8
 8211ec4:	8804c03a 	cmpne	r2,r17,zero
 8211ec8:	1906b03a 	or	r3,r3,r4
 8211ecc:	18a2b03a 	or	r17,r3,r2
 8211ed0:	0021883a 	mov	r16,zero
 8211ed4:	003fa206 	br	8211d60 <__adddf3+0x7c>
 8211ed8:	1890b03a 	or	r8,r3,r2
 8211edc:	40017d26 	beq	r8,zero,82124d4 <__adddf3+0x7f0>
 8211ee0:	1011883a 	mov	r8,r2
 8211ee4:	1823883a 	mov	r17,r3
 8211ee8:	888001cc 	andi	r2,r17,7
 8211eec:	103f9e1e 	bne	r2,zero,8211d68 <__adddf3+0x84>
 8211ef0:	4004977a 	slli	r2,r8,29
 8211ef4:	8822d0fa 	srli	r17,r17,3
 8211ef8:	4010d0fa 	srli	r8,r8,3
 8211efc:	9007883a 	mov	r3,r18
 8211f00:	1444b03a 	or	r2,r2,r17
 8211f04:	0101ffc4 	movi	r4,2047
 8211f08:	81002426 	beq	r16,r4,8211f9c <__adddf3+0x2b8>
 8211f0c:	8120703a 	and	r16,r16,r4
 8211f10:	01000434 	movhi	r4,16
 8211f14:	213fffc4 	addi	r4,r4,-1
 8211f18:	4110703a 	and	r8,r8,r4
 8211f1c:	003fa806 	br	8211dc0 <__adddf3+0xdc>
 8211f20:	8089c83a 	sub	r4,r16,r2
 8211f24:	01005e0e 	bge	zero,r4,82120a0 <__adddf3+0x3bc>
 8211f28:	10002b26 	beq	r2,zero,8211fd8 <__adddf3+0x2f4>
 8211f2c:	0081ffc4 	movi	r2,2047
 8211f30:	80bf8b26 	beq	r16,r2,8211d60 <__adddf3+0x7c>
 8211f34:	4a402034 	orhi	r9,r9,128
 8211f38:	00800e04 	movi	r2,56
 8211f3c:	1100a40e 	bge	r2,r4,82121d0 <__adddf3+0x4ec>
 8211f40:	498cb03a 	or	r6,r9,r6
 8211f44:	300ac03a 	cmpne	r5,r6,zero
 8211f48:	0013883a 	mov	r9,zero
 8211f4c:	2c4b883a 	add	r5,r5,r17
 8211f50:	2c63803a 	cmpltu	r17,r5,r17
 8211f54:	4a11883a 	add	r8,r9,r8
 8211f58:	8a11883a 	add	r8,r17,r8
 8211f5c:	2823883a 	mov	r17,r5
 8211f60:	4080202c 	andhi	r2,r8,128
 8211f64:	103fe026 	beq	r2,zero,8211ee8 <__adddf3+0x204>
 8211f68:	84000044 	addi	r16,r16,1
 8211f6c:	0081ffc4 	movi	r2,2047
 8211f70:	8080d226 	beq	r16,r2,82122bc <__adddf3+0x5d8>
 8211f74:	00bfe034 	movhi	r2,65408
 8211f78:	10bfffc4 	addi	r2,r2,-1
 8211f7c:	4090703a 	and	r8,r8,r2
 8211f80:	880ad07a 	srli	r5,r17,1
 8211f84:	400897fa 	slli	r4,r8,31
 8211f88:	88c0004c 	andi	r3,r17,1
 8211f8c:	28e2b03a 	or	r17,r5,r3
 8211f90:	4010d07a 	srli	r8,r8,1
 8211f94:	2462b03a 	or	r17,r4,r17
 8211f98:	003f7106 	br	8211d60 <__adddf3+0x7c>
 8211f9c:	4088b03a 	or	r4,r8,r2
 8211fa0:	20014526 	beq	r4,zero,82124b8 <__adddf3+0x7d4>
 8211fa4:	01000434 	movhi	r4,16
 8211fa8:	42000234 	orhi	r8,r8,8
 8211fac:	213fffc4 	addi	r4,r4,-1
 8211fb0:	4110703a 	and	r8,r8,r4
 8211fb4:	003f8206 	br	8211dc0 <__adddf3+0xdc>
 8211fb8:	18ffffc4 	addi	r3,r3,-1
 8211fbc:	1800491e 	bne	r3,zero,82120e4 <__adddf3+0x400>
 8211fc0:	898bc83a 	sub	r5,r17,r6
 8211fc4:	8963803a 	cmpltu	r17,r17,r5
 8211fc8:	4251c83a 	sub	r8,r8,r9
 8211fcc:	4451c83a 	sub	r8,r8,r17
 8211fd0:	2823883a 	mov	r17,r5
 8211fd4:	003f9f06 	br	8211e54 <__adddf3+0x170>
 8211fd8:	4984b03a 	or	r2,r9,r6
 8211fdc:	103f6026 	beq	r2,zero,8211d60 <__adddf3+0x7c>
 8211fe0:	213fffc4 	addi	r4,r4,-1
 8211fe4:	2000931e 	bne	r4,zero,8212234 <__adddf3+0x550>
 8211fe8:	898d883a 	add	r6,r17,r6
 8211fec:	3463803a 	cmpltu	r17,r6,r17
 8211ff0:	4251883a 	add	r8,r8,r9
 8211ff4:	8a11883a 	add	r8,r17,r8
 8211ff8:	3023883a 	mov	r17,r6
 8211ffc:	003fd806 	br	8211f60 <__adddf3+0x27c>
 8212000:	1800541e 	bne	r3,zero,8212154 <__adddf3+0x470>
 8212004:	80800044 	addi	r2,r16,1
 8212008:	1081ffcc 	andi	r2,r2,2047
 821200c:	00c00044 	movi	r3,1
 8212010:	1880a00e 	bge	r3,r2,8212294 <__adddf3+0x5b0>
 8212014:	8989c83a 	sub	r4,r17,r6
 8212018:	8905803a 	cmpltu	r2,r17,r4
 821201c:	4267c83a 	sub	r19,r8,r9
 8212020:	98a7c83a 	sub	r19,r19,r2
 8212024:	9880202c 	andhi	r2,r19,128
 8212028:	10006326 	beq	r2,zero,82121b8 <__adddf3+0x4d4>
 821202c:	3463c83a 	sub	r17,r6,r17
 8212030:	4a07c83a 	sub	r3,r9,r8
 8212034:	344d803a 	cmpltu	r6,r6,r17
 8212038:	19a7c83a 	sub	r19,r3,r6
 821203c:	3825883a 	mov	r18,r7
 8212040:	983f8a1e 	bne	r19,zero,8211e6c <__adddf3+0x188>
 8212044:	8809883a 	mov	r4,r17
 8212048:	82142e80 	call	82142e8 <__clzsi2>
 821204c:	10800804 	addi	r2,r2,32
 8212050:	10fffe04 	addi	r3,r2,-8
 8212054:	010007c4 	movi	r4,31
 8212058:	20ff890e 	bge	r4,r3,8211e80 <__adddf3+0x19c>
 821205c:	10bff604 	addi	r2,r2,-40
 8212060:	8884983a 	sll	r2,r17,r2
 8212064:	0023883a 	mov	r17,zero
 8212068:	1c3f8c0e 	bge	r3,r16,8211e9c <__adddf3+0x1b8>
 821206c:	023fe034 	movhi	r8,65408
 8212070:	423fffc4 	addi	r8,r8,-1
 8212074:	80e1c83a 	sub	r16,r16,r3
 8212078:	1210703a 	and	r8,r2,r8
 821207c:	003f3806 	br	8211d60 <__adddf3+0x7c>
 8212080:	9007883a 	mov	r3,r18
 8212084:	0011883a 	mov	r8,zero
 8212088:	0005883a 	mov	r2,zero
 821208c:	003f4c06 	br	8211dc0 <__adddf3+0xdc>
 8212090:	498cb03a 	or	r6,r9,r6
 8212094:	300cc03a 	cmpne	r6,r6,zero
 8212098:	0007883a 	mov	r3,zero
 821209c:	003f6806 	br	8211e40 <__adddf3+0x15c>
 82120a0:	20009c1e 	bne	r4,zero,8212314 <__adddf3+0x630>
 82120a4:	80800044 	addi	r2,r16,1
 82120a8:	1141ffcc 	andi	r5,r2,2047
 82120ac:	01000044 	movi	r4,1
 82120b0:	2140670e 	bge	r4,r5,8212250 <__adddf3+0x56c>
 82120b4:	0101ffc4 	movi	r4,2047
 82120b8:	11007f26 	beq	r2,r4,82122b8 <__adddf3+0x5d4>
 82120bc:	898d883a 	add	r6,r17,r6
 82120c0:	4247883a 	add	r3,r8,r9
 82120c4:	3451803a 	cmpltu	r8,r6,r17
 82120c8:	40d1883a 	add	r8,r8,r3
 82120cc:	402297fa 	slli	r17,r8,31
 82120d0:	300cd07a 	srli	r6,r6,1
 82120d4:	4010d07a 	srli	r8,r8,1
 82120d8:	1021883a 	mov	r16,r2
 82120dc:	89a2b03a 	or	r17,r17,r6
 82120e0:	003f1f06 	br	8211d60 <__adddf3+0x7c>
 82120e4:	0081ffc4 	movi	r2,2047
 82120e8:	80bf481e 	bne	r16,r2,8211e0c <__adddf3+0x128>
 82120ec:	003f1c06 	br	8211d60 <__adddf3+0x7c>
 82120f0:	843ff844 	addi	r16,r16,-31
 82120f4:	01000804 	movi	r4,32
 82120f8:	1406d83a 	srl	r3,r2,r16
 82120fc:	41005026 	beq	r8,r4,8212240 <__adddf3+0x55c>
 8212100:	01001004 	movi	r4,64
 8212104:	2211c83a 	sub	r8,r4,r8
 8212108:	1204983a 	sll	r2,r2,r8
 821210c:	88a2b03a 	or	r17,r17,r2
 8212110:	8822c03a 	cmpne	r17,r17,zero
 8212114:	1c62b03a 	or	r17,r3,r17
 8212118:	0011883a 	mov	r8,zero
 821211c:	0021883a 	mov	r16,zero
 8212120:	003f7106 	br	8211ee8 <__adddf3+0x204>
 8212124:	193ff804 	addi	r4,r3,-32
 8212128:	00800804 	movi	r2,32
 821212c:	4908d83a 	srl	r4,r9,r4
 8212130:	18804526 	beq	r3,r2,8212248 <__adddf3+0x564>
 8212134:	00801004 	movi	r2,64
 8212138:	10c5c83a 	sub	r2,r2,r3
 821213c:	4886983a 	sll	r3,r9,r2
 8212140:	198cb03a 	or	r6,r3,r6
 8212144:	300cc03a 	cmpne	r6,r6,zero
 8212148:	218cb03a 	or	r6,r4,r6
 821214c:	0007883a 	mov	r3,zero
 8212150:	003f3b06 	br	8211e40 <__adddf3+0x15c>
 8212154:	80002a26 	beq	r16,zero,8212200 <__adddf3+0x51c>
 8212158:	0101ffc4 	movi	r4,2047
 821215c:	11006826 	beq	r2,r4,8212300 <__adddf3+0x61c>
 8212160:	00c7c83a 	sub	r3,zero,r3
 8212164:	42002034 	orhi	r8,r8,128
 8212168:	01000e04 	movi	r4,56
 821216c:	20c07c16 	blt	r4,r3,8212360 <__adddf3+0x67c>
 8212170:	010007c4 	movi	r4,31
 8212174:	20c0da16 	blt	r4,r3,82124e0 <__adddf3+0x7fc>
 8212178:	01000804 	movi	r4,32
 821217c:	20c9c83a 	sub	r4,r4,r3
 8212180:	4114983a 	sll	r10,r8,r4
 8212184:	88cad83a 	srl	r5,r17,r3
 8212188:	8908983a 	sll	r4,r17,r4
 821218c:	40c6d83a 	srl	r3,r8,r3
 8212190:	5162b03a 	or	r17,r10,r5
 8212194:	2008c03a 	cmpne	r4,r4,zero
 8212198:	8922b03a 	or	r17,r17,r4
 821219c:	3463c83a 	sub	r17,r6,r17
 82121a0:	48c7c83a 	sub	r3,r9,r3
 82121a4:	344d803a 	cmpltu	r6,r6,r17
 82121a8:	1991c83a 	sub	r8,r3,r6
 82121ac:	1021883a 	mov	r16,r2
 82121b0:	3825883a 	mov	r18,r7
 82121b4:	003f2706 	br	8211e54 <__adddf3+0x170>
 82121b8:	24d0b03a 	or	r8,r4,r19
 82121bc:	40001b1e 	bne	r8,zero,821222c <__adddf3+0x548>
 82121c0:	0005883a 	mov	r2,zero
 82121c4:	0007883a 	mov	r3,zero
 82121c8:	0021883a 	mov	r16,zero
 82121cc:	003f4d06 	br	8211f04 <__adddf3+0x220>
 82121d0:	008007c4 	movi	r2,31
 82121d4:	11003c16 	blt	r2,r4,82122c8 <__adddf3+0x5e4>
 82121d8:	00800804 	movi	r2,32
 82121dc:	1105c83a 	sub	r2,r2,r4
 82121e0:	488e983a 	sll	r7,r9,r2
 82121e4:	310ad83a 	srl	r5,r6,r4
 82121e8:	3084983a 	sll	r2,r6,r2
 82121ec:	4912d83a 	srl	r9,r9,r4
 82121f0:	394ab03a 	or	r5,r7,r5
 82121f4:	1004c03a 	cmpne	r2,r2,zero
 82121f8:	288ab03a 	or	r5,r5,r2
 82121fc:	003f5306 	br	8211f4c <__adddf3+0x268>
 8212200:	4448b03a 	or	r4,r8,r17
 8212204:	20003e26 	beq	r4,zero,8212300 <__adddf3+0x61c>
 8212208:	00c6303a 	nor	r3,zero,r3
 821220c:	18003a1e 	bne	r3,zero,82122f8 <__adddf3+0x614>
 8212210:	3463c83a 	sub	r17,r6,r17
 8212214:	4a07c83a 	sub	r3,r9,r8
 8212218:	344d803a 	cmpltu	r6,r6,r17
 821221c:	1991c83a 	sub	r8,r3,r6
 8212220:	1021883a 	mov	r16,r2
 8212224:	3825883a 	mov	r18,r7
 8212228:	003f0a06 	br	8211e54 <__adddf3+0x170>
 821222c:	2023883a 	mov	r17,r4
 8212230:	003f0d06 	br	8211e68 <__adddf3+0x184>
 8212234:	0081ffc4 	movi	r2,2047
 8212238:	80bf3f1e 	bne	r16,r2,8211f38 <__adddf3+0x254>
 821223c:	003ec806 	br	8211d60 <__adddf3+0x7c>
 8212240:	0005883a 	mov	r2,zero
 8212244:	003fb106 	br	821210c <__adddf3+0x428>
 8212248:	0007883a 	mov	r3,zero
 821224c:	003fbc06 	br	8212140 <__adddf3+0x45c>
 8212250:	4444b03a 	or	r2,r8,r17
 8212254:	8000871e 	bne	r16,zero,8212474 <__adddf3+0x790>
 8212258:	1000ba26 	beq	r2,zero,8212544 <__adddf3+0x860>
 821225c:	4984b03a 	or	r2,r9,r6
 8212260:	103ebf26 	beq	r2,zero,8211d60 <__adddf3+0x7c>
 8212264:	8985883a 	add	r2,r17,r6
 8212268:	4247883a 	add	r3,r8,r9
 821226c:	1451803a 	cmpltu	r8,r2,r17
 8212270:	40d1883a 	add	r8,r8,r3
 8212274:	40c0202c 	andhi	r3,r8,128
 8212278:	1023883a 	mov	r17,r2
 821227c:	183f1a26 	beq	r3,zero,8211ee8 <__adddf3+0x204>
 8212280:	00bfe034 	movhi	r2,65408
 8212284:	10bfffc4 	addi	r2,r2,-1
 8212288:	2021883a 	mov	r16,r4
 821228c:	4090703a 	and	r8,r8,r2
 8212290:	003eb306 	br	8211d60 <__adddf3+0x7c>
 8212294:	4444b03a 	or	r2,r8,r17
 8212298:	8000291e 	bne	r16,zero,8212340 <__adddf3+0x65c>
 821229c:	10004b1e 	bne	r2,zero,82123cc <__adddf3+0x6e8>
 82122a0:	4990b03a 	or	r8,r9,r6
 82122a4:	40008b26 	beq	r8,zero,82124d4 <__adddf3+0x7f0>
 82122a8:	4811883a 	mov	r8,r9
 82122ac:	3023883a 	mov	r17,r6
 82122b0:	3825883a 	mov	r18,r7
 82122b4:	003eaa06 	br	8211d60 <__adddf3+0x7c>
 82122b8:	1021883a 	mov	r16,r2
 82122bc:	0011883a 	mov	r8,zero
 82122c0:	0005883a 	mov	r2,zero
 82122c4:	003f0f06 	br	8211f04 <__adddf3+0x220>
 82122c8:	217ff804 	addi	r5,r4,-32
 82122cc:	00800804 	movi	r2,32
 82122d0:	494ad83a 	srl	r5,r9,r5
 82122d4:	20807d26 	beq	r4,r2,82124cc <__adddf3+0x7e8>
 82122d8:	00801004 	movi	r2,64
 82122dc:	1109c83a 	sub	r4,r2,r4
 82122e0:	4912983a 	sll	r9,r9,r4
 82122e4:	498cb03a 	or	r6,r9,r6
 82122e8:	300cc03a 	cmpne	r6,r6,zero
 82122ec:	298ab03a 	or	r5,r5,r6
 82122f0:	0013883a 	mov	r9,zero
 82122f4:	003f1506 	br	8211f4c <__adddf3+0x268>
 82122f8:	0101ffc4 	movi	r4,2047
 82122fc:	113f9a1e 	bne	r2,r4,8212168 <__adddf3+0x484>
 8212300:	4811883a 	mov	r8,r9
 8212304:	3023883a 	mov	r17,r6
 8212308:	1021883a 	mov	r16,r2
 821230c:	3825883a 	mov	r18,r7
 8212310:	003e9306 	br	8211d60 <__adddf3+0x7c>
 8212314:	8000161e 	bne	r16,zero,8212370 <__adddf3+0x68c>
 8212318:	444ab03a 	or	r5,r8,r17
 821231c:	28005126 	beq	r5,zero,8212464 <__adddf3+0x780>
 8212320:	0108303a 	nor	r4,zero,r4
 8212324:	20004d1e 	bne	r4,zero,821245c <__adddf3+0x778>
 8212328:	89a3883a 	add	r17,r17,r6
 821232c:	4253883a 	add	r9,r8,r9
 8212330:	898d803a 	cmpltu	r6,r17,r6
 8212334:	3251883a 	add	r8,r6,r9
 8212338:	1021883a 	mov	r16,r2
 821233c:	003f0806 	br	8211f60 <__adddf3+0x27c>
 8212340:	1000301e 	bne	r2,zero,8212404 <__adddf3+0x720>
 8212344:	4984b03a 	or	r2,r9,r6
 8212348:	10007126 	beq	r2,zero,8212510 <__adddf3+0x82c>
 821234c:	4811883a 	mov	r8,r9
 8212350:	3023883a 	mov	r17,r6
 8212354:	3825883a 	mov	r18,r7
 8212358:	0401ffc4 	movi	r16,2047
 821235c:	003e8006 	br	8211d60 <__adddf3+0x7c>
 8212360:	4462b03a 	or	r17,r8,r17
 8212364:	8822c03a 	cmpne	r17,r17,zero
 8212368:	0007883a 	mov	r3,zero
 821236c:	003f8b06 	br	821219c <__adddf3+0x4b8>
 8212370:	0141ffc4 	movi	r5,2047
 8212374:	11403b26 	beq	r2,r5,8212464 <__adddf3+0x780>
 8212378:	0109c83a 	sub	r4,zero,r4
 821237c:	42002034 	orhi	r8,r8,128
 8212380:	01400e04 	movi	r5,56
 8212384:	29006716 	blt	r5,r4,8212524 <__adddf3+0x840>
 8212388:	014007c4 	movi	r5,31
 821238c:	29007016 	blt	r5,r4,8212550 <__adddf3+0x86c>
 8212390:	01400804 	movi	r5,32
 8212394:	290bc83a 	sub	r5,r5,r4
 8212398:	4154983a 	sll	r10,r8,r5
 821239c:	890ed83a 	srl	r7,r17,r4
 82123a0:	894a983a 	sll	r5,r17,r5
 82123a4:	4108d83a 	srl	r4,r8,r4
 82123a8:	51e2b03a 	or	r17,r10,r7
 82123ac:	280ac03a 	cmpne	r5,r5,zero
 82123b0:	8962b03a 	or	r17,r17,r5
 82123b4:	89a3883a 	add	r17,r17,r6
 82123b8:	2253883a 	add	r9,r4,r9
 82123bc:	898d803a 	cmpltu	r6,r17,r6
 82123c0:	3251883a 	add	r8,r6,r9
 82123c4:	1021883a 	mov	r16,r2
 82123c8:	003ee506 	br	8211f60 <__adddf3+0x27c>
 82123cc:	4984b03a 	or	r2,r9,r6
 82123d0:	103e6326 	beq	r2,zero,8211d60 <__adddf3+0x7c>
 82123d4:	8987c83a 	sub	r3,r17,r6
 82123d8:	88c9803a 	cmpltu	r4,r17,r3
 82123dc:	4245c83a 	sub	r2,r8,r9
 82123e0:	1105c83a 	sub	r2,r2,r4
 82123e4:	1100202c 	andhi	r4,r2,128
 82123e8:	203ebb26 	beq	r4,zero,8211ed8 <__adddf3+0x1f4>
 82123ec:	3463c83a 	sub	r17,r6,r17
 82123f0:	4a07c83a 	sub	r3,r9,r8
 82123f4:	344d803a 	cmpltu	r6,r6,r17
 82123f8:	1991c83a 	sub	r8,r3,r6
 82123fc:	3825883a 	mov	r18,r7
 8212400:	003e5706 	br	8211d60 <__adddf3+0x7c>
 8212404:	4984b03a 	or	r2,r9,r6
 8212408:	10002e26 	beq	r2,zero,82124c4 <__adddf3+0x7e0>
 821240c:	4004d0fa 	srli	r2,r8,3
 8212410:	8822d0fa 	srli	r17,r17,3
 8212414:	4010977a 	slli	r8,r8,29
 8212418:	10c0022c 	andhi	r3,r2,8
 821241c:	4462b03a 	or	r17,r8,r17
 8212420:	18000826 	beq	r3,zero,8212444 <__adddf3+0x760>
 8212424:	4808d0fa 	srli	r4,r9,3
 8212428:	20c0022c 	andhi	r3,r4,8
 821242c:	1800051e 	bne	r3,zero,8212444 <__adddf3+0x760>
 8212430:	300cd0fa 	srli	r6,r6,3
 8212434:	4806977a 	slli	r3,r9,29
 8212438:	2005883a 	mov	r2,r4
 821243c:	3825883a 	mov	r18,r7
 8212440:	19a2b03a 	or	r17,r3,r6
 8212444:	8810d77a 	srli	r8,r17,29
 8212448:	100490fa 	slli	r2,r2,3
 821244c:	882290fa 	slli	r17,r17,3
 8212450:	0401ffc4 	movi	r16,2047
 8212454:	4090b03a 	or	r8,r8,r2
 8212458:	003e4106 	br	8211d60 <__adddf3+0x7c>
 821245c:	0141ffc4 	movi	r5,2047
 8212460:	117fc71e 	bne	r2,r5,8212380 <__adddf3+0x69c>
 8212464:	4811883a 	mov	r8,r9
 8212468:	3023883a 	mov	r17,r6
 821246c:	1021883a 	mov	r16,r2
 8212470:	003e3b06 	br	8211d60 <__adddf3+0x7c>
 8212474:	10002f26 	beq	r2,zero,8212534 <__adddf3+0x850>
 8212478:	4984b03a 	or	r2,r9,r6
 821247c:	10001126 	beq	r2,zero,82124c4 <__adddf3+0x7e0>
 8212480:	4004d0fa 	srli	r2,r8,3
 8212484:	8822d0fa 	srli	r17,r17,3
 8212488:	4010977a 	slli	r8,r8,29
 821248c:	10c0022c 	andhi	r3,r2,8
 8212490:	4462b03a 	or	r17,r8,r17
 8212494:	183feb26 	beq	r3,zero,8212444 <__adddf3+0x760>
 8212498:	4808d0fa 	srli	r4,r9,3
 821249c:	20c0022c 	andhi	r3,r4,8
 82124a0:	183fe81e 	bne	r3,zero,8212444 <__adddf3+0x760>
 82124a4:	300cd0fa 	srli	r6,r6,3
 82124a8:	4806977a 	slli	r3,r9,29
 82124ac:	2005883a 	mov	r2,r4
 82124b0:	19a2b03a 	or	r17,r3,r6
 82124b4:	003fe306 	br	8212444 <__adddf3+0x760>
 82124b8:	0011883a 	mov	r8,zero
 82124bc:	0005883a 	mov	r2,zero
 82124c0:	003e3f06 	br	8211dc0 <__adddf3+0xdc>
 82124c4:	0401ffc4 	movi	r16,2047
 82124c8:	003e2506 	br	8211d60 <__adddf3+0x7c>
 82124cc:	0013883a 	mov	r9,zero
 82124d0:	003f8406 	br	82122e4 <__adddf3+0x600>
 82124d4:	0005883a 	mov	r2,zero
 82124d8:	0007883a 	mov	r3,zero
 82124dc:	003e8906 	br	8211f04 <__adddf3+0x220>
 82124e0:	197ff804 	addi	r5,r3,-32
 82124e4:	01000804 	movi	r4,32
 82124e8:	414ad83a 	srl	r5,r8,r5
 82124ec:	19002426 	beq	r3,r4,8212580 <__adddf3+0x89c>
 82124f0:	01001004 	movi	r4,64
 82124f4:	20c7c83a 	sub	r3,r4,r3
 82124f8:	40c6983a 	sll	r3,r8,r3
 82124fc:	1c46b03a 	or	r3,r3,r17
 8212500:	1806c03a 	cmpne	r3,r3,zero
 8212504:	28e2b03a 	or	r17,r5,r3
 8212508:	0007883a 	mov	r3,zero
 821250c:	003f2306 	br	821219c <__adddf3+0x4b8>
 8212510:	0007883a 	mov	r3,zero
 8212514:	5811883a 	mov	r8,r11
 8212518:	00bfffc4 	movi	r2,-1
 821251c:	0401ffc4 	movi	r16,2047
 8212520:	003e7806 	br	8211f04 <__adddf3+0x220>
 8212524:	4462b03a 	or	r17,r8,r17
 8212528:	8822c03a 	cmpne	r17,r17,zero
 821252c:	0009883a 	mov	r4,zero
 8212530:	003fa006 	br	82123b4 <__adddf3+0x6d0>
 8212534:	4811883a 	mov	r8,r9
 8212538:	3023883a 	mov	r17,r6
 821253c:	0401ffc4 	movi	r16,2047
 8212540:	003e0706 	br	8211d60 <__adddf3+0x7c>
 8212544:	4811883a 	mov	r8,r9
 8212548:	3023883a 	mov	r17,r6
 821254c:	003e0406 	br	8211d60 <__adddf3+0x7c>
 8212550:	21fff804 	addi	r7,r4,-32
 8212554:	01400804 	movi	r5,32
 8212558:	41ced83a 	srl	r7,r8,r7
 821255c:	21400a26 	beq	r4,r5,8212588 <__adddf3+0x8a4>
 8212560:	01401004 	movi	r5,64
 8212564:	2909c83a 	sub	r4,r5,r4
 8212568:	4108983a 	sll	r4,r8,r4
 821256c:	2448b03a 	or	r4,r4,r17
 8212570:	2008c03a 	cmpne	r4,r4,zero
 8212574:	3922b03a 	or	r17,r7,r4
 8212578:	0009883a 	mov	r4,zero
 821257c:	003f8d06 	br	82123b4 <__adddf3+0x6d0>
 8212580:	0007883a 	mov	r3,zero
 8212584:	003fdd06 	br	82124fc <__adddf3+0x818>
 8212588:	0009883a 	mov	r4,zero
 821258c:	003ff706 	br	821256c <__adddf3+0x888>

08212590 <__divdf3>:
 8212590:	defff204 	addi	sp,sp,-56
 8212594:	dd400915 	stw	r21,36(sp)
 8212598:	282ad53a 	srli	r21,r5,20
 821259c:	dd000815 	stw	r20,32(sp)
 82125a0:	2828d7fa 	srli	r20,r5,31
 82125a4:	dc000415 	stw	r16,16(sp)
 82125a8:	04000434 	movhi	r16,16
 82125ac:	df000c15 	stw	fp,48(sp)
 82125b0:	843fffc4 	addi	r16,r16,-1
 82125b4:	dfc00d15 	stw	ra,52(sp)
 82125b8:	ddc00b15 	stw	r23,44(sp)
 82125bc:	dd800a15 	stw	r22,40(sp)
 82125c0:	dcc00715 	stw	r19,28(sp)
 82125c4:	dc800615 	stw	r18,24(sp)
 82125c8:	dc400515 	stw	r17,20(sp)
 82125cc:	ad41ffcc 	andi	r21,r21,2047
 82125d0:	2c20703a 	and	r16,r5,r16
 82125d4:	a7003fcc 	andi	fp,r20,255
 82125d8:	a8006126 	beq	r21,zero,8212760 <__divdf3+0x1d0>
 82125dc:	0081ffc4 	movi	r2,2047
 82125e0:	2025883a 	mov	r18,r4
 82125e4:	a8803726 	beq	r21,r2,82126c4 <__divdf3+0x134>
 82125e8:	80800434 	orhi	r2,r16,16
 82125ec:	100490fa 	slli	r2,r2,3
 82125f0:	2020d77a 	srli	r16,r4,29
 82125f4:	202490fa 	slli	r18,r4,3
 82125f8:	ad7f0044 	addi	r21,r21,-1023
 82125fc:	80a0b03a 	or	r16,r16,r2
 8212600:	0027883a 	mov	r19,zero
 8212604:	0013883a 	mov	r9,zero
 8212608:	3804d53a 	srli	r2,r7,20
 821260c:	382cd7fa 	srli	r22,r7,31
 8212610:	04400434 	movhi	r17,16
 8212614:	8c7fffc4 	addi	r17,r17,-1
 8212618:	1081ffcc 	andi	r2,r2,2047
 821261c:	3011883a 	mov	r8,r6
 8212620:	3c62703a 	and	r17,r7,r17
 8212624:	b5c03fcc 	andi	r23,r22,255
 8212628:	10006c26 	beq	r2,zero,82127dc <__divdf3+0x24c>
 821262c:	00c1ffc4 	movi	r3,2047
 8212630:	10c06426 	beq	r2,r3,82127c4 <__divdf3+0x234>
 8212634:	88c00434 	orhi	r3,r17,16
 8212638:	180690fa 	slli	r3,r3,3
 821263c:	3022d77a 	srli	r17,r6,29
 8212640:	301090fa 	slli	r8,r6,3
 8212644:	10bf0044 	addi	r2,r2,-1023
 8212648:	88e2b03a 	or	r17,r17,r3
 821264c:	000f883a 	mov	r7,zero
 8212650:	a58cf03a 	xor	r6,r20,r22
 8212654:	3cc8b03a 	or	r4,r7,r19
 8212658:	a8abc83a 	sub	r21,r21,r2
 821265c:	008003c4 	movi	r2,15
 8212660:	3007883a 	mov	r3,r6
 8212664:	34c03fcc 	andi	r19,r6,255
 8212668:	11009036 	bltu	r2,r4,82128ac <__divdf3+0x31c>
 821266c:	200890ba 	slli	r4,r4,2
 8212670:	00820874 	movhi	r2,2081
 8212674:	1089a104 	addi	r2,r2,9860
 8212678:	2089883a 	add	r4,r4,r2
 821267c:	20800017 	ldw	r2,0(r4)
 8212680:	1000683a 	jmp	r2
 8212684:	082128ac 	andhi	zero,at,33954
 8212688:	082126fc 	xorhi	zero,at,33947
 821268c:	0821289c 	xori	zero,at,33954
 8212690:	082126f0 	cmpltui	zero,at,33947
 8212694:	0821289c 	xori	zero,at,33954
 8212698:	08212870 	cmpltui	zero,at,33953
 821269c:	0821289c 	xori	zero,at,33954
 82126a0:	082126f0 	cmpltui	zero,at,33947
 82126a4:	082126fc 	xorhi	zero,at,33947
 82126a8:	082126fc 	xorhi	zero,at,33947
 82126ac:	08212870 	cmpltui	zero,at,33953
 82126b0:	082126f0 	cmpltui	zero,at,33947
 82126b4:	082126e0 	cmpeqi	zero,at,-31589
 82126b8:	082126e0 	cmpeqi	zero,at,-31589
 82126bc:	082126e0 	cmpeqi	zero,at,-31589
 82126c0:	08212b90 	cmplti	zero,at,-31570
 82126c4:	2404b03a 	or	r2,r4,r16
 82126c8:	1000661e 	bne	r2,zero,8212864 <__divdf3+0x2d4>
 82126cc:	04c00204 	movi	r19,8
 82126d0:	0021883a 	mov	r16,zero
 82126d4:	0025883a 	mov	r18,zero
 82126d8:	02400084 	movi	r9,2
 82126dc:	003fca06 	br	8212608 <__divdf3+0x78>
 82126e0:	8023883a 	mov	r17,r16
 82126e4:	9011883a 	mov	r8,r18
 82126e8:	e02f883a 	mov	r23,fp
 82126ec:	480f883a 	mov	r7,r9
 82126f0:	00800084 	movi	r2,2
 82126f4:	3881311e 	bne	r7,r2,8212bbc <__divdf3+0x62c>
 82126f8:	b827883a 	mov	r19,r23
 82126fc:	98c0004c 	andi	r3,r19,1
 8212700:	0081ffc4 	movi	r2,2047
 8212704:	000b883a 	mov	r5,zero
 8212708:	0025883a 	mov	r18,zero
 821270c:	1004953a 	slli	r2,r2,20
 8212710:	18c03fcc 	andi	r3,r3,255
 8212714:	04400434 	movhi	r17,16
 8212718:	8c7fffc4 	addi	r17,r17,-1
 821271c:	180697fa 	slli	r3,r3,31
 8212720:	2c4a703a 	and	r5,r5,r17
 8212724:	288ab03a 	or	r5,r5,r2
 8212728:	28c6b03a 	or	r3,r5,r3
 821272c:	9005883a 	mov	r2,r18
 8212730:	dfc00d17 	ldw	ra,52(sp)
 8212734:	df000c17 	ldw	fp,48(sp)
 8212738:	ddc00b17 	ldw	r23,44(sp)
 821273c:	dd800a17 	ldw	r22,40(sp)
 8212740:	dd400917 	ldw	r21,36(sp)
 8212744:	dd000817 	ldw	r20,32(sp)
 8212748:	dcc00717 	ldw	r19,28(sp)
 821274c:	dc800617 	ldw	r18,24(sp)
 8212750:	dc400517 	ldw	r17,20(sp)
 8212754:	dc000417 	ldw	r16,16(sp)
 8212758:	dec00e04 	addi	sp,sp,56
 821275c:	f800283a 	ret
 8212760:	2404b03a 	or	r2,r4,r16
 8212764:	2027883a 	mov	r19,r4
 8212768:	10003926 	beq	r2,zero,8212850 <__divdf3+0x2c0>
 821276c:	80012e26 	beq	r16,zero,8212c28 <__divdf3+0x698>
 8212770:	8009883a 	mov	r4,r16
 8212774:	d9800315 	stw	r6,12(sp)
 8212778:	d9c00215 	stw	r7,8(sp)
 821277c:	82142e80 	call	82142e8 <__clzsi2>
 8212780:	d9800317 	ldw	r6,12(sp)
 8212784:	d9c00217 	ldw	r7,8(sp)
 8212788:	113ffd44 	addi	r4,r2,-11
 821278c:	00c00704 	movi	r3,28
 8212790:	19012116 	blt	r3,r4,8212c18 <__divdf3+0x688>
 8212794:	00c00744 	movi	r3,29
 8212798:	147ffe04 	addi	r17,r2,-8
 821279c:	1907c83a 	sub	r3,r3,r4
 82127a0:	8460983a 	sll	r16,r16,r17
 82127a4:	98c6d83a 	srl	r3,r19,r3
 82127a8:	9c64983a 	sll	r18,r19,r17
 82127ac:	1c20b03a 	or	r16,r3,r16
 82127b0:	1080fcc4 	addi	r2,r2,1011
 82127b4:	00abc83a 	sub	r21,zero,r2
 82127b8:	0027883a 	mov	r19,zero
 82127bc:	0013883a 	mov	r9,zero
 82127c0:	003f9106 	br	8212608 <__divdf3+0x78>
 82127c4:	3446b03a 	or	r3,r6,r17
 82127c8:	18001f1e 	bne	r3,zero,8212848 <__divdf3+0x2b8>
 82127cc:	0023883a 	mov	r17,zero
 82127d0:	0011883a 	mov	r8,zero
 82127d4:	01c00084 	movi	r7,2
 82127d8:	003f9d06 	br	8212650 <__divdf3+0xc0>
 82127dc:	3446b03a 	or	r3,r6,r17
 82127e0:	18001526 	beq	r3,zero,8212838 <__divdf3+0x2a8>
 82127e4:	88011b26 	beq	r17,zero,8212c54 <__divdf3+0x6c4>
 82127e8:	8809883a 	mov	r4,r17
 82127ec:	d9800315 	stw	r6,12(sp)
 82127f0:	da400115 	stw	r9,4(sp)
 82127f4:	82142e80 	call	82142e8 <__clzsi2>
 82127f8:	d9800317 	ldw	r6,12(sp)
 82127fc:	da400117 	ldw	r9,4(sp)
 8212800:	113ffd44 	addi	r4,r2,-11
 8212804:	00c00704 	movi	r3,28
 8212808:	19010e16 	blt	r3,r4,8212c44 <__divdf3+0x6b4>
 821280c:	00c00744 	movi	r3,29
 8212810:	123ffe04 	addi	r8,r2,-8
 8212814:	1907c83a 	sub	r3,r3,r4
 8212818:	8a22983a 	sll	r17,r17,r8
 821281c:	30c6d83a 	srl	r3,r6,r3
 8212820:	3210983a 	sll	r8,r6,r8
 8212824:	1c62b03a 	or	r17,r3,r17
 8212828:	1080fcc4 	addi	r2,r2,1011
 821282c:	0085c83a 	sub	r2,zero,r2
 8212830:	000f883a 	mov	r7,zero
 8212834:	003f8606 	br	8212650 <__divdf3+0xc0>
 8212838:	0023883a 	mov	r17,zero
 821283c:	0011883a 	mov	r8,zero
 8212840:	01c00044 	movi	r7,1
 8212844:	003f8206 	br	8212650 <__divdf3+0xc0>
 8212848:	01c000c4 	movi	r7,3
 821284c:	003f8006 	br	8212650 <__divdf3+0xc0>
 8212850:	04c00104 	movi	r19,4
 8212854:	0021883a 	mov	r16,zero
 8212858:	0025883a 	mov	r18,zero
 821285c:	02400044 	movi	r9,1
 8212860:	003f6906 	br	8212608 <__divdf3+0x78>
 8212864:	04c00304 	movi	r19,12
 8212868:	024000c4 	movi	r9,3
 821286c:	003f6606 	br	8212608 <__divdf3+0x78>
 8212870:	01400434 	movhi	r5,16
 8212874:	0007883a 	mov	r3,zero
 8212878:	297fffc4 	addi	r5,r5,-1
 821287c:	04bfffc4 	movi	r18,-1
 8212880:	0081ffc4 	movi	r2,2047
 8212884:	003fa106 	br	821270c <__divdf3+0x17c>
 8212888:	00c00044 	movi	r3,1
 821288c:	1887c83a 	sub	r3,r3,r2
 8212890:	01000e04 	movi	r4,56
 8212894:	20c1210e 	bge	r4,r3,8212d1c <__divdf3+0x78c>
 8212898:	98c0004c 	andi	r3,r19,1
 821289c:	0005883a 	mov	r2,zero
 82128a0:	000b883a 	mov	r5,zero
 82128a4:	0025883a 	mov	r18,zero
 82128a8:	003f9806 	br	821270c <__divdf3+0x17c>
 82128ac:	8c00fd36 	bltu	r17,r16,8212ca4 <__divdf3+0x714>
 82128b0:	8440fb26 	beq	r16,r17,8212ca0 <__divdf3+0x710>
 82128b4:	8007883a 	mov	r3,r16
 82128b8:	ad7fffc4 	addi	r21,r21,-1
 82128bc:	0021883a 	mov	r16,zero
 82128c0:	4004d63a 	srli	r2,r8,24
 82128c4:	8822923a 	slli	r17,r17,8
 82128c8:	1809883a 	mov	r4,r3
 82128cc:	402c923a 	slli	r22,r8,8
 82128d0:	88b8b03a 	or	fp,r17,r2
 82128d4:	e028d43a 	srli	r20,fp,16
 82128d8:	d8c00015 	stw	r3,0(sp)
 82128dc:	e5ffffcc 	andi	r23,fp,65535
 82128e0:	a00b883a 	mov	r5,r20
 82128e4:	8202b8c0 	call	8202b8c <__udivsi3>
 82128e8:	d8c00017 	ldw	r3,0(sp)
 82128ec:	a00b883a 	mov	r5,r20
 82128f0:	d8800315 	stw	r2,12(sp)
 82128f4:	1809883a 	mov	r4,r3
 82128f8:	8202bf00 	call	8202bf0 <__umodsi3>
 82128fc:	d9800317 	ldw	r6,12(sp)
 8212900:	1006943a 	slli	r3,r2,16
 8212904:	9004d43a 	srli	r2,r18,16
 8212908:	b9a3383a 	mul	r17,r23,r6
 821290c:	10c4b03a 	or	r2,r2,r3
 8212910:	1440062e 	bgeu	r2,r17,821292c <__divdf3+0x39c>
 8212914:	1705883a 	add	r2,r2,fp
 8212918:	30ffffc4 	addi	r3,r6,-1
 821291c:	1700ee36 	bltu	r2,fp,8212cd8 <__divdf3+0x748>
 8212920:	1440ed2e 	bgeu	r2,r17,8212cd8 <__divdf3+0x748>
 8212924:	31bfff84 	addi	r6,r6,-2
 8212928:	1705883a 	add	r2,r2,fp
 821292c:	1463c83a 	sub	r17,r2,r17
 8212930:	a00b883a 	mov	r5,r20
 8212934:	8809883a 	mov	r4,r17
 8212938:	d9800315 	stw	r6,12(sp)
 821293c:	8202b8c0 	call	8202b8c <__udivsi3>
 8212940:	a00b883a 	mov	r5,r20
 8212944:	8809883a 	mov	r4,r17
 8212948:	d8800215 	stw	r2,8(sp)
 821294c:	8202bf00 	call	8202bf0 <__umodsi3>
 8212950:	d9c00217 	ldw	r7,8(sp)
 8212954:	1004943a 	slli	r2,r2,16
 8212958:	94bfffcc 	andi	r18,r18,65535
 821295c:	b9d1383a 	mul	r8,r23,r7
 8212960:	90a4b03a 	or	r18,r18,r2
 8212964:	d9800317 	ldw	r6,12(sp)
 8212968:	9200062e 	bgeu	r18,r8,8212984 <__divdf3+0x3f4>
 821296c:	9725883a 	add	r18,r18,fp
 8212970:	38bfffc4 	addi	r2,r7,-1
 8212974:	9700d636 	bltu	r18,fp,8212cd0 <__divdf3+0x740>
 8212978:	9200d52e 	bgeu	r18,r8,8212cd0 <__divdf3+0x740>
 821297c:	39ffff84 	addi	r7,r7,-2
 8212980:	9725883a 	add	r18,r18,fp
 8212984:	3004943a 	slli	r2,r6,16
 8212988:	b012d43a 	srli	r9,r22,16
 821298c:	b1bfffcc 	andi	r6,r22,65535
 8212990:	11e2b03a 	or	r17,r2,r7
 8212994:	8806d43a 	srli	r3,r17,16
 8212998:	893fffcc 	andi	r4,r17,65535
 821299c:	218b383a 	mul	r5,r4,r6
 82129a0:	30c5383a 	mul	r2,r6,r3
 82129a4:	2249383a 	mul	r4,r4,r9
 82129a8:	280ed43a 	srli	r7,r5,16
 82129ac:	9225c83a 	sub	r18,r18,r8
 82129b0:	2089883a 	add	r4,r4,r2
 82129b4:	3909883a 	add	r4,r7,r4
 82129b8:	1a47383a 	mul	r3,r3,r9
 82129bc:	2080022e 	bgeu	r4,r2,82129c8 <__divdf3+0x438>
 82129c0:	00800074 	movhi	r2,1
 82129c4:	1887883a 	add	r3,r3,r2
 82129c8:	2004d43a 	srli	r2,r4,16
 82129cc:	2008943a 	slli	r4,r4,16
 82129d0:	297fffcc 	andi	r5,r5,65535
 82129d4:	10c7883a 	add	r3,r2,r3
 82129d8:	2149883a 	add	r4,r4,r5
 82129dc:	90c0a536 	bltu	r18,r3,8212c74 <__divdf3+0x6e4>
 82129e0:	90c0bf26 	beq	r18,r3,8212ce0 <__divdf3+0x750>
 82129e4:	90c7c83a 	sub	r3,r18,r3
 82129e8:	810fc83a 	sub	r7,r16,r4
 82129ec:	81e5803a 	cmpltu	r18,r16,r7
 82129f0:	1ca5c83a 	sub	r18,r3,r18
 82129f4:	e480c126 	beq	fp,r18,8212cfc <__divdf3+0x76c>
 82129f8:	a00b883a 	mov	r5,r20
 82129fc:	9009883a 	mov	r4,r18
 8212a00:	d9800315 	stw	r6,12(sp)
 8212a04:	d9c00215 	stw	r7,8(sp)
 8212a08:	da400115 	stw	r9,4(sp)
 8212a0c:	8202b8c0 	call	8202b8c <__udivsi3>
 8212a10:	a00b883a 	mov	r5,r20
 8212a14:	9009883a 	mov	r4,r18
 8212a18:	d8800015 	stw	r2,0(sp)
 8212a1c:	8202bf00 	call	8202bf0 <__umodsi3>
 8212a20:	d9c00217 	ldw	r7,8(sp)
 8212a24:	da000017 	ldw	r8,0(sp)
 8212a28:	1006943a 	slli	r3,r2,16
 8212a2c:	3804d43a 	srli	r2,r7,16
 8212a30:	ba21383a 	mul	r16,r23,r8
 8212a34:	d9800317 	ldw	r6,12(sp)
 8212a38:	10c4b03a 	or	r2,r2,r3
 8212a3c:	da400117 	ldw	r9,4(sp)
 8212a40:	1400062e 	bgeu	r2,r16,8212a5c <__divdf3+0x4cc>
 8212a44:	1705883a 	add	r2,r2,fp
 8212a48:	40ffffc4 	addi	r3,r8,-1
 8212a4c:	1700ad36 	bltu	r2,fp,8212d04 <__divdf3+0x774>
 8212a50:	1400ac2e 	bgeu	r2,r16,8212d04 <__divdf3+0x774>
 8212a54:	423fff84 	addi	r8,r8,-2
 8212a58:	1705883a 	add	r2,r2,fp
 8212a5c:	1421c83a 	sub	r16,r2,r16
 8212a60:	a00b883a 	mov	r5,r20
 8212a64:	8009883a 	mov	r4,r16
 8212a68:	d9800315 	stw	r6,12(sp)
 8212a6c:	d9c00215 	stw	r7,8(sp)
 8212a70:	da000015 	stw	r8,0(sp)
 8212a74:	da400115 	stw	r9,4(sp)
 8212a78:	8202b8c0 	call	8202b8c <__udivsi3>
 8212a7c:	8009883a 	mov	r4,r16
 8212a80:	a00b883a 	mov	r5,r20
 8212a84:	1025883a 	mov	r18,r2
 8212a88:	8202bf00 	call	8202bf0 <__umodsi3>
 8212a8c:	d9c00217 	ldw	r7,8(sp)
 8212a90:	1004943a 	slli	r2,r2,16
 8212a94:	bcaf383a 	mul	r23,r23,r18
 8212a98:	393fffcc 	andi	r4,r7,65535
 8212a9c:	2088b03a 	or	r4,r4,r2
 8212aa0:	d9800317 	ldw	r6,12(sp)
 8212aa4:	da000017 	ldw	r8,0(sp)
 8212aa8:	da400117 	ldw	r9,4(sp)
 8212aac:	25c0062e 	bgeu	r4,r23,8212ac8 <__divdf3+0x538>
 8212ab0:	2709883a 	add	r4,r4,fp
 8212ab4:	90bfffc4 	addi	r2,r18,-1
 8212ab8:	27009436 	bltu	r4,fp,8212d0c <__divdf3+0x77c>
 8212abc:	25c0932e 	bgeu	r4,r23,8212d0c <__divdf3+0x77c>
 8212ac0:	94bfff84 	addi	r18,r18,-2
 8212ac4:	2709883a 	add	r4,r4,fp
 8212ac8:	4004943a 	slli	r2,r8,16
 8212acc:	25efc83a 	sub	r23,r4,r23
 8212ad0:	1490b03a 	or	r8,r2,r18
 8212ad4:	4008d43a 	srli	r4,r8,16
 8212ad8:	40ffffcc 	andi	r3,r8,65535
 8212adc:	30c5383a 	mul	r2,r6,r3
 8212ae0:	1a47383a 	mul	r3,r3,r9
 8212ae4:	310d383a 	mul	r6,r6,r4
 8212ae8:	100ad43a 	srli	r5,r2,16
 8212aec:	4913383a 	mul	r9,r9,r4
 8212af0:	1987883a 	add	r3,r3,r6
 8212af4:	28c7883a 	add	r3,r5,r3
 8212af8:	1980022e 	bgeu	r3,r6,8212b04 <__divdf3+0x574>
 8212afc:	01000074 	movhi	r4,1
 8212b00:	4913883a 	add	r9,r9,r4
 8212b04:	1808d43a 	srli	r4,r3,16
 8212b08:	1806943a 	slli	r3,r3,16
 8212b0c:	10bfffcc 	andi	r2,r2,65535
 8212b10:	2253883a 	add	r9,r4,r9
 8212b14:	1887883a 	add	r3,r3,r2
 8212b18:	ba403836 	bltu	r23,r9,8212bfc <__divdf3+0x66c>
 8212b1c:	ba403626 	beq	r23,r9,8212bf8 <__divdf3+0x668>
 8212b20:	42000054 	ori	r8,r8,1
 8212b24:	a880ffc4 	addi	r2,r21,1023
 8212b28:	00bf570e 	bge	zero,r2,8212888 <__divdf3+0x2f8>
 8212b2c:	40c001cc 	andi	r3,r8,7
 8212b30:	18000726 	beq	r3,zero,8212b50 <__divdf3+0x5c0>
 8212b34:	40c003cc 	andi	r3,r8,15
 8212b38:	01000104 	movi	r4,4
 8212b3c:	19000426 	beq	r3,r4,8212b50 <__divdf3+0x5c0>
 8212b40:	4107883a 	add	r3,r8,r4
 8212b44:	1a11803a 	cmpltu	r8,r3,r8
 8212b48:	8a23883a 	add	r17,r17,r8
 8212b4c:	1811883a 	mov	r8,r3
 8212b50:	88c0402c 	andhi	r3,r17,256
 8212b54:	18000426 	beq	r3,zero,8212b68 <__divdf3+0x5d8>
 8212b58:	00ffc034 	movhi	r3,65280
 8212b5c:	18ffffc4 	addi	r3,r3,-1
 8212b60:	a8810004 	addi	r2,r21,1024
 8212b64:	88e2703a 	and	r17,r17,r3
 8212b68:	00c1ff84 	movi	r3,2046
 8212b6c:	18bee316 	blt	r3,r2,82126fc <__divdf3+0x16c>
 8212b70:	8824977a 	slli	r18,r17,29
 8212b74:	4010d0fa 	srli	r8,r8,3
 8212b78:	8822927a 	slli	r17,r17,9
 8212b7c:	1081ffcc 	andi	r2,r2,2047
 8212b80:	9224b03a 	or	r18,r18,r8
 8212b84:	880ad33a 	srli	r5,r17,12
 8212b88:	98c0004c 	andi	r3,r19,1
 8212b8c:	003edf06 	br	821270c <__divdf3+0x17c>
 8212b90:	8080022c 	andhi	r2,r16,8
 8212b94:	10001226 	beq	r2,zero,8212be0 <__divdf3+0x650>
 8212b98:	8880022c 	andhi	r2,r17,8
 8212b9c:	1000101e 	bne	r2,zero,8212be0 <__divdf3+0x650>
 8212ba0:	00800434 	movhi	r2,16
 8212ba4:	89400234 	orhi	r5,r17,8
 8212ba8:	10bfffc4 	addi	r2,r2,-1
 8212bac:	b007883a 	mov	r3,r22
 8212bb0:	288a703a 	and	r5,r5,r2
 8212bb4:	4025883a 	mov	r18,r8
 8212bb8:	003f3106 	br	8212880 <__divdf3+0x2f0>
 8212bbc:	008000c4 	movi	r2,3
 8212bc0:	3880a626 	beq	r7,r2,8212e5c <__divdf3+0x8cc>
 8212bc4:	00800044 	movi	r2,1
 8212bc8:	3880521e 	bne	r7,r2,8212d14 <__divdf3+0x784>
 8212bcc:	b807883a 	mov	r3,r23
 8212bd0:	0005883a 	mov	r2,zero
 8212bd4:	000b883a 	mov	r5,zero
 8212bd8:	0025883a 	mov	r18,zero
 8212bdc:	003ecb06 	br	821270c <__divdf3+0x17c>
 8212be0:	00800434 	movhi	r2,16
 8212be4:	81400234 	orhi	r5,r16,8
 8212be8:	10bfffc4 	addi	r2,r2,-1
 8212bec:	a007883a 	mov	r3,r20
 8212bf0:	288a703a 	and	r5,r5,r2
 8212bf4:	003f2206 	br	8212880 <__divdf3+0x2f0>
 8212bf8:	183fca26 	beq	r3,zero,8212b24 <__divdf3+0x594>
 8212bfc:	e5ef883a 	add	r23,fp,r23
 8212c00:	40bfffc4 	addi	r2,r8,-1
 8212c04:	bf00392e 	bgeu	r23,fp,8212cec <__divdf3+0x75c>
 8212c08:	1011883a 	mov	r8,r2
 8212c0c:	ba7fc41e 	bne	r23,r9,8212b20 <__divdf3+0x590>
 8212c10:	b0ffc31e 	bne	r22,r3,8212b20 <__divdf3+0x590>
 8212c14:	003fc306 	br	8212b24 <__divdf3+0x594>
 8212c18:	143ff604 	addi	r16,r2,-40
 8212c1c:	9c20983a 	sll	r16,r19,r16
 8212c20:	0025883a 	mov	r18,zero
 8212c24:	003ee206 	br	82127b0 <__divdf3+0x220>
 8212c28:	d9800315 	stw	r6,12(sp)
 8212c2c:	d9c00215 	stw	r7,8(sp)
 8212c30:	82142e80 	call	82142e8 <__clzsi2>
 8212c34:	10800804 	addi	r2,r2,32
 8212c38:	d9c00217 	ldw	r7,8(sp)
 8212c3c:	d9800317 	ldw	r6,12(sp)
 8212c40:	003ed106 	br	8212788 <__divdf3+0x1f8>
 8212c44:	147ff604 	addi	r17,r2,-40
 8212c48:	3462983a 	sll	r17,r6,r17
 8212c4c:	0011883a 	mov	r8,zero
 8212c50:	003ef506 	br	8212828 <__divdf3+0x298>
 8212c54:	3009883a 	mov	r4,r6
 8212c58:	d9800315 	stw	r6,12(sp)
 8212c5c:	da400115 	stw	r9,4(sp)
 8212c60:	82142e80 	call	82142e8 <__clzsi2>
 8212c64:	10800804 	addi	r2,r2,32
 8212c68:	da400117 	ldw	r9,4(sp)
 8212c6c:	d9800317 	ldw	r6,12(sp)
 8212c70:	003ee306 	br	8212800 <__divdf3+0x270>
 8212c74:	85a1883a 	add	r16,r16,r22
 8212c78:	8585803a 	cmpltu	r2,r16,r22
 8212c7c:	1705883a 	add	r2,r2,fp
 8212c80:	14a5883a 	add	r18,r2,r18
 8212c84:	88bfffc4 	addi	r2,r17,-1
 8212c88:	e4800c2e 	bgeu	fp,r18,8212cbc <__divdf3+0x72c>
 8212c8c:	90c03e36 	bltu	r18,r3,8212d88 <__divdf3+0x7f8>
 8212c90:	1c806926 	beq	r3,r18,8212e38 <__divdf3+0x8a8>
 8212c94:	90c7c83a 	sub	r3,r18,r3
 8212c98:	1023883a 	mov	r17,r2
 8212c9c:	003f5206 	br	82129e8 <__divdf3+0x458>
 8212ca0:	923f0436 	bltu	r18,r8,82128b4 <__divdf3+0x324>
 8212ca4:	800897fa 	slli	r4,r16,31
 8212ca8:	9004d07a 	srli	r2,r18,1
 8212cac:	8006d07a 	srli	r3,r16,1
 8212cb0:	902097fa 	slli	r16,r18,31
 8212cb4:	20a4b03a 	or	r18,r4,r2
 8212cb8:	003f0106 	br	82128c0 <__divdf3+0x330>
 8212cbc:	e4bff51e 	bne	fp,r18,8212c94 <__divdf3+0x704>
 8212cc0:	85bff22e 	bgeu	r16,r22,8212c8c <__divdf3+0x6fc>
 8212cc4:	e0c7c83a 	sub	r3,fp,r3
 8212cc8:	1023883a 	mov	r17,r2
 8212ccc:	003f4606 	br	82129e8 <__divdf3+0x458>
 8212cd0:	100f883a 	mov	r7,r2
 8212cd4:	003f2b06 	br	8212984 <__divdf3+0x3f4>
 8212cd8:	180d883a 	mov	r6,r3
 8212cdc:	003f1306 	br	821292c <__divdf3+0x39c>
 8212ce0:	813fe436 	bltu	r16,r4,8212c74 <__divdf3+0x6e4>
 8212ce4:	0007883a 	mov	r3,zero
 8212ce8:	003f3f06 	br	82129e8 <__divdf3+0x458>
 8212cec:	ba402c36 	bltu	r23,r9,8212da0 <__divdf3+0x810>
 8212cf0:	4dc05426 	beq	r9,r23,8212e44 <__divdf3+0x8b4>
 8212cf4:	1011883a 	mov	r8,r2
 8212cf8:	003f8906 	br	8212b20 <__divdf3+0x590>
 8212cfc:	023fffc4 	movi	r8,-1
 8212d00:	003f8806 	br	8212b24 <__divdf3+0x594>
 8212d04:	1811883a 	mov	r8,r3
 8212d08:	003f5406 	br	8212a5c <__divdf3+0x4cc>
 8212d0c:	1025883a 	mov	r18,r2
 8212d10:	003f6d06 	br	8212ac8 <__divdf3+0x538>
 8212d14:	b827883a 	mov	r19,r23
 8212d18:	003f8206 	br	8212b24 <__divdf3+0x594>
 8212d1c:	010007c4 	movi	r4,31
 8212d20:	20c02616 	blt	r4,r3,8212dbc <__divdf3+0x82c>
 8212d24:	00800804 	movi	r2,32
 8212d28:	10c5c83a 	sub	r2,r2,r3
 8212d2c:	888a983a 	sll	r5,r17,r2
 8212d30:	40c8d83a 	srl	r4,r8,r3
 8212d34:	4084983a 	sll	r2,r8,r2
 8212d38:	88e2d83a 	srl	r17,r17,r3
 8212d3c:	2906b03a 	or	r3,r5,r4
 8212d40:	1004c03a 	cmpne	r2,r2,zero
 8212d44:	1886b03a 	or	r3,r3,r2
 8212d48:	188001cc 	andi	r2,r3,7
 8212d4c:	10000726 	beq	r2,zero,8212d6c <__divdf3+0x7dc>
 8212d50:	188003cc 	andi	r2,r3,15
 8212d54:	01000104 	movi	r4,4
 8212d58:	11000426 	beq	r2,r4,8212d6c <__divdf3+0x7dc>
 8212d5c:	1805883a 	mov	r2,r3
 8212d60:	10c00104 	addi	r3,r2,4
 8212d64:	1885803a 	cmpltu	r2,r3,r2
 8212d68:	88a3883a 	add	r17,r17,r2
 8212d6c:	8880202c 	andhi	r2,r17,128
 8212d70:	10002726 	beq	r2,zero,8212e10 <__divdf3+0x880>
 8212d74:	98c0004c 	andi	r3,r19,1
 8212d78:	00800044 	movi	r2,1
 8212d7c:	000b883a 	mov	r5,zero
 8212d80:	0025883a 	mov	r18,zero
 8212d84:	003e6106 	br	821270c <__divdf3+0x17c>
 8212d88:	85a1883a 	add	r16,r16,r22
 8212d8c:	8585803a 	cmpltu	r2,r16,r22
 8212d90:	1705883a 	add	r2,r2,fp
 8212d94:	14a5883a 	add	r18,r2,r18
 8212d98:	8c7fff84 	addi	r17,r17,-2
 8212d9c:	003f1106 	br	82129e4 <__divdf3+0x454>
 8212da0:	b589883a 	add	r4,r22,r22
 8212da4:	25ad803a 	cmpltu	r22,r4,r22
 8212da8:	b739883a 	add	fp,r22,fp
 8212dac:	40bfff84 	addi	r2,r8,-2
 8212db0:	bf2f883a 	add	r23,r23,fp
 8212db4:	202d883a 	mov	r22,r4
 8212db8:	003f9306 	br	8212c08 <__divdf3+0x678>
 8212dbc:	013ff844 	movi	r4,-31
 8212dc0:	2085c83a 	sub	r2,r4,r2
 8212dc4:	8888d83a 	srl	r4,r17,r2
 8212dc8:	00800804 	movi	r2,32
 8212dcc:	18802126 	beq	r3,r2,8212e54 <__divdf3+0x8c4>
 8212dd0:	00801004 	movi	r2,64
 8212dd4:	10c5c83a 	sub	r2,r2,r3
 8212dd8:	8884983a 	sll	r2,r17,r2
 8212ddc:	1204b03a 	or	r2,r2,r8
 8212de0:	1004c03a 	cmpne	r2,r2,zero
 8212de4:	2084b03a 	or	r2,r4,r2
 8212de8:	144001cc 	andi	r17,r2,7
 8212dec:	88000d1e 	bne	r17,zero,8212e24 <__divdf3+0x894>
 8212df0:	000b883a 	mov	r5,zero
 8212df4:	1024d0fa 	srli	r18,r2,3
 8212df8:	98c0004c 	andi	r3,r19,1
 8212dfc:	0005883a 	mov	r2,zero
 8212e00:	9464b03a 	or	r18,r18,r17
 8212e04:	003e4106 	br	821270c <__divdf3+0x17c>
 8212e08:	1007883a 	mov	r3,r2
 8212e0c:	0023883a 	mov	r17,zero
 8212e10:	880a927a 	slli	r5,r17,9
 8212e14:	1805883a 	mov	r2,r3
 8212e18:	8822977a 	slli	r17,r17,29
 8212e1c:	280ad33a 	srli	r5,r5,12
 8212e20:	003ff406 	br	8212df4 <__divdf3+0x864>
 8212e24:	10c003cc 	andi	r3,r2,15
 8212e28:	01000104 	movi	r4,4
 8212e2c:	193ff626 	beq	r3,r4,8212e08 <__divdf3+0x878>
 8212e30:	0023883a 	mov	r17,zero
 8212e34:	003fca06 	br	8212d60 <__divdf3+0x7d0>
 8212e38:	813fd336 	bltu	r16,r4,8212d88 <__divdf3+0x7f8>
 8212e3c:	1023883a 	mov	r17,r2
 8212e40:	003fa806 	br	8212ce4 <__divdf3+0x754>
 8212e44:	b0ffd636 	bltu	r22,r3,8212da0 <__divdf3+0x810>
 8212e48:	1011883a 	mov	r8,r2
 8212e4c:	b0ff341e 	bne	r22,r3,8212b20 <__divdf3+0x590>
 8212e50:	003f3406 	br	8212b24 <__divdf3+0x594>
 8212e54:	0005883a 	mov	r2,zero
 8212e58:	003fe006 	br	8212ddc <__divdf3+0x84c>
 8212e5c:	00800434 	movhi	r2,16
 8212e60:	89400234 	orhi	r5,r17,8
 8212e64:	10bfffc4 	addi	r2,r2,-1
 8212e68:	b807883a 	mov	r3,r23
 8212e6c:	288a703a 	and	r5,r5,r2
 8212e70:	4025883a 	mov	r18,r8
 8212e74:	003e8206 	br	8212880 <__divdf3+0x2f0>

08212e78 <__eqdf2>:
 8212e78:	2804d53a 	srli	r2,r5,20
 8212e7c:	3806d53a 	srli	r3,r7,20
 8212e80:	02000434 	movhi	r8,16
 8212e84:	423fffc4 	addi	r8,r8,-1
 8212e88:	1081ffcc 	andi	r2,r2,2047
 8212e8c:	0281ffc4 	movi	r10,2047
 8212e90:	2a12703a 	and	r9,r5,r8
 8212e94:	18c1ffcc 	andi	r3,r3,2047
 8212e98:	3a10703a 	and	r8,r7,r8
 8212e9c:	280ad7fa 	srli	r5,r5,31
 8212ea0:	380ed7fa 	srli	r7,r7,31
 8212ea4:	12801026 	beq	r2,r10,8212ee8 <__eqdf2+0x70>
 8212ea8:	0281ffc4 	movi	r10,2047
 8212eac:	1a800a26 	beq	r3,r10,8212ed8 <__eqdf2+0x60>
 8212eb0:	10c00226 	beq	r2,r3,8212ebc <__eqdf2+0x44>
 8212eb4:	00800044 	movi	r2,1
 8212eb8:	f800283a 	ret
 8212ebc:	4a3ffd1e 	bne	r9,r8,8212eb4 <__eqdf2+0x3c>
 8212ec0:	21bffc1e 	bne	r4,r6,8212eb4 <__eqdf2+0x3c>
 8212ec4:	29c00c26 	beq	r5,r7,8212ef8 <__eqdf2+0x80>
 8212ec8:	103ffa1e 	bne	r2,zero,8212eb4 <__eqdf2+0x3c>
 8212ecc:	2244b03a 	or	r2,r4,r9
 8212ed0:	1004c03a 	cmpne	r2,r2,zero
 8212ed4:	f800283a 	ret
 8212ed8:	3214b03a 	or	r10,r6,r8
 8212edc:	503ff426 	beq	r10,zero,8212eb0 <__eqdf2+0x38>
 8212ee0:	00800044 	movi	r2,1
 8212ee4:	f800283a 	ret
 8212ee8:	2254b03a 	or	r10,r4,r9
 8212eec:	503fee26 	beq	r10,zero,8212ea8 <__eqdf2+0x30>
 8212ef0:	00800044 	movi	r2,1
 8212ef4:	f800283a 	ret
 8212ef8:	0005883a 	mov	r2,zero
 8212efc:	f800283a 	ret

08212f00 <__gedf2>:
 8212f00:	2804d53a 	srli	r2,r5,20
 8212f04:	3806d53a 	srli	r3,r7,20
 8212f08:	02000434 	movhi	r8,16
 8212f0c:	423fffc4 	addi	r8,r8,-1
 8212f10:	1081ffcc 	andi	r2,r2,2047
 8212f14:	0241ffc4 	movi	r9,2047
 8212f18:	2a14703a 	and	r10,r5,r8
 8212f1c:	18c1ffcc 	andi	r3,r3,2047
 8212f20:	3a10703a 	and	r8,r7,r8
 8212f24:	280ad7fa 	srli	r5,r5,31
 8212f28:	380ed7fa 	srli	r7,r7,31
 8212f2c:	12401d26 	beq	r2,r9,8212fa4 <__gedf2+0xa4>
 8212f30:	0241ffc4 	movi	r9,2047
 8212f34:	1a401226 	beq	r3,r9,8212f80 <__gedf2+0x80>
 8212f38:	1000081e 	bne	r2,zero,8212f5c <__gedf2+0x5c>
 8212f3c:	2296b03a 	or	r11,r4,r10
 8212f40:	5813003a 	cmpeq	r9,r11,zero
 8212f44:	1800091e 	bne	r3,zero,8212f6c <__gedf2+0x6c>
 8212f48:	3218b03a 	or	r12,r6,r8
 8212f4c:	6000071e 	bne	r12,zero,8212f6c <__gedf2+0x6c>
 8212f50:	0005883a 	mov	r2,zero
 8212f54:	5800101e 	bne	r11,zero,8212f98 <__gedf2+0x98>
 8212f58:	f800283a 	ret
 8212f5c:	18000c1e 	bne	r3,zero,8212f90 <__gedf2+0x90>
 8212f60:	3212b03a 	or	r9,r6,r8
 8212f64:	48000c26 	beq	r9,zero,8212f98 <__gedf2+0x98>
 8212f68:	0013883a 	mov	r9,zero
 8212f6c:	39c03fcc 	andi	r7,r7,255
 8212f70:	48000826 	beq	r9,zero,8212f94 <__gedf2+0x94>
 8212f74:	38000926 	beq	r7,zero,8212f9c <__gedf2+0x9c>
 8212f78:	00800044 	movi	r2,1
 8212f7c:	f800283a 	ret
 8212f80:	3212b03a 	or	r9,r6,r8
 8212f84:	483fec26 	beq	r9,zero,8212f38 <__gedf2+0x38>
 8212f88:	00bfff84 	movi	r2,-2
 8212f8c:	f800283a 	ret
 8212f90:	39c03fcc 	andi	r7,r7,255
 8212f94:	29c00626 	beq	r5,r7,8212fb0 <__gedf2+0xb0>
 8212f98:	283ff726 	beq	r5,zero,8212f78 <__gedf2+0x78>
 8212f9c:	00bfffc4 	movi	r2,-1
 8212fa0:	f800283a 	ret
 8212fa4:	2292b03a 	or	r9,r4,r10
 8212fa8:	483fe126 	beq	r9,zero,8212f30 <__gedf2+0x30>
 8212fac:	003ff606 	br	8212f88 <__gedf2+0x88>
 8212fb0:	18bff916 	blt	r3,r2,8212f98 <__gedf2+0x98>
 8212fb4:	10c00316 	blt	r2,r3,8212fc4 <__gedf2+0xc4>
 8212fb8:	42bff736 	bltu	r8,r10,8212f98 <__gedf2+0x98>
 8212fbc:	52000326 	beq	r10,r8,8212fcc <__gedf2+0xcc>
 8212fc0:	5200042e 	bgeu	r10,r8,8212fd4 <__gedf2+0xd4>
 8212fc4:	283fec1e 	bne	r5,zero,8212f78 <__gedf2+0x78>
 8212fc8:	003ff406 	br	8212f9c <__gedf2+0x9c>
 8212fcc:	313ff236 	bltu	r6,r4,8212f98 <__gedf2+0x98>
 8212fd0:	21bffc36 	bltu	r4,r6,8212fc4 <__gedf2+0xc4>
 8212fd4:	0005883a 	mov	r2,zero
 8212fd8:	f800283a 	ret

08212fdc <__ledf2>:
 8212fdc:	2804d53a 	srli	r2,r5,20
 8212fe0:	3810d53a 	srli	r8,r7,20
 8212fe4:	00c00434 	movhi	r3,16
 8212fe8:	18ffffc4 	addi	r3,r3,-1
 8212fec:	1081ffcc 	andi	r2,r2,2047
 8212ff0:	0241ffc4 	movi	r9,2047
 8212ff4:	28d4703a 	and	r10,r5,r3
 8212ff8:	4201ffcc 	andi	r8,r8,2047
 8212ffc:	38c6703a 	and	r3,r7,r3
 8213000:	280ad7fa 	srli	r5,r5,31
 8213004:	380ed7fa 	srli	r7,r7,31
 8213008:	12401f26 	beq	r2,r9,8213088 <__ledf2+0xac>
 821300c:	0241ffc4 	movi	r9,2047
 8213010:	42401426 	beq	r8,r9,8213064 <__ledf2+0x88>
 8213014:	1000091e 	bne	r2,zero,821303c <__ledf2+0x60>
 8213018:	2296b03a 	or	r11,r4,r10
 821301c:	5813003a 	cmpeq	r9,r11,zero
 8213020:	29403fcc 	andi	r5,r5,255
 8213024:	40000a1e 	bne	r8,zero,8213050 <__ledf2+0x74>
 8213028:	30d8b03a 	or	r12,r6,r3
 821302c:	6000081e 	bne	r12,zero,8213050 <__ledf2+0x74>
 8213030:	0005883a 	mov	r2,zero
 8213034:	5800111e 	bne	r11,zero,821307c <__ledf2+0xa0>
 8213038:	f800283a 	ret
 821303c:	29403fcc 	andi	r5,r5,255
 8213040:	40000c1e 	bne	r8,zero,8213074 <__ledf2+0x98>
 8213044:	30d2b03a 	or	r9,r6,r3
 8213048:	48000c26 	beq	r9,zero,821307c <__ledf2+0xa0>
 821304c:	0013883a 	mov	r9,zero
 8213050:	39c03fcc 	andi	r7,r7,255
 8213054:	48000826 	beq	r9,zero,8213078 <__ledf2+0x9c>
 8213058:	38001126 	beq	r7,zero,82130a0 <__ledf2+0xc4>
 821305c:	00800044 	movi	r2,1
 8213060:	f800283a 	ret
 8213064:	30d2b03a 	or	r9,r6,r3
 8213068:	483fea26 	beq	r9,zero,8213014 <__ledf2+0x38>
 821306c:	00800084 	movi	r2,2
 8213070:	f800283a 	ret
 8213074:	39c03fcc 	andi	r7,r7,255
 8213078:	39400726 	beq	r7,r5,8213098 <__ledf2+0xbc>
 821307c:	2800081e 	bne	r5,zero,82130a0 <__ledf2+0xc4>
 8213080:	00800044 	movi	r2,1
 8213084:	f800283a 	ret
 8213088:	2292b03a 	or	r9,r4,r10
 821308c:	483fdf26 	beq	r9,zero,821300c <__ledf2+0x30>
 8213090:	00800084 	movi	r2,2
 8213094:	f800283a 	ret
 8213098:	4080030e 	bge	r8,r2,82130a8 <__ledf2+0xcc>
 821309c:	383fef26 	beq	r7,zero,821305c <__ledf2+0x80>
 82130a0:	00bfffc4 	movi	r2,-1
 82130a4:	f800283a 	ret
 82130a8:	123feb16 	blt	r2,r8,8213058 <__ledf2+0x7c>
 82130ac:	1abff336 	bltu	r3,r10,821307c <__ledf2+0xa0>
 82130b0:	50c00326 	beq	r10,r3,82130c0 <__ledf2+0xe4>
 82130b4:	50c0042e 	bgeu	r10,r3,82130c8 <__ledf2+0xec>
 82130b8:	283fe81e 	bne	r5,zero,821305c <__ledf2+0x80>
 82130bc:	003ff806 	br	82130a0 <__ledf2+0xc4>
 82130c0:	313fee36 	bltu	r6,r4,821307c <__ledf2+0xa0>
 82130c4:	21bffc36 	bltu	r4,r6,82130b8 <__ledf2+0xdc>
 82130c8:	0005883a 	mov	r2,zero
 82130cc:	f800283a 	ret

082130d0 <__muldf3>:
 82130d0:	defff304 	addi	sp,sp,-52
 82130d4:	2804d53a 	srli	r2,r5,20
 82130d8:	dd800915 	stw	r22,36(sp)
 82130dc:	282cd7fa 	srli	r22,r5,31
 82130e0:	dc000315 	stw	r16,12(sp)
 82130e4:	04000434 	movhi	r16,16
 82130e8:	dd400815 	stw	r21,32(sp)
 82130ec:	dc800515 	stw	r18,20(sp)
 82130f0:	843fffc4 	addi	r16,r16,-1
 82130f4:	dfc00c15 	stw	ra,48(sp)
 82130f8:	df000b15 	stw	fp,44(sp)
 82130fc:	ddc00a15 	stw	r23,40(sp)
 8213100:	dd000715 	stw	r20,28(sp)
 8213104:	dcc00615 	stw	r19,24(sp)
 8213108:	dc400415 	stw	r17,16(sp)
 821310c:	1481ffcc 	andi	r18,r2,2047
 8213110:	2c20703a 	and	r16,r5,r16
 8213114:	b02b883a 	mov	r21,r22
 8213118:	b2403fcc 	andi	r9,r22,255
 821311c:	90006026 	beq	r18,zero,82132a0 <__muldf3+0x1d0>
 8213120:	0081ffc4 	movi	r2,2047
 8213124:	2029883a 	mov	r20,r4
 8213128:	90803626 	beq	r18,r2,8213204 <__muldf3+0x134>
 821312c:	80800434 	orhi	r2,r16,16
 8213130:	100490fa 	slli	r2,r2,3
 8213134:	2020d77a 	srli	r16,r4,29
 8213138:	202890fa 	slli	r20,r4,3
 821313c:	94bf0044 	addi	r18,r18,-1023
 8213140:	80a0b03a 	or	r16,r16,r2
 8213144:	0027883a 	mov	r19,zero
 8213148:	0039883a 	mov	fp,zero
 821314c:	3804d53a 	srli	r2,r7,20
 8213150:	382ed7fa 	srli	r23,r7,31
 8213154:	04400434 	movhi	r17,16
 8213158:	8c7fffc4 	addi	r17,r17,-1
 821315c:	1081ffcc 	andi	r2,r2,2047
 8213160:	3011883a 	mov	r8,r6
 8213164:	3c62703a 	and	r17,r7,r17
 8213168:	ba803fcc 	andi	r10,r23,255
 821316c:	10006d26 	beq	r2,zero,8213324 <__muldf3+0x254>
 8213170:	00c1ffc4 	movi	r3,2047
 8213174:	10c06526 	beq	r2,r3,821330c <__muldf3+0x23c>
 8213178:	88c00434 	orhi	r3,r17,16
 821317c:	180690fa 	slli	r3,r3,3
 8213180:	3022d77a 	srli	r17,r6,29
 8213184:	301090fa 	slli	r8,r6,3
 8213188:	10bf0044 	addi	r2,r2,-1023
 821318c:	88e2b03a 	or	r17,r17,r3
 8213190:	000b883a 	mov	r5,zero
 8213194:	9085883a 	add	r2,r18,r2
 8213198:	2cc8b03a 	or	r4,r5,r19
 821319c:	00c003c4 	movi	r3,15
 82131a0:	bdacf03a 	xor	r22,r23,r22
 82131a4:	12c00044 	addi	r11,r2,1
 82131a8:	19009936 	bltu	r3,r4,8213410 <__muldf3+0x340>
 82131ac:	200890ba 	slli	r4,r4,2
 82131b0:	00c20874 	movhi	r3,2081
 82131b4:	18cc7104 	addi	r3,r3,12740
 82131b8:	20c9883a 	add	r4,r4,r3
 82131bc:	20c00017 	ldw	r3,0(r4)
 82131c0:	1800683a 	jmp	r3
 82131c4:	08213410 	cmplti	zero,at,-31536
 82131c8:	08213224 	muli	zero,at,-31544
 82131cc:	08213224 	muli	zero,at,-31544
 82131d0:	08213220 	cmpeqi	zero,at,-31544
 82131d4:	082133ec 	andhi	zero,at,33999
 82131d8:	082133ec 	andhi	zero,at,33999
 82131dc:	082133d4 	ori	zero,at,33999
 82131e0:	08213220 	cmpeqi	zero,at,-31544
 82131e4:	082133ec 	andhi	zero,at,33999
 82131e8:	082133d4 	ori	zero,at,33999
 82131ec:	082133ec 	andhi	zero,at,33999
 82131f0:	08213220 	cmpeqi	zero,at,-31544
 82131f4:	082133fc 	xorhi	zero,at,33999
 82131f8:	082133fc 	xorhi	zero,at,33999
 82131fc:	082133fc 	xorhi	zero,at,33999
 8213200:	08213618 	cmpnei	zero,at,-31528
 8213204:	2404b03a 	or	r2,r4,r16
 8213208:	10006f1e 	bne	r2,zero,82133c8 <__muldf3+0x2f8>
 821320c:	04c00204 	movi	r19,8
 8213210:	0021883a 	mov	r16,zero
 8213214:	0029883a 	mov	r20,zero
 8213218:	07000084 	movi	fp,2
 821321c:	003fcb06 	br	821314c <__muldf3+0x7c>
 8213220:	502d883a 	mov	r22,r10
 8213224:	00800084 	movi	r2,2
 8213228:	28805726 	beq	r5,r2,8213388 <__muldf3+0x2b8>
 821322c:	008000c4 	movi	r2,3
 8213230:	28816626 	beq	r5,r2,82137cc <__muldf3+0x6fc>
 8213234:	00800044 	movi	r2,1
 8213238:	2881411e 	bne	r5,r2,8213740 <__muldf3+0x670>
 821323c:	b02b883a 	mov	r21,r22
 8213240:	0005883a 	mov	r2,zero
 8213244:	000b883a 	mov	r5,zero
 8213248:	0029883a 	mov	r20,zero
 821324c:	1004953a 	slli	r2,r2,20
 8213250:	a8c03fcc 	andi	r3,r21,255
 8213254:	04400434 	movhi	r17,16
 8213258:	8c7fffc4 	addi	r17,r17,-1
 821325c:	180697fa 	slli	r3,r3,31
 8213260:	2c4a703a 	and	r5,r5,r17
 8213264:	288ab03a 	or	r5,r5,r2
 8213268:	28c6b03a 	or	r3,r5,r3
 821326c:	a005883a 	mov	r2,r20
 8213270:	dfc00c17 	ldw	ra,48(sp)
 8213274:	df000b17 	ldw	fp,44(sp)
 8213278:	ddc00a17 	ldw	r23,40(sp)
 821327c:	dd800917 	ldw	r22,36(sp)
 8213280:	dd400817 	ldw	r21,32(sp)
 8213284:	dd000717 	ldw	r20,28(sp)
 8213288:	dcc00617 	ldw	r19,24(sp)
 821328c:	dc800517 	ldw	r18,20(sp)
 8213290:	dc400417 	ldw	r17,16(sp)
 8213294:	dc000317 	ldw	r16,12(sp)
 8213298:	dec00d04 	addi	sp,sp,52
 821329c:	f800283a 	ret
 82132a0:	2404b03a 	or	r2,r4,r16
 82132a4:	2027883a 	mov	r19,r4
 82132a8:	10004226 	beq	r2,zero,82133b4 <__muldf3+0x2e4>
 82132ac:	8000fc26 	beq	r16,zero,82136a0 <__muldf3+0x5d0>
 82132b0:	8009883a 	mov	r4,r16
 82132b4:	d9800215 	stw	r6,8(sp)
 82132b8:	d9c00015 	stw	r7,0(sp)
 82132bc:	da400115 	stw	r9,4(sp)
 82132c0:	82142e80 	call	82142e8 <__clzsi2>
 82132c4:	d9800217 	ldw	r6,8(sp)
 82132c8:	d9c00017 	ldw	r7,0(sp)
 82132cc:	da400117 	ldw	r9,4(sp)
 82132d0:	113ffd44 	addi	r4,r2,-11
 82132d4:	00c00704 	movi	r3,28
 82132d8:	1900ed16 	blt	r3,r4,8213690 <__muldf3+0x5c0>
 82132dc:	00c00744 	movi	r3,29
 82132e0:	147ffe04 	addi	r17,r2,-8
 82132e4:	1907c83a 	sub	r3,r3,r4
 82132e8:	8460983a 	sll	r16,r16,r17
 82132ec:	98c6d83a 	srl	r3,r19,r3
 82132f0:	9c68983a 	sll	r20,r19,r17
 82132f4:	1c20b03a 	or	r16,r3,r16
 82132f8:	1080fcc4 	addi	r2,r2,1011
 82132fc:	00a5c83a 	sub	r18,zero,r2
 8213300:	0027883a 	mov	r19,zero
 8213304:	0039883a 	mov	fp,zero
 8213308:	003f9006 	br	821314c <__muldf3+0x7c>
 821330c:	3446b03a 	or	r3,r6,r17
 8213310:	1800261e 	bne	r3,zero,82133ac <__muldf3+0x2dc>
 8213314:	0023883a 	mov	r17,zero
 8213318:	0011883a 	mov	r8,zero
 821331c:	01400084 	movi	r5,2
 8213320:	003f9c06 	br	8213194 <__muldf3+0xc4>
 8213324:	3446b03a 	or	r3,r6,r17
 8213328:	18001c26 	beq	r3,zero,821339c <__muldf3+0x2cc>
 821332c:	8800ce26 	beq	r17,zero,8213668 <__muldf3+0x598>
 8213330:	8809883a 	mov	r4,r17
 8213334:	d9800215 	stw	r6,8(sp)
 8213338:	da400115 	stw	r9,4(sp)
 821333c:	da800015 	stw	r10,0(sp)
 8213340:	82142e80 	call	82142e8 <__clzsi2>
 8213344:	d9800217 	ldw	r6,8(sp)
 8213348:	da400117 	ldw	r9,4(sp)
 821334c:	da800017 	ldw	r10,0(sp)
 8213350:	113ffd44 	addi	r4,r2,-11
 8213354:	00c00704 	movi	r3,28
 8213358:	1900bf16 	blt	r3,r4,8213658 <__muldf3+0x588>
 821335c:	00c00744 	movi	r3,29
 8213360:	123ffe04 	addi	r8,r2,-8
 8213364:	1907c83a 	sub	r3,r3,r4
 8213368:	8a22983a 	sll	r17,r17,r8
 821336c:	30c6d83a 	srl	r3,r6,r3
 8213370:	3210983a 	sll	r8,r6,r8
 8213374:	1c62b03a 	or	r17,r3,r17
 8213378:	1080fcc4 	addi	r2,r2,1011
 821337c:	0085c83a 	sub	r2,zero,r2
 8213380:	000b883a 	mov	r5,zero
 8213384:	003f8306 	br	8213194 <__muldf3+0xc4>
 8213388:	b02b883a 	mov	r21,r22
 821338c:	0081ffc4 	movi	r2,2047
 8213390:	000b883a 	mov	r5,zero
 8213394:	0029883a 	mov	r20,zero
 8213398:	003fac06 	br	821324c <__muldf3+0x17c>
 821339c:	0023883a 	mov	r17,zero
 82133a0:	0011883a 	mov	r8,zero
 82133a4:	01400044 	movi	r5,1
 82133a8:	003f7a06 	br	8213194 <__muldf3+0xc4>
 82133ac:	014000c4 	movi	r5,3
 82133b0:	003f7806 	br	8213194 <__muldf3+0xc4>
 82133b4:	04c00104 	movi	r19,4
 82133b8:	0021883a 	mov	r16,zero
 82133bc:	0029883a 	mov	r20,zero
 82133c0:	07000044 	movi	fp,1
 82133c4:	003f6106 	br	821314c <__muldf3+0x7c>
 82133c8:	04c00304 	movi	r19,12
 82133cc:	070000c4 	movi	fp,3
 82133d0:	003f5e06 	br	821314c <__muldf3+0x7c>
 82133d4:	01400434 	movhi	r5,16
 82133d8:	002b883a 	mov	r21,zero
 82133dc:	297fffc4 	addi	r5,r5,-1
 82133e0:	053fffc4 	movi	r20,-1
 82133e4:	0081ffc4 	movi	r2,2047
 82133e8:	003f9806 	br	821324c <__muldf3+0x17c>
 82133ec:	8023883a 	mov	r17,r16
 82133f0:	a011883a 	mov	r8,r20
 82133f4:	e00b883a 	mov	r5,fp
 82133f8:	003f8a06 	br	8213224 <__muldf3+0x154>
 82133fc:	8023883a 	mov	r17,r16
 8213400:	a011883a 	mov	r8,r20
 8213404:	482d883a 	mov	r22,r9
 8213408:	e00b883a 	mov	r5,fp
 821340c:	003f8506 	br	8213224 <__muldf3+0x154>
 8213410:	a00ad43a 	srli	r5,r20,16
 8213414:	401ad43a 	srli	r13,r8,16
 8213418:	a53fffcc 	andi	r20,r20,65535
 821341c:	423fffcc 	andi	r8,r8,65535
 8213420:	4519383a 	mul	r12,r8,r20
 8213424:	4147383a 	mul	r3,r8,r5
 8213428:	6d09383a 	mul	r4,r13,r20
 821342c:	600cd43a 	srli	r6,r12,16
 8213430:	2b5d383a 	mul	r14,r5,r13
 8213434:	20c9883a 	add	r4,r4,r3
 8213438:	310d883a 	add	r6,r6,r4
 821343c:	30c0022e 	bgeu	r6,r3,8213448 <__muldf3+0x378>
 8213440:	00c00074 	movhi	r3,1
 8213444:	70dd883a 	add	r14,r14,r3
 8213448:	8826d43a 	srli	r19,r17,16
 821344c:	8bffffcc 	andi	r15,r17,65535
 8213450:	7d23383a 	mul	r17,r15,r20
 8213454:	7949383a 	mul	r4,r15,r5
 8213458:	9d29383a 	mul	r20,r19,r20
 821345c:	8814d43a 	srli	r10,r17,16
 8213460:	3012943a 	slli	r9,r6,16
 8213464:	a129883a 	add	r20,r20,r4
 8213468:	633fffcc 	andi	r12,r12,65535
 821346c:	5515883a 	add	r10,r10,r20
 8213470:	3006d43a 	srli	r3,r6,16
 8213474:	4b13883a 	add	r9,r9,r12
 8213478:	2ccb383a 	mul	r5,r5,r19
 821347c:	5100022e 	bgeu	r10,r4,8213488 <__muldf3+0x3b8>
 8213480:	01000074 	movhi	r4,1
 8213484:	290b883a 	add	r5,r5,r4
 8213488:	802ad43a 	srli	r21,r16,16
 821348c:	843fffcc 	andi	r16,r16,65535
 8213490:	440d383a 	mul	r6,r8,r16
 8213494:	4565383a 	mul	r18,r8,r21
 8213498:	8349383a 	mul	r4,r16,r13
 821349c:	500e943a 	slli	r7,r10,16
 82134a0:	3010d43a 	srli	r8,r6,16
 82134a4:	5028d43a 	srli	r20,r10,16
 82134a8:	2489883a 	add	r4,r4,r18
 82134ac:	8abfffcc 	andi	r10,r17,65535
 82134b0:	3a95883a 	add	r10,r7,r10
 82134b4:	4119883a 	add	r12,r8,r4
 82134b8:	a169883a 	add	r20,r20,r5
 82134bc:	1a87883a 	add	r3,r3,r10
 82134c0:	6d5b383a 	mul	r13,r13,r21
 82134c4:	6480022e 	bgeu	r12,r18,82134d0 <__muldf3+0x400>
 82134c8:	01000074 	movhi	r4,1
 82134cc:	691b883a 	add	r13,r13,r4
 82134d0:	7c25383a 	mul	r18,r15,r16
 82134d4:	7d4b383a 	mul	r5,r15,r21
 82134d8:	84cf383a 	mul	r7,r16,r19
 82134dc:	901ed43a 	srli	r15,r18,16
 82134e0:	6008d43a 	srli	r4,r12,16
 82134e4:	6010943a 	slli	r8,r12,16
 82134e8:	394f883a 	add	r7,r7,r5
 82134ec:	333fffcc 	andi	r12,r6,65535
 82134f0:	79df883a 	add	r15,r15,r7
 82134f4:	235b883a 	add	r13,r4,r13
 82134f8:	9d63383a 	mul	r17,r19,r21
 82134fc:	4309883a 	add	r4,r8,r12
 8213500:	7940022e 	bgeu	r15,r5,821350c <__muldf3+0x43c>
 8213504:	01400074 	movhi	r5,1
 8213508:	8963883a 	add	r17,r17,r5
 821350c:	780a943a 	slli	r5,r15,16
 8213510:	91bfffcc 	andi	r6,r18,65535
 8213514:	70c7883a 	add	r3,r14,r3
 8213518:	298d883a 	add	r6,r5,r6
 821351c:	1a8f803a 	cmpltu	r7,r3,r10
 8213520:	350b883a 	add	r5,r6,r20
 8213524:	20c7883a 	add	r3,r4,r3
 8213528:	3955883a 	add	r10,r7,r5
 821352c:	1909803a 	cmpltu	r4,r3,r4
 8213530:	6a91883a 	add	r8,r13,r10
 8213534:	780cd43a 	srli	r6,r15,16
 8213538:	2219883a 	add	r12,r4,r8
 821353c:	2d0b803a 	cmpltu	r5,r5,r20
 8213540:	51cf803a 	cmpltu	r7,r10,r7
 8213544:	29ceb03a 	or	r7,r5,r7
 8213548:	4351803a 	cmpltu	r8,r8,r13
 821354c:	610b803a 	cmpltu	r5,r12,r4
 8213550:	4148b03a 	or	r4,r8,r5
 8213554:	398f883a 	add	r7,r7,r6
 8213558:	3909883a 	add	r4,r7,r4
 821355c:	1810927a 	slli	r8,r3,9
 8213560:	2449883a 	add	r4,r4,r17
 8213564:	2008927a 	slli	r4,r4,9
 8213568:	6022d5fa 	srli	r17,r12,23
 821356c:	1806d5fa 	srli	r3,r3,23
 8213570:	4252b03a 	or	r9,r8,r9
 8213574:	600a927a 	slli	r5,r12,9
 8213578:	4810c03a 	cmpne	r8,r9,zero
 821357c:	2462b03a 	or	r17,r4,r17
 8213580:	40c6b03a 	or	r3,r8,r3
 8213584:	8900402c 	andhi	r4,r17,256
 8213588:	1950b03a 	or	r8,r3,r5
 821358c:	20000726 	beq	r4,zero,82135ac <__muldf3+0x4dc>
 8213590:	4006d07a 	srli	r3,r8,1
 8213594:	880497fa 	slli	r2,r17,31
 8213598:	4200004c 	andi	r8,r8,1
 821359c:	8822d07a 	srli	r17,r17,1
 82135a0:	1a10b03a 	or	r8,r3,r8
 82135a4:	1210b03a 	or	r8,r2,r8
 82135a8:	5805883a 	mov	r2,r11
 82135ac:	1140ffc4 	addi	r5,r2,1023
 82135b0:	0140440e 	bge	zero,r5,82136c4 <__muldf3+0x5f4>
 82135b4:	40c001cc 	andi	r3,r8,7
 82135b8:	18000726 	beq	r3,zero,82135d8 <__muldf3+0x508>
 82135bc:	40c003cc 	andi	r3,r8,15
 82135c0:	01000104 	movi	r4,4
 82135c4:	19000426 	beq	r3,r4,82135d8 <__muldf3+0x508>
 82135c8:	4107883a 	add	r3,r8,r4
 82135cc:	1a11803a 	cmpltu	r8,r3,r8
 82135d0:	8a23883a 	add	r17,r17,r8
 82135d4:	1811883a 	mov	r8,r3
 82135d8:	88c0402c 	andhi	r3,r17,256
 82135dc:	18000426 	beq	r3,zero,82135f0 <__muldf3+0x520>
 82135e0:	11410004 	addi	r5,r2,1024
 82135e4:	00bfc034 	movhi	r2,65280
 82135e8:	10bfffc4 	addi	r2,r2,-1
 82135ec:	88a2703a 	and	r17,r17,r2
 82135f0:	0081ff84 	movi	r2,2046
 82135f4:	117f6416 	blt	r2,r5,8213388 <__muldf3+0x2b8>
 82135f8:	8828977a 	slli	r20,r17,29
 82135fc:	4010d0fa 	srli	r8,r8,3
 8213600:	8822927a 	slli	r17,r17,9
 8213604:	2881ffcc 	andi	r2,r5,2047
 8213608:	a228b03a 	or	r20,r20,r8
 821360c:	880ad33a 	srli	r5,r17,12
 8213610:	b02b883a 	mov	r21,r22
 8213614:	003f0d06 	br	821324c <__muldf3+0x17c>
 8213618:	8080022c 	andhi	r2,r16,8
 821361c:	10000926 	beq	r2,zero,8213644 <__muldf3+0x574>
 8213620:	8880022c 	andhi	r2,r17,8
 8213624:	1000071e 	bne	r2,zero,8213644 <__muldf3+0x574>
 8213628:	00800434 	movhi	r2,16
 821362c:	89400234 	orhi	r5,r17,8
 8213630:	10bfffc4 	addi	r2,r2,-1
 8213634:	b82b883a 	mov	r21,r23
 8213638:	288a703a 	and	r5,r5,r2
 821363c:	4029883a 	mov	r20,r8
 8213640:	003f6806 	br	82133e4 <__muldf3+0x314>
 8213644:	00800434 	movhi	r2,16
 8213648:	81400234 	orhi	r5,r16,8
 821364c:	10bfffc4 	addi	r2,r2,-1
 8213650:	288a703a 	and	r5,r5,r2
 8213654:	003f6306 	br	82133e4 <__muldf3+0x314>
 8213658:	147ff604 	addi	r17,r2,-40
 821365c:	3462983a 	sll	r17,r6,r17
 8213660:	0011883a 	mov	r8,zero
 8213664:	003f4406 	br	8213378 <__muldf3+0x2a8>
 8213668:	3009883a 	mov	r4,r6
 821366c:	d9800215 	stw	r6,8(sp)
 8213670:	da400115 	stw	r9,4(sp)
 8213674:	da800015 	stw	r10,0(sp)
 8213678:	82142e80 	call	82142e8 <__clzsi2>
 821367c:	10800804 	addi	r2,r2,32
 8213680:	da800017 	ldw	r10,0(sp)
 8213684:	da400117 	ldw	r9,4(sp)
 8213688:	d9800217 	ldw	r6,8(sp)
 821368c:	003f3006 	br	8213350 <__muldf3+0x280>
 8213690:	143ff604 	addi	r16,r2,-40
 8213694:	9c20983a 	sll	r16,r19,r16
 8213698:	0029883a 	mov	r20,zero
 821369c:	003f1606 	br	82132f8 <__muldf3+0x228>
 82136a0:	d9800215 	stw	r6,8(sp)
 82136a4:	d9c00015 	stw	r7,0(sp)
 82136a8:	da400115 	stw	r9,4(sp)
 82136ac:	82142e80 	call	82142e8 <__clzsi2>
 82136b0:	10800804 	addi	r2,r2,32
 82136b4:	da400117 	ldw	r9,4(sp)
 82136b8:	d9c00017 	ldw	r7,0(sp)
 82136bc:	d9800217 	ldw	r6,8(sp)
 82136c0:	003f0306 	br	82132d0 <__muldf3+0x200>
 82136c4:	00c00044 	movi	r3,1
 82136c8:	1947c83a 	sub	r3,r3,r5
 82136cc:	00800e04 	movi	r2,56
 82136d0:	10feda16 	blt	r2,r3,821323c <__muldf3+0x16c>
 82136d4:	008007c4 	movi	r2,31
 82136d8:	10c01b16 	blt	r2,r3,8213748 <__muldf3+0x678>
 82136dc:	00800804 	movi	r2,32
 82136e0:	10c5c83a 	sub	r2,r2,r3
 82136e4:	888a983a 	sll	r5,r17,r2
 82136e8:	40c8d83a 	srl	r4,r8,r3
 82136ec:	4084983a 	sll	r2,r8,r2
 82136f0:	88e2d83a 	srl	r17,r17,r3
 82136f4:	2906b03a 	or	r3,r5,r4
 82136f8:	1004c03a 	cmpne	r2,r2,zero
 82136fc:	1886b03a 	or	r3,r3,r2
 8213700:	188001cc 	andi	r2,r3,7
 8213704:	10000726 	beq	r2,zero,8213724 <__muldf3+0x654>
 8213708:	188003cc 	andi	r2,r3,15
 821370c:	01000104 	movi	r4,4
 8213710:	11000426 	beq	r2,r4,8213724 <__muldf3+0x654>
 8213714:	1805883a 	mov	r2,r3
 8213718:	10c00104 	addi	r3,r2,4
 821371c:	1885803a 	cmpltu	r2,r3,r2
 8213720:	88a3883a 	add	r17,r17,r2
 8213724:	8880202c 	andhi	r2,r17,128
 8213728:	10001c26 	beq	r2,zero,821379c <__muldf3+0x6cc>
 821372c:	b02b883a 	mov	r21,r22
 8213730:	00800044 	movi	r2,1
 8213734:	000b883a 	mov	r5,zero
 8213738:	0029883a 	mov	r20,zero
 821373c:	003ec306 	br	821324c <__muldf3+0x17c>
 8213740:	5805883a 	mov	r2,r11
 8213744:	003f9906 	br	82135ac <__muldf3+0x4dc>
 8213748:	00bff844 	movi	r2,-31
 821374c:	1145c83a 	sub	r2,r2,r5
 8213750:	8888d83a 	srl	r4,r17,r2
 8213754:	00800804 	movi	r2,32
 8213758:	18801a26 	beq	r3,r2,82137c4 <__muldf3+0x6f4>
 821375c:	00801004 	movi	r2,64
 8213760:	10c5c83a 	sub	r2,r2,r3
 8213764:	8884983a 	sll	r2,r17,r2
 8213768:	1204b03a 	or	r2,r2,r8
 821376c:	1004c03a 	cmpne	r2,r2,zero
 8213770:	2084b03a 	or	r2,r4,r2
 8213774:	144001cc 	andi	r17,r2,7
 8213778:	88000d1e 	bne	r17,zero,82137b0 <__muldf3+0x6e0>
 821377c:	000b883a 	mov	r5,zero
 8213780:	1028d0fa 	srli	r20,r2,3
 8213784:	b02b883a 	mov	r21,r22
 8213788:	0005883a 	mov	r2,zero
 821378c:	a468b03a 	or	r20,r20,r17
 8213790:	003eae06 	br	821324c <__muldf3+0x17c>
 8213794:	1007883a 	mov	r3,r2
 8213798:	0023883a 	mov	r17,zero
 821379c:	880a927a 	slli	r5,r17,9
 82137a0:	1805883a 	mov	r2,r3
 82137a4:	8822977a 	slli	r17,r17,29
 82137a8:	280ad33a 	srli	r5,r5,12
 82137ac:	003ff406 	br	8213780 <__muldf3+0x6b0>
 82137b0:	10c003cc 	andi	r3,r2,15
 82137b4:	01000104 	movi	r4,4
 82137b8:	193ff626 	beq	r3,r4,8213794 <__muldf3+0x6c4>
 82137bc:	0023883a 	mov	r17,zero
 82137c0:	003fd506 	br	8213718 <__muldf3+0x648>
 82137c4:	0005883a 	mov	r2,zero
 82137c8:	003fe706 	br	8213768 <__muldf3+0x698>
 82137cc:	00800434 	movhi	r2,16
 82137d0:	89400234 	orhi	r5,r17,8
 82137d4:	10bfffc4 	addi	r2,r2,-1
 82137d8:	b02b883a 	mov	r21,r22
 82137dc:	288a703a 	and	r5,r5,r2
 82137e0:	4029883a 	mov	r20,r8
 82137e4:	003eff06 	br	82133e4 <__muldf3+0x314>

082137e8 <__subdf3>:
 82137e8:	02000434 	movhi	r8,16
 82137ec:	423fffc4 	addi	r8,r8,-1
 82137f0:	defffb04 	addi	sp,sp,-20
 82137f4:	2a14703a 	and	r10,r5,r8
 82137f8:	3812d53a 	srli	r9,r7,20
 82137fc:	3a10703a 	and	r8,r7,r8
 8213800:	2006d77a 	srli	r3,r4,29
 8213804:	3004d77a 	srli	r2,r6,29
 8213808:	dc000015 	stw	r16,0(sp)
 821380c:	501490fa 	slli	r10,r10,3
 8213810:	2820d53a 	srli	r16,r5,20
 8213814:	401090fa 	slli	r8,r8,3
 8213818:	dc800215 	stw	r18,8(sp)
 821381c:	dc400115 	stw	r17,4(sp)
 8213820:	dfc00415 	stw	ra,16(sp)
 8213824:	202290fa 	slli	r17,r4,3
 8213828:	dcc00315 	stw	r19,12(sp)
 821382c:	4a41ffcc 	andi	r9,r9,2047
 8213830:	0101ffc4 	movi	r4,2047
 8213834:	2824d7fa 	srli	r18,r5,31
 8213838:	8401ffcc 	andi	r16,r16,2047
 821383c:	50c6b03a 	or	r3,r10,r3
 8213840:	380ed7fa 	srli	r7,r7,31
 8213844:	408ab03a 	or	r5,r8,r2
 8213848:	300c90fa 	slli	r6,r6,3
 821384c:	49009626 	beq	r9,r4,8213aa8 <__subdf3+0x2c0>
 8213850:	39c0005c 	xori	r7,r7,1
 8213854:	8245c83a 	sub	r2,r16,r9
 8213858:	3c807426 	beq	r7,r18,8213a2c <__subdf3+0x244>
 821385c:	0080af0e 	bge	zero,r2,8213b1c <__subdf3+0x334>
 8213860:	48002a1e 	bne	r9,zero,821390c <__subdf3+0x124>
 8213864:	2988b03a 	or	r4,r5,r6
 8213868:	20009a1e 	bne	r4,zero,8213ad4 <__subdf3+0x2ec>
 821386c:	888001cc 	andi	r2,r17,7
 8213870:	10000726 	beq	r2,zero,8213890 <__subdf3+0xa8>
 8213874:	888003cc 	andi	r2,r17,15
 8213878:	01000104 	movi	r4,4
 821387c:	11000426 	beq	r2,r4,8213890 <__subdf3+0xa8>
 8213880:	890b883a 	add	r5,r17,r4
 8213884:	2c63803a 	cmpltu	r17,r5,r17
 8213888:	1c47883a 	add	r3,r3,r17
 821388c:	2823883a 	mov	r17,r5
 8213890:	1880202c 	andhi	r2,r3,128
 8213894:	10005926 	beq	r2,zero,82139fc <__subdf3+0x214>
 8213898:	84000044 	addi	r16,r16,1
 821389c:	0081ffc4 	movi	r2,2047
 82138a0:	8080be26 	beq	r16,r2,8213b9c <__subdf3+0x3b4>
 82138a4:	017fe034 	movhi	r5,65408
 82138a8:	297fffc4 	addi	r5,r5,-1
 82138ac:	1946703a 	and	r3,r3,r5
 82138b0:	1804977a 	slli	r2,r3,29
 82138b4:	1806927a 	slli	r3,r3,9
 82138b8:	8822d0fa 	srli	r17,r17,3
 82138bc:	8401ffcc 	andi	r16,r16,2047
 82138c0:	180ad33a 	srli	r5,r3,12
 82138c4:	9100004c 	andi	r4,r18,1
 82138c8:	1444b03a 	or	r2,r2,r17
 82138cc:	80c1ffcc 	andi	r3,r16,2047
 82138d0:	1820953a 	slli	r16,r3,20
 82138d4:	20c03fcc 	andi	r3,r4,255
 82138d8:	180897fa 	slli	r4,r3,31
 82138dc:	00c00434 	movhi	r3,16
 82138e0:	18ffffc4 	addi	r3,r3,-1
 82138e4:	28c6703a 	and	r3,r5,r3
 82138e8:	1c06b03a 	or	r3,r3,r16
 82138ec:	1906b03a 	or	r3,r3,r4
 82138f0:	dfc00417 	ldw	ra,16(sp)
 82138f4:	dcc00317 	ldw	r19,12(sp)
 82138f8:	dc800217 	ldw	r18,8(sp)
 82138fc:	dc400117 	ldw	r17,4(sp)
 8213900:	dc000017 	ldw	r16,0(sp)
 8213904:	dec00504 	addi	sp,sp,20
 8213908:	f800283a 	ret
 821390c:	0101ffc4 	movi	r4,2047
 8213910:	813fd626 	beq	r16,r4,821386c <__subdf3+0x84>
 8213914:	29402034 	orhi	r5,r5,128
 8213918:	01000e04 	movi	r4,56
 821391c:	2080a316 	blt	r4,r2,8213bac <__subdf3+0x3c4>
 8213920:	010007c4 	movi	r4,31
 8213924:	2080c616 	blt	r4,r2,8213c40 <__subdf3+0x458>
 8213928:	01000804 	movi	r4,32
 821392c:	2089c83a 	sub	r4,r4,r2
 8213930:	2910983a 	sll	r8,r5,r4
 8213934:	308ed83a 	srl	r7,r6,r2
 8213938:	3108983a 	sll	r4,r6,r4
 821393c:	2884d83a 	srl	r2,r5,r2
 8213940:	41ccb03a 	or	r6,r8,r7
 8213944:	2008c03a 	cmpne	r4,r4,zero
 8213948:	310cb03a 	or	r6,r6,r4
 821394c:	898dc83a 	sub	r6,r17,r6
 8213950:	89a3803a 	cmpltu	r17,r17,r6
 8213954:	1887c83a 	sub	r3,r3,r2
 8213958:	1c47c83a 	sub	r3,r3,r17
 821395c:	3023883a 	mov	r17,r6
 8213960:	1880202c 	andhi	r2,r3,128
 8213964:	10002326 	beq	r2,zero,82139f4 <__subdf3+0x20c>
 8213968:	04c02034 	movhi	r19,128
 821396c:	9cffffc4 	addi	r19,r19,-1
 8213970:	1ce6703a 	and	r19,r3,r19
 8213974:	98007a26 	beq	r19,zero,8213b60 <__subdf3+0x378>
 8213978:	9809883a 	mov	r4,r19
 821397c:	82142e80 	call	82142e8 <__clzsi2>
 8213980:	113ffe04 	addi	r4,r2,-8
 8213984:	00c007c4 	movi	r3,31
 8213988:	19007b16 	blt	r3,r4,8213b78 <__subdf3+0x390>
 821398c:	00800804 	movi	r2,32
 8213990:	1105c83a 	sub	r2,r2,r4
 8213994:	8884d83a 	srl	r2,r17,r2
 8213998:	9906983a 	sll	r3,r19,r4
 821399c:	8922983a 	sll	r17,r17,r4
 82139a0:	10c4b03a 	or	r2,r2,r3
 82139a4:	24007816 	blt	r4,r16,8213b88 <__subdf3+0x3a0>
 82139a8:	2421c83a 	sub	r16,r4,r16
 82139ac:	80c00044 	addi	r3,r16,1
 82139b0:	010007c4 	movi	r4,31
 82139b4:	20c09516 	blt	r4,r3,8213c0c <__subdf3+0x424>
 82139b8:	01400804 	movi	r5,32
 82139bc:	28cbc83a 	sub	r5,r5,r3
 82139c0:	88c8d83a 	srl	r4,r17,r3
 82139c4:	8962983a 	sll	r17,r17,r5
 82139c8:	114a983a 	sll	r5,r2,r5
 82139cc:	10c6d83a 	srl	r3,r2,r3
 82139d0:	8804c03a 	cmpne	r2,r17,zero
 82139d4:	290ab03a 	or	r5,r5,r4
 82139d8:	28a2b03a 	or	r17,r5,r2
 82139dc:	0021883a 	mov	r16,zero
 82139e0:	003fa206 	br	821386c <__subdf3+0x84>
 82139e4:	2090b03a 	or	r8,r4,r2
 82139e8:	40018e26 	beq	r8,zero,8214024 <__subdf3+0x83c>
 82139ec:	1007883a 	mov	r3,r2
 82139f0:	2023883a 	mov	r17,r4
 82139f4:	888001cc 	andi	r2,r17,7
 82139f8:	103f9e1e 	bne	r2,zero,8213874 <__subdf3+0x8c>
 82139fc:	1804977a 	slli	r2,r3,29
 8213a00:	8822d0fa 	srli	r17,r17,3
 8213a04:	1810d0fa 	srli	r8,r3,3
 8213a08:	9100004c 	andi	r4,r18,1
 8213a0c:	1444b03a 	or	r2,r2,r17
 8213a10:	00c1ffc4 	movi	r3,2047
 8213a14:	80c02826 	beq	r16,r3,8213ab8 <__subdf3+0x2d0>
 8213a18:	01400434 	movhi	r5,16
 8213a1c:	297fffc4 	addi	r5,r5,-1
 8213a20:	80e0703a 	and	r16,r16,r3
 8213a24:	414a703a 	and	r5,r8,r5
 8213a28:	003fa806 	br	82138cc <__subdf3+0xe4>
 8213a2c:	0080630e 	bge	zero,r2,8213bbc <__subdf3+0x3d4>
 8213a30:	48003026 	beq	r9,zero,8213af4 <__subdf3+0x30c>
 8213a34:	0101ffc4 	movi	r4,2047
 8213a38:	813f8c26 	beq	r16,r4,821386c <__subdf3+0x84>
 8213a3c:	29402034 	orhi	r5,r5,128
 8213a40:	01000e04 	movi	r4,56
 8213a44:	2080a90e 	bge	r4,r2,8213cec <__subdf3+0x504>
 8213a48:	298cb03a 	or	r6,r5,r6
 8213a4c:	3012c03a 	cmpne	r9,r6,zero
 8213a50:	0005883a 	mov	r2,zero
 8213a54:	4c53883a 	add	r9,r9,r17
 8213a58:	4c63803a 	cmpltu	r17,r9,r17
 8213a5c:	10c7883a 	add	r3,r2,r3
 8213a60:	88c7883a 	add	r3,r17,r3
 8213a64:	4823883a 	mov	r17,r9
 8213a68:	1880202c 	andhi	r2,r3,128
 8213a6c:	1000d026 	beq	r2,zero,8213db0 <__subdf3+0x5c8>
 8213a70:	84000044 	addi	r16,r16,1
 8213a74:	0081ffc4 	movi	r2,2047
 8213a78:	8080fe26 	beq	r16,r2,8213e74 <__subdf3+0x68c>
 8213a7c:	00bfe034 	movhi	r2,65408
 8213a80:	10bfffc4 	addi	r2,r2,-1
 8213a84:	1886703a 	and	r3,r3,r2
 8213a88:	880ad07a 	srli	r5,r17,1
 8213a8c:	180497fa 	slli	r2,r3,31
 8213a90:	8900004c 	andi	r4,r17,1
 8213a94:	2922b03a 	or	r17,r5,r4
 8213a98:	1806d07a 	srli	r3,r3,1
 8213a9c:	1462b03a 	or	r17,r2,r17
 8213aa0:	3825883a 	mov	r18,r7
 8213aa4:	003f7106 	br	821386c <__subdf3+0x84>
 8213aa8:	2984b03a 	or	r2,r5,r6
 8213aac:	103f6826 	beq	r2,zero,8213850 <__subdf3+0x68>
 8213ab0:	39c03fcc 	andi	r7,r7,255
 8213ab4:	003f6706 	br	8213854 <__subdf3+0x6c>
 8213ab8:	4086b03a 	or	r3,r8,r2
 8213abc:	18015226 	beq	r3,zero,8214008 <__subdf3+0x820>
 8213ac0:	00c00434 	movhi	r3,16
 8213ac4:	41400234 	orhi	r5,r8,8
 8213ac8:	18ffffc4 	addi	r3,r3,-1
 8213acc:	28ca703a 	and	r5,r5,r3
 8213ad0:	003f7e06 	br	82138cc <__subdf3+0xe4>
 8213ad4:	10bfffc4 	addi	r2,r2,-1
 8213ad8:	1000491e 	bne	r2,zero,8213c00 <__subdf3+0x418>
 8213adc:	898fc83a 	sub	r7,r17,r6
 8213ae0:	89e3803a 	cmpltu	r17,r17,r7
 8213ae4:	1947c83a 	sub	r3,r3,r5
 8213ae8:	1c47c83a 	sub	r3,r3,r17
 8213aec:	3823883a 	mov	r17,r7
 8213af0:	003f9b06 	br	8213960 <__subdf3+0x178>
 8213af4:	2988b03a 	or	r4,r5,r6
 8213af8:	203f5c26 	beq	r4,zero,821386c <__subdf3+0x84>
 8213afc:	10bfffc4 	addi	r2,r2,-1
 8213b00:	1000931e 	bne	r2,zero,8213d50 <__subdf3+0x568>
 8213b04:	898d883a 	add	r6,r17,r6
 8213b08:	3463803a 	cmpltu	r17,r6,r17
 8213b0c:	1947883a 	add	r3,r3,r5
 8213b10:	88c7883a 	add	r3,r17,r3
 8213b14:	3023883a 	mov	r17,r6
 8213b18:	003fd306 	br	8213a68 <__subdf3+0x280>
 8213b1c:	1000541e 	bne	r2,zero,8213c70 <__subdf3+0x488>
 8213b20:	80800044 	addi	r2,r16,1
 8213b24:	1081ffcc 	andi	r2,r2,2047
 8213b28:	01000044 	movi	r4,1
 8213b2c:	2080a20e 	bge	r4,r2,8213db8 <__subdf3+0x5d0>
 8213b30:	8989c83a 	sub	r4,r17,r6
 8213b34:	8905803a 	cmpltu	r2,r17,r4
 8213b38:	1967c83a 	sub	r19,r3,r5
 8213b3c:	98a7c83a 	sub	r19,r19,r2
 8213b40:	9880202c 	andhi	r2,r19,128
 8213b44:	10006326 	beq	r2,zero,8213cd4 <__subdf3+0x4ec>
 8213b48:	3463c83a 	sub	r17,r6,r17
 8213b4c:	28c7c83a 	sub	r3,r5,r3
 8213b50:	344d803a 	cmpltu	r6,r6,r17
 8213b54:	19a7c83a 	sub	r19,r3,r6
 8213b58:	3825883a 	mov	r18,r7
 8213b5c:	983f861e 	bne	r19,zero,8213978 <__subdf3+0x190>
 8213b60:	8809883a 	mov	r4,r17
 8213b64:	82142e80 	call	82142e8 <__clzsi2>
 8213b68:	10800804 	addi	r2,r2,32
 8213b6c:	113ffe04 	addi	r4,r2,-8
 8213b70:	00c007c4 	movi	r3,31
 8213b74:	193f850e 	bge	r3,r4,821398c <__subdf3+0x1a4>
 8213b78:	10bff604 	addi	r2,r2,-40
 8213b7c:	8884983a 	sll	r2,r17,r2
 8213b80:	0023883a 	mov	r17,zero
 8213b84:	243f880e 	bge	r4,r16,82139a8 <__subdf3+0x1c0>
 8213b88:	00ffe034 	movhi	r3,65408
 8213b8c:	18ffffc4 	addi	r3,r3,-1
 8213b90:	8121c83a 	sub	r16,r16,r4
 8213b94:	10c6703a 	and	r3,r2,r3
 8213b98:	003f3406 	br	821386c <__subdf3+0x84>
 8213b9c:	9100004c 	andi	r4,r18,1
 8213ba0:	000b883a 	mov	r5,zero
 8213ba4:	0005883a 	mov	r2,zero
 8213ba8:	003f4806 	br	82138cc <__subdf3+0xe4>
 8213bac:	298cb03a 	or	r6,r5,r6
 8213bb0:	300cc03a 	cmpne	r6,r6,zero
 8213bb4:	0005883a 	mov	r2,zero
 8213bb8:	003f6406 	br	821394c <__subdf3+0x164>
 8213bbc:	10009a1e 	bne	r2,zero,8213e28 <__subdf3+0x640>
 8213bc0:	82400044 	addi	r9,r16,1
 8213bc4:	4881ffcc 	andi	r2,r9,2047
 8213bc8:	02800044 	movi	r10,1
 8213bcc:	5080670e 	bge	r10,r2,8213d6c <__subdf3+0x584>
 8213bd0:	0081ffc4 	movi	r2,2047
 8213bd4:	4880af26 	beq	r9,r2,8213e94 <__subdf3+0x6ac>
 8213bd8:	898d883a 	add	r6,r17,r6
 8213bdc:	1945883a 	add	r2,r3,r5
 8213be0:	3447803a 	cmpltu	r3,r6,r17
 8213be4:	1887883a 	add	r3,r3,r2
 8213be8:	182297fa 	slli	r17,r3,31
 8213bec:	300cd07a 	srli	r6,r6,1
 8213bf0:	1806d07a 	srli	r3,r3,1
 8213bf4:	4821883a 	mov	r16,r9
 8213bf8:	89a2b03a 	or	r17,r17,r6
 8213bfc:	003f1b06 	br	821386c <__subdf3+0x84>
 8213c00:	0101ffc4 	movi	r4,2047
 8213c04:	813f441e 	bne	r16,r4,8213918 <__subdf3+0x130>
 8213c08:	003f1806 	br	821386c <__subdf3+0x84>
 8213c0c:	843ff844 	addi	r16,r16,-31
 8213c10:	01400804 	movi	r5,32
 8213c14:	1408d83a 	srl	r4,r2,r16
 8213c18:	19405026 	beq	r3,r5,8213d5c <__subdf3+0x574>
 8213c1c:	01401004 	movi	r5,64
 8213c20:	28c7c83a 	sub	r3,r5,r3
 8213c24:	10c4983a 	sll	r2,r2,r3
 8213c28:	88a2b03a 	or	r17,r17,r2
 8213c2c:	8822c03a 	cmpne	r17,r17,zero
 8213c30:	2462b03a 	or	r17,r4,r17
 8213c34:	0007883a 	mov	r3,zero
 8213c38:	0021883a 	mov	r16,zero
 8213c3c:	003f6d06 	br	82139f4 <__subdf3+0x20c>
 8213c40:	11fff804 	addi	r7,r2,-32
 8213c44:	01000804 	movi	r4,32
 8213c48:	29ced83a 	srl	r7,r5,r7
 8213c4c:	11004526 	beq	r2,r4,8213d64 <__subdf3+0x57c>
 8213c50:	01001004 	movi	r4,64
 8213c54:	2089c83a 	sub	r4,r4,r2
 8213c58:	2904983a 	sll	r2,r5,r4
 8213c5c:	118cb03a 	or	r6,r2,r6
 8213c60:	300cc03a 	cmpne	r6,r6,zero
 8213c64:	398cb03a 	or	r6,r7,r6
 8213c68:	0005883a 	mov	r2,zero
 8213c6c:	003f3706 	br	821394c <__subdf3+0x164>
 8213c70:	80002a26 	beq	r16,zero,8213d1c <__subdf3+0x534>
 8213c74:	0101ffc4 	movi	r4,2047
 8213c78:	49006626 	beq	r9,r4,8213e14 <__subdf3+0x62c>
 8213c7c:	0085c83a 	sub	r2,zero,r2
 8213c80:	18c02034 	orhi	r3,r3,128
 8213c84:	01000e04 	movi	r4,56
 8213c88:	20807e16 	blt	r4,r2,8213e84 <__subdf3+0x69c>
 8213c8c:	010007c4 	movi	r4,31
 8213c90:	2080e716 	blt	r4,r2,8214030 <__subdf3+0x848>
 8213c94:	01000804 	movi	r4,32
 8213c98:	2089c83a 	sub	r4,r4,r2
 8213c9c:	1914983a 	sll	r10,r3,r4
 8213ca0:	8890d83a 	srl	r8,r17,r2
 8213ca4:	8908983a 	sll	r4,r17,r4
 8213ca8:	1884d83a 	srl	r2,r3,r2
 8213cac:	5222b03a 	or	r17,r10,r8
 8213cb0:	2006c03a 	cmpne	r3,r4,zero
 8213cb4:	88e2b03a 	or	r17,r17,r3
 8213cb8:	3463c83a 	sub	r17,r6,r17
 8213cbc:	2885c83a 	sub	r2,r5,r2
 8213cc0:	344d803a 	cmpltu	r6,r6,r17
 8213cc4:	1187c83a 	sub	r3,r2,r6
 8213cc8:	4821883a 	mov	r16,r9
 8213ccc:	3825883a 	mov	r18,r7
 8213cd0:	003f2306 	br	8213960 <__subdf3+0x178>
 8213cd4:	24d0b03a 	or	r8,r4,r19
 8213cd8:	40001b1e 	bne	r8,zero,8213d48 <__subdf3+0x560>
 8213cdc:	0005883a 	mov	r2,zero
 8213ce0:	0009883a 	mov	r4,zero
 8213ce4:	0021883a 	mov	r16,zero
 8213ce8:	003f4906 	br	8213a10 <__subdf3+0x228>
 8213cec:	010007c4 	movi	r4,31
 8213cf0:	20803a16 	blt	r4,r2,8213ddc <__subdf3+0x5f4>
 8213cf4:	01000804 	movi	r4,32
 8213cf8:	2089c83a 	sub	r4,r4,r2
 8213cfc:	2912983a 	sll	r9,r5,r4
 8213d00:	3090d83a 	srl	r8,r6,r2
 8213d04:	3108983a 	sll	r4,r6,r4
 8213d08:	2884d83a 	srl	r2,r5,r2
 8213d0c:	4a12b03a 	or	r9,r9,r8
 8213d10:	2008c03a 	cmpne	r4,r4,zero
 8213d14:	4912b03a 	or	r9,r9,r4
 8213d18:	003f4e06 	br	8213a54 <__subdf3+0x26c>
 8213d1c:	1c48b03a 	or	r4,r3,r17
 8213d20:	20003c26 	beq	r4,zero,8213e14 <__subdf3+0x62c>
 8213d24:	0084303a 	nor	r2,zero,r2
 8213d28:	1000381e 	bne	r2,zero,8213e0c <__subdf3+0x624>
 8213d2c:	3463c83a 	sub	r17,r6,r17
 8213d30:	28c5c83a 	sub	r2,r5,r3
 8213d34:	344d803a 	cmpltu	r6,r6,r17
 8213d38:	1187c83a 	sub	r3,r2,r6
 8213d3c:	4821883a 	mov	r16,r9
 8213d40:	3825883a 	mov	r18,r7
 8213d44:	003f0606 	br	8213960 <__subdf3+0x178>
 8213d48:	2023883a 	mov	r17,r4
 8213d4c:	003f0906 	br	8213974 <__subdf3+0x18c>
 8213d50:	0101ffc4 	movi	r4,2047
 8213d54:	813f3a1e 	bne	r16,r4,8213a40 <__subdf3+0x258>
 8213d58:	003ec406 	br	821386c <__subdf3+0x84>
 8213d5c:	0005883a 	mov	r2,zero
 8213d60:	003fb106 	br	8213c28 <__subdf3+0x440>
 8213d64:	0005883a 	mov	r2,zero
 8213d68:	003fbc06 	br	8213c5c <__subdf3+0x474>
 8213d6c:	1c44b03a 	or	r2,r3,r17
 8213d70:	80008e1e 	bne	r16,zero,8213fac <__subdf3+0x7c4>
 8213d74:	1000c826 	beq	r2,zero,8214098 <__subdf3+0x8b0>
 8213d78:	2984b03a 	or	r2,r5,r6
 8213d7c:	103ebb26 	beq	r2,zero,821386c <__subdf3+0x84>
 8213d80:	8989883a 	add	r4,r17,r6
 8213d84:	1945883a 	add	r2,r3,r5
 8213d88:	2447803a 	cmpltu	r3,r4,r17
 8213d8c:	1887883a 	add	r3,r3,r2
 8213d90:	1880202c 	andhi	r2,r3,128
 8213d94:	2023883a 	mov	r17,r4
 8213d98:	103f1626 	beq	r2,zero,82139f4 <__subdf3+0x20c>
 8213d9c:	00bfe034 	movhi	r2,65408
 8213da0:	10bfffc4 	addi	r2,r2,-1
 8213da4:	5021883a 	mov	r16,r10
 8213da8:	1886703a 	and	r3,r3,r2
 8213dac:	003eaf06 	br	821386c <__subdf3+0x84>
 8213db0:	3825883a 	mov	r18,r7
 8213db4:	003f0f06 	br	82139f4 <__subdf3+0x20c>
 8213db8:	1c44b03a 	or	r2,r3,r17
 8213dbc:	8000251e 	bne	r16,zero,8213e54 <__subdf3+0x66c>
 8213dc0:	1000661e 	bne	r2,zero,8213f5c <__subdf3+0x774>
 8213dc4:	2990b03a 	or	r8,r5,r6
 8213dc8:	40009626 	beq	r8,zero,8214024 <__subdf3+0x83c>
 8213dcc:	2807883a 	mov	r3,r5
 8213dd0:	3023883a 	mov	r17,r6
 8213dd4:	3825883a 	mov	r18,r7
 8213dd8:	003ea406 	br	821386c <__subdf3+0x84>
 8213ddc:	127ff804 	addi	r9,r2,-32
 8213de0:	01000804 	movi	r4,32
 8213de4:	2a52d83a 	srl	r9,r5,r9
 8213de8:	11008c26 	beq	r2,r4,821401c <__subdf3+0x834>
 8213dec:	01001004 	movi	r4,64
 8213df0:	2085c83a 	sub	r2,r4,r2
 8213df4:	2884983a 	sll	r2,r5,r2
 8213df8:	118cb03a 	or	r6,r2,r6
 8213dfc:	300cc03a 	cmpne	r6,r6,zero
 8213e00:	4992b03a 	or	r9,r9,r6
 8213e04:	0005883a 	mov	r2,zero
 8213e08:	003f1206 	br	8213a54 <__subdf3+0x26c>
 8213e0c:	0101ffc4 	movi	r4,2047
 8213e10:	493f9c1e 	bne	r9,r4,8213c84 <__subdf3+0x49c>
 8213e14:	2807883a 	mov	r3,r5
 8213e18:	3023883a 	mov	r17,r6
 8213e1c:	4821883a 	mov	r16,r9
 8213e20:	3825883a 	mov	r18,r7
 8213e24:	003e9106 	br	821386c <__subdf3+0x84>
 8213e28:	80001f1e 	bne	r16,zero,8213ea8 <__subdf3+0x6c0>
 8213e2c:	1c48b03a 	or	r4,r3,r17
 8213e30:	20005a26 	beq	r4,zero,8213f9c <__subdf3+0x7b4>
 8213e34:	0084303a 	nor	r2,zero,r2
 8213e38:	1000561e 	bne	r2,zero,8213f94 <__subdf3+0x7ac>
 8213e3c:	89a3883a 	add	r17,r17,r6
 8213e40:	1945883a 	add	r2,r3,r5
 8213e44:	898d803a 	cmpltu	r6,r17,r6
 8213e48:	3087883a 	add	r3,r6,r2
 8213e4c:	4821883a 	mov	r16,r9
 8213e50:	003f0506 	br	8213a68 <__subdf3+0x280>
 8213e54:	10002b1e 	bne	r2,zero,8213f04 <__subdf3+0x71c>
 8213e58:	2984b03a 	or	r2,r5,r6
 8213e5c:	10008026 	beq	r2,zero,8214060 <__subdf3+0x878>
 8213e60:	2807883a 	mov	r3,r5
 8213e64:	3023883a 	mov	r17,r6
 8213e68:	3825883a 	mov	r18,r7
 8213e6c:	0401ffc4 	movi	r16,2047
 8213e70:	003e7e06 	br	821386c <__subdf3+0x84>
 8213e74:	3809883a 	mov	r4,r7
 8213e78:	0011883a 	mov	r8,zero
 8213e7c:	0005883a 	mov	r2,zero
 8213e80:	003ee306 	br	8213a10 <__subdf3+0x228>
 8213e84:	1c62b03a 	or	r17,r3,r17
 8213e88:	8822c03a 	cmpne	r17,r17,zero
 8213e8c:	0005883a 	mov	r2,zero
 8213e90:	003f8906 	br	8213cb8 <__subdf3+0x4d0>
 8213e94:	3809883a 	mov	r4,r7
 8213e98:	4821883a 	mov	r16,r9
 8213e9c:	0011883a 	mov	r8,zero
 8213ea0:	0005883a 	mov	r2,zero
 8213ea4:	003eda06 	br	8213a10 <__subdf3+0x228>
 8213ea8:	0101ffc4 	movi	r4,2047
 8213eac:	49003b26 	beq	r9,r4,8213f9c <__subdf3+0x7b4>
 8213eb0:	0085c83a 	sub	r2,zero,r2
 8213eb4:	18c02034 	orhi	r3,r3,128
 8213eb8:	01000e04 	movi	r4,56
 8213ebc:	20806e16 	blt	r4,r2,8214078 <__subdf3+0x890>
 8213ec0:	010007c4 	movi	r4,31
 8213ec4:	20807716 	blt	r4,r2,82140a4 <__subdf3+0x8bc>
 8213ec8:	01000804 	movi	r4,32
 8213ecc:	2089c83a 	sub	r4,r4,r2
 8213ed0:	1914983a 	sll	r10,r3,r4
 8213ed4:	8890d83a 	srl	r8,r17,r2
 8213ed8:	8908983a 	sll	r4,r17,r4
 8213edc:	1884d83a 	srl	r2,r3,r2
 8213ee0:	5222b03a 	or	r17,r10,r8
 8213ee4:	2006c03a 	cmpne	r3,r4,zero
 8213ee8:	88e2b03a 	or	r17,r17,r3
 8213eec:	89a3883a 	add	r17,r17,r6
 8213ef0:	1145883a 	add	r2,r2,r5
 8213ef4:	898d803a 	cmpltu	r6,r17,r6
 8213ef8:	3087883a 	add	r3,r6,r2
 8213efc:	4821883a 	mov	r16,r9
 8213f00:	003ed906 	br	8213a68 <__subdf3+0x280>
 8213f04:	2984b03a 	or	r2,r5,r6
 8213f08:	10004226 	beq	r2,zero,8214014 <__subdf3+0x82c>
 8213f0c:	1808d0fa 	srli	r4,r3,3
 8213f10:	8822d0fa 	srli	r17,r17,3
 8213f14:	1806977a 	slli	r3,r3,29
 8213f18:	2080022c 	andhi	r2,r4,8
 8213f1c:	1c62b03a 	or	r17,r3,r17
 8213f20:	10000826 	beq	r2,zero,8213f44 <__subdf3+0x75c>
 8213f24:	2812d0fa 	srli	r9,r5,3
 8213f28:	4880022c 	andhi	r2,r9,8
 8213f2c:	1000051e 	bne	r2,zero,8213f44 <__subdf3+0x75c>
 8213f30:	300cd0fa 	srli	r6,r6,3
 8213f34:	2804977a 	slli	r2,r5,29
 8213f38:	4809883a 	mov	r4,r9
 8213f3c:	3825883a 	mov	r18,r7
 8213f40:	11a2b03a 	or	r17,r2,r6
 8213f44:	8806d77a 	srli	r3,r17,29
 8213f48:	200890fa 	slli	r4,r4,3
 8213f4c:	882290fa 	slli	r17,r17,3
 8213f50:	0401ffc4 	movi	r16,2047
 8213f54:	1906b03a 	or	r3,r3,r4
 8213f58:	003e4406 	br	821386c <__subdf3+0x84>
 8213f5c:	2984b03a 	or	r2,r5,r6
 8213f60:	103e4226 	beq	r2,zero,821386c <__subdf3+0x84>
 8213f64:	8989c83a 	sub	r4,r17,r6
 8213f68:	8911803a 	cmpltu	r8,r17,r4
 8213f6c:	1945c83a 	sub	r2,r3,r5
 8213f70:	1205c83a 	sub	r2,r2,r8
 8213f74:	1200202c 	andhi	r8,r2,128
 8213f78:	403e9a26 	beq	r8,zero,82139e4 <__subdf3+0x1fc>
 8213f7c:	3463c83a 	sub	r17,r6,r17
 8213f80:	28c5c83a 	sub	r2,r5,r3
 8213f84:	344d803a 	cmpltu	r6,r6,r17
 8213f88:	1187c83a 	sub	r3,r2,r6
 8213f8c:	3825883a 	mov	r18,r7
 8213f90:	003e3606 	br	821386c <__subdf3+0x84>
 8213f94:	0101ffc4 	movi	r4,2047
 8213f98:	493fc71e 	bne	r9,r4,8213eb8 <__subdf3+0x6d0>
 8213f9c:	2807883a 	mov	r3,r5
 8213fa0:	3023883a 	mov	r17,r6
 8213fa4:	4821883a 	mov	r16,r9
 8213fa8:	003e3006 	br	821386c <__subdf3+0x84>
 8213fac:	10003626 	beq	r2,zero,8214088 <__subdf3+0x8a0>
 8213fb0:	2984b03a 	or	r2,r5,r6
 8213fb4:	10001726 	beq	r2,zero,8214014 <__subdf3+0x82c>
 8213fb8:	1808d0fa 	srli	r4,r3,3
 8213fbc:	8822d0fa 	srli	r17,r17,3
 8213fc0:	1806977a 	slli	r3,r3,29
 8213fc4:	2080022c 	andhi	r2,r4,8
 8213fc8:	1c62b03a 	or	r17,r3,r17
 8213fcc:	10000726 	beq	r2,zero,8213fec <__subdf3+0x804>
 8213fd0:	2812d0fa 	srli	r9,r5,3
 8213fd4:	4880022c 	andhi	r2,r9,8
 8213fd8:	1000041e 	bne	r2,zero,8213fec <__subdf3+0x804>
 8213fdc:	300cd0fa 	srli	r6,r6,3
 8213fe0:	2804977a 	slli	r2,r5,29
 8213fe4:	4809883a 	mov	r4,r9
 8213fe8:	11a2b03a 	or	r17,r2,r6
 8213fec:	8806d77a 	srli	r3,r17,29
 8213ff0:	200890fa 	slli	r4,r4,3
 8213ff4:	882290fa 	slli	r17,r17,3
 8213ff8:	3825883a 	mov	r18,r7
 8213ffc:	1906b03a 	or	r3,r3,r4
 8214000:	0401ffc4 	movi	r16,2047
 8214004:	003e1906 	br	821386c <__subdf3+0x84>
 8214008:	000b883a 	mov	r5,zero
 821400c:	0005883a 	mov	r2,zero
 8214010:	003e2e06 	br	82138cc <__subdf3+0xe4>
 8214014:	0401ffc4 	movi	r16,2047
 8214018:	003e1406 	br	821386c <__subdf3+0x84>
 821401c:	0005883a 	mov	r2,zero
 8214020:	003f7506 	br	8213df8 <__subdf3+0x610>
 8214024:	0005883a 	mov	r2,zero
 8214028:	0009883a 	mov	r4,zero
 821402c:	003e7806 	br	8213a10 <__subdf3+0x228>
 8214030:	123ff804 	addi	r8,r2,-32
 8214034:	01000804 	movi	r4,32
 8214038:	1a10d83a 	srl	r8,r3,r8
 821403c:	11002526 	beq	r2,r4,82140d4 <__subdf3+0x8ec>
 8214040:	01001004 	movi	r4,64
 8214044:	2085c83a 	sub	r2,r4,r2
 8214048:	1884983a 	sll	r2,r3,r2
 821404c:	1444b03a 	or	r2,r2,r17
 8214050:	1004c03a 	cmpne	r2,r2,zero
 8214054:	40a2b03a 	or	r17,r8,r2
 8214058:	0005883a 	mov	r2,zero
 821405c:	003f1606 	br	8213cb8 <__subdf3+0x4d0>
 8214060:	02000434 	movhi	r8,16
 8214064:	0009883a 	mov	r4,zero
 8214068:	423fffc4 	addi	r8,r8,-1
 821406c:	00bfffc4 	movi	r2,-1
 8214070:	0401ffc4 	movi	r16,2047
 8214074:	003e6606 	br	8213a10 <__subdf3+0x228>
 8214078:	1c62b03a 	or	r17,r3,r17
 821407c:	8822c03a 	cmpne	r17,r17,zero
 8214080:	0005883a 	mov	r2,zero
 8214084:	003f9906 	br	8213eec <__subdf3+0x704>
 8214088:	2807883a 	mov	r3,r5
 821408c:	3023883a 	mov	r17,r6
 8214090:	0401ffc4 	movi	r16,2047
 8214094:	003df506 	br	821386c <__subdf3+0x84>
 8214098:	2807883a 	mov	r3,r5
 821409c:	3023883a 	mov	r17,r6
 82140a0:	003df206 	br	821386c <__subdf3+0x84>
 82140a4:	123ff804 	addi	r8,r2,-32
 82140a8:	01000804 	movi	r4,32
 82140ac:	1a10d83a 	srl	r8,r3,r8
 82140b0:	11000a26 	beq	r2,r4,82140dc <__subdf3+0x8f4>
 82140b4:	01001004 	movi	r4,64
 82140b8:	2085c83a 	sub	r2,r4,r2
 82140bc:	1884983a 	sll	r2,r3,r2
 82140c0:	1444b03a 	or	r2,r2,r17
 82140c4:	1004c03a 	cmpne	r2,r2,zero
 82140c8:	40a2b03a 	or	r17,r8,r2
 82140cc:	0005883a 	mov	r2,zero
 82140d0:	003f8606 	br	8213eec <__subdf3+0x704>
 82140d4:	0005883a 	mov	r2,zero
 82140d8:	003fdc06 	br	821404c <__subdf3+0x864>
 82140dc:	0005883a 	mov	r2,zero
 82140e0:	003ff706 	br	82140c0 <__subdf3+0x8d8>

082140e4 <__fixdfsi>:
 82140e4:	280cd53a 	srli	r6,r5,20
 82140e8:	00c00434 	movhi	r3,16
 82140ec:	18ffffc4 	addi	r3,r3,-1
 82140f0:	3181ffcc 	andi	r6,r6,2047
 82140f4:	01c0ff84 	movi	r7,1022
 82140f8:	28c6703a 	and	r3,r5,r3
 82140fc:	280ad7fa 	srli	r5,r5,31
 8214100:	3980120e 	bge	r7,r6,821414c <__fixdfsi+0x68>
 8214104:	00810744 	movi	r2,1053
 8214108:	11800c16 	blt	r2,r6,821413c <__fixdfsi+0x58>
 821410c:	00810cc4 	movi	r2,1075
 8214110:	1185c83a 	sub	r2,r2,r6
 8214114:	01c007c4 	movi	r7,31
 8214118:	18c00434 	orhi	r3,r3,16
 821411c:	38800d16 	blt	r7,r2,8214154 <__fixdfsi+0x70>
 8214120:	31befb44 	addi	r6,r6,-1043
 8214124:	2084d83a 	srl	r2,r4,r2
 8214128:	1986983a 	sll	r3,r3,r6
 821412c:	1884b03a 	or	r2,r3,r2
 8214130:	28000726 	beq	r5,zero,8214150 <__fixdfsi+0x6c>
 8214134:	0085c83a 	sub	r2,zero,r2
 8214138:	f800283a 	ret
 821413c:	00a00034 	movhi	r2,32768
 8214140:	10bfffc4 	addi	r2,r2,-1
 8214144:	2885883a 	add	r2,r5,r2
 8214148:	f800283a 	ret
 821414c:	0005883a 	mov	r2,zero
 8214150:	f800283a 	ret
 8214154:	008104c4 	movi	r2,1043
 8214158:	1185c83a 	sub	r2,r2,r6
 821415c:	1884d83a 	srl	r2,r3,r2
 8214160:	003ff306 	br	8214130 <__fixdfsi+0x4c>

08214164 <__floatsidf>:
 8214164:	defffd04 	addi	sp,sp,-12
 8214168:	dfc00215 	stw	ra,8(sp)
 821416c:	dc400115 	stw	r17,4(sp)
 8214170:	dc000015 	stw	r16,0(sp)
 8214174:	20002b26 	beq	r4,zero,8214224 <__floatsidf+0xc0>
 8214178:	2023883a 	mov	r17,r4
 821417c:	2020d7fa 	srli	r16,r4,31
 8214180:	20002d16 	blt	r4,zero,8214238 <__floatsidf+0xd4>
 8214184:	8809883a 	mov	r4,r17
 8214188:	82142e80 	call	82142e8 <__clzsi2>
 821418c:	01410784 	movi	r5,1054
 8214190:	288bc83a 	sub	r5,r5,r2
 8214194:	01010cc4 	movi	r4,1075
 8214198:	2149c83a 	sub	r4,r4,r5
 821419c:	00c007c4 	movi	r3,31
 82141a0:	1900160e 	bge	r3,r4,82141fc <__floatsidf+0x98>
 82141a4:	00c104c4 	movi	r3,1043
 82141a8:	1947c83a 	sub	r3,r3,r5
 82141ac:	88c6983a 	sll	r3,r17,r3
 82141b0:	00800434 	movhi	r2,16
 82141b4:	10bfffc4 	addi	r2,r2,-1
 82141b8:	1886703a 	and	r3,r3,r2
 82141bc:	2941ffcc 	andi	r5,r5,2047
 82141c0:	800d883a 	mov	r6,r16
 82141c4:	0005883a 	mov	r2,zero
 82141c8:	280a953a 	slli	r5,r5,20
 82141cc:	31803fcc 	andi	r6,r6,255
 82141d0:	01000434 	movhi	r4,16
 82141d4:	300c97fa 	slli	r6,r6,31
 82141d8:	213fffc4 	addi	r4,r4,-1
 82141dc:	1906703a 	and	r3,r3,r4
 82141e0:	1946b03a 	or	r3,r3,r5
 82141e4:	1986b03a 	or	r3,r3,r6
 82141e8:	dfc00217 	ldw	ra,8(sp)
 82141ec:	dc400117 	ldw	r17,4(sp)
 82141f0:	dc000017 	ldw	r16,0(sp)
 82141f4:	dec00304 	addi	sp,sp,12
 82141f8:	f800283a 	ret
 82141fc:	00c002c4 	movi	r3,11
 8214200:	1887c83a 	sub	r3,r3,r2
 8214204:	88c6d83a 	srl	r3,r17,r3
 8214208:	8904983a 	sll	r2,r17,r4
 821420c:	01000434 	movhi	r4,16
 8214210:	213fffc4 	addi	r4,r4,-1
 8214214:	2941ffcc 	andi	r5,r5,2047
 8214218:	1906703a 	and	r3,r3,r4
 821421c:	800d883a 	mov	r6,r16
 8214220:	003fe906 	br	82141c8 <__floatsidf+0x64>
 8214224:	000d883a 	mov	r6,zero
 8214228:	000b883a 	mov	r5,zero
 821422c:	0007883a 	mov	r3,zero
 8214230:	0005883a 	mov	r2,zero
 8214234:	003fe406 	br	82141c8 <__floatsidf+0x64>
 8214238:	0123c83a 	sub	r17,zero,r4
 821423c:	003fd106 	br	8214184 <__floatsidf+0x20>

08214240 <__floatunsidf>:
 8214240:	defffe04 	addi	sp,sp,-8
 8214244:	dc000015 	stw	r16,0(sp)
 8214248:	dfc00115 	stw	ra,4(sp)
 821424c:	2021883a 	mov	r16,r4
 8214250:	20002226 	beq	r4,zero,82142dc <__floatunsidf+0x9c>
 8214254:	82142e80 	call	82142e8 <__clzsi2>
 8214258:	01010784 	movi	r4,1054
 821425c:	2089c83a 	sub	r4,r4,r2
 8214260:	01810cc4 	movi	r6,1075
 8214264:	310dc83a 	sub	r6,r6,r4
 8214268:	00c007c4 	movi	r3,31
 821426c:	1980120e 	bge	r3,r6,82142b8 <__floatunsidf+0x78>
 8214270:	00c104c4 	movi	r3,1043
 8214274:	1907c83a 	sub	r3,r3,r4
 8214278:	80ca983a 	sll	r5,r16,r3
 821427c:	00800434 	movhi	r2,16
 8214280:	10bfffc4 	addi	r2,r2,-1
 8214284:	2101ffcc 	andi	r4,r4,2047
 8214288:	0021883a 	mov	r16,zero
 821428c:	288a703a 	and	r5,r5,r2
 8214290:	2008953a 	slli	r4,r4,20
 8214294:	00c00434 	movhi	r3,16
 8214298:	18ffffc4 	addi	r3,r3,-1
 821429c:	28c6703a 	and	r3,r5,r3
 82142a0:	8005883a 	mov	r2,r16
 82142a4:	1906b03a 	or	r3,r3,r4
 82142a8:	dfc00117 	ldw	ra,4(sp)
 82142ac:	dc000017 	ldw	r16,0(sp)
 82142b0:	dec00204 	addi	sp,sp,8
 82142b4:	f800283a 	ret
 82142b8:	00c002c4 	movi	r3,11
 82142bc:	188bc83a 	sub	r5,r3,r2
 82142c0:	814ad83a 	srl	r5,r16,r5
 82142c4:	00c00434 	movhi	r3,16
 82142c8:	18ffffc4 	addi	r3,r3,-1
 82142cc:	81a0983a 	sll	r16,r16,r6
 82142d0:	2101ffcc 	andi	r4,r4,2047
 82142d4:	28ca703a 	and	r5,r5,r3
 82142d8:	003fed06 	br	8214290 <__floatunsidf+0x50>
 82142dc:	0009883a 	mov	r4,zero
 82142e0:	000b883a 	mov	r5,zero
 82142e4:	003fea06 	br	8214290 <__floatunsidf+0x50>

082142e8 <__clzsi2>:
 82142e8:	00bfffd4 	movui	r2,65535
 82142ec:	11000536 	bltu	r2,r4,8214304 <__clzsi2+0x1c>
 82142f0:	00803fc4 	movi	r2,255
 82142f4:	11000f36 	bltu	r2,r4,8214334 <__clzsi2+0x4c>
 82142f8:	00800804 	movi	r2,32
 82142fc:	0007883a 	mov	r3,zero
 8214300:	00000506 	br	8214318 <__clzsi2+0x30>
 8214304:	00804034 	movhi	r2,256
 8214308:	10bfffc4 	addi	r2,r2,-1
 821430c:	11000c2e 	bgeu	r2,r4,8214340 <__clzsi2+0x58>
 8214310:	00800204 	movi	r2,8
 8214314:	00c00604 	movi	r3,24
 8214318:	20c8d83a 	srl	r4,r4,r3
 821431c:	00c20974 	movhi	r3,2085
 8214320:	18f74404 	addi	r3,r3,-8944
 8214324:	1909883a 	add	r4,r3,r4
 8214328:	20c00003 	ldbu	r3,0(r4)
 821432c:	10c5c83a 	sub	r2,r2,r3
 8214330:	f800283a 	ret
 8214334:	00800604 	movi	r2,24
 8214338:	00c00204 	movi	r3,8
 821433c:	003ff606 	br	8214318 <__clzsi2+0x30>
 8214340:	00800404 	movi	r2,16
 8214344:	1007883a 	mov	r3,r2
 8214348:	003ff306 	br	8214318 <__clzsi2+0x30>

0821434c <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 821434c:	defffc04 	addi	sp,sp,-16
 8214350:	dfc00315 	stw	ra,12(sp)
 8214354:	df000215 	stw	fp,8(sp)
 8214358:	df000204 	addi	fp,sp,8
 821435c:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 8214360:	d1600704 	addi	r5,gp,-32740
 8214364:	e13fff17 	ldw	r4,-4(fp)
 8214368:	823bdc00 	call	823bdc0 <alt_find_dev>
 821436c:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
 8214370:	e0bffe17 	ldw	r2,-8(fp)
 8214374:	10000926 	beq	r2,zero,821439c <alt_flash_open_dev+0x50>
 8214378:	e0bffe17 	ldw	r2,-8(fp)
 821437c:	10800317 	ldw	r2,12(r2)
 8214380:	10000626 	beq	r2,zero,821439c <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
 8214384:	e0bffe17 	ldw	r2,-8(fp)
 8214388:	10800317 	ldw	r2,12(r2)
 821438c:	e17fff17 	ldw	r5,-4(fp)
 8214390:	e13ffe17 	ldw	r4,-8(fp)
 8214394:	103ee83a 	callr	r2
 8214398:	00000106 	br	82143a0 <alt_flash_open_dev+0x54>
  }

  return dev;
 821439c:	e0bffe17 	ldw	r2,-8(fp)
}
 82143a0:	e037883a 	mov	sp,fp
 82143a4:	dfc00117 	ldw	ra,4(sp)
 82143a8:	df000017 	ldw	fp,0(sp)
 82143ac:	dec00204 	addi	sp,sp,8
 82143b0:	f800283a 	ret

082143b4 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 82143b4:	defffd04 	addi	sp,sp,-12
 82143b8:	dfc00215 	stw	ra,8(sp)
 82143bc:	df000115 	stw	fp,4(sp)
 82143c0:	df000104 	addi	fp,sp,4
 82143c4:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 82143c8:	e0bfff17 	ldw	r2,-4(fp)
 82143cc:	10000826 	beq	r2,zero,82143f0 <alt_flash_close_dev+0x3c>
 82143d0:	e0bfff17 	ldw	r2,-4(fp)
 82143d4:	10800417 	ldw	r2,16(r2)
 82143d8:	10000526 	beq	r2,zero,82143f0 <alt_flash_close_dev+0x3c>
  {
    fd->close(fd);
 82143dc:	e0bfff17 	ldw	r2,-4(fp)
 82143e0:	10800417 	ldw	r2,16(r2)
 82143e4:	e13fff17 	ldw	r4,-4(fp)
 82143e8:	103ee83a 	callr	r2
  }
  return;
 82143ec:	0001883a 	nop
 82143f0:	0001883a 	nop
}
 82143f4:	e037883a 	mov	sp,fp
 82143f8:	dfc00117 	ldw	ra,4(sp)
 82143fc:	df000017 	ldw	fp,0(sp)
 8214400:	dec00204 	addi	sp,sp,8
 8214404:	f800283a 	ret

08214408 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 8214408:	defffe04 	addi	sp,sp,-8
 821440c:	dfc00115 	stw	ra,4(sp)
 8214410:	df000015 	stw	fp,0(sp)
 8214414:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8214418:	d0a04717 	ldw	r2,-32484(gp)
 821441c:	10000326 	beq	r2,zero,821442c <alt_get_errno+0x24>
 8214420:	d0a04717 	ldw	r2,-32484(gp)
 8214424:	103ee83a 	callr	r2
 8214428:	00000106 	br	8214430 <alt_get_errno+0x28>
 821442c:	d0a06304 	addi	r2,gp,-32372
}
 8214430:	e037883a 	mov	sp,fp
 8214434:	dfc00117 	ldw	ra,4(sp)
 8214438:	df000017 	ldw	fp,0(sp)
 821443c:	dec00204 	addi	sp,sp,8
 8214440:	f800283a 	ret

08214444 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 8214444:	defffb04 	addi	sp,sp,-20
 8214448:	dfc00415 	stw	ra,16(sp)
 821444c:	df000315 	stw	fp,12(sp)
 8214450:	df000304 	addi	fp,sp,12
 8214454:	e13ffe15 	stw	r4,-8(fp)
 8214458:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 821445c:	e0bffe17 	ldw	r2,-8(fp)
 8214460:	10000616 	blt	r2,zero,821447c <fstat+0x38>
 8214464:	e0bffe17 	ldw	r2,-8(fp)
 8214468:	10c00324 	muli	r3,r2,12
 821446c:	00820974 	movhi	r2,2085
 8214470:	108edc04 	addi	r2,r2,15216
 8214474:	1885883a 	add	r2,r3,r2
 8214478:	00000106 	br	8214480 <fstat+0x3c>
 821447c:	0005883a 	mov	r2,zero
 8214480:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 8214484:	e0bffd17 	ldw	r2,-12(fp)
 8214488:	10001026 	beq	r2,zero,82144cc <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 821448c:	e0bffd17 	ldw	r2,-12(fp)
 8214490:	10800017 	ldw	r2,0(r2)
 8214494:	10800817 	ldw	r2,32(r2)
 8214498:	10000726 	beq	r2,zero,82144b8 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 821449c:	e0bffd17 	ldw	r2,-12(fp)
 82144a0:	10800017 	ldw	r2,0(r2)
 82144a4:	10800817 	ldw	r2,32(r2)
 82144a8:	e17fff17 	ldw	r5,-4(fp)
 82144ac:	e13ffd17 	ldw	r4,-12(fp)
 82144b0:	103ee83a 	callr	r2
 82144b4:	00000a06 	br	82144e0 <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 82144b8:	e0bfff17 	ldw	r2,-4(fp)
 82144bc:	00c80004 	movi	r3,8192
 82144c0:	10c00115 	stw	r3,4(r2)
      return 0;
 82144c4:	0005883a 	mov	r2,zero
 82144c8:	00000506 	br	82144e0 <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 82144cc:	82144080 	call	8214408 <alt_get_errno>
 82144d0:	1007883a 	mov	r3,r2
 82144d4:	00801444 	movi	r2,81
 82144d8:	18800015 	stw	r2,0(r3)
    return -1;
 82144dc:	00bfffc4 	movi	r2,-1
  }
}
 82144e0:	e037883a 	mov	sp,fp
 82144e4:	dfc00117 	ldw	ra,4(sp)
 82144e8:	df000017 	ldw	fp,0(sp)
 82144ec:	dec00204 	addi	sp,sp,8
 82144f0:	f800283a 	ret

082144f4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 82144f4:	defffe04 	addi	sp,sp,-8
 82144f8:	dfc00115 	stw	ra,4(sp)
 82144fc:	df000015 	stw	fp,0(sp)
 8214500:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8214504:	d0a04717 	ldw	r2,-32484(gp)
 8214508:	10000326 	beq	r2,zero,8214518 <alt_get_errno+0x24>
 821450c:	d0a04717 	ldw	r2,-32484(gp)
 8214510:	103ee83a 	callr	r2
 8214514:	00000106 	br	821451c <alt_get_errno+0x28>
 8214518:	d0a06304 	addi	r2,gp,-32372
}
 821451c:	e037883a 	mov	sp,fp
 8214520:	dfc00117 	ldw	ra,4(sp)
 8214524:	df000017 	ldw	fp,0(sp)
 8214528:	dec00204 	addi	sp,sp,8
 821452c:	f800283a 	ret

08214530 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 8214530:	deffed04 	addi	sp,sp,-76
 8214534:	dfc01215 	stw	ra,72(sp)
 8214538:	df001115 	stw	fp,68(sp)
 821453c:	df001104 	addi	fp,sp,68
 8214540:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 8214544:	e0bfff17 	ldw	r2,-4(fp)
 8214548:	10000616 	blt	r2,zero,8214564 <isatty+0x34>
 821454c:	e0bfff17 	ldw	r2,-4(fp)
 8214550:	10c00324 	muli	r3,r2,12
 8214554:	00820974 	movhi	r2,2085
 8214558:	108edc04 	addi	r2,r2,15216
 821455c:	1885883a 	add	r2,r3,r2
 8214560:	00000106 	br	8214568 <isatty+0x38>
 8214564:	0005883a 	mov	r2,zero
 8214568:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 821456c:	e0bfef17 	ldw	r2,-68(fp)
 8214570:	10000e26 	beq	r2,zero,82145ac <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 8214574:	e0bfef17 	ldw	r2,-68(fp)
 8214578:	10800017 	ldw	r2,0(r2)
 821457c:	10800817 	ldw	r2,32(r2)
 8214580:	1000021e 	bne	r2,zero,821458c <isatty+0x5c>
    {
      return 1;
 8214584:	00800044 	movi	r2,1
 8214588:	00000d06 	br	82145c0 <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 821458c:	e0bff004 	addi	r2,fp,-64
 8214590:	100b883a 	mov	r5,r2
 8214594:	e13fff17 	ldw	r4,-4(fp)
 8214598:	82144440 	call	8214444 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 821459c:	e0bff117 	ldw	r2,-60(fp)
 82145a0:	10880020 	cmpeqi	r2,r2,8192
 82145a4:	10803fcc 	andi	r2,r2,255
 82145a8:	00000506 	br	82145c0 <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 82145ac:	82144f40 	call	82144f4 <alt_get_errno>
 82145b0:	1007883a 	mov	r3,r2
 82145b4:	00801444 	movi	r2,81
 82145b8:	18800015 	stw	r2,0(r3)
    return 0;
 82145bc:	0005883a 	mov	r2,zero
  }
}
 82145c0:	e037883a 	mov	sp,fp
 82145c4:	dfc00117 	ldw	ra,4(sp)
 82145c8:	df000017 	ldw	fp,0(sp)
 82145cc:	dec00204 	addi	sp,sp,8
 82145d0:	f800283a 	ret

082145d4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 82145d4:	defffe04 	addi	sp,sp,-8
 82145d8:	dfc00115 	stw	ra,4(sp)
 82145dc:	df000015 	stw	fp,0(sp)
 82145e0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 82145e4:	d0a04717 	ldw	r2,-32484(gp)
 82145e8:	10000326 	beq	r2,zero,82145f8 <alt_get_errno+0x24>
 82145ec:	d0a04717 	ldw	r2,-32484(gp)
 82145f0:	103ee83a 	callr	r2
 82145f4:	00000106 	br	82145fc <alt_get_errno+0x28>
 82145f8:	d0a06304 	addi	r2,gp,-32372
}
 82145fc:	e037883a 	mov	sp,fp
 8214600:	dfc00117 	ldw	ra,4(sp)
 8214604:	df000017 	ldw	fp,0(sp)
 8214608:	dec00204 	addi	sp,sp,8
 821460c:	f800283a 	ret

08214610 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 8214610:	defff904 	addi	sp,sp,-28
 8214614:	dfc00615 	stw	ra,24(sp)
 8214618:	df000515 	stw	fp,20(sp)
 821461c:	df000504 	addi	fp,sp,20
 8214620:	e13ffd15 	stw	r4,-12(fp)
 8214624:	e17ffe15 	stw	r5,-8(fp)
 8214628:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 821462c:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 8214630:	e0bffd17 	ldw	r2,-12(fp)
 8214634:	10000616 	blt	r2,zero,8214650 <lseek+0x40>
 8214638:	e0bffd17 	ldw	r2,-12(fp)
 821463c:	10c00324 	muli	r3,r2,12
 8214640:	00820974 	movhi	r2,2085
 8214644:	108edc04 	addi	r2,r2,15216
 8214648:	1885883a 	add	r2,r3,r2
 821464c:	00000106 	br	8214654 <lseek+0x44>
 8214650:	0005883a 	mov	r2,zero
 8214654:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 8214658:	e0bffc17 	ldw	r2,-16(fp)
 821465c:	10001026 	beq	r2,zero,82146a0 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 8214660:	e0bffc17 	ldw	r2,-16(fp)
 8214664:	10800017 	ldw	r2,0(r2)
 8214668:	10800717 	ldw	r2,28(r2)
 821466c:	10000926 	beq	r2,zero,8214694 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 8214670:	e0bffc17 	ldw	r2,-16(fp)
 8214674:	10800017 	ldw	r2,0(r2)
 8214678:	10800717 	ldw	r2,28(r2)
 821467c:	e1bfff17 	ldw	r6,-4(fp)
 8214680:	e17ffe17 	ldw	r5,-8(fp)
 8214684:	e13ffc17 	ldw	r4,-16(fp)
 8214688:	103ee83a 	callr	r2
 821468c:	e0bffb15 	stw	r2,-20(fp)
 8214690:	00000506 	br	82146a8 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 8214694:	00bfde84 	movi	r2,-134
 8214698:	e0bffb15 	stw	r2,-20(fp)
 821469c:	00000206 	br	82146a8 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 82146a0:	00bfebc4 	movi	r2,-81
 82146a4:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 82146a8:	e0bffb17 	ldw	r2,-20(fp)
 82146ac:	1000070e 	bge	r2,zero,82146cc <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
 82146b0:	82145d40 	call	82145d4 <alt_get_errno>
 82146b4:	1007883a 	mov	r3,r2
 82146b8:	e0bffb17 	ldw	r2,-20(fp)
 82146bc:	0085c83a 	sub	r2,zero,r2
 82146c0:	18800015 	stw	r2,0(r3)
    rc = -1;
 82146c4:	00bfffc4 	movi	r2,-1
 82146c8:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 82146cc:	e0bffb17 	ldw	r2,-20(fp)
}
 82146d0:	e037883a 	mov	sp,fp
 82146d4:	dfc00117 	ldw	ra,4(sp)
 82146d8:	df000017 	ldw	fp,0(sp)
 82146dc:	dec00204 	addi	sp,sp,8
 82146e0:	f800283a 	ret

082146e4 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 82146e4:	defff904 	addi	sp,sp,-28
 82146e8:	dfc00615 	stw	ra,24(sp)
 82146ec:	df000515 	stw	fp,20(sp)
 82146f0:	df000504 	addi	fp,sp,20
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 82146f4:	0009883a 	mov	r4,zero
 82146f8:	821c35c0 	call	821c35c <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 82146fc:	82153d00 	call	82153d0 <OSInit>
 8214700:	01000044 	movi	r4,1
 8214704:	8219d200 	call	8219d20 <OSSemCreate>
 8214708:	d0a06815 	stw	r2,-32352(gp)
 821470c:	01000044 	movi	r4,1
 8214710:	8219d200 	call	8219d20 <OSSemCreate>
 8214714:	d0a06a15 	stw	r2,-32344(gp)
 8214718:	d0a0b604 	addi	r2,gp,-32040
 821471c:	e0bffc15 	stw	r2,-16(fp)
 8214720:	00800044 	movi	r2,1
 8214724:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 8214728:	e0bffd0b 	ldhu	r2,-12(fp)
 821472c:	1009883a 	mov	r4,r2
 8214730:	8219d200 	call	8219d20 <OSSemCreate>
 8214734:	1007883a 	mov	r3,r2
 8214738:	e0bffc17 	ldw	r2,-16(fp)
 821473c:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 8214740:	821c3940 	call	821c394 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 8214744:	01820974 	movhi	r6,2085
 8214748:	31b78404 	addi	r6,r6,-8688
 821474c:	01420974 	movhi	r5,2085
 8214750:	29778404 	addi	r5,r5,-8688
 8214754:	01020974 	movhi	r4,2085
 8214758:	21378404 	addi	r4,r4,-8688
 821475c:	823c1b40 	call	823c1b4 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 8214760:	823bd000 	call	823bd00 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 8214764:	01020934 	movhi	r4,2084
 8214768:	212f5804 	addi	r4,r4,-17056
 821476c:	824b47c0 	call	824b47c <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 8214770:	d0a06417 	ldw	r2,-32368(gp)
 8214774:	d0e06517 	ldw	r3,-32364(gp)
 8214778:	d1206617 	ldw	r4,-32360(gp)
 821477c:	200d883a 	mov	r6,r4
 8214780:	180b883a 	mov	r5,r3
 8214784:	1009883a 	mov	r4,r2
 8214788:	8200d180 	call	8200d18 <main>
 821478c:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
 8214790:	01000044 	movi	r4,1
 8214794:	82257740 	call	8225774 <close>
  exit (result);
 8214798:	e13ffb17 	ldw	r4,-20(fp)
 821479c:	824b4a80 	call	824b4a8 <exit>

082147a0 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 82147a0:	defff904 	addi	sp,sp,-28
 82147a4:	df000615 	stw	fp,24(sp)
 82147a8:	df000604 	addi	fp,sp,24
 82147ac:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82147b0:	0005303a 	rdctl	r2,status
 82147b4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82147b8:	e0fffe17 	ldw	r3,-8(fp)
 82147bc:	00bfff84 	movi	r2,-2
 82147c0:	1884703a 	and	r2,r3,r2
 82147c4:	1001703a 	wrctl	status,r2
  
  return context;
 82147c8:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 82147cc:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 82147d0:	d0a00917 	ldw	r2,-32732(gp)
 82147d4:	10c000c4 	addi	r3,r2,3
 82147d8:	00bfff04 	movi	r2,-4
 82147dc:	1884703a 	and	r2,r3,r2
 82147e0:	d0a00915 	stw	r2,-32732(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 82147e4:	d0e00917 	ldw	r3,-32732(gp)
 82147e8:	e0bfff17 	ldw	r2,-4(fp)
 82147ec:	1887883a 	add	r3,r3,r2
 82147f0:	00820e34 	movhi	r2,2104
 82147f4:	10800004 	addi	r2,r2,0
 82147f8:	10c0062e 	bgeu	r2,r3,8214814 <sbrk+0x74>
 82147fc:	e0bffb17 	ldw	r2,-20(fp)
 8214800:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214804:	e0bffa17 	ldw	r2,-24(fp)
 8214808:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 821480c:	00bfffc4 	movi	r2,-1
 8214810:	00000b06 	br	8214840 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 8214814:	d0a00917 	ldw	r2,-32732(gp)
 8214818:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 821481c:	d0e00917 	ldw	r3,-32732(gp)
 8214820:	e0bfff17 	ldw	r2,-4(fp)
 8214824:	1885883a 	add	r2,r3,r2
 8214828:	d0a00915 	stw	r2,-32732(gp)
 821482c:	e0bffb17 	ldw	r2,-20(fp)
 8214830:	e0bffc15 	stw	r2,-16(fp)
 8214834:	e0bffc17 	ldw	r2,-16(fp)
 8214838:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 821483c:	e0bffd17 	ldw	r2,-12(fp)
} 
 8214840:	e037883a 	mov	sp,fp
 8214844:	df000017 	ldw	fp,0(sp)
 8214848:	dec00104 	addi	sp,sp,4
 821484c:	f800283a 	ret

08214850 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
 8214850:	deffdf04 	addi	sp,sp,-132
 8214854:	dfc02015 	stw	ra,128(sp)
 8214858:	df001f15 	stw	fp,124(sp)
 821485c:	df001f04 	addi	fp,sp,124
 8214860:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 8214864:	e0bfe204 	addi	r2,fp,-120
 8214868:	100b883a 	mov	r5,r2
 821486c:	01003fc4 	movi	r4,255
 8214870:	821bca80 	call	821bca8 <OSTaskQuery>
 8214874:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 8214878:	e0bffe83 	ldbu	r2,-6(fp)
 821487c:	10803fcc 	andi	r2,r2,255
 8214880:	10001e1e 	bne	r2,zero,82148fc <__env_lock+0xac>
    return;

  id = tcb.OSTCBPrio;
 8214884:	e0bfee83 	ldbu	r2,-70(fp)
 8214888:	10803fcc 	andi	r2,r2,255
 821488c:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
 8214890:	d0a06817 	ldw	r2,-32352(gp)
 8214894:	e0fffd04 	addi	r3,fp,-12
 8214898:	180b883a 	mov	r5,r3
 821489c:	1009883a 	mov	r4,r2
 82148a0:	821a4c00 	call	821a4c0 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
 82148a4:	e0bffe43 	ldbu	r2,-7(fp)
 82148a8:	10803fcc 	andi	r2,r2,255
 82148ac:	10000726 	beq	r2,zero,82148cc <__env_lock+0x7c>
 82148b0:	d0a00a17 	ldw	r2,-32728(gp)
 82148b4:	e0ffe117 	ldw	r3,-124(fp)
 82148b8:	1880041e 	bne	r3,r2,82148cc <__env_lock+0x7c>
  {
    /* we do; just count the recursion */

    locks++;
 82148bc:	d0a06717 	ldw	r2,-32356(gp)
 82148c0:	10800044 	addi	r2,r2,1
 82148c4:	d0a06715 	stw	r2,-32356(gp)
 82148c8:	00000a06 	br	82148f4 <__env_lock+0xa4>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
 82148cc:	d0a06817 	ldw	r2,-32352(gp)
 82148d0:	e0fffe84 	addi	r3,fp,-6
 82148d4:	180d883a 	mov	r6,r3
 82148d8:	000b883a 	mov	r5,zero
 82148dc:	1009883a 	mov	r4,r2
 82148e0:	821a0380 	call	821a038 <OSSemPend>
    locks  = 1;
 82148e4:	00800044 	movi	r2,1
 82148e8:	d0a06715 	stw	r2,-32356(gp)
    lockid = id;
 82148ec:	e0bfe117 	ldw	r2,-124(fp)
 82148f0:	d0a00a15 	stw	r2,-32728(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
 82148f4:	0001883a 	nop
 82148f8:	00000106 	br	8214900 <__env_lock+0xb0>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
 82148fc:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 8214900:	e037883a 	mov	sp,fp
 8214904:	dfc00117 	ldw	ra,4(sp)
 8214908:	df000017 	ldw	fp,0(sp)
 821490c:	dec00204 	addi	sp,sp,8
 8214910:	f800283a 	ret

08214914 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
 8214914:	defffd04 	addi	sp,sp,-12
 8214918:	dfc00215 	stw	ra,8(sp)
 821491c:	df000115 	stw	fp,4(sp)
 8214920:	df000104 	addi	fp,sp,4
 8214924:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
 8214928:	d0a06717 	ldw	r2,-32356(gp)
 821492c:	10000b26 	beq	r2,zero,821495c <__env_unlock+0x48>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
 8214930:	d0a06717 	ldw	r2,-32356(gp)
 8214934:	10bfffc4 	addi	r2,r2,-1
 8214938:	d0a06715 	stw	r2,-32356(gp)
 821493c:	d0a06717 	ldw	r2,-32356(gp)
 8214940:	1000071e 	bne	r2,zero,8214960 <__env_unlock+0x4c>
  {
    lockid = -1;
 8214944:	00bfffc4 	movi	r2,-1
 8214948:	d0a00a15 	stw	r2,-32728(gp)
    OSSemPost( alt_envsem );
 821494c:	d0a06817 	ldw	r2,-32352(gp)
 8214950:	1009883a 	mov	r4,r2
 8214954:	821a3b00 	call	821a3b0 <OSSemPost>
 8214958:	00000106 	br	8214960 <__env_unlock+0x4c>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
 821495c:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 8214960:	e037883a 	mov	sp,fp
 8214964:	dfc00117 	ldw	ra,4(sp)
 8214968:	df000017 	ldw	fp,0(sp)
 821496c:	dec00204 	addi	sp,sp,8
 8214970:	f800283a 	ret

08214974 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
 8214974:	deffdb04 	addi	sp,sp,-148
 8214978:	dfc02415 	stw	ra,144(sp)
 821497c:	df002315 	stw	fp,140(sp)
 8214980:	df002304 	addi	fp,sp,140
 8214984:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214988:	e03fdd15 	stw	zero,-140(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
 821498c:	d0a06b43 	ldbu	r2,-32339(gp)
 8214990:	10803fcc 	andi	r2,r2,255
 8214994:	10800060 	cmpeqi	r2,r2,1
 8214998:	10003626 	beq	r2,zero,8214a74 <__malloc_lock+0x100>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 821499c:	e0bfe204 	addi	r2,fp,-120
 82149a0:	100b883a 	mov	r5,r2
 82149a4:	01003fc4 	movi	r4,255
 82149a8:	821bca80 	call	821bca8 <OSTaskQuery>
 82149ac:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 82149b0:	e0bffe83 	ldbu	r2,-6(fp)
 82149b4:	10803fcc 	andi	r2,r2,255
 82149b8:	1000301e 	bne	r2,zero,8214a7c <__malloc_lock+0x108>
    return;

  id = tcb.OSTCBPrio;
 82149bc:	e0bfee83 	ldbu	r2,-70(fp)
 82149c0:	10803fcc 	andi	r2,r2,255
 82149c4:	e0bfde15 	stw	r2,-136(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
 82149c8:	d0a06a17 	ldw	r2,-32344(gp)
 82149cc:	e0fffd04 	addi	r3,fp,-12
 82149d0:	180b883a 	mov	r5,r3
 82149d4:	1009883a 	mov	r4,r2
 82149d8:	821a4c00 	call	821a4c0 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82149dc:	0005303a 	rdctl	r2,status
 82149e0:	e0bfe115 	stw	r2,-124(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82149e4:	e0ffe117 	ldw	r3,-124(fp)
 82149e8:	00bfff84 	movi	r2,-2
 82149ec:	1884703a 	and	r2,r3,r2
 82149f0:	1001703a 	wrctl	status,r2
  
  return context;
 82149f4:	e0bfe117 	ldw	r2,-124(fp)
  
  OS_ENTER_CRITICAL();
 82149f8:	e0bfdd15 	stw	r2,-140(fp)

  if( !semdata.OSCnt && id == lockid ) 
 82149fc:	e0bffd0b 	ldhu	r2,-12(fp)
 8214a00:	10bfffcc 	andi	r2,r2,65535
 8214a04:	10000b1e 	bne	r2,zero,8214a34 <__malloc_lock+0xc0>
 8214a08:	d0a00b17 	ldw	r2,-32724(gp)
 8214a0c:	e0ffde17 	ldw	r3,-136(fp)
 8214a10:	1880081e 	bne	r3,r2,8214a34 <__malloc_lock+0xc0>
  {
    /* we do; just count the recursion */
    locks++;
 8214a14:	d0a06917 	ldw	r2,-32348(gp)
 8214a18:	10800044 	addi	r2,r2,1
 8214a1c:	d0a06915 	stw	r2,-32348(gp)
 8214a20:	e0bfdd17 	ldw	r2,-140(fp)
 8214a24:	e0bfdf15 	stw	r2,-132(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214a28:	e0bfdf17 	ldw	r2,-132(fp)
 8214a2c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
 8214a30:	00000e06 	br	8214a6c <__malloc_lock+0xf8>
 8214a34:	e0bfdd17 	ldw	r2,-140(fp)
 8214a38:	e0bfe015 	stw	r2,-128(fp)
 8214a3c:	e0bfe017 	ldw	r2,-128(fp)
 8214a40:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
 8214a44:	d0a06a17 	ldw	r2,-32344(gp)
 8214a48:	e0fffe84 	addi	r3,fp,-6
 8214a4c:	180d883a 	mov	r6,r3
 8214a50:	000b883a 	mov	r5,zero
 8214a54:	1009883a 	mov	r4,r2
 8214a58:	821a0380 	call	821a038 <OSSemPend>
    locks  = 1;
 8214a5c:	00800044 	movi	r2,1
 8214a60:	d0a06915 	stw	r2,-32348(gp)
    lockid = id;
 8214a64:	e0bfde17 	ldw	r2,-136(fp)
 8214a68:	d0a00b15 	stw	r2,-32724(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
 8214a6c:	0001883a 	nop
 8214a70:	00000306 	br	8214a80 <__malloc_lock+0x10c>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
 8214a74:	0001883a 	nop
 8214a78:	00000106 	br	8214a80 <__malloc_lock+0x10c>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
 8214a7c:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 8214a80:	e037883a 	mov	sp,fp
 8214a84:	dfc00117 	ldw	ra,4(sp)
 8214a88:	df000017 	ldw	fp,0(sp)
 8214a8c:	dec00204 	addi	sp,sp,8
 8214a90:	f800283a 	ret

08214a94 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 8214a94:	defff804 	addi	sp,sp,-32
 8214a98:	dfc00715 	stw	ra,28(sp)
 8214a9c:	df000615 	stw	fp,24(sp)
 8214aa0:	df000604 	addi	fp,sp,24
 8214aa4:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214aa8:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
 8214aac:	d0a06b43 	ldbu	r2,-32339(gp)
 8214ab0:	10803fcc 	andi	r2,r2,255
 8214ab4:	10800060 	cmpeqi	r2,r2,1
 8214ab8:	10002326 	beq	r2,zero,8214b48 <__malloc_unlock+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214abc:	0005303a 	rdctl	r2,status
 8214ac0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214ac4:	e0fffe17 	ldw	r3,-8(fp)
 8214ac8:	00bfff84 	movi	r2,-2
 8214acc:	1884703a 	and	r2,r3,r2
 8214ad0:	1001703a 	wrctl	status,r2
  
  return context;
 8214ad4:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
 8214ad8:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
 8214adc:	d0a06917 	ldw	r2,-32348(gp)
 8214ae0:	1000051e 	bne	r2,zero,8214af8 <__malloc_unlock+0x64>
 8214ae4:	e0bffa17 	ldw	r2,-24(fp)
 8214ae8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214aec:	e0bffb17 	ldw	r2,-20(fp)
 8214af0:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
 8214af4:	00001506 	br	8214b4c <__malloc_unlock+0xb8>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
 8214af8:	d0a06917 	ldw	r2,-32348(gp)
 8214afc:	10bfffc4 	addi	r2,r2,-1
 8214b00:	d0a06915 	stw	r2,-32348(gp)
 8214b04:	d0a06917 	ldw	r2,-32348(gp)
 8214b08:	10000a1e 	bne	r2,zero,8214b34 <__malloc_unlock+0xa0>
  {
    lockid = -1;
 8214b0c:	00bfffc4 	movi	r2,-1
 8214b10:	d0a00b15 	stw	r2,-32724(gp)
 8214b14:	e0bffa17 	ldw	r2,-24(fp)
 8214b18:	e0bffc15 	stw	r2,-16(fp)
 8214b1c:	e0bffc17 	ldw	r2,-16(fp)
 8214b20:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
 8214b24:	d0a06a17 	ldw	r2,-32344(gp)
 8214b28:	1009883a 	mov	r4,r2
 8214b2c:	821a3b00 	call	821a3b0 <OSSemPost>
 8214b30:	00000606 	br	8214b4c <__malloc_unlock+0xb8>
 8214b34:	e0bffa17 	ldw	r2,-24(fp)
 8214b38:	e0bffd15 	stw	r2,-12(fp)
 8214b3c:	e0bffd17 	ldw	r2,-12(fp)
 8214b40:	1001703a 	wrctl	status,r2
 8214b44:	00000106 	br	8214b4c <__malloc_unlock+0xb8>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
 8214b48:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 8214b4c:	e037883a 	mov	sp,fp
 8214b50:	dfc00117 	ldw	ra,4(sp)
 8214b54:	df000017 	ldw	fp,0(sp)
 8214b58:	dec00204 	addi	sp,sp,8
 8214b5c:	f800283a 	ret

08214b60 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 8214b60:	defff704 	addi	sp,sp,-36
 8214b64:	dfc00815 	stw	ra,32(sp)
 8214b68:	df000715 	stw	fp,28(sp)
 8214b6c:	df000704 	addi	fp,sp,28
 8214b70:	e13ffd15 	stw	r4,-12(fp)
 8214b74:	e17ffe15 	stw	r5,-8(fp)
 8214b78:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214b7c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8214b80:	e0bfff17 	ldw	r2,-4(fp)
 8214b84:	1000021e 	bne	r2,zero,8214b90 <OSEventNameGet+0x30>
        return (0);
 8214b88:	0005883a 	mov	r2,zero
 8214b8c:	00003706 	br	8214c6c <OSEventNameGet+0x10c>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 8214b90:	e0bffd17 	ldw	r2,-12(fp)
 8214b94:	1000051e 	bne	r2,zero,8214bac <OSEventNameGet+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
 8214b98:	e0bfff17 	ldw	r2,-4(fp)
 8214b9c:	00c00104 	movi	r3,4
 8214ba0:	10c00005 	stb	r3,0(r2)
        return (0);
 8214ba4:	0005883a 	mov	r2,zero
 8214ba8:	00003006 	br	8214c6c <OSEventNameGet+0x10c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8214bac:	e0bffe17 	ldw	r2,-8(fp)
 8214bb0:	1000051e 	bne	r2,zero,8214bc8 <OSEventNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 8214bb4:	e0bfff17 	ldw	r2,-4(fp)
 8214bb8:	00c00304 	movi	r3,12
 8214bbc:	10c00005 	stb	r3,0(r2)
        return (0);
 8214bc0:	0005883a 	mov	r2,zero
 8214bc4:	00002906 	br	8214c6c <OSEventNameGet+0x10c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8214bc8:	d0a07903 	ldbu	r2,-32284(gp)
 8214bcc:	10803fcc 	andi	r2,r2,255
 8214bd0:	10000526 	beq	r2,zero,8214be8 <OSEventNameGet+0x88>
        *perr  = OS_ERR_NAME_GET_ISR;
 8214bd4:	e0bfff17 	ldw	r2,-4(fp)
 8214bd8:	00c00444 	movi	r3,17
 8214bdc:	10c00005 	stb	r3,0(r2)
        return (0);
 8214be0:	0005883a 	mov	r2,zero
 8214be4:	00002106 	br	8214c6c <OSEventNameGet+0x10c>
    }
    switch (pevent->OSEventType) {
 8214be8:	e0bffd17 	ldw	r2,-12(fp)
 8214bec:	10800003 	ldbu	r2,0(r2)
 8214bf0:	10803fcc 	andi	r2,r2,255
 8214bf4:	10bfffc4 	addi	r2,r2,-1
 8214bf8:	10800128 	cmpgeui	r2,r2,4
 8214bfc:	10000526 	beq	r2,zero,8214c14 <OSEventNameGet+0xb4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 8214c00:	e0bfff17 	ldw	r2,-4(fp)
 8214c04:	00c00044 	movi	r3,1
 8214c08:	10c00005 	stb	r3,0(r2)
             return (0);
 8214c0c:	0005883a 	mov	r2,zero
 8214c10:	00001606 	br	8214c6c <OSEventNameGet+0x10c>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
 8214c14:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214c18:	0005303a 	rdctl	r2,status
 8214c1c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214c20:	e0fffb17 	ldw	r3,-20(fp)
 8214c24:	00bfff84 	movi	r2,-2
 8214c28:	1884703a 	and	r2,r3,r2
 8214c2c:	1001703a 	wrctl	status,r2
  
  return context;
 8214c30:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
 8214c34:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
 8214c38:	e0bffd17 	ldw	r2,-12(fp)
 8214c3c:	10800384 	addi	r2,r2,14
 8214c40:	100b883a 	mov	r5,r2
 8214c44:	e13ffe17 	ldw	r4,-8(fp)
 8214c48:	82165e40 	call	82165e4 <OS_StrCopy>
 8214c4c:	e0bffa05 	stb	r2,-24(fp)
 8214c50:	e0bff917 	ldw	r2,-28(fp)
 8214c54:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214c58:	e0bffc17 	ldw	r2,-16(fp)
 8214c5c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8214c60:	e0bfff17 	ldw	r2,-4(fp)
 8214c64:	10000005 	stb	zero,0(r2)
    return (len);
 8214c68:	e0bffa03 	ldbu	r2,-24(fp)
}
 8214c6c:	e037883a 	mov	sp,fp
 8214c70:	dfc00117 	ldw	ra,4(sp)
 8214c74:	df000017 	ldw	fp,0(sp)
 8214c78:	dec00204 	addi	sp,sp,8
 8214c7c:	f800283a 	ret

08214c80 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 8214c80:	defff604 	addi	sp,sp,-40
 8214c84:	dfc00915 	stw	ra,36(sp)
 8214c88:	df000815 	stw	fp,32(sp)
 8214c8c:	df000804 	addi	fp,sp,32
 8214c90:	e13ffd15 	stw	r4,-12(fp)
 8214c94:	e17ffe15 	stw	r5,-8(fp)
 8214c98:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8214c9c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8214ca0:	e0bfff17 	ldw	r2,-4(fp)
 8214ca4:	10004026 	beq	r2,zero,8214da8 <OSEventNameSet+0x128>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 8214ca8:	e0bffd17 	ldw	r2,-12(fp)
 8214cac:	1000041e 	bne	r2,zero,8214cc0 <OSEventNameSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
 8214cb0:	e0bfff17 	ldw	r2,-4(fp)
 8214cb4:	00c00104 	movi	r3,4
 8214cb8:	10c00005 	stb	r3,0(r2)
        return;
 8214cbc:	00003b06 	br	8214dac <OSEventNameSet+0x12c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8214cc0:	e0bffe17 	ldw	r2,-8(fp)
 8214cc4:	1000041e 	bne	r2,zero,8214cd8 <OSEventNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 8214cc8:	e0bfff17 	ldw	r2,-4(fp)
 8214ccc:	00c00304 	movi	r3,12
 8214cd0:	10c00005 	stb	r3,0(r2)
        return;
 8214cd4:	00003506 	br	8214dac <OSEventNameSet+0x12c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8214cd8:	d0a07903 	ldbu	r2,-32284(gp)
 8214cdc:	10803fcc 	andi	r2,r2,255
 8214ce0:	10000426 	beq	r2,zero,8214cf4 <OSEventNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 8214ce4:	e0bfff17 	ldw	r2,-4(fp)
 8214ce8:	00c00484 	movi	r3,18
 8214cec:	10c00005 	stb	r3,0(r2)
        return;
 8214cf0:	00002e06 	br	8214dac <OSEventNameSet+0x12c>
    }
    switch (pevent->OSEventType) {
 8214cf4:	e0bffd17 	ldw	r2,-12(fp)
 8214cf8:	10800003 	ldbu	r2,0(r2)
 8214cfc:	10803fcc 	andi	r2,r2,255
 8214d00:	10bfffc4 	addi	r2,r2,-1
 8214d04:	10800128 	cmpgeui	r2,r2,4
 8214d08:	10000426 	beq	r2,zero,8214d1c <OSEventNameSet+0x9c>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 8214d0c:	e0bfff17 	ldw	r2,-4(fp)
 8214d10:	00c00044 	movi	r3,1
 8214d14:	10c00005 	stb	r3,0(r2)
             return;
 8214d18:	00002406 	br	8214dac <OSEventNameSet+0x12c>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
 8214d1c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214d20:	0005303a 	rdctl	r2,status
 8214d24:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214d28:	e0fffc17 	ldw	r3,-16(fp)
 8214d2c:	00bfff84 	movi	r2,-2
 8214d30:	1884703a 	and	r2,r3,r2
 8214d34:	1001703a 	wrctl	status,r2
  
  return context;
 8214d38:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
 8214d3c:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
 8214d40:	e13ffe17 	ldw	r4,-8(fp)
 8214d44:	82166580 	call	8216658 <OS_StrLen>
 8214d48:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
 8214d4c:	e0bffa03 	ldbu	r2,-24(fp)
 8214d50:	10800830 	cmpltui	r2,r2,32
 8214d54:	1000081e 	bne	r2,zero,8214d78 <OSEventNameSet+0xf8>
 8214d58:	e0bff817 	ldw	r2,-32(fp)
 8214d5c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8214d60:	e0bff917 	ldw	r2,-28(fp)
 8214d64:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
 8214d68:	e0bfff17 	ldw	r2,-4(fp)
 8214d6c:	00c002c4 	movi	r3,11
 8214d70:	10c00005 	stb	r3,0(r2)
        return;
 8214d74:	00000d06 	br	8214dac <OSEventNameSet+0x12c>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
 8214d78:	e0bffd17 	ldw	r2,-12(fp)
 8214d7c:	10800384 	addi	r2,r2,14
 8214d80:	e17ffe17 	ldw	r5,-8(fp)
 8214d84:	1009883a 	mov	r4,r2
 8214d88:	82165e40 	call	82165e4 <OS_StrCopy>
 8214d8c:	e0bff817 	ldw	r2,-32(fp)
 8214d90:	e0bffb15 	stw	r2,-20(fp)
 8214d94:	e0bffb17 	ldw	r2,-20(fp)
 8214d98:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8214d9c:	e0bfff17 	ldw	r2,-4(fp)
 8214da0:	10000005 	stb	zero,0(r2)
 8214da4:	00000106 	br	8214dac <OSEventNameSet+0x12c>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 8214da8:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 8214dac:	e037883a 	mov	sp,fp
 8214db0:	dfc00117 	ldw	ra,4(sp)
 8214db4:	df000017 	ldw	fp,0(sp)
 8214db8:	dec00204 	addi	sp,sp,8
 8214dbc:	f800283a 	ret

08214dc0 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
 8214dc0:	deffed04 	addi	sp,sp,-76
 8214dc4:	dfc01215 	stw	ra,72(sp)
 8214dc8:	df001115 	stw	fp,68(sp)
 8214dcc:	df001104 	addi	fp,sp,68
 8214dd0:	e13ffc15 	stw	r4,-16(fp)
 8214dd4:	e17ffd15 	stw	r5,-12(fp)
 8214dd8:	e1bffe15 	stw	r6,-8(fp)
 8214ddc:	3805883a 	mov	r2,r7
 8214de0:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
 8214de4:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
 8214de8:	e0800217 	ldw	r2,8(fp)
 8214dec:	1000021e 	bne	r2,zero,8214df8 <OSEventPendMulti+0x38>
        return (0);
 8214df0:	0005883a 	mov	r2,zero
 8214df4:	00017106 	br	82153bc <OSEventPendMulti+0x5fc>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
 8214df8:	e0bffc17 	ldw	r2,-16(fp)
 8214dfc:	1000051e 	bne	r2,zero,8214e14 <OSEventPendMulti+0x54>
       *perr =  OS_ERR_PEVENT_NULL;
 8214e00:	e0800217 	ldw	r2,8(fp)
 8214e04:	00c00104 	movi	r3,4
 8214e08:	10c00005 	stb	r3,0(r2)
        return (0);
 8214e0c:	0005883a 	mov	r2,zero
 8214e10:	00016a06 	br	82153bc <OSEventPendMulti+0x5fc>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
 8214e14:	e0bffd17 	ldw	r2,-12(fp)
 8214e18:	1000051e 	bne	r2,zero,8214e30 <OSEventPendMulti+0x70>
       *perr =  OS_ERR_PEVENT_NULL;
 8214e1c:	e0800217 	ldw	r2,8(fp)
 8214e20:	00c00104 	movi	r3,4
 8214e24:	10c00005 	stb	r3,0(r2)
        return (0);
 8214e28:	0005883a 	mov	r2,zero
 8214e2c:	00016306 	br	82153bc <OSEventPendMulti+0x5fc>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
 8214e30:	e0bffe17 	ldw	r2,-8(fp)
 8214e34:	1000051e 	bne	r2,zero,8214e4c <OSEventPendMulti+0x8c>
       *perr =  OS_ERR_PEVENT_NULL;
 8214e38:	e0800217 	ldw	r2,8(fp)
 8214e3c:	00c00104 	movi	r3,4
 8214e40:	10c00005 	stb	r3,0(r2)
        return (0);
 8214e44:	0005883a 	mov	r2,zero
 8214e48:	00015c06 	br	82153bc <OSEventPendMulti+0x5fc>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
 8214e4c:	e0bffd17 	ldw	r2,-12(fp)
 8214e50:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
 8214e54:	e0bffc17 	ldw	r2,-16(fp)
 8214e58:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
 8214e5c:	e0bfef17 	ldw	r2,-68(fp)
 8214e60:	10800017 	ldw	r2,0(r2)
 8214e64:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
 8214e68:	00001906 	br	8214ed0 <OSEventPendMulti+0x110>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
 8214e6c:	e0bff017 	ldw	r2,-64(fp)
 8214e70:	10800003 	ldbu	r2,0(r2)
 8214e74:	10803fcc 	andi	r2,r2,255
 8214e78:	10c000a0 	cmpeqi	r3,r2,2
 8214e7c:	1800091e 	bne	r3,zero,8214ea4 <OSEventPendMulti+0xe4>
 8214e80:	10c000e0 	cmpeqi	r3,r2,3
 8214e84:	1800091e 	bne	r3,zero,8214eac <OSEventPendMulti+0xec>
 8214e88:	10800060 	cmpeqi	r2,r2,1
 8214e8c:	1000091e 	bne	r2,zero,8214eb4 <OSEventPendMulti+0xf4>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
 8214e90:	e0800217 	ldw	r2,8(fp)
 8214e94:	00c00044 	movi	r3,1
 8214e98:	10c00005 	stb	r3,0(r2)
                 return (0);
 8214e9c:	0005883a 	mov	r2,zero
 8214ea0:	00014606 	br	82153bc <OSEventPendMulti+0x5fc>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
 8214ea4:	0001883a 	nop
 8214ea8:	00000306 	br	8214eb8 <OSEventPendMulti+0xf8>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
 8214eac:	0001883a 	nop
 8214eb0:	00000106 	br	8214eb8 <OSEventPendMulti+0xf8>
#endif
#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 break;
 8214eb4:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
 8214eb8:	e0bfef17 	ldw	r2,-68(fp)
 8214ebc:	10800104 	addi	r2,r2,4
 8214ec0:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
 8214ec4:	e0bfef17 	ldw	r2,-68(fp)
 8214ec8:	10800017 	ldw	r2,0(r2)
 8214ecc:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
 8214ed0:	e0bff017 	ldw	r2,-64(fp)
 8214ed4:	103fe51e 	bne	r2,zero,8214e6c <OSEventPendMulti+0xac>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
 8214ed8:	d0a07903 	ldbu	r2,-32284(gp)
 8214edc:	10803fcc 	andi	r2,r2,255
 8214ee0:	10000526 	beq	r2,zero,8214ef8 <OSEventPendMulti+0x138>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
 8214ee4:	e0800217 	ldw	r2,8(fp)
 8214ee8:	00c00084 	movi	r3,2
 8214eec:	10c00005 	stb	r3,0(r2)
        return (0);
 8214ef0:	0005883a 	mov	r2,zero
 8214ef4:	00013106 	br	82153bc <OSEventPendMulti+0x5fc>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
 8214ef8:	d0a06b03 	ldbu	r2,-32340(gp)
 8214efc:	10803fcc 	andi	r2,r2,255
 8214f00:	10000526 	beq	r2,zero,8214f18 <OSEventPendMulti+0x158>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
 8214f04:	e0800217 	ldw	r2,8(fp)
 8214f08:	00c00344 	movi	r3,13
 8214f0c:	10c00005 	stb	r3,0(r2)
        return (0);
 8214f10:	0005883a 	mov	r2,zero
 8214f14:	00012906 	br	82153bc <OSEventPendMulti+0x5fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8214f18:	0005303a 	rdctl	r2,status
 8214f1c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8214f20:	e0fffb17 	ldw	r3,-20(fp)
 8214f24:	00bfff84 	movi	r2,-2
 8214f28:	1884703a 	and	r2,r3,r2
 8214f2c:	1001703a 	wrctl	status,r2
  
  return context;
 8214f30:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
 8214f34:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
 8214f38:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
 8214f3c:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
 8214f40:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
 8214f44:	e0bffc17 	ldw	r2,-16(fp)
 8214f48:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
 8214f4c:	e0bfef17 	ldw	r2,-68(fp)
 8214f50:	10800017 	ldw	r2,0(r2)
 8214f54:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 8214f58:	00008106 	br	8215160 <OSEventPendMulti+0x3a0>
        switch (pevent->OSEventType) {
 8214f5c:	e0bff017 	ldw	r2,-64(fp)
 8214f60:	10800003 	ldbu	r2,0(r2)
 8214f64:	10803fcc 	andi	r2,r2,255
 8214f68:	10c000a0 	cmpeqi	r3,r2,2
 8214f6c:	18003c1e 	bne	r3,zero,8215060 <OSEventPendMulti+0x2a0>
 8214f70:	10c000e0 	cmpeqi	r3,r2,3
 8214f74:	1800031e 	bne	r3,zero,8214f84 <OSEventPendMulti+0x1c4>
 8214f78:	10800060 	cmpeqi	r2,r2,1
 8214f7c:	10001e1e 	bne	r2,zero,8214ff8 <OSEventPendMulti+0x238>
 8214f80:	00006606 	br	821511c <OSEventPendMulti+0x35c>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
 8214f84:	e0bff017 	ldw	r2,-64(fp)
 8214f88:	1080020b 	ldhu	r2,8(r2)
 8214f8c:	10bfffcc 	andi	r2,r2,65535
 8214f90:	10001526 	beq	r2,zero,8214fe8 <OSEventPendMulti+0x228>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
 8214f94:	e0bff017 	ldw	r2,-64(fp)
 8214f98:	1080020b 	ldhu	r2,8(r2)
 8214f9c:	10bfffc4 	addi	r2,r2,-1
 8214fa0:	1007883a 	mov	r3,r2
 8214fa4:	e0bff017 	ldw	r2,-64(fp)
 8214fa8:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
 8214fac:	e0bffd17 	ldw	r2,-12(fp)
 8214fb0:	10c00104 	addi	r3,r2,4
 8214fb4:	e0fffd15 	stw	r3,-12(fp)
 8214fb8:	e0fff017 	ldw	r3,-64(fp)
 8214fbc:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
 8214fc0:	00800044 	movi	r2,1
 8214fc4:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
 8214fc8:	e0bffe17 	ldw	r2,-8(fp)
 8214fcc:	10c00104 	addi	r3,r2,4
 8214fd0:	e0fffe15 	stw	r3,-8(fp)
 8214fd4:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
 8214fd8:	e0bff18b 	ldhu	r2,-58(fp)
 8214fdc:	10800044 	addi	r2,r2,1
 8214fe0:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
 8214fe4:	00005806 	br	8215148 <OSEventPendMulti+0x388>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
 8214fe8:	e0bff203 	ldbu	r2,-56(fp)
 8214fec:	10800054 	ori	r2,r2,1
 8214ff0:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 8214ff4:	00005406 	br	8215148 <OSEventPendMulti+0x388>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
 8214ff8:	e0bff017 	ldw	r2,-64(fp)
 8214ffc:	10800117 	ldw	r2,4(r2)
 8215000:	10001326 	beq	r2,zero,8215050 <OSEventPendMulti+0x290>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
 8215004:	e0bffe17 	ldw	r2,-8(fp)
 8215008:	10c00104 	addi	r3,r2,4
 821500c:	e0fffe15 	stw	r3,-8(fp)
 8215010:	e0fff017 	ldw	r3,-64(fp)
 8215014:	18c00117 	ldw	r3,4(r3)
 8215018:	10c00015 	stw	r3,0(r2)
                     pevent->OSEventPtr  = (void *)0;
 821501c:	e0bff017 	ldw	r2,-64(fp)
 8215020:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
 8215024:	e0bffd17 	ldw	r2,-12(fp)
 8215028:	10c00104 	addi	r3,r2,4
 821502c:	e0fffd15 	stw	r3,-12(fp)
 8215030:	e0fff017 	ldw	r3,-64(fp)
 8215034:	10c00015 	stw	r3,0(r2)
                      events_rdy         =  OS_TRUE;
 8215038:	00800044 	movi	r2,1
 821503c:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
 8215040:	e0bff18b 	ldhu	r2,-58(fp)
 8215044:	10800044 	addi	r2,r2,1
 8215048:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
                 }
                 break;
 821504c:	00003e06 	br	8215148 <OSEventPendMulti+0x388>
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
                      events_rdy         =  OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
 8215050:	e0bff203 	ldbu	r2,-56(fp)
 8215054:	10800094 	ori	r2,r2,2
 8215058:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 821505c:	00003a06 	br	8215148 <OSEventPendMulti+0x388>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
 8215060:	e0bff017 	ldw	r2,-64(fp)
 8215064:	10800117 	ldw	r2,4(r2)
 8215068:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
 821506c:	e0bff517 	ldw	r2,-44(fp)
 8215070:	1080058b 	ldhu	r2,22(r2)
 8215074:	10bfffcc 	andi	r2,r2,65535
 8215078:	10002426 	beq	r2,zero,821510c <OSEventPendMulti+0x34c>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
 821507c:	e0bffe17 	ldw	r2,-8(fp)
 8215080:	10c00104 	addi	r3,r2,4
 8215084:	e0fffe15 	stw	r3,-8(fp)
 8215088:	e0fff517 	ldw	r3,-44(fp)
 821508c:	18c00417 	ldw	r3,16(r3)
 8215090:	19400104 	addi	r5,r3,4
 8215094:	e13ff517 	ldw	r4,-44(fp)
 8215098:	21400415 	stw	r5,16(r4)
 821509c:	18c00017 	ldw	r3,0(r3)
 82150a0:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
 82150a4:	e0bff517 	ldw	r2,-44(fp)
 82150a8:	10c00417 	ldw	r3,16(r2)
 82150ac:	e0bff517 	ldw	r2,-44(fp)
 82150b0:	10800217 	ldw	r2,8(r2)
 82150b4:	1880041e 	bne	r3,r2,82150c8 <OSEventPendMulti+0x308>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
 82150b8:	e0bff517 	ldw	r2,-44(fp)
 82150bc:	10c00117 	ldw	r3,4(r2)
 82150c0:	e0bff517 	ldw	r2,-44(fp)
 82150c4:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
 82150c8:	e0bff517 	ldw	r2,-44(fp)
 82150cc:	1080058b 	ldhu	r2,22(r2)
 82150d0:	10bfffc4 	addi	r2,r2,-1
 82150d4:	1007883a 	mov	r3,r2
 82150d8:	e0bff517 	ldw	r2,-44(fp)
 82150dc:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
 82150e0:	e0bffd17 	ldw	r2,-12(fp)
 82150e4:	10c00104 	addi	r3,r2,4
 82150e8:	e0fffd15 	stw	r3,-12(fp)
 82150ec:	e0fff017 	ldw	r3,-64(fp)
 82150f0:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
 82150f4:	00800044 	movi	r2,1
 82150f8:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
 82150fc:	e0bff18b 	ldhu	r2,-58(fp)
 8215100:	10800044 	addi	r2,r2,1
 8215104:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
 8215108:	00000f06 	br	8215148 <OSEventPendMulti+0x388>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
 821510c:	e0bff203 	ldbu	r2,-56(fp)
 8215110:	10800114 	ori	r2,r2,4
 8215114:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 8215118:	00000b06 	br	8215148 <OSEventPendMulti+0x388>
 821511c:	e0bff317 	ldw	r2,-52(fp)
 8215120:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215124:	e0bff417 	ldw	r2,-48(fp)
 8215128:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
 821512c:	e0bffd17 	ldw	r2,-12(fp)
 8215130:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
 8215134:	e0800217 	ldw	r2,8(fp)
 8215138:	00c00044 	movi	r3,1
 821513c:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
 8215140:	e0bff18b 	ldhu	r2,-58(fp)
 8215144:	00009d06 	br	82153bc <OSEventPendMulti+0x5fc>
        }
        pevents++;
 8215148:	e0bfef17 	ldw	r2,-68(fp)
 821514c:	10800104 	addi	r2,r2,4
 8215150:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
 8215154:	e0bfef17 	ldw	r2,-68(fp)
 8215158:	10800017 	ldw	r2,0(r2)
 821515c:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 8215160:	e0bff017 	ldw	r2,-64(fp)
 8215164:	103f7d1e 	bne	r2,zero,8214f5c <OSEventPendMulti+0x19c>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
 8215168:	e0bff103 	ldbu	r2,-60(fp)
 821516c:	10800058 	cmpnei	r2,r2,1
 8215170:	10000a1e 	bne	r2,zero,821519c <OSEventPendMulti+0x3dc>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
 8215174:	e0bffd17 	ldw	r2,-12(fp)
 8215178:	10000015 	stw	zero,0(r2)
 821517c:	e0bff317 	ldw	r2,-52(fp)
 8215180:	e0bff615 	stw	r2,-40(fp)
 8215184:	e0bff617 	ldw	r2,-40(fp)
 8215188:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
 821518c:	e0800217 	ldw	r2,8(fp)
 8215190:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
 8215194:	e0bff18b 	ldhu	r2,-58(fp)
 8215198:	00008806 	br	82153bc <OSEventPendMulti+0x5fc>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
 821519c:	d0a07a17 	ldw	r2,-32280(gp)
 82151a0:	d0e07a17 	ldw	r3,-32280(gp)
 82151a4:	19000c03 	ldbu	r4,48(r3)
 82151a8:	e0fff203 	ldbu	r3,-56(fp)
 82151ac:	20c6b03a 	or	r3,r4,r3
 82151b0:	1809883a 	mov	r4,r3
 82151b4:	00ffe004 	movi	r3,-128
 82151b8:	20c6b03a 	or	r3,r4,r3
 82151bc:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 82151c0:	d0a07a17 	ldw	r2,-32280(gp)
 82151c4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
 82151c8:	d0a07a17 	ldw	r2,-32280(gp)
 82151cc:	e0ffff0b 	ldhu	r3,-4(fp)
 82151d0:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
 82151d4:	e13ffc17 	ldw	r4,-16(fp)
 82151d8:	8215cfc0 	call	8215cfc <OS_EventTaskWaitMulti>
 82151dc:	e0bff317 	ldw	r2,-52(fp)
 82151e0:	e0bff915 	stw	r2,-28(fp)
 82151e4:	e0bff917 	ldw	r2,-28(fp)
 82151e8:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
 82151ec:	82164a00 	call	82164a0 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82151f0:	0005303a 	rdctl	r2,status
 82151f4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82151f8:	e0fff717 	ldw	r3,-36(fp)
 82151fc:	00bfff84 	movi	r2,-2
 8215200:	1884703a 	and	r2,r3,r2
 8215204:	1001703a 	wrctl	status,r2
  
  return context;
 8215208:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 821520c:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
 8215210:	d0a07a17 	ldw	r2,-32280(gp)
 8215214:	10800c43 	ldbu	r2,49(r2)
 8215218:	10803fcc 	andi	r2,r2,255
 821521c:	10000226 	beq	r2,zero,8215228 <OSEventPendMulti+0x468>
 8215220:	108000a0 	cmpeqi	r2,r2,2
 8215224:	10001826 	beq	r2,zero,8215288 <OSEventPendMulti+0x4c8>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
 8215228:	d0a07a17 	ldw	r2,-32280(gp)
 821522c:	10800717 	ldw	r2,28(r2)
 8215230:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
 8215234:	e0bff017 	ldw	r2,-64(fp)
 8215238:	10000b26 	beq	r2,zero,8215268 <OSEventPendMulti+0x4a8>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
 821523c:	e0bffd17 	ldw	r2,-12(fp)
 8215240:	10c00104 	addi	r3,r2,4
 8215244:	e0fffd15 	stw	r3,-12(fp)
 8215248:	e0fff017 	ldw	r3,-64(fp)
 821524c:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
 8215250:	e0bffd17 	ldw	r2,-12(fp)
 8215254:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
 8215258:	e0bff18b 	ldhu	r2,-58(fp)
 821525c:	10800044 	addi	r2,r2,1
 8215260:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
 8215264:	00000d06 	br	821529c <OSEventPendMulti+0x4dc>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
 8215268:	d0a07a17 	ldw	r2,-32280(gp)
 821526c:	00c00044 	movi	r3,1
 8215270:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 8215274:	d0a07a17 	ldw	r2,-32280(gp)
 8215278:	e17ffc17 	ldw	r5,-16(fp)
 821527c:	1009883a 	mov	r4,r2
 8215280:	8215f040 	call	8215f04 <OS_EventTaskRemoveMulti>
             }
			 break;
 8215284:	00000506 	br	821529c <OSEventPendMulti+0x4dc>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 8215288:	d0a07a17 	ldw	r2,-32280(gp)
 821528c:	e17ffc17 	ldw	r5,-16(fp)
 8215290:	1009883a 	mov	r4,r2
 8215294:	8215f040 	call	8215f04 <OS_EventTaskRemoveMulti>
             break;
 8215298:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
 821529c:	d0a07a17 	ldw	r2,-32280(gp)
 82152a0:	10800c43 	ldbu	r2,49(r2)
 82152a4:	10803fcc 	andi	r2,r2,255
 82152a8:	10000326 	beq	r2,zero,82152b8 <OSEventPendMulti+0x4f8>
 82152ac:	108000a0 	cmpeqi	r2,r2,2
 82152b0:	1000231e 	bne	r2,zero,8215340 <OSEventPendMulti+0x580>
 82152b4:	00002a06 	br	8215360 <OSEventPendMulti+0x5a0>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
 82152b8:	e0bff017 	ldw	r2,-64(fp)
 82152bc:	10800003 	ldbu	r2,0(r2)
 82152c0:	10803fcc 	andi	r2,r2,255
 82152c4:	0080100e 	bge	zero,r2,8215308 <OSEventPendMulti+0x548>
 82152c8:	10c000d0 	cmplti	r3,r2,3
 82152cc:	1800071e 	bne	r3,zero,82152ec <OSEventPendMulti+0x52c>
 82152d0:	108000e0 	cmpeqi	r2,r2,3
 82152d4:	10000c26 	beq	r2,zero,8215308 <OSEventPendMulti+0x548>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
 82152d8:	e0bffe17 	ldw	r2,-8(fp)
 82152dc:	10c00104 	addi	r3,r2,4
 82152e0:	e0fffe15 	stw	r3,-8(fp)
 82152e4:	10000015 	stw	zero,0(r2)
                      break;
 82152e8:	00001206 	br	8215334 <OSEventPendMulti+0x574>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
 82152ec:	e0bffe17 	ldw	r2,-8(fp)
 82152f0:	10c00104 	addi	r3,r2,4
 82152f4:	e0fffe15 	stw	r3,-8(fp)
 82152f8:	d0e07a17 	ldw	r3,-32280(gp)
 82152fc:	18c00917 	ldw	r3,36(r3)
 8215300:	10c00015 	stw	r3,0(r2)
                      break;
 8215304:	00000b06 	br	8215334 <OSEventPendMulti+0x574>
 8215308:	e0bff317 	ldw	r2,-52(fp)
 821530c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215310:	e0bff817 	ldw	r2,-32(fp)
 8215314:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
 8215318:	e0bffd17 	ldw	r2,-12(fp)
 821531c:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
 8215320:	e0800217 	ldw	r2,8(fp)
 8215324:	00c00044 	movi	r3,1
 8215328:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
 821532c:	e0bff18b 	ldhu	r2,-58(fp)
 8215330:	00002206 	br	82153bc <OSEventPendMulti+0x5fc>
             }
            *perr = OS_ERR_NONE;
 8215334:	e0800217 	ldw	r2,8(fp)
 8215338:	10000005 	stb	zero,0(r2)
             break;
 821533c:	00001006 	br	8215380 <OSEventPendMulti+0x5c0>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
 8215340:	e0bffe17 	ldw	r2,-8(fp)
 8215344:	10c00104 	addi	r3,r2,4
 8215348:	e0fffe15 	stw	r3,-8(fp)
 821534c:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
 8215350:	e0800217 	ldw	r2,8(fp)
 8215354:	00c00384 	movi	r3,14
 8215358:	10c00005 	stb	r3,0(r2)
             break;
 821535c:	00000806 	br	8215380 <OSEventPendMulti+0x5c0>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
 8215360:	e0bffe17 	ldw	r2,-8(fp)
 8215364:	10c00104 	addi	r3,r2,4
 8215368:	e0fffe15 	stw	r3,-8(fp)
 821536c:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
 8215370:	e0800217 	ldw	r2,8(fp)
 8215374:	00c00284 	movi	r3,10
 8215378:	10c00005 	stb	r3,0(r2)
             break;
 821537c:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
 8215380:	d0a07a17 	ldw	r2,-32280(gp)
 8215384:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
 8215388:	d0a07a17 	ldw	r2,-32280(gp)
 821538c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
 8215390:	d0a07a17 	ldw	r2,-32280(gp)
 8215394:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 8215398:	d0a07a17 	ldw	r2,-32280(gp)
 821539c:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
 82153a0:	d0a07a17 	ldw	r2,-32280(gp)
 82153a4:	10000915 	stw	zero,36(r2)
 82153a8:	e0bff317 	ldw	r2,-52(fp)
 82153ac:	e0bffa15 	stw	r2,-24(fp)
 82153b0:	e0bffa17 	ldw	r2,-24(fp)
 82153b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
 82153b8:	e0bff18b 	ldhu	r2,-58(fp)
}
 82153bc:	e037883a 	mov	sp,fp
 82153c0:	dfc00117 	ldw	ra,4(sp)
 82153c4:	df000017 	ldw	fp,0(sp)
 82153c8:	dec00204 	addi	sp,sp,8
 82153cc:	f800283a 	ret

082153d0 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
 82153d0:	defffe04 	addi	sp,sp,-8
 82153d4:	dfc00115 	stw	ra,4(sp)
 82153d8:	df000015 	stw	fp,0(sp)
 82153dc:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
 82153e0:	823ce000 	call	823ce00 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
 82153e4:	821614c0 	call	821614c <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
 82153e8:	82161940 	call	8216194 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
 82153ec:	82163000 	call	8216300 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
 82153f0:	821606c0 	call	821606c <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
 82153f4:	82181a00 	call	82181a0 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
 82153f8:	8218aa00 	call	8218aa0 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
 82153fc:	8219bc80 	call	8219bc8 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
 8215400:	82162000 	call	8216200 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
 8215404:	82162800 	call	8216280 <OS_InitTaskStat>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
 8215408:	823ce200 	call	823ce20 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
 821540c:	8216b740 	call	8216b74 <OSDebugInit>
#endif
}
 8215410:	0001883a 	nop
 8215414:	e037883a 	mov	sp,fp
 8215418:	dfc00117 	ldw	ra,4(sp)
 821541c:	df000017 	ldw	fp,0(sp)
 8215420:	dec00204 	addi	sp,sp,8
 8215424:	f800283a 	ret

08215428 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
 8215428:	deffff04 	addi	sp,sp,-4
 821542c:	df000015 	stw	fp,0(sp)
 8215430:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
 8215434:	d0a06b43 	ldbu	r2,-32339(gp)
 8215438:	10803fcc 	andi	r2,r2,255
 821543c:	10800058 	cmpnei	r2,r2,1
 8215440:	1000071e 	bne	r2,zero,8215460 <OSIntEnter+0x38>
        if (OSIntNesting < 255u) {
 8215444:	d0a07903 	ldbu	r2,-32284(gp)
 8215448:	10803fcc 	andi	r2,r2,255
 821544c:	10803fe0 	cmpeqi	r2,r2,255
 8215450:	1000031e 	bne	r2,zero,8215460 <OSIntEnter+0x38>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
 8215454:	d0a07903 	ldbu	r2,-32284(gp)
 8215458:	10800044 	addi	r2,r2,1
 821545c:	d0a07905 	stb	r2,-32284(gp)
        }
    }
}
 8215460:	0001883a 	nop
 8215464:	e037883a 	mov	sp,fp
 8215468:	df000017 	ldw	fp,0(sp)
 821546c:	dec00104 	addi	sp,sp,4
 8215470:	f800283a 	ret

08215474 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
 8215474:	defffb04 	addi	sp,sp,-20
 8215478:	dfc00415 	stw	ra,16(sp)
 821547c:	df000315 	stw	fp,12(sp)
 8215480:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8215484:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
 8215488:	d0a06b43 	ldbu	r2,-32339(gp)
 821548c:	10803fcc 	andi	r2,r2,255
 8215490:	10800058 	cmpnei	r2,r2,1
 8215494:	10002f1e 	bne	r2,zero,8215554 <OSIntExit+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215498:	0005303a 	rdctl	r2,status
 821549c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82154a0:	e0ffff17 	ldw	r3,-4(fp)
 82154a4:	00bfff84 	movi	r2,-2
 82154a8:	1884703a 	and	r2,r3,r2
 82154ac:	1001703a 	wrctl	status,r2
  
  return context;
 82154b0:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 82154b4:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
 82154b8:	d0a07903 	ldbu	r2,-32284(gp)
 82154bc:	10803fcc 	andi	r2,r2,255
 82154c0:	10000326 	beq	r2,zero,82154d0 <OSIntExit+0x5c>
            OSIntNesting--;
 82154c4:	d0a07903 	ldbu	r2,-32284(gp)
 82154c8:	10bfffc4 	addi	r2,r2,-1
 82154cc:	d0a07905 	stb	r2,-32284(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
 82154d0:	d0a07903 	ldbu	r2,-32284(gp)
 82154d4:	10803fcc 	andi	r2,r2,255
 82154d8:	10001a1e 	bne	r2,zero,8215544 <OSIntExit+0xd0>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
 82154dc:	d0a06b03 	ldbu	r2,-32340(gp)
 82154e0:	10803fcc 	andi	r2,r2,255
 82154e4:	1000171e 	bne	r2,zero,8215544 <OSIntExit+0xd0>
                OS_SchedNew();
 82154e8:	82165700 	call	8216570 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
 82154ec:	d0e06d03 	ldbu	r3,-32332(gp)
 82154f0:	d0a06d43 	ldbu	r2,-32331(gp)
 82154f4:	18c03fcc 	andi	r3,r3,255
 82154f8:	10803fcc 	andi	r2,r2,255
 82154fc:	18801126 	beq	r3,r2,8215544 <OSIntExit+0xd0>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
 8215500:	d0a06d03 	ldbu	r2,-32332(gp)
 8215504:	10c03fcc 	andi	r3,r2,255
 8215508:	008209b4 	movhi	r2,2086
 821550c:	10b6b204 	addi	r2,r2,-9528
 8215510:	18c7883a 	add	r3,r3,r3
 8215514:	18c7883a 	add	r3,r3,r3
 8215518:	10c5883a 	add	r2,r2,r3
 821551c:	10800017 	ldw	r2,0(r2)
 8215520:	d0a07515 	stw	r2,-32300(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
 8215524:	d0a07517 	ldw	r2,-32300(gp)
 8215528:	10c00e17 	ldw	r3,56(r2)
 821552c:	18c00044 	addi	r3,r3,1
 8215530:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
 8215534:	d0a07017 	ldw	r2,-32320(gp)
 8215538:	10800044 	addi	r2,r2,1
 821553c:	d0a07015 	stw	r2,-32320(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
 8215540:	823cb200 	call	823cb20 <OSCtxSw>
 8215544:	e0bffd17 	ldw	r2,-12(fp)
 8215548:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821554c:	e0bffe17 	ldw	r2,-8(fp)
 8215550:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 8215554:	0001883a 	nop
 8215558:	e037883a 	mov	sp,fp
 821555c:	dfc00117 	ldw	ra,4(sp)
 8215560:	df000017 	ldw	fp,0(sp)
 8215564:	dec00204 	addi	sp,sp,8
 8215568:	f800283a 	ret

0821556c <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
 821556c:	defffc04 	addi	sp,sp,-16
 8215570:	df000315 	stw	fp,12(sp)
 8215574:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8215578:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
 821557c:	d0a06b43 	ldbu	r2,-32339(gp)
 8215580:	10803fcc 	andi	r2,r2,255
 8215584:	10800058 	cmpnei	r2,r2,1
 8215588:	1000161e 	bne	r2,zero,82155e4 <OSSchedLock+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821558c:	0005303a 	rdctl	r2,status
 8215590:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215594:	e0ffff17 	ldw	r3,-4(fp)
 8215598:	00bfff84 	movi	r2,-2
 821559c:	1884703a 	and	r2,r3,r2
 82155a0:	1001703a 	wrctl	status,r2
  
  return context;
 82155a4:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 82155a8:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
 82155ac:	d0a07903 	ldbu	r2,-32284(gp)
 82155b0:	10803fcc 	andi	r2,r2,255
 82155b4:	1000071e 	bne	r2,zero,82155d4 <OSSchedLock+0x68>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
 82155b8:	d0a06b03 	ldbu	r2,-32340(gp)
 82155bc:	10803fcc 	andi	r2,r2,255
 82155c0:	10803fe0 	cmpeqi	r2,r2,255
 82155c4:	1000031e 	bne	r2,zero,82155d4 <OSSchedLock+0x68>
                OSLockNesting++;                 /* Increment lock nesting level                       */
 82155c8:	d0a06b03 	ldbu	r2,-32340(gp)
 82155cc:	10800044 	addi	r2,r2,1
 82155d0:	d0a06b05 	stb	r2,-32340(gp)
 82155d4:	e0bffd17 	ldw	r2,-12(fp)
 82155d8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82155dc:	e0bffe17 	ldw	r2,-8(fp)
 82155e0:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 82155e4:	0001883a 	nop
 82155e8:	e037883a 	mov	sp,fp
 82155ec:	df000017 	ldw	fp,0(sp)
 82155f0:	dec00104 	addi	sp,sp,4
 82155f4:	f800283a 	ret

082155f8 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
 82155f8:	defff804 	addi	sp,sp,-32
 82155fc:	dfc00715 	stw	ra,28(sp)
 8215600:	df000615 	stw	fp,24(sp)
 8215604:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8215608:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
 821560c:	d0a06b43 	ldbu	r2,-32339(gp)
 8215610:	10803fcc 	andi	r2,r2,255
 8215614:	10800058 	cmpnei	r2,r2,1
 8215618:	1000281e 	bne	r2,zero,82156bc <OSSchedUnlock+0xc4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821561c:	0005303a 	rdctl	r2,status
 8215620:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215624:	e0ffff17 	ldw	r3,-4(fp)
 8215628:	00bfff84 	movi	r2,-2
 821562c:	1884703a 	and	r2,r3,r2
 8215630:	1001703a 	wrctl	status,r2
  
  return context;
 8215634:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 8215638:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
 821563c:	d0a06b03 	ldbu	r2,-32340(gp)
 8215640:	10803fcc 	andi	r2,r2,255
 8215644:	10001926 	beq	r2,zero,82156ac <OSSchedUnlock+0xb4>
            OSLockNesting--;                               /* Decrement lock nesting level             */
 8215648:	d0a06b03 	ldbu	r2,-32340(gp)
 821564c:	10bfffc4 	addi	r2,r2,-1
 8215650:	d0a06b05 	stb	r2,-32340(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
 8215654:	d0a06b03 	ldbu	r2,-32340(gp)
 8215658:	10803fcc 	andi	r2,r2,255
 821565c:	10000e1e 	bne	r2,zero,8215698 <OSSchedUnlock+0xa0>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
 8215660:	d0a07903 	ldbu	r2,-32284(gp)
 8215664:	10803fcc 	andi	r2,r2,255
 8215668:	1000061e 	bne	r2,zero,8215684 <OSSchedUnlock+0x8c>
 821566c:	e0bffa17 	ldw	r2,-24(fp)
 8215670:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215674:	e0bffb17 	ldw	r2,-20(fp)
 8215678:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
 821567c:	82164a00 	call	82164a0 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
 8215680:	00000e06 	br	82156bc <OSSchedUnlock+0xc4>
 8215684:	e0bffa17 	ldw	r2,-24(fp)
 8215688:	e0bffc15 	stw	r2,-16(fp)
 821568c:	e0bffc17 	ldw	r2,-16(fp)
 8215690:	1001703a 	wrctl	status,r2
 8215694:	00000906 	br	82156bc <OSSchedUnlock+0xc4>
 8215698:	e0bffa17 	ldw	r2,-24(fp)
 821569c:	e0bffd15 	stw	r2,-12(fp)
 82156a0:	e0bffd17 	ldw	r2,-12(fp)
 82156a4:	1001703a 	wrctl	status,r2
 82156a8:	00000406 	br	82156bc <OSSchedUnlock+0xc4>
 82156ac:	e0bffa17 	ldw	r2,-24(fp)
 82156b0:	e0bffe15 	stw	r2,-8(fp)
 82156b4:	e0bffe17 	ldw	r2,-8(fp)
 82156b8:	1001703a 	wrctl	status,r2
 82156bc:	0001883a 	nop
 82156c0:	e037883a 	mov	sp,fp
 82156c4:	dfc00117 	ldw	ra,4(sp)
 82156c8:	df000017 	ldw	fp,0(sp)
 82156cc:	dec00204 	addi	sp,sp,8
 82156d0:	f800283a 	ret

082156d4 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
 82156d4:	defffe04 	addi	sp,sp,-8
 82156d8:	dfc00115 	stw	ra,4(sp)
 82156dc:	df000015 	stw	fp,0(sp)
 82156e0:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
 82156e4:	d0a06b43 	ldbu	r2,-32339(gp)
 82156e8:	10803fcc 	andi	r2,r2,255
 82156ec:	10000f1e 	bne	r2,zero,821572c <OSStart+0x58>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
 82156f0:	82165700 	call	8216570 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
 82156f4:	d0a06d03 	ldbu	r2,-32332(gp)
 82156f8:	d0a06d45 	stb	r2,-32331(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
 82156fc:	d0a06d03 	ldbu	r2,-32332(gp)
 8215700:	10c03fcc 	andi	r3,r2,255
 8215704:	008209b4 	movhi	r2,2086
 8215708:	10b6b204 	addi	r2,r2,-9528
 821570c:	18c7883a 	add	r3,r3,r3
 8215710:	18c7883a 	add	r3,r3,r3
 8215714:	10c5883a 	add	r2,r2,r3
 8215718:	10800017 	ldw	r2,0(r2)
 821571c:	d0a07515 	stw	r2,-32300(gp)
        OSTCBCur      = OSTCBHighRdy;
 8215720:	d0a07517 	ldw	r2,-32300(gp)
 8215724:	d0a07a15 	stw	r2,-32280(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
 8215728:	823cbac0 	call	823cbac <OSStartHighRdy>
    }
}
 821572c:	0001883a 	nop
 8215730:	e037883a 	mov	sp,fp
 8215734:	dfc00117 	ldw	ra,4(sp)
 8215738:	df000017 	ldw	fp,0(sp)
 821573c:	dec00204 	addi	sp,sp,8
 8215740:	f800283a 	ret

08215744 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
 8215744:	defff904 	addi	sp,sp,-28
 8215748:	dfc00615 	stw	ra,24(sp)
 821574c:	df000515 	stw	fp,20(sp)
 8215750:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8215754:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
 8215758:	01000084 	movi	r4,2
 821575c:	821be3c0 	call	821be3c <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8215760:	0005303a 	rdctl	r2,status
 8215764:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215768:	e0fffc17 	ldw	r3,-16(fp)
 821576c:	00bfff84 	movi	r2,-2
 8215770:	1884703a 	and	r2,r3,r2
 8215774:	1001703a 	wrctl	status,r2
  
  return context;
 8215778:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
 821577c:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
 8215780:	d0206c15 	stw	zero,-32336(gp)
 8215784:	e0bffb17 	ldw	r2,-20(fp)
 8215788:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821578c:	e0bffd17 	ldw	r2,-12(fp)
 8215790:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
 8215794:	01000284 	movi	r4,10
 8215798:	821be3c0 	call	821be3c <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821579c:	0005303a 	rdctl	r2,status
 82157a0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82157a4:	e0fffe17 	ldw	r3,-8(fp)
 82157a8:	00bfff84 	movi	r2,-2
 82157ac:	1884703a 	and	r2,r3,r2
 82157b0:	1001703a 	wrctl	status,r2
  
  return context;
 82157b4:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
 82157b8:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
 82157bc:	d0a06c17 	ldw	r2,-32336(gp)
 82157c0:	d0a07115 	stw	r2,-32316(gp)
    OSStatRdy    = OS_TRUE;
 82157c4:	00800044 	movi	r2,1
 82157c8:	d0a07d05 	stb	r2,-32268(gp)
 82157cc:	e0bffb17 	ldw	r2,-20(fp)
 82157d0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82157d4:	e0bfff17 	ldw	r2,-4(fp)
 82157d8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 82157dc:	0001883a 	nop
 82157e0:	e037883a 	mov	sp,fp
 82157e4:	dfc00117 	ldw	ra,4(sp)
 82157e8:	df000017 	ldw	fp,0(sp)
 82157ec:	dec00204 	addi	sp,sp,8
 82157f0:	f800283a 	ret

082157f4 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
 82157f4:	defff704 	addi	sp,sp,-36
 82157f8:	dfc00815 	stw	ra,32(sp)
 82157fc:	df000715 	stw	fp,28(sp)
 8215800:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 8215804:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
 8215808:	823cdd40 	call	823cdd4 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821580c:	0005303a 	rdctl	r2,status
 8215810:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8215814:	e0fffd17 	ldw	r3,-12(fp)
 8215818:	00bfff84 	movi	r2,-2
 821581c:	1884703a 	and	r2,r3,r2
 8215820:	1001703a 	wrctl	status,r2
  
  return context;
 8215824:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
 8215828:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
 821582c:	d0a07b17 	ldw	r2,-32276(gp)
 8215830:	10800044 	addi	r2,r2,1
 8215834:	d0a07b15 	stw	r2,-32276(gp)
 8215838:	e0bffb17 	ldw	r2,-20(fp)
 821583c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8215840:	e0bfff17 	ldw	r2,-4(fp)
 8215844:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
 8215848:	d0a06b43 	ldbu	r2,-32339(gp)
 821584c:	10803fcc 	andi	r2,r2,255
 8215850:	10800058 	cmpnei	r2,r2,1
 8215854:	10006a1e 	bne	r2,zero,8215a00 <OSTimeTick+0x20c>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
 8215858:	d0a06f03 	ldbu	r2,-32324(gp)
 821585c:	10803fcc 	andi	r2,r2,255
 8215860:	10c00060 	cmpeqi	r3,r2,1
 8215864:	1800061e 	bne	r3,zero,8215880 <OSTimeTick+0x8c>
 8215868:	10c000a0 	cmpeqi	r3,r2,2
 821586c:	1800061e 	bne	r3,zero,8215888 <OSTimeTick+0x94>
 8215870:	10000a1e 	bne	r2,zero,821589c <OSTimeTick+0xa8>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
 8215874:	00800044 	movi	r2,1
 8215878:	e0bffa05 	stb	r2,-24(fp)
                 break;
 821587c:	00000b06 	br	82158ac <OSTimeTick+0xb8>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
 8215880:	e03ffa05 	stb	zero,-24(fp)
                 break;
 8215884:	00000906 	br	82158ac <OSTimeTick+0xb8>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
 8215888:	00800044 	movi	r2,1
 821588c:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
 8215890:	00800044 	movi	r2,1
 8215894:	d0a06f05 	stb	r2,-32324(gp)
                 break;
 8215898:	00000406 	br	82158ac <OSTimeTick+0xb8>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
 821589c:	00800044 	movi	r2,1
 82158a0:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
 82158a4:	d0206f05 	stb	zero,-32324(gp)
                 break;
 82158a8:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
 82158ac:	e0bffa03 	ldbu	r2,-24(fp)
 82158b0:	10005226 	beq	r2,zero,82159fc <OSTimeTick+0x208>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
 82158b4:	d0a06e17 	ldw	r2,-32328(gp)
 82158b8:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 82158bc:	00004906 	br	82159e4 <OSTimeTick+0x1f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82158c0:	0005303a 	rdctl	r2,status
 82158c4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82158c8:	e0fffc17 	ldw	r3,-16(fp)
 82158cc:	00bfff84 	movi	r2,-2
 82158d0:	1884703a 	and	r2,r3,r2
 82158d4:	1001703a 	wrctl	status,r2
  
  return context;
 82158d8:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
 82158dc:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
 82158e0:	e0bff917 	ldw	r2,-28(fp)
 82158e4:	10800b8b 	ldhu	r2,46(r2)
 82158e8:	10bfffcc 	andi	r2,r2,65535
 82158ec:	10003626 	beq	r2,zero,82159c8 <OSTimeTick+0x1d4>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
 82158f0:	e0bff917 	ldw	r2,-28(fp)
 82158f4:	10800b8b 	ldhu	r2,46(r2)
 82158f8:	10bfffc4 	addi	r2,r2,-1
 82158fc:	1007883a 	mov	r3,r2
 8215900:	e0bff917 	ldw	r2,-28(fp)
 8215904:	10c00b8d 	sth	r3,46(r2)
 8215908:	e0bff917 	ldw	r2,-28(fp)
 821590c:	10800b8b 	ldhu	r2,46(r2)
 8215910:	10bfffcc 	andi	r2,r2,65535
 8215914:	10002c1e 	bne	r2,zero,82159c8 <OSTimeTick+0x1d4>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 8215918:	e0bff917 	ldw	r2,-28(fp)
 821591c:	10800c03 	ldbu	r2,48(r2)
 8215920:	10803fcc 	andi	r2,r2,255
 8215924:	10800dcc 	andi	r2,r2,55
 8215928:	10000b26 	beq	r2,zero,8215958 <OSTimeTick+0x164>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
 821592c:	e0bff917 	ldw	r2,-28(fp)
 8215930:	10c00c03 	ldbu	r3,48(r2)
 8215934:	00bff204 	movi	r2,-56
 8215938:	1884703a 	and	r2,r3,r2
 821593c:	1007883a 	mov	r3,r2
 8215940:	e0bff917 	ldw	r2,-28(fp)
 8215944:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
 8215948:	e0bff917 	ldw	r2,-28(fp)
 821594c:	00c00044 	movi	r3,1
 8215950:	10c00c45 	stb	r3,49(r2)
 8215954:	00000206 	br	8215960 <OSTimeTick+0x16c>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 8215958:	e0bff917 	ldw	r2,-28(fp)
 821595c:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
 8215960:	e0bff917 	ldw	r2,-28(fp)
 8215964:	10800c03 	ldbu	r2,48(r2)
 8215968:	10803fcc 	andi	r2,r2,255
 821596c:	1080020c 	andi	r2,r2,8
 8215970:	1000151e 	bne	r2,zero,82159c8 <OSTimeTick+0x1d4>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
 8215974:	e0bff917 	ldw	r2,-28(fp)
 8215978:	10c00d83 	ldbu	r3,54(r2)
 821597c:	d0a07703 	ldbu	r2,-32292(gp)
 8215980:	1884b03a 	or	r2,r3,r2
 8215984:	d0a07705 	stb	r2,-32292(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 8215988:	e0bff917 	ldw	r2,-28(fp)
 821598c:	10800d03 	ldbu	r2,52(r2)
 8215990:	10c03fcc 	andi	r3,r2,255
 8215994:	e0bff917 	ldw	r2,-28(fp)
 8215998:	10800d03 	ldbu	r2,52(r2)
 821599c:	11003fcc 	andi	r4,r2,255
 82159a0:	d0a07744 	addi	r2,gp,-32291
 82159a4:	2085883a 	add	r2,r4,r2
 82159a8:	11000003 	ldbu	r4,0(r2)
 82159ac:	e0bff917 	ldw	r2,-28(fp)
 82159b0:	10800d43 	ldbu	r2,53(r2)
 82159b4:	2084b03a 	or	r2,r4,r2
 82159b8:	1009883a 	mov	r4,r2
 82159bc:	d0a07744 	addi	r2,gp,-32291
 82159c0:	1885883a 	add	r2,r3,r2
 82159c4:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
 82159c8:	e0bff917 	ldw	r2,-28(fp)
 82159cc:	10800517 	ldw	r2,20(r2)
 82159d0:	e0bff915 	stw	r2,-28(fp)
 82159d4:	e0bffb17 	ldw	r2,-20(fp)
 82159d8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82159dc:	e0bffe17 	ldw	r2,-8(fp)
 82159e0:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 82159e4:	e0bff917 	ldw	r2,-28(fp)
 82159e8:	10800c83 	ldbu	r2,50(r2)
 82159ec:	10803fcc 	andi	r2,r2,255
 82159f0:	10800518 	cmpnei	r2,r2,20
 82159f4:	103fb21e 	bne	r2,zero,82158c0 <OSTimeTick+0xcc>
 82159f8:	00000106 	br	8215a00 <OSTimeTick+0x20c>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
 82159fc:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
 8215a00:	e037883a 	mov	sp,fp
 8215a04:	dfc00117 	ldw	ra,4(sp)
 8215a08:	df000017 	ldw	fp,0(sp)
 8215a0c:	dec00204 	addi	sp,sp,8
 8215a10:	f800283a 	ret

08215a14 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
 8215a14:	deffff04 	addi	sp,sp,-4
 8215a18:	df000015 	stw	fp,0(sp)
 8215a1c:	d839883a 	mov	fp,sp
    return (OS_VERSION);
 8215a20:	00804784 	movi	r2,286
}
 8215a24:	e037883a 	mov	sp,fp
 8215a28:	df000017 	ldw	fp,0(sp)
 8215a2c:	dec00104 	addi	sp,sp,4
 8215a30:	f800283a 	ret

08215a34 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
 8215a34:	deffff04 	addi	sp,sp,-4
 8215a38:	df000015 	stw	fp,0(sp)
 8215a3c:	d839883a 	mov	fp,sp
}
 8215a40:	0001883a 	nop
 8215a44:	e037883a 	mov	sp,fp
 8215a48:	df000017 	ldw	fp,0(sp)
 8215a4c:	dec00104 	addi	sp,sp,4
 8215a50:	f800283a 	ret

08215a54 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
 8215a54:	defff804 	addi	sp,sp,-32
 8215a58:	dfc00715 	stw	ra,28(sp)
 8215a5c:	df000615 	stw	fp,24(sp)
 8215a60:	df000604 	addi	fp,sp,24
 8215a64:	e13ffc15 	stw	r4,-16(fp)
 8215a68:	e17ffd15 	stw	r5,-12(fp)
 8215a6c:	3007883a 	mov	r3,r6
 8215a70:	3805883a 	mov	r2,r7
 8215a74:	e0fffe05 	stb	r3,-8(fp)
 8215a78:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
 8215a7c:	e0bffc17 	ldw	r2,-16(fp)
 8215a80:	10800283 	ldbu	r2,10(r2)
 8215a84:	10c03fcc 	andi	r3,r2,255
 8215a88:	00820974 	movhi	r2,2085
 8215a8c:	10b78904 	addi	r2,r2,-8668
 8215a90:	10c5883a 	add	r2,r2,r3
 8215a94:	10800003 	ldbu	r2,0(r2)
 8215a98:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
 8215a9c:	e0bffa03 	ldbu	r2,-24(fp)
 8215aa0:	e0fffc17 	ldw	r3,-16(fp)
 8215aa4:	1885883a 	add	r2,r3,r2
 8215aa8:	108002c4 	addi	r2,r2,11
 8215aac:	10800003 	ldbu	r2,0(r2)
 8215ab0:	10c03fcc 	andi	r3,r2,255
 8215ab4:	00820974 	movhi	r2,2085
 8215ab8:	10b78904 	addi	r2,r2,-8668
 8215abc:	10c5883a 	add	r2,r2,r3
 8215ac0:	10800003 	ldbu	r2,0(r2)
 8215ac4:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
 8215ac8:	e0bffa03 	ldbu	r2,-24(fp)
 8215acc:	100490fa 	slli	r2,r2,3
 8215ad0:	1007883a 	mov	r3,r2
 8215ad4:	e0bffa43 	ldbu	r2,-23(fp)
 8215ad8:	1885883a 	add	r2,r3,r2
 8215adc:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
 8215ae0:	e0fffa83 	ldbu	r3,-22(fp)
 8215ae4:	008209b4 	movhi	r2,2086
 8215ae8:	10b6b204 	addi	r2,r2,-9528
 8215aec:	18c7883a 	add	r3,r3,r3
 8215af0:	18c7883a 	add	r3,r3,r3
 8215af4:	10c5883a 	add	r2,r2,r3
 8215af8:	10800017 	ldw	r2,0(r2)
 8215afc:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
 8215b00:	e0bffb17 	ldw	r2,-20(fp)
 8215b04:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
 8215b08:	e0bffb17 	ldw	r2,-20(fp)
 8215b0c:	e0fffd17 	ldw	r3,-12(fp)
 8215b10:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
 8215b14:	e0bffb17 	ldw	r2,-20(fp)
 8215b18:	10800c03 	ldbu	r2,48(r2)
 8215b1c:	1007883a 	mov	r3,r2
 8215b20:	e0bffe03 	ldbu	r2,-8(fp)
 8215b24:	0084303a 	nor	r2,zero,r2
 8215b28:	1884703a 	and	r2,r3,r2
 8215b2c:	1007883a 	mov	r3,r2
 8215b30:	e0bffb17 	ldw	r2,-20(fp)
 8215b34:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
 8215b38:	e0bffb17 	ldw	r2,-20(fp)
 8215b3c:	e0ffff03 	ldbu	r3,-4(fp)
 8215b40:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
 8215b44:	e0bffb17 	ldw	r2,-20(fp)
 8215b48:	10800c03 	ldbu	r2,48(r2)
 8215b4c:	10803fcc 	andi	r2,r2,255
 8215b50:	1080020c 	andi	r2,r2,8
 8215b54:	1000111e 	bne	r2,zero,8215b9c <OS_EventTaskRdy+0x148>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
 8215b58:	e0bffb17 	ldw	r2,-20(fp)
 8215b5c:	10c00d83 	ldbu	r3,54(r2)
 8215b60:	d0a07703 	ldbu	r2,-32292(gp)
 8215b64:	1884b03a 	or	r2,r3,r2
 8215b68:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
 8215b6c:	e0fffa03 	ldbu	r3,-24(fp)
 8215b70:	e13ffa03 	ldbu	r4,-24(fp)
 8215b74:	d0a07744 	addi	r2,gp,-32291
 8215b78:	2085883a 	add	r2,r4,r2
 8215b7c:	11000003 	ldbu	r4,0(r2)
 8215b80:	e0bffb17 	ldw	r2,-20(fp)
 8215b84:	10800d43 	ldbu	r2,53(r2)
 8215b88:	2084b03a 	or	r2,r4,r2
 8215b8c:	1009883a 	mov	r4,r2
 8215b90:	d0a07744 	addi	r2,gp,-32291
 8215b94:	1885883a 	add	r2,r3,r2
 8215b98:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
 8215b9c:	e17ffc17 	ldw	r5,-16(fp)
 8215ba0:	e13ffb17 	ldw	r4,-20(fp)
 8215ba4:	8215e4c0 	call	8215e4c <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
 8215ba8:	e0bffb17 	ldw	r2,-20(fp)
 8215bac:	10800817 	ldw	r2,32(r2)
 8215bb0:	10000826 	beq	r2,zero,8215bd4 <OS_EventTaskRdy+0x180>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 8215bb4:	e0bffb17 	ldw	r2,-20(fp)
 8215bb8:	10800817 	ldw	r2,32(r2)
 8215bbc:	100b883a 	mov	r5,r2
 8215bc0:	e13ffb17 	ldw	r4,-20(fp)
 8215bc4:	8215f040 	call	8215f04 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
 8215bc8:	e0bffb17 	ldw	r2,-20(fp)
 8215bcc:	e0fffc17 	ldw	r3,-16(fp)
 8215bd0:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
 8215bd4:	e0bffa83 	ldbu	r2,-22(fp)
}
 8215bd8:	e037883a 	mov	sp,fp
 8215bdc:	dfc00117 	ldw	ra,4(sp)
 8215be0:	df000017 	ldw	fp,0(sp)
 8215be4:	dec00204 	addi	sp,sp,8
 8215be8:	f800283a 	ret

08215bec <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
 8215bec:	defffd04 	addi	sp,sp,-12
 8215bf0:	df000215 	stw	fp,8(sp)
 8215bf4:	df000204 	addi	fp,sp,8
 8215bf8:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
 8215bfc:	d0a07a17 	ldw	r2,-32280(gp)
 8215c00:	e0ffff17 	ldw	r3,-4(fp)
 8215c04:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
 8215c08:	d0a07a17 	ldw	r2,-32280(gp)
 8215c0c:	10800d03 	ldbu	r2,52(r2)
 8215c10:	10803fcc 	andi	r2,r2,255
 8215c14:	d0e07a17 	ldw	r3,-32280(gp)
 8215c18:	18c00d03 	ldbu	r3,52(r3)
 8215c1c:	18c03fcc 	andi	r3,r3,255
 8215c20:	e13fff17 	ldw	r4,-4(fp)
 8215c24:	20c7883a 	add	r3,r4,r3
 8215c28:	18c002c4 	addi	r3,r3,11
 8215c2c:	19000003 	ldbu	r4,0(r3)
 8215c30:	d0e07a17 	ldw	r3,-32280(gp)
 8215c34:	18c00d43 	ldbu	r3,53(r3)
 8215c38:	20c6b03a 	or	r3,r4,r3
 8215c3c:	1809883a 	mov	r4,r3
 8215c40:	e0ffff17 	ldw	r3,-4(fp)
 8215c44:	1885883a 	add	r2,r3,r2
 8215c48:	108002c4 	addi	r2,r2,11
 8215c4c:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 8215c50:	e0bfff17 	ldw	r2,-4(fp)
 8215c54:	10c00283 	ldbu	r3,10(r2)
 8215c58:	d0a07a17 	ldw	r2,-32280(gp)
 8215c5c:	10800d83 	ldbu	r2,54(r2)
 8215c60:	1884b03a 	or	r2,r3,r2
 8215c64:	1007883a 	mov	r3,r2
 8215c68:	e0bfff17 	ldw	r2,-4(fp)
 8215c6c:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 8215c70:	d0a07a17 	ldw	r2,-32280(gp)
 8215c74:	10800d03 	ldbu	r2,52(r2)
 8215c78:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 8215c7c:	e0fffe03 	ldbu	r3,-8(fp)
 8215c80:	e13ffe03 	ldbu	r4,-8(fp)
 8215c84:	d0a07744 	addi	r2,gp,-32291
 8215c88:	2085883a 	add	r2,r4,r2
 8215c8c:	10800003 	ldbu	r2,0(r2)
 8215c90:	1009883a 	mov	r4,r2
 8215c94:	d0a07a17 	ldw	r2,-32280(gp)
 8215c98:	10800d43 	ldbu	r2,53(r2)
 8215c9c:	0084303a 	nor	r2,zero,r2
 8215ca0:	2084703a 	and	r2,r4,r2
 8215ca4:	1009883a 	mov	r4,r2
 8215ca8:	d0a07744 	addi	r2,gp,-32291
 8215cac:	1885883a 	add	r2,r3,r2
 8215cb0:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 8215cb4:	e0fffe03 	ldbu	r3,-8(fp)
 8215cb8:	d0a07744 	addi	r2,gp,-32291
 8215cbc:	1885883a 	add	r2,r3,r2
 8215cc0:	10800003 	ldbu	r2,0(r2)
 8215cc4:	10803fcc 	andi	r2,r2,255
 8215cc8:	1000071e 	bne	r2,zero,8215ce8 <OS_EventTaskWait+0xfc>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 8215ccc:	d0a07a17 	ldw	r2,-32280(gp)
 8215cd0:	10800d83 	ldbu	r2,54(r2)
 8215cd4:	0084303a 	nor	r2,zero,r2
 8215cd8:	1007883a 	mov	r3,r2
 8215cdc:	d0a07703 	ldbu	r2,-32292(gp)
 8215ce0:	1884703a 	and	r2,r3,r2
 8215ce4:	d0a07705 	stb	r2,-32292(gp)
    }
}
 8215ce8:	0001883a 	nop
 8215cec:	e037883a 	mov	sp,fp
 8215cf0:	df000017 	ldw	fp,0(sp)
 8215cf4:	dec00104 	addi	sp,sp,4
 8215cf8:	f800283a 	ret

08215cfc <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
 8215cfc:	defffb04 	addi	sp,sp,-20
 8215d00:	df000415 	stw	fp,16(sp)
 8215d04:	df000404 	addi	fp,sp,16
 8215d08:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
 8215d0c:	d0a07a17 	ldw	r2,-32280(gp)
 8215d10:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
 8215d14:	d0a07a17 	ldw	r2,-32280(gp)
 8215d18:	e0ffff17 	ldw	r3,-4(fp)
 8215d1c:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
 8215d20:	e0bfff17 	ldw	r2,-4(fp)
 8215d24:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
 8215d28:	e0bffc17 	ldw	r2,-16(fp)
 8215d2c:	10800017 	ldw	r2,0(r2)
 8215d30:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 8215d34:	00002006 	br	8215db8 <OS_EventTaskWaitMulti+0xbc>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
 8215d38:	d0a07a17 	ldw	r2,-32280(gp)
 8215d3c:	10800d03 	ldbu	r2,52(r2)
 8215d40:	10803fcc 	andi	r2,r2,255
 8215d44:	d0e07a17 	ldw	r3,-32280(gp)
 8215d48:	18c00d03 	ldbu	r3,52(r3)
 8215d4c:	18c03fcc 	andi	r3,r3,255
 8215d50:	e13ffd17 	ldw	r4,-12(fp)
 8215d54:	20c7883a 	add	r3,r4,r3
 8215d58:	18c002c4 	addi	r3,r3,11
 8215d5c:	19000003 	ldbu	r4,0(r3)
 8215d60:	d0e07a17 	ldw	r3,-32280(gp)
 8215d64:	18c00d43 	ldbu	r3,53(r3)
 8215d68:	20c6b03a 	or	r3,r4,r3
 8215d6c:	1809883a 	mov	r4,r3
 8215d70:	e0fffd17 	ldw	r3,-12(fp)
 8215d74:	1885883a 	add	r2,r3,r2
 8215d78:	108002c4 	addi	r2,r2,11
 8215d7c:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 8215d80:	e0bffd17 	ldw	r2,-12(fp)
 8215d84:	10c00283 	ldbu	r3,10(r2)
 8215d88:	d0a07a17 	ldw	r2,-32280(gp)
 8215d8c:	10800d83 	ldbu	r2,54(r2)
 8215d90:	1884b03a 	or	r2,r3,r2
 8215d94:	1007883a 	mov	r3,r2
 8215d98:	e0bffd17 	ldw	r2,-12(fp)
 8215d9c:	10c00285 	stb	r3,10(r2)
        pevents++;
 8215da0:	e0bffc17 	ldw	r2,-16(fp)
 8215da4:	10800104 	addi	r2,r2,4
 8215da8:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
 8215dac:	e0bffc17 	ldw	r2,-16(fp)
 8215db0:	10800017 	ldw	r2,0(r2)
 8215db4:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 8215db8:	e0bffd17 	ldw	r2,-12(fp)
 8215dbc:	103fde1e 	bne	r2,zero,8215d38 <OS_EventTaskWaitMulti+0x3c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 8215dc0:	d0a07a17 	ldw	r2,-32280(gp)
 8215dc4:	10800d03 	ldbu	r2,52(r2)
 8215dc8:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 8215dcc:	e0fffe03 	ldbu	r3,-8(fp)
 8215dd0:	e13ffe03 	ldbu	r4,-8(fp)
 8215dd4:	d0a07744 	addi	r2,gp,-32291
 8215dd8:	2085883a 	add	r2,r4,r2
 8215ddc:	10800003 	ldbu	r2,0(r2)
 8215de0:	1009883a 	mov	r4,r2
 8215de4:	d0a07a17 	ldw	r2,-32280(gp)
 8215de8:	10800d43 	ldbu	r2,53(r2)
 8215dec:	0084303a 	nor	r2,zero,r2
 8215df0:	2084703a 	and	r2,r4,r2
 8215df4:	1009883a 	mov	r4,r2
 8215df8:	d0a07744 	addi	r2,gp,-32291
 8215dfc:	1885883a 	add	r2,r3,r2
 8215e00:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 8215e04:	e0fffe03 	ldbu	r3,-8(fp)
 8215e08:	d0a07744 	addi	r2,gp,-32291
 8215e0c:	1885883a 	add	r2,r3,r2
 8215e10:	10800003 	ldbu	r2,0(r2)
 8215e14:	10803fcc 	andi	r2,r2,255
 8215e18:	1000071e 	bne	r2,zero,8215e38 <OS_EventTaskWaitMulti+0x13c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 8215e1c:	d0a07a17 	ldw	r2,-32280(gp)
 8215e20:	10800d83 	ldbu	r2,54(r2)
 8215e24:	0084303a 	nor	r2,zero,r2
 8215e28:	1007883a 	mov	r3,r2
 8215e2c:	d0a07703 	ldbu	r2,-32292(gp)
 8215e30:	1884703a 	and	r2,r3,r2
 8215e34:	d0a07705 	stb	r2,-32292(gp)
    }
}
 8215e38:	0001883a 	nop
 8215e3c:	e037883a 	mov	sp,fp
 8215e40:	df000017 	ldw	fp,0(sp)
 8215e44:	dec00104 	addi	sp,sp,4
 8215e48:	f800283a 	ret

08215e4c <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
 8215e4c:	defffc04 	addi	sp,sp,-16
 8215e50:	df000315 	stw	fp,12(sp)
 8215e54:	df000304 	addi	fp,sp,12
 8215e58:	e13ffe15 	stw	r4,-8(fp)
 8215e5c:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
 8215e60:	e0bffe17 	ldw	r2,-8(fp)
 8215e64:	10800d03 	ldbu	r2,52(r2)
 8215e68:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
 8215e6c:	e0bffd03 	ldbu	r2,-12(fp)
 8215e70:	e0fffd03 	ldbu	r3,-12(fp)
 8215e74:	e13fff17 	ldw	r4,-4(fp)
 8215e78:	20c7883a 	add	r3,r4,r3
 8215e7c:	18c002c4 	addi	r3,r3,11
 8215e80:	18c00003 	ldbu	r3,0(r3)
 8215e84:	1809883a 	mov	r4,r3
 8215e88:	e0fffe17 	ldw	r3,-8(fp)
 8215e8c:	18c00d43 	ldbu	r3,53(r3)
 8215e90:	00c6303a 	nor	r3,zero,r3
 8215e94:	20c6703a 	and	r3,r4,r3
 8215e98:	1809883a 	mov	r4,r3
 8215e9c:	e0ffff17 	ldw	r3,-4(fp)
 8215ea0:	1885883a 	add	r2,r3,r2
 8215ea4:	108002c4 	addi	r2,r2,11
 8215ea8:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
 8215eac:	e0bffd03 	ldbu	r2,-12(fp)
 8215eb0:	e0ffff17 	ldw	r3,-4(fp)
 8215eb4:	1885883a 	add	r2,r3,r2
 8215eb8:	108002c4 	addi	r2,r2,11
 8215ebc:	10800003 	ldbu	r2,0(r2)
 8215ec0:	10803fcc 	andi	r2,r2,255
 8215ec4:	10000a1e 	bne	r2,zero,8215ef0 <OS_EventTaskRemove+0xa4>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
 8215ec8:	e0bfff17 	ldw	r2,-4(fp)
 8215ecc:	10800283 	ldbu	r2,10(r2)
 8215ed0:	1007883a 	mov	r3,r2
 8215ed4:	e0bffe17 	ldw	r2,-8(fp)
 8215ed8:	10800d83 	ldbu	r2,54(r2)
 8215edc:	0084303a 	nor	r2,zero,r2
 8215ee0:	1884703a 	and	r2,r3,r2
 8215ee4:	1007883a 	mov	r3,r2
 8215ee8:	e0bfff17 	ldw	r2,-4(fp)
 8215eec:	10c00285 	stb	r3,10(r2)
    }
}
 8215ef0:	0001883a 	nop
 8215ef4:	e037883a 	mov	sp,fp
 8215ef8:	df000017 	ldw	fp,0(sp)
 8215efc:	dec00104 	addi	sp,sp,4
 8215f00:	f800283a 	ret

08215f04 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
 8215f04:	defffa04 	addi	sp,sp,-24
 8215f08:	df000515 	stw	fp,20(sp)
 8215f0c:	df000504 	addi	fp,sp,20
 8215f10:	e13ffe15 	stw	r4,-8(fp)
 8215f14:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
 8215f18:	e0bffe17 	ldw	r2,-8(fp)
 8215f1c:	10800d03 	ldbu	r2,52(r2)
 8215f20:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
 8215f24:	e0bffe17 	ldw	r2,-8(fp)
 8215f28:	10800d83 	ldbu	r2,54(r2)
 8215f2c:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
 8215f30:	e0bffe17 	ldw	r2,-8(fp)
 8215f34:	10800d43 	ldbu	r2,53(r2)
 8215f38:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
 8215f3c:	e0bfff17 	ldw	r2,-4(fp)
 8215f40:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
 8215f44:	e0bffb17 	ldw	r2,-20(fp)
 8215f48:	10800017 	ldw	r2,0(r2)
 8215f4c:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 8215f50:	00002506 	br	8215fe8 <OS_EventTaskRemoveMulti+0xe4>
        pevent->OSEventTbl[y]  &= ~bitx;
 8215f54:	e0bffd03 	ldbu	r2,-12(fp)
 8215f58:	e0fffd03 	ldbu	r3,-12(fp)
 8215f5c:	e13ffc17 	ldw	r4,-16(fp)
 8215f60:	20c7883a 	add	r3,r4,r3
 8215f64:	18c002c4 	addi	r3,r3,11
 8215f68:	18c00003 	ldbu	r3,0(r3)
 8215f6c:	1809883a 	mov	r4,r3
 8215f70:	e0fffd83 	ldbu	r3,-10(fp)
 8215f74:	00c6303a 	nor	r3,zero,r3
 8215f78:	20c6703a 	and	r3,r4,r3
 8215f7c:	1809883a 	mov	r4,r3
 8215f80:	e0fffc17 	ldw	r3,-16(fp)
 8215f84:	1885883a 	add	r2,r3,r2
 8215f88:	108002c4 	addi	r2,r2,11
 8215f8c:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
 8215f90:	e0bffd03 	ldbu	r2,-12(fp)
 8215f94:	e0fffc17 	ldw	r3,-16(fp)
 8215f98:	1885883a 	add	r2,r3,r2
 8215f9c:	108002c4 	addi	r2,r2,11
 8215fa0:	10800003 	ldbu	r2,0(r2)
 8215fa4:	10803fcc 	andi	r2,r2,255
 8215fa8:	1000091e 	bne	r2,zero,8215fd0 <OS_EventTaskRemoveMulti+0xcc>
            pevent->OSEventGrp &= ~bity;
 8215fac:	e0bffc17 	ldw	r2,-16(fp)
 8215fb0:	10800283 	ldbu	r2,10(r2)
 8215fb4:	1007883a 	mov	r3,r2
 8215fb8:	e0bffd43 	ldbu	r2,-11(fp)
 8215fbc:	0084303a 	nor	r2,zero,r2
 8215fc0:	1884703a 	and	r2,r3,r2
 8215fc4:	1007883a 	mov	r3,r2
 8215fc8:	e0bffc17 	ldw	r2,-16(fp)
 8215fcc:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
 8215fd0:	e0bffb17 	ldw	r2,-20(fp)
 8215fd4:	10800104 	addi	r2,r2,4
 8215fd8:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
 8215fdc:	e0bffb17 	ldw	r2,-20(fp)
 8215fe0:	10800017 	ldw	r2,0(r2)
 8215fe4:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 8215fe8:	e0bffc17 	ldw	r2,-16(fp)
 8215fec:	103fd91e 	bne	r2,zero,8215f54 <OS_EventTaskRemoveMulti+0x50>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
 8215ff0:	0001883a 	nop
 8215ff4:	e037883a 	mov	sp,fp
 8215ff8:	df000017 	ldw	fp,0(sp)
 8215ffc:	dec00104 	addi	sp,sp,4
 8216000:	f800283a 	ret

08216004 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
 8216004:	defffc04 	addi	sp,sp,-16
 8216008:	df000315 	stw	fp,12(sp)
 821600c:	df000304 	addi	fp,sp,12
 8216010:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
 8216014:	e0bfff17 	ldw	r2,-4(fp)
 8216018:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
 821601c:	e0bfff17 	ldw	r2,-4(fp)
 8216020:	108002c4 	addi	r2,r2,11
 8216024:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8216028:	e03ffe05 	stb	zero,-8(fp)
 821602c:	00000706 	br	821604c <OS_EventWaitListInit+0x48>
        *ptbl++ = 0;
 8216030:	e0bffd17 	ldw	r2,-12(fp)
 8216034:	10c00044 	addi	r3,r2,1
 8216038:	e0fffd15 	stw	r3,-12(fp)
 821603c:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8216040:	e0bffe03 	ldbu	r2,-8(fp)
 8216044:	10800044 	addi	r2,r2,1
 8216048:	e0bffe05 	stb	r2,-8(fp)
 821604c:	e0bffe03 	ldbu	r2,-8(fp)
 8216050:	108000f0 	cmpltui	r2,r2,3
 8216054:	103ff61e 	bne	r2,zero,8216030 <OS_EventWaitListInit+0x2c>
        *ptbl++ = 0;
    }
}
 8216058:	0001883a 	nop
 821605c:	e037883a 	mov	sp,fp
 8216060:	df000017 	ldw	fp,0(sp)
 8216064:	dec00104 	addi	sp,sp,4
 8216068:	f800283a 	ret

0821606c <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
 821606c:	defffb04 	addi	sp,sp,-20
 8216070:	dfc00415 	stw	ra,16(sp)
 8216074:	df000315 	stw	fp,12(sp)
 8216078:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
 821607c:	0142d004 	movi	r5,2880
 8216080:	010209b4 	movhi	r4,2086
 8216084:	21329e04 	addi	r4,r4,-13704
 8216088:	82163e40 	call	82163e4 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
 821608c:	008209b4 	movhi	r2,2086
 8216090:	10b29e04 	addi	r2,r2,-13704
 8216094:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
 8216098:	008209b4 	movhi	r2,2086
 821609c:	10b2aa04 	addi	r2,r2,-13656
 82160a0:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 82160a4:	e03ffd0d 	sth	zero,-12(fp)
 82160a8:	00001306 	br	82160f8 <OS_InitEventList+0x8c>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
 82160ac:	e0bffe17 	ldw	r2,-8(fp)
 82160b0:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
 82160b4:	e0bffe17 	ldw	r2,-8(fp)
 82160b8:	e0ffff17 	ldw	r3,-4(fp)
 82160bc:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
 82160c0:	e0bffe17 	ldw	r2,-8(fp)
 82160c4:	00c00fc4 	movi	r3,63
 82160c8:	10c00385 	stb	r3,14(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
 82160cc:	e0bffe17 	ldw	r2,-8(fp)
 82160d0:	100003c5 	stb	zero,15(r2)
#endif
        pevent1++;
 82160d4:	e0bffe17 	ldw	r2,-8(fp)
 82160d8:	10800c04 	addi	r2,r2,48
 82160dc:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
 82160e0:	e0bfff17 	ldw	r2,-4(fp)
 82160e4:	10800c04 	addi	r2,r2,48
 82160e8:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 82160ec:	e0bffd0b 	ldhu	r2,-12(fp)
 82160f0:	10800044 	addi	r2,r2,1
 82160f4:	e0bffd0d 	sth	r2,-12(fp)
 82160f8:	e0bffd0b 	ldhu	r2,-12(fp)
 82160fc:	10800ef0 	cmpltui	r2,r2,59
 8216100:	103fea1e 	bne	r2,zero,82160ac <OS_InitEventList+0x40>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
 8216104:	e0bffe17 	ldw	r2,-8(fp)
 8216108:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
 821610c:	e0bffe17 	ldw	r2,-8(fp)
 8216110:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
 8216114:	e0bffe17 	ldw	r2,-8(fp)
 8216118:	00c00fc4 	movi	r3,63
 821611c:	10c00385 	stb	r3,14(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
 8216120:	e0bffe17 	ldw	r2,-8(fp)
 8216124:	100003c5 	stb	zero,15(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
 8216128:	008209b4 	movhi	r2,2086
 821612c:	10b29e04 	addi	r2,r2,-13704
 8216130:	d0a07815 	stw	r2,-32288(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
 8216134:	0001883a 	nop
 8216138:	e037883a 	mov	sp,fp
 821613c:	dfc00117 	ldw	ra,4(sp)
 8216140:	df000017 	ldw	fp,0(sp)
 8216144:	dec00204 	addi	sp,sp,8
 8216148:	f800283a 	ret

0821614c <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
 821614c:	deffff04 	addi	sp,sp,-4
 8216150:	df000015 	stw	fp,0(sp)
 8216154:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
 8216158:	d0207b15 	stw	zero,-32276(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
 821615c:	d0207905 	stb	zero,-32284(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
 8216160:	d0206b05 	stb	zero,-32340(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
 8216164:	d0207345 	stb	zero,-32307(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
 8216168:	d0206b45 	stb	zero,-32339(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
 821616c:	d0207015 	stw	zero,-32320(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
 8216170:	d0206c15 	stw	zero,-32336(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
 8216174:	d0207e15 	stw	zero,-32264(gp)
    OSIdleCtrMax  = 0L;
 8216178:	d0207115 	stw	zero,-32316(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
 821617c:	d0207d05 	stb	zero,-32268(gp)
#endif
}
 8216180:	0001883a 	nop
 8216184:	e037883a 	mov	sp,fp
 8216188:	df000017 	ldw	fp,0(sp)
 821618c:	dec00104 	addi	sp,sp,4
 8216190:	f800283a 	ret

08216194 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
 8216194:	defffd04 	addi	sp,sp,-12
 8216198:	df000215 	stw	fp,8(sp)
 821619c:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
 82161a0:	d0207705 	stb	zero,-32292(gp)
    prdytbl       = &OSRdyTbl[0];
 82161a4:	d0a07744 	addi	r2,gp,-32291
 82161a8:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 82161ac:	e03ffe05 	stb	zero,-8(fp)
 82161b0:	00000706 	br	82161d0 <OS_InitRdyList+0x3c>
        *prdytbl++ = 0;
 82161b4:	e0bfff17 	ldw	r2,-4(fp)
 82161b8:	10c00044 	addi	r3,r2,1
 82161bc:	e0ffff15 	stw	r3,-4(fp)
 82161c0:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 82161c4:	e0bffe03 	ldbu	r2,-8(fp)
 82161c8:	10800044 	addi	r2,r2,1
 82161cc:	e0bffe05 	stb	r2,-8(fp)
 82161d0:	e0bffe03 	ldbu	r2,-8(fp)
 82161d4:	108000f0 	cmpltui	r2,r2,3
 82161d8:	103ff61e 	bne	r2,zero,82161b4 <OS_InitRdyList+0x20>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
 82161dc:	d0206d45 	stb	zero,-32331(gp)
    OSPrioHighRdy = 0;
 82161e0:	d0206d05 	stb	zero,-32332(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
 82161e4:	d0207515 	stw	zero,-32300(gp)
    OSTCBCur      = (OS_TCB *)0;
 82161e8:	d0207a15 	stw	zero,-32280(gp)
}
 82161ec:	0001883a 	nop
 82161f0:	e037883a 	mov	sp,fp
 82161f4:	df000017 	ldw	fp,0(sp)
 82161f8:	dec00104 	addi	sp,sp,4
 82161fc:	f800283a 	ret

08216200 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
 8216200:	defff804 	addi	sp,sp,-32
 8216204:	dfc00715 	stw	ra,28(sp)
 8216208:	df000615 	stw	fp,24(sp)
 821620c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
 8216210:	008000c4 	movi	r2,3
 8216214:	d8800415 	stw	r2,16(sp)
 8216218:	d8000315 	stw	zero,12(sp)
 821621c:	00808004 	movi	r2,512
 8216220:	d8800215 	stw	r2,8(sp)
 8216224:	008209b4 	movhi	r2,2086
 8216228:	10b09e04 	addi	r2,r2,-15752
 821622c:	d8800115 	stw	r2,4(sp)
 8216230:	00bfffd4 	movui	r2,65535
 8216234:	d8800015 	stw	r2,0(sp)
 8216238:	01c00504 	movi	r7,20
 821623c:	018209b4 	movhi	r6,2086
 8216240:	31b29d04 	addi	r6,r6,-13708
 8216244:	000b883a 	mov	r5,zero
 8216248:	01020874 	movhi	r4,2081
 821624c:	2119ab04 	addi	r4,r4,26284
 8216250:	821ad6c0 	call	821ad6c <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
 8216254:	e1bfff04 	addi	r6,fp,-4
 8216258:	01420974 	movhi	r5,2085
 821625c:	2977c904 	addi	r5,r5,-8412
 8216260:	01000504 	movi	r4,20
 8216264:	821b57c0 	call	821b57c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
 8216268:	0001883a 	nop
 821626c:	e037883a 	mov	sp,fp
 8216270:	dfc00117 	ldw	ra,4(sp)
 8216274:	df000017 	ldw	fp,0(sp)
 8216278:	dec00204 	addi	sp,sp,8
 821627c:	f800283a 	ret

08216280 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
 8216280:	defff804 	addi	sp,sp,-32
 8216284:	dfc00715 	stw	ra,28(sp)
 8216288:	df000615 	stw	fp,24(sp)
 821628c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
 8216290:	008000c4 	movi	r2,3
 8216294:	d8800415 	stw	r2,16(sp)
 8216298:	d8000315 	stw	zero,12(sp)
 821629c:	00808004 	movi	r2,512
 82162a0:	d8800215 	stw	r2,8(sp)
 82162a4:	008209b4 	movhi	r2,2086
 82162a8:	10ae2604 	addi	r2,r2,-18280
 82162ac:	d8800115 	stw	r2,4(sp)
 82162b0:	00bfff94 	movui	r2,65534
 82162b4:	d8800015 	stw	r2,0(sp)
 82162b8:	01c004c4 	movi	r7,19
 82162bc:	018209b4 	movhi	r6,2086
 82162c0:	31b02504 	addi	r6,r6,-16236
 82162c4:	000b883a 	mov	r5,zero
 82162c8:	01020874 	movhi	r4,2081
 82162cc:	2119c204 	addi	r4,r4,26376
 82162d0:	821ad6c0 	call	821ad6c <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
 82162d4:	e1bfff04 	addi	r6,fp,-4
 82162d8:	01420974 	movhi	r5,2085
 82162dc:	2977cd04 	addi	r5,r5,-8396
 82162e0:	010004c4 	movi	r4,19
 82162e4:	821b57c0 	call	821b57c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
 82162e8:	0001883a 	nop
 82162ec:	e037883a 	mov	sp,fp
 82162f0:	dfc00117 	ldw	ra,4(sp)
 82162f4:	df000017 	ldw	fp,0(sp)
 82162f8:	dec00204 	addi	sp,sp,8
 82162fc:	f800283a 	ret

08216300 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
 8216300:	defffb04 	addi	sp,sp,-20
 8216304:	dfc00415 	stw	ra,16(sp)
 8216308:	df000315 	stw	fp,12(sp)
 821630c:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
 8216310:	01414404 	movi	r5,1296
 8216314:	010209b4 	movhi	r4,2086
 8216318:	21356e04 	addi	r4,r4,-10824
 821631c:	82163e40 	call	82163e4 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
 8216320:	01401504 	movi	r5,84
 8216324:	010209b4 	movhi	r4,2086
 8216328:	2136b204 	addi	r4,r4,-9528
 821632c:	82163e40 	call	82163e4 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
 8216330:	008209b4 	movhi	r2,2086
 8216334:	10b56e04 	addi	r2,r2,-10824
 8216338:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
 821633c:	008209b4 	movhi	r2,2086
 8216340:	10b58904 	addi	r2,r2,-10716
 8216344:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 8216348:	e03ffd05 	stb	zero,-12(fp)
 821634c:	00001106 	br	8216394 <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
 8216350:	e0bffe17 	ldw	r2,-8(fp)
 8216354:	e0ffff17 	ldw	r3,-4(fp)
 8216358:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
 821635c:	e0bffe17 	ldw	r2,-8(fp)
 8216360:	00c00fc4 	movi	r3,63
 8216364:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 8216368:	e0bffe17 	ldw	r2,-8(fp)
 821636c:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
 8216370:	e0bffe17 	ldw	r2,-8(fp)
 8216374:	10801b04 	addi	r2,r2,108
 8216378:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
 821637c:	e0bfff17 	ldw	r2,-4(fp)
 8216380:	10801b04 	addi	r2,r2,108
 8216384:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 8216388:	e0bffd03 	ldbu	r2,-12(fp)
 821638c:	10800044 	addi	r2,r2,1
 8216390:	e0bffd05 	stb	r2,-12(fp)
 8216394:	e0bffd03 	ldbu	r2,-12(fp)
 8216398:	108002f0 	cmpltui	r2,r2,11
 821639c:	103fec1e 	bne	r2,zero,8216350 <OS_InitTCBList+0x50>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
 82163a0:	e0bffe17 	ldw	r2,-8(fp)
 82163a4:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
 82163a8:	e0bffe17 	ldw	r2,-8(fp)
 82163ac:	00c00fc4 	movi	r3,63
 82163b0:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 82163b4:	e0bffe17 	ldw	r2,-8(fp)
 82163b8:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
 82163bc:	d0206e15 	stw	zero,-32328(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
 82163c0:	008209b4 	movhi	r2,2086
 82163c4:	10b56e04 	addi	r2,r2,-10824
 82163c8:	d0a07215 	stw	r2,-32312(gp)
}
 82163cc:	0001883a 	nop
 82163d0:	e037883a 	mov	sp,fp
 82163d4:	dfc00117 	ldw	ra,4(sp)
 82163d8:	df000017 	ldw	fp,0(sp)
 82163dc:	dec00204 	addi	sp,sp,8
 82163e0:	f800283a 	ret

082163e4 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
 82163e4:	defffd04 	addi	sp,sp,-12
 82163e8:	df000215 	stw	fp,8(sp)
 82163ec:	df000204 	addi	fp,sp,8
 82163f0:	e13ffe15 	stw	r4,-8(fp)
 82163f4:	2805883a 	mov	r2,r5
 82163f8:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
 82163fc:	00000706 	br	821641c <OS_MemClr+0x38>
        *pdest++ = (INT8U)0;
 8216400:	e0bffe17 	ldw	r2,-8(fp)
 8216404:	10c00044 	addi	r3,r2,1
 8216408:	e0fffe15 	stw	r3,-8(fp)
 821640c:	10000005 	stb	zero,0(r2)
        size--;
 8216410:	e0bfff0b 	ldhu	r2,-4(fp)
 8216414:	10bfffc4 	addi	r2,r2,-1
 8216418:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
 821641c:	e0bfff0b 	ldhu	r2,-4(fp)
 8216420:	103ff71e 	bne	r2,zero,8216400 <OS_MemClr+0x1c>
        *pdest++ = (INT8U)0;
        size--;
    }
}
 8216424:	0001883a 	nop
 8216428:	e037883a 	mov	sp,fp
 821642c:	df000017 	ldw	fp,0(sp)
 8216430:	dec00104 	addi	sp,sp,4
 8216434:	f800283a 	ret

08216438 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
 8216438:	defffc04 	addi	sp,sp,-16
 821643c:	df000315 	stw	fp,12(sp)
 8216440:	df000304 	addi	fp,sp,12
 8216444:	e13ffd15 	stw	r4,-12(fp)
 8216448:	e17ffe15 	stw	r5,-8(fp)
 821644c:	3005883a 	mov	r2,r6
 8216450:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
 8216454:	00000b06 	br	8216484 <OS_MemCopy+0x4c>
        *pdest++ = *psrc++;
 8216458:	e0bffd17 	ldw	r2,-12(fp)
 821645c:	10c00044 	addi	r3,r2,1
 8216460:	e0fffd15 	stw	r3,-12(fp)
 8216464:	e0fffe17 	ldw	r3,-8(fp)
 8216468:	19000044 	addi	r4,r3,1
 821646c:	e13ffe15 	stw	r4,-8(fp)
 8216470:	18c00003 	ldbu	r3,0(r3)
 8216474:	10c00005 	stb	r3,0(r2)
        size--;
 8216478:	e0bfff0b 	ldhu	r2,-4(fp)
 821647c:	10bfffc4 	addi	r2,r2,-1
 8216480:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
 8216484:	e0bfff0b 	ldhu	r2,-4(fp)
 8216488:	103ff31e 	bne	r2,zero,8216458 <OS_MemCopy+0x20>
        *pdest++ = *psrc++;
        size--;
    }
}
 821648c:	0001883a 	nop
 8216490:	e037883a 	mov	sp,fp
 8216494:	df000017 	ldw	fp,0(sp)
 8216498:	dec00104 	addi	sp,sp,4
 821649c:	f800283a 	ret

082164a0 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
 82164a0:	defffb04 	addi	sp,sp,-20
 82164a4:	dfc00415 	stw	ra,16(sp)
 82164a8:	df000315 	stw	fp,12(sp)
 82164ac:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 82164b0:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82164b4:	0005303a 	rdctl	r2,status
 82164b8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82164bc:	e0ffff17 	ldw	r3,-4(fp)
 82164c0:	00bfff84 	movi	r2,-2
 82164c4:	1884703a 	and	r2,r3,r2
 82164c8:	1001703a 	wrctl	status,r2
  
  return context;
 82164cc:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
 82164d0:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
 82164d4:	d0a07903 	ldbu	r2,-32284(gp)
 82164d8:	10803fcc 	andi	r2,r2,255
 82164dc:	10001a1e 	bne	r2,zero,8216548 <OS_Sched+0xa8>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
 82164e0:	d0a06b03 	ldbu	r2,-32340(gp)
 82164e4:	10803fcc 	andi	r2,r2,255
 82164e8:	1000171e 	bne	r2,zero,8216548 <OS_Sched+0xa8>
            OS_SchedNew();
 82164ec:	82165700 	call	8216570 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
 82164f0:	d0e06d03 	ldbu	r3,-32332(gp)
 82164f4:	d0a06d43 	ldbu	r2,-32331(gp)
 82164f8:	18c03fcc 	andi	r3,r3,255
 82164fc:	10803fcc 	andi	r2,r2,255
 8216500:	18801126 	beq	r3,r2,8216548 <OS_Sched+0xa8>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
 8216504:	d0a06d03 	ldbu	r2,-32332(gp)
 8216508:	10c03fcc 	andi	r3,r2,255
 821650c:	008209b4 	movhi	r2,2086
 8216510:	10b6b204 	addi	r2,r2,-9528
 8216514:	18c7883a 	add	r3,r3,r3
 8216518:	18c7883a 	add	r3,r3,r3
 821651c:	10c5883a 	add	r2,r2,r3
 8216520:	10800017 	ldw	r2,0(r2)
 8216524:	d0a07515 	stw	r2,-32300(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
 8216528:	d0a07517 	ldw	r2,-32300(gp)
 821652c:	10c00e17 	ldw	r3,56(r2)
 8216530:	18c00044 	addi	r3,r3,1
 8216534:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
 8216538:	d0a07017 	ldw	r2,-32320(gp)
 821653c:	10800044 	addi	r2,r2,1
 8216540:	d0a07015 	stw	r2,-32320(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
 8216544:	823cb200 	call	823cb20 <OSCtxSw>
 8216548:	e0bffd17 	ldw	r2,-12(fp)
 821654c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216550:	e0bffe17 	ldw	r2,-8(fp)
 8216554:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
 8216558:	0001883a 	nop
 821655c:	e037883a 	mov	sp,fp
 8216560:	dfc00117 	ldw	ra,4(sp)
 8216564:	df000017 	ldw	fp,0(sp)
 8216568:	dec00204 	addi	sp,sp,8
 821656c:	f800283a 	ret

08216570 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
 8216570:	defffe04 	addi	sp,sp,-8
 8216574:	df000115 	stw	fp,4(sp)
 8216578:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
 821657c:	d0a07703 	ldbu	r2,-32292(gp)
 8216580:	10c03fcc 	andi	r3,r2,255
 8216584:	00820974 	movhi	r2,2085
 8216588:	10b78904 	addi	r2,r2,-8668
 821658c:	10c5883a 	add	r2,r2,r3
 8216590:	10800003 	ldbu	r2,0(r2)
 8216594:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 8216598:	e0bfff03 	ldbu	r2,-4(fp)
 821659c:	100490fa 	slli	r2,r2,3
 82165a0:	1009883a 	mov	r4,r2
 82165a4:	e0ffff03 	ldbu	r3,-4(fp)
 82165a8:	d0a07744 	addi	r2,gp,-32291
 82165ac:	1885883a 	add	r2,r3,r2
 82165b0:	10800003 	ldbu	r2,0(r2)
 82165b4:	10c03fcc 	andi	r3,r2,255
 82165b8:	00820974 	movhi	r2,2085
 82165bc:	10b78904 	addi	r2,r2,-8668
 82165c0:	10c5883a 	add	r2,r2,r3
 82165c4:	10800003 	ldbu	r2,0(r2)
 82165c8:	2085883a 	add	r2,r4,r2
 82165cc:	d0a06d05 	stb	r2,-32332(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
 82165d0:	0001883a 	nop
 82165d4:	e037883a 	mov	sp,fp
 82165d8:	df000017 	ldw	fp,0(sp)
 82165dc:	dec00104 	addi	sp,sp,4
 82165e0:	f800283a 	ret

082165e4 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
 82165e4:	defffc04 	addi	sp,sp,-16
 82165e8:	df000315 	stw	fp,12(sp)
 82165ec:	df000304 	addi	fp,sp,12
 82165f0:	e13ffe15 	stw	r4,-8(fp)
 82165f4:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
 82165f8:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
 82165fc:	00000b06 	br	821662c <OS_StrCopy+0x48>
        *pdest++ = *psrc++;
 8216600:	e0bffe17 	ldw	r2,-8(fp)
 8216604:	10c00044 	addi	r3,r2,1
 8216608:	e0fffe15 	stw	r3,-8(fp)
 821660c:	e0ffff17 	ldw	r3,-4(fp)
 8216610:	19000044 	addi	r4,r3,1
 8216614:	e13fff15 	stw	r4,-4(fp)
 8216618:	18c00003 	ldbu	r3,0(r3)
 821661c:	10c00005 	stb	r3,0(r2)
        len++;
 8216620:	e0bffd03 	ldbu	r2,-12(fp)
 8216624:	10800044 	addi	r2,r2,1
 8216628:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 821662c:	e0bfff17 	ldw	r2,-4(fp)
 8216630:	10800003 	ldbu	r2,0(r2)
 8216634:	10803fcc 	andi	r2,r2,255
 8216638:	103ff11e 	bne	r2,zero,8216600 <OS_StrCopy+0x1c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
 821663c:	e0bffe17 	ldw	r2,-8(fp)
 8216640:	10000005 	stb	zero,0(r2)
    return (len);
 8216644:	e0bffd03 	ldbu	r2,-12(fp)
}
 8216648:	e037883a 	mov	sp,fp
 821664c:	df000017 	ldw	fp,0(sp)
 8216650:	dec00104 	addi	sp,sp,4
 8216654:	f800283a 	ret

08216658 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
 8216658:	defffd04 	addi	sp,sp,-12
 821665c:	df000215 	stw	fp,8(sp)
 8216660:	df000204 	addi	fp,sp,8
 8216664:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
 8216668:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
 821666c:	00000606 	br	8216688 <OS_StrLen+0x30>
        psrc++;
 8216670:	e0bfff17 	ldw	r2,-4(fp)
 8216674:	10800044 	addi	r2,r2,1
 8216678:	e0bfff15 	stw	r2,-4(fp)
        len++;
 821667c:	e0bffe03 	ldbu	r2,-8(fp)
 8216680:	10800044 	addi	r2,r2,1
 8216684:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 8216688:	e0bfff17 	ldw	r2,-4(fp)
 821668c:	10800003 	ldbu	r2,0(r2)
 8216690:	10803fcc 	andi	r2,r2,255
 8216694:	103ff61e 	bne	r2,zero,8216670 <OS_StrLen+0x18>
        psrc++;
        len++;
    }
    return (len);
 8216698:	e0bffe03 	ldbu	r2,-8(fp)
}
 821669c:	e037883a 	mov	sp,fp
 82166a0:	df000017 	ldw	fp,0(sp)
 82166a4:	dec00104 	addi	sp,sp,4
 82166a8:	f800283a 	ret

082166ac <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
 82166ac:	defffa04 	addi	sp,sp,-24
 82166b0:	dfc00515 	stw	ra,20(sp)
 82166b4:	df000415 	stw	fp,16(sp)
 82166b8:	df000404 	addi	fp,sp,16
 82166bc:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82166c0:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82166c4:	0005303a 	rdctl	r2,status
 82166c8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82166cc:	e0fffd17 	ldw	r3,-12(fp)
 82166d0:	00bfff84 	movi	r2,-2
 82166d4:	1884703a 	and	r2,r3,r2
 82166d8:	1001703a 	wrctl	status,r2
  
  return context;
 82166dc:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
 82166e0:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
 82166e4:	d0a06c17 	ldw	r2,-32336(gp)
 82166e8:	10800044 	addi	r2,r2,1
 82166ec:	d0a06c15 	stw	r2,-32336(gp)
 82166f0:	e0bffc17 	ldw	r2,-16(fp)
 82166f4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82166f8:	e0bffe17 	ldw	r2,-8(fp)
 82166fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
 8216700:	823ce400 	call	823ce40 <OSTaskIdleHook>
    }
 8216704:	003fef06 	br	82166c4 <OS_TaskIdle+0x18>

08216708 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
 8216708:	defffa04 	addi	sp,sp,-24
 821670c:	dfc00515 	stw	ra,20(sp)
 8216710:	df000415 	stw	fp,16(sp)
 8216714:	df000404 	addi	fp,sp,16
 8216718:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821671c:	e03ffc15 	stw	zero,-16(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 8216720:	00000206 	br	821672c <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
 8216724:	01000504 	movi	r4,20
 8216728:	821be3c0 	call	821be3c <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 821672c:	d0a07d03 	ldbu	r2,-32268(gp)
 8216730:	10803fcc 	andi	r2,r2,255
 8216734:	103ffb26 	beq	r2,zero,8216724 <OS_TaskStat+0x1c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
 8216738:	d0a07117 	ldw	r2,-32316(gp)
 821673c:	01401904 	movi	r5,100
 8216740:	1009883a 	mov	r4,r2
 8216744:	8202b8c0 	call	8202b8c <__udivsi3>
 8216748:	d0a07115 	stw	r2,-32316(gp)
    if (OSIdleCtrMax == 0L) {
 821674c:	d0a07117 	ldw	r2,-32316(gp)
 8216750:	1000031e 	bne	r2,zero,8216760 <OS_TaskStat+0x58>
        OSCPUUsage = 0;
 8216754:	d0207305 	stb	zero,-32308(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
 8216758:	01003fc4 	movi	r4,255
 821675c:	821bac40 	call	821bac4 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216760:	0005303a 	rdctl	r2,status
 8216764:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216768:	e0fffd17 	ldw	r3,-12(fp)
 821676c:	00bfff84 	movi	r2,-2
 8216770:	1884703a 	and	r2,r3,r2
 8216774:	1001703a 	wrctl	status,r2
  
  return context;
 8216778:	e0bffd17 	ldw	r2,-12(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
 821677c:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
 8216780:	d0a06c17 	ldw	r2,-32336(gp)
 8216784:	d0a07e15 	stw	r2,-32264(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
 8216788:	d0206c15 	stw	zero,-32336(gp)
 821678c:	e0bffc17 	ldw	r2,-16(fp)
 8216790:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216794:	e0bffe17 	ldw	r2,-8(fp)
 8216798:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
 821679c:	d0a07e17 	ldw	r2,-32264(gp)
 82167a0:	d0e07117 	ldw	r3,-32316(gp)
 82167a4:	180b883a 	mov	r5,r3
 82167a8:	1009883a 	mov	r4,r2
 82167ac:	8202b8c0 	call	8202b8c <__udivsi3>
 82167b0:	1007883a 	mov	r3,r2
 82167b4:	00801904 	movi	r2,100
 82167b8:	10c5c83a 	sub	r2,r2,r3
 82167bc:	d0a07305 	stb	r2,-32308(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
 82167c0:	823cdb40 	call	823cdb4 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
 82167c4:	82167d40 	call	82167d4 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
 82167c8:	01000284 	movi	r4,10
 82167cc:	821be3c0 	call	821be3c <OSTimeDly>
    }
 82167d0:	003fe306 	br	8216760 <OS_TaskStat+0x58>

082167d4 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
 82167d4:	defffa04 	addi	sp,sp,-24
 82167d8:	dfc00515 	stw	ra,20(sp)
 82167dc:	df000415 	stw	fp,16(sp)
 82167e0:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 82167e4:	e03ffc05 	stb	zero,-16(fp)
 82167e8:	00002406 	br	821687c <OS_TaskStatStkChk+0xa8>
        err = OSTaskStkChk(prio, &stk_data);
 82167ec:	e0bffc03 	ldbu	r2,-16(fp)
 82167f0:	e0fffe04 	addi	r3,fp,-8
 82167f4:	180b883a 	mov	r5,r3
 82167f8:	1009883a 	mov	r4,r2
 82167fc:	821b9040 	call	821b904 <OSTaskStkChk>
 8216800:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
 8216804:	e0bffc43 	ldbu	r2,-15(fp)
 8216808:	1000191e 	bne	r2,zero,8216870 <OS_TaskStatStkChk+0x9c>
            ptcb = OSTCBPrioTbl[prio];
 821680c:	e0fffc03 	ldbu	r3,-16(fp)
 8216810:	008209b4 	movhi	r2,2086
 8216814:	10b6b204 	addi	r2,r2,-9528
 8216818:	18c7883a 	add	r3,r3,r3
 821681c:	18c7883a 	add	r3,r3,r3
 8216820:	10c5883a 	add	r2,r2,r3
 8216824:	10800017 	ldw	r2,0(r2)
 8216828:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
 821682c:	e0bffd17 	ldw	r2,-12(fp)
 8216830:	10000f26 	beq	r2,zero,8216870 <OS_TaskStatStkChk+0x9c>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
 8216834:	e0bffd17 	ldw	r2,-12(fp)
 8216838:	10800060 	cmpeqi	r2,r2,1
 821683c:	10000c1e 	bne	r2,zero,8216870 <OS_TaskStatStkChk+0x9c>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
 8216840:	e0bffd17 	ldw	r2,-12(fp)
 8216844:	10c00217 	ldw	r3,8(r2)
 8216848:	e0bffd17 	ldw	r2,-12(fp)
 821684c:	10800317 	ldw	r2,12(r2)
 8216850:	1085883a 	add	r2,r2,r2
 8216854:	1085883a 	add	r2,r2,r2
 8216858:	1887883a 	add	r3,r3,r2
 821685c:	e0bffd17 	ldw	r2,-12(fp)
 8216860:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
 8216864:	e0ffff17 	ldw	r3,-4(fp)
 8216868:	e0bffd17 	ldw	r2,-12(fp)
 821686c:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 8216870:	e0bffc03 	ldbu	r2,-16(fp)
 8216874:	10800044 	addi	r2,r2,1
 8216878:	e0bffc05 	stb	r2,-16(fp)
 821687c:	e0bffc03 	ldbu	r2,-16(fp)
 8216880:	10800570 	cmpltui	r2,r2,21
 8216884:	103fd91e 	bne	r2,zero,82167ec <OS_TaskStatStkChk+0x18>
#endif
                }
            }
        }
    }
}
 8216888:	0001883a 	nop
 821688c:	e037883a 	mov	sp,fp
 8216890:	dfc00117 	ldw	ra,4(sp)
 8216894:	df000017 	ldw	fp,0(sp)
 8216898:	dec00204 	addi	sp,sp,8
 821689c:	f800283a 	ret

082168a0 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
 82168a0:	defff204 	addi	sp,sp,-56
 82168a4:	dfc00d15 	stw	ra,52(sp)
 82168a8:	df000c15 	stw	fp,48(sp)
 82168ac:	df000c04 	addi	fp,sp,48
 82168b0:	e17ffc15 	stw	r5,-16(fp)
 82168b4:	e1bffd15 	stw	r6,-12(fp)
 82168b8:	3807883a 	mov	r3,r7
 82168bc:	e0800417 	ldw	r2,16(fp)
 82168c0:	e13ffb05 	stb	r4,-20(fp)
 82168c4:	e0fffe0d 	sth	r3,-8(fp)
 82168c8:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 82168cc:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82168d0:	0005303a 	rdctl	r2,status
 82168d4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82168d8:	e0fffa17 	ldw	r3,-24(fp)
 82168dc:	00bfff84 	movi	r2,-2
 82168e0:	1884703a 	and	r2,r3,r2
 82168e4:	1001703a 	wrctl	status,r2
  
  return context;
 82168e8:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
 82168ec:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
 82168f0:	d0a07217 	ldw	r2,-32312(gp)
 82168f4:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
 82168f8:	e0bff617 	ldw	r2,-40(fp)
 82168fc:	10009326 	beq	r2,zero,8216b4c <OS_TCBInit+0x2ac>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
 8216900:	e0bff617 	ldw	r2,-40(fp)
 8216904:	10800517 	ldw	r2,20(r2)
 8216908:	d0a07215 	stw	r2,-32312(gp)
 821690c:	e0bff417 	ldw	r2,-48(fp)
 8216910:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216914:	e0bff817 	ldw	r2,-32(fp)
 8216918:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
 821691c:	e0bff617 	ldw	r2,-40(fp)
 8216920:	e0fffc17 	ldw	r3,-16(fp)
 8216924:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
 8216928:	e0bff617 	ldw	r2,-40(fp)
 821692c:	e0fffb03 	ldbu	r3,-20(fp)
 8216930:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
 8216934:	e0bff617 	ldw	r2,-40(fp)
 8216938:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
 821693c:	e0bff617 	ldw	r2,-40(fp)
 8216940:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
 8216944:	e0bff617 	ldw	r2,-40(fp)
 8216948:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
 821694c:	e0bff617 	ldw	r2,-40(fp)
 8216950:	e0c00317 	ldw	r3,12(fp)
 8216954:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
 8216958:	e0bff617 	ldw	r2,-40(fp)
 821695c:	e0c00217 	ldw	r3,8(fp)
 8216960:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
 8216964:	e0bff617 	ldw	r2,-40(fp)
 8216968:	e0fffd17 	ldw	r3,-12(fp)
 821696c:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
 8216970:	e0bff617 	ldw	r2,-40(fp)
 8216974:	e0ffff0b 	ldhu	r3,-4(fp)
 8216978:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
 821697c:	e0bff617 	ldw	r2,-40(fp)
 8216980:	e0fffe0b 	ldhu	r3,-8(fp)
 8216984:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
 8216988:	e0bff617 	ldw	r2,-40(fp)
 821698c:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
 8216990:	e0bffb03 	ldbu	r2,-20(fp)
 8216994:	1004d0fa 	srli	r2,r2,3
 8216998:	1007883a 	mov	r3,r2
 821699c:	e0bff617 	ldw	r2,-40(fp)
 82169a0:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
 82169a4:	e0bffb03 	ldbu	r2,-20(fp)
 82169a8:	108001cc 	andi	r2,r2,7
 82169ac:	1007883a 	mov	r3,r2
 82169b0:	e0bff617 	ldw	r2,-40(fp)
 82169b4:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
 82169b8:	e0bff617 	ldw	r2,-40(fp)
 82169bc:	10800d03 	ldbu	r2,52(r2)
 82169c0:	10803fcc 	andi	r2,r2,255
 82169c4:	00c00044 	movi	r3,1
 82169c8:	1884983a 	sll	r2,r3,r2
 82169cc:	1007883a 	mov	r3,r2
 82169d0:	e0bff617 	ldw	r2,-40(fp)
 82169d4:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
 82169d8:	e0bff617 	ldw	r2,-40(fp)
 82169dc:	10800cc3 	ldbu	r2,51(r2)
 82169e0:	10803fcc 	andi	r2,r2,255
 82169e4:	00c00044 	movi	r3,1
 82169e8:	1884983a 	sll	r2,r3,r2
 82169ec:	1007883a 	mov	r3,r2
 82169f0:	e0bff617 	ldw	r2,-40(fp)
 82169f4:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
 82169f8:	e0bff617 	ldw	r2,-40(fp)
 82169fc:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
 8216a00:	e0bff617 	ldw	r2,-40(fp)
 8216a04:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
 8216a08:	e0bff617 	ldw	r2,-40(fp)
 8216a0c:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
 8216a10:	e0bff617 	ldw	r2,-40(fp)
 8216a14:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
 8216a18:	e0bff617 	ldw	r2,-40(fp)
 8216a1c:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
 8216a20:	e0bff617 	ldw	r2,-40(fp)
 8216a24:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
 8216a28:	e0bff617 	ldw	r2,-40(fp)
 8216a2c:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
 8216a30:	e0bff617 	ldw	r2,-40(fp)
 8216a34:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
 8216a38:	e0bff617 	ldw	r2,-40(fp)
 8216a3c:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
 8216a40:	e0bff617 	ldw	r2,-40(fp)
 8216a44:	00c00fc4 	movi	r3,63
 8216a48:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 8216a4c:	e0bff617 	ldw	r2,-40(fp)
 8216a50:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
 8216a54:	e13ff617 	ldw	r4,-40(fp)
 8216a58:	823ce600 	call	823ce60 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
 8216a5c:	e13ff617 	ldw	r4,-40(fp)
 8216a60:	823cd4c0 	call	823cd4c <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216a64:	0005303a 	rdctl	r2,status
 8216a68:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216a6c:	e0fff517 	ldw	r3,-44(fp)
 8216a70:	00bfff84 	movi	r2,-2
 8216a74:	1884703a 	and	r2,r3,r2
 8216a78:	1001703a 	wrctl	status,r2
  
  return context;
 8216a7c:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
 8216a80:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
 8216a84:	e0fffb03 	ldbu	r3,-20(fp)
 8216a88:	008209b4 	movhi	r2,2086
 8216a8c:	10b6b204 	addi	r2,r2,-9528
 8216a90:	18c7883a 	add	r3,r3,r3
 8216a94:	18c7883a 	add	r3,r3,r3
 8216a98:	10c5883a 	add	r2,r2,r3
 8216a9c:	e0fff617 	ldw	r3,-40(fp)
 8216aa0:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
 8216aa4:	d0e06e17 	ldw	r3,-32328(gp)
 8216aa8:	e0bff617 	ldw	r2,-40(fp)
 8216aac:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
 8216ab0:	e0bff617 	ldw	r2,-40(fp)
 8216ab4:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
 8216ab8:	d0a06e17 	ldw	r2,-32328(gp)
 8216abc:	10000326 	beq	r2,zero,8216acc <OS_TCBInit+0x22c>
            OSTCBList->OSTCBPrev = ptcb;
 8216ac0:	d0a06e17 	ldw	r2,-32328(gp)
 8216ac4:	e0fff617 	ldw	r3,-40(fp)
 8216ac8:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
 8216acc:	e0bff617 	ldw	r2,-40(fp)
 8216ad0:	d0a06e15 	stw	r2,-32328(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
 8216ad4:	e0bff617 	ldw	r2,-40(fp)
 8216ad8:	10c00d83 	ldbu	r3,54(r2)
 8216adc:	d0a07703 	ldbu	r2,-32292(gp)
 8216ae0:	1884b03a 	or	r2,r3,r2
 8216ae4:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 8216ae8:	e0bff617 	ldw	r2,-40(fp)
 8216aec:	10800d03 	ldbu	r2,52(r2)
 8216af0:	10c03fcc 	andi	r3,r2,255
 8216af4:	e0bff617 	ldw	r2,-40(fp)
 8216af8:	10800d03 	ldbu	r2,52(r2)
 8216afc:	11003fcc 	andi	r4,r2,255
 8216b00:	d0a07744 	addi	r2,gp,-32291
 8216b04:	2085883a 	add	r2,r4,r2
 8216b08:	11000003 	ldbu	r4,0(r2)
 8216b0c:	e0bff617 	ldw	r2,-40(fp)
 8216b10:	10800d43 	ldbu	r2,53(r2)
 8216b14:	2084b03a 	or	r2,r4,r2
 8216b18:	1009883a 	mov	r4,r2
 8216b1c:	d0a07744 	addi	r2,gp,-32291
 8216b20:	1885883a 	add	r2,r3,r2
 8216b24:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
 8216b28:	d0a07343 	ldbu	r2,-32307(gp)
 8216b2c:	10800044 	addi	r2,r2,1
 8216b30:	d0a07345 	stb	r2,-32307(gp)
 8216b34:	e0bff417 	ldw	r2,-48(fp)
 8216b38:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216b3c:	e0bff717 	ldw	r2,-36(fp)
 8216b40:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 8216b44:	0005883a 	mov	r2,zero
 8216b48:	00000506 	br	8216b60 <OS_TCBInit+0x2c0>
 8216b4c:	e0bff417 	ldw	r2,-48(fp)
 8216b50:	e0bff915 	stw	r2,-28(fp)
 8216b54:	e0bff917 	ldw	r2,-28(fp)
 8216b58:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
 8216b5c:	00801084 	movi	r2,66
}
 8216b60:	e037883a 	mov	sp,fp
 8216b64:	dfc00117 	ldw	ra,4(sp)
 8216b68:	df000017 	ldw	fp,0(sp)
 8216b6c:	dec00204 	addi	sp,sp,8
 8216b70:	f800283a 	ret

08216b74 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
 8216b74:	defffe04 	addi	sp,sp,-8
 8216b78:	df000115 	stw	fp,4(sp)
 8216b7c:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
 8216b80:	d0a00c04 	addi	r2,gp,-32720
 8216b84:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
 8216b88:	d0a00d04 	addi	r2,gp,-32716
 8216b8c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
 8216b90:	d0a00e84 	addi	r2,gp,-32710
 8216b94:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
 8216b98:	d0a00f04 	addi	r2,gp,-32708
 8216b9c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
 8216ba0:	d0a00e04 	addi	r2,gp,-32712
 8216ba4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
 8216ba8:	d0a00f84 	addi	r2,gp,-32706
 8216bac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
 8216bb0:	d0a01004 	addi	r2,gp,-32704
 8216bb4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
 8216bb8:	d0a01084 	addi	r2,gp,-32702
 8216bbc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
 8216bc0:	d0a01104 	addi	r2,gp,-32700
 8216bc4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
 8216bc8:	d0a01184 	addi	r2,gp,-32698
 8216bcc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
 8216bd0:	d0a01204 	addi	r2,gp,-32696
 8216bd4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
 8216bd8:	d0a01284 	addi	r2,gp,-32694
 8216bdc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
 8216be0:	d0a01304 	addi	r2,gp,-32692
 8216be4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
 8216be8:	d0a01384 	addi	r2,gp,-32690
 8216bec:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
 8216bf0:	d0a01404 	addi	r2,gp,-32688
 8216bf4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
 8216bf8:	d0a01484 	addi	r2,gp,-32686
 8216bfc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
 8216c00:	d0a01504 	addi	r2,gp,-32684
 8216c04:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
 8216c08:	d0a01584 	addi	r2,gp,-32682
 8216c0c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
 8216c10:	d0a01604 	addi	r2,gp,-32680
 8216c14:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
 8216c18:	d0a01684 	addi	r2,gp,-32678
 8216c1c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
 8216c20:	d0a01704 	addi	r2,gp,-32676
 8216c24:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
 8216c28:	d0a01784 	addi	r2,gp,-32674
 8216c2c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
 8216c30:	d0a01804 	addi	r2,gp,-32672
 8216c34:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
 8216c38:	d0a01884 	addi	r2,gp,-32670
 8216c3c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
 8216c40:	d0a01904 	addi	r2,gp,-32668
 8216c44:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
 8216c48:	d0a01984 	addi	r2,gp,-32666
 8216c4c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
 8216c50:	d0a01a04 	addi	r2,gp,-32664
 8216c54:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
 8216c58:	d0a01a84 	addi	r2,gp,-32662
 8216c5c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
 8216c60:	d0a01b04 	addi	r2,gp,-32660
 8216c64:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
 8216c68:	d0a01b84 	addi	r2,gp,-32658
 8216c6c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
 8216c70:	d0a01c04 	addi	r2,gp,-32656
 8216c74:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
 8216c78:	d0a01c84 	addi	r2,gp,-32654
 8216c7c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
 8216c80:	d0a01d04 	addi	r2,gp,-32652
 8216c84:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
 8216c88:	d0a01d84 	addi	r2,gp,-32650
 8216c8c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
 8216c90:	d0a01e04 	addi	r2,gp,-32648
 8216c94:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
 8216c98:	d0a01e84 	addi	r2,gp,-32646
 8216c9c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
 8216ca0:	d0a01f04 	addi	r2,gp,-32644
 8216ca4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
 8216ca8:	d0a01f84 	addi	r2,gp,-32642
 8216cac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
 8216cb0:	d0a02004 	addi	r2,gp,-32640
 8216cb4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
 8216cb8:	d0a02084 	addi	r2,gp,-32638
 8216cbc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
 8216cc0:	d0a02104 	addi	r2,gp,-32636
 8216cc4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
 8216cc8:	d0a02184 	addi	r2,gp,-32634
 8216ccc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
 8216cd0:	d0a02204 	addi	r2,gp,-32632
 8216cd4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
 8216cd8:	d0a02284 	addi	r2,gp,-32630
 8216cdc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
    ptemp = (void *)&OSTmrWheelTblSize;
#endif

    ptemp = (void *)&OSVersionNbr;
 8216ce0:	d0a02304 	addi	r2,gp,-32628
 8216ce4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
 8216ce8:	d0a02804 	addi	r2,gp,-32608
 8216cec:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
 8216cf0:	0001883a 	nop
 8216cf4:	e037883a 	mov	sp,fp
 8216cf8:	df000017 	ldw	fp,0(sp)
 8216cfc:	dec00104 	addi	sp,sp,4
 8216d00:	f800283a 	ret

08216d04 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
 8216d04:	defff204 	addi	sp,sp,-56
 8216d08:	df000d15 	stw	fp,52(sp)
 8216d0c:	df000d04 	addi	fp,sp,52
 8216d10:	e13ffc15 	stw	r4,-16(fp)
 8216d14:	2807883a 	mov	r3,r5
 8216d18:	3005883a 	mov	r2,r6
 8216d1c:	e1ffff15 	stw	r7,-4(fp)
 8216d20:	e0fffd0d 	sth	r3,-12(fp)
 8216d24:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 8216d28:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8216d2c:	e0bfff17 	ldw	r2,-4(fp)
 8216d30:	1000021e 	bne	r2,zero,8216d3c <OSFlagAccept+0x38>
        return ((OS_FLAGS)0);
 8216d34:	0005883a 	mov	r2,zero
 8216d38:	0000b006 	br	8216ffc <OSFlagAccept+0x2f8>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 8216d3c:	e0bffc17 	ldw	r2,-16(fp)
 8216d40:	1000051e 	bne	r2,zero,8216d58 <OSFlagAccept+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8216d44:	e0bfff17 	ldw	r2,-4(fp)
 8216d48:	00c01b84 	movi	r3,110
 8216d4c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8216d50:	0005883a 	mov	r2,zero
 8216d54:	0000a906 	br	8216ffc <OSFlagAccept+0x2f8>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 8216d58:	e0bffc17 	ldw	r2,-16(fp)
 8216d5c:	10800003 	ldbu	r2,0(r2)
 8216d60:	10803fcc 	andi	r2,r2,255
 8216d64:	10800160 	cmpeqi	r2,r2,5
 8216d68:	1000051e 	bne	r2,zero,8216d80 <OSFlagAccept+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 8216d6c:	e0bfff17 	ldw	r2,-4(fp)
 8216d70:	00c00044 	movi	r3,1
 8216d74:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8216d78:	0005883a 	mov	r2,zero
 8216d7c:	00009f06 	br	8216ffc <OSFlagAccept+0x2f8>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 8216d80:	e0fffe03 	ldbu	r3,-8(fp)
 8216d84:	00bfe004 	movi	r2,-128
 8216d88:	1884703a 	and	r2,r3,r2
 8216d8c:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
 8216d90:	e0bff503 	ldbu	r2,-44(fp)
 8216d94:	10000626 	beq	r2,zero,8216db0 <OSFlagAccept+0xac>
        wait_type &= ~OS_FLAG_CONSUME;
 8216d98:	e0bffe03 	ldbu	r2,-8(fp)
 8216d9c:	10801fcc 	andi	r2,r2,127
 8216da0:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
 8216da4:	00800044 	movi	r2,1
 8216da8:	e0bff385 	stb	r2,-50(fp)
 8216dac:	00000106 	br	8216db4 <OSFlagAccept+0xb0>
    } else {
        consume    = OS_FALSE;
 8216db0:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
 8216db4:	e0bfff17 	ldw	r2,-4(fp)
 8216db8:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8216dbc:	0005303a 	rdctl	r2,status
 8216dc0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8216dc4:	e0fffb17 	ldw	r3,-20(fp)
 8216dc8:	00bfff84 	movi	r2,-2
 8216dcc:	1884703a 	and	r2,r3,r2
 8216dd0:	1001703a 	wrctl	status,r2
  
  return context;
 8216dd4:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
 8216dd8:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
 8216ddc:	e0bffe03 	ldbu	r2,-8(fp)
 8216de0:	10c00060 	cmpeqi	r3,r2,1
 8216de4:	18005f1e 	bne	r3,zero,8216f64 <OSFlagAccept+0x260>
 8216de8:	10c00088 	cmpgei	r3,r2,2
 8216dec:	1800021e 	bne	r3,zero,8216df8 <OSFlagAccept+0xf4>
 8216df0:	10003f26 	beq	r2,zero,8216ef0 <OSFlagAccept+0x1ec>
 8216df4:	00007706 	br	8216fd4 <OSFlagAccept+0x2d0>
 8216df8:	10c000a0 	cmpeqi	r3,r2,2
 8216dfc:	1800031e 	bne	r3,zero,8216e0c <OSFlagAccept+0x108>
 8216e00:	108000e0 	cmpeqi	r2,r2,3
 8216e04:	10001e1e 	bne	r2,zero,8216e80 <OSFlagAccept+0x17c>
 8216e08:	00007206 	br	8216fd4 <OSFlagAccept+0x2d0>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 8216e0c:	e0bffc17 	ldw	r2,-16(fp)
 8216e10:	10c0020b 	ldhu	r3,8(r2)
 8216e14:	e0bffd0b 	ldhu	r2,-12(fp)
 8216e18:	1884703a 	and	r2,r3,r2
 8216e1c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 8216e20:	e0fff30b 	ldhu	r3,-52(fp)
 8216e24:	e0bffd0b 	ldhu	r2,-12(fp)
 8216e28:	18800d1e 	bne	r3,r2,8216e60 <OSFlagAccept+0x15c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216e2c:	e0bff383 	ldbu	r2,-50(fp)
 8216e30:	10800058 	cmpnei	r2,r2,1
 8216e34:	10000d1e 	bne	r2,zero,8216e6c <OSFlagAccept+0x168>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 8216e38:	e0bffc17 	ldw	r2,-16(fp)
 8216e3c:	1080020b 	ldhu	r2,8(r2)
 8216e40:	1007883a 	mov	r3,r2
 8216e44:	e0bff30b 	ldhu	r2,-52(fp)
 8216e48:	0084303a 	nor	r2,zero,r2
 8216e4c:	1884703a 	and	r2,r3,r2
 8216e50:	1007883a 	mov	r3,r2
 8216e54:	e0bffc17 	ldw	r2,-16(fp)
 8216e58:	10c0020d 	sth	r3,8(r2)
 8216e5c:	00000306 	br	8216e6c <OSFlagAccept+0x168>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216e60:	e0bfff17 	ldw	r2,-4(fp)
 8216e64:	00c01c04 	movi	r3,112
 8216e68:	10c00005 	stb	r3,0(r2)
 8216e6c:	e0bff417 	ldw	r2,-48(fp)
 8216e70:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8216e74:	e0bff617 	ldw	r2,-40(fp)
 8216e78:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216e7c:	00005e06 	br	8216ff8 <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 8216e80:	e0bffc17 	ldw	r2,-16(fp)
 8216e84:	10c0020b 	ldhu	r3,8(r2)
 8216e88:	e0bffd0b 	ldhu	r2,-12(fp)
 8216e8c:	1884703a 	and	r2,r3,r2
 8216e90:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 8216e94:	e0bff30b 	ldhu	r2,-52(fp)
 8216e98:	10000d26 	beq	r2,zero,8216ed0 <OSFlagAccept+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216e9c:	e0bff383 	ldbu	r2,-50(fp)
 8216ea0:	10800058 	cmpnei	r2,r2,1
 8216ea4:	10000d1e 	bne	r2,zero,8216edc <OSFlagAccept+0x1d8>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 8216ea8:	e0bffc17 	ldw	r2,-16(fp)
 8216eac:	1080020b 	ldhu	r2,8(r2)
 8216eb0:	1007883a 	mov	r3,r2
 8216eb4:	e0bff30b 	ldhu	r2,-52(fp)
 8216eb8:	0084303a 	nor	r2,zero,r2
 8216ebc:	1884703a 	and	r2,r3,r2
 8216ec0:	1007883a 	mov	r3,r2
 8216ec4:	e0bffc17 	ldw	r2,-16(fp)
 8216ec8:	10c0020d 	sth	r3,8(r2)
 8216ecc:	00000306 	br	8216edc <OSFlagAccept+0x1d8>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216ed0:	e0bfff17 	ldw	r2,-4(fp)
 8216ed4:	00c01c04 	movi	r3,112
 8216ed8:	10c00005 	stb	r3,0(r2)
 8216edc:	e0bff417 	ldw	r2,-48(fp)
 8216ee0:	e0bff715 	stw	r2,-36(fp)
 8216ee4:	e0bff717 	ldw	r2,-36(fp)
 8216ee8:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216eec:	00004206 	br	8216ff8 <OSFlagAccept+0x2f4>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 8216ef0:	e0bffc17 	ldw	r2,-16(fp)
 8216ef4:	1080020b 	ldhu	r2,8(r2)
 8216ef8:	0084303a 	nor	r2,zero,r2
 8216efc:	1007883a 	mov	r3,r2
 8216f00:	e0bffd0b 	ldhu	r2,-12(fp)
 8216f04:	1884703a 	and	r2,r3,r2
 8216f08:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 8216f0c:	e0fff30b 	ldhu	r3,-52(fp)
 8216f10:	e0bffd0b 	ldhu	r2,-12(fp)
 8216f14:	18800b1e 	bne	r3,r2,8216f44 <OSFlagAccept+0x240>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216f18:	e0bff383 	ldbu	r2,-50(fp)
 8216f1c:	10800058 	cmpnei	r2,r2,1
 8216f20:	10000b1e 	bne	r2,zero,8216f50 <OSFlagAccept+0x24c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 8216f24:	e0bffc17 	ldw	r2,-16(fp)
 8216f28:	10c0020b 	ldhu	r3,8(r2)
 8216f2c:	e0bff30b 	ldhu	r2,-52(fp)
 8216f30:	1884b03a 	or	r2,r3,r2
 8216f34:	1007883a 	mov	r3,r2
 8216f38:	e0bffc17 	ldw	r2,-16(fp)
 8216f3c:	10c0020d 	sth	r3,8(r2)
 8216f40:	00000306 	br	8216f50 <OSFlagAccept+0x24c>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216f44:	e0bfff17 	ldw	r2,-4(fp)
 8216f48:	00c01c04 	movi	r3,112
 8216f4c:	10c00005 	stb	r3,0(r2)
 8216f50:	e0bff417 	ldw	r2,-48(fp)
 8216f54:	e0bff815 	stw	r2,-32(fp)
 8216f58:	e0bff817 	ldw	r2,-32(fp)
 8216f5c:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216f60:	00002506 	br	8216ff8 <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 8216f64:	e0bffc17 	ldw	r2,-16(fp)
 8216f68:	1080020b 	ldhu	r2,8(r2)
 8216f6c:	0084303a 	nor	r2,zero,r2
 8216f70:	1007883a 	mov	r3,r2
 8216f74:	e0bffd0b 	ldhu	r2,-12(fp)
 8216f78:	1884703a 	and	r2,r3,r2
 8216f7c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 8216f80:	e0bff30b 	ldhu	r2,-52(fp)
 8216f84:	10000b26 	beq	r2,zero,8216fb4 <OSFlagAccept+0x2b0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8216f88:	e0bff383 	ldbu	r2,-50(fp)
 8216f8c:	10800058 	cmpnei	r2,r2,1
 8216f90:	10000b1e 	bne	r2,zero,8216fc0 <OSFlagAccept+0x2bc>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 8216f94:	e0bffc17 	ldw	r2,-16(fp)
 8216f98:	10c0020b 	ldhu	r3,8(r2)
 8216f9c:	e0bff30b 	ldhu	r2,-52(fp)
 8216fa0:	1884b03a 	or	r2,r3,r2
 8216fa4:	1007883a 	mov	r3,r2
 8216fa8:	e0bffc17 	ldw	r2,-16(fp)
 8216fac:	10c0020d 	sth	r3,8(r2)
 8216fb0:	00000306 	br	8216fc0 <OSFlagAccept+0x2bc>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 8216fb4:	e0bfff17 	ldw	r2,-4(fp)
 8216fb8:	00c01c04 	movi	r3,112
 8216fbc:	10c00005 	stb	r3,0(r2)
 8216fc0:	e0bff417 	ldw	r2,-48(fp)
 8216fc4:	e0bff915 	stw	r2,-28(fp)
 8216fc8:	e0bff917 	ldw	r2,-28(fp)
 8216fcc:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 8216fd0:	00000906 	br	8216ff8 <OSFlagAccept+0x2f4>
 8216fd4:	e0bff417 	ldw	r2,-48(fp)
 8216fd8:	e0bffa15 	stw	r2,-24(fp)
 8216fdc:	e0bffa17 	ldw	r2,-24(fp)
 8216fe0:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 8216fe4:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
 8216fe8:	e0bfff17 	ldw	r2,-4(fp)
 8216fec:	00c01bc4 	movi	r3,111
 8216ff0:	10c00005 	stb	r3,0(r2)
             break;
 8216ff4:	0001883a 	nop
    }
    return (flags_rdy);
 8216ff8:	e0bff30b 	ldhu	r2,-52(fp)
}
 8216ffc:	e037883a 	mov	sp,fp
 8217000:	df000017 	ldw	fp,0(sp)
 8217004:	dec00104 	addi	sp,sp,4
 8217008:	f800283a 	ret

0821700c <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
 821700c:	defff804 	addi	sp,sp,-32
 8217010:	df000715 	stw	fp,28(sp)
 8217014:	df000704 	addi	fp,sp,28
 8217018:	2005883a 	mov	r2,r4
 821701c:	e17fff15 	stw	r5,-4(fp)
 8217020:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
 8217024:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
 8217028:	e0bfff17 	ldw	r2,-4(fp)
 821702c:	1000021e 	bne	r2,zero,8217038 <OSFlagCreate+0x2c>
        return ((OS_FLAG_GRP *)0);
 8217030:	0005883a 	mov	r2,zero
 8217034:	00003306 	br	8217104 <OSFlagCreate+0xf8>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
 8217038:	d0a07903 	ldbu	r2,-32284(gp)
 821703c:	10803fcc 	andi	r2,r2,255
 8217040:	10000526 	beq	r2,zero,8217058 <OSFlagCreate+0x4c>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
 8217044:	e0bfff17 	ldw	r2,-4(fp)
 8217048:	00c00404 	movi	r3,16
 821704c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
 8217050:	0005883a 	mov	r2,zero
 8217054:	00002b06 	br	8217104 <OSFlagCreate+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217058:	0005303a 	rdctl	r2,status
 821705c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217060:	e0fffd17 	ldw	r3,-12(fp)
 8217064:	00bfff84 	movi	r2,-2
 8217068:	1884703a 	and	r2,r3,r2
 821706c:	1001703a 	wrctl	status,r2
  
  return context;
 8217070:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8217074:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
 8217078:	d0a07c17 	ldw	r2,-32272(gp)
 821707c:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
 8217080:	e0bffb17 	ldw	r2,-20(fp)
 8217084:	10001726 	beq	r2,zero,82170e4 <OSFlagCreate+0xd8>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
 8217088:	d0a07c17 	ldw	r2,-32272(gp)
 821708c:	10800117 	ldw	r2,4(r2)
 8217090:	d0a07c15 	stw	r2,-32272(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
 8217094:	e0bffb17 	ldw	r2,-20(fp)
 8217098:	00c00144 	movi	r3,5
 821709c:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
 82170a0:	e0bffb17 	ldw	r2,-20(fp)
 82170a4:	e0fffe0b 	ldhu	r3,-8(fp)
 82170a8:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
 82170ac:	e0bffb17 	ldw	r2,-20(fp)
 82170b0:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
 82170b4:	e0bffb17 	ldw	r2,-20(fp)
 82170b8:	00c00fc4 	movi	r3,63
 82170bc:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 82170c0:	e0bffb17 	ldw	r2,-20(fp)
 82170c4:	100002c5 	stb	zero,11(r2)
 82170c8:	e0bff917 	ldw	r2,-28(fp)
 82170cc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82170d0:	e0bffa17 	ldw	r2,-24(fp)
 82170d4:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
 82170d8:	e0bfff17 	ldw	r2,-4(fp)
 82170dc:	10000005 	stb	zero,0(r2)
 82170e0:	00000706 	br	8217100 <OSFlagCreate+0xf4>
 82170e4:	e0bff917 	ldw	r2,-28(fp)
 82170e8:	e0bffc15 	stw	r2,-16(fp)
 82170ec:	e0bffc17 	ldw	r2,-16(fp)
 82170f0:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
 82170f4:	e0bfff17 	ldw	r2,-4(fp)
 82170f8:	00c01c84 	movi	r3,114
 82170fc:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
 8217100:	e0bffb17 	ldw	r2,-20(fp)
}
 8217104:	e037883a 	mov	sp,fp
 8217108:	df000017 	ldw	fp,0(sp)
 821710c:	dec00104 	addi	sp,sp,4
 8217110:	f800283a 	ret

08217114 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
 8217114:	defff204 	addi	sp,sp,-56
 8217118:	dfc00d15 	stw	ra,52(sp)
 821711c:	df000c15 	stw	fp,48(sp)
 8217120:	df000c04 	addi	fp,sp,48
 8217124:	e13ffd15 	stw	r4,-12(fp)
 8217128:	2805883a 	mov	r2,r5
 821712c:	e1bfff15 	stw	r6,-4(fp)
 8217130:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 8217134:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8217138:	e0bfff17 	ldw	r2,-4(fp)
 821713c:	1000021e 	bne	r2,zero,8217148 <OSFlagDel+0x34>
        return (pgrp);
 8217140:	e0bffd17 	ldw	r2,-12(fp)
 8217144:	00008006 	br	8217348 <OSFlagDel+0x234>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 8217148:	e0bffd17 	ldw	r2,-12(fp)
 821714c:	1000051e 	bne	r2,zero,8217164 <OSFlagDel+0x50>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217150:	e0bfff17 	ldw	r2,-4(fp)
 8217154:	00c01b84 	movi	r3,110
 8217158:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 821715c:	e0bffd17 	ldw	r2,-12(fp)
 8217160:	00007906 	br	8217348 <OSFlagDel+0x234>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8217164:	d0a07903 	ldbu	r2,-32284(gp)
 8217168:	10803fcc 	andi	r2,r2,255
 821716c:	10000526 	beq	r2,zero,8217184 <OSFlagDel+0x70>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 8217170:	e0bfff17 	ldw	r2,-4(fp)
 8217174:	00c003c4 	movi	r3,15
 8217178:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 821717c:	e0bffd17 	ldw	r2,-12(fp)
 8217180:	00007106 	br	8217348 <OSFlagDel+0x234>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
 8217184:	e0bffd17 	ldw	r2,-12(fp)
 8217188:	10800003 	ldbu	r2,0(r2)
 821718c:	10803fcc 	andi	r2,r2,255
 8217190:	10800160 	cmpeqi	r2,r2,5
 8217194:	1000051e 	bne	r2,zero,82171ac <OSFlagDel+0x98>
        *perr = OS_ERR_EVENT_TYPE;
 8217198:	e0bfff17 	ldw	r2,-4(fp)
 821719c:	00c00044 	movi	r3,1
 82171a0:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 82171a4:	e0bffd17 	ldw	r2,-12(fp)
 82171a8:	00006706 	br	8217348 <OSFlagDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82171ac:	0005303a 	rdctl	r2,status
 82171b0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82171b4:	e0fffc17 	ldw	r3,-16(fp)
 82171b8:	00bfff84 	movi	r2,-2
 82171bc:	1884703a 	and	r2,r3,r2
 82171c0:	1001703a 	wrctl	status,r2
  
  return context;
 82171c4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82171c8:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
 82171cc:	e0bffd17 	ldw	r2,-12(fp)
 82171d0:	10800117 	ldw	r2,4(r2)
 82171d4:	10000326 	beq	r2,zero,82171e4 <OSFlagDel+0xd0>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 82171d8:	00800044 	movi	r2,1
 82171dc:	e0bff405 	stb	r2,-48(fp)
 82171e0:	00000106 	br	82171e8 <OSFlagDel+0xd4>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 82171e4:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
 82171e8:	e0bffe03 	ldbu	r2,-8(fp)
 82171ec:	10000326 	beq	r2,zero,82171fc <OSFlagDel+0xe8>
 82171f0:	10800060 	cmpeqi	r2,r2,1
 82171f4:	1000231e 	bne	r2,zero,8217284 <OSFlagDel+0x170>
 82171f8:	00004806 	br	821731c <OSFlagDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
 82171fc:	e0bff403 	ldbu	r2,-48(fp)
 8217200:	1000161e 	bne	r2,zero,821725c <OSFlagDel+0x148>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
 8217204:	e0bffd17 	ldw	r2,-12(fp)
 8217208:	00c00fc4 	movi	r3,63
 821720c:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 8217210:	e0bffd17 	ldw	r2,-12(fp)
 8217214:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 8217218:	e0bffd17 	ldw	r2,-12(fp)
 821721c:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
 8217220:	d0e07c17 	ldw	r3,-32272(gp)
 8217224:	e0bffd17 	ldw	r2,-12(fp)
 8217228:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
 821722c:	e0bffd17 	ldw	r2,-12(fp)
 8217230:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
 8217234:	e0bffd17 	ldw	r2,-12(fp)
 8217238:	d0a07c15 	stw	r2,-32272(gp)
 821723c:	e0bff717 	ldw	r2,-36(fp)
 8217240:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217244:	e0bff817 	ldw	r2,-32(fp)
 8217248:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
 821724c:	e0bfff17 	ldw	r2,-4(fp)
 8217250:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
 8217254:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
 8217258:	00003a06 	br	8217344 <OSFlagDel+0x230>
 821725c:	e0bff717 	ldw	r2,-36(fp)
 8217260:	e0bff915 	stw	r2,-28(fp)
 8217264:	e0bff917 	ldw	r2,-28(fp)
 8217268:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
 821726c:	e0bfff17 	ldw	r2,-4(fp)
 8217270:	00c01244 	movi	r3,73
 8217274:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
 8217278:	e0bffd17 	ldw	r2,-12(fp)
 821727c:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 8217280:	00003006 	br	8217344 <OSFlagDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 8217284:	e0bffd17 	ldw	r2,-12(fp)
 8217288:	10800117 	ldw	r2,4(r2)
 821728c:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 8217290:	00000606 	br	82172ac <OSFlagDel+0x198>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
 8217294:	000b883a 	mov	r5,zero
 8217298:	e13ff517 	ldw	r4,-44(fp)
 821729c:	82182800 	call	8218280 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 82172a0:	e0bff517 	ldw	r2,-44(fp)
 82172a4:	10800017 	ldw	r2,0(r2)
 82172a8:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 82172ac:	e0bff517 	ldw	r2,-44(fp)
 82172b0:	103ff81e 	bne	r2,zero,8217294 <OSFlagDel+0x180>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
 82172b4:	e0bffd17 	ldw	r2,-12(fp)
 82172b8:	00c00fc4 	movi	r3,63
 82172bc:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 82172c0:	e0bffd17 	ldw	r2,-12(fp)
 82172c4:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 82172c8:	e0bffd17 	ldw	r2,-12(fp)
 82172cc:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
 82172d0:	d0e07c17 	ldw	r3,-32272(gp)
 82172d4:	e0bffd17 	ldw	r2,-12(fp)
 82172d8:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
 82172dc:	e0bffd17 	ldw	r2,-12(fp)
 82172e0:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
 82172e4:	e0bffd17 	ldw	r2,-12(fp)
 82172e8:	d0a07c15 	stw	r2,-32272(gp)
 82172ec:	e0bff717 	ldw	r2,-36(fp)
 82172f0:	e0bffa15 	stw	r2,-24(fp)
 82172f4:	e0bffa17 	ldw	r2,-24(fp)
 82172f8:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 82172fc:	e0bff403 	ldbu	r2,-48(fp)
 8217300:	10800058 	cmpnei	r2,r2,1
 8217304:	1000011e 	bne	r2,zero,821730c <OSFlagDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 8217308:	82164a00 	call	82164a0 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
 821730c:	e0bfff17 	ldw	r2,-4(fp)
 8217310:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
 8217314:	e03ff615 	stw	zero,-40(fp)
             break;
 8217318:	00000a06 	br	8217344 <OSFlagDel+0x230>
 821731c:	e0bff717 	ldw	r2,-36(fp)
 8217320:	e0bffb15 	stw	r2,-20(fp)
 8217324:	e0bffb17 	ldw	r2,-20(fp)
 8217328:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
 821732c:	e0bfff17 	ldw	r2,-4(fp)
 8217330:	00c001c4 	movi	r3,7
 8217334:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
 8217338:	e0bffd17 	ldw	r2,-12(fp)
 821733c:	e0bff615 	stw	r2,-40(fp)
             break;
 8217340:	0001883a 	nop
    }
    return (pgrp_return);
 8217344:	e0bff617 	ldw	r2,-40(fp)
}
 8217348:	e037883a 	mov	sp,fp
 821734c:	dfc00117 	ldw	ra,4(sp)
 8217350:	df000017 	ldw	fp,0(sp)
 8217354:	dec00204 	addi	sp,sp,8
 8217358:	f800283a 	ret

0821735c <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 821735c:	defff604 	addi	sp,sp,-40
 8217360:	dfc00915 	stw	ra,36(sp)
 8217364:	df000815 	stw	fp,32(sp)
 8217368:	df000804 	addi	fp,sp,32
 821736c:	e13ffd15 	stw	r4,-12(fp)
 8217370:	e17ffe15 	stw	r5,-8(fp)
 8217374:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8217378:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 821737c:	e0bfff17 	ldw	r2,-4(fp)
 8217380:	1000021e 	bne	r2,zero,821738c <OSFlagNameGet+0x30>
        return (0);
 8217384:	0005883a 	mov	r2,zero
 8217388:	00003906 	br	8217470 <OSFlagNameGet+0x114>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 821738c:	e0bffd17 	ldw	r2,-12(fp)
 8217390:	1000051e 	bne	r2,zero,82173a8 <OSFlagNameGet+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217394:	e0bfff17 	ldw	r2,-4(fp)
 8217398:	00c01b84 	movi	r3,110
 821739c:	10c00005 	stb	r3,0(r2)
        return (0);
 82173a0:	0005883a 	mov	r2,zero
 82173a4:	00003206 	br	8217470 <OSFlagNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 82173a8:	e0bffe17 	ldw	r2,-8(fp)
 82173ac:	1000051e 	bne	r2,zero,82173c4 <OSFlagNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 82173b0:	e0bfff17 	ldw	r2,-4(fp)
 82173b4:	00c00304 	movi	r3,12
 82173b8:	10c00005 	stb	r3,0(r2)
        return (0);
 82173bc:	0005883a 	mov	r2,zero
 82173c0:	00002b06 	br	8217470 <OSFlagNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 82173c4:	d0a07903 	ldbu	r2,-32284(gp)
 82173c8:	10803fcc 	andi	r2,r2,255
 82173cc:	10000526 	beq	r2,zero,82173e4 <OSFlagNameGet+0x88>
        *perr = OS_ERR_NAME_GET_ISR;
 82173d0:	e0bfff17 	ldw	r2,-4(fp)
 82173d4:	00c00444 	movi	r3,17
 82173d8:	10c00005 	stb	r3,0(r2)
        return (0);
 82173dc:	0005883a 	mov	r2,zero
 82173e0:	00002306 	br	8217470 <OSFlagNameGet+0x114>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82173e4:	0005303a 	rdctl	r2,status
 82173e8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82173ec:	e0fffc17 	ldw	r3,-16(fp)
 82173f0:	00bfff84 	movi	r2,-2
 82173f4:	1884703a 	and	r2,r3,r2
 82173f8:	1001703a 	wrctl	status,r2
  
  return context;
 82173fc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8217400:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 8217404:	e0bffd17 	ldw	r2,-12(fp)
 8217408:	10800003 	ldbu	r2,0(r2)
 821740c:	10803fcc 	andi	r2,r2,255
 8217410:	10800160 	cmpeqi	r2,r2,5
 8217414:	1000091e 	bne	r2,zero,821743c <OSFlagNameGet+0xe0>
 8217418:	e0bff817 	ldw	r2,-32(fp)
 821741c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217420:	e0bff917 	ldw	r2,-28(fp)
 8217424:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 8217428:	e0bfff17 	ldw	r2,-4(fp)
 821742c:	00c00044 	movi	r3,1
 8217430:	10c00005 	stb	r3,0(r2)
        return (0);
 8217434:	0005883a 	mov	r2,zero
 8217438:	00000d06 	br	8217470 <OSFlagNameGet+0x114>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
 821743c:	e0bffd17 	ldw	r2,-12(fp)
 8217440:	10800284 	addi	r2,r2,10
 8217444:	100b883a 	mov	r5,r2
 8217448:	e13ffe17 	ldw	r4,-8(fp)
 821744c:	82165e40 	call	82165e4 <OS_StrCopy>
 8217450:	e0bffb05 	stb	r2,-20(fp)
 8217454:	e0bff817 	ldw	r2,-32(fp)
 8217458:	e0bffa15 	stw	r2,-24(fp)
 821745c:	e0bffa17 	ldw	r2,-24(fp)
 8217460:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8217464:	e0bfff17 	ldw	r2,-4(fp)
 8217468:	10000005 	stb	zero,0(r2)
    return (len);
 821746c:	e0bffb03 	ldbu	r2,-20(fp)
}
 8217470:	e037883a 	mov	sp,fp
 8217474:	dfc00117 	ldw	ra,4(sp)
 8217478:	df000017 	ldw	fp,0(sp)
 821747c:	dec00204 	addi	sp,sp,8
 8217480:	f800283a 	ret

08217484 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 8217484:	defff504 	addi	sp,sp,-44
 8217488:	dfc00a15 	stw	ra,40(sp)
 821748c:	df000915 	stw	fp,36(sp)
 8217490:	df000904 	addi	fp,sp,36
 8217494:	e13ffd15 	stw	r4,-12(fp)
 8217498:	e17ffe15 	stw	r5,-8(fp)
 821749c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82174a0:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 82174a4:	e0bfff17 	ldw	r2,-4(fp)
 82174a8:	10004326 	beq	r2,zero,82175b8 <OSFlagNameSet+0x134>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 82174ac:	e0bffd17 	ldw	r2,-12(fp)
 82174b0:	1000041e 	bne	r2,zero,82174c4 <OSFlagNameSet+0x40>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 82174b4:	e0bfff17 	ldw	r2,-4(fp)
 82174b8:	00c01b84 	movi	r3,110
 82174bc:	10c00005 	stb	r3,0(r2)
        return;
 82174c0:	00003e06 	br	82175bc <OSFlagNameSet+0x138>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 82174c4:	e0bffe17 	ldw	r2,-8(fp)
 82174c8:	1000041e 	bne	r2,zero,82174dc <OSFlagNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 82174cc:	e0bfff17 	ldw	r2,-4(fp)
 82174d0:	00c00304 	movi	r3,12
 82174d4:	10c00005 	stb	r3,0(r2)
        return;
 82174d8:	00003806 	br	82175bc <OSFlagNameSet+0x138>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 82174dc:	d0a07903 	ldbu	r2,-32284(gp)
 82174e0:	10803fcc 	andi	r2,r2,255
 82174e4:	10000426 	beq	r2,zero,82174f8 <OSFlagNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 82174e8:	e0bfff17 	ldw	r2,-4(fp)
 82174ec:	00c00484 	movi	r3,18
 82174f0:	10c00005 	stb	r3,0(r2)
        return;
 82174f4:	00003106 	br	82175bc <OSFlagNameSet+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82174f8:	0005303a 	rdctl	r2,status
 82174fc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217500:	e0fffc17 	ldw	r3,-16(fp)
 8217504:	00bfff84 	movi	r2,-2
 8217508:	1884703a 	and	r2,r3,r2
 821750c:	1001703a 	wrctl	status,r2
  
  return context;
 8217510:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8217514:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 8217518:	e0bffd17 	ldw	r2,-12(fp)
 821751c:	10800003 	ldbu	r2,0(r2)
 8217520:	10803fcc 	andi	r2,r2,255
 8217524:	10800160 	cmpeqi	r2,r2,5
 8217528:	1000081e 	bne	r2,zero,821754c <OSFlagNameSet+0xc8>
 821752c:	e0bff717 	ldw	r2,-36(fp)
 8217530:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217534:	e0bff817 	ldw	r2,-32(fp)
 8217538:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 821753c:	e0bfff17 	ldw	r2,-4(fp)
 8217540:	00c00044 	movi	r3,1
 8217544:	10c00005 	stb	r3,0(r2)
        return;
 8217548:	00001c06 	br	82175bc <OSFlagNameSet+0x138>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 821754c:	e13ffe17 	ldw	r4,-8(fp)
 8217550:	82166580 	call	8216658 <OS_StrLen>
 8217554:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
 8217558:	e0bffa03 	ldbu	r2,-24(fp)
 821755c:	10800830 	cmpltui	r2,r2,32
 8217560:	1000081e 	bne	r2,zero,8217584 <OSFlagNameSet+0x100>
 8217564:	e0bff717 	ldw	r2,-36(fp)
 8217568:	e0bff915 	stw	r2,-28(fp)
 821756c:	e0bff917 	ldw	r2,-28(fp)
 8217570:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
 8217574:	e0bfff17 	ldw	r2,-4(fp)
 8217578:	00c01cc4 	movi	r3,115
 821757c:	10c00005 	stb	r3,0(r2)
        return;
 8217580:	00000e06 	br	82175bc <OSFlagNameSet+0x138>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
 8217584:	e0bffd17 	ldw	r2,-12(fp)
 8217588:	10800284 	addi	r2,r2,10
 821758c:	e17ffe17 	ldw	r5,-8(fp)
 8217590:	1009883a 	mov	r4,r2
 8217594:	82165e40 	call	82165e4 <OS_StrCopy>
 8217598:	e0bff717 	ldw	r2,-36(fp)
 821759c:	e0bffb15 	stw	r2,-20(fp)
 82175a0:	e0bffb17 	ldw	r2,-20(fp)
 82175a4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 82175a8:	e0bfff17 	ldw	r2,-4(fp)
 82175ac:	10000005 	stb	zero,0(r2)
    return;
 82175b0:	0001883a 	nop
 82175b4:	00000106 	br	82175bc <OSFlagNameSet+0x138>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 82175b8:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
 82175bc:	e037883a 	mov	sp,fp
 82175c0:	dfc00117 	ldw	ra,4(sp)
 82175c4:	df000017 	ldw	fp,0(sp)
 82175c8:	dec00204 	addi	sp,sp,8
 82175cc:	f800283a 	ret

082175d0 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
 82175d0:	deffe104 	addi	sp,sp,-124
 82175d4:	dfc01e15 	stw	ra,120(sp)
 82175d8:	df001d15 	stw	fp,116(sp)
 82175dc:	df001d04 	addi	fp,sp,116
 82175e0:	e13ffc15 	stw	r4,-16(fp)
 82175e4:	2809883a 	mov	r4,r5
 82175e8:	3007883a 	mov	r3,r6
 82175ec:	3805883a 	mov	r2,r7
 82175f0:	e13ffd0d 	sth	r4,-12(fp)
 82175f4:	e0fffe05 	stb	r3,-8(fp)
 82175f8:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 82175fc:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8217600:	e0800217 	ldw	r2,8(fp)
 8217604:	1000021e 	bne	r2,zero,8217610 <OSFlagPend+0x40>
        return ((OS_FLAGS)0);
 8217608:	0005883a 	mov	r2,zero
 821760c:	00015906 	br	8217b74 <OSFlagPend+0x5a4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 8217610:	e0bffc17 	ldw	r2,-16(fp)
 8217614:	1000051e 	bne	r2,zero,821762c <OSFlagPend+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217618:	e0800217 	ldw	r2,8(fp)
 821761c:	00c01b84 	movi	r3,110
 8217620:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217624:	0005883a 	mov	r2,zero
 8217628:	00015206 	br	8217b74 <OSFlagPend+0x5a4>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 821762c:	d0a07903 	ldbu	r2,-32284(gp)
 8217630:	10803fcc 	andi	r2,r2,255
 8217634:	10000526 	beq	r2,zero,821764c <OSFlagPend+0x7c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
 8217638:	e0800217 	ldw	r2,8(fp)
 821763c:	00c00084 	movi	r3,2
 8217640:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217644:	0005883a 	mov	r2,zero
 8217648:	00014a06 	br	8217b74 <OSFlagPend+0x5a4>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
 821764c:	d0a06b03 	ldbu	r2,-32340(gp)
 8217650:	10803fcc 	andi	r2,r2,255
 8217654:	10000526 	beq	r2,zero,821766c <OSFlagPend+0x9c>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
 8217658:	e0800217 	ldw	r2,8(fp)
 821765c:	00c00344 	movi	r3,13
 8217660:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217664:	0005883a 	mov	r2,zero
 8217668:	00014206 	br	8217b74 <OSFlagPend+0x5a4>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 821766c:	e0bffc17 	ldw	r2,-16(fp)
 8217670:	10800003 	ldbu	r2,0(r2)
 8217674:	10803fcc 	andi	r2,r2,255
 8217678:	10800160 	cmpeqi	r2,r2,5
 821767c:	1000051e 	bne	r2,zero,8217694 <OSFlagPend+0xc4>
        *perr = OS_ERR_EVENT_TYPE;
 8217680:	e0800217 	ldw	r2,8(fp)
 8217684:	00c00044 	movi	r3,1
 8217688:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 821768c:	0005883a 	mov	r2,zero
 8217690:	00013806 	br	8217b74 <OSFlagPend+0x5a4>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 8217694:	e0fffe03 	ldbu	r3,-8(fp)
 8217698:	00bfe004 	movi	r2,-128
 821769c:	1884703a 	and	r2,r3,r2
 82176a0:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
 82176a4:	e0bfe603 	ldbu	r2,-104(fp)
 82176a8:	10000626 	beq	r2,zero,82176c4 <OSFlagPend+0xf4>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
 82176ac:	e0bffe03 	ldbu	r2,-8(fp)
 82176b0:	10801fcc 	andi	r2,r2,127
 82176b4:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
 82176b8:	00800044 	movi	r2,1
 82176bc:	e0bfe405 	stb	r2,-112(fp)
 82176c0:	00000106 	br	82176c8 <OSFlagPend+0xf8>
    } else {
        consume    = OS_FALSE;
 82176c4:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82176c8:	0005303a 	rdctl	r2,status
 82176cc:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82176d0:	e0fff617 	ldw	r3,-40(fp)
 82176d4:	00bfff84 	movi	r2,-2
 82176d8:	1884703a 	and	r2,r3,r2
 82176dc:	1001703a 	wrctl	status,r2
  
  return context;
 82176e0:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 82176e4:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
 82176e8:	e0bffe03 	ldbu	r2,-8(fp)
 82176ec:	10c00060 	cmpeqi	r3,r2,1
 82176f0:	1800921e 	bne	r3,zero,821793c <OSFlagPend+0x36c>
 82176f4:	10c00088 	cmpgei	r3,r2,2
 82176f8:	1800021e 	bne	r3,zero,8217704 <OSFlagPend+0x134>
 82176fc:	10006126 	beq	r2,zero,8217884 <OSFlagPend+0x2b4>
 8217700:	0000bb06 	br	82179f0 <OSFlagPend+0x420>
 8217704:	10c000a0 	cmpeqi	r3,r2,2
 8217708:	1800031e 	bne	r3,zero,8217718 <OSFlagPend+0x148>
 821770c:	108000e0 	cmpeqi	r2,r2,3
 8217710:	10002f1e 	bne	r2,zero,82177d0 <OSFlagPend+0x200>
 8217714:	0000b606 	br	82179f0 <OSFlagPend+0x420>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
 8217718:	e0bffc17 	ldw	r2,-16(fp)
 821771c:	10c0020b 	ldhu	r3,8(r2)
 8217720:	e0bffd0b 	ldhu	r2,-12(fp)
 8217724:	1884703a 	and	r2,r3,r2
 8217728:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 821772c:	e0ffe80b 	ldhu	r3,-96(fp)
 8217730:	e0bffd0b 	ldhu	r2,-12(fp)
 8217734:	1880171e 	bne	r3,r2,8217794 <OSFlagPend+0x1c4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8217738:	e0bfe403 	ldbu	r2,-112(fp)
 821773c:	10800058 	cmpnei	r2,r2,1
 8217740:	1000091e 	bne	r2,zero,8217768 <OSFlagPend+0x198>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 8217744:	e0bffc17 	ldw	r2,-16(fp)
 8217748:	1080020b 	ldhu	r2,8(r2)
 821774c:	1007883a 	mov	r3,r2
 8217750:	e0bfe80b 	ldhu	r2,-96(fp)
 8217754:	0084303a 	nor	r2,zero,r2
 8217758:	1884703a 	and	r2,r3,r2
 821775c:	1007883a 	mov	r3,r2
 8217760:	e0bffc17 	ldw	r2,-16(fp)
 8217764:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 8217768:	d0a07a17 	ldw	r2,-32280(gp)
 821776c:	e0ffe80b 	ldhu	r3,-96(fp)
 8217770:	10c00b0d 	sth	r3,44(r2)
 8217774:	e0bfe517 	ldw	r2,-108(fp)
 8217778:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821777c:	e0bfe717 	ldw	r2,-100(fp)
 8217780:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 8217784:	e0800217 	ldw	r2,8(fp)
 8217788:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 821778c:	e0bfe80b 	ldhu	r2,-96(fp)
 8217790:	0000f806 	br	8217b74 <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 8217794:	e13ffd0b 	ldhu	r4,-12(fp)
 8217798:	e17ffe03 	ldbu	r5,-8(fp)
 821779c:	e0bfff0b 	ldhu	r2,-4(fp)
 82177a0:	e0fff704 	addi	r3,fp,-36
 82177a4:	d8800015 	stw	r2,0(sp)
 82177a8:	280f883a 	mov	r7,r5
 82177ac:	200d883a 	mov	r6,r4
 82177b0:	180b883a 	mov	r5,r3
 82177b4:	e13ffc17 	ldw	r4,-16(fp)
 82177b8:	82180400 	call	8218040 <OS_FlagBlock>
 82177bc:	e0bfe517 	ldw	r2,-108(fp)
 82177c0:	e0bfe915 	stw	r2,-92(fp)
 82177c4:	e0bfe917 	ldw	r2,-92(fp)
 82177c8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 82177cc:	00009206 	br	8217a18 <OSFlagPend+0x448>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
 82177d0:	e0bffc17 	ldw	r2,-16(fp)
 82177d4:	10c0020b 	ldhu	r3,8(r2)
 82177d8:	e0bffd0b 	ldhu	r2,-12(fp)
 82177dc:	1884703a 	and	r2,r3,r2
 82177e0:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 82177e4:	e0bfe80b 	ldhu	r2,-96(fp)
 82177e8:	10001726 	beq	r2,zero,8217848 <OSFlagPend+0x278>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 82177ec:	e0bfe403 	ldbu	r2,-112(fp)
 82177f0:	10800058 	cmpnei	r2,r2,1
 82177f4:	1000091e 	bne	r2,zero,821781c <OSFlagPend+0x24c>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 82177f8:	e0bffc17 	ldw	r2,-16(fp)
 82177fc:	1080020b 	ldhu	r2,8(r2)
 8217800:	1007883a 	mov	r3,r2
 8217804:	e0bfe80b 	ldhu	r2,-96(fp)
 8217808:	0084303a 	nor	r2,zero,r2
 821780c:	1884703a 	and	r2,r3,r2
 8217810:	1007883a 	mov	r3,r2
 8217814:	e0bffc17 	ldw	r2,-16(fp)
 8217818:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 821781c:	d0a07a17 	ldw	r2,-32280(gp)
 8217820:	e0ffe80b 	ldhu	r3,-96(fp)
 8217824:	10c00b0d 	sth	r3,44(r2)
 8217828:	e0bfe517 	ldw	r2,-108(fp)
 821782c:	e0bfea15 	stw	r2,-88(fp)
 8217830:	e0bfea17 	ldw	r2,-88(fp)
 8217834:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 8217838:	e0800217 	ldw	r2,8(fp)
 821783c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 8217840:	e0bfe80b 	ldhu	r2,-96(fp)
 8217844:	0000cb06 	br	8217b74 <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 8217848:	e13ffd0b 	ldhu	r4,-12(fp)
 821784c:	e17ffe03 	ldbu	r5,-8(fp)
 8217850:	e0bfff0b 	ldhu	r2,-4(fp)
 8217854:	e0fff704 	addi	r3,fp,-36
 8217858:	d8800015 	stw	r2,0(sp)
 821785c:	280f883a 	mov	r7,r5
 8217860:	200d883a 	mov	r6,r4
 8217864:	180b883a 	mov	r5,r3
 8217868:	e13ffc17 	ldw	r4,-16(fp)
 821786c:	82180400 	call	8218040 <OS_FlagBlock>
 8217870:	e0bfe517 	ldw	r2,-108(fp)
 8217874:	e0bfeb15 	stw	r2,-84(fp)
 8217878:	e0bfeb17 	ldw	r2,-84(fp)
 821787c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 8217880:	00006506 	br	8217a18 <OSFlagPend+0x448>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 8217884:	e0bffc17 	ldw	r2,-16(fp)
 8217888:	1080020b 	ldhu	r2,8(r2)
 821788c:	0084303a 	nor	r2,zero,r2
 8217890:	1007883a 	mov	r3,r2
 8217894:	e0bffd0b 	ldhu	r2,-12(fp)
 8217898:	1884703a 	and	r2,r3,r2
 821789c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 82178a0:	e0ffe80b 	ldhu	r3,-96(fp)
 82178a4:	e0bffd0b 	ldhu	r2,-12(fp)
 82178a8:	1880151e 	bne	r3,r2,8217900 <OSFlagPend+0x330>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 82178ac:	e0bfe403 	ldbu	r2,-112(fp)
 82178b0:	10800058 	cmpnei	r2,r2,1
 82178b4:	1000071e 	bne	r2,zero,82178d4 <OSFlagPend+0x304>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 82178b8:	e0bffc17 	ldw	r2,-16(fp)
 82178bc:	10c0020b 	ldhu	r3,8(r2)
 82178c0:	e0bfe80b 	ldhu	r2,-96(fp)
 82178c4:	1884b03a 	or	r2,r3,r2
 82178c8:	1007883a 	mov	r3,r2
 82178cc:	e0bffc17 	ldw	r2,-16(fp)
 82178d0:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 82178d4:	d0a07a17 	ldw	r2,-32280(gp)
 82178d8:	e0ffe80b 	ldhu	r3,-96(fp)
 82178dc:	10c00b0d 	sth	r3,44(r2)
 82178e0:	e0bfe517 	ldw	r2,-108(fp)
 82178e4:	e0bfec15 	stw	r2,-80(fp)
 82178e8:	e0bfec17 	ldw	r2,-80(fp)
 82178ec:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 82178f0:	e0800217 	ldw	r2,8(fp)
 82178f4:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 82178f8:	e0bfe80b 	ldhu	r2,-96(fp)
 82178fc:	00009d06 	br	8217b74 <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 8217900:	e13ffd0b 	ldhu	r4,-12(fp)
 8217904:	e17ffe03 	ldbu	r5,-8(fp)
 8217908:	e0bfff0b 	ldhu	r2,-4(fp)
 821790c:	e0fff704 	addi	r3,fp,-36
 8217910:	d8800015 	stw	r2,0(sp)
 8217914:	280f883a 	mov	r7,r5
 8217918:	200d883a 	mov	r6,r4
 821791c:	180b883a 	mov	r5,r3
 8217920:	e13ffc17 	ldw	r4,-16(fp)
 8217924:	82180400 	call	8218040 <OS_FlagBlock>
 8217928:	e0bfe517 	ldw	r2,-108(fp)
 821792c:	e0bfed15 	stw	r2,-76(fp)
 8217930:	e0bfed17 	ldw	r2,-76(fp)
 8217934:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 8217938:	00003706 	br	8217a18 <OSFlagPend+0x448>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 821793c:	e0bffc17 	ldw	r2,-16(fp)
 8217940:	1080020b 	ldhu	r2,8(r2)
 8217944:	0084303a 	nor	r2,zero,r2
 8217948:	1007883a 	mov	r3,r2
 821794c:	e0bffd0b 	ldhu	r2,-12(fp)
 8217950:	1884703a 	and	r2,r3,r2
 8217954:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 8217958:	e0bfe80b 	ldhu	r2,-96(fp)
 821795c:	10001526 	beq	r2,zero,82179b4 <OSFlagPend+0x3e4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 8217960:	e0bfe403 	ldbu	r2,-112(fp)
 8217964:	10800058 	cmpnei	r2,r2,1
 8217968:	1000071e 	bne	r2,zero,8217988 <OSFlagPend+0x3b8>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 821796c:	e0bffc17 	ldw	r2,-16(fp)
 8217970:	10c0020b 	ldhu	r3,8(r2)
 8217974:	e0bfe80b 	ldhu	r2,-96(fp)
 8217978:	1884b03a 	or	r2,r3,r2
 821797c:	1007883a 	mov	r3,r2
 8217980:	e0bffc17 	ldw	r2,-16(fp)
 8217984:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 8217988:	d0a07a17 	ldw	r2,-32280(gp)
 821798c:	e0ffe80b 	ldhu	r3,-96(fp)
 8217990:	10c00b0d 	sth	r3,44(r2)
 8217994:	e0bfe517 	ldw	r2,-108(fp)
 8217998:	e0bfee15 	stw	r2,-72(fp)
 821799c:	e0bfee17 	ldw	r2,-72(fp)
 82179a0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 82179a4:	e0800217 	ldw	r2,8(fp)
 82179a8:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 82179ac:	e0bfe80b 	ldhu	r2,-96(fp)
 82179b0:	00007006 	br	8217b74 <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 82179b4:	e13ffd0b 	ldhu	r4,-12(fp)
 82179b8:	e17ffe03 	ldbu	r5,-8(fp)
 82179bc:	e0bfff0b 	ldhu	r2,-4(fp)
 82179c0:	e0fff704 	addi	r3,fp,-36
 82179c4:	d8800015 	stw	r2,0(sp)
 82179c8:	280f883a 	mov	r7,r5
 82179cc:	200d883a 	mov	r6,r4
 82179d0:	180b883a 	mov	r5,r3
 82179d4:	e13ffc17 	ldw	r4,-16(fp)
 82179d8:	82180400 	call	8218040 <OS_FlagBlock>
 82179dc:	e0bfe517 	ldw	r2,-108(fp)
 82179e0:	e0bfef15 	stw	r2,-68(fp)
 82179e4:	e0bfef17 	ldw	r2,-68(fp)
 82179e8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 82179ec:	00000a06 	br	8217a18 <OSFlagPend+0x448>
 82179f0:	e0bfe517 	ldw	r2,-108(fp)
 82179f4:	e0bff015 	stw	r2,-64(fp)
 82179f8:	e0bff017 	ldw	r2,-64(fp)
 82179fc:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 8217a00:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
 8217a04:	e0800217 	ldw	r2,8(fp)
 8217a08:	00c01bc4 	movi	r3,111
 8217a0c:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
 8217a10:	e0bfe80b 	ldhu	r2,-96(fp)
 8217a14:	00005706 	br	8217b74 <OSFlagPend+0x5a4>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
 8217a18:	82164a00 	call	82164a0 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217a1c:	0005303a 	rdctl	r2,status
 8217a20:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217a24:	e0fff117 	ldw	r3,-60(fp)
 8217a28:	00bfff84 	movi	r2,-2
 8217a2c:	1884703a 	and	r2,r3,r2
 8217a30:	1001703a 	wrctl	status,r2
  
  return context;
 8217a34:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
 8217a38:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
 8217a3c:	d0a07a17 	ldw	r2,-32280(gp)
 8217a40:	10800c43 	ldbu	r2,49(r2)
 8217a44:	10803fcc 	andi	r2,r2,255
 8217a48:	10001c26 	beq	r2,zero,8217abc <OSFlagPend+0x4ec>
        pend_stat                = OSTCBCur->OSTCBStatPend;
 8217a4c:	d0a07a17 	ldw	r2,-32280(gp)
 8217a50:	10800c43 	ldbu	r2,49(r2)
 8217a54:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 8217a58:	d0a07a17 	ldw	r2,-32280(gp)
 8217a5c:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
 8217a60:	e0bff704 	addi	r2,fp,-36
 8217a64:	1009883a 	mov	r4,r2
 8217a68:	82183740 	call	8218374 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
 8217a6c:	d0a07a17 	ldw	r2,-32280(gp)
 8217a70:	10000c05 	stb	zero,48(r2)
 8217a74:	e0bfe517 	ldw	r2,-108(fp)
 8217a78:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217a7c:	e0bff217 	ldw	r2,-56(fp)
 8217a80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
 8217a84:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
 8217a88:	e0bff303 	ldbu	r2,-52(fp)
 8217a8c:	108000a0 	cmpeqi	r2,r2,2
 8217a90:	10000426 	beq	r2,zero,8217aa4 <OSFlagPend+0x4d4>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
 8217a94:	e0800217 	ldw	r2,8(fp)
 8217a98:	00c00384 	movi	r3,14
 8217a9c:	10c00005 	stb	r3,0(r2)
                 break;
 8217aa0:	00000406 	br	8217ab4 <OSFlagPend+0x4e4>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
 8217aa4:	e0800217 	ldw	r2,8(fp)
 8217aa8:	00c00284 	movi	r3,10
 8217aac:	10c00005 	stb	r3,0(r2)
                 break;
 8217ab0:	0001883a 	nop
        }
        return (flags_rdy);
 8217ab4:	e0bfe80b 	ldhu	r2,-96(fp)
 8217ab8:	00002e06 	br	8217b74 <OSFlagPend+0x5a4>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
 8217abc:	d0a07a17 	ldw	r2,-32280(gp)
 8217ac0:	10800b0b 	ldhu	r2,44(r2)
 8217ac4:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
 8217ac8:	e0bfe403 	ldbu	r2,-112(fp)
 8217acc:	10800058 	cmpnei	r2,r2,1
 8217ad0:	1000211e 	bne	r2,zero,8217b58 <OSFlagPend+0x588>
        switch (wait_type) {
 8217ad4:	e0bffe03 	ldbu	r2,-8(fp)
 8217ad8:	10001616 	blt	r2,zero,8217b34 <OSFlagPend+0x564>
 8217adc:	10c00090 	cmplti	r3,r2,2
 8217ae0:	18000c1e 	bne	r3,zero,8217b14 <OSFlagPend+0x544>
 8217ae4:	10800108 	cmpgei	r2,r2,4
 8217ae8:	1000121e 	bne	r2,zero,8217b34 <OSFlagPend+0x564>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
 8217aec:	e0bffc17 	ldw	r2,-16(fp)
 8217af0:	1080020b 	ldhu	r2,8(r2)
 8217af4:	1007883a 	mov	r3,r2
 8217af8:	e0bfe80b 	ldhu	r2,-96(fp)
 8217afc:	0084303a 	nor	r2,zero,r2
 8217b00:	1884703a 	and	r2,r3,r2
 8217b04:	1007883a 	mov	r3,r2
 8217b08:	e0bffc17 	ldw	r2,-16(fp)
 8217b0c:	10c0020d 	sth	r3,8(r2)
                 break;
 8217b10:	00001106 	br	8217b58 <OSFlagPend+0x588>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
 8217b14:	e0bffc17 	ldw	r2,-16(fp)
 8217b18:	10c0020b 	ldhu	r3,8(r2)
 8217b1c:	e0bfe80b 	ldhu	r2,-96(fp)
 8217b20:	1884b03a 	or	r2,r3,r2
 8217b24:	1007883a 	mov	r3,r2
 8217b28:	e0bffc17 	ldw	r2,-16(fp)
 8217b2c:	10c0020d 	sth	r3,8(r2)
                 break;
 8217b30:	00000906 	br	8217b58 <OSFlagPend+0x588>
 8217b34:	e0bfe517 	ldw	r2,-108(fp)
 8217b38:	e0bff415 	stw	r2,-48(fp)
 8217b3c:	e0bff417 	ldw	r2,-48(fp)
 8217b40:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 8217b44:	e0800217 	ldw	r2,8(fp)
 8217b48:	00c01bc4 	movi	r3,111
 8217b4c:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
 8217b50:	0005883a 	mov	r2,zero
 8217b54:	00000706 	br	8217b74 <OSFlagPend+0x5a4>
 8217b58:	e0bfe517 	ldw	r2,-108(fp)
 8217b5c:	e0bff515 	stw	r2,-44(fp)
 8217b60:	e0bff517 	ldw	r2,-44(fp)
 8217b64:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
 8217b68:	e0800217 	ldw	r2,8(fp)
 8217b6c:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
 8217b70:	e0bfe80b 	ldhu	r2,-96(fp)
}
 8217b74:	e037883a 	mov	sp,fp
 8217b78:	dfc00117 	ldw	ra,4(sp)
 8217b7c:	df000017 	ldw	fp,0(sp)
 8217b80:	dec00204 	addi	sp,sp,8
 8217b84:	f800283a 	ret

08217b88 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
 8217b88:	defffb04 	addi	sp,sp,-20
 8217b8c:	df000415 	stw	fp,16(sp)
 8217b90:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 8217b94:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217b98:	0005303a 	rdctl	r2,status
 8217b9c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217ba0:	e0fffe17 	ldw	r3,-8(fp)
 8217ba4:	00bfff84 	movi	r2,-2
 8217ba8:	1884703a 	and	r2,r3,r2
 8217bac:	1001703a 	wrctl	status,r2
  
  return context;
 8217bb0:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 8217bb4:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
 8217bb8:	d0a07a17 	ldw	r2,-32280(gp)
 8217bbc:	10800b0b 	ldhu	r2,44(r2)
 8217bc0:	e0bffd0d 	sth	r2,-12(fp)
 8217bc4:	e0bffc17 	ldw	r2,-16(fp)
 8217bc8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217bcc:	e0bfff17 	ldw	r2,-4(fp)
 8217bd0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
 8217bd4:	e0bffd0b 	ldhu	r2,-12(fp)
}
 8217bd8:	e037883a 	mov	sp,fp
 8217bdc:	df000017 	ldw	fp,0(sp)
 8217be0:	dec00104 	addi	sp,sp,4
 8217be4:	f800283a 	ret

08217be8 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
 8217be8:	deffef04 	addi	sp,sp,-68
 8217bec:	dfc01015 	stw	ra,64(sp)
 8217bf0:	df000f15 	stw	fp,60(sp)
 8217bf4:	df000f04 	addi	fp,sp,60
 8217bf8:	e13ffc15 	stw	r4,-16(fp)
 8217bfc:	2807883a 	mov	r3,r5
 8217c00:	3005883a 	mov	r2,r6
 8217c04:	e1ffff15 	stw	r7,-4(fp)
 8217c08:	e0fffd0d 	sth	r3,-12(fp)
 8217c0c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
 8217c10:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 8217c14:	e0bfff17 	ldw	r2,-4(fp)
 8217c18:	1000021e 	bne	r2,zero,8217c24 <OSFlagPost+0x3c>
        return ((OS_FLAGS)0);
 8217c1c:	0005883a 	mov	r2,zero
 8217c20:	0000d106 	br	8217f68 <OSFlagPost+0x380>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
 8217c24:	e0bffc17 	ldw	r2,-16(fp)
 8217c28:	1000051e 	bne	r2,zero,8217c40 <OSFlagPost+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217c2c:	e0bfff17 	ldw	r2,-4(fp)
 8217c30:	00c01b84 	movi	r3,110
 8217c34:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217c38:	0005883a 	mov	r2,zero
 8217c3c:	0000ca06 	br	8217f68 <OSFlagPost+0x380>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
 8217c40:	e0bffc17 	ldw	r2,-16(fp)
 8217c44:	10800003 	ldbu	r2,0(r2)
 8217c48:	10803fcc 	andi	r2,r2,255
 8217c4c:	10800160 	cmpeqi	r2,r2,5
 8217c50:	1000051e 	bne	r2,zero,8217c68 <OSFlagPost+0x80>
        *perr = OS_ERR_EVENT_TYPE;
 8217c54:	e0bfff17 	ldw	r2,-4(fp)
 8217c58:	00c00044 	movi	r3,1
 8217c5c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217c60:	0005883a 	mov	r2,zero
 8217c64:	0000c006 	br	8217f68 <OSFlagPost+0x380>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217c68:	0005303a 	rdctl	r2,status
 8217c6c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217c70:	e0fffb17 	ldw	r3,-20(fp)
 8217c74:	00bfff84 	movi	r2,-2
 8217c78:	1884703a 	and	r2,r3,r2
 8217c7c:	1001703a 	wrctl	status,r2
  
  return context;
 8217c80:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 8217c84:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
 8217c88:	e0bffe03 	ldbu	r2,-8(fp)
 8217c8c:	10000326 	beq	r2,zero,8217c9c <OSFlagPost+0xb4>
 8217c90:	10800060 	cmpeqi	r2,r2,1
 8217c94:	10000b1e 	bne	r2,zero,8217cc4 <OSFlagPost+0xdc>
 8217c98:	00001206 	br	8217ce4 <OSFlagPost+0xfc>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
 8217c9c:	e0bffc17 	ldw	r2,-16(fp)
 8217ca0:	1080020b 	ldhu	r2,8(r2)
 8217ca4:	1007883a 	mov	r3,r2
 8217ca8:	e0bffd0b 	ldhu	r2,-12(fp)
 8217cac:	0084303a 	nor	r2,zero,r2
 8217cb0:	1884703a 	and	r2,r3,r2
 8217cb4:	1007883a 	mov	r3,r2
 8217cb8:	e0bffc17 	ldw	r2,-16(fp)
 8217cbc:	10c0020d 	sth	r3,8(r2)
             break;
 8217cc0:	00001106 	br	8217d08 <OSFlagPost+0x120>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
 8217cc4:	e0bffc17 	ldw	r2,-16(fp)
 8217cc8:	10c0020b 	ldhu	r3,8(r2)
 8217ccc:	e0bffd0b 	ldhu	r2,-12(fp)
 8217cd0:	1884b03a 	or	r2,r3,r2
 8217cd4:	1007883a 	mov	r3,r2
 8217cd8:	e0bffc17 	ldw	r2,-16(fp)
 8217cdc:	10c0020d 	sth	r3,8(r2)
             break;
 8217ce0:	00000906 	br	8217d08 <OSFlagPost+0x120>
 8217ce4:	e0bff317 	ldw	r2,-52(fp)
 8217ce8:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217cec:	e0bff417 	ldw	r2,-48(fp)
 8217cf0:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
 8217cf4:	e0bfff17 	ldw	r2,-4(fp)
 8217cf8:	00c01c44 	movi	r3,113
 8217cfc:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
 8217d00:	0005883a 	mov	r2,zero
 8217d04:	00009806 	br	8217f68 <OSFlagPost+0x380>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
 8217d08:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 8217d0c:	e0bffc17 	ldw	r2,-16(fp)
 8217d10:	10800117 	ldw	r2,4(r2)
 8217d14:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 8217d18:	00007706 	br	8217ef8 <OSFlagPost+0x310>
        switch (pnode->OSFlagNodeWaitType) {
 8217d1c:	e0bff117 	ldw	r2,-60(fp)
 8217d20:	10800483 	ldbu	r2,18(r2)
 8217d24:	10803fcc 	andi	r2,r2,255
 8217d28:	10c00060 	cmpeqi	r3,r2,1
 8217d2c:	18004a1e 	bne	r3,zero,8217e58 <OSFlagPost+0x270>
 8217d30:	10c00088 	cmpgei	r3,r2,2
 8217d34:	1800021e 	bne	r3,zero,8217d40 <OSFlagPost+0x158>
 8217d38:	10002f26 	beq	r2,zero,8217df8 <OSFlagPost+0x210>
 8217d3c:	00005b06 	br	8217eac <OSFlagPost+0x2c4>
 8217d40:	10c000a0 	cmpeqi	r3,r2,2
 8217d44:	1800031e 	bne	r3,zero,8217d54 <OSFlagPost+0x16c>
 8217d48:	108000e0 	cmpeqi	r2,r2,3
 8217d4c:	1000171e 	bne	r2,zero,8217dac <OSFlagPost+0x1c4>
 8217d50:	00005606 	br	8217eac <OSFlagPost+0x2c4>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217d54:	e0bffc17 	ldw	r2,-16(fp)
 8217d58:	10c0020b 	ldhu	r3,8(r2)
 8217d5c:	e0bff117 	ldw	r2,-60(fp)
 8217d60:	1080040b 	ldhu	r2,16(r2)
 8217d64:	1884703a 	and	r2,r3,r2
 8217d68:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 8217d6c:	e0bff117 	ldw	r2,-60(fp)
 8217d70:	1080040b 	ldhu	r2,16(r2)
 8217d74:	10ffffcc 	andi	r3,r2,65535
 8217d78:	e0bff60b 	ldhu	r2,-40(fp)
 8217d7c:	1880541e 	bne	r3,r2,8217ed0 <OSFlagPost+0x2e8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217d80:	e0bff60b 	ldhu	r2,-40(fp)
 8217d84:	100b883a 	mov	r5,r2
 8217d88:	e13ff117 	ldw	r4,-60(fp)
 8217d8c:	82182800 	call	8218280 <OS_FlagTaskRdy>
 8217d90:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217d94:	e0bff683 	ldbu	r2,-38(fp)
 8217d98:	10800058 	cmpnei	r2,r2,1
 8217d9c:	10004c1e 	bne	r2,zero,8217ed0 <OSFlagPost+0x2e8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217da0:	00800044 	movi	r2,1
 8217da4:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217da8:	00004906 	br	8217ed0 <OSFlagPost+0x2e8>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217dac:	e0bffc17 	ldw	r2,-16(fp)
 8217db0:	10c0020b 	ldhu	r3,8(r2)
 8217db4:	e0bff117 	ldw	r2,-60(fp)
 8217db8:	1080040b 	ldhu	r2,16(r2)
 8217dbc:	1884703a 	and	r2,r3,r2
 8217dc0:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 8217dc4:	e0bff60b 	ldhu	r2,-40(fp)
 8217dc8:	10004326 	beq	r2,zero,8217ed8 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217dcc:	e0bff60b 	ldhu	r2,-40(fp)
 8217dd0:	100b883a 	mov	r5,r2
 8217dd4:	e13ff117 	ldw	r4,-60(fp)
 8217dd8:	82182800 	call	8218280 <OS_FlagTaskRdy>
 8217ddc:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217de0:	e0bff683 	ldbu	r2,-38(fp)
 8217de4:	10800058 	cmpnei	r2,r2,1
 8217de8:	10003b1e 	bne	r2,zero,8217ed8 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217dec:	00800044 	movi	r2,1
 8217df0:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217df4:	00003806 	br	8217ed8 <OSFlagPost+0x2f0>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217df8:	e0bffc17 	ldw	r2,-16(fp)
 8217dfc:	1080020b 	ldhu	r2,8(r2)
 8217e00:	0084303a 	nor	r2,zero,r2
 8217e04:	1007883a 	mov	r3,r2
 8217e08:	e0bff117 	ldw	r2,-60(fp)
 8217e0c:	1080040b 	ldhu	r2,16(r2)
 8217e10:	1884703a 	and	r2,r3,r2
 8217e14:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 8217e18:	e0bff117 	ldw	r2,-60(fp)
 8217e1c:	1080040b 	ldhu	r2,16(r2)
 8217e20:	10ffffcc 	andi	r3,r2,65535
 8217e24:	e0bff60b 	ldhu	r2,-40(fp)
 8217e28:	18802d1e 	bne	r3,r2,8217ee0 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217e2c:	e0bff60b 	ldhu	r2,-40(fp)
 8217e30:	100b883a 	mov	r5,r2
 8217e34:	e13ff117 	ldw	r4,-60(fp)
 8217e38:	82182800 	call	8218280 <OS_FlagTaskRdy>
 8217e3c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217e40:	e0bff683 	ldbu	r2,-38(fp)
 8217e44:	10800058 	cmpnei	r2,r2,1
 8217e48:	1000251e 	bne	r2,zero,8217ee0 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217e4c:	00800044 	movi	r2,1
 8217e50:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217e54:	00002206 	br	8217ee0 <OSFlagPost+0x2f8>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 8217e58:	e0bffc17 	ldw	r2,-16(fp)
 8217e5c:	1080020b 	ldhu	r2,8(r2)
 8217e60:	0084303a 	nor	r2,zero,r2
 8217e64:	1007883a 	mov	r3,r2
 8217e68:	e0bff117 	ldw	r2,-60(fp)
 8217e6c:	1080040b 	ldhu	r2,16(r2)
 8217e70:	1884703a 	and	r2,r3,r2
 8217e74:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 8217e78:	e0bff60b 	ldhu	r2,-40(fp)
 8217e7c:	10001a26 	beq	r2,zero,8217ee8 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 8217e80:	e0bff60b 	ldhu	r2,-40(fp)
 8217e84:	100b883a 	mov	r5,r2
 8217e88:	e13ff117 	ldw	r4,-60(fp)
 8217e8c:	82182800 	call	8218280 <OS_FlagTaskRdy>
 8217e90:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 8217e94:	e0bff683 	ldbu	r2,-38(fp)
 8217e98:	10800058 	cmpnei	r2,r2,1
 8217e9c:	1000121e 	bne	r2,zero,8217ee8 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 8217ea0:	00800044 	movi	r2,1
 8217ea4:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 8217ea8:	00000f06 	br	8217ee8 <OSFlagPost+0x300>
 8217eac:	e0bff317 	ldw	r2,-52(fp)
 8217eb0:	e0bff515 	stw	r2,-44(fp)
 8217eb4:	e0bff517 	ldw	r2,-44(fp)
 8217eb8:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 8217ebc:	e0bfff17 	ldw	r2,-4(fp)
 8217ec0:	00c01bc4 	movi	r3,111
 8217ec4:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
 8217ec8:	0005883a 	mov	r2,zero
 8217ecc:	00002606 	br	8217f68 <OSFlagPost+0x380>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217ed0:	0001883a 	nop
 8217ed4:	00000506 	br	8217eec <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217ed8:	0001883a 	nop
 8217edc:	00000306 	br	8217eec <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217ee0:	0001883a 	nop
 8217ee4:	00000106 	br	8217eec <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 8217ee8:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
 8217eec:	e0bff117 	ldw	r2,-60(fp)
 8217ef0:	10800017 	ldw	r2,0(r2)
 8217ef4:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 8217ef8:	e0bff117 	ldw	r2,-60(fp)
 8217efc:	103f871e 	bne	r2,zero,8217d1c <OSFlagPost+0x134>
 8217f00:	e0bff317 	ldw	r2,-52(fp)
 8217f04:	e0bff715 	stw	r2,-36(fp)
 8217f08:	e0bff717 	ldw	r2,-36(fp)
 8217f0c:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
 8217f10:	e0bff203 	ldbu	r2,-56(fp)
 8217f14:	10800058 	cmpnei	r2,r2,1
 8217f18:	1000011e 	bne	r2,zero,8217f20 <OSFlagPost+0x338>
        OS_Sched();
 8217f1c:	82164a00 	call	82164a0 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217f20:	0005303a 	rdctl	r2,status
 8217f24:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217f28:	e0fffa17 	ldw	r3,-24(fp)
 8217f2c:	00bfff84 	movi	r2,-2
 8217f30:	1884703a 	and	r2,r3,r2
 8217f34:	1001703a 	wrctl	status,r2
  
  return context;
 8217f38:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 8217f3c:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
 8217f40:	e0bffc17 	ldw	r2,-16(fp)
 8217f44:	1080020b 	ldhu	r2,8(r2)
 8217f48:	e0bff90d 	sth	r2,-28(fp)
 8217f4c:	e0bff317 	ldw	r2,-52(fp)
 8217f50:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8217f54:	e0bff817 	ldw	r2,-32(fp)
 8217f58:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
 8217f5c:	e0bfff17 	ldw	r2,-4(fp)
 8217f60:	10000005 	stb	zero,0(r2)
    return (flags_cur);
 8217f64:	e0bff90b 	ldhu	r2,-28(fp)
}
 8217f68:	e037883a 	mov	sp,fp
 8217f6c:	dfc00117 	ldw	ra,4(sp)
 8217f70:	df000017 	ldw	fp,0(sp)
 8217f74:	dec00204 	addi	sp,sp,8
 8217f78:	f800283a 	ret

08217f7c <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
 8217f7c:	defff904 	addi	sp,sp,-28
 8217f80:	df000615 	stw	fp,24(sp)
 8217f84:	df000604 	addi	fp,sp,24
 8217f88:	e13ffe15 	stw	r4,-8(fp)
 8217f8c:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
 8217f90:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
 8217f94:	e0bfff17 	ldw	r2,-4(fp)
 8217f98:	1000021e 	bne	r2,zero,8217fa4 <OSFlagQuery+0x28>
        return ((OS_FLAGS)0);
 8217f9c:	0005883a 	mov	r2,zero
 8217fa0:	00002306 	br	8218030 <OSFlagQuery+0xb4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
 8217fa4:	e0bffe17 	ldw	r2,-8(fp)
 8217fa8:	1000051e 	bne	r2,zero,8217fc0 <OSFlagQuery+0x44>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 8217fac:	e0bfff17 	ldw	r2,-4(fp)
 8217fb0:	00c01b84 	movi	r3,110
 8217fb4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217fb8:	0005883a 	mov	r2,zero
 8217fbc:	00001c06 	br	8218030 <OSFlagQuery+0xb4>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
 8217fc0:	e0bffe17 	ldw	r2,-8(fp)
 8217fc4:	10800003 	ldbu	r2,0(r2)
 8217fc8:	10803fcc 	andi	r2,r2,255
 8217fcc:	10800160 	cmpeqi	r2,r2,5
 8217fd0:	1000051e 	bne	r2,zero,8217fe8 <OSFlagQuery+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 8217fd4:	e0bfff17 	ldw	r2,-4(fp)
 8217fd8:	00c00044 	movi	r3,1
 8217fdc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 8217fe0:	0005883a 	mov	r2,zero
 8217fe4:	00001206 	br	8218030 <OSFlagQuery+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8217fe8:	0005303a 	rdctl	r2,status
 8217fec:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8217ff0:	e0fffc17 	ldw	r3,-16(fp)
 8217ff4:	00bfff84 	movi	r2,-2
 8217ff8:	1884703a 	and	r2,r3,r2
 8217ffc:	1001703a 	wrctl	status,r2
  
  return context;
 8218000:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8218004:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
 8218008:	e0bffe17 	ldw	r2,-8(fp)
 821800c:	1080020b 	ldhu	r2,8(r2)
 8218010:	e0bffb0d 	sth	r2,-20(fp)
 8218014:	e0bffa17 	ldw	r2,-24(fp)
 8218018:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821801c:	e0bffd17 	ldw	r2,-12(fp)
 8218020:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8218024:	e0bfff17 	ldw	r2,-4(fp)
 8218028:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
 821802c:	e0bffb0b 	ldhu	r2,-20(fp)
}
 8218030:	e037883a 	mov	sp,fp
 8218034:	df000017 	ldw	fp,0(sp)
 8218038:	dec00104 	addi	sp,sp,4
 821803c:	f800283a 	ret

08218040 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
 8218040:	defff804 	addi	sp,sp,-32
 8218044:	df000715 	stw	fp,28(sp)
 8218048:	df000704 	addi	fp,sp,28
 821804c:	e13ffb15 	stw	r4,-20(fp)
 8218050:	e17ffc15 	stw	r5,-16(fp)
 8218054:	3009883a 	mov	r4,r6
 8218058:	3807883a 	mov	r3,r7
 821805c:	e0800117 	ldw	r2,4(fp)
 8218060:	e13ffd0d 	sth	r4,-12(fp)
 8218064:	e0fffe05 	stb	r3,-8(fp)
 8218068:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
 821806c:	d0a07a17 	ldw	r2,-32280(gp)
 8218070:	d0e07a17 	ldw	r3,-32280(gp)
 8218074:	18c00c03 	ldbu	r3,48(r3)
 8218078:	18c00814 	ori	r3,r3,32
 821807c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
 8218080:	d0a07a17 	ldw	r2,-32280(gp)
 8218084:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
 8218088:	d0a07a17 	ldw	r2,-32280(gp)
 821808c:	e0ffff0b 	ldhu	r3,-4(fp)
 8218090:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
 8218094:	d0a07a17 	ldw	r2,-32280(gp)
 8218098:	e0fffc17 	ldw	r3,-16(fp)
 821809c:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
 82180a0:	e0bffc17 	ldw	r2,-16(fp)
 82180a4:	e0fffd0b 	ldhu	r3,-12(fp)
 82180a8:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
 82180ac:	e0bffc17 	ldw	r2,-16(fp)
 82180b0:	e0fffe03 	ldbu	r3,-8(fp)
 82180b4:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
 82180b8:	d0e07a17 	ldw	r3,-32280(gp)
 82180bc:	e0bffc17 	ldw	r2,-16(fp)
 82180c0:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
 82180c4:	e0bffb17 	ldw	r2,-20(fp)
 82180c8:	10c00117 	ldw	r3,4(r2)
 82180cc:	e0bffc17 	ldw	r2,-16(fp)
 82180d0:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
 82180d4:	e0bffc17 	ldw	r2,-16(fp)
 82180d8:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
 82180dc:	e0bffc17 	ldw	r2,-16(fp)
 82180e0:	e0fffb17 	ldw	r3,-20(fp)
 82180e4:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 82180e8:	e0bffb17 	ldw	r2,-20(fp)
 82180ec:	10800117 	ldw	r2,4(r2)
 82180f0:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
 82180f4:	e0bff917 	ldw	r2,-28(fp)
 82180f8:	10000326 	beq	r2,zero,8218108 <OS_FlagBlock+0xc8>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
 82180fc:	e0bff917 	ldw	r2,-28(fp)
 8218100:	e0fffc17 	ldw	r3,-16(fp)
 8218104:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
 8218108:	e0bffb17 	ldw	r2,-20(fp)
 821810c:	e0fffc17 	ldw	r3,-16(fp)
 8218110:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
 8218114:	d0a07a17 	ldw	r2,-32280(gp)
 8218118:	10800d03 	ldbu	r2,52(r2)
 821811c:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 8218120:	e0fffa03 	ldbu	r3,-24(fp)
 8218124:	e13ffa03 	ldbu	r4,-24(fp)
 8218128:	d0a07744 	addi	r2,gp,-32291
 821812c:	2085883a 	add	r2,r4,r2
 8218130:	10800003 	ldbu	r2,0(r2)
 8218134:	1009883a 	mov	r4,r2
 8218138:	d0a07a17 	ldw	r2,-32280(gp)
 821813c:	10800d43 	ldbu	r2,53(r2)
 8218140:	0084303a 	nor	r2,zero,r2
 8218144:	2084703a 	and	r2,r4,r2
 8218148:	1009883a 	mov	r4,r2
 821814c:	d0a07744 	addi	r2,gp,-32291
 8218150:	1885883a 	add	r2,r3,r2
 8218154:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
 8218158:	e0fffa03 	ldbu	r3,-24(fp)
 821815c:	d0a07744 	addi	r2,gp,-32291
 8218160:	1885883a 	add	r2,r3,r2
 8218164:	10800003 	ldbu	r2,0(r2)
 8218168:	10803fcc 	andi	r2,r2,255
 821816c:	1000071e 	bne	r2,zero,821818c <OS_FlagBlock+0x14c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 8218170:	d0a07a17 	ldw	r2,-32280(gp)
 8218174:	10800d83 	ldbu	r2,54(r2)
 8218178:	0084303a 	nor	r2,zero,r2
 821817c:	1007883a 	mov	r3,r2
 8218180:	d0a07703 	ldbu	r2,-32292(gp)
 8218184:	1884703a 	and	r2,r3,r2
 8218188:	d0a07705 	stb	r2,-32292(gp)
    }
}
 821818c:	0001883a 	nop
 8218190:	e037883a 	mov	sp,fp
 8218194:	df000017 	ldw	fp,0(sp)
 8218198:	dec00104 	addi	sp,sp,4
 821819c:	f800283a 	ret

082181a0 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
 82181a0:	defffb04 	addi	sp,sp,-20
 82181a4:	dfc00415 	stw	ra,16(sp)
 82181a8:	df000315 	stw	fp,12(sp)
 82181ac:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
 82181b0:	0140dc04 	movi	r5,880
 82181b4:	010209b4 	movhi	r4,2086
 82181b8:	212a3e04 	addi	r4,r4,-22280
 82181bc:	82163e40 	call	82163e4 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
 82181c0:	008209b4 	movhi	r2,2086
 82181c4:	10aa3e04 	addi	r2,r2,-22280
 82181c8:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
 82181cc:	008209b4 	movhi	r2,2086
 82181d0:	10aa4904 	addi	r2,r2,-22236
 82181d4:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 82181d8:	e03ffd0d 	sth	zero,-12(fp)
 82181dc:	00001306 	br	821822c <OS_FlagInit+0x8c>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 82181e0:	e0bffe17 	ldw	r2,-8(fp)
 82181e4:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
 82181e8:	e0bffe17 	ldw	r2,-8(fp)
 82181ec:	e0ffff17 	ldw	r3,-4(fp)
 82181f0:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
 82181f4:	e0bffe17 	ldw	r2,-8(fp)
 82181f8:	00c00fc4 	movi	r3,63
 82181fc:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 8218200:	e0bffe17 	ldw	r2,-8(fp)
 8218204:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
 8218208:	e0bffe17 	ldw	r2,-8(fp)
 821820c:	10800b04 	addi	r2,r2,44
 8218210:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
 8218214:	e0bfff17 	ldw	r2,-4(fp)
 8218218:	10800b04 	addi	r2,r2,44
 821821c:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 8218220:	e0bffd0b 	ldhu	r2,-12(fp)
 8218224:	10800044 	addi	r2,r2,1
 8218228:	e0bffd0d 	sth	r2,-12(fp)
 821822c:	e0bffd0b 	ldhu	r2,-12(fp)
 8218230:	108004f0 	cmpltui	r2,r2,19
 8218234:	103fea1e 	bne	r2,zero,82181e0 <OS_FlagInit+0x40>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 8218238:	e0bffe17 	ldw	r2,-8(fp)
 821823c:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
 8218240:	e0bffe17 	ldw	r2,-8(fp)
 8218244:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
 8218248:	e0bffe17 	ldw	r2,-8(fp)
 821824c:	00c00fc4 	movi	r3,63
 8218250:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 8218254:	e0bffe17 	ldw	r2,-8(fp)
 8218258:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
 821825c:	008209b4 	movhi	r2,2086
 8218260:	10aa3e04 	addi	r2,r2,-22280
 8218264:	d0a07c15 	stw	r2,-32272(gp)
#endif
}
 8218268:	0001883a 	nop
 821826c:	e037883a 	mov	sp,fp
 8218270:	dfc00117 	ldw	ra,4(sp)
 8218274:	df000017 	ldw	fp,0(sp)
 8218278:	dec00204 	addi	sp,sp,8
 821827c:	f800283a 	ret

08218280 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
 8218280:	defffa04 	addi	sp,sp,-24
 8218284:	dfc00515 	stw	ra,20(sp)
 8218288:	df000415 	stw	fp,16(sp)
 821828c:	df000404 	addi	fp,sp,16
 8218290:	e13ffe15 	stw	r4,-8(fp)
 8218294:	2805883a 	mov	r2,r5
 8218298:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
 821829c:	e0bffe17 	ldw	r2,-8(fp)
 82182a0:	10800217 	ldw	r2,8(r2)
 82182a4:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
 82182a8:	e0bffd17 	ldw	r2,-12(fp)
 82182ac:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
 82182b0:	e0bffd17 	ldw	r2,-12(fp)
 82182b4:	e0ffff0b 	ldhu	r3,-4(fp)
 82182b8:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
 82182bc:	e0bffd17 	ldw	r2,-12(fp)
 82182c0:	10c00c03 	ldbu	r3,48(r2)
 82182c4:	00bff7c4 	movi	r2,-33
 82182c8:	1884703a 	and	r2,r3,r2
 82182cc:	1007883a 	mov	r3,r2
 82182d0:	e0bffd17 	ldw	r2,-12(fp)
 82182d4:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
 82182d8:	e0bffd17 	ldw	r2,-12(fp)
 82182dc:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
 82182e0:	e0bffd17 	ldw	r2,-12(fp)
 82182e4:	10800c03 	ldbu	r2,48(r2)
 82182e8:	10803fcc 	andi	r2,r2,255
 82182ec:	1000181e 	bne	r2,zero,8218350 <OS_FlagTaskRdy+0xd0>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
 82182f0:	e0bffd17 	ldw	r2,-12(fp)
 82182f4:	10c00d83 	ldbu	r3,54(r2)
 82182f8:	d0a07703 	ldbu	r2,-32292(gp)
 82182fc:	1884b03a 	or	r2,r3,r2
 8218300:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 8218304:	e0bffd17 	ldw	r2,-12(fp)
 8218308:	10800d03 	ldbu	r2,52(r2)
 821830c:	10c03fcc 	andi	r3,r2,255
 8218310:	e0bffd17 	ldw	r2,-12(fp)
 8218314:	10800d03 	ldbu	r2,52(r2)
 8218318:	11003fcc 	andi	r4,r2,255
 821831c:	d0a07744 	addi	r2,gp,-32291
 8218320:	2085883a 	add	r2,r4,r2
 8218324:	11000003 	ldbu	r4,0(r2)
 8218328:	e0bffd17 	ldw	r2,-12(fp)
 821832c:	10800d43 	ldbu	r2,53(r2)
 8218330:	2084b03a 	or	r2,r4,r2
 8218334:	1009883a 	mov	r4,r2
 8218338:	d0a07744 	addi	r2,gp,-32291
 821833c:	1885883a 	add	r2,r3,r2
 8218340:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
 8218344:	00800044 	movi	r2,1
 8218348:	e0bffc05 	stb	r2,-16(fp)
 821834c:	00000106 	br	8218354 <OS_FlagTaskRdy+0xd4>
    } else {
        sched                   = OS_FALSE;
 8218350:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
 8218354:	e13ffe17 	ldw	r4,-8(fp)
 8218358:	82183740 	call	8218374 <OS_FlagUnlink>
    return (sched);
 821835c:	e0bffc03 	ldbu	r2,-16(fp)
}
 8218360:	e037883a 	mov	sp,fp
 8218364:	dfc00117 	ldw	ra,4(sp)
 8218368:	df000017 	ldw	fp,0(sp)
 821836c:	dec00204 	addi	sp,sp,8
 8218370:	f800283a 	ret

08218374 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
 8218374:	defffa04 	addi	sp,sp,-24
 8218378:	df000515 	stw	fp,20(sp)
 821837c:	df000504 	addi	fp,sp,20
 8218380:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
 8218384:	e0bfff17 	ldw	r2,-4(fp)
 8218388:	10800117 	ldw	r2,4(r2)
 821838c:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 8218390:	e0bfff17 	ldw	r2,-4(fp)
 8218394:	10800017 	ldw	r2,0(r2)
 8218398:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
 821839c:	e0bffb17 	ldw	r2,-20(fp)
 82183a0:	10000b1e 	bne	r2,zero,82183d0 <OS_FlagUnlink+0x5c>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
 82183a4:	e0bfff17 	ldw	r2,-4(fp)
 82183a8:	10800317 	ldw	r2,12(r2)
 82183ac:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
 82183b0:	e0bffd17 	ldw	r2,-12(fp)
 82183b4:	e0fffc17 	ldw	r3,-16(fp)
 82183b8:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
 82183bc:	e0bffc17 	ldw	r2,-16(fp)
 82183c0:	10000b26 	beq	r2,zero,82183f0 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
 82183c4:	e0bffc17 	ldw	r2,-16(fp)
 82183c8:	10000115 	stw	zero,4(r2)
 82183cc:	00000806 	br	82183f0 <OS_FlagUnlink+0x7c>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
 82183d0:	e0bffb17 	ldw	r2,-20(fp)
 82183d4:	e0fffc17 	ldw	r3,-16(fp)
 82183d8:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
 82183dc:	e0bffc17 	ldw	r2,-16(fp)
 82183e0:	10000326 	beq	r2,zero,82183f0 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
 82183e4:	e0bffc17 	ldw	r2,-16(fp)
 82183e8:	e0fffb17 	ldw	r3,-20(fp)
 82183ec:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
 82183f0:	e0bfff17 	ldw	r2,-4(fp)
 82183f4:	10800217 	ldw	r2,8(r2)
 82183f8:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
 82183fc:	e0bffe17 	ldw	r2,-8(fp)
 8218400:	10000a15 	stw	zero,40(r2)
#endif
}
 8218404:	0001883a 	nop
 8218408:	e037883a 	mov	sp,fp
 821840c:	df000017 	ldw	fp,0(sp)
 8218410:	dec00104 	addi	sp,sp,4
 8218414:	f800283a 	ret

08218418 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
 8218418:	defff404 	addi	sp,sp,-48
 821841c:	df000b15 	stw	fp,44(sp)
 8218420:	df000b04 	addi	fp,sp,44
 8218424:	e13ffc15 	stw	r4,-16(fp)
 8218428:	e17ffd15 	stw	r5,-12(fp)
 821842c:	e1bffe15 	stw	r6,-8(fp)
 8218430:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8218434:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 8218438:	e0bfff17 	ldw	r2,-4(fp)
 821843c:	1000021e 	bne	r2,zero,8218448 <OSMemCreate+0x30>
        return ((OS_MEM *)0);
 8218440:	0005883a 	mov	r2,zero
 8218444:	00006506 	br	82185dc <OSMemCreate+0x1c4>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
 8218448:	e0bffc17 	ldw	r2,-16(fp)
 821844c:	1000051e 	bne	r2,zero,8218464 <OSMemCreate+0x4c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 8218450:	e0bfff17 	ldw	r2,-4(fp)
 8218454:	00c01884 	movi	r3,98
 8218458:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 821845c:	0005883a 	mov	r2,zero
 8218460:	00005e06 	br	82185dc <OSMemCreate+0x1c4>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
 8218464:	e0bffc17 	ldw	r2,-16(fp)
 8218468:	108000cc 	andi	r2,r2,3
 821846c:	10000526 	beq	r2,zero,8218484 <OSMemCreate+0x6c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 8218470:	e0bfff17 	ldw	r2,-4(fp)
 8218474:	00c01884 	movi	r3,98
 8218478:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 821847c:	0005883a 	mov	r2,zero
 8218480:	00005606 	br	82185dc <OSMemCreate+0x1c4>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
 8218484:	e0bffd17 	ldw	r2,-12(fp)
 8218488:	108000a8 	cmpgeui	r2,r2,2
 821848c:	1000051e 	bne	r2,zero,82184a4 <OSMemCreate+0x8c>
        *perr = OS_ERR_MEM_INVALID_BLKS;
 8218490:	e0bfff17 	ldw	r2,-4(fp)
 8218494:	00c016c4 	movi	r3,91
 8218498:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 821849c:	0005883a 	mov	r2,zero
 82184a0:	00004e06 	br	82185dc <OSMemCreate+0x1c4>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
 82184a4:	e0bffe17 	ldw	r2,-8(fp)
 82184a8:	10800128 	cmpgeui	r2,r2,4
 82184ac:	1000051e 	bne	r2,zero,82184c4 <OSMemCreate+0xac>
        *perr = OS_ERR_MEM_INVALID_SIZE;
 82184b0:	e0bfff17 	ldw	r2,-4(fp)
 82184b4:	00c01704 	movi	r3,92
 82184b8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 82184bc:	0005883a 	mov	r2,zero
 82184c0:	00004606 	br	82185dc <OSMemCreate+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82184c4:	0005303a 	rdctl	r2,status
 82184c8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82184cc:	e0fffb17 	ldw	r3,-20(fp)
 82184d0:	00bfff84 	movi	r2,-2
 82184d4:	1884703a 	and	r2,r3,r2
 82184d8:	1001703a 	wrctl	status,r2
  
  return context;
 82184dc:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 82184e0:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
 82184e4:	d0a07417 	ldw	r2,-32304(gp)
 82184e8:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
 82184ec:	d0a07417 	ldw	r2,-32304(gp)
 82184f0:	10000326 	beq	r2,zero,8218500 <OSMemCreate+0xe8>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
 82184f4:	d0a07417 	ldw	r2,-32304(gp)
 82184f8:	10800117 	ldw	r2,4(r2)
 82184fc:	d0a07415 	stw	r2,-32304(gp)
 8218500:	e0bff817 	ldw	r2,-32(fp)
 8218504:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218508:	e0bff917 	ldw	r2,-28(fp)
 821850c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
 8218510:	e0bffa17 	ldw	r2,-24(fp)
 8218514:	1000051e 	bne	r2,zero,821852c <OSMemCreate+0x114>
        *perr = OS_ERR_MEM_INVALID_PART;
 8218518:	e0bfff17 	ldw	r2,-4(fp)
 821851c:	00c01684 	movi	r3,90
 8218520:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 8218524:	0005883a 	mov	r2,zero
 8218528:	00002c06 	br	82185dc <OSMemCreate+0x1c4>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
 821852c:	e0bffc17 	ldw	r2,-16(fp)
 8218530:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
 8218534:	e0fffc17 	ldw	r3,-16(fp)
 8218538:	e0bffe17 	ldw	r2,-8(fp)
 821853c:	1885883a 	add	r2,r3,r2
 8218540:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
 8218544:	e03ff715 	stw	zero,-36(fp)
 8218548:	00000c06 	br	821857c <OSMemCreate+0x164>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
 821854c:	e0bff617 	ldw	r2,-40(fp)
 8218550:	e0fff517 	ldw	r3,-44(fp)
 8218554:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
 8218558:	e0bff517 	ldw	r2,-44(fp)
 821855c:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
 8218560:	e0fff517 	ldw	r3,-44(fp)
 8218564:	e0bffe17 	ldw	r2,-8(fp)
 8218568:	1885883a 	add	r2,r3,r2
 821856c:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
 8218570:	e0bff717 	ldw	r2,-36(fp)
 8218574:	10800044 	addi	r2,r2,1
 8218578:	e0bff715 	stw	r2,-36(fp)
 821857c:	e0bffd17 	ldw	r2,-12(fp)
 8218580:	10bfffc4 	addi	r2,r2,-1
 8218584:	e0fff717 	ldw	r3,-36(fp)
 8218588:	18bff036 	bltu	r3,r2,821854c <OSMemCreate+0x134>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
 821858c:	e0bff617 	ldw	r2,-40(fp)
 8218590:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
 8218594:	e0bffa17 	ldw	r2,-24(fp)
 8218598:	e0fffc17 	ldw	r3,-16(fp)
 821859c:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
 82185a0:	e0bffa17 	ldw	r2,-24(fp)
 82185a4:	e0fffc17 	ldw	r3,-16(fp)
 82185a8:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
 82185ac:	e0bffa17 	ldw	r2,-24(fp)
 82185b0:	e0fffd17 	ldw	r3,-12(fp)
 82185b4:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
 82185b8:	e0bffa17 	ldw	r2,-24(fp)
 82185bc:	e0fffd17 	ldw	r3,-12(fp)
 82185c0:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
 82185c4:	e0bffa17 	ldw	r2,-24(fp)
 82185c8:	e0fffe17 	ldw	r3,-8(fp)
 82185cc:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
 82185d0:	e0bfff17 	ldw	r2,-4(fp)
 82185d4:	10000005 	stb	zero,0(r2)
    return (pmem);
 82185d8:	e0bffa17 	ldw	r2,-24(fp)
}
 82185dc:	e037883a 	mov	sp,fp
 82185e0:	df000017 	ldw	fp,0(sp)
 82185e4:	dec00104 	addi	sp,sp,4
 82185e8:	f800283a 	ret

082185ec <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
 82185ec:	defff804 	addi	sp,sp,-32
 82185f0:	df000715 	stw	fp,28(sp)
 82185f4:	df000704 	addi	fp,sp,28
 82185f8:	e13ffe15 	stw	r4,-8(fp)
 82185fc:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8218600:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 8218604:	e0bfff17 	ldw	r2,-4(fp)
 8218608:	1000021e 	bne	r2,zero,8218614 <OSMemGet+0x28>
        return ((void *)0);
 821860c:	0005883a 	mov	r2,zero
 8218610:	00002e06 	br	82186cc <OSMemGet+0xe0>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
 8218614:	e0bffe17 	ldw	r2,-8(fp)
 8218618:	1000051e 	bne	r2,zero,8218630 <OSMemGet+0x44>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 821861c:	e0bfff17 	ldw	r2,-4(fp)
 8218620:	00c01804 	movi	r3,96
 8218624:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218628:	0005883a 	mov	r2,zero
 821862c:	00002706 	br	82186cc <OSMemGet+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218630:	0005303a 	rdctl	r2,status
 8218634:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218638:	e0fffd17 	ldw	r3,-12(fp)
 821863c:	00bfff84 	movi	r2,-2
 8218640:	1884703a 	and	r2,r3,r2
 8218644:	1001703a 	wrctl	status,r2
  
  return context;
 8218648:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821864c:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
 8218650:	e0bffe17 	ldw	r2,-8(fp)
 8218654:	10800417 	ldw	r2,16(r2)
 8218658:	10001426 	beq	r2,zero,82186ac <OSMemGet+0xc0>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
 821865c:	e0bffe17 	ldw	r2,-8(fp)
 8218660:	10800117 	ldw	r2,4(r2)
 8218664:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
 8218668:	e0bffb17 	ldw	r2,-20(fp)
 821866c:	10c00017 	ldw	r3,0(r2)
 8218670:	e0bffe17 	ldw	r2,-8(fp)
 8218674:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
 8218678:	e0bffe17 	ldw	r2,-8(fp)
 821867c:	10800417 	ldw	r2,16(r2)
 8218680:	10ffffc4 	addi	r3,r2,-1
 8218684:	e0bffe17 	ldw	r2,-8(fp)
 8218688:	10c00415 	stw	r3,16(r2)
 821868c:	e0bff917 	ldw	r2,-28(fp)
 8218690:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218694:	e0bffa17 	ldw	r2,-24(fp)
 8218698:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
 821869c:	e0bfff17 	ldw	r2,-4(fp)
 82186a0:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
 82186a4:	e0bffb17 	ldw	r2,-20(fp)
 82186a8:	00000806 	br	82186cc <OSMemGet+0xe0>
 82186ac:	e0bff917 	ldw	r2,-28(fp)
 82186b0:	e0bffc15 	stw	r2,-16(fp)
 82186b4:	e0bffc17 	ldw	r2,-16(fp)
 82186b8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
 82186bc:	e0bfff17 	ldw	r2,-4(fp)
 82186c0:	00c01744 	movi	r3,93
 82186c4:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
 82186c8:	0005883a 	mov	r2,zero
}
 82186cc:	e037883a 	mov	sp,fp
 82186d0:	df000017 	ldw	fp,0(sp)
 82186d4:	dec00104 	addi	sp,sp,4
 82186d8:	f800283a 	ret

082186dc <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 82186dc:	defff704 	addi	sp,sp,-36
 82186e0:	dfc00815 	stw	ra,32(sp)
 82186e4:	df000715 	stw	fp,28(sp)
 82186e8:	df000704 	addi	fp,sp,28
 82186ec:	e13ffd15 	stw	r4,-12(fp)
 82186f0:	e17ffe15 	stw	r5,-8(fp)
 82186f4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82186f8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 82186fc:	e0bfff17 	ldw	r2,-4(fp)
 8218700:	1000021e 	bne	r2,zero,821870c <OSMemNameGet+0x30>
        return (0);
 8218704:	0005883a 	mov	r2,zero
 8218708:	00002b06 	br	82187b8 <OSMemNameGet+0xdc>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 821870c:	e0bffd17 	ldw	r2,-12(fp)
 8218710:	1000051e 	bne	r2,zero,8218728 <OSMemNameGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 8218714:	e0bfff17 	ldw	r2,-4(fp)
 8218718:	00c01804 	movi	r3,96
 821871c:	10c00005 	stb	r3,0(r2)
        return (0);
 8218720:	0005883a 	mov	r2,zero
 8218724:	00002406 	br	82187b8 <OSMemNameGet+0xdc>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 8218728:	e0bffe17 	ldw	r2,-8(fp)
 821872c:	1000051e 	bne	r2,zero,8218744 <OSMemNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 8218730:	e0bfff17 	ldw	r2,-4(fp)
 8218734:	00c00304 	movi	r3,12
 8218738:	10c00005 	stb	r3,0(r2)
        return (0);
 821873c:	0005883a 	mov	r2,zero
 8218740:	00001d06 	br	82187b8 <OSMemNameGet+0xdc>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8218744:	d0a07903 	ldbu	r2,-32284(gp)
 8218748:	10803fcc 	andi	r2,r2,255
 821874c:	10000526 	beq	r2,zero,8218764 <OSMemNameGet+0x88>
        *perr = OS_ERR_NAME_GET_ISR;
 8218750:	e0bfff17 	ldw	r2,-4(fp)
 8218754:	00c00444 	movi	r3,17
 8218758:	10c00005 	stb	r3,0(r2)
        return (0);
 821875c:	0005883a 	mov	r2,zero
 8218760:	00001506 	br	82187b8 <OSMemNameGet+0xdc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218764:	0005303a 	rdctl	r2,status
 8218768:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821876c:	e0fffb17 	ldw	r3,-20(fp)
 8218770:	00bfff84 	movi	r2,-2
 8218774:	1884703a 	and	r2,r3,r2
 8218778:	1001703a 	wrctl	status,r2
  
  return context;
 821877c:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 8218780:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
 8218784:	e0bffd17 	ldw	r2,-12(fp)
 8218788:	10800504 	addi	r2,r2,20
 821878c:	100b883a 	mov	r5,r2
 8218790:	e13ffe17 	ldw	r4,-8(fp)
 8218794:	82165e40 	call	82165e4 <OS_StrCopy>
 8218798:	e0bffa05 	stb	r2,-24(fp)
 821879c:	e0bff917 	ldw	r2,-28(fp)
 82187a0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82187a4:	e0bffc17 	ldw	r2,-16(fp)
 82187a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 82187ac:	e0bfff17 	ldw	r2,-4(fp)
 82187b0:	10000005 	stb	zero,0(r2)
    return (len);
 82187b4:	e0bffa03 	ldbu	r2,-24(fp)
}
 82187b8:	e037883a 	mov	sp,fp
 82187bc:	dfc00117 	ldw	ra,4(sp)
 82187c0:	df000017 	ldw	fp,0(sp)
 82187c4:	dec00204 	addi	sp,sp,8
 82187c8:	f800283a 	ret

082187cc <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 82187cc:	defff604 	addi	sp,sp,-40
 82187d0:	dfc00915 	stw	ra,36(sp)
 82187d4:	df000815 	stw	fp,32(sp)
 82187d8:	df000804 	addi	fp,sp,32
 82187dc:	e13ffd15 	stw	r4,-12(fp)
 82187e0:	e17ffe15 	stw	r5,-8(fp)
 82187e4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82187e8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 82187ec:	e0bfff17 	ldw	r2,-4(fp)
 82187f0:	10003526 	beq	r2,zero,82188c8 <OSMemNameSet+0xfc>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 82187f4:	e0bffd17 	ldw	r2,-12(fp)
 82187f8:	1000041e 	bne	r2,zero,821880c <OSMemNameSet+0x40>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 82187fc:	e0bfff17 	ldw	r2,-4(fp)
 8218800:	00c01804 	movi	r3,96
 8218804:	10c00005 	stb	r3,0(r2)
        return;
 8218808:	00003006 	br	82188cc <OSMemNameSet+0x100>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 821880c:	e0bffe17 	ldw	r2,-8(fp)
 8218810:	1000041e 	bne	r2,zero,8218824 <OSMemNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 8218814:	e0bfff17 	ldw	r2,-4(fp)
 8218818:	00c00304 	movi	r3,12
 821881c:	10c00005 	stb	r3,0(r2)
        return;
 8218820:	00002a06 	br	82188cc <OSMemNameSet+0x100>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 8218824:	d0a07903 	ldbu	r2,-32284(gp)
 8218828:	10803fcc 	andi	r2,r2,255
 821882c:	10000426 	beq	r2,zero,8218840 <OSMemNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 8218830:	e0bfff17 	ldw	r2,-4(fp)
 8218834:	00c00484 	movi	r3,18
 8218838:	10c00005 	stb	r3,0(r2)
        return;
 821883c:	00002306 	br	82188cc <OSMemNameSet+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218840:	0005303a 	rdctl	r2,status
 8218844:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218848:	e0fffc17 	ldw	r3,-16(fp)
 821884c:	00bfff84 	movi	r2,-2
 8218850:	1884703a 	and	r2,r3,r2
 8218854:	1001703a 	wrctl	status,r2
  
  return context;
 8218858:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821885c:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 8218860:	e13ffe17 	ldw	r4,-8(fp)
 8218864:	82166580 	call	8216658 <OS_StrLen>
 8218868:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
 821886c:	e0bffa03 	ldbu	r2,-24(fp)
 8218870:	10800830 	cmpltui	r2,r2,32
 8218874:	1000081e 	bne	r2,zero,8218898 <OSMemNameSet+0xcc>
 8218878:	e0bff817 	ldw	r2,-32(fp)
 821887c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218880:	e0bff917 	ldw	r2,-28(fp)
 8218884:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
 8218888:	e0bfff17 	ldw	r2,-4(fp)
 821888c:	00c018c4 	movi	r3,99
 8218890:	10c00005 	stb	r3,0(r2)
        return;
 8218894:	00000d06 	br	82188cc <OSMemNameSet+0x100>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
 8218898:	e0bffd17 	ldw	r2,-12(fp)
 821889c:	10800504 	addi	r2,r2,20
 82188a0:	e17ffe17 	ldw	r5,-8(fp)
 82188a4:	1009883a 	mov	r4,r2
 82188a8:	82165e40 	call	82165e4 <OS_StrCopy>
 82188ac:	e0bff817 	ldw	r2,-32(fp)
 82188b0:	e0bffb15 	stw	r2,-20(fp)
 82188b4:	e0bffb17 	ldw	r2,-20(fp)
 82188b8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 82188bc:	e0bfff17 	ldw	r2,-4(fp)
 82188c0:	10000005 	stb	zero,0(r2)
 82188c4:	00000106 	br	82188cc <OSMemNameSet+0x100>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 82188c8:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 82188cc:	e037883a 	mov	sp,fp
 82188d0:	dfc00117 	ldw	ra,4(sp)
 82188d4:	df000017 	ldw	fp,0(sp)
 82188d8:	dec00204 	addi	sp,sp,8
 82188dc:	f800283a 	ret

082188e0 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
 82188e0:	defff904 	addi	sp,sp,-28
 82188e4:	df000615 	stw	fp,24(sp)
 82188e8:	df000604 	addi	fp,sp,24
 82188ec:	e13ffe15 	stw	r4,-8(fp)
 82188f0:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82188f4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 82188f8:	e0bffe17 	ldw	r2,-8(fp)
 82188fc:	1000021e 	bne	r2,zero,8218908 <OSMemPut+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
 8218900:	00801804 	movi	r2,96
 8218904:	00002806 	br	82189a8 <OSMemPut+0xc8>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
 8218908:	e0bfff17 	ldw	r2,-4(fp)
 821890c:	1000021e 	bne	r2,zero,8218918 <OSMemPut+0x38>
        return (OS_ERR_MEM_INVALID_PBLK);
 8218910:	008017c4 	movi	r2,95
 8218914:	00002406 	br	82189a8 <OSMemPut+0xc8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218918:	0005303a 	rdctl	r2,status
 821891c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218920:	e0fffd17 	ldw	r3,-12(fp)
 8218924:	00bfff84 	movi	r2,-2
 8218928:	1884703a 	and	r2,r3,r2
 821892c:	1001703a 	wrctl	status,r2
  
  return context;
 8218930:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 8218934:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
 8218938:	e0bffe17 	ldw	r2,-8(fp)
 821893c:	10c00417 	ldw	r3,16(r2)
 8218940:	e0bffe17 	ldw	r2,-8(fp)
 8218944:	10800317 	ldw	r2,12(r2)
 8218948:	18800636 	bltu	r3,r2,8218964 <OSMemPut+0x84>
 821894c:	e0bffa17 	ldw	r2,-24(fp)
 8218950:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218954:	e0bffb17 	ldw	r2,-20(fp)
 8218958:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
 821895c:	00801784 	movi	r2,94
 8218960:	00001106 	br	82189a8 <OSMemPut+0xc8>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
 8218964:	e0bffe17 	ldw	r2,-8(fp)
 8218968:	10c00117 	ldw	r3,4(r2)
 821896c:	e0bfff17 	ldw	r2,-4(fp)
 8218970:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
 8218974:	e0bffe17 	ldw	r2,-8(fp)
 8218978:	e0ffff17 	ldw	r3,-4(fp)
 821897c:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
 8218980:	e0bffe17 	ldw	r2,-8(fp)
 8218984:	10800417 	ldw	r2,16(r2)
 8218988:	10c00044 	addi	r3,r2,1
 821898c:	e0bffe17 	ldw	r2,-8(fp)
 8218990:	10c00415 	stw	r3,16(r2)
 8218994:	e0bffa17 	ldw	r2,-24(fp)
 8218998:	e0bffc15 	stw	r2,-16(fp)
 821899c:	e0bffc17 	ldw	r2,-16(fp)
 82189a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
 82189a4:	0005883a 	mov	r2,zero
}
 82189a8:	e037883a 	mov	sp,fp
 82189ac:	df000017 	ldw	fp,0(sp)
 82189b0:	dec00104 	addi	sp,sp,4
 82189b4:	f800283a 	ret

082189b8 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
 82189b8:	defffa04 	addi	sp,sp,-24
 82189bc:	df000515 	stw	fp,20(sp)
 82189c0:	df000504 	addi	fp,sp,20
 82189c4:	e13ffe15 	stw	r4,-8(fp)
 82189c8:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82189cc:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 82189d0:	e0bffe17 	ldw	r2,-8(fp)
 82189d4:	1000021e 	bne	r2,zero,82189e0 <OSMemQuery+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
 82189d8:	00801804 	movi	r2,96
 82189dc:	00002c06 	br	8218a90 <OSMemQuery+0xd8>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
 82189e0:	e0bfff17 	ldw	r2,-4(fp)
 82189e4:	1000021e 	bne	r2,zero,82189f0 <OSMemQuery+0x38>
        return (OS_ERR_MEM_INVALID_PDATA);
 82189e8:	00801844 	movi	r2,97
 82189ec:	00002806 	br	8218a90 <OSMemQuery+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82189f0:	0005303a 	rdctl	r2,status
 82189f4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82189f8:	e0fffc17 	ldw	r3,-16(fp)
 82189fc:	00bfff84 	movi	r2,-2
 8218a00:	1884703a 	and	r2,r3,r2
 8218a04:	1001703a 	wrctl	status,r2
  
  return context;
 8218a08:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 8218a0c:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
 8218a10:	e0bffe17 	ldw	r2,-8(fp)
 8218a14:	10c00017 	ldw	r3,0(r2)
 8218a18:	e0bfff17 	ldw	r2,-4(fp)
 8218a1c:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
 8218a20:	e0bffe17 	ldw	r2,-8(fp)
 8218a24:	10c00117 	ldw	r3,4(r2)
 8218a28:	e0bfff17 	ldw	r2,-4(fp)
 8218a2c:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
 8218a30:	e0bffe17 	ldw	r2,-8(fp)
 8218a34:	10c00217 	ldw	r3,8(r2)
 8218a38:	e0bfff17 	ldw	r2,-4(fp)
 8218a3c:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
 8218a40:	e0bffe17 	ldw	r2,-8(fp)
 8218a44:	10c00317 	ldw	r3,12(r2)
 8218a48:	e0bfff17 	ldw	r2,-4(fp)
 8218a4c:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
 8218a50:	e0bffe17 	ldw	r2,-8(fp)
 8218a54:	10c00417 	ldw	r3,16(r2)
 8218a58:	e0bfff17 	ldw	r2,-4(fp)
 8218a5c:	10c00415 	stw	r3,16(r2)
 8218a60:	e0bffb17 	ldw	r2,-20(fp)
 8218a64:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218a68:	e0bffd17 	ldw	r2,-12(fp)
 8218a6c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
 8218a70:	e0bfff17 	ldw	r2,-4(fp)
 8218a74:	10c00317 	ldw	r3,12(r2)
 8218a78:	e0bfff17 	ldw	r2,-4(fp)
 8218a7c:	10800417 	ldw	r2,16(r2)
 8218a80:	1887c83a 	sub	r3,r3,r2
 8218a84:	e0bfff17 	ldw	r2,-4(fp)
 8218a88:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
 8218a8c:	0005883a 	mov	r2,zero
}
 8218a90:	e037883a 	mov	sp,fp
 8218a94:	df000017 	ldw	fp,0(sp)
 8218a98:	dec00104 	addi	sp,sp,4
 8218a9c:	f800283a 	ret

08218aa0 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
 8218aa0:	defffc04 	addi	sp,sp,-16
 8218aa4:	dfc00315 	stw	ra,12(sp)
 8218aa8:	df000215 	stw	fp,8(sp)
 8218aac:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
 8218ab0:	01430c04 	movi	r5,3120
 8218ab4:	010209b4 	movhi	r4,2086
 8218ab8:	212b1a04 	addi	r4,r4,-21400
 8218abc:	82163e40 	call	82163e4 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
 8218ac0:	008209b4 	movhi	r2,2086
 8218ac4:	10ab1a04 	addi	r2,r2,-21400
 8218ac8:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 8218acc:	e03fff0d 	sth	zero,-4(fp)
 8218ad0:	00001306 	br	8218b20 <OS_MemInit+0x80>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
 8218ad4:	e0bfff0b 	ldhu	r2,-4(fp)
 8218ad8:	10800044 	addi	r2,r2,1
 8218adc:	10c00d24 	muli	r3,r2,52
 8218ae0:	008209b4 	movhi	r2,2086
 8218ae4:	10ab1a04 	addi	r2,r2,-21400
 8218ae8:	1887883a 	add	r3,r3,r2
 8218aec:	e0bffe17 	ldw	r2,-8(fp)
 8218af0:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
 8218af4:	e0bffe17 	ldw	r2,-8(fp)
 8218af8:	00c00fc4 	movi	r3,63
 8218afc:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
 8218b00:	e0bffe17 	ldw	r2,-8(fp)
 8218b04:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
 8218b08:	e0bffe17 	ldw	r2,-8(fp)
 8218b0c:	10800d04 	addi	r2,r2,52
 8218b10:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 8218b14:	e0bfff0b 	ldhu	r2,-4(fp)
 8218b18:	10800044 	addi	r2,r2,1
 8218b1c:	e0bfff0d 	sth	r2,-4(fp)
 8218b20:	e0bfff0b 	ldhu	r2,-4(fp)
 8218b24:	10800ef0 	cmpltui	r2,r2,59
 8218b28:	103fea1e 	bne	r2,zero,8218ad4 <OS_MemInit+0x34>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
 8218b2c:	e0bffe17 	ldw	r2,-8(fp)
 8218b30:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
 8218b34:	e0bffe17 	ldw	r2,-8(fp)
 8218b38:	00c00fc4 	movi	r3,63
 8218b3c:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
 8218b40:	e0bffe17 	ldw	r2,-8(fp)
 8218b44:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
 8218b48:	008209b4 	movhi	r2,2086
 8218b4c:	10ab1a04 	addi	r2,r2,-21400
 8218b50:	d0a07415 	stw	r2,-32304(gp)
#endif
}
 8218b54:	0001883a 	nop
 8218b58:	e037883a 	mov	sp,fp
 8218b5c:	dfc00117 	ldw	ra,4(sp)
 8218b60:	df000017 	ldw	fp,0(sp)
 8218b64:	dec00204 	addi	sp,sp,8
 8218b68:	f800283a 	ret

08218b6c <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
 8218b6c:	defff804 	addi	sp,sp,-32
 8218b70:	df000715 	stw	fp,28(sp)
 8218b74:	df000704 	addi	fp,sp,28
 8218b78:	e13ffe15 	stw	r4,-8(fp)
 8218b7c:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218b80:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 8218b84:	e0bfff17 	ldw	r2,-4(fp)
 8218b88:	1000021e 	bne	r2,zero,8218b94 <OSQAccept+0x28>
        return ((void *)0);
 8218b8c:	0005883a 	mov	r2,zero
 8218b90:	00004206 	br	8218c9c <OSQAccept+0x130>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 8218b94:	e0bffe17 	ldw	r2,-8(fp)
 8218b98:	1000051e 	bne	r2,zero,8218bb0 <OSQAccept+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 8218b9c:	e0bfff17 	ldw	r2,-4(fp)
 8218ba0:	00c00104 	movi	r3,4
 8218ba4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218ba8:	0005883a 	mov	r2,zero
 8218bac:	00003b06 	br	8218c9c <OSQAccept+0x130>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 8218bb0:	e0bffe17 	ldw	r2,-8(fp)
 8218bb4:	10800003 	ldbu	r2,0(r2)
 8218bb8:	10803fcc 	andi	r2,r2,255
 8218bbc:	108000a0 	cmpeqi	r2,r2,2
 8218bc0:	1000051e 	bne	r2,zero,8218bd8 <OSQAccept+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 8218bc4:	e0bfff17 	ldw	r2,-4(fp)
 8218bc8:	00c00044 	movi	r3,1
 8218bcc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8218bd0:	0005883a 	mov	r2,zero
 8218bd4:	00003106 	br	8218c9c <OSQAccept+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218bd8:	0005303a 	rdctl	r2,status
 8218bdc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218be0:	e0fffd17 	ldw	r3,-12(fp)
 8218be4:	00bfff84 	movi	r2,-2
 8218be8:	1884703a 	and	r2,r3,r2
 8218bec:	1001703a 	wrctl	status,r2
  
  return context;
 8218bf0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8218bf4:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 8218bf8:	e0bffe17 	ldw	r2,-8(fp)
 8218bfc:	10800117 	ldw	r2,4(r2)
 8218c00:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 8218c04:	e0bffc17 	ldw	r2,-16(fp)
 8218c08:	1080058b 	ldhu	r2,22(r2)
 8218c0c:	10bfffcc 	andi	r2,r2,65535
 8218c10:	10001926 	beq	r2,zero,8218c78 <OSQAccept+0x10c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 8218c14:	e0bffc17 	ldw	r2,-16(fp)
 8218c18:	10800417 	ldw	r2,16(r2)
 8218c1c:	11000104 	addi	r4,r2,4
 8218c20:	e0fffc17 	ldw	r3,-16(fp)
 8218c24:	19000415 	stw	r4,16(r3)
 8218c28:	10800017 	ldw	r2,0(r2)
 8218c2c:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 8218c30:	e0bffc17 	ldw	r2,-16(fp)
 8218c34:	1080058b 	ldhu	r2,22(r2)
 8218c38:	10bfffc4 	addi	r2,r2,-1
 8218c3c:	1007883a 	mov	r3,r2
 8218c40:	e0bffc17 	ldw	r2,-16(fp)
 8218c44:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 8218c48:	e0bffc17 	ldw	r2,-16(fp)
 8218c4c:	10c00417 	ldw	r3,16(r2)
 8218c50:	e0bffc17 	ldw	r2,-16(fp)
 8218c54:	10800217 	ldw	r2,8(r2)
 8218c58:	1880041e 	bne	r3,r2,8218c6c <OSQAccept+0x100>
            pq->OSQOut = pq->OSQStart;
 8218c5c:	e0bffc17 	ldw	r2,-16(fp)
 8218c60:	10c00117 	ldw	r3,4(r2)
 8218c64:	e0bffc17 	ldw	r2,-16(fp)
 8218c68:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
 8218c6c:	e0bfff17 	ldw	r2,-4(fp)
 8218c70:	10000005 	stb	zero,0(r2)
 8218c74:	00000406 	br	8218c88 <OSQAccept+0x11c>
    } else {
        *perr = OS_ERR_Q_EMPTY;
 8218c78:	e0bfff17 	ldw	r2,-4(fp)
 8218c7c:	00c007c4 	movi	r3,31
 8218c80:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
 8218c84:	e03ff915 	stw	zero,-28(fp)
 8218c88:	e0bffa17 	ldw	r2,-24(fp)
 8218c8c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218c90:	e0bffb17 	ldw	r2,-20(fp)
 8218c94:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
 8218c98:	e0bff917 	ldw	r2,-28(fp)
}
 8218c9c:	e037883a 	mov	sp,fp
 8218ca0:	df000017 	ldw	fp,0(sp)
 8218ca4:	dec00104 	addi	sp,sp,4
 8218ca8:	f800283a 	ret

08218cac <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
 8218cac:	defff404 	addi	sp,sp,-48
 8218cb0:	dfc00b15 	stw	ra,44(sp)
 8218cb4:	df000a15 	stw	fp,40(sp)
 8218cb8:	df000a04 	addi	fp,sp,40
 8218cbc:	e13ffe15 	stw	r4,-8(fp)
 8218cc0:	2805883a 	mov	r2,r5
 8218cc4:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 8218cc8:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 8218ccc:	d0a07903 	ldbu	r2,-32284(gp)
 8218cd0:	10803fcc 	andi	r2,r2,255
 8218cd4:	10000226 	beq	r2,zero,8218ce0 <OSQCreate+0x34>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 8218cd8:	0005883a 	mov	r2,zero
 8218cdc:	00005906 	br	8218e44 <OSQCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218ce0:	0005303a 	rdctl	r2,status
 8218ce4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218ce8:	e0fffd17 	ldw	r3,-12(fp)
 8218cec:	00bfff84 	movi	r2,-2
 8218cf0:	1884703a 	and	r2,r3,r2
 8218cf4:	1001703a 	wrctl	status,r2
  
  return context;
 8218cf8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8218cfc:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 8218d00:	d0a07817 	ldw	r2,-32288(gp)
 8218d04:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 8218d08:	d0a07817 	ldw	r2,-32288(gp)
 8218d0c:	10000326 	beq	r2,zero,8218d1c <OSQCreate+0x70>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 8218d10:	d0a07817 	ldw	r2,-32288(gp)
 8218d14:	10800117 	ldw	r2,4(r2)
 8218d18:	d0a07815 	stw	r2,-32288(gp)
 8218d1c:	e0bff717 	ldw	r2,-36(fp)
 8218d20:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218d24:	e0bff817 	ldw	r2,-32(fp)
 8218d28:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
 8218d2c:	e0bff617 	ldw	r2,-40(fp)
 8218d30:	10004326 	beq	r2,zero,8218e40 <OSQCreate+0x194>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218d34:	0005303a 	rdctl	r2,status
 8218d38:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218d3c:	e0fff917 	ldw	r3,-28(fp)
 8218d40:	00bfff84 	movi	r2,-2
 8218d44:	1884703a 	and	r2,r3,r2
 8218d48:	1001703a 	wrctl	status,r2
  
  return context;
 8218d4c:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
 8218d50:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
 8218d54:	d0a07617 	ldw	r2,-32296(gp)
 8218d58:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
 8218d5c:	e0bffb17 	ldw	r2,-20(fp)
 8218d60:	10002d26 	beq	r2,zero,8218e18 <OSQCreate+0x16c>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
 8218d64:	d0a07617 	ldw	r2,-32296(gp)
 8218d68:	10800017 	ldw	r2,0(r2)
 8218d6c:	d0a07615 	stw	r2,-32296(gp)
 8218d70:	e0bff717 	ldw	r2,-36(fp)
 8218d74:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218d78:	e0bffa17 	ldw	r2,-24(fp)
 8218d7c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
 8218d80:	e0bffb17 	ldw	r2,-20(fp)
 8218d84:	e0fffe17 	ldw	r3,-8(fp)
 8218d88:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
 8218d8c:	e0bfff0b 	ldhu	r2,-4(fp)
 8218d90:	1085883a 	add	r2,r2,r2
 8218d94:	1085883a 	add	r2,r2,r2
 8218d98:	1007883a 	mov	r3,r2
 8218d9c:	e0bffe17 	ldw	r2,-8(fp)
 8218da0:	10c7883a 	add	r3,r2,r3
 8218da4:	e0bffb17 	ldw	r2,-20(fp)
 8218da8:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
 8218dac:	e0bffb17 	ldw	r2,-20(fp)
 8218db0:	e0fffe17 	ldw	r3,-8(fp)
 8218db4:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
 8218db8:	e0bffb17 	ldw	r2,-20(fp)
 8218dbc:	e0fffe17 	ldw	r3,-8(fp)
 8218dc0:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
 8218dc4:	e0bffb17 	ldw	r2,-20(fp)
 8218dc8:	e0ffff0b 	ldhu	r3,-4(fp)
 8218dcc:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
 8218dd0:	e0bffb17 	ldw	r2,-20(fp)
 8218dd4:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
 8218dd8:	e0bff617 	ldw	r2,-40(fp)
 8218ddc:	00c00084 	movi	r3,2
 8218de0:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
 8218de4:	e0bff617 	ldw	r2,-40(fp)
 8218de8:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
 8218dec:	e0bff617 	ldw	r2,-40(fp)
 8218df0:	e0fffb17 	ldw	r3,-20(fp)
 8218df4:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
 8218df8:	e0bff617 	ldw	r2,-40(fp)
 8218dfc:	00c00fc4 	movi	r3,63
 8218e00:	10c00385 	stb	r3,14(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
 8218e04:	e0bff617 	ldw	r2,-40(fp)
 8218e08:	100003c5 	stb	zero,15(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
 8218e0c:	e13ff617 	ldw	r4,-40(fp)
 8218e10:	82160040 	call	8216004 <OS_EventWaitListInit>
 8218e14:	00000a06 	br	8218e40 <OSQCreate+0x194>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
 8218e18:	d0e07817 	ldw	r3,-32288(gp)
 8218e1c:	e0bff617 	ldw	r2,-40(fp)
 8218e20:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
 8218e24:	e0bff617 	ldw	r2,-40(fp)
 8218e28:	d0a07815 	stw	r2,-32288(gp)
 8218e2c:	e0bff717 	ldw	r2,-36(fp)
 8218e30:	e0bffc15 	stw	r2,-16(fp)
 8218e34:	e0bffc17 	ldw	r2,-16(fp)
 8218e38:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
 8218e3c:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
 8218e40:	e0bff617 	ldw	r2,-40(fp)
}
 8218e44:	e037883a 	mov	sp,fp
 8218e48:	dfc00117 	ldw	ra,4(sp)
 8218e4c:	df000017 	ldw	fp,0(sp)
 8218e50:	dec00204 	addi	sp,sp,8
 8218e54:	f800283a 	ret

08218e58 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 8218e58:	defff204 	addi	sp,sp,-56
 8218e5c:	dfc00d15 	stw	ra,52(sp)
 8218e60:	df000c15 	stw	fp,48(sp)
 8218e64:	df000c04 	addi	fp,sp,48
 8218e68:	e13ffd15 	stw	r4,-12(fp)
 8218e6c:	2805883a 	mov	r2,r5
 8218e70:	e1bfff15 	stw	r6,-4(fp)
 8218e74:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8218e78:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8218e7c:	e0bfff17 	ldw	r2,-4(fp)
 8218e80:	1000021e 	bne	r2,zero,8218e8c <OSQDel+0x34>
        return (pevent);
 8218e84:	e0bffd17 	ldw	r2,-12(fp)
 8218e88:	00008e06 	br	82190c4 <OSQDel+0x26c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 8218e8c:	e0bffd17 	ldw	r2,-12(fp)
 8218e90:	1000051e 	bne	r2,zero,8218ea8 <OSQDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8218e94:	e0bfff17 	ldw	r2,-4(fp)
 8218e98:	00c00104 	movi	r3,4
 8218e9c:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8218ea0:	e0bffd17 	ldw	r2,-12(fp)
 8218ea4:	00008706 	br	82190c4 <OSQDel+0x26c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 8218ea8:	e0bffd17 	ldw	r2,-12(fp)
 8218eac:	10800003 	ldbu	r2,0(r2)
 8218eb0:	10803fcc 	andi	r2,r2,255
 8218eb4:	108000a0 	cmpeqi	r2,r2,2
 8218eb8:	1000051e 	bne	r2,zero,8218ed0 <OSQDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8218ebc:	e0bfff17 	ldw	r2,-4(fp)
 8218ec0:	00c00044 	movi	r3,1
 8218ec4:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8218ec8:	e0bffd17 	ldw	r2,-12(fp)
 8218ecc:	00007d06 	br	82190c4 <OSQDel+0x26c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8218ed0:	d0a07903 	ldbu	r2,-32284(gp)
 8218ed4:	10803fcc 	andi	r2,r2,255
 8218ed8:	10000526 	beq	r2,zero,8218ef0 <OSQDel+0x98>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 8218edc:	e0bfff17 	ldw	r2,-4(fp)
 8218ee0:	00c003c4 	movi	r3,15
 8218ee4:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8218ee8:	e0bffd17 	ldw	r2,-12(fp)
 8218eec:	00007506 	br	82190c4 <OSQDel+0x26c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8218ef0:	0005303a 	rdctl	r2,status
 8218ef4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8218ef8:	e0fffc17 	ldw	r3,-16(fp)
 8218efc:	00bfff84 	movi	r2,-2
 8218f00:	1884703a 	and	r2,r3,r2
 8218f04:	1001703a 	wrctl	status,r2
  
  return context;
 8218f08:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8218f0c:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
 8218f10:	e0bffd17 	ldw	r2,-12(fp)
 8218f14:	10800283 	ldbu	r2,10(r2)
 8218f18:	10803fcc 	andi	r2,r2,255
 8218f1c:	10000326 	beq	r2,zero,8218f2c <OSQDel+0xd4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 8218f20:	00800044 	movi	r2,1
 8218f24:	e0bff405 	stb	r2,-48(fp)
 8218f28:	00000106 	br	8218f30 <OSQDel+0xd8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 8218f2c:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
 8218f30:	e0bffe03 	ldbu	r2,-8(fp)
 8218f34:	10000326 	beq	r2,zero,8218f44 <OSQDel+0xec>
 8218f38:	10800060 	cmpeqi	r2,r2,1
 8218f3c:	1000301e 	bne	r2,zero,8219000 <OSQDel+0x1a8>
 8218f40:	00005506 	br	8219098 <OSQDel+0x240>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
 8218f44:	e0bff403 	ldbu	r2,-48(fp)
 8218f48:	10001e1e 	bne	r2,zero,8218fc4 <OSQDel+0x16c>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 8218f4c:	e0bffd17 	ldw	r2,-12(fp)
 8218f50:	00c00fc4 	movi	r3,63
 8218f54:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 8218f58:	e0bffd17 	ldw	r2,-12(fp)
 8218f5c:	100003c5 	stb	zero,15(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
 8218f60:	e0bffd17 	ldw	r2,-12(fp)
 8218f64:	10800117 	ldw	r2,4(r2)
 8218f68:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
 8218f6c:	d0e07617 	ldw	r3,-32296(gp)
 8218f70:	e0bff817 	ldw	r2,-32(fp)
 8218f74:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
 8218f78:	e0bff817 	ldw	r2,-32(fp)
 8218f7c:	d0a07615 	stw	r2,-32296(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8218f80:	e0bffd17 	ldw	r2,-12(fp)
 8218f84:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 8218f88:	d0e07817 	ldw	r3,-32288(gp)
 8218f8c:	e0bffd17 	ldw	r2,-12(fp)
 8218f90:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 8218f94:	e0bffd17 	ldw	r2,-12(fp)
 8218f98:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 8218f9c:	e0bffd17 	ldw	r2,-12(fp)
 8218fa0:	d0a07815 	stw	r2,-32288(gp)
 8218fa4:	e0bff617 	ldw	r2,-40(fp)
 8218fa8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8218fac:	e0bff717 	ldw	r2,-36(fp)
 8218fb0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 8218fb4:	e0bfff17 	ldw	r2,-4(fp)
 8218fb8:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
 8218fbc:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
 8218fc0:	00003f06 	br	82190c0 <OSQDel+0x268>
 8218fc4:	e0bff617 	ldw	r2,-40(fp)
 8218fc8:	e0bff915 	stw	r2,-28(fp)
 8218fcc:	e0bff917 	ldw	r2,-28(fp)
 8218fd0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 8218fd4:	e0bfff17 	ldw	r2,-4(fp)
 8218fd8:	00c01244 	movi	r3,73
 8218fdc:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
 8218fe0:	e0bffd17 	ldw	r2,-12(fp)
 8218fe4:	e0bff515 	stw	r2,-44(fp)
             }
             break;
 8218fe8:	00003506 	br	82190c0 <OSQDel+0x268>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
 8218fec:	000f883a 	mov	r7,zero
 8218ff0:	01800104 	movi	r6,4
 8218ff4:	000b883a 	mov	r5,zero
 8218ff8:	e13ffd17 	ldw	r4,-12(fp)
 8218ffc:	8215a540 	call	8215a54 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
 8219000:	e0bffd17 	ldw	r2,-12(fp)
 8219004:	10800283 	ldbu	r2,10(r2)
 8219008:	10803fcc 	andi	r2,r2,255
 821900c:	103ff71e 	bne	r2,zero,8218fec <OSQDel+0x194>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 8219010:	e0bffd17 	ldw	r2,-12(fp)
 8219014:	00c00fc4 	movi	r3,63
 8219018:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 821901c:	e0bffd17 	ldw	r2,-12(fp)
 8219020:	100003c5 	stb	zero,15(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
 8219024:	e0bffd17 	ldw	r2,-12(fp)
 8219028:	10800117 	ldw	r2,4(r2)
 821902c:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
 8219030:	d0e07617 	ldw	r3,-32296(gp)
 8219034:	e0bff817 	ldw	r2,-32(fp)
 8219038:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
 821903c:	e0bff817 	ldw	r2,-32(fp)
 8219040:	d0a07615 	stw	r2,-32296(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8219044:	e0bffd17 	ldw	r2,-12(fp)
 8219048:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 821904c:	d0e07817 	ldw	r3,-32288(gp)
 8219050:	e0bffd17 	ldw	r2,-12(fp)
 8219054:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 8219058:	e0bffd17 	ldw	r2,-12(fp)
 821905c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 8219060:	e0bffd17 	ldw	r2,-12(fp)
 8219064:	d0a07815 	stw	r2,-32288(gp)
 8219068:	e0bff617 	ldw	r2,-40(fp)
 821906c:	e0bffa15 	stw	r2,-24(fp)
 8219070:	e0bffa17 	ldw	r2,-24(fp)
 8219074:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 8219078:	e0bff403 	ldbu	r2,-48(fp)
 821907c:	10800058 	cmpnei	r2,r2,1
 8219080:	1000011e 	bne	r2,zero,8219088 <OSQDel+0x230>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 8219084:	82164a00 	call	82164a0 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 8219088:	e0bfff17 	ldw	r2,-4(fp)
 821908c:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
 8219090:	e03ff515 	stw	zero,-44(fp)
             break;
 8219094:	00000a06 	br	82190c0 <OSQDel+0x268>
 8219098:	e0bff617 	ldw	r2,-40(fp)
 821909c:	e0bffb15 	stw	r2,-20(fp)
 82190a0:	e0bffb17 	ldw	r2,-20(fp)
 82190a4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 82190a8:	e0bfff17 	ldw	r2,-4(fp)
 82190ac:	00c001c4 	movi	r3,7
 82190b0:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
 82190b4:	e0bffd17 	ldw	r2,-12(fp)
 82190b8:	e0bff515 	stw	r2,-44(fp)
             break;
 82190bc:	0001883a 	nop
    }
    return (pevent_return);
 82190c0:	e0bff517 	ldw	r2,-44(fp)
}
 82190c4:	e037883a 	mov	sp,fp
 82190c8:	dfc00117 	ldw	ra,4(sp)
 82190cc:	df000017 	ldw	fp,0(sp)
 82190d0:	dec00204 	addi	sp,sp,8
 82190d4:	f800283a 	ret

082190d8 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
 82190d8:	defffa04 	addi	sp,sp,-24
 82190dc:	df000515 	stw	fp,20(sp)
 82190e0:	df000504 	addi	fp,sp,20
 82190e4:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 82190e8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 82190ec:	e0bfff17 	ldw	r2,-4(fp)
 82190f0:	1000021e 	bne	r2,zero,82190fc <OSQFlush+0x24>
        return (OS_ERR_PEVENT_NULL);
 82190f4:	00800104 	movi	r2,4
 82190f8:	00002106 	br	8219180 <OSQFlush+0xa8>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 82190fc:	e0bfff17 	ldw	r2,-4(fp)
 8219100:	10800003 	ldbu	r2,0(r2)
 8219104:	10803fcc 	andi	r2,r2,255
 8219108:	108000a0 	cmpeqi	r2,r2,2
 821910c:	1000021e 	bne	r2,zero,8219118 <OSQFlush+0x40>
        return (OS_ERR_EVENT_TYPE);
 8219110:	00800044 	movi	r2,1
 8219114:	00001a06 	br	8219180 <OSQFlush+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219118:	0005303a 	rdctl	r2,status
 821911c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219120:	e0fffd17 	ldw	r3,-12(fp)
 8219124:	00bfff84 	movi	r2,-2
 8219128:	1884703a 	and	r2,r3,r2
 821912c:	1001703a 	wrctl	status,r2
  
  return context;
 8219130:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 8219134:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
 8219138:	e0bfff17 	ldw	r2,-4(fp)
 821913c:	10800117 	ldw	r2,4(r2)
 8219140:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
 8219144:	e0bffc17 	ldw	r2,-16(fp)
 8219148:	10c00117 	ldw	r3,4(r2)
 821914c:	e0bffc17 	ldw	r2,-16(fp)
 8219150:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
 8219154:	e0bffc17 	ldw	r2,-16(fp)
 8219158:	10c00117 	ldw	r3,4(r2)
 821915c:	e0bffc17 	ldw	r2,-16(fp)
 8219160:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
 8219164:	e0bffc17 	ldw	r2,-16(fp)
 8219168:	1000058d 	sth	zero,22(r2)
 821916c:	e0bffb17 	ldw	r2,-20(fp)
 8219170:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219174:	e0bffe17 	ldw	r2,-8(fp)
 8219178:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821917c:	0005883a 	mov	r2,zero
}
 8219180:	e037883a 	mov	sp,fp
 8219184:	df000017 	ldw	fp,0(sp)
 8219188:	dec00104 	addi	sp,sp,4
 821918c:	f800283a 	ret

08219190 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 8219190:	defff304 	addi	sp,sp,-52
 8219194:	dfc00c15 	stw	ra,48(sp)
 8219198:	df000b15 	stw	fp,44(sp)
 821919c:	df000b04 	addi	fp,sp,44
 82191a0:	e13ffd15 	stw	r4,-12(fp)
 82191a4:	2805883a 	mov	r2,r5
 82191a8:	e1bfff15 	stw	r6,-4(fp)
 82191ac:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 82191b0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 82191b4:	e0bfff17 	ldw	r2,-4(fp)
 82191b8:	1000021e 	bne	r2,zero,82191c4 <OSQPend+0x34>
        return ((void *)0);
 82191bc:	0005883a 	mov	r2,zero
 82191c0:	00009106 	br	8219408 <OSQPend+0x278>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 82191c4:	e0bffd17 	ldw	r2,-12(fp)
 82191c8:	1000051e 	bne	r2,zero,82191e0 <OSQPend+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 82191cc:	e0bfff17 	ldw	r2,-4(fp)
 82191d0:	00c00104 	movi	r3,4
 82191d4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 82191d8:	0005883a 	mov	r2,zero
 82191dc:	00008a06 	br	8219408 <OSQPend+0x278>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 82191e0:	e0bffd17 	ldw	r2,-12(fp)
 82191e4:	10800003 	ldbu	r2,0(r2)
 82191e8:	10803fcc 	andi	r2,r2,255
 82191ec:	108000a0 	cmpeqi	r2,r2,2
 82191f0:	1000051e 	bne	r2,zero,8219208 <OSQPend+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 82191f4:	e0bfff17 	ldw	r2,-4(fp)
 82191f8:	00c00044 	movi	r3,1
 82191fc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8219200:	0005883a 	mov	r2,zero
 8219204:	00008006 	br	8219408 <OSQPend+0x278>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 8219208:	d0a07903 	ldbu	r2,-32284(gp)
 821920c:	10803fcc 	andi	r2,r2,255
 8219210:	10000526 	beq	r2,zero,8219228 <OSQPend+0x98>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
 8219214:	e0bfff17 	ldw	r2,-4(fp)
 8219218:	00c00084 	movi	r3,2
 821921c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8219220:	0005883a 	mov	r2,zero
 8219224:	00007806 	br	8219408 <OSQPend+0x278>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
 8219228:	d0a06b03 	ldbu	r2,-32340(gp)
 821922c:	10803fcc 	andi	r2,r2,255
 8219230:	10000526 	beq	r2,zero,8219248 <OSQPend+0xb8>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
 8219234:	e0bfff17 	ldw	r2,-4(fp)
 8219238:	00c00344 	movi	r3,13
 821923c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 8219240:	0005883a 	mov	r2,zero
 8219244:	00007006 	br	8219408 <OSQPend+0x278>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219248:	0005303a 	rdctl	r2,status
 821924c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219250:	e0fffc17 	ldw	r3,-16(fp)
 8219254:	00bfff84 	movi	r2,-2
 8219258:	1884703a 	and	r2,r3,r2
 821925c:	1001703a 	wrctl	status,r2
  
  return context;
 8219260:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8219264:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 8219268:	e0bffd17 	ldw	r2,-12(fp)
 821926c:	10800117 	ldw	r2,4(r2)
 8219270:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 8219274:	e0bff817 	ldw	r2,-32(fp)
 8219278:	1080058b 	ldhu	r2,22(r2)
 821927c:	10bfffcc 	andi	r2,r2,65535
 8219280:	10001e26 	beq	r2,zero,82192fc <OSQPend+0x16c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 8219284:	e0bff817 	ldw	r2,-32(fp)
 8219288:	10800417 	ldw	r2,16(r2)
 821928c:	11000104 	addi	r4,r2,4
 8219290:	e0fff817 	ldw	r3,-32(fp)
 8219294:	19000415 	stw	r4,16(r3)
 8219298:	10800017 	ldw	r2,0(r2)
 821929c:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 82192a0:	e0bff817 	ldw	r2,-32(fp)
 82192a4:	1080058b 	ldhu	r2,22(r2)
 82192a8:	10bfffc4 	addi	r2,r2,-1
 82192ac:	1007883a 	mov	r3,r2
 82192b0:	e0bff817 	ldw	r2,-32(fp)
 82192b4:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 82192b8:	e0bff817 	ldw	r2,-32(fp)
 82192bc:	10c00417 	ldw	r3,16(r2)
 82192c0:	e0bff817 	ldw	r2,-32(fp)
 82192c4:	10800217 	ldw	r2,8(r2)
 82192c8:	1880041e 	bne	r3,r2,82192dc <OSQPend+0x14c>
            pq->OSQOut = pq->OSQStart;
 82192cc:	e0bff817 	ldw	r2,-32(fp)
 82192d0:	10c00117 	ldw	r3,4(r2)
 82192d4:	e0bff817 	ldw	r2,-32(fp)
 82192d8:	10c00415 	stw	r3,16(r2)
 82192dc:	e0bff617 	ldw	r2,-40(fp)
 82192e0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82192e4:	e0bff717 	ldw	r2,-36(fp)
 82192e8:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 82192ec:	e0bfff17 	ldw	r2,-4(fp)
 82192f0:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
 82192f4:	e0bff517 	ldw	r2,-44(fp)
 82192f8:	00004306 	br	8219408 <OSQPend+0x278>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
 82192fc:	d0a07a17 	ldw	r2,-32280(gp)
 8219300:	d0e07a17 	ldw	r3,-32280(gp)
 8219304:	18c00c03 	ldbu	r3,48(r3)
 8219308:	18c00114 	ori	r3,r3,4
 821930c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 8219310:	d0a07a17 	ldw	r2,-32280(gp)
 8219314:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
 8219318:	d0a07a17 	ldw	r2,-32280(gp)
 821931c:	e0fffe0b 	ldhu	r3,-8(fp)
 8219320:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
 8219324:	e13ffd17 	ldw	r4,-12(fp)
 8219328:	8215bec0 	call	8215bec <OS_EventTaskWait>
 821932c:	e0bff617 	ldw	r2,-40(fp)
 8219330:	e0bffb15 	stw	r2,-20(fp)
 8219334:	e0bffb17 	ldw	r2,-20(fp)
 8219338:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
 821933c:	82164a00 	call	82164a0 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219340:	0005303a 	rdctl	r2,status
 8219344:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219348:	e0fff917 	ldw	r3,-28(fp)
 821934c:	00bfff84 	movi	r2,-2
 8219350:	1884703a 	and	r2,r3,r2
 8219354:	1001703a 	wrctl	status,r2
  
  return context;
 8219358:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
 821935c:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 8219360:	d0a07a17 	ldw	r2,-32280(gp)
 8219364:	10800c43 	ldbu	r2,49(r2)
 8219368:	10803fcc 	andi	r2,r2,255
 821936c:	10000326 	beq	r2,zero,821937c <OSQPend+0x1ec>
 8219370:	108000a0 	cmpeqi	r2,r2,2
 8219374:	1000071e 	bne	r2,zero,8219394 <OSQPend+0x204>
 8219378:	00000b06 	br	82193a8 <OSQPend+0x218>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
 821937c:	d0a07a17 	ldw	r2,-32280(gp)
 8219380:	10800917 	ldw	r2,36(r2)
 8219384:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
 8219388:	e0bfff17 	ldw	r2,-4(fp)
 821938c:	10000005 	stb	zero,0(r2)
             break;
 8219390:	00000e06 	br	82193cc <OSQPend+0x23c>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
 8219394:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 8219398:	e0bfff17 	ldw	r2,-4(fp)
 821939c:	00c00384 	movi	r3,14
 82193a0:	10c00005 	stb	r3,0(r2)
             break;
 82193a4:	00000906 	br	82193cc <OSQPend+0x23c>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
 82193a8:	d0a07a17 	ldw	r2,-32280(gp)
 82193ac:	e17ffd17 	ldw	r5,-12(fp)
 82193b0:	1009883a 	mov	r4,r2
 82193b4:	8215e4c0 	call	8215e4c <OS_EventTaskRemove>
             pmsg = (void *)0;
 82193b8:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 82193bc:	e0bfff17 	ldw	r2,-4(fp)
 82193c0:	00c00284 	movi	r3,10
 82193c4:	10c00005 	stb	r3,0(r2)
             break;
 82193c8:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 82193cc:	d0a07a17 	ldw	r2,-32280(gp)
 82193d0:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 82193d4:	d0a07a17 	ldw	r2,-32280(gp)
 82193d8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 82193dc:	d0a07a17 	ldw	r2,-32280(gp)
 82193e0:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 82193e4:	d0a07a17 	ldw	r2,-32280(gp)
 82193e8:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 82193ec:	d0a07a17 	ldw	r2,-32280(gp)
 82193f0:	10000915 	stw	zero,36(r2)
 82193f4:	e0bff617 	ldw	r2,-40(fp)
 82193f8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 82193fc:	e0bffa17 	ldw	r2,-24(fp)
 8219400:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
 8219404:	e0bff517 	ldw	r2,-44(fp)
}
 8219408:	e037883a 	mov	sp,fp
 821940c:	dfc00117 	ldw	ra,4(sp)
 8219410:	df000017 	ldw	fp,0(sp)
 8219414:	dec00204 	addi	sp,sp,8
 8219418:	f800283a 	ret

0821941c <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 821941c:	defff604 	addi	sp,sp,-40
 8219420:	dfc00915 	stw	ra,36(sp)
 8219424:	df000815 	stw	fp,32(sp)
 8219428:	df000804 	addi	fp,sp,32
 821942c:	e13ffd15 	stw	r4,-12(fp)
 8219430:	2805883a 	mov	r2,r5
 8219434:	e1bfff15 	stw	r6,-4(fp)
 8219438:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 821943c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8219440:	e0bfff17 	ldw	r2,-4(fp)
 8219444:	1000021e 	bne	r2,zero,8219450 <OSQPendAbort+0x34>
        return (0);
 8219448:	0005883a 	mov	r2,zero
 821944c:	00004906 	br	8219574 <OSQPendAbort+0x158>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 8219450:	e0bffd17 	ldw	r2,-12(fp)
 8219454:	1000051e 	bne	r2,zero,821946c <OSQPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8219458:	e0bfff17 	ldw	r2,-4(fp)
 821945c:	00c00104 	movi	r3,4
 8219460:	10c00005 	stb	r3,0(r2)
        return (0);
 8219464:	0005883a 	mov	r2,zero
 8219468:	00004206 	br	8219574 <OSQPendAbort+0x158>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 821946c:	e0bffd17 	ldw	r2,-12(fp)
 8219470:	10800003 	ldbu	r2,0(r2)
 8219474:	10803fcc 	andi	r2,r2,255
 8219478:	108000a0 	cmpeqi	r2,r2,2
 821947c:	1000051e 	bne	r2,zero,8219494 <OSQPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8219480:	e0bfff17 	ldw	r2,-4(fp)
 8219484:	00c00044 	movi	r3,1
 8219488:	10c00005 	stb	r3,0(r2)
        return (0);
 821948c:	0005883a 	mov	r2,zero
 8219490:	00003806 	br	8219574 <OSQPendAbort+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219494:	0005303a 	rdctl	r2,status
 8219498:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821949c:	e0fffc17 	ldw	r3,-16(fp)
 82194a0:	00bfff84 	movi	r2,-2
 82194a4:	1884703a 	and	r2,r3,r2
 82194a8:	1001703a 	wrctl	status,r2
  
  return context;
 82194ac:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82194b0:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
 82194b4:	e0bffd17 	ldw	r2,-12(fp)
 82194b8:	10800283 	ldbu	r2,10(r2)
 82194bc:	10803fcc 	andi	r2,r2,255
 82194c0:	10002526 	beq	r2,zero,8219558 <OSQPendAbort+0x13c>
        nbr_tasks = 0;
 82194c4:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 82194c8:	e0bffe03 	ldbu	r2,-8(fp)
 82194cc:	10800060 	cmpeqi	r2,r2,1
 82194d0:	10000e26 	beq	r2,zero,821950c <OSQPendAbort+0xf0>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 82194d4:	00000806 	br	82194f8 <OSQPendAbort+0xdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 82194d8:	01c00084 	movi	r7,2
 82194dc:	01800104 	movi	r6,4
 82194e0:	000b883a 	mov	r5,zero
 82194e4:	e13ffd17 	ldw	r4,-12(fp)
 82194e8:	8215a540 	call	8215a54 <OS_EventTaskRdy>
                     nbr_tasks++;
 82194ec:	e0bff803 	ldbu	r2,-32(fp)
 82194f0:	10800044 	addi	r2,r2,1
 82194f4:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 82194f8:	e0bffd17 	ldw	r2,-12(fp)
 82194fc:	10800283 	ldbu	r2,10(r2)
 8219500:	10803fcc 	andi	r2,r2,255
 8219504:	103ff41e 	bne	r2,zero,82194d8 <OSQPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 8219508:	00000906 	br	8219530 <OSQPendAbort+0x114>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 821950c:	01c00084 	movi	r7,2
 8219510:	01800104 	movi	r6,4
 8219514:	000b883a 	mov	r5,zero
 8219518:	e13ffd17 	ldw	r4,-12(fp)
 821951c:	8215a540 	call	8215a54 <OS_EventTaskRdy>
                 nbr_tasks++;
 8219520:	e0bff803 	ldbu	r2,-32(fp)
 8219524:	10800044 	addi	r2,r2,1
 8219528:	e0bff805 	stb	r2,-32(fp)
                 break;
 821952c:	0001883a 	nop
 8219530:	e0bff917 	ldw	r2,-28(fp)
 8219534:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219538:	e0bffa17 	ldw	r2,-24(fp)
 821953c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
 8219540:	82164a00 	call	82164a0 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 8219544:	e0bfff17 	ldw	r2,-4(fp)
 8219548:	00c00384 	movi	r3,14
 821954c:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 8219550:	e0bff803 	ldbu	r2,-32(fp)
 8219554:	00000706 	br	8219574 <OSQPendAbort+0x158>
 8219558:	e0bff917 	ldw	r2,-28(fp)
 821955c:	e0bffb15 	stw	r2,-20(fp)
 8219560:	e0bffb17 	ldw	r2,-20(fp)
 8219564:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 8219568:	e0bfff17 	ldw	r2,-4(fp)
 821956c:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
 8219570:	0005883a 	mov	r2,zero
}
 8219574:	e037883a 	mov	sp,fp
 8219578:	dfc00117 	ldw	ra,4(sp)
 821957c:	df000017 	ldw	fp,0(sp)
 8219580:	dec00204 	addi	sp,sp,8
 8219584:	f800283a 	ret

08219588 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
 8219588:	defff604 	addi	sp,sp,-40
 821958c:	dfc00915 	stw	ra,36(sp)
 8219590:	df000815 	stw	fp,32(sp)
 8219594:	df000804 	addi	fp,sp,32
 8219598:	e13ffe15 	stw	r4,-8(fp)
 821959c:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 82195a0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 82195a4:	e0bffe17 	ldw	r2,-8(fp)
 82195a8:	1000021e 	bne	r2,zero,82195b4 <OSQPost+0x2c>
        return (OS_ERR_PEVENT_NULL);
 82195ac:	00800104 	movi	r2,4
 82195b0:	00004a06 	br	82196dc <OSQPost+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 82195b4:	e0bffe17 	ldw	r2,-8(fp)
 82195b8:	10800003 	ldbu	r2,0(r2)
 82195bc:	10803fcc 	andi	r2,r2,255
 82195c0:	108000a0 	cmpeqi	r2,r2,2
 82195c4:	1000021e 	bne	r2,zero,82195d0 <OSQPost+0x48>
        return (OS_ERR_EVENT_TYPE);
 82195c8:	00800044 	movi	r2,1
 82195cc:	00004306 	br	82196dc <OSQPost+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82195d0:	0005303a 	rdctl	r2,status
 82195d4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82195d8:	e0fffd17 	ldw	r3,-12(fp)
 82195dc:	00bfff84 	movi	r2,-2
 82195e0:	1884703a 	and	r2,r3,r2
 82195e4:	1001703a 	wrctl	status,r2
  
  return context;
 82195e8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 82195ec:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
 82195f0:	e0bffe17 	ldw	r2,-8(fp)
 82195f4:	10800283 	ldbu	r2,10(r2)
 82195f8:	10803fcc 	andi	r2,r2,255
 82195fc:	10000c26 	beq	r2,zero,8219630 <OSQPost+0xa8>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 8219600:	000f883a 	mov	r7,zero
 8219604:	01800104 	movi	r6,4
 8219608:	e17fff17 	ldw	r5,-4(fp)
 821960c:	e13ffe17 	ldw	r4,-8(fp)
 8219610:	8215a540 	call	8215a54 <OS_EventTaskRdy>
 8219614:	e0bff817 	ldw	r2,-32(fp)
 8219618:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821961c:	e0bff917 	ldw	r2,-28(fp)
 8219620:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
 8219624:	82164a00 	call	82164a0 <OS_Sched>
        return (OS_ERR_NONE);
 8219628:	0005883a 	mov	r2,zero
 821962c:	00002b06 	br	82196dc <OSQPost+0x154>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
 8219630:	e0bffe17 	ldw	r2,-8(fp)
 8219634:	10800117 	ldw	r2,4(r2)
 8219638:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
 821963c:	e0bffb17 	ldw	r2,-20(fp)
 8219640:	10c0058b 	ldhu	r3,22(r2)
 8219644:	e0bffb17 	ldw	r2,-20(fp)
 8219648:	1080050b 	ldhu	r2,20(r2)
 821964c:	18ffffcc 	andi	r3,r3,65535
 8219650:	10bfffcc 	andi	r2,r2,65535
 8219654:	18800636 	bltu	r3,r2,8219670 <OSQPost+0xe8>
 8219658:	e0bff817 	ldw	r2,-32(fp)
 821965c:	e0bffa15 	stw	r2,-24(fp)
 8219660:	e0bffa17 	ldw	r2,-24(fp)
 8219664:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 8219668:	00800784 	movi	r2,30
 821966c:	00001b06 	br	82196dc <OSQPost+0x154>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
 8219670:	e0bffb17 	ldw	r2,-20(fp)
 8219674:	10800317 	ldw	r2,12(r2)
 8219678:	11000104 	addi	r4,r2,4
 821967c:	e0fffb17 	ldw	r3,-20(fp)
 8219680:	19000315 	stw	r4,12(r3)
 8219684:	e0ffff17 	ldw	r3,-4(fp)
 8219688:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
 821968c:	e0bffb17 	ldw	r2,-20(fp)
 8219690:	1080058b 	ldhu	r2,22(r2)
 8219694:	10800044 	addi	r2,r2,1
 8219698:	1007883a 	mov	r3,r2
 821969c:	e0bffb17 	ldw	r2,-20(fp)
 82196a0:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
 82196a4:	e0bffb17 	ldw	r2,-20(fp)
 82196a8:	10c00317 	ldw	r3,12(r2)
 82196ac:	e0bffb17 	ldw	r2,-20(fp)
 82196b0:	10800217 	ldw	r2,8(r2)
 82196b4:	1880041e 	bne	r3,r2,82196c8 <OSQPost+0x140>
        pq->OSQIn = pq->OSQStart;
 82196b8:	e0bffb17 	ldw	r2,-20(fp)
 82196bc:	10c00117 	ldw	r3,4(r2)
 82196c0:	e0bffb17 	ldw	r2,-20(fp)
 82196c4:	10c00315 	stw	r3,12(r2)
 82196c8:	e0bff817 	ldw	r2,-32(fp)
 82196cc:	e0bffc15 	stw	r2,-16(fp)
 82196d0:	e0bffc17 	ldw	r2,-16(fp)
 82196d4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 82196d8:	0005883a 	mov	r2,zero
}
 82196dc:	e037883a 	mov	sp,fp
 82196e0:	dfc00117 	ldw	ra,4(sp)
 82196e4:	df000017 	ldw	fp,0(sp)
 82196e8:	dec00204 	addi	sp,sp,8
 82196ec:	f800283a 	ret

082196f0 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
 82196f0:	defff604 	addi	sp,sp,-40
 82196f4:	dfc00915 	stw	ra,36(sp)
 82196f8:	df000815 	stw	fp,32(sp)
 82196fc:	df000804 	addi	fp,sp,32
 8219700:	e13ffe15 	stw	r4,-8(fp)
 8219704:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8219708:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821970c:	e0bffe17 	ldw	r2,-8(fp)
 8219710:	1000021e 	bne	r2,zero,821971c <OSQPostFront+0x2c>
        return (OS_ERR_PEVENT_NULL);
 8219714:	00800104 	movi	r2,4
 8219718:	00004c06 	br	821984c <OSQPostFront+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 821971c:	e0bffe17 	ldw	r2,-8(fp)
 8219720:	10800003 	ldbu	r2,0(r2)
 8219724:	10803fcc 	andi	r2,r2,255
 8219728:	108000a0 	cmpeqi	r2,r2,2
 821972c:	1000021e 	bne	r2,zero,8219738 <OSQPostFront+0x48>
        return (OS_ERR_EVENT_TYPE);
 8219730:	00800044 	movi	r2,1
 8219734:	00004506 	br	821984c <OSQPostFront+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219738:	0005303a 	rdctl	r2,status
 821973c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219740:	e0fffd17 	ldw	r3,-12(fp)
 8219744:	00bfff84 	movi	r2,-2
 8219748:	1884703a 	and	r2,r3,r2
 821974c:	1001703a 	wrctl	status,r2
  
  return context;
 8219750:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8219754:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
 8219758:	e0bffe17 	ldw	r2,-8(fp)
 821975c:	10800283 	ldbu	r2,10(r2)
 8219760:	10803fcc 	andi	r2,r2,255
 8219764:	10000c26 	beq	r2,zero,8219798 <OSQPostFront+0xa8>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 8219768:	000f883a 	mov	r7,zero
 821976c:	01800104 	movi	r6,4
 8219770:	e17fff17 	ldw	r5,-4(fp)
 8219774:	e13ffe17 	ldw	r4,-8(fp)
 8219778:	8215a540 	call	8215a54 <OS_EventTaskRdy>
 821977c:	e0bff817 	ldw	r2,-32(fp)
 8219780:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219784:	e0bff917 	ldw	r2,-28(fp)
 8219788:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
 821978c:	82164a00 	call	82164a0 <OS_Sched>
        return (OS_ERR_NONE);
 8219790:	0005883a 	mov	r2,zero
 8219794:	00002d06 	br	821984c <OSQPostFront+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 8219798:	e0bffe17 	ldw	r2,-8(fp)
 821979c:	10800117 	ldw	r2,4(r2)
 82197a0:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 82197a4:	e0bffb17 	ldw	r2,-20(fp)
 82197a8:	10c0058b 	ldhu	r3,22(r2)
 82197ac:	e0bffb17 	ldw	r2,-20(fp)
 82197b0:	1080050b 	ldhu	r2,20(r2)
 82197b4:	18ffffcc 	andi	r3,r3,65535
 82197b8:	10bfffcc 	andi	r2,r2,65535
 82197bc:	18800636 	bltu	r3,r2,82197d8 <OSQPostFront+0xe8>
 82197c0:	e0bff817 	ldw	r2,-32(fp)
 82197c4:	e0bffa15 	stw	r2,-24(fp)
 82197c8:	e0bffa17 	ldw	r2,-24(fp)
 82197cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 82197d0:	00800784 	movi	r2,30
 82197d4:	00001d06 	br	821984c <OSQPostFront+0x15c>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
 82197d8:	e0bffb17 	ldw	r2,-20(fp)
 82197dc:	10c00417 	ldw	r3,16(r2)
 82197e0:	e0bffb17 	ldw	r2,-20(fp)
 82197e4:	10800117 	ldw	r2,4(r2)
 82197e8:	1880041e 	bne	r3,r2,82197fc <OSQPostFront+0x10c>
        pq->OSQOut = pq->OSQEnd;
 82197ec:	e0bffb17 	ldw	r2,-20(fp)
 82197f0:	10c00217 	ldw	r3,8(r2)
 82197f4:	e0bffb17 	ldw	r2,-20(fp)
 82197f8:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
 82197fc:	e0bffb17 	ldw	r2,-20(fp)
 8219800:	10800417 	ldw	r2,16(r2)
 8219804:	10ffff04 	addi	r3,r2,-4
 8219808:	e0bffb17 	ldw	r2,-20(fp)
 821980c:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
 8219810:	e0bffb17 	ldw	r2,-20(fp)
 8219814:	10800417 	ldw	r2,16(r2)
 8219818:	e0ffff17 	ldw	r3,-4(fp)
 821981c:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 8219820:	e0bffb17 	ldw	r2,-20(fp)
 8219824:	1080058b 	ldhu	r2,22(r2)
 8219828:	10800044 	addi	r2,r2,1
 821982c:	1007883a 	mov	r3,r2
 8219830:	e0bffb17 	ldw	r2,-20(fp)
 8219834:	10c0058d 	sth	r3,22(r2)
 8219838:	e0bff817 	ldw	r2,-32(fp)
 821983c:	e0bffc15 	stw	r2,-16(fp)
 8219840:	e0bffc17 	ldw	r2,-16(fp)
 8219844:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8219848:	0005883a 	mov	r2,zero
}
 821984c:	e037883a 	mov	sp,fp
 8219850:	dfc00117 	ldw	ra,4(sp)
 8219854:	df000017 	ldw	fp,0(sp)
 8219858:	dec00204 	addi	sp,sp,8
 821985c:	f800283a 	ret

08219860 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
 8219860:	defff504 	addi	sp,sp,-44
 8219864:	dfc00a15 	stw	ra,40(sp)
 8219868:	df000915 	stw	fp,36(sp)
 821986c:	df000904 	addi	fp,sp,36
 8219870:	e13ffd15 	stw	r4,-12(fp)
 8219874:	e17ffe15 	stw	r5,-8(fp)
 8219878:	3005883a 	mov	r2,r6
 821987c:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8219880:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 8219884:	e0bffd17 	ldw	r2,-12(fp)
 8219888:	1000021e 	bne	r2,zero,8219894 <OSQPostOpt+0x34>
        return (OS_ERR_PEVENT_NULL);
 821988c:	00800104 	movi	r2,4
 8219890:	00007106 	br	8219a58 <OSQPostOpt+0x1f8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 8219894:	e0bffd17 	ldw	r2,-12(fp)
 8219898:	10800003 	ldbu	r2,0(r2)
 821989c:	10803fcc 	andi	r2,r2,255
 82198a0:	108000a0 	cmpeqi	r2,r2,2
 82198a4:	1000021e 	bne	r2,zero,82198b0 <OSQPostOpt+0x50>
        return (OS_ERR_EVENT_TYPE);
 82198a8:	00800044 	movi	r2,1
 82198ac:	00006a06 	br	8219a58 <OSQPostOpt+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 82198b0:	0005303a 	rdctl	r2,status
 82198b4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 82198b8:	e0fffc17 	ldw	r3,-16(fp)
 82198bc:	00bfff84 	movi	r2,-2
 82198c0:	1884703a 	and	r2,r3,r2
 82198c4:	1001703a 	wrctl	status,r2
  
  return context;
 82198c8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 82198cc:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
 82198d0:	e0bffd17 	ldw	r2,-12(fp)
 82198d4:	10800283 	ldbu	r2,10(r2)
 82198d8:	10803fcc 	andi	r2,r2,255
 82198dc:	10001d26 	beq	r2,zero,8219954 <OSQPostOpt+0xf4>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 82198e0:	e0bfff03 	ldbu	r2,-4(fp)
 82198e4:	1080004c 	andi	r2,r2,1
 82198e8:	10000b26 	beq	r2,zero,8219918 <OSQPostOpt+0xb8>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 82198ec:	00000506 	br	8219904 <OSQPostOpt+0xa4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 82198f0:	000f883a 	mov	r7,zero
 82198f4:	01800104 	movi	r6,4
 82198f8:	e17ffe17 	ldw	r5,-8(fp)
 82198fc:	e13ffd17 	ldw	r4,-12(fp)
 8219900:	8215a540 	call	8215a54 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 8219904:	e0bffd17 	ldw	r2,-12(fp)
 8219908:	10800283 	ldbu	r2,10(r2)
 821990c:	10803fcc 	andi	r2,r2,255
 8219910:	103ff71e 	bne	r2,zero,82198f0 <OSQPostOpt+0x90>
 8219914:	00000506 	br	821992c <OSQPostOpt+0xcc>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 8219918:	000f883a 	mov	r7,zero
 821991c:	01800104 	movi	r6,4
 8219920:	e17ffe17 	ldw	r5,-8(fp)
 8219924:	e13ffd17 	ldw	r4,-12(fp)
 8219928:	8215a540 	call	8215a54 <OS_EventTaskRdy>
 821992c:	e0bff717 	ldw	r2,-36(fp)
 8219930:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219934:	e0bff817 	ldw	r2,-32(fp)
 8219938:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
 821993c:	e0bfff03 	ldbu	r2,-4(fp)
 8219940:	1080010c 	andi	r2,r2,4
 8219944:	1000011e 	bne	r2,zero,821994c <OSQPostOpt+0xec>
            OS_Sched();                               /* Find highest priority task ready to run       */
 8219948:	82164a00 	call	82164a0 <OS_Sched>
        }
        return (OS_ERR_NONE);
 821994c:	0005883a 	mov	r2,zero
 8219950:	00004106 	br	8219a58 <OSQPostOpt+0x1f8>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 8219954:	e0bffd17 	ldw	r2,-12(fp)
 8219958:	10800117 	ldw	r2,4(r2)
 821995c:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 8219960:	e0bffa17 	ldw	r2,-24(fp)
 8219964:	10c0058b 	ldhu	r3,22(r2)
 8219968:	e0bffa17 	ldw	r2,-24(fp)
 821996c:	1080050b 	ldhu	r2,20(r2)
 8219970:	18ffffcc 	andi	r3,r3,65535
 8219974:	10bfffcc 	andi	r2,r2,65535
 8219978:	18800636 	bltu	r3,r2,8219994 <OSQPostOpt+0x134>
 821997c:	e0bff717 	ldw	r2,-36(fp)
 8219980:	e0bff915 	stw	r2,-28(fp)
 8219984:	e0bff917 	ldw	r2,-28(fp)
 8219988:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 821998c:	00800784 	movi	r2,30
 8219990:	00003106 	br	8219a58 <OSQPostOpt+0x1f8>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
 8219994:	e0bfff03 	ldbu	r2,-4(fp)
 8219998:	1080008c 	andi	r2,r2,2
 821999c:	10001326 	beq	r2,zero,82199ec <OSQPostOpt+0x18c>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
 82199a0:	e0bffa17 	ldw	r2,-24(fp)
 82199a4:	10c00417 	ldw	r3,16(r2)
 82199a8:	e0bffa17 	ldw	r2,-24(fp)
 82199ac:	10800117 	ldw	r2,4(r2)
 82199b0:	1880041e 	bne	r3,r2,82199c4 <OSQPostOpt+0x164>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
 82199b4:	e0bffa17 	ldw	r2,-24(fp)
 82199b8:	10c00217 	ldw	r3,8(r2)
 82199bc:	e0bffa17 	ldw	r2,-24(fp)
 82199c0:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
 82199c4:	e0bffa17 	ldw	r2,-24(fp)
 82199c8:	10800417 	ldw	r2,16(r2)
 82199cc:	10ffff04 	addi	r3,r2,-4
 82199d0:	e0bffa17 	ldw	r2,-24(fp)
 82199d4:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
 82199d8:	e0bffa17 	ldw	r2,-24(fp)
 82199dc:	10800417 	ldw	r2,16(r2)
 82199e0:	e0fffe17 	ldw	r3,-8(fp)
 82199e4:	10c00015 	stw	r3,0(r2)
 82199e8:	00001006 	br	8219a2c <OSQPostOpt+0x1cc>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
 82199ec:	e0bffa17 	ldw	r2,-24(fp)
 82199f0:	10800317 	ldw	r2,12(r2)
 82199f4:	11000104 	addi	r4,r2,4
 82199f8:	e0fffa17 	ldw	r3,-24(fp)
 82199fc:	19000315 	stw	r4,12(r3)
 8219a00:	e0fffe17 	ldw	r3,-8(fp)
 8219a04:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
 8219a08:	e0bffa17 	ldw	r2,-24(fp)
 8219a0c:	10c00317 	ldw	r3,12(r2)
 8219a10:	e0bffa17 	ldw	r2,-24(fp)
 8219a14:	10800217 	ldw	r2,8(r2)
 8219a18:	1880041e 	bne	r3,r2,8219a2c <OSQPostOpt+0x1cc>
            pq->OSQIn = pq->OSQStart;
 8219a1c:	e0bffa17 	ldw	r2,-24(fp)
 8219a20:	10c00117 	ldw	r3,4(r2)
 8219a24:	e0bffa17 	ldw	r2,-24(fp)
 8219a28:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 8219a2c:	e0bffa17 	ldw	r2,-24(fp)
 8219a30:	1080058b 	ldhu	r2,22(r2)
 8219a34:	10800044 	addi	r2,r2,1
 8219a38:	1007883a 	mov	r3,r2
 8219a3c:	e0bffa17 	ldw	r2,-24(fp)
 8219a40:	10c0058d 	sth	r3,22(r2)
 8219a44:	e0bff717 	ldw	r2,-36(fp)
 8219a48:	e0bffb15 	stw	r2,-20(fp)
 8219a4c:	e0bffb17 	ldw	r2,-20(fp)
 8219a50:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8219a54:	0005883a 	mov	r2,zero
}
 8219a58:	e037883a 	mov	sp,fp
 8219a5c:	dfc00117 	ldw	ra,4(sp)
 8219a60:	df000017 	ldw	fp,0(sp)
 8219a64:	dec00204 	addi	sp,sp,8
 8219a68:	f800283a 	ret

08219a6c <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
 8219a6c:	defff604 	addi	sp,sp,-40
 8219a70:	df000915 	stw	fp,36(sp)
 8219a74:	df000904 	addi	fp,sp,36
 8219a78:	e13ffe15 	stw	r4,-8(fp)
 8219a7c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 8219a80:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 8219a84:	e0bffe17 	ldw	r2,-8(fp)
 8219a88:	1000021e 	bne	r2,zero,8219a94 <OSQQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 8219a8c:	00800104 	movi	r2,4
 8219a90:	00004906 	br	8219bb8 <OSQQuery+0x14c>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
 8219a94:	e0bfff17 	ldw	r2,-4(fp)
 8219a98:	1000021e 	bne	r2,zero,8219aa4 <OSQQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 8219a9c:	00800244 	movi	r2,9
 8219aa0:	00004506 	br	8219bb8 <OSQQuery+0x14c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 8219aa4:	e0bffe17 	ldw	r2,-8(fp)
 8219aa8:	10800003 	ldbu	r2,0(r2)
 8219aac:	10803fcc 	andi	r2,r2,255
 8219ab0:	108000a0 	cmpeqi	r2,r2,2
 8219ab4:	1000021e 	bne	r2,zero,8219ac0 <OSQQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 8219ab8:	00800044 	movi	r2,1
 8219abc:	00003e06 	br	8219bb8 <OSQQuery+0x14c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219ac0:	0005303a 	rdctl	r2,status
 8219ac4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219ac8:	e0fffd17 	ldw	r3,-12(fp)
 8219acc:	00bfff84 	movi	r2,-2
 8219ad0:	1884703a 	and	r2,r3,r2
 8219ad4:	1001703a 	wrctl	status,r2
  
  return context;
 8219ad8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 8219adc:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
 8219ae0:	e0bffe17 	ldw	r2,-8(fp)
 8219ae4:	10c00283 	ldbu	r3,10(r2)
 8219ae8:	e0bfff17 	ldw	r2,-4(fp)
 8219aec:	10c002c5 	stb	r3,11(r2)
    psrc                 = &pevent->OSEventTbl[0];
 8219af0:	e0bffe17 	ldw	r2,-8(fp)
 8219af4:	108002c4 	addi	r2,r2,11
 8219af8:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
 8219afc:	e0bfff17 	ldw	r2,-4(fp)
 8219b00:	10800204 	addi	r2,r2,8
 8219b04:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8219b08:	e03ff705 	stb	zero,-36(fp)
 8219b0c:	00000b06 	br	8219b3c <OSQQuery+0xd0>
        *pdest++ = *psrc++;
 8219b10:	e0bff917 	ldw	r2,-28(fp)
 8219b14:	10c00044 	addi	r3,r2,1
 8219b18:	e0fff915 	stw	r3,-28(fp)
 8219b1c:	e0fff817 	ldw	r3,-32(fp)
 8219b20:	19000044 	addi	r4,r3,1
 8219b24:	e13ff815 	stw	r4,-32(fp)
 8219b28:	18c00003 	ldbu	r3,0(r3)
 8219b2c:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 8219b30:	e0bff703 	ldbu	r2,-36(fp)
 8219b34:	10800044 	addi	r2,r2,1
 8219b38:	e0bff705 	stb	r2,-36(fp)
 8219b3c:	e0bff703 	ldbu	r2,-36(fp)
 8219b40:	108000f0 	cmpltui	r2,r2,3
 8219b44:	103ff21e 	bne	r2,zero,8219b10 <OSQQuery+0xa4>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
 8219b48:	e0bffe17 	ldw	r2,-8(fp)
 8219b4c:	10800117 	ldw	r2,4(r2)
 8219b50:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
 8219b54:	e0bffc17 	ldw	r2,-16(fp)
 8219b58:	1080058b 	ldhu	r2,22(r2)
 8219b5c:	10bfffcc 	andi	r2,r2,65535
 8219b60:	10000626 	beq	r2,zero,8219b7c <OSQQuery+0x110>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
 8219b64:	e0bffc17 	ldw	r2,-16(fp)
 8219b68:	10800417 	ldw	r2,16(r2)
 8219b6c:	10c00017 	ldw	r3,0(r2)
 8219b70:	e0bfff17 	ldw	r2,-4(fp)
 8219b74:	10c00015 	stw	r3,0(r2)
 8219b78:	00000206 	br	8219b84 <OSQQuery+0x118>
    } else {
        p_q_data->OSMsg = (void *)0;
 8219b7c:	e0bfff17 	ldw	r2,-4(fp)
 8219b80:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
 8219b84:	e0bffc17 	ldw	r2,-16(fp)
 8219b88:	10c0058b 	ldhu	r3,22(r2)
 8219b8c:	e0bfff17 	ldw	r2,-4(fp)
 8219b90:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
 8219b94:	e0bffc17 	ldw	r2,-16(fp)
 8219b98:	10c0050b 	ldhu	r3,20(r2)
 8219b9c:	e0bfff17 	ldw	r2,-4(fp)
 8219ba0:	10c0018d 	sth	r3,6(r2)
 8219ba4:	e0bffa17 	ldw	r2,-24(fp)
 8219ba8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219bac:	e0bffb17 	ldw	r2,-20(fp)
 8219bb0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 8219bb4:	0005883a 	mov	r2,zero
}
 8219bb8:	e037883a 	mov	sp,fp
 8219bbc:	df000017 	ldw	fp,0(sp)
 8219bc0:	dec00104 	addi	sp,sp,4
 8219bc4:	f800283a 	ret

08219bc8 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
 8219bc8:	defffb04 	addi	sp,sp,-20
 8219bcc:	dfc00415 	stw	ra,16(sp)
 8219bd0:	df000315 	stw	fp,12(sp)
 8219bd4:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
 8219bd8:	01407804 	movi	r5,480
 8219bdc:	010209b4 	movhi	r4,2086
 8219be0:	21302604 	addi	r4,r4,-16232
 8219be4:	82163e40 	call	82163e4 <OS_MemClr>
    pq1 = &OSQTbl[0];
 8219be8:	008209b4 	movhi	r2,2086
 8219bec:	10b02604 	addi	r2,r2,-16232
 8219bf0:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
 8219bf4:	008209b4 	movhi	r2,2086
 8219bf8:	10b02c04 	addi	r2,r2,-16208
 8219bfc:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 8219c00:	e03ffd0d 	sth	zero,-12(fp)
 8219c04:	00000c06 	br	8219c38 <OS_QInit+0x70>
        pq1->OSQPtr = pq2;
 8219c08:	e0bffe17 	ldw	r2,-8(fp)
 8219c0c:	e0ffff17 	ldw	r3,-4(fp)
 8219c10:	10c00015 	stw	r3,0(r2)
        pq1++;
 8219c14:	e0bffe17 	ldw	r2,-8(fp)
 8219c18:	10800604 	addi	r2,r2,24
 8219c1c:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
 8219c20:	e0bfff17 	ldw	r2,-4(fp)
 8219c24:	10800604 	addi	r2,r2,24
 8219c28:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 8219c2c:	e0bffd0b 	ldhu	r2,-12(fp)
 8219c30:	10800044 	addi	r2,r2,1
 8219c34:	e0bffd0d 	sth	r2,-12(fp)
 8219c38:	e0bffd0b 	ldhu	r2,-12(fp)
 8219c3c:	108004f0 	cmpltui	r2,r2,19
 8219c40:	103ff11e 	bne	r2,zero,8219c08 <OS_QInit+0x40>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
 8219c44:	e0bffe17 	ldw	r2,-8(fp)
 8219c48:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
 8219c4c:	008209b4 	movhi	r2,2086
 8219c50:	10b02604 	addi	r2,r2,-16232
 8219c54:	d0a07615 	stw	r2,-32296(gp)
#endif
}
 8219c58:	0001883a 	nop
 8219c5c:	e037883a 	mov	sp,fp
 8219c60:	dfc00117 	ldw	ra,4(sp)
 8219c64:	df000017 	ldw	fp,0(sp)
 8219c68:	dec00204 	addi	sp,sp,8
 8219c6c:	f800283a 	ret

08219c70 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
 8219c70:	defffa04 	addi	sp,sp,-24
 8219c74:	df000515 	stw	fp,20(sp)
 8219c78:	df000504 	addi	fp,sp,20
 8219c7c:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 8219c80:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 8219c84:	e0bfff17 	ldw	r2,-4(fp)
 8219c88:	1000021e 	bne	r2,zero,8219c94 <OSSemAccept+0x24>
        return (0);
 8219c8c:	0005883a 	mov	r2,zero
 8219c90:	00001f06 	br	8219d10 <OSSemAccept+0xa0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 8219c94:	e0bfff17 	ldw	r2,-4(fp)
 8219c98:	10800003 	ldbu	r2,0(r2)
 8219c9c:	10803fcc 	andi	r2,r2,255
 8219ca0:	108000e0 	cmpeqi	r2,r2,3
 8219ca4:	1000021e 	bne	r2,zero,8219cb0 <OSSemAccept+0x40>
        return (0);
 8219ca8:	0005883a 	mov	r2,zero
 8219cac:	00001806 	br	8219d10 <OSSemAccept+0xa0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219cb0:	0005303a 	rdctl	r2,status
 8219cb4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219cb8:	e0fffe17 	ldw	r3,-8(fp)
 8219cbc:	00bfff84 	movi	r2,-2
 8219cc0:	1884703a 	and	r2,r3,r2
 8219cc4:	1001703a 	wrctl	status,r2
  
  return context;
 8219cc8:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 8219ccc:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
 8219cd0:	e0bfff17 	ldw	r2,-4(fp)
 8219cd4:	1080020b 	ldhu	r2,8(r2)
 8219cd8:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
 8219cdc:	e0bffd0b 	ldhu	r2,-12(fp)
 8219ce0:	10000626 	beq	r2,zero,8219cfc <OSSemAccept+0x8c>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
 8219ce4:	e0bfff17 	ldw	r2,-4(fp)
 8219ce8:	1080020b 	ldhu	r2,8(r2)
 8219cec:	10bfffc4 	addi	r2,r2,-1
 8219cf0:	1007883a 	mov	r3,r2
 8219cf4:	e0bfff17 	ldw	r2,-4(fp)
 8219cf8:	10c0020d 	sth	r3,8(r2)
 8219cfc:	e0bffb17 	ldw	r2,-20(fp)
 8219d00:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219d04:	e0bffc17 	ldw	r2,-16(fp)
 8219d08:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
 8219d0c:	e0bffd0b 	ldhu	r2,-12(fp)
}
 8219d10:	e037883a 	mov	sp,fp
 8219d14:	df000017 	ldw	fp,0(sp)
 8219d18:	dec00104 	addi	sp,sp,4
 8219d1c:	f800283a 	ret

08219d20 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
 8219d20:	defff904 	addi	sp,sp,-28
 8219d24:	dfc00615 	stw	ra,24(sp)
 8219d28:	df000515 	stw	fp,20(sp)
 8219d2c:	df000504 	addi	fp,sp,20
 8219d30:	2005883a 	mov	r2,r4
 8219d34:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8219d38:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8219d3c:	d0a07903 	ldbu	r2,-32284(gp)
 8219d40:	10803fcc 	andi	r2,r2,255
 8219d44:	10000226 	beq	r2,zero,8219d50 <OSSemCreate+0x30>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
 8219d48:	0005883a 	mov	r2,zero
 8219d4c:	00002506 	br	8219de4 <OSSemCreate+0xc4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219d50:	0005303a 	rdctl	r2,status
 8219d54:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219d58:	e0fffe17 	ldw	r3,-8(fp)
 8219d5c:	00bfff84 	movi	r2,-2
 8219d60:	1884703a 	and	r2,r3,r2
 8219d64:	1001703a 	wrctl	status,r2
  
  return context;
 8219d68:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 8219d6c:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
 8219d70:	d0a07817 	ldw	r2,-32288(gp)
 8219d74:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
 8219d78:	d0a07817 	ldw	r2,-32288(gp)
 8219d7c:	10000326 	beq	r2,zero,8219d8c <OSSemCreate+0x6c>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 8219d80:	d0a07817 	ldw	r2,-32288(gp)
 8219d84:	10800117 	ldw	r2,4(r2)
 8219d88:	d0a07815 	stw	r2,-32288(gp)
 8219d8c:	e0bffb17 	ldw	r2,-20(fp)
 8219d90:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219d94:	e0bffc17 	ldw	r2,-16(fp)
 8219d98:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
 8219d9c:	e0bffd17 	ldw	r2,-12(fp)
 8219da0:	10000f26 	beq	r2,zero,8219de0 <OSSemCreate+0xc0>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
 8219da4:	e0bffd17 	ldw	r2,-12(fp)
 8219da8:	00c000c4 	movi	r3,3
 8219dac:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
 8219db0:	e0bffd17 	ldw	r2,-12(fp)
 8219db4:	e0ffff0b 	ldhu	r3,-4(fp)
 8219db8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
 8219dbc:	e0bffd17 	ldw	r2,-12(fp)
 8219dc0:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
 8219dc4:	e0bffd17 	ldw	r2,-12(fp)
 8219dc8:	00c00fc4 	movi	r3,63
 8219dcc:	10c00385 	stb	r3,14(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
 8219dd0:	e0bffd17 	ldw	r2,-12(fp)
 8219dd4:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
 8219dd8:	e13ffd17 	ldw	r4,-12(fp)
 8219ddc:	82160040 	call	8216004 <OS_EventWaitListInit>
    }
    return (pevent);
 8219de0:	e0bffd17 	ldw	r2,-12(fp)
}
 8219de4:	e037883a 	mov	sp,fp
 8219de8:	dfc00117 	ldw	ra,4(sp)
 8219dec:	df000017 	ldw	fp,0(sp)
 8219df0:	dec00204 	addi	sp,sp,8
 8219df4:	f800283a 	ret

08219df8 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 8219df8:	defff304 	addi	sp,sp,-52
 8219dfc:	dfc00c15 	stw	ra,48(sp)
 8219e00:	df000b15 	stw	fp,44(sp)
 8219e04:	df000b04 	addi	fp,sp,44
 8219e08:	e13ffd15 	stw	r4,-12(fp)
 8219e0c:	2805883a 	mov	r2,r5
 8219e10:	e1bfff15 	stw	r6,-4(fp)
 8219e14:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 8219e18:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 8219e1c:	e0bfff17 	ldw	r2,-4(fp)
 8219e20:	1000021e 	bne	r2,zero,8219e2c <OSSemDel+0x34>
        return (pevent);
 8219e24:	e0bffd17 	ldw	r2,-12(fp)
 8219e28:	00007e06 	br	821a024 <OSSemDel+0x22c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 8219e2c:	e0bffd17 	ldw	r2,-12(fp)
 8219e30:	1000051e 	bne	r2,zero,8219e48 <OSSemDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 8219e34:	e0bfff17 	ldw	r2,-4(fp)
 8219e38:	00c00104 	movi	r3,4
 8219e3c:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8219e40:	e0bffd17 	ldw	r2,-12(fp)
 8219e44:	00007706 	br	821a024 <OSSemDel+0x22c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 8219e48:	e0bffd17 	ldw	r2,-12(fp)
 8219e4c:	10800003 	ldbu	r2,0(r2)
 8219e50:	10803fcc 	andi	r2,r2,255
 8219e54:	108000e0 	cmpeqi	r2,r2,3
 8219e58:	1000051e 	bne	r2,zero,8219e70 <OSSemDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 8219e5c:	e0bfff17 	ldw	r2,-4(fp)
 8219e60:	00c00044 	movi	r3,1
 8219e64:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8219e68:	e0bffd17 	ldw	r2,-12(fp)
 8219e6c:	00006d06 	br	821a024 <OSSemDel+0x22c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 8219e70:	d0a07903 	ldbu	r2,-32284(gp)
 8219e74:	10803fcc 	andi	r2,r2,255
 8219e78:	10000526 	beq	r2,zero,8219e90 <OSSemDel+0x98>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 8219e7c:	e0bfff17 	ldw	r2,-4(fp)
 8219e80:	00c003c4 	movi	r3,15
 8219e84:	10c00005 	stb	r3,0(r2)
        return (pevent);
 8219e88:	e0bffd17 	ldw	r2,-12(fp)
 8219e8c:	00006506 	br	821a024 <OSSemDel+0x22c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8219e90:	0005303a 	rdctl	r2,status
 8219e94:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8219e98:	e0fffc17 	ldw	r3,-16(fp)
 8219e9c:	00bfff84 	movi	r2,-2
 8219ea0:	1884703a 	and	r2,r3,r2
 8219ea4:	1001703a 	wrctl	status,r2
  
  return context;
 8219ea8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 8219eac:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
 8219eb0:	e0bffd17 	ldw	r2,-12(fp)
 8219eb4:	10800283 	ldbu	r2,10(r2)
 8219eb8:	10803fcc 	andi	r2,r2,255
 8219ebc:	10000326 	beq	r2,zero,8219ecc <OSSemDel+0xd4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 8219ec0:	00800044 	movi	r2,1
 8219ec4:	e0bff505 	stb	r2,-44(fp)
 8219ec8:	00000106 	br	8219ed0 <OSSemDel+0xd8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 8219ecc:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
 8219ed0:	e0bffe03 	ldbu	r2,-8(fp)
 8219ed4:	10000326 	beq	r2,zero,8219ee4 <OSSemDel+0xec>
 8219ed8:	10800060 	cmpeqi	r2,r2,1
 8219edc:	1000281e 	bne	r2,zero,8219f80 <OSSemDel+0x188>
 8219ee0:	00004506 	br	8219ff8 <OSSemDel+0x200>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
 8219ee4:	e0bff503 	ldbu	r2,-44(fp)
 8219ee8:	1000161e 	bne	r2,zero,8219f44 <OSSemDel+0x14c>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 8219eec:	e0bffd17 	ldw	r2,-12(fp)
 8219ef0:	00c00fc4 	movi	r3,63
 8219ef4:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 8219ef8:	e0bffd17 	ldw	r2,-12(fp)
 8219efc:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8219f00:	e0bffd17 	ldw	r2,-12(fp)
 8219f04:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 8219f08:	d0e07817 	ldw	r3,-32288(gp)
 8219f0c:	e0bffd17 	ldw	r2,-12(fp)
 8219f10:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 8219f14:	e0bffd17 	ldw	r2,-12(fp)
 8219f18:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 8219f1c:	e0bffd17 	ldw	r2,-12(fp)
 8219f20:	d0a07815 	stw	r2,-32288(gp)
 8219f24:	e0bff717 	ldw	r2,-36(fp)
 8219f28:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8219f2c:	e0bff817 	ldw	r2,-32(fp)
 8219f30:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 8219f34:	e0bfff17 	ldw	r2,-4(fp)
 8219f38:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
 8219f3c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
 8219f40:	00003706 	br	821a020 <OSSemDel+0x228>
 8219f44:	e0bff717 	ldw	r2,-36(fp)
 8219f48:	e0bff915 	stw	r2,-28(fp)
 8219f4c:	e0bff917 	ldw	r2,-28(fp)
 8219f50:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 8219f54:	e0bfff17 	ldw	r2,-4(fp)
 8219f58:	00c01244 	movi	r3,73
 8219f5c:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
 8219f60:	e0bffd17 	ldw	r2,-12(fp)
 8219f64:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 8219f68:	00002d06 	br	821a020 <OSSemDel+0x228>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 8219f6c:	000f883a 	mov	r7,zero
 8219f70:	01800044 	movi	r6,1
 8219f74:	000b883a 	mov	r5,zero
 8219f78:	e13ffd17 	ldw	r4,-12(fp)
 8219f7c:	8215a540 	call	8215a54 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
 8219f80:	e0bffd17 	ldw	r2,-12(fp)
 8219f84:	10800283 	ldbu	r2,10(r2)
 8219f88:	10803fcc 	andi	r2,r2,255
 8219f8c:	103ff71e 	bne	r2,zero,8219f6c <OSSemDel+0x174>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 8219f90:	e0bffd17 	ldw	r2,-12(fp)
 8219f94:	00c00fc4 	movi	r3,63
 8219f98:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 8219f9c:	e0bffd17 	ldw	r2,-12(fp)
 8219fa0:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 8219fa4:	e0bffd17 	ldw	r2,-12(fp)
 8219fa8:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 8219fac:	d0e07817 	ldw	r3,-32288(gp)
 8219fb0:	e0bffd17 	ldw	r2,-12(fp)
 8219fb4:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 8219fb8:	e0bffd17 	ldw	r2,-12(fp)
 8219fbc:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 8219fc0:	e0bffd17 	ldw	r2,-12(fp)
 8219fc4:	d0a07815 	stw	r2,-32288(gp)
 8219fc8:	e0bff717 	ldw	r2,-36(fp)
 8219fcc:	e0bffa15 	stw	r2,-24(fp)
 8219fd0:	e0bffa17 	ldw	r2,-24(fp)
 8219fd4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 8219fd8:	e0bff503 	ldbu	r2,-44(fp)
 8219fdc:	10800058 	cmpnei	r2,r2,1
 8219fe0:	1000011e 	bne	r2,zero,8219fe8 <OSSemDel+0x1f0>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 8219fe4:	82164a00 	call	82164a0 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 8219fe8:	e0bfff17 	ldw	r2,-4(fp)
 8219fec:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
 8219ff0:	e03ff615 	stw	zero,-40(fp)
             break;
 8219ff4:	00000a06 	br	821a020 <OSSemDel+0x228>
 8219ff8:	e0bff717 	ldw	r2,-36(fp)
 8219ffc:	e0bffb15 	stw	r2,-20(fp)
 821a000:	e0bffb17 	ldw	r2,-20(fp)
 821a004:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 821a008:	e0bfff17 	ldw	r2,-4(fp)
 821a00c:	00c001c4 	movi	r3,7
 821a010:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
 821a014:	e0bffd17 	ldw	r2,-12(fp)
 821a018:	e0bff615 	stw	r2,-40(fp)
             break;
 821a01c:	0001883a 	nop
    }
    return (pevent_return);
 821a020:	e0bff617 	ldw	r2,-40(fp)
}
 821a024:	e037883a 	mov	sp,fp
 821a028:	dfc00117 	ldw	ra,4(sp)
 821a02c:	df000017 	ldw	fp,0(sp)
 821a030:	dec00204 	addi	sp,sp,8
 821a034:	f800283a 	ret

0821a038 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 821a038:	defff504 	addi	sp,sp,-44
 821a03c:	dfc00a15 	stw	ra,40(sp)
 821a040:	df000915 	stw	fp,36(sp)
 821a044:	df000904 	addi	fp,sp,36
 821a048:	e13ffd15 	stw	r4,-12(fp)
 821a04c:	2805883a 	mov	r2,r5
 821a050:	e1bfff15 	stw	r6,-4(fp)
 821a054:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a058:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 821a05c:	e0bfff17 	ldw	r2,-4(fp)
 821a060:	10007226 	beq	r2,zero,821a22c <OSSemPend+0x1f4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a064:	e0bffd17 	ldw	r2,-12(fp)
 821a068:	1000041e 	bne	r2,zero,821a07c <OSSemPend+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 821a06c:	e0bfff17 	ldw	r2,-4(fp)
 821a070:	00c00104 	movi	r3,4
 821a074:	10c00005 	stb	r3,0(r2)
        return;
 821a078:	00006d06 	br	821a230 <OSSemPend+0x1f8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a07c:	e0bffd17 	ldw	r2,-12(fp)
 821a080:	10800003 	ldbu	r2,0(r2)
 821a084:	10803fcc 	andi	r2,r2,255
 821a088:	108000e0 	cmpeqi	r2,r2,3
 821a08c:	1000041e 	bne	r2,zero,821a0a0 <OSSemPend+0x68>
        *perr = OS_ERR_EVENT_TYPE;
 821a090:	e0bfff17 	ldw	r2,-4(fp)
 821a094:	00c00044 	movi	r3,1
 821a098:	10c00005 	stb	r3,0(r2)
        return;
 821a09c:	00006406 	br	821a230 <OSSemPend+0x1f8>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 821a0a0:	d0a07903 	ldbu	r2,-32284(gp)
 821a0a4:	10803fcc 	andi	r2,r2,255
 821a0a8:	10000426 	beq	r2,zero,821a0bc <OSSemPend+0x84>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 821a0ac:	e0bfff17 	ldw	r2,-4(fp)
 821a0b0:	00c00084 	movi	r3,2
 821a0b4:	10c00005 	stb	r3,0(r2)
        return;
 821a0b8:	00005d06 	br	821a230 <OSSemPend+0x1f8>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
 821a0bc:	d0a06b03 	ldbu	r2,-32340(gp)
 821a0c0:	10803fcc 	andi	r2,r2,255
 821a0c4:	10000426 	beq	r2,zero,821a0d8 <OSSemPend+0xa0>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 821a0c8:	e0bfff17 	ldw	r2,-4(fp)
 821a0cc:	00c00344 	movi	r3,13
 821a0d0:	10c00005 	stb	r3,0(r2)
        return;
 821a0d4:	00005606 	br	821a230 <OSSemPend+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a0d8:	0005303a 	rdctl	r2,status
 821a0dc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a0e0:	e0fffc17 	ldw	r3,-16(fp)
 821a0e4:	00bfff84 	movi	r2,-2
 821a0e8:	1884703a 	and	r2,r3,r2
 821a0ec:	1001703a 	wrctl	status,r2
  
  return context;
 821a0f0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821a0f4:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
 821a0f8:	e0bffd17 	ldw	r2,-12(fp)
 821a0fc:	1080020b 	ldhu	r2,8(r2)
 821a100:	10bfffcc 	andi	r2,r2,65535
 821a104:	10000d26 	beq	r2,zero,821a13c <OSSemPend+0x104>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
 821a108:	e0bffd17 	ldw	r2,-12(fp)
 821a10c:	1080020b 	ldhu	r2,8(r2)
 821a110:	10bfffc4 	addi	r2,r2,-1
 821a114:	1007883a 	mov	r3,r2
 821a118:	e0bffd17 	ldw	r2,-12(fp)
 821a11c:	10c0020d 	sth	r3,8(r2)
 821a120:	e0bff717 	ldw	r2,-36(fp)
 821a124:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a128:	e0bff817 	ldw	r2,-32(fp)
 821a12c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 821a130:	e0bfff17 	ldw	r2,-4(fp)
 821a134:	10000005 	stb	zero,0(r2)
        return;
 821a138:	00003d06 	br	821a230 <OSSemPend+0x1f8>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
 821a13c:	d0a07a17 	ldw	r2,-32280(gp)
 821a140:	d0e07a17 	ldw	r3,-32280(gp)
 821a144:	18c00c03 	ldbu	r3,48(r3)
 821a148:	18c00054 	ori	r3,r3,1
 821a14c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 821a150:	d0a07a17 	ldw	r2,-32280(gp)
 821a154:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
 821a158:	d0a07a17 	ldw	r2,-32280(gp)
 821a15c:	e0fffe0b 	ldhu	r3,-8(fp)
 821a160:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 821a164:	e13ffd17 	ldw	r4,-12(fp)
 821a168:	8215bec0 	call	8215bec <OS_EventTaskWait>
 821a16c:	e0bff717 	ldw	r2,-36(fp)
 821a170:	e0bffb15 	stw	r2,-20(fp)
 821a174:	e0bffb17 	ldw	r2,-20(fp)
 821a178:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
 821a17c:	82164a00 	call	82164a0 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a180:	0005303a 	rdctl	r2,status
 821a184:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a188:	e0fff917 	ldw	r3,-28(fp)
 821a18c:	00bfff84 	movi	r2,-2
 821a190:	1884703a 	and	r2,r3,r2
 821a194:	1001703a 	wrctl	status,r2
  
  return context;
 821a198:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
 821a19c:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 821a1a0:	d0a07a17 	ldw	r2,-32280(gp)
 821a1a4:	10800c43 	ldbu	r2,49(r2)
 821a1a8:	10803fcc 	andi	r2,r2,255
 821a1ac:	10000326 	beq	r2,zero,821a1bc <OSSemPend+0x184>
 821a1b0:	108000a0 	cmpeqi	r2,r2,2
 821a1b4:	1000041e 	bne	r2,zero,821a1c8 <OSSemPend+0x190>
 821a1b8:	00000706 	br	821a1d8 <OSSemPend+0x1a0>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
 821a1bc:	e0bfff17 	ldw	r2,-4(fp)
 821a1c0:	10000005 	stb	zero,0(r2)
             break;
 821a1c4:	00000c06 	br	821a1f8 <OSSemPend+0x1c0>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 821a1c8:	e0bfff17 	ldw	r2,-4(fp)
 821a1cc:	00c00384 	movi	r3,14
 821a1d0:	10c00005 	stb	r3,0(r2)
             break;
 821a1d4:	00000806 	br	821a1f8 <OSSemPend+0x1c0>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
 821a1d8:	d0a07a17 	ldw	r2,-32280(gp)
 821a1dc:	e17ffd17 	ldw	r5,-12(fp)
 821a1e0:	1009883a 	mov	r4,r2
 821a1e4:	8215e4c0 	call	8215e4c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 821a1e8:	e0bfff17 	ldw	r2,-4(fp)
 821a1ec:	00c00284 	movi	r3,10
 821a1f0:	10c00005 	stb	r3,0(r2)
             break;
 821a1f4:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 821a1f8:	d0a07a17 	ldw	r2,-32280(gp)
 821a1fc:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 821a200:	d0a07a17 	ldw	r2,-32280(gp)
 821a204:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 821a208:	d0a07a17 	ldw	r2,-32280(gp)
 821a20c:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 821a210:	d0a07a17 	ldw	r2,-32280(gp)
 821a214:	10000815 	stw	zero,32(r2)
 821a218:	e0bff717 	ldw	r2,-36(fp)
 821a21c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a220:	e0bffa17 	ldw	r2,-24(fp)
 821a224:	1001703a 	wrctl	status,r2
 821a228:	00000106 	br	821a230 <OSSemPend+0x1f8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
 821a22c:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
 821a230:	e037883a 	mov	sp,fp
 821a234:	dfc00117 	ldw	ra,4(sp)
 821a238:	df000017 	ldw	fp,0(sp)
 821a23c:	dec00204 	addi	sp,sp,8
 821a240:	f800283a 	ret

0821a244 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 821a244:	defff604 	addi	sp,sp,-40
 821a248:	dfc00915 	stw	ra,36(sp)
 821a24c:	df000815 	stw	fp,32(sp)
 821a250:	df000804 	addi	fp,sp,32
 821a254:	e13ffd15 	stw	r4,-12(fp)
 821a258:	2805883a 	mov	r2,r5
 821a25c:	e1bfff15 	stw	r6,-4(fp)
 821a260:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a264:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 821a268:	e0bfff17 	ldw	r2,-4(fp)
 821a26c:	1000021e 	bne	r2,zero,821a278 <OSSemPendAbort+0x34>
        return (0);
 821a270:	0005883a 	mov	r2,zero
 821a274:	00004906 	br	821a39c <OSSemPendAbort+0x158>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a278:	e0bffd17 	ldw	r2,-12(fp)
 821a27c:	1000051e 	bne	r2,zero,821a294 <OSSemPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 821a280:	e0bfff17 	ldw	r2,-4(fp)
 821a284:	00c00104 	movi	r3,4
 821a288:	10c00005 	stb	r3,0(r2)
        return (0);
 821a28c:	0005883a 	mov	r2,zero
 821a290:	00004206 	br	821a39c <OSSemPendAbort+0x158>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a294:	e0bffd17 	ldw	r2,-12(fp)
 821a298:	10800003 	ldbu	r2,0(r2)
 821a29c:	10803fcc 	andi	r2,r2,255
 821a2a0:	108000e0 	cmpeqi	r2,r2,3
 821a2a4:	1000051e 	bne	r2,zero,821a2bc <OSSemPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 821a2a8:	e0bfff17 	ldw	r2,-4(fp)
 821a2ac:	00c00044 	movi	r3,1
 821a2b0:	10c00005 	stb	r3,0(r2)
        return (0);
 821a2b4:	0005883a 	mov	r2,zero
 821a2b8:	00003806 	br	821a39c <OSSemPendAbort+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a2bc:	0005303a 	rdctl	r2,status
 821a2c0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a2c4:	e0fffc17 	ldw	r3,-16(fp)
 821a2c8:	00bfff84 	movi	r2,-2
 821a2cc:	1884703a 	and	r2,r3,r2
 821a2d0:	1001703a 	wrctl	status,r2
  
  return context;
 821a2d4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821a2d8:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
 821a2dc:	e0bffd17 	ldw	r2,-12(fp)
 821a2e0:	10800283 	ldbu	r2,10(r2)
 821a2e4:	10803fcc 	andi	r2,r2,255
 821a2e8:	10002526 	beq	r2,zero,821a380 <OSSemPendAbort+0x13c>
        nbr_tasks = 0;
 821a2ec:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 821a2f0:	e0bffe03 	ldbu	r2,-8(fp)
 821a2f4:	10800060 	cmpeqi	r2,r2,1
 821a2f8:	10000e26 	beq	r2,zero,821a334 <OSSemPendAbort+0xf0>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 821a2fc:	00000806 	br	821a320 <OSSemPendAbort+0xdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 821a300:	01c00084 	movi	r7,2
 821a304:	01800044 	movi	r6,1
 821a308:	000b883a 	mov	r5,zero
 821a30c:	e13ffd17 	ldw	r4,-12(fp)
 821a310:	8215a540 	call	8215a54 <OS_EventTaskRdy>
                     nbr_tasks++;
 821a314:	e0bff803 	ldbu	r2,-32(fp)
 821a318:	10800044 	addi	r2,r2,1
 821a31c:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 821a320:	e0bffd17 	ldw	r2,-12(fp)
 821a324:	10800283 	ldbu	r2,10(r2)
 821a328:	10803fcc 	andi	r2,r2,255
 821a32c:	103ff41e 	bne	r2,zero,821a300 <OSSemPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 821a330:	00000906 	br	821a358 <OSSemPendAbort+0x114>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 821a334:	01c00084 	movi	r7,2
 821a338:	01800044 	movi	r6,1
 821a33c:	000b883a 	mov	r5,zero
 821a340:	e13ffd17 	ldw	r4,-12(fp)
 821a344:	8215a540 	call	8215a54 <OS_EventTaskRdy>
                 nbr_tasks++;
 821a348:	e0bff803 	ldbu	r2,-32(fp)
 821a34c:	10800044 	addi	r2,r2,1
 821a350:	e0bff805 	stb	r2,-32(fp)
                 break;
 821a354:	0001883a 	nop
 821a358:	e0bff917 	ldw	r2,-28(fp)
 821a35c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a360:	e0bffa17 	ldw	r2,-24(fp)
 821a364:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 821a368:	82164a00 	call	82164a0 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 821a36c:	e0bfff17 	ldw	r2,-4(fp)
 821a370:	00c00384 	movi	r3,14
 821a374:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 821a378:	e0bff803 	ldbu	r2,-32(fp)
 821a37c:	00000706 	br	821a39c <OSSemPendAbort+0x158>
 821a380:	e0bff917 	ldw	r2,-28(fp)
 821a384:	e0bffb15 	stw	r2,-20(fp)
 821a388:	e0bffb17 	ldw	r2,-20(fp)
 821a38c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821a390:	e0bfff17 	ldw	r2,-4(fp)
 821a394:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
 821a398:	0005883a 	mov	r2,zero
}
 821a39c:	e037883a 	mov	sp,fp
 821a3a0:	dfc00117 	ldw	ra,4(sp)
 821a3a4:	df000017 	ldw	fp,0(sp)
 821a3a8:	dec00204 	addi	sp,sp,8
 821a3ac:	f800283a 	ret

0821a3b0 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
 821a3b0:	defff804 	addi	sp,sp,-32
 821a3b4:	dfc00715 	stw	ra,28(sp)
 821a3b8:	df000615 	stw	fp,24(sp)
 821a3bc:	df000604 	addi	fp,sp,24
 821a3c0:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a3c4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a3c8:	e0bfff17 	ldw	r2,-4(fp)
 821a3cc:	1000021e 	bne	r2,zero,821a3d8 <OSSemPost+0x28>
        return (OS_ERR_PEVENT_NULL);
 821a3d0:	00800104 	movi	r2,4
 821a3d4:	00003506 	br	821a4ac <OSSemPost+0xfc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a3d8:	e0bfff17 	ldw	r2,-4(fp)
 821a3dc:	10800003 	ldbu	r2,0(r2)
 821a3e0:	10803fcc 	andi	r2,r2,255
 821a3e4:	108000e0 	cmpeqi	r2,r2,3
 821a3e8:	1000021e 	bne	r2,zero,821a3f4 <OSSemPost+0x44>
        return (OS_ERR_EVENT_TYPE);
 821a3ec:	00800044 	movi	r2,1
 821a3f0:	00002e06 	br	821a4ac <OSSemPost+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a3f4:	0005303a 	rdctl	r2,status
 821a3f8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a3fc:	e0fffe17 	ldw	r3,-8(fp)
 821a400:	00bfff84 	movi	r2,-2
 821a404:	1884703a 	and	r2,r3,r2
 821a408:	1001703a 	wrctl	status,r2
  
  return context;
 821a40c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 821a410:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
 821a414:	e0bfff17 	ldw	r2,-4(fp)
 821a418:	10800283 	ldbu	r2,10(r2)
 821a41c:	10803fcc 	andi	r2,r2,255
 821a420:	10000c26 	beq	r2,zero,821a454 <OSSemPost+0xa4>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 821a424:	000f883a 	mov	r7,zero
 821a428:	01800044 	movi	r6,1
 821a42c:	000b883a 	mov	r5,zero
 821a430:	e13fff17 	ldw	r4,-4(fp)
 821a434:	8215a540 	call	8215a54 <OS_EventTaskRdy>
 821a438:	e0bffa17 	ldw	r2,-24(fp)
 821a43c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a440:	e0bffb17 	ldw	r2,-20(fp)
 821a444:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 821a448:	82164a00 	call	82164a0 <OS_Sched>
        return (OS_ERR_NONE);
 821a44c:	0005883a 	mov	r2,zero
 821a450:	00001606 	br	821a4ac <OSSemPost+0xfc>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
 821a454:	e0bfff17 	ldw	r2,-4(fp)
 821a458:	1080020b 	ldhu	r2,8(r2)
 821a45c:	10ffffcc 	andi	r3,r2,65535
 821a460:	00bfffd4 	movui	r2,65535
 821a464:	18800c26 	beq	r3,r2,821a498 <OSSemPost+0xe8>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
 821a468:	e0bfff17 	ldw	r2,-4(fp)
 821a46c:	1080020b 	ldhu	r2,8(r2)
 821a470:	10800044 	addi	r2,r2,1
 821a474:	1007883a 	mov	r3,r2
 821a478:	e0bfff17 	ldw	r2,-4(fp)
 821a47c:	10c0020d 	sth	r3,8(r2)
 821a480:	e0bffa17 	ldw	r2,-24(fp)
 821a484:	e0bffc15 	stw	r2,-16(fp)
 821a488:	e0bffc17 	ldw	r2,-16(fp)
 821a48c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 821a490:	0005883a 	mov	r2,zero
 821a494:	00000506 	br	821a4ac <OSSemPost+0xfc>
 821a498:	e0bffa17 	ldw	r2,-24(fp)
 821a49c:	e0bffd15 	stw	r2,-12(fp)
 821a4a0:	e0bffd17 	ldw	r2,-12(fp)
 821a4a4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
 821a4a8:	00800c84 	movi	r2,50
}
 821a4ac:	e037883a 	mov	sp,fp
 821a4b0:	dfc00117 	ldw	ra,4(sp)
 821a4b4:	df000017 	ldw	fp,0(sp)
 821a4b8:	dec00204 	addi	sp,sp,8
 821a4bc:	f800283a 	ret

0821a4c0 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
 821a4c0:	defff704 	addi	sp,sp,-36
 821a4c4:	df000815 	stw	fp,32(sp)
 821a4c8:	df000804 	addi	fp,sp,32
 821a4cc:	e13ffe15 	stw	r4,-8(fp)
 821a4d0:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 821a4d4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 821a4d8:	e0bffe17 	ldw	r2,-8(fp)
 821a4dc:	1000021e 	bne	r2,zero,821a4e8 <OSSemQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 821a4e0:	00800104 	movi	r2,4
 821a4e4:	00003606 	br	821a5c0 <OSSemQuery+0x100>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
 821a4e8:	e0bfff17 	ldw	r2,-4(fp)
 821a4ec:	1000021e 	bne	r2,zero,821a4f8 <OSSemQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 821a4f0:	00800244 	movi	r2,9
 821a4f4:	00003206 	br	821a5c0 <OSSemQuery+0x100>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 821a4f8:	e0bffe17 	ldw	r2,-8(fp)
 821a4fc:	10800003 	ldbu	r2,0(r2)
 821a500:	10803fcc 	andi	r2,r2,255
 821a504:	108000e0 	cmpeqi	r2,r2,3
 821a508:	1000021e 	bne	r2,zero,821a514 <OSSemQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 821a50c:	00800044 	movi	r2,1
 821a510:	00002b06 	br	821a5c0 <OSSemQuery+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a514:	0005303a 	rdctl	r2,status
 821a518:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a51c:	e0fffd17 	ldw	r3,-12(fp)
 821a520:	00bfff84 	movi	r2,-2
 821a524:	1884703a 	and	r2,r3,r2
 821a528:	1001703a 	wrctl	status,r2
  
  return context;
 821a52c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 821a530:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
 821a534:	e0bffe17 	ldw	r2,-8(fp)
 821a538:	10c00283 	ldbu	r3,10(r2)
 821a53c:	e0bfff17 	ldw	r2,-4(fp)
 821a540:	10c00145 	stb	r3,5(r2)
    psrc                   = &pevent->OSEventTbl[0];
 821a544:	e0bffe17 	ldw	r2,-8(fp)
 821a548:	108002c4 	addi	r2,r2,11
 821a54c:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
 821a550:	e0bfff17 	ldw	r2,-4(fp)
 821a554:	10800084 	addi	r2,r2,2
 821a558:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 821a55c:	e03ffa05 	stb	zero,-24(fp)
 821a560:	00000b06 	br	821a590 <OSSemQuery+0xd0>
        *pdest++ = *psrc++;
 821a564:	e0bff917 	ldw	r2,-28(fp)
 821a568:	10c00044 	addi	r3,r2,1
 821a56c:	e0fff915 	stw	r3,-28(fp)
 821a570:	e0fff817 	ldw	r3,-32(fp)
 821a574:	19000044 	addi	r4,r3,1
 821a578:	e13ff815 	stw	r4,-32(fp)
 821a57c:	18c00003 	ldbu	r3,0(r3)
 821a580:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 821a584:	e0bffa03 	ldbu	r2,-24(fp)
 821a588:	10800044 	addi	r2,r2,1
 821a58c:	e0bffa05 	stb	r2,-24(fp)
 821a590:	e0bffa03 	ldbu	r2,-24(fp)
 821a594:	108000f0 	cmpltui	r2,r2,3
 821a598:	103ff21e 	bne	r2,zero,821a564 <OSSemQuery+0xa4>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
 821a59c:	e0bffe17 	ldw	r2,-8(fp)
 821a5a0:	10c0020b 	ldhu	r3,8(r2)
 821a5a4:	e0bfff17 	ldw	r2,-4(fp)
 821a5a8:	10c0000d 	sth	r3,0(r2)
 821a5ac:	e0bffb17 	ldw	r2,-20(fp)
 821a5b0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a5b4:	e0bffc17 	ldw	r2,-16(fp)
 821a5b8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821a5bc:	0005883a 	mov	r2,zero
}
 821a5c0:	e037883a 	mov	sp,fp
 821a5c4:	df000017 	ldw	fp,0(sp)
 821a5c8:	dec00104 	addi	sp,sp,4
 821a5cc:	f800283a 	ret

0821a5d0 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
 821a5d0:	defff904 	addi	sp,sp,-28
 821a5d4:	df000615 	stw	fp,24(sp)
 821a5d8:	df000604 	addi	fp,sp,24
 821a5dc:	e13ffd15 	stw	r4,-12(fp)
 821a5e0:	2805883a 	mov	r2,r5
 821a5e4:	e1bfff15 	stw	r6,-4(fp)
 821a5e8:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821a5ec:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 821a5f0:	e0bfff17 	ldw	r2,-4(fp)
 821a5f4:	10003126 	beq	r2,zero,821a6bc <OSSemSet+0xec>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 821a5f8:	e0bffd17 	ldw	r2,-12(fp)
 821a5fc:	1000041e 	bne	r2,zero,821a610 <OSSemSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
 821a600:	e0bfff17 	ldw	r2,-4(fp)
 821a604:	00c00104 	movi	r3,4
 821a608:	10c00005 	stb	r3,0(r2)
        return;
 821a60c:	00002c06 	br	821a6c0 <OSSemSet+0xf0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 821a610:	e0bffd17 	ldw	r2,-12(fp)
 821a614:	10800003 	ldbu	r2,0(r2)
 821a618:	10803fcc 	andi	r2,r2,255
 821a61c:	108000e0 	cmpeqi	r2,r2,3
 821a620:	1000041e 	bne	r2,zero,821a634 <OSSemSet+0x64>
        *perr = OS_ERR_EVENT_TYPE;
 821a624:	e0bfff17 	ldw	r2,-4(fp)
 821a628:	00c00044 	movi	r3,1
 821a62c:	10c00005 	stb	r3,0(r2)
        return;
 821a630:	00002306 	br	821a6c0 <OSSemSet+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a634:	0005303a 	rdctl	r2,status
 821a638:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a63c:	e0fffc17 	ldw	r3,-16(fp)
 821a640:	00bfff84 	movi	r2,-2
 821a644:	1884703a 	and	r2,r3,r2
 821a648:	1001703a 	wrctl	status,r2
  
  return context;
 821a64c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821a650:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
 821a654:	e0bfff17 	ldw	r2,-4(fp)
 821a658:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
 821a65c:	e0bffd17 	ldw	r2,-12(fp)
 821a660:	1080020b 	ldhu	r2,8(r2)
 821a664:	10bfffcc 	andi	r2,r2,65535
 821a668:	10000426 	beq	r2,zero,821a67c <OSSemSet+0xac>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
 821a66c:	e0bffd17 	ldw	r2,-12(fp)
 821a670:	e0fffe0b 	ldhu	r3,-8(fp)
 821a674:	10c0020d 	sth	r3,8(r2)
 821a678:	00000b06 	br	821a6a8 <OSSemSet+0xd8>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
 821a67c:	e0bffd17 	ldw	r2,-12(fp)
 821a680:	10800283 	ldbu	r2,10(r2)
 821a684:	10803fcc 	andi	r2,r2,255
 821a688:	1000041e 	bne	r2,zero,821a69c <OSSemSet+0xcc>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
 821a68c:	e0bffd17 	ldw	r2,-12(fp)
 821a690:	e0fffe0b 	ldhu	r3,-8(fp)
 821a694:	10c0020d 	sth	r3,8(r2)
 821a698:	00000306 	br	821a6a8 <OSSemSet+0xd8>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
 821a69c:	e0bfff17 	ldw	r2,-4(fp)
 821a6a0:	00c01244 	movi	r3,73
 821a6a4:	10c00005 	stb	r3,0(r2)
 821a6a8:	e0bffa17 	ldw	r2,-24(fp)
 821a6ac:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a6b0:	e0bffb17 	ldw	r2,-20(fp)
 821a6b4:	1001703a 	wrctl	status,r2
 821a6b8:	00000106 	br	821a6c0 <OSSemSet+0xf0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
 821a6bc:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
 821a6c0:	e037883a 	mov	sp,fp
 821a6c4:	df000017 	ldw	fp,0(sp)
 821a6c8:	dec00104 	addi	sp,sp,4
 821a6cc:	f800283a 	ret

0821a6d0 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
 821a6d0:	defff104 	addi	sp,sp,-60
 821a6d4:	dfc00e15 	stw	ra,56(sp)
 821a6d8:	df000d15 	stw	fp,52(sp)
 821a6dc:	df000d04 	addi	fp,sp,52
 821a6e0:	2007883a 	mov	r3,r4
 821a6e4:	2805883a 	mov	r2,r5
 821a6e8:	e0fffe05 	stb	r3,-8(fp)
 821a6ec:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
 821a6f0:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
 821a6f4:	e0bffe03 	ldbu	r2,-8(fp)
 821a6f8:	10800530 	cmpltui	r2,r2,20
 821a6fc:	1000051e 	bne	r2,zero,821a714 <OSTaskChangePrio+0x44>
        if (oldprio != OS_PRIO_SELF) {
 821a700:	e0bffe03 	ldbu	r2,-8(fp)
 821a704:	10803fe0 	cmpeqi	r2,r2,255
 821a708:	1000021e 	bne	r2,zero,821a714 <OSTaskChangePrio+0x44>
            return (OS_ERR_PRIO_INVALID);
 821a70c:	00800a84 	movi	r2,42
 821a710:	00012606 	br	821abac <OSTaskChangePrio+0x4dc>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
 821a714:	e0bfff03 	ldbu	r2,-4(fp)
 821a718:	10800530 	cmpltui	r2,r2,20
 821a71c:	1000021e 	bne	r2,zero,821a728 <OSTaskChangePrio+0x58>
        return (OS_ERR_PRIO_INVALID);
 821a720:	00800a84 	movi	r2,42
 821a724:	00012106 	br	821abac <OSTaskChangePrio+0x4dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821a728:	0005303a 	rdctl	r2,status
 821a72c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821a730:	e0fffd17 	ldw	r3,-12(fp)
 821a734:	00bfff84 	movi	r2,-2
 821a738:	1884703a 	and	r2,r3,r2
 821a73c:	1001703a 	wrctl	status,r2
  
  return context;
 821a740:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821a744:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
 821a748:	e0ffff03 	ldbu	r3,-4(fp)
 821a74c:	008209b4 	movhi	r2,2086
 821a750:	10b6b204 	addi	r2,r2,-9528
 821a754:	18c7883a 	add	r3,r3,r3
 821a758:	18c7883a 	add	r3,r3,r3
 821a75c:	10c5883a 	add	r2,r2,r3
 821a760:	10800017 	ldw	r2,0(r2)
 821a764:	10000626 	beq	r2,zero,821a780 <OSTaskChangePrio+0xb0>
 821a768:	e0bff517 	ldw	r2,-44(fp)
 821a76c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821a770:	e0bff617 	ldw	r2,-40(fp)
 821a774:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
 821a778:	00800a04 	movi	r2,40
 821a77c:	00010b06 	br	821abac <OSTaskChangePrio+0x4dc>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
 821a780:	e0bffe03 	ldbu	r2,-8(fp)
 821a784:	10803fd8 	cmpnei	r2,r2,255
 821a788:	1000031e 	bne	r2,zero,821a798 <OSTaskChangePrio+0xc8>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
 821a78c:	d0a07a17 	ldw	r2,-32280(gp)
 821a790:	10800c83 	ldbu	r2,50(r2)
 821a794:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
 821a798:	e0fffe03 	ldbu	r3,-8(fp)
 821a79c:	008209b4 	movhi	r2,2086
 821a7a0:	10b6b204 	addi	r2,r2,-9528
 821a7a4:	18c7883a 	add	r3,r3,r3
 821a7a8:	18c7883a 	add	r3,r3,r3
 821a7ac:	10c5883a 	add	r2,r2,r3
 821a7b0:	10800017 	ldw	r2,0(r2)
 821a7b4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
 821a7b8:	e0bff817 	ldw	r2,-32(fp)
 821a7bc:	1000061e 	bne	r2,zero,821a7d8 <OSTaskChangePrio+0x108>
 821a7c0:	e0bff517 	ldw	r2,-44(fp)
 821a7c4:	e0bff715 	stw	r2,-36(fp)
 821a7c8:	e0bff717 	ldw	r2,-36(fp)
 821a7cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
 821a7d0:	00800a44 	movi	r2,41
 821a7d4:	0000f506 	br	821abac <OSTaskChangePrio+0x4dc>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
 821a7d8:	e0bff817 	ldw	r2,-32(fp)
 821a7dc:	10800058 	cmpnei	r2,r2,1
 821a7e0:	1000061e 	bne	r2,zero,821a7fc <OSTaskChangePrio+0x12c>
 821a7e4:	e0bff517 	ldw	r2,-44(fp)
 821a7e8:	e0bff915 	stw	r2,-28(fp)
 821a7ec:	e0bff917 	ldw	r2,-28(fp)
 821a7f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
 821a7f4:	008010c4 	movi	r2,67
 821a7f8:	0000ec06 	br	821abac <OSTaskChangePrio+0x4dc>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
 821a7fc:	e0bfff03 	ldbu	r2,-4(fp)
 821a800:	1004d0fa 	srli	r2,r2,3
 821a804:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
 821a808:	e0bfff03 	ldbu	r2,-4(fp)
 821a80c:	108001cc 	andi	r2,r2,7
 821a810:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
 821a814:	e0bffb03 	ldbu	r2,-20(fp)
 821a818:	00c00044 	movi	r3,1
 821a81c:	1884983a 	sll	r2,r3,r2
 821a820:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
 821a824:	e0bffb43 	ldbu	r2,-19(fp)
 821a828:	00c00044 	movi	r3,1
 821a82c:	1884983a 	sll	r2,r3,r2
 821a830:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
 821a834:	e0fffe03 	ldbu	r3,-8(fp)
 821a838:	008209b4 	movhi	r2,2086
 821a83c:	10b6b204 	addi	r2,r2,-9528
 821a840:	18c7883a 	add	r3,r3,r3
 821a844:	18c7883a 	add	r3,r3,r3
 821a848:	10c5883a 	add	r2,r2,r3
 821a84c:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
 821a850:	e0ffff03 	ldbu	r3,-4(fp)
 821a854:	008209b4 	movhi	r2,2086
 821a858:	10b6b204 	addi	r2,r2,-9528
 821a85c:	18c7883a 	add	r3,r3,r3
 821a860:	18c7883a 	add	r3,r3,r3
 821a864:	10c5883a 	add	r2,r2,r3
 821a868:	e0fff817 	ldw	r3,-32(fp)
 821a86c:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
 821a870:	e0bff817 	ldw	r2,-32(fp)
 821a874:	10800d03 	ldbu	r2,52(r2)
 821a878:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
 821a87c:	e0bff817 	ldw	r2,-32(fp)
 821a880:	10800d83 	ldbu	r2,54(r2)
 821a884:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
 821a888:	e0bff817 	ldw	r2,-32(fp)
 821a88c:	10800d43 	ldbu	r2,53(r2)
 821a890:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
 821a894:	e0fffc03 	ldbu	r3,-16(fp)
 821a898:	d0a07744 	addi	r2,gp,-32291
 821a89c:	1885883a 	add	r2,r3,r2
 821a8a0:	10c00003 	ldbu	r3,0(r2)
 821a8a4:	e0bffc83 	ldbu	r2,-14(fp)
 821a8a8:	1884703a 	and	r2,r3,r2
 821a8ac:	10803fcc 	andi	r2,r2,255
 821a8b0:	10002826 	beq	r2,zero,821a954 <OSTaskChangePrio+0x284>
         OSRdyTbl[y_old] &= ~bitx_old;
 821a8b4:	e0fffc03 	ldbu	r3,-16(fp)
 821a8b8:	e13ffc03 	ldbu	r4,-16(fp)
 821a8bc:	d0a07744 	addi	r2,gp,-32291
 821a8c0:	2085883a 	add	r2,r4,r2
 821a8c4:	10800003 	ldbu	r2,0(r2)
 821a8c8:	1009883a 	mov	r4,r2
 821a8cc:	e0bffc83 	ldbu	r2,-14(fp)
 821a8d0:	0084303a 	nor	r2,zero,r2
 821a8d4:	2084703a 	and	r2,r4,r2
 821a8d8:	1009883a 	mov	r4,r2
 821a8dc:	d0a07744 	addi	r2,gp,-32291
 821a8e0:	1885883a 	add	r2,r3,r2
 821a8e4:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
 821a8e8:	e0fffc03 	ldbu	r3,-16(fp)
 821a8ec:	d0a07744 	addi	r2,gp,-32291
 821a8f0:	1885883a 	add	r2,r3,r2
 821a8f4:	10800003 	ldbu	r2,0(r2)
 821a8f8:	10803fcc 	andi	r2,r2,255
 821a8fc:	1000061e 	bne	r2,zero,821a918 <OSTaskChangePrio+0x248>
             OSRdyGrp &= ~bity_old;
 821a900:	e0bffc43 	ldbu	r2,-15(fp)
 821a904:	0084303a 	nor	r2,zero,r2
 821a908:	1007883a 	mov	r3,r2
 821a90c:	d0a07703 	ldbu	r2,-32292(gp)
 821a910:	1884703a 	and	r2,r3,r2
 821a914:	d0a07705 	stb	r2,-32292(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
 821a918:	d0e07703 	ldbu	r3,-32292(gp)
 821a91c:	e0bffb83 	ldbu	r2,-18(fp)
 821a920:	1884b03a 	or	r2,r3,r2
 821a924:	d0a07705 	stb	r2,-32292(gp)
         OSRdyTbl[y_new] |= bitx_new;
 821a928:	e0fffb03 	ldbu	r3,-20(fp)
 821a92c:	e13ffb03 	ldbu	r4,-20(fp)
 821a930:	d0a07744 	addi	r2,gp,-32291
 821a934:	2085883a 	add	r2,r4,r2
 821a938:	11000003 	ldbu	r4,0(r2)
 821a93c:	e0bffbc3 	ldbu	r2,-17(fp)
 821a940:	2084b03a 	or	r2,r4,r2
 821a944:	1009883a 	mov	r4,r2
 821a948:	d0a07744 	addi	r2,gp,-32291
 821a94c:	1885883a 	add	r2,r3,r2
 821a950:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
 821a954:	e0bff817 	ldw	r2,-32(fp)
 821a958:	10800717 	ldw	r2,28(r2)
 821a95c:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
 821a960:	e0bff317 	ldw	r2,-52(fp)
 821a964:	10003326 	beq	r2,zero,821aa34 <OSTaskChangePrio+0x364>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
 821a968:	e0bffc03 	ldbu	r2,-16(fp)
 821a96c:	e0fffc03 	ldbu	r3,-16(fp)
 821a970:	e13ff317 	ldw	r4,-52(fp)
 821a974:	20c7883a 	add	r3,r4,r3
 821a978:	18c002c4 	addi	r3,r3,11
 821a97c:	18c00003 	ldbu	r3,0(r3)
 821a980:	1809883a 	mov	r4,r3
 821a984:	e0fffc83 	ldbu	r3,-14(fp)
 821a988:	00c6303a 	nor	r3,zero,r3
 821a98c:	20c6703a 	and	r3,r4,r3
 821a990:	1809883a 	mov	r4,r3
 821a994:	e0fff317 	ldw	r3,-52(fp)
 821a998:	1885883a 	add	r2,r3,r2
 821a99c:	108002c4 	addi	r2,r2,11
 821a9a0:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
 821a9a4:	e0bffc03 	ldbu	r2,-16(fp)
 821a9a8:	e0fff317 	ldw	r3,-52(fp)
 821a9ac:	1885883a 	add	r2,r3,r2
 821a9b0:	108002c4 	addi	r2,r2,11
 821a9b4:	10800003 	ldbu	r2,0(r2)
 821a9b8:	10803fcc 	andi	r2,r2,255
 821a9bc:	1000091e 	bne	r2,zero,821a9e4 <OSTaskChangePrio+0x314>
            pevent->OSEventGrp    &= ~bity_old;
 821a9c0:	e0bff317 	ldw	r2,-52(fp)
 821a9c4:	10800283 	ldbu	r2,10(r2)
 821a9c8:	1007883a 	mov	r3,r2
 821a9cc:	e0bffc43 	ldbu	r2,-15(fp)
 821a9d0:	0084303a 	nor	r2,zero,r2
 821a9d4:	1884703a 	and	r2,r3,r2
 821a9d8:	1007883a 	mov	r3,r2
 821a9dc:	e0bff317 	ldw	r2,-52(fp)
 821a9e0:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
 821a9e4:	e0bff317 	ldw	r2,-52(fp)
 821a9e8:	10c00283 	ldbu	r3,10(r2)
 821a9ec:	e0bffb83 	ldbu	r2,-18(fp)
 821a9f0:	1884b03a 	or	r2,r3,r2
 821a9f4:	1007883a 	mov	r3,r2
 821a9f8:	e0bff317 	ldw	r2,-52(fp)
 821a9fc:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
 821aa00:	e0bffb03 	ldbu	r2,-20(fp)
 821aa04:	e0fffb03 	ldbu	r3,-20(fp)
 821aa08:	e13ff317 	ldw	r4,-52(fp)
 821aa0c:	20c7883a 	add	r3,r4,r3
 821aa10:	18c002c4 	addi	r3,r3,11
 821aa14:	19000003 	ldbu	r4,0(r3)
 821aa18:	e0fffbc3 	ldbu	r3,-17(fp)
 821aa1c:	20c6b03a 	or	r3,r4,r3
 821aa20:	1809883a 	mov	r4,r3
 821aa24:	e0fff317 	ldw	r3,-52(fp)
 821aa28:	1885883a 	add	r2,r3,r2
 821aa2c:	108002c4 	addi	r2,r2,11
 821aa30:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
 821aa34:	e0bff817 	ldw	r2,-32(fp)
 821aa38:	10800817 	ldw	r2,32(r2)
 821aa3c:	10004226 	beq	r2,zero,821ab48 <OSTaskChangePrio+0x478>
        pevents =  ptcb->OSTCBEventMultiPtr;
 821aa40:	e0bff817 	ldw	r2,-32(fp)
 821aa44:	10800817 	ldw	r2,32(r2)
 821aa48:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
 821aa4c:	e0bff417 	ldw	r2,-48(fp)
 821aa50:	10800017 	ldw	r2,0(r2)
 821aa54:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
 821aa58:	00003906 	br	821ab40 <OSTaskChangePrio+0x470>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
 821aa5c:	e0bffc03 	ldbu	r2,-16(fp)
 821aa60:	e0fffc03 	ldbu	r3,-16(fp)
 821aa64:	e13ff317 	ldw	r4,-52(fp)
 821aa68:	20c7883a 	add	r3,r4,r3
 821aa6c:	18c002c4 	addi	r3,r3,11
 821aa70:	18c00003 	ldbu	r3,0(r3)
 821aa74:	1809883a 	mov	r4,r3
 821aa78:	e0fffc83 	ldbu	r3,-14(fp)
 821aa7c:	00c6303a 	nor	r3,zero,r3
 821aa80:	20c6703a 	and	r3,r4,r3
 821aa84:	1809883a 	mov	r4,r3
 821aa88:	e0fff317 	ldw	r3,-52(fp)
 821aa8c:	1885883a 	add	r2,r3,r2
 821aa90:	108002c4 	addi	r2,r2,11
 821aa94:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
 821aa98:	e0bffc03 	ldbu	r2,-16(fp)
 821aa9c:	e0fff317 	ldw	r3,-52(fp)
 821aaa0:	1885883a 	add	r2,r3,r2
 821aaa4:	108002c4 	addi	r2,r2,11
 821aaa8:	10800003 	ldbu	r2,0(r2)
 821aaac:	10803fcc 	andi	r2,r2,255
 821aab0:	1000091e 	bne	r2,zero,821aad8 <OSTaskChangePrio+0x408>
                pevent->OSEventGrp    &= ~bity_old;
 821aab4:	e0bff317 	ldw	r2,-52(fp)
 821aab8:	10800283 	ldbu	r2,10(r2)
 821aabc:	1007883a 	mov	r3,r2
 821aac0:	e0bffc43 	ldbu	r2,-15(fp)
 821aac4:	0084303a 	nor	r2,zero,r2
 821aac8:	1884703a 	and	r2,r3,r2
 821aacc:	1007883a 	mov	r3,r2
 821aad0:	e0bff317 	ldw	r2,-52(fp)
 821aad4:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
 821aad8:	e0bff317 	ldw	r2,-52(fp)
 821aadc:	10c00283 	ldbu	r3,10(r2)
 821aae0:	e0bffb83 	ldbu	r2,-18(fp)
 821aae4:	1884b03a 	or	r2,r3,r2
 821aae8:	1007883a 	mov	r3,r2
 821aaec:	e0bff317 	ldw	r2,-52(fp)
 821aaf0:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
 821aaf4:	e0bffb03 	ldbu	r2,-20(fp)
 821aaf8:	e0fffb03 	ldbu	r3,-20(fp)
 821aafc:	e13ff317 	ldw	r4,-52(fp)
 821ab00:	20c7883a 	add	r3,r4,r3
 821ab04:	18c002c4 	addi	r3,r3,11
 821ab08:	19000003 	ldbu	r4,0(r3)
 821ab0c:	e0fffbc3 	ldbu	r3,-17(fp)
 821ab10:	20c6b03a 	or	r3,r4,r3
 821ab14:	1809883a 	mov	r4,r3
 821ab18:	e0fff317 	ldw	r3,-52(fp)
 821ab1c:	1885883a 	add	r2,r3,r2
 821ab20:	108002c4 	addi	r2,r2,11
 821ab24:	11000005 	stb	r4,0(r2)
            pevents++;
 821ab28:	e0bff417 	ldw	r2,-48(fp)
 821ab2c:	10800104 	addi	r2,r2,4
 821ab30:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
 821ab34:	e0bff417 	ldw	r2,-48(fp)
 821ab38:	10800017 	ldw	r2,0(r2)
 821ab3c:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
 821ab40:	e0bff317 	ldw	r2,-52(fp)
 821ab44:	103fc51e 	bne	r2,zero,821aa5c <OSTaskChangePrio+0x38c>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
 821ab48:	e0bff817 	ldw	r2,-32(fp)
 821ab4c:	e0ffff03 	ldbu	r3,-4(fp)
 821ab50:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
 821ab54:	e0bff817 	ldw	r2,-32(fp)
 821ab58:	e0fffb03 	ldbu	r3,-20(fp)
 821ab5c:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
 821ab60:	e0bff817 	ldw	r2,-32(fp)
 821ab64:	e0fffb43 	ldbu	r3,-19(fp)
 821ab68:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
 821ab6c:	e0bff817 	ldw	r2,-32(fp)
 821ab70:	e0fffb83 	ldbu	r3,-18(fp)
 821ab74:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
 821ab78:	e0bff817 	ldw	r2,-32(fp)
 821ab7c:	e0fffbc3 	ldbu	r3,-17(fp)
 821ab80:	10c00d45 	stb	r3,53(r2)
 821ab84:	e0bff517 	ldw	r2,-44(fp)
 821ab88:	e0bffa15 	stw	r2,-24(fp)
 821ab8c:	e0bffa17 	ldw	r2,-24(fp)
 821ab90:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 821ab94:	d0a06b43 	ldbu	r2,-32339(gp)
 821ab98:	10803fcc 	andi	r2,r2,255
 821ab9c:	10800058 	cmpnei	r2,r2,1
 821aba0:	1000011e 	bne	r2,zero,821aba8 <OSTaskChangePrio+0x4d8>
        OS_Sched();                                         /* Find new highest priority task          */
 821aba4:	82164a00 	call	82164a0 <OS_Sched>
    }
    return (OS_ERR_NONE);
 821aba8:	0005883a 	mov	r2,zero
}
 821abac:	e037883a 	mov	sp,fp
 821abb0:	dfc00117 	ldw	ra,4(sp)
 821abb4:	df000017 	ldw	fp,0(sp)
 821abb8:	dec00204 	addi	sp,sp,8
 821abbc:	f800283a 	ret

0821abc0 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
 821abc0:	deffee04 	addi	sp,sp,-72
 821abc4:	dfc01115 	stw	ra,68(sp)
 821abc8:	df001015 	stw	fp,64(sp)
 821abcc:	df001004 	addi	fp,sp,64
 821abd0:	e13ffc15 	stw	r4,-16(fp)
 821abd4:	e17ffd15 	stw	r5,-12(fp)
 821abd8:	e1bffe15 	stw	r6,-8(fp)
 821abdc:	3805883a 	mov	r2,r7
 821abe0:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 821abe4:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 821abe8:	e0bfff03 	ldbu	r2,-4(fp)
 821abec:	10800570 	cmpltui	r2,r2,21
 821abf0:	1000021e 	bne	r2,zero,821abfc <OSTaskCreate+0x3c>
        return (OS_ERR_PRIO_INVALID);
 821abf4:	00800a84 	movi	r2,42
 821abf8:	00005706 	br	821ad58 <OSTaskCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821abfc:	0005303a 	rdctl	r2,status
 821ac00:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821ac04:	e0fffb17 	ldw	r3,-20(fp)
 821ac08:	00bfff84 	movi	r2,-2
 821ac0c:	1884703a 	and	r2,r3,r2
 821ac10:	1001703a 	wrctl	status,r2
  
  return context;
 821ac14:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821ac18:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 821ac1c:	d0a07903 	ldbu	r2,-32284(gp)
 821ac20:	10803fcc 	andi	r2,r2,255
 821ac24:	10000626 	beq	r2,zero,821ac40 <OSTaskCreate+0x80>
 821ac28:	e0bff317 	ldw	r2,-52(fp)
 821ac2c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ac30:	e0bff417 	ldw	r2,-48(fp)
 821ac34:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 821ac38:	00800f04 	movi	r2,60
 821ac3c:	00004606 	br	821ad58 <OSTaskCreate+0x198>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 821ac40:	e0ffff03 	ldbu	r3,-4(fp)
 821ac44:	008209b4 	movhi	r2,2086
 821ac48:	10b6b204 	addi	r2,r2,-9528
 821ac4c:	18c7883a 	add	r3,r3,r3
 821ac50:	18c7883a 	add	r3,r3,r3
 821ac54:	10c5883a 	add	r2,r2,r3
 821ac58:	10800017 	ldw	r2,0(r2)
 821ac5c:	1000391e 	bne	r2,zero,821ad44 <OSTaskCreate+0x184>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 821ac60:	e0ffff03 	ldbu	r3,-4(fp)
 821ac64:	008209b4 	movhi	r2,2086
 821ac68:	10b6b204 	addi	r2,r2,-9528
 821ac6c:	18c7883a 	add	r3,r3,r3
 821ac70:	18c7883a 	add	r3,r3,r3
 821ac74:	10c5883a 	add	r2,r2,r3
 821ac78:	00c00044 	movi	r3,1
 821ac7c:	10c00015 	stw	r3,0(r2)
 821ac80:	e0bff317 	ldw	r2,-52(fp)
 821ac84:	e0bff515 	stw	r2,-44(fp)
 821ac88:	e0bff517 	ldw	r2,-44(fp)
 821ac8c:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
 821ac90:	000f883a 	mov	r7,zero
 821ac94:	e1bffe17 	ldw	r6,-8(fp)
 821ac98:	e17ffd17 	ldw	r5,-12(fp)
 821ac9c:	e13ffc17 	ldw	r4,-16(fp)
 821aca0:	823cbf00 	call	823cbf0 <OSTaskStkInit>
 821aca4:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 821aca8:	e0bfff03 	ldbu	r2,-4(fp)
 821acac:	d8000215 	stw	zero,8(sp)
 821acb0:	d8000115 	stw	zero,4(sp)
 821acb4:	d8000015 	stw	zero,0(sp)
 821acb8:	000f883a 	mov	r7,zero
 821acbc:	000d883a 	mov	r6,zero
 821acc0:	e17ff717 	ldw	r5,-36(fp)
 821acc4:	1009883a 	mov	r4,r2
 821acc8:	82168a00 	call	82168a0 <OS_TCBInit>
 821accc:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
 821acd0:	e0bff803 	ldbu	r2,-32(fp)
 821acd4:	1000061e 	bne	r2,zero,821acf0 <OSTaskCreate+0x130>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
 821acd8:	d0a06b43 	ldbu	r2,-32339(gp)
 821acdc:	10803fcc 	andi	r2,r2,255
 821ace0:	10800058 	cmpnei	r2,r2,1
 821ace4:	1000151e 	bne	r2,zero,821ad3c <OSTaskCreate+0x17c>
                OS_Sched();
 821ace8:	82164a00 	call	82164a0 <OS_Sched>
 821acec:	00001306 	br	821ad3c <OSTaskCreate+0x17c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821acf0:	0005303a 	rdctl	r2,status
 821acf4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821acf8:	e0fffa17 	ldw	r3,-24(fp)
 821acfc:	00bfff84 	movi	r2,-2
 821ad00:	1884703a 	and	r2,r3,r2
 821ad04:	1001703a 	wrctl	status,r2
  
  return context;
 821ad08:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 821ad0c:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 821ad10:	e0ffff03 	ldbu	r3,-4(fp)
 821ad14:	008209b4 	movhi	r2,2086
 821ad18:	10b6b204 	addi	r2,r2,-9528
 821ad1c:	18c7883a 	add	r3,r3,r3
 821ad20:	18c7883a 	add	r3,r3,r3
 821ad24:	10c5883a 	add	r2,r2,r3
 821ad28:	10000015 	stw	zero,0(r2)
 821ad2c:	e0bff317 	ldw	r2,-52(fp)
 821ad30:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ad34:	e0bff617 	ldw	r2,-40(fp)
 821ad38:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 821ad3c:	e0bff803 	ldbu	r2,-32(fp)
 821ad40:	00000506 	br	821ad58 <OSTaskCreate+0x198>
 821ad44:	e0bff317 	ldw	r2,-52(fp)
 821ad48:	e0bff915 	stw	r2,-28(fp)
 821ad4c:	e0bff917 	ldw	r2,-28(fp)
 821ad50:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 821ad54:	00800a04 	movi	r2,40
}
 821ad58:	e037883a 	mov	sp,fp
 821ad5c:	dfc00117 	ldw	ra,4(sp)
 821ad60:	df000017 	ldw	fp,0(sp)
 821ad64:	dec00204 	addi	sp,sp,8
 821ad68:	f800283a 	ret

0821ad6c <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
 821ad6c:	deffec04 	addi	sp,sp,-80
 821ad70:	dfc01315 	stw	ra,76(sp)
 821ad74:	df001215 	stw	fp,72(sp)
 821ad78:	df001204 	addi	fp,sp,72
 821ad7c:	e13ffa15 	stw	r4,-24(fp)
 821ad80:	e17ffb15 	stw	r5,-20(fp)
 821ad84:	e1bffc15 	stw	r6,-16(fp)
 821ad88:	3809883a 	mov	r4,r7
 821ad8c:	e0c00217 	ldw	r3,8(fp)
 821ad90:	e0800617 	ldw	r2,24(fp)
 821ad94:	e13ffd05 	stb	r4,-12(fp)
 821ad98:	e0fffe0d 	sth	r3,-8(fp)
 821ad9c:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 821ada0:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 821ada4:	e0bffd03 	ldbu	r2,-12(fp)
 821ada8:	10800570 	cmpltui	r2,r2,21
 821adac:	1000021e 	bne	r2,zero,821adb8 <OSTaskCreateExt+0x4c>
        return (OS_ERR_PRIO_INVALID);
 821adb0:	00800a84 	movi	r2,42
 821adb4:	00006106 	br	821af3c <OSTaskCreateExt+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821adb8:	0005303a 	rdctl	r2,status
 821adbc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821adc0:	e0fff917 	ldw	r3,-28(fp)
 821adc4:	00bfff84 	movi	r2,-2
 821adc8:	1884703a 	and	r2,r3,r2
 821adcc:	1001703a 	wrctl	status,r2
  
  return context;
 821add0:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821add4:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 821add8:	d0a07903 	ldbu	r2,-32284(gp)
 821addc:	10803fcc 	andi	r2,r2,255
 821ade0:	10000626 	beq	r2,zero,821adfc <OSTaskCreateExt+0x90>
 821ade4:	e0bff117 	ldw	r2,-60(fp)
 821ade8:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821adec:	e0bff217 	ldw	r2,-56(fp)
 821adf0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 821adf4:	00800f04 	movi	r2,60
 821adf8:	00005006 	br	821af3c <OSTaskCreateExt+0x1d0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 821adfc:	e0fffd03 	ldbu	r3,-12(fp)
 821ae00:	008209b4 	movhi	r2,2086
 821ae04:	10b6b204 	addi	r2,r2,-9528
 821ae08:	18c7883a 	add	r3,r3,r3
 821ae0c:	18c7883a 	add	r3,r3,r3
 821ae10:	10c5883a 	add	r2,r2,r3
 821ae14:	10800017 	ldw	r2,0(r2)
 821ae18:	1000431e 	bne	r2,zero,821af28 <OSTaskCreateExt+0x1bc>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 821ae1c:	e0fffd03 	ldbu	r3,-12(fp)
 821ae20:	008209b4 	movhi	r2,2086
 821ae24:	10b6b204 	addi	r2,r2,-9528
 821ae28:	18c7883a 	add	r3,r3,r3
 821ae2c:	18c7883a 	add	r3,r3,r3
 821ae30:	10c5883a 	add	r2,r2,r3
 821ae34:	00c00044 	movi	r3,1
 821ae38:	10c00015 	stw	r3,0(r2)
 821ae3c:	e0bff117 	ldw	r2,-60(fp)
 821ae40:	e0bff315 	stw	r2,-52(fp)
 821ae44:	e0bff317 	ldw	r2,-52(fp)
 821ae48:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
 821ae4c:	e0bfff0b 	ldhu	r2,-4(fp)
 821ae50:	100d883a 	mov	r6,r2
 821ae54:	e1400417 	ldw	r5,16(fp)
 821ae58:	e1000317 	ldw	r4,12(fp)
 821ae5c:	821bdcc0 	call	821bdcc <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
 821ae60:	e0bfff0b 	ldhu	r2,-4(fp)
 821ae64:	100f883a 	mov	r7,r2
 821ae68:	e1bffc17 	ldw	r6,-16(fp)
 821ae6c:	e17ffb17 	ldw	r5,-20(fp)
 821ae70:	e13ffa17 	ldw	r4,-24(fp)
 821ae74:	823cbf00 	call	823cbf0 <OSTaskStkInit>
 821ae78:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
 821ae7c:	e0fffd03 	ldbu	r3,-12(fp)
 821ae80:	e13ffe0b 	ldhu	r4,-8(fp)
 821ae84:	e0bfff0b 	ldhu	r2,-4(fp)
 821ae88:	d8800215 	stw	r2,8(sp)
 821ae8c:	e0800517 	ldw	r2,20(fp)
 821ae90:	d8800115 	stw	r2,4(sp)
 821ae94:	e0800417 	ldw	r2,16(fp)
 821ae98:	d8800015 	stw	r2,0(sp)
 821ae9c:	200f883a 	mov	r7,r4
 821aea0:	e1800317 	ldw	r6,12(fp)
 821aea4:	e17ff517 	ldw	r5,-44(fp)
 821aea8:	1809883a 	mov	r4,r3
 821aeac:	82168a00 	call	82168a0 <OS_TCBInit>
 821aeb0:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
 821aeb4:	e0bff603 	ldbu	r2,-40(fp)
 821aeb8:	1000061e 	bne	r2,zero,821aed4 <OSTaskCreateExt+0x168>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
 821aebc:	d0a06b43 	ldbu	r2,-32339(gp)
 821aec0:	10803fcc 	andi	r2,r2,255
 821aec4:	10800058 	cmpnei	r2,r2,1
 821aec8:	1000151e 	bne	r2,zero,821af20 <OSTaskCreateExt+0x1b4>
                OS_Sched();
 821aecc:	82164a00 	call	82164a0 <OS_Sched>
 821aed0:	00001306 	br	821af20 <OSTaskCreateExt+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821aed4:	0005303a 	rdctl	r2,status
 821aed8:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821aedc:	e0fff817 	ldw	r3,-32(fp)
 821aee0:	00bfff84 	movi	r2,-2
 821aee4:	1884703a 	and	r2,r3,r2
 821aee8:	1001703a 	wrctl	status,r2
  
  return context;
 821aeec:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 821aef0:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
 821aef4:	e0fffd03 	ldbu	r3,-12(fp)
 821aef8:	008209b4 	movhi	r2,2086
 821aefc:	10b6b204 	addi	r2,r2,-9528
 821af00:	18c7883a 	add	r3,r3,r3
 821af04:	18c7883a 	add	r3,r3,r3
 821af08:	10c5883a 	add	r2,r2,r3
 821af0c:	10000015 	stw	zero,0(r2)
 821af10:	e0bff117 	ldw	r2,-60(fp)
 821af14:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821af18:	e0bff417 	ldw	r2,-48(fp)
 821af1c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 821af20:	e0bff603 	ldbu	r2,-40(fp)
 821af24:	00000506 	br	821af3c <OSTaskCreateExt+0x1d0>
 821af28:	e0bff117 	ldw	r2,-60(fp)
 821af2c:	e0bff715 	stw	r2,-36(fp)
 821af30:	e0bff717 	ldw	r2,-36(fp)
 821af34:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 821af38:	00800a04 	movi	r2,40
}
 821af3c:	e037883a 	mov	sp,fp
 821af40:	dfc00117 	ldw	ra,4(sp)
 821af44:	df000017 	ldw	fp,0(sp)
 821af48:	dec00204 	addi	sp,sp,8
 821af4c:	f800283a 	ret

0821af50 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
 821af50:	defff404 	addi	sp,sp,-48
 821af54:	dfc00b15 	stw	ra,44(sp)
 821af58:	df000a15 	stw	fp,40(sp)
 821af5c:	df000a04 	addi	fp,sp,40
 821af60:	2005883a 	mov	r2,r4
 821af64:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
 821af68:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
 821af6c:	d0a07903 	ldbu	r2,-32284(gp)
 821af70:	10803fcc 	andi	r2,r2,255
 821af74:	10000226 	beq	r2,zero,821af80 <OSTaskDel+0x30>
        return (OS_ERR_TASK_DEL_ISR);
 821af78:	00801004 	movi	r2,64
 821af7c:	0000c006 	br	821b280 <OSTaskDel+0x330>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
 821af80:	e0bfff03 	ldbu	r2,-4(fp)
 821af84:	10800518 	cmpnei	r2,r2,20
 821af88:	1000021e 	bne	r2,zero,821af94 <OSTaskDel+0x44>
        return (OS_ERR_TASK_DEL_IDLE);
 821af8c:	00800f84 	movi	r2,62
 821af90:	0000bb06 	br	821b280 <OSTaskDel+0x330>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
 821af94:	e0bfff03 	ldbu	r2,-4(fp)
 821af98:	10800530 	cmpltui	r2,r2,20
 821af9c:	1000051e 	bne	r2,zero,821afb4 <OSTaskDel+0x64>
        if (prio != OS_PRIO_SELF) {
 821afa0:	e0bfff03 	ldbu	r2,-4(fp)
 821afa4:	10803fe0 	cmpeqi	r2,r2,255
 821afa8:	1000021e 	bne	r2,zero,821afb4 <OSTaskDel+0x64>
            return (OS_ERR_PRIO_INVALID);
 821afac:	00800a84 	movi	r2,42
 821afb0:	0000b306 	br	821b280 <OSTaskDel+0x330>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821afb4:	0005303a 	rdctl	r2,status
 821afb8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821afbc:	e0fffe17 	ldw	r3,-8(fp)
 821afc0:	00bfff84 	movi	r2,-2
 821afc4:	1884703a 	and	r2,r3,r2
 821afc8:	1001703a 	wrctl	status,r2
  
  return context;
 821afcc:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
 821afd0:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
 821afd4:	e0bfff03 	ldbu	r2,-4(fp)
 821afd8:	10803fd8 	cmpnei	r2,r2,255
 821afdc:	1000031e 	bne	r2,zero,821afec <OSTaskDel+0x9c>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
 821afe0:	d0a07a17 	ldw	r2,-32280(gp)
 821afe4:	10800c83 	ldbu	r2,50(r2)
 821afe8:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821afec:	e0ffff03 	ldbu	r3,-4(fp)
 821aff0:	008209b4 	movhi	r2,2086
 821aff4:	10b6b204 	addi	r2,r2,-9528
 821aff8:	18c7883a 	add	r3,r3,r3
 821affc:	18c7883a 	add	r3,r3,r3
 821b000:	10c5883a 	add	r2,r2,r3
 821b004:	10800017 	ldw	r2,0(r2)
 821b008:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
 821b00c:	e0bff817 	ldw	r2,-32(fp)
 821b010:	1000061e 	bne	r2,zero,821b02c <OSTaskDel+0xdc>
 821b014:	e0bff617 	ldw	r2,-40(fp)
 821b018:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b01c:	e0bff717 	ldw	r2,-36(fp)
 821b020:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b024:	008010c4 	movi	r2,67
 821b028:	00009506 	br	821b280 <OSTaskDel+0x330>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
 821b02c:	e0bff817 	ldw	r2,-32(fp)
 821b030:	10800058 	cmpnei	r2,r2,1
 821b034:	1000061e 	bne	r2,zero,821b050 <OSTaskDel+0x100>
 821b038:	e0bff617 	ldw	r2,-40(fp)
 821b03c:	e0bff915 	stw	r2,-28(fp)
 821b040:	e0bff917 	ldw	r2,-28(fp)
 821b044:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 821b048:	00800f44 	movi	r2,61
 821b04c:	00008c06 	br	821b280 <OSTaskDel+0x330>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
 821b050:	e0bff817 	ldw	r2,-32(fp)
 821b054:	10800d03 	ldbu	r2,52(r2)
 821b058:	10c03fcc 	andi	r3,r2,255
 821b05c:	e0bff817 	ldw	r2,-32(fp)
 821b060:	10800d03 	ldbu	r2,52(r2)
 821b064:	11003fcc 	andi	r4,r2,255
 821b068:	d0a07744 	addi	r2,gp,-32291
 821b06c:	2085883a 	add	r2,r4,r2
 821b070:	10800003 	ldbu	r2,0(r2)
 821b074:	1009883a 	mov	r4,r2
 821b078:	e0bff817 	ldw	r2,-32(fp)
 821b07c:	10800d43 	ldbu	r2,53(r2)
 821b080:	0084303a 	nor	r2,zero,r2
 821b084:	2084703a 	and	r2,r4,r2
 821b088:	1009883a 	mov	r4,r2
 821b08c:	d0a07744 	addi	r2,gp,-32291
 821b090:	1885883a 	add	r2,r3,r2
 821b094:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
 821b098:	e0bff817 	ldw	r2,-32(fp)
 821b09c:	10800d03 	ldbu	r2,52(r2)
 821b0a0:	10c03fcc 	andi	r3,r2,255
 821b0a4:	d0a07744 	addi	r2,gp,-32291
 821b0a8:	1885883a 	add	r2,r3,r2
 821b0ac:	10800003 	ldbu	r2,0(r2)
 821b0b0:	10803fcc 	andi	r2,r2,255
 821b0b4:	1000071e 	bne	r2,zero,821b0d4 <OSTaskDel+0x184>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
 821b0b8:	e0bff817 	ldw	r2,-32(fp)
 821b0bc:	10800d83 	ldbu	r2,54(r2)
 821b0c0:	0084303a 	nor	r2,zero,r2
 821b0c4:	1007883a 	mov	r3,r2
 821b0c8:	d0a07703 	ldbu	r2,-32292(gp)
 821b0cc:	1884703a 	and	r2,r3,r2
 821b0d0:	d0a07705 	stb	r2,-32292(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
 821b0d4:	e0bff817 	ldw	r2,-32(fp)
 821b0d8:	10800717 	ldw	r2,28(r2)
 821b0dc:	10000526 	beq	r2,zero,821b0f4 <OSTaskDel+0x1a4>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
 821b0e0:	e0bff817 	ldw	r2,-32(fp)
 821b0e4:	10800717 	ldw	r2,28(r2)
 821b0e8:	100b883a 	mov	r5,r2
 821b0ec:	e13ff817 	ldw	r4,-32(fp)
 821b0f0:	8215e4c0 	call	8215e4c <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
 821b0f4:	e0bff817 	ldw	r2,-32(fp)
 821b0f8:	10800817 	ldw	r2,32(r2)
 821b0fc:	10000526 	beq	r2,zero,821b114 <OSTaskDel+0x1c4>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 821b100:	e0bff817 	ldw	r2,-32(fp)
 821b104:	10800817 	ldw	r2,32(r2)
 821b108:	100b883a 	mov	r5,r2
 821b10c:	e13ff817 	ldw	r4,-32(fp)
 821b110:	8215f040 	call	8215f04 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
 821b114:	e0bff817 	ldw	r2,-32(fp)
 821b118:	10800a17 	ldw	r2,40(r2)
 821b11c:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
 821b120:	e0bffb17 	ldw	r2,-20(fp)
 821b124:	10000226 	beq	r2,zero,821b130 <OSTaskDel+0x1e0>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
 821b128:	e13ffb17 	ldw	r4,-20(fp)
 821b12c:	82183740 	call	8218374 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
 821b130:	e0bff817 	ldw	r2,-32(fp)
 821b134:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
 821b138:	e0bff817 	ldw	r2,-32(fp)
 821b13c:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 821b140:	e0bff817 	ldw	r2,-32(fp)
 821b144:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
 821b148:	d0a06b03 	ldbu	r2,-32340(gp)
 821b14c:	10803fcc 	andi	r2,r2,255
 821b150:	10803fe0 	cmpeqi	r2,r2,255
 821b154:	1000031e 	bne	r2,zero,821b164 <OSTaskDel+0x214>
        OSLockNesting++;
 821b158:	d0a06b03 	ldbu	r2,-32340(gp)
 821b15c:	10800044 	addi	r2,r2,1
 821b160:	d0a06b05 	stb	r2,-32340(gp)
 821b164:	e0bff617 	ldw	r2,-40(fp)
 821b168:	e0bffd15 	stw	r2,-12(fp)
 821b16c:	e0bffd17 	ldw	r2,-12(fp)
 821b170:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
 821b174:	8215a340 	call	8215a34 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b178:	0005303a 	rdctl	r2,status
 821b17c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b180:	e0fffa17 	ldw	r3,-24(fp)
 821b184:	00bfff84 	movi	r2,-2
 821b188:	1884703a 	and	r2,r3,r2
 821b18c:	1001703a 	wrctl	status,r2
  
  return context;
 821b190:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
 821b194:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
 821b198:	d0a06b03 	ldbu	r2,-32340(gp)
 821b19c:	10803fcc 	andi	r2,r2,255
 821b1a0:	10000326 	beq	r2,zero,821b1b0 <OSTaskDel+0x260>
        OSLockNesting--;
 821b1a4:	d0a06b03 	ldbu	r2,-32340(gp)
 821b1a8:	10bfffc4 	addi	r2,r2,-1
 821b1ac:	d0a06b05 	stb	r2,-32340(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
 821b1b0:	e13ff817 	ldw	r4,-32(fp)
 821b1b4:	823cd700 	call	823cd70 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
 821b1b8:	d0a07343 	ldbu	r2,-32307(gp)
 821b1bc:	10bfffc4 	addi	r2,r2,-1
 821b1c0:	d0a07345 	stb	r2,-32307(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
 821b1c4:	e0ffff03 	ldbu	r3,-4(fp)
 821b1c8:	008209b4 	movhi	r2,2086
 821b1cc:	10b6b204 	addi	r2,r2,-9528
 821b1d0:	18c7883a 	add	r3,r3,r3
 821b1d4:	18c7883a 	add	r3,r3,r3
 821b1d8:	10c5883a 	add	r2,r2,r3
 821b1dc:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
 821b1e0:	e0bff817 	ldw	r2,-32(fp)
 821b1e4:	10800617 	ldw	r2,24(r2)
 821b1e8:	1000071e 	bne	r2,zero,821b208 <OSTaskDel+0x2b8>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
 821b1ec:	e0bff817 	ldw	r2,-32(fp)
 821b1f0:	10800517 	ldw	r2,20(r2)
 821b1f4:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
 821b1f8:	e0bff817 	ldw	r2,-32(fp)
 821b1fc:	10800517 	ldw	r2,20(r2)
 821b200:	d0a06e15 	stw	r2,-32328(gp)
 821b204:	00000a06 	br	821b230 <OSTaskDel+0x2e0>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
 821b208:	e0bff817 	ldw	r2,-32(fp)
 821b20c:	10800617 	ldw	r2,24(r2)
 821b210:	e0fff817 	ldw	r3,-32(fp)
 821b214:	18c00517 	ldw	r3,20(r3)
 821b218:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
 821b21c:	e0bff817 	ldw	r2,-32(fp)
 821b220:	10800517 	ldw	r2,20(r2)
 821b224:	e0fff817 	ldw	r3,-32(fp)
 821b228:	18c00617 	ldw	r3,24(r3)
 821b22c:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
 821b230:	d0e07217 	ldw	r3,-32312(gp)
 821b234:	e0bff817 	ldw	r2,-32(fp)
 821b238:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
 821b23c:	e0bff817 	ldw	r2,-32(fp)
 821b240:	d0a07215 	stw	r2,-32312(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
 821b244:	e0bff817 	ldw	r2,-32(fp)
 821b248:	00c00fc4 	movi	r3,63
 821b24c:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 821b250:	e0bff817 	ldw	r2,-32(fp)
 821b254:	10001345 	stb	zero,77(r2)
 821b258:	e0bff617 	ldw	r2,-40(fp)
 821b25c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b260:	e0bffc17 	ldw	r2,-16(fp)
 821b264:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 821b268:	d0a06b43 	ldbu	r2,-32339(gp)
 821b26c:	10803fcc 	andi	r2,r2,255
 821b270:	10800058 	cmpnei	r2,r2,1
 821b274:	1000011e 	bne	r2,zero,821b27c <OSTaskDel+0x32c>
        OS_Sched();                                     /* Find new highest priority task              */
 821b278:	82164a00 	call	82164a0 <OS_Sched>
    }
    return (OS_ERR_NONE);
 821b27c:	0005883a 	mov	r2,zero
}
 821b280:	e037883a 	mov	sp,fp
 821b284:	dfc00117 	ldw	ra,4(sp)
 821b288:	df000017 	ldw	fp,0(sp)
 821b28c:	dec00204 	addi	sp,sp,8
 821b290:	f800283a 	ret

0821b294 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
 821b294:	defff504 	addi	sp,sp,-44
 821b298:	df000a15 	stw	fp,40(sp)
 821b29c:	df000a04 	addi	fp,sp,40
 821b2a0:	2005883a 	mov	r2,r4
 821b2a4:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821b2a8:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
 821b2ac:	e0bfff03 	ldbu	r2,-4(fp)
 821b2b0:	10800518 	cmpnei	r2,r2,20
 821b2b4:	1000021e 	bne	r2,zero,821b2c0 <OSTaskDelReq+0x2c>
        return (OS_ERR_TASK_DEL_IDLE);
 821b2b8:	00800f84 	movi	r2,62
 821b2bc:	00004506 	br	821b3d4 <OSTaskDelReq+0x140>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 821b2c0:	e0bfff03 	ldbu	r2,-4(fp)
 821b2c4:	10800530 	cmpltui	r2,r2,20
 821b2c8:	1000051e 	bne	r2,zero,821b2e0 <OSTaskDelReq+0x4c>
        if (prio != OS_PRIO_SELF) {
 821b2cc:	e0bfff03 	ldbu	r2,-4(fp)
 821b2d0:	10803fe0 	cmpeqi	r2,r2,255
 821b2d4:	1000021e 	bne	r2,zero,821b2e0 <OSTaskDelReq+0x4c>
            return (OS_ERR_PRIO_INVALID);
 821b2d8:	00800a84 	movi	r2,42
 821b2dc:	00003d06 	br	821b3d4 <OSTaskDelReq+0x140>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
 821b2e0:	e0bfff03 	ldbu	r2,-4(fp)
 821b2e4:	10803fd8 	cmpnei	r2,r2,255
 821b2e8:	1000111e 	bne	r2,zero,821b330 <OSTaskDelReq+0x9c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b2ec:	0005303a 	rdctl	r2,status
 821b2f0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b2f4:	e0fff917 	ldw	r3,-28(fp)
 821b2f8:	00bfff84 	movi	r2,-2
 821b2fc:	1884703a 	and	r2,r3,r2
 821b300:	1001703a 	wrctl	status,r2
  
  return context;
 821b304:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
 821b308:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
 821b30c:	d0a07a17 	ldw	r2,-32280(gp)
 821b310:	10800dc3 	ldbu	r2,55(r2)
 821b314:	e0bff805 	stb	r2,-32(fp)
 821b318:	e0bff617 	ldw	r2,-40(fp)
 821b31c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b320:	e0bffe17 	ldw	r2,-8(fp)
 821b324:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
 821b328:	e0bff803 	ldbu	r2,-32(fp)
 821b32c:	00002906 	br	821b3d4 <OSTaskDelReq+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b330:	0005303a 	rdctl	r2,status
 821b334:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b338:	e0fff717 	ldw	r3,-36(fp)
 821b33c:	00bfff84 	movi	r2,-2
 821b340:	1884703a 	and	r2,r3,r2
 821b344:	1001703a 	wrctl	status,r2
  
  return context;
 821b348:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 821b34c:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
 821b350:	e0ffff03 	ldbu	r3,-4(fp)
 821b354:	008209b4 	movhi	r2,2086
 821b358:	10b6b204 	addi	r2,r2,-9528
 821b35c:	18c7883a 	add	r3,r3,r3
 821b360:	18c7883a 	add	r3,r3,r3
 821b364:	10c5883a 	add	r2,r2,r3
 821b368:	10800017 	ldw	r2,0(r2)
 821b36c:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
 821b370:	e0bffb17 	ldw	r2,-20(fp)
 821b374:	1000061e 	bne	r2,zero,821b390 <OSTaskDelReq+0xfc>
 821b378:	e0bff617 	ldw	r2,-40(fp)
 821b37c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b380:	e0bffa17 	ldw	r2,-24(fp)
 821b384:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
 821b388:	008010c4 	movi	r2,67
 821b38c:	00001106 	br	821b3d4 <OSTaskDelReq+0x140>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
 821b390:	e0bffb17 	ldw	r2,-20(fp)
 821b394:	10800058 	cmpnei	r2,r2,1
 821b398:	1000061e 	bne	r2,zero,821b3b4 <OSTaskDelReq+0x120>
 821b39c:	e0bff617 	ldw	r2,-40(fp)
 821b3a0:	e0bffc15 	stw	r2,-16(fp)
 821b3a4:	e0bffc17 	ldw	r2,-16(fp)
 821b3a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 821b3ac:	00800f44 	movi	r2,61
 821b3b0:	00000806 	br	821b3d4 <OSTaskDelReq+0x140>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
 821b3b4:	e0bffb17 	ldw	r2,-20(fp)
 821b3b8:	00c00fc4 	movi	r3,63
 821b3bc:	10c00dc5 	stb	r3,55(r2)
 821b3c0:	e0bff617 	ldw	r2,-40(fp)
 821b3c4:	e0bffd15 	stw	r2,-12(fp)
 821b3c8:	e0bffd17 	ldw	r2,-12(fp)
 821b3cc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821b3d0:	0005883a 	mov	r2,zero
}
 821b3d4:	e037883a 	mov	sp,fp
 821b3d8:	df000017 	ldw	fp,0(sp)
 821b3dc:	dec00104 	addi	sp,sp,4
 821b3e0:	f800283a 	ret

0821b3e4 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
 821b3e4:	defff404 	addi	sp,sp,-48
 821b3e8:	dfc00b15 	stw	ra,44(sp)
 821b3ec:	df000a15 	stw	fp,40(sp)
 821b3f0:	df000a04 	addi	fp,sp,40
 821b3f4:	2005883a 	mov	r2,r4
 821b3f8:	e17ffe15 	stw	r5,-8(fp)
 821b3fc:	e1bfff15 	stw	r6,-4(fp)
 821b400:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
 821b404:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
 821b408:	e0bfff17 	ldw	r2,-4(fp)
 821b40c:	1000021e 	bne	r2,zero,821b418 <OSTaskNameGet+0x34>
        return (0);
 821b410:	0005883a 	mov	r2,zero
 821b414:	00005406 	br	821b568 <OSTaskNameGet+0x184>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
 821b418:	e0bffd03 	ldbu	r2,-12(fp)
 821b41c:	10800570 	cmpltui	r2,r2,21
 821b420:	1000081e 	bne	r2,zero,821b444 <OSTaskNameGet+0x60>
        if (prio != OS_PRIO_SELF) {
 821b424:	e0bffd03 	ldbu	r2,-12(fp)
 821b428:	10803fe0 	cmpeqi	r2,r2,255
 821b42c:	1000051e 	bne	r2,zero,821b444 <OSTaskNameGet+0x60>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
 821b430:	e0bfff17 	ldw	r2,-4(fp)
 821b434:	00c00a84 	movi	r3,42
 821b438:	10c00005 	stb	r3,0(r2)
            return (0);
 821b43c:	0005883a 	mov	r2,zero
 821b440:	00004906 	br	821b568 <OSTaskNameGet+0x184>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
 821b444:	e0bffe17 	ldw	r2,-8(fp)
 821b448:	1000051e 	bne	r2,zero,821b460 <OSTaskNameGet+0x7c>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
 821b44c:	e0bfff17 	ldw	r2,-4(fp)
 821b450:	00c00304 	movi	r3,12
 821b454:	10c00005 	stb	r3,0(r2)
        return (0);
 821b458:	0005883a 	mov	r2,zero
 821b45c:	00004206 	br	821b568 <OSTaskNameGet+0x184>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
 821b460:	d0a07903 	ldbu	r2,-32284(gp)
 821b464:	10803fcc 	andi	r2,r2,255
 821b468:	10000526 	beq	r2,zero,821b480 <OSTaskNameGet+0x9c>
        *perr = OS_ERR_NAME_GET_ISR;
 821b46c:	e0bfff17 	ldw	r2,-4(fp)
 821b470:	00c00444 	movi	r3,17
 821b474:	10c00005 	stb	r3,0(r2)
        return (0);
 821b478:	0005883a 	mov	r2,zero
 821b47c:	00003a06 	br	821b568 <OSTaskNameGet+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b480:	0005303a 	rdctl	r2,status
 821b484:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b488:	e0fffc17 	ldw	r3,-16(fp)
 821b48c:	00bfff84 	movi	r2,-2
 821b490:	1884703a 	and	r2,r3,r2
 821b494:	1001703a 	wrctl	status,r2
  
  return context;
 821b498:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821b49c:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
 821b4a0:	e0bffd03 	ldbu	r2,-12(fp)
 821b4a4:	10803fd8 	cmpnei	r2,r2,255
 821b4a8:	1000031e 	bne	r2,zero,821b4b8 <OSTaskNameGet+0xd4>
        prio = OSTCBCur->OSTCBPrio;
 821b4ac:	d0a07a17 	ldw	r2,-32280(gp)
 821b4b0:	10800c83 	ldbu	r2,50(r2)
 821b4b4:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b4b8:	e0fffd03 	ldbu	r3,-12(fp)
 821b4bc:	008209b4 	movhi	r2,2086
 821b4c0:	10b6b204 	addi	r2,r2,-9528
 821b4c4:	18c7883a 	add	r3,r3,r3
 821b4c8:	18c7883a 	add	r3,r3,r3
 821b4cc:	10c5883a 	add	r2,r2,r3
 821b4d0:	10800017 	ldw	r2,0(r2)
 821b4d4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
 821b4d8:	e0bff817 	ldw	r2,-32(fp)
 821b4dc:	1000091e 	bne	r2,zero,821b504 <OSTaskNameGet+0x120>
 821b4e0:	e0bff617 	ldw	r2,-40(fp)
 821b4e4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b4e8:	e0bff717 	ldw	r2,-36(fp)
 821b4ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b4f0:	e0bfff17 	ldw	r2,-4(fp)
 821b4f4:	00c010c4 	movi	r3,67
 821b4f8:	10c00005 	stb	r3,0(r2)
        return (0);
 821b4fc:	0005883a 	mov	r2,zero
 821b500:	00001906 	br	821b568 <OSTaskNameGet+0x184>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
 821b504:	e0bff817 	ldw	r2,-32(fp)
 821b508:	10800058 	cmpnei	r2,r2,1
 821b50c:	1000091e 	bne	r2,zero,821b534 <OSTaskNameGet+0x150>
 821b510:	e0bff617 	ldw	r2,-40(fp)
 821b514:	e0bff915 	stw	r2,-28(fp)
 821b518:	e0bff917 	ldw	r2,-28(fp)
 821b51c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b520:	e0bfff17 	ldw	r2,-4(fp)
 821b524:	00c010c4 	movi	r3,67
 821b528:	10c00005 	stb	r3,0(r2)
        return (0);
 821b52c:	0005883a 	mov	r2,zero
 821b530:	00000d06 	br	821b568 <OSTaskNameGet+0x184>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
 821b534:	e0bff817 	ldw	r2,-32(fp)
 821b538:	10801304 	addi	r2,r2,76
 821b53c:	100b883a 	mov	r5,r2
 821b540:	e13ffe17 	ldw	r4,-8(fp)
 821b544:	82165e40 	call	82165e4 <OS_StrCopy>
 821b548:	e0bffb05 	stb	r2,-20(fp)
 821b54c:	e0bff617 	ldw	r2,-40(fp)
 821b550:	e0bffa15 	stw	r2,-24(fp)
 821b554:	e0bffa17 	ldw	r2,-24(fp)
 821b558:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821b55c:	e0bfff17 	ldw	r2,-4(fp)
 821b560:	10000005 	stb	zero,0(r2)
    return (len);
 821b564:	e0bffb03 	ldbu	r2,-20(fp)
}
 821b568:	e037883a 	mov	sp,fp
 821b56c:	dfc00117 	ldw	ra,4(sp)
 821b570:	df000017 	ldw	fp,0(sp)
 821b574:	dec00204 	addi	sp,sp,8
 821b578:	f800283a 	ret

0821b57c <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
 821b57c:	defff304 	addi	sp,sp,-52
 821b580:	dfc00c15 	stw	ra,48(sp)
 821b584:	df000b15 	stw	fp,44(sp)
 821b588:	df000b04 	addi	fp,sp,44
 821b58c:	2005883a 	mov	r2,r4
 821b590:	e17ffe15 	stw	r5,-8(fp)
 821b594:	e1bfff15 	stw	r6,-4(fp)
 821b598:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 821b59c:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 821b5a0:	e0bfff17 	ldw	r2,-4(fp)
 821b5a4:	10005c26 	beq	r2,zero,821b718 <OSTaskNameSet+0x19c>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
 821b5a8:	e0bffd03 	ldbu	r2,-12(fp)
 821b5ac:	10800570 	cmpltui	r2,r2,21
 821b5b0:	1000071e 	bne	r2,zero,821b5d0 <OSTaskNameSet+0x54>
        if (prio != OS_PRIO_SELF) {
 821b5b4:	e0bffd03 	ldbu	r2,-12(fp)
 821b5b8:	10803fe0 	cmpeqi	r2,r2,255
 821b5bc:	1000041e 	bne	r2,zero,821b5d0 <OSTaskNameSet+0x54>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
 821b5c0:	e0bfff17 	ldw	r2,-4(fp)
 821b5c4:	00c00a84 	movi	r3,42
 821b5c8:	10c00005 	stb	r3,0(r2)
            return;
 821b5cc:	00005306 	br	821b71c <OSTaskNameSet+0x1a0>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
 821b5d0:	e0bffe17 	ldw	r2,-8(fp)
 821b5d4:	1000041e 	bne	r2,zero,821b5e8 <OSTaskNameSet+0x6c>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
 821b5d8:	e0bfff17 	ldw	r2,-4(fp)
 821b5dc:	00c00304 	movi	r3,12
 821b5e0:	10c00005 	stb	r3,0(r2)
        return;
 821b5e4:	00004d06 	br	821b71c <OSTaskNameSet+0x1a0>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
 821b5e8:	d0a07903 	ldbu	r2,-32284(gp)
 821b5ec:	10803fcc 	andi	r2,r2,255
 821b5f0:	10000426 	beq	r2,zero,821b604 <OSTaskNameSet+0x88>
        *perr = OS_ERR_NAME_SET_ISR;
 821b5f4:	e0bfff17 	ldw	r2,-4(fp)
 821b5f8:	00c00484 	movi	r3,18
 821b5fc:	10c00005 	stb	r3,0(r2)
        return;
 821b600:	00004606 	br	821b71c <OSTaskNameSet+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b604:	0005303a 	rdctl	r2,status
 821b608:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b60c:	e0fffc17 	ldw	r3,-16(fp)
 821b610:	00bfff84 	movi	r2,-2
 821b614:	1884703a 	and	r2,r3,r2
 821b618:	1001703a 	wrctl	status,r2
  
  return context;
 821b61c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 821b620:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
 821b624:	e0bffd03 	ldbu	r2,-12(fp)
 821b628:	10803fd8 	cmpnei	r2,r2,255
 821b62c:	1000031e 	bne	r2,zero,821b63c <OSTaskNameSet+0xc0>
        prio = OSTCBCur->OSTCBPrio;
 821b630:	d0a07a17 	ldw	r2,-32280(gp)
 821b634:	10800c83 	ldbu	r2,50(r2)
 821b638:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b63c:	e0fffd03 	ldbu	r3,-12(fp)
 821b640:	008209b4 	movhi	r2,2086
 821b644:	10b6b204 	addi	r2,r2,-9528
 821b648:	18c7883a 	add	r3,r3,r3
 821b64c:	18c7883a 	add	r3,r3,r3
 821b650:	10c5883a 	add	r2,r2,r3
 821b654:	10800017 	ldw	r2,0(r2)
 821b658:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
 821b65c:	e0bff717 	ldw	r2,-36(fp)
 821b660:	1000081e 	bne	r2,zero,821b684 <OSTaskNameSet+0x108>
 821b664:	e0bff517 	ldw	r2,-44(fp)
 821b668:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b66c:	e0bff617 	ldw	r2,-40(fp)
 821b670:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b674:	e0bfff17 	ldw	r2,-4(fp)
 821b678:	00c010c4 	movi	r3,67
 821b67c:	10c00005 	stb	r3,0(r2)
        return;
 821b680:	00002606 	br	821b71c <OSTaskNameSet+0x1a0>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
 821b684:	e0bff717 	ldw	r2,-36(fp)
 821b688:	10800058 	cmpnei	r2,r2,1
 821b68c:	1000081e 	bne	r2,zero,821b6b0 <OSTaskNameSet+0x134>
 821b690:	e0bff517 	ldw	r2,-44(fp)
 821b694:	e0bff815 	stw	r2,-32(fp)
 821b698:	e0bff817 	ldw	r2,-32(fp)
 821b69c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
 821b6a0:	e0bfff17 	ldw	r2,-4(fp)
 821b6a4:	00c010c4 	movi	r3,67
 821b6a8:	10c00005 	stb	r3,0(r2)
        return;
 821b6ac:	00001b06 	br	821b71c <OSTaskNameSet+0x1a0>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
 821b6b0:	e13ffe17 	ldw	r4,-8(fp)
 821b6b4:	82166580 	call	8216658 <OS_StrLen>
 821b6b8:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
 821b6bc:	e0bffa03 	ldbu	r2,-24(fp)
 821b6c0:	10800830 	cmpltui	r2,r2,32
 821b6c4:	1000081e 	bne	r2,zero,821b6e8 <OSTaskNameSet+0x16c>
 821b6c8:	e0bff517 	ldw	r2,-44(fp)
 821b6cc:	e0bff915 	stw	r2,-28(fp)
 821b6d0:	e0bff917 	ldw	r2,-28(fp)
 821b6d4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
 821b6d8:	e0bfff17 	ldw	r2,-4(fp)
 821b6dc:	00c01044 	movi	r3,65
 821b6e0:	10c00005 	stb	r3,0(r2)
        return;
 821b6e4:	00000d06 	br	821b71c <OSTaskNameSet+0x1a0>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
 821b6e8:	e0bff717 	ldw	r2,-36(fp)
 821b6ec:	10801304 	addi	r2,r2,76
 821b6f0:	e17ffe17 	ldw	r5,-8(fp)
 821b6f4:	1009883a 	mov	r4,r2
 821b6f8:	82165e40 	call	82165e4 <OS_StrCopy>
 821b6fc:	e0bff517 	ldw	r2,-44(fp)
 821b700:	e0bffb15 	stw	r2,-20(fp)
 821b704:	e0bffb17 	ldw	r2,-20(fp)
 821b708:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 821b70c:	e0bfff17 	ldw	r2,-4(fp)
 821b710:	10000005 	stb	zero,0(r2)
 821b714:	00000106 	br	821b71c <OSTaskNameSet+0x1a0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
 821b718:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 821b71c:	e037883a 	mov	sp,fp
 821b720:	dfc00117 	ldw	ra,4(sp)
 821b724:	df000017 	ldw	fp,0(sp)
 821b728:	dec00204 	addi	sp,sp,8
 821b72c:	f800283a 	ret

0821b730 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
 821b730:	defff404 	addi	sp,sp,-48
 821b734:	dfc00b15 	stw	ra,44(sp)
 821b738:	df000a15 	stw	fp,40(sp)
 821b73c:	df000a04 	addi	fp,sp,40
 821b740:	2005883a 	mov	r2,r4
 821b744:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 821b748:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
 821b74c:	e0bfff03 	ldbu	r2,-4(fp)
 821b750:	10800530 	cmpltui	r2,r2,20
 821b754:	1000021e 	bne	r2,zero,821b760 <OSTaskResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 821b758:	00800a84 	movi	r2,42
 821b75c:	00006406 	br	821b8f0 <OSTaskResume+0x1c0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b760:	0005303a 	rdctl	r2,status
 821b764:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b768:	e0fffe17 	ldw	r3,-8(fp)
 821b76c:	00bfff84 	movi	r2,-2
 821b770:	1884703a 	and	r2,r3,r2
 821b774:	1001703a 	wrctl	status,r2
  
  return context;
 821b778:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821b77c:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
 821b780:	e0ffff03 	ldbu	r3,-4(fp)
 821b784:	008209b4 	movhi	r2,2086
 821b788:	10b6b204 	addi	r2,r2,-9528
 821b78c:	18c7883a 	add	r3,r3,r3
 821b790:	18c7883a 	add	r3,r3,r3
 821b794:	10c5883a 	add	r2,r2,r3
 821b798:	10800017 	ldw	r2,0(r2)
 821b79c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
 821b7a0:	e0bff817 	ldw	r2,-32(fp)
 821b7a4:	1000061e 	bne	r2,zero,821b7c0 <OSTaskResume+0x90>
 821b7a8:	e0bff617 	ldw	r2,-40(fp)
 821b7ac:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b7b0:	e0bff717 	ldw	r2,-36(fp)
 821b7b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
 821b7b8:	00801184 	movi	r2,70
 821b7bc:	00004c06 	br	821b8f0 <OSTaskResume+0x1c0>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
 821b7c0:	e0bff817 	ldw	r2,-32(fp)
 821b7c4:	10800058 	cmpnei	r2,r2,1
 821b7c8:	1000061e 	bne	r2,zero,821b7e4 <OSTaskResume+0xb4>
 821b7cc:	e0bff617 	ldw	r2,-40(fp)
 821b7d0:	e0bff915 	stw	r2,-28(fp)
 821b7d4:	e0bff917 	ldw	r2,-28(fp)
 821b7d8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b7dc:	008010c4 	movi	r2,67
 821b7e0:	00004306 	br	821b8f0 <OSTaskResume+0x1c0>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
 821b7e4:	e0bff817 	ldw	r2,-32(fp)
 821b7e8:	10800c03 	ldbu	r2,48(r2)
 821b7ec:	10803fcc 	andi	r2,r2,255
 821b7f0:	1080020c 	andi	r2,r2,8
 821b7f4:	10003926 	beq	r2,zero,821b8dc <OSTaskResume+0x1ac>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
 821b7f8:	e0bff817 	ldw	r2,-32(fp)
 821b7fc:	10c00c03 	ldbu	r3,48(r2)
 821b800:	00bffdc4 	movi	r2,-9
 821b804:	1884703a 	and	r2,r3,r2
 821b808:	1007883a 	mov	r3,r2
 821b80c:	e0bff817 	ldw	r2,-32(fp)
 821b810:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
 821b814:	e0bff817 	ldw	r2,-32(fp)
 821b818:	10800c03 	ldbu	r2,48(r2)
 821b81c:	10803fcc 	andi	r2,r2,255
 821b820:	1000281e 	bne	r2,zero,821b8c4 <OSTaskResume+0x194>
            if (ptcb->OSTCBDly == 0) {
 821b824:	e0bff817 	ldw	r2,-32(fp)
 821b828:	10800b8b 	ldhu	r2,46(r2)
 821b82c:	10bfffcc 	andi	r2,r2,65535
 821b830:	10001f1e 	bne	r2,zero,821b8b0 <OSTaskResume+0x180>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
 821b834:	e0bff817 	ldw	r2,-32(fp)
 821b838:	10c00d83 	ldbu	r3,54(r2)
 821b83c:	d0a07703 	ldbu	r2,-32292(gp)
 821b840:	1884b03a 	or	r2,r3,r2
 821b844:	d0a07705 	stb	r2,-32292(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 821b848:	e0bff817 	ldw	r2,-32(fp)
 821b84c:	10800d03 	ldbu	r2,52(r2)
 821b850:	10c03fcc 	andi	r3,r2,255
 821b854:	e0bff817 	ldw	r2,-32(fp)
 821b858:	10800d03 	ldbu	r2,52(r2)
 821b85c:	11003fcc 	andi	r4,r2,255
 821b860:	d0a07744 	addi	r2,gp,-32291
 821b864:	2085883a 	add	r2,r4,r2
 821b868:	11000003 	ldbu	r4,0(r2)
 821b86c:	e0bff817 	ldw	r2,-32(fp)
 821b870:	10800d43 	ldbu	r2,53(r2)
 821b874:	2084b03a 	or	r2,r4,r2
 821b878:	1009883a 	mov	r4,r2
 821b87c:	d0a07744 	addi	r2,gp,-32291
 821b880:	1885883a 	add	r2,r3,r2
 821b884:	11000005 	stb	r4,0(r2)
 821b888:	e0bff617 	ldw	r2,-40(fp)
 821b88c:	e0bffa15 	stw	r2,-24(fp)
 821b890:	e0bffa17 	ldw	r2,-24(fp)
 821b894:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
 821b898:	d0a06b43 	ldbu	r2,-32339(gp)
 821b89c:	10803fcc 	andi	r2,r2,255
 821b8a0:	10800058 	cmpnei	r2,r2,1
 821b8a4:	10000b1e 	bne	r2,zero,821b8d4 <OSTaskResume+0x1a4>
                    OS_Sched();                               /* Find new highest priority task        */
 821b8a8:	82164a00 	call	82164a0 <OS_Sched>
 821b8ac:	00000906 	br	821b8d4 <OSTaskResume+0x1a4>
 821b8b0:	e0bff617 	ldw	r2,-40(fp)
 821b8b4:	e0bffb15 	stw	r2,-20(fp)
 821b8b8:	e0bffb17 	ldw	r2,-20(fp)
 821b8bc:	1001703a 	wrctl	status,r2
 821b8c0:	00000406 	br	821b8d4 <OSTaskResume+0x1a4>
 821b8c4:	e0bff617 	ldw	r2,-40(fp)
 821b8c8:	e0bffc15 	stw	r2,-16(fp)
 821b8cc:	e0bffc17 	ldw	r2,-16(fp)
 821b8d0:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
 821b8d4:	0005883a 	mov	r2,zero
 821b8d8:	00000506 	br	821b8f0 <OSTaskResume+0x1c0>
 821b8dc:	e0bff617 	ldw	r2,-40(fp)
 821b8e0:	e0bffd15 	stw	r2,-12(fp)
 821b8e4:	e0bffd17 	ldw	r2,-12(fp)
 821b8e8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
 821b8ec:	00801104 	movi	r2,68
}
 821b8f0:	e037883a 	mov	sp,fp
 821b8f4:	dfc00117 	ldw	ra,4(sp)
 821b8f8:	df000017 	ldw	fp,0(sp)
 821b8fc:	dec00204 	addi	sp,sp,8
 821b900:	f800283a 	ret

0821b904 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
 821b904:	defff304 	addi	sp,sp,-52
 821b908:	df000c15 	stw	fp,48(sp)
 821b90c:	df000c04 	addi	fp,sp,48
 821b910:	2005883a 	mov	r2,r4
 821b914:	e17fff15 	stw	r5,-4(fp)
 821b918:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 821b91c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
 821b920:	e0bffe03 	ldbu	r2,-8(fp)
 821b924:	10800570 	cmpltui	r2,r2,21
 821b928:	1000051e 	bne	r2,zero,821b940 <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {
 821b92c:	e0bffe03 	ldbu	r2,-8(fp)
 821b930:	10803fe0 	cmpeqi	r2,r2,255
 821b934:	1000021e 	bne	r2,zero,821b940 <OSTaskStkChk+0x3c>
            return (OS_ERR_PRIO_INVALID);
 821b938:	00800a84 	movi	r2,42
 821b93c:	00005d06 	br	821bab4 <OSTaskStkChk+0x1b0>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
 821b940:	e0bfff17 	ldw	r2,-4(fp)
 821b944:	1000021e 	bne	r2,zero,821b950 <OSTaskStkChk+0x4c>
        return (OS_ERR_PDATA_NULL);
 821b948:	00800244 	movi	r2,9
 821b94c:	00005906 	br	821bab4 <OSTaskStkChk+0x1b0>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
 821b950:	e0bfff17 	ldw	r2,-4(fp)
 821b954:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
 821b958:	e0bfff17 	ldw	r2,-4(fp)
 821b95c:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821b960:	0005303a 	rdctl	r2,status
 821b964:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821b968:	e0fffd17 	ldw	r3,-12(fp)
 821b96c:	00bfff84 	movi	r2,-2
 821b970:	1884703a 	and	r2,r3,r2
 821b974:	1001703a 	wrctl	status,r2
  
  return context;
 821b978:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
 821b97c:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
 821b980:	e0bffe03 	ldbu	r2,-8(fp)
 821b984:	10803fd8 	cmpnei	r2,r2,255
 821b988:	1000031e 	bne	r2,zero,821b998 <OSTaskStkChk+0x94>
        prio = OSTCBCur->OSTCBPrio;
 821b98c:	d0a07a17 	ldw	r2,-32280(gp)
 821b990:	10800c83 	ldbu	r2,50(r2)
 821b994:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821b998:	e0fffe03 	ldbu	r3,-8(fp)
 821b99c:	008209b4 	movhi	r2,2086
 821b9a0:	10b6b204 	addi	r2,r2,-9528
 821b9a4:	18c7883a 	add	r3,r3,r3
 821b9a8:	18c7883a 	add	r3,r3,r3
 821b9ac:	10c5883a 	add	r2,r2,r3
 821b9b0:	10800017 	ldw	r2,0(r2)
 821b9b4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
 821b9b8:	e0bff817 	ldw	r2,-32(fp)
 821b9bc:	1000061e 	bne	r2,zero,821b9d8 <OSTaskStkChk+0xd4>
 821b9c0:	e0bff617 	ldw	r2,-40(fp)
 821b9c4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821b9c8:	e0bff717 	ldw	r2,-36(fp)
 821b9cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b9d0:	008010c4 	movi	r2,67
 821b9d4:	00003706 	br	821bab4 <OSTaskStkChk+0x1b0>
    }
    if (ptcb == OS_TCB_RESERVED) {
 821b9d8:	e0bff817 	ldw	r2,-32(fp)
 821b9dc:	10800058 	cmpnei	r2,r2,1
 821b9e0:	1000061e 	bne	r2,zero,821b9fc <OSTaskStkChk+0xf8>
 821b9e4:	e0bff617 	ldw	r2,-40(fp)
 821b9e8:	e0bff915 	stw	r2,-28(fp)
 821b9ec:	e0bff917 	ldw	r2,-28(fp)
 821b9f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821b9f4:	008010c4 	movi	r2,67
 821b9f8:	00002e06 	br	821bab4 <OSTaskStkChk+0x1b0>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
 821b9fc:	e0bff817 	ldw	r2,-32(fp)
 821ba00:	1080040b 	ldhu	r2,16(r2)
 821ba04:	10bfffcc 	andi	r2,r2,65535
 821ba08:	1080004c 	andi	r2,r2,1
 821ba0c:	1000061e 	bne	r2,zero,821ba28 <OSTaskStkChk+0x124>
 821ba10:	e0bff617 	ldw	r2,-40(fp)
 821ba14:	e0bffa15 	stw	r2,-24(fp)
 821ba18:	e0bffa17 	ldw	r2,-24(fp)
 821ba1c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
 821ba20:	00801144 	movi	r2,69
 821ba24:	00002306 	br	821bab4 <OSTaskStkChk+0x1b0>
    }
    nfree = 0;
 821ba28:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
 821ba2c:	e0bff817 	ldw	r2,-32(fp)
 821ba30:	10800317 	ldw	r2,12(r2)
 821ba34:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
 821ba38:	e0bff817 	ldw	r2,-32(fp)
 821ba3c:	10800217 	ldw	r2,8(r2)
 821ba40:	e0bff415 	stw	r2,-48(fp)
 821ba44:	e0bff617 	ldw	r2,-40(fp)
 821ba48:	e0bffb15 	stw	r2,-20(fp)
 821ba4c:	e0bffb17 	ldw	r2,-20(fp)
 821ba50:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 821ba54:	00000306 	br	821ba64 <OSTaskStkChk+0x160>
        nfree++;
 821ba58:	e0bff517 	ldw	r2,-44(fp)
 821ba5c:	10800044 	addi	r2,r2,1
 821ba60:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 821ba64:	e0bff417 	ldw	r2,-48(fp)
 821ba68:	10c00104 	addi	r3,r2,4
 821ba6c:	e0fff415 	stw	r3,-48(fp)
 821ba70:	10800017 	ldw	r2,0(r2)
 821ba74:	103ff826 	beq	r2,zero,821ba58 <OSTaskStkChk+0x154>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
 821ba78:	e0bff517 	ldw	r2,-44(fp)
 821ba7c:	1085883a 	add	r2,r2,r2
 821ba80:	1085883a 	add	r2,r2,r2
 821ba84:	1007883a 	mov	r3,r2
 821ba88:	e0bfff17 	ldw	r2,-4(fp)
 821ba8c:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
 821ba90:	e0fffc17 	ldw	r3,-16(fp)
 821ba94:	e0bff517 	ldw	r2,-44(fp)
 821ba98:	1885c83a 	sub	r2,r3,r2
 821ba9c:	1085883a 	add	r2,r2,r2
 821baa0:	1085883a 	add	r2,r2,r2
 821baa4:	1007883a 	mov	r3,r2
 821baa8:	e0bfff17 	ldw	r2,-4(fp)
 821baac:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
 821bab0:	0005883a 	mov	r2,zero
}
 821bab4:	e037883a 	mov	sp,fp
 821bab8:	df000017 	ldw	fp,0(sp)
 821babc:	dec00104 	addi	sp,sp,4
 821bac0:	f800283a 	ret

0821bac4 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
 821bac4:	defff504 	addi	sp,sp,-44
 821bac8:	dfc00a15 	stw	ra,40(sp)
 821bacc:	df000915 	stw	fp,36(sp)
 821bad0:	df000904 	addi	fp,sp,36
 821bad4:	2005883a 	mov	r2,r4
 821bad8:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821badc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
 821bae0:	e0bfff03 	ldbu	r2,-4(fp)
 821bae4:	10800518 	cmpnei	r2,r2,20
 821bae8:	1000021e 	bne	r2,zero,821baf4 <OSTaskSuspend+0x30>
        return (OS_ERR_TASK_SUSPEND_IDLE);
 821baec:	008011c4 	movi	r2,71
 821baf0:	00006806 	br	821bc94 <OSTaskSuspend+0x1d0>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 821baf4:	e0bfff03 	ldbu	r2,-4(fp)
 821baf8:	10800530 	cmpltui	r2,r2,20
 821bafc:	1000051e 	bne	r2,zero,821bb14 <OSTaskSuspend+0x50>
        if (prio != OS_PRIO_SELF) {
 821bb00:	e0bfff03 	ldbu	r2,-4(fp)
 821bb04:	10803fe0 	cmpeqi	r2,r2,255
 821bb08:	1000021e 	bne	r2,zero,821bb14 <OSTaskSuspend+0x50>
            return (OS_ERR_PRIO_INVALID);
 821bb0c:	00800a84 	movi	r2,42
 821bb10:	00006006 	br	821bc94 <OSTaskSuspend+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821bb14:	0005303a 	rdctl	r2,status
 821bb18:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821bb1c:	e0fffe17 	ldw	r3,-8(fp)
 821bb20:	00bfff84 	movi	r2,-2
 821bb24:	1884703a 	and	r2,r3,r2
 821bb28:	1001703a 	wrctl	status,r2
  
  return context;
 821bb2c:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
 821bb30:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
 821bb34:	e0bfff03 	ldbu	r2,-4(fp)
 821bb38:	10803fd8 	cmpnei	r2,r2,255
 821bb3c:	1000061e 	bne	r2,zero,821bb58 <OSTaskSuspend+0x94>
        prio = OSTCBCur->OSTCBPrio;
 821bb40:	d0a07a17 	ldw	r2,-32280(gp)
 821bb44:	10800c83 	ldbu	r2,50(r2)
 821bb48:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
 821bb4c:	00800044 	movi	r2,1
 821bb50:	e0bff705 	stb	r2,-36(fp)
 821bb54:	00000906 	br	821bb7c <OSTaskSuspend+0xb8>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
 821bb58:	d0a07a17 	ldw	r2,-32280(gp)
 821bb5c:	10800c83 	ldbu	r2,50(r2)
 821bb60:	10c03fcc 	andi	r3,r2,255
 821bb64:	e0bfff03 	ldbu	r2,-4(fp)
 821bb68:	1880031e 	bne	r3,r2,821bb78 <OSTaskSuspend+0xb4>
        self = OS_TRUE;
 821bb6c:	00800044 	movi	r2,1
 821bb70:	e0bff705 	stb	r2,-36(fp)
 821bb74:	00000106 	br	821bb7c <OSTaskSuspend+0xb8>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
 821bb78:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821bb7c:	e0ffff03 	ldbu	r3,-4(fp)
 821bb80:	008209b4 	movhi	r2,2086
 821bb84:	10b6b204 	addi	r2,r2,-9528
 821bb88:	18c7883a 	add	r3,r3,r3
 821bb8c:	18c7883a 	add	r3,r3,r3
 821bb90:	10c5883a 	add	r2,r2,r3
 821bb94:	10800017 	ldw	r2,0(r2)
 821bb98:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
 821bb9c:	e0bffa17 	ldw	r2,-24(fp)
 821bba0:	1000061e 	bne	r2,zero,821bbbc <OSTaskSuspend+0xf8>
 821bba4:	e0bff817 	ldw	r2,-32(fp)
 821bba8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821bbac:	e0bff917 	ldw	r2,-28(fp)
 821bbb0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
 821bbb4:	00801204 	movi	r2,72
 821bbb8:	00003606 	br	821bc94 <OSTaskSuspend+0x1d0>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
 821bbbc:	e0bffa17 	ldw	r2,-24(fp)
 821bbc0:	10800058 	cmpnei	r2,r2,1
 821bbc4:	1000061e 	bne	r2,zero,821bbe0 <OSTaskSuspend+0x11c>
 821bbc8:	e0bff817 	ldw	r2,-32(fp)
 821bbcc:	e0bffb15 	stw	r2,-20(fp)
 821bbd0:	e0bffb17 	ldw	r2,-20(fp)
 821bbd4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821bbd8:	008010c4 	movi	r2,67
 821bbdc:	00002d06 	br	821bc94 <OSTaskSuspend+0x1d0>
    }
    y            = ptcb->OSTCBY;
 821bbe0:	e0bffa17 	ldw	r2,-24(fp)
 821bbe4:	10800d03 	ldbu	r2,52(r2)
 821bbe8:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
 821bbec:	e0fffd03 	ldbu	r3,-12(fp)
 821bbf0:	e13ffd03 	ldbu	r4,-12(fp)
 821bbf4:	d0a07744 	addi	r2,gp,-32291
 821bbf8:	2085883a 	add	r2,r4,r2
 821bbfc:	10800003 	ldbu	r2,0(r2)
 821bc00:	1009883a 	mov	r4,r2
 821bc04:	e0bffa17 	ldw	r2,-24(fp)
 821bc08:	10800d43 	ldbu	r2,53(r2)
 821bc0c:	0084303a 	nor	r2,zero,r2
 821bc10:	2084703a 	and	r2,r4,r2
 821bc14:	1009883a 	mov	r4,r2
 821bc18:	d0a07744 	addi	r2,gp,-32291
 821bc1c:	1885883a 	add	r2,r3,r2
 821bc20:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 821bc24:	e0fffd03 	ldbu	r3,-12(fp)
 821bc28:	d0a07744 	addi	r2,gp,-32291
 821bc2c:	1885883a 	add	r2,r3,r2
 821bc30:	10800003 	ldbu	r2,0(r2)
 821bc34:	10803fcc 	andi	r2,r2,255
 821bc38:	1000071e 	bne	r2,zero,821bc58 <OSTaskSuspend+0x194>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
 821bc3c:	e0bffa17 	ldw	r2,-24(fp)
 821bc40:	10800d83 	ldbu	r2,54(r2)
 821bc44:	0084303a 	nor	r2,zero,r2
 821bc48:	1007883a 	mov	r3,r2
 821bc4c:	d0a07703 	ldbu	r2,-32292(gp)
 821bc50:	1884703a 	and	r2,r3,r2
 821bc54:	d0a07705 	stb	r2,-32292(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
 821bc58:	e0bffa17 	ldw	r2,-24(fp)
 821bc5c:	10800c03 	ldbu	r2,48(r2)
 821bc60:	10800214 	ori	r2,r2,8
 821bc64:	1007883a 	mov	r3,r2
 821bc68:	e0bffa17 	ldw	r2,-24(fp)
 821bc6c:	10c00c05 	stb	r3,48(r2)
 821bc70:	e0bff817 	ldw	r2,-32(fp)
 821bc74:	e0bffc15 	stw	r2,-16(fp)
 821bc78:	e0bffc17 	ldw	r2,-16(fp)
 821bc7c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
 821bc80:	e0bff703 	ldbu	r2,-36(fp)
 821bc84:	10800058 	cmpnei	r2,r2,1
 821bc88:	1000011e 	bne	r2,zero,821bc90 <OSTaskSuspend+0x1cc>
        OS_Sched();                                             /* Find new highest priority task      */
 821bc8c:	82164a00 	call	82164a0 <OS_Sched>
    }
    return (OS_ERR_NONE);
 821bc90:	0005883a 	mov	r2,zero
}
 821bc94:	e037883a 	mov	sp,fp
 821bc98:	dfc00117 	ldw	ra,4(sp)
 821bc9c:	df000017 	ldw	fp,0(sp)
 821bca0:	dec00204 	addi	sp,sp,8
 821bca4:	f800283a 	ret

0821bca8 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
 821bca8:	defff604 	addi	sp,sp,-40
 821bcac:	dfc00915 	stw	ra,36(sp)
 821bcb0:	df000815 	stw	fp,32(sp)
 821bcb4:	df000804 	addi	fp,sp,32
 821bcb8:	2005883a 	mov	r2,r4
 821bcbc:	e17fff15 	stw	r5,-4(fp)
 821bcc0:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821bcc4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
 821bcc8:	e0bffe03 	ldbu	r2,-8(fp)
 821bccc:	10800570 	cmpltui	r2,r2,21
 821bcd0:	1000051e 	bne	r2,zero,821bce8 <OSTaskQuery+0x40>
        if (prio != OS_PRIO_SELF) {
 821bcd4:	e0bffe03 	ldbu	r2,-8(fp)
 821bcd8:	10803fe0 	cmpeqi	r2,r2,255
 821bcdc:	1000021e 	bne	r2,zero,821bce8 <OSTaskQuery+0x40>
            return (OS_ERR_PRIO_INVALID);
 821bce0:	00800a84 	movi	r2,42
 821bce4:	00003406 	br	821bdb8 <OSTaskQuery+0x110>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
 821bce8:	e0bfff17 	ldw	r2,-4(fp)
 821bcec:	1000021e 	bne	r2,zero,821bcf8 <OSTaskQuery+0x50>
        return (OS_ERR_PDATA_NULL);
 821bcf0:	00800244 	movi	r2,9
 821bcf4:	00003006 	br	821bdb8 <OSTaskQuery+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821bcf8:	0005303a 	rdctl	r2,status
 821bcfc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821bd00:	e0fffd17 	ldw	r3,-12(fp)
 821bd04:	00bfff84 	movi	r2,-2
 821bd08:	1884703a 	and	r2,r3,r2
 821bd0c:	1001703a 	wrctl	status,r2
  
  return context;
 821bd10:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 821bd14:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
 821bd18:	e0bffe03 	ldbu	r2,-8(fp)
 821bd1c:	10803fd8 	cmpnei	r2,r2,255
 821bd20:	1000031e 	bne	r2,zero,821bd30 <OSTaskQuery+0x88>
        prio = OSTCBCur->OSTCBPrio;
 821bd24:	d0a07a17 	ldw	r2,-32280(gp)
 821bd28:	10800c83 	ldbu	r2,50(r2)
 821bd2c:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 821bd30:	e0fffe03 	ldbu	r3,-8(fp)
 821bd34:	008209b4 	movhi	r2,2086
 821bd38:	10b6b204 	addi	r2,r2,-9528
 821bd3c:	18c7883a 	add	r3,r3,r3
 821bd40:	18c7883a 	add	r3,r3,r3
 821bd44:	10c5883a 	add	r2,r2,r3
 821bd48:	10800017 	ldw	r2,0(r2)
 821bd4c:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
 821bd50:	e0bffa17 	ldw	r2,-24(fp)
 821bd54:	1000061e 	bne	r2,zero,821bd70 <OSTaskQuery+0xc8>
 821bd58:	e0bff817 	ldw	r2,-32(fp)
 821bd5c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821bd60:	e0bff917 	ldw	r2,-28(fp)
 821bd64:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
 821bd68:	00800a44 	movi	r2,41
 821bd6c:	00001206 	br	821bdb8 <OSTaskQuery+0x110>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
 821bd70:	e0bffa17 	ldw	r2,-24(fp)
 821bd74:	10800058 	cmpnei	r2,r2,1
 821bd78:	1000061e 	bne	r2,zero,821bd94 <OSTaskQuery+0xec>
 821bd7c:	e0bff817 	ldw	r2,-32(fp)
 821bd80:	e0bffb15 	stw	r2,-20(fp)
 821bd84:	e0bffb17 	ldw	r2,-20(fp)
 821bd88:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 821bd8c:	008010c4 	movi	r2,67
 821bd90:	00000906 	br	821bdb8 <OSTaskQuery+0x110>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
 821bd94:	01801b04 	movi	r6,108
 821bd98:	e17ffa17 	ldw	r5,-24(fp)
 821bd9c:	e13fff17 	ldw	r4,-4(fp)
 821bda0:	82164380 	call	8216438 <OS_MemCopy>
 821bda4:	e0bff817 	ldw	r2,-32(fp)
 821bda8:	e0bffc15 	stw	r2,-16(fp)
 821bdac:	e0bffc17 	ldw	r2,-16(fp)
 821bdb0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 821bdb4:	0005883a 	mov	r2,zero
}
 821bdb8:	e037883a 	mov	sp,fp
 821bdbc:	dfc00117 	ldw	ra,4(sp)
 821bdc0:	df000017 	ldw	fp,0(sp)
 821bdc4:	dec00204 	addi	sp,sp,8
 821bdc8:	f800283a 	ret

0821bdcc <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
 821bdcc:	defffc04 	addi	sp,sp,-16
 821bdd0:	df000315 	stw	fp,12(sp)
 821bdd4:	df000304 	addi	fp,sp,12
 821bdd8:	e13ffd15 	stw	r4,-12(fp)
 821bddc:	e17ffe15 	stw	r5,-8(fp)
 821bde0:	3005883a 	mov	r2,r6
 821bde4:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
 821bde8:	e0bfff0b 	ldhu	r2,-4(fp)
 821bdec:	1080004c 	andi	r2,r2,1
 821bdf0:	10000d26 	beq	r2,zero,821be28 <OS_TaskStkClr+0x5c>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
 821bdf4:	e0bfff0b 	ldhu	r2,-4(fp)
 821bdf8:	1080008c 	andi	r2,r2,2
 821bdfc:	10000a26 	beq	r2,zero,821be28 <OS_TaskStkClr+0x5c>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 821be00:	00000706 	br	821be20 <OS_TaskStkClr+0x54>
                size--;
 821be04:	e0bffe17 	ldw	r2,-8(fp)
 821be08:	10bfffc4 	addi	r2,r2,-1
 821be0c:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
 821be10:	e0bffd17 	ldw	r2,-12(fp)
 821be14:	10c00104 	addi	r3,r2,4
 821be18:	e0fffd15 	stw	r3,-12(fp)
 821be1c:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 821be20:	e0bffe17 	ldw	r2,-8(fp)
 821be24:	103ff71e 	bne	r2,zero,821be04 <OS_TaskStkClr+0x38>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
 821be28:	0001883a 	nop
 821be2c:	e037883a 	mov	sp,fp
 821be30:	df000017 	ldw	fp,0(sp)
 821be34:	dec00104 	addi	sp,sp,4
 821be38:	f800283a 	ret

0821be3c <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
 821be3c:	defff904 	addi	sp,sp,-28
 821be40:	dfc00615 	stw	ra,24(sp)
 821be44:	df000515 	stw	fp,20(sp)
 821be48:	df000504 	addi	fp,sp,20
 821be4c:	2005883a 	mov	r2,r4
 821be50:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821be54:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 821be58:	d0a07903 	ldbu	r2,-32284(gp)
 821be5c:	10803fcc 	andi	r2,r2,255
 821be60:	1000311e 	bne	r2,zero,821bf28 <OSTimeDly+0xec>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
 821be64:	e0bfff0b 	ldhu	r2,-4(fp)
 821be68:	10003026 	beq	r2,zero,821bf2c <OSTimeDly+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821be6c:	0005303a 	rdctl	r2,status
 821be70:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821be74:	e0fffe17 	ldw	r3,-8(fp)
 821be78:	00bfff84 	movi	r2,-2
 821be7c:	1884703a 	and	r2,r3,r2
 821be80:	1001703a 	wrctl	status,r2
  
  return context;
 821be84:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 821be88:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
 821be8c:	d0a07a17 	ldw	r2,-32280(gp)
 821be90:	10800d03 	ldbu	r2,52(r2)
 821be94:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 821be98:	e0fffd03 	ldbu	r3,-12(fp)
 821be9c:	e13ffd03 	ldbu	r4,-12(fp)
 821bea0:	d0a07744 	addi	r2,gp,-32291
 821bea4:	2085883a 	add	r2,r4,r2
 821bea8:	10800003 	ldbu	r2,0(r2)
 821beac:	1009883a 	mov	r4,r2
 821beb0:	d0a07a17 	ldw	r2,-32280(gp)
 821beb4:	10800d43 	ldbu	r2,53(r2)
 821beb8:	0084303a 	nor	r2,zero,r2
 821bebc:	2084703a 	and	r2,r4,r2
 821bec0:	1009883a 	mov	r4,r2
 821bec4:	d0a07744 	addi	r2,gp,-32291
 821bec8:	1885883a 	add	r2,r3,r2
 821becc:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
 821bed0:	e0fffd03 	ldbu	r3,-12(fp)
 821bed4:	d0a07744 	addi	r2,gp,-32291
 821bed8:	1885883a 	add	r2,r3,r2
 821bedc:	10800003 	ldbu	r2,0(r2)
 821bee0:	10803fcc 	andi	r2,r2,255
 821bee4:	1000071e 	bne	r2,zero,821bf04 <OSTimeDly+0xc8>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 821bee8:	d0a07a17 	ldw	r2,-32280(gp)
 821beec:	10800d83 	ldbu	r2,54(r2)
 821bef0:	0084303a 	nor	r2,zero,r2
 821bef4:	1007883a 	mov	r3,r2
 821bef8:	d0a07703 	ldbu	r2,-32292(gp)
 821befc:	1884703a 	and	r2,r3,r2
 821bf00:	d0a07705 	stb	r2,-32292(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
 821bf04:	d0a07a17 	ldw	r2,-32280(gp)
 821bf08:	e0ffff0b 	ldhu	r3,-4(fp)
 821bf0c:	10c00b8d 	sth	r3,46(r2)
 821bf10:	e0bffb17 	ldw	r2,-20(fp)
 821bf14:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821bf18:	e0bffc17 	ldw	r2,-16(fp)
 821bf1c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
 821bf20:	82164a00 	call	82164a0 <OS_Sched>
 821bf24:	00000106 	br	821bf2c <OSTimeDly+0xf0>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
 821bf28:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
 821bf2c:	e037883a 	mov	sp,fp
 821bf30:	dfc00117 	ldw	ra,4(sp)
 821bf34:	df000017 	ldw	fp,0(sp)
 821bf38:	dec00204 	addi	sp,sp,8
 821bf3c:	f800283a 	ret

0821bf40 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
 821bf40:	defff704 	addi	sp,sp,-36
 821bf44:	dfc00815 	stw	ra,32(sp)
 821bf48:	df000715 	stw	fp,28(sp)
 821bf4c:	dc000615 	stw	r16,24(sp)
 821bf50:	df000704 	addi	fp,sp,28
 821bf54:	2011883a 	mov	r8,r4
 821bf58:	2809883a 	mov	r4,r5
 821bf5c:	3007883a 	mov	r3,r6
 821bf60:	3805883a 	mov	r2,r7
 821bf64:	e23ffb05 	stb	r8,-20(fp)
 821bf68:	e13ffc05 	stb	r4,-16(fp)
 821bf6c:	e0fffd05 	stb	r3,-12(fp)
 821bf70:	e0bffe0d 	sth	r2,-8(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 821bf74:	d0a07903 	ldbu	r2,-32284(gp)
 821bf78:	10803fcc 	andi	r2,r2,255
 821bf7c:	10000226 	beq	r2,zero,821bf88 <OSTimeDlyHMSM+0x48>
        return (OS_ERR_TIME_DLY_ISR);
 821bf80:	00801544 	movi	r2,85
 821bf84:	00003e06 	br	821c080 <OSTimeDlyHMSM+0x140>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
 821bf88:	e0bffb03 	ldbu	r2,-20(fp)
 821bf8c:	1000081e 	bne	r2,zero,821bfb0 <OSTimeDlyHMSM+0x70>
        if (minutes == 0) {
 821bf90:	e0bffc03 	ldbu	r2,-16(fp)
 821bf94:	1000061e 	bne	r2,zero,821bfb0 <OSTimeDlyHMSM+0x70>
            if (seconds == 0) {
 821bf98:	e0bffd03 	ldbu	r2,-12(fp)
 821bf9c:	1000041e 	bne	r2,zero,821bfb0 <OSTimeDlyHMSM+0x70>
                if (ms == 0) {
 821bfa0:	e0bffe0b 	ldhu	r2,-8(fp)
 821bfa4:	1000021e 	bne	r2,zero,821bfb0 <OSTimeDlyHMSM+0x70>
                    return (OS_ERR_TIME_ZERO_DLY);
 821bfa8:	00801504 	movi	r2,84
 821bfac:	00003406 	br	821c080 <OSTimeDlyHMSM+0x140>
                }
            }
        }
    }
    if (minutes > 59) {
 821bfb0:	e0bffc03 	ldbu	r2,-16(fp)
 821bfb4:	10800f30 	cmpltui	r2,r2,60
 821bfb8:	1000021e 	bne	r2,zero,821bfc4 <OSTimeDlyHMSM+0x84>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
 821bfbc:	00801444 	movi	r2,81
 821bfc0:	00002f06 	br	821c080 <OSTimeDlyHMSM+0x140>
    }
    if (seconds > 59) {
 821bfc4:	e0bffd03 	ldbu	r2,-12(fp)
 821bfc8:	10800f30 	cmpltui	r2,r2,60
 821bfcc:	1000021e 	bne	r2,zero,821bfd8 <OSTimeDlyHMSM+0x98>
        return (OS_ERR_TIME_INVALID_SECONDS);
 821bfd0:	00801484 	movi	r2,82
 821bfd4:	00002a06 	br	821c080 <OSTimeDlyHMSM+0x140>
    }
    if (ms > 999) {
 821bfd8:	e0bffe0b 	ldhu	r2,-8(fp)
 821bfdc:	1080fa30 	cmpltui	r2,r2,1000
 821bfe0:	1000021e 	bne	r2,zero,821bfec <OSTimeDlyHMSM+0xac>
        return (OS_ERR_TIME_INVALID_MS);
 821bfe4:	008014c4 	movi	r2,83
 821bfe8:	00002506 	br	821c080 <OSTimeDlyHMSM+0x140>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 821bfec:	e0bffb03 	ldbu	r2,-20(fp)
 821bff0:	10c38424 	muli	r3,r2,3600
 821bff4:	e0bffc03 	ldbu	r2,-16(fp)
 821bff8:	10800f24 	muli	r2,r2,60
 821bffc:	1887883a 	add	r3,r3,r2
 821c000:	e0bffd03 	ldbu	r2,-12(fp)
 821c004:	1885883a 	add	r2,r3,r2
 821c008:	14001924 	muli	r16,r2,100
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
 821c00c:	e0bffe0b 	ldhu	r2,-8(fp)
 821c010:	10801924 	muli	r2,r2,100
 821c014:	10807d04 	addi	r2,r2,500
 821c018:	0140fa04 	movi	r5,1000
 821c01c:	1009883a 	mov	r4,r2
 821c020:	8202b8c0 	call	8202b8c <__udivsi3>
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 821c024:	8085883a 	add	r2,r16,r2
 821c028:	e0bffa15 	stw	r2,-24(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
 821c02c:	e0bffa17 	ldw	r2,-24(fp)
 821c030:	1004d43a 	srli	r2,r2,16
 821c034:	e0bff90d 	sth	r2,-28(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
 821c038:	e0bffa17 	ldw	r2,-24(fp)
 821c03c:	10bfffcc 	andi	r2,r2,65535
 821c040:	e0bffa15 	stw	r2,-24(fp)
    OSTimeDly((INT16U)ticks);
 821c044:	e0bffa17 	ldw	r2,-24(fp)
 821c048:	10bfffcc 	andi	r2,r2,65535
 821c04c:	1009883a 	mov	r4,r2
 821c050:	821be3c0 	call	821be3c <OSTimeDly>
    while (loops > 0) {
 821c054:	00000706 	br	821c074 <OSTimeDlyHMSM+0x134>
        OSTimeDly((INT16U)32768u);
 821c058:	01200014 	movui	r4,32768
 821c05c:	821be3c0 	call	821be3c <OSTimeDly>
        OSTimeDly((INT16U)32768u);
 821c060:	01200014 	movui	r4,32768
 821c064:	821be3c0 	call	821be3c <OSTimeDly>
        loops--;
 821c068:	e0bff90b 	ldhu	r2,-28(fp)
 821c06c:	10bfffc4 	addi	r2,r2,-1
 821c070:	e0bff90d 	sth	r2,-28(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
 821c074:	e0bff90b 	ldhu	r2,-28(fp)
 821c078:	103ff71e 	bne	r2,zero,821c058 <OSTimeDlyHMSM+0x118>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
 821c07c:	0005883a 	mov	r2,zero
}
 821c080:	e6ffff04 	addi	sp,fp,-4
 821c084:	dfc00217 	ldw	ra,8(sp)
 821c088:	df000117 	ldw	fp,4(sp)
 821c08c:	dc000017 	ldw	r16,0(sp)
 821c090:	dec00304 	addi	sp,sp,12
 821c094:	f800283a 	ret

0821c098 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
 821c098:	defff504 	addi	sp,sp,-44
 821c09c:	dfc00a15 	stw	ra,40(sp)
 821c0a0:	df000915 	stw	fp,36(sp)
 821c0a4:	df000904 	addi	fp,sp,36
 821c0a8:	2005883a 	mov	r2,r4
 821c0ac:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 821c0b0:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
 821c0b4:	e0bfff03 	ldbu	r2,-4(fp)
 821c0b8:	10800530 	cmpltui	r2,r2,20
 821c0bc:	1000021e 	bne	r2,zero,821c0c8 <OSTimeDlyResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 821c0c0:	00800a84 	movi	r2,42
 821c0c4:	00006406 	br	821c258 <OSTimeDlyResume+0x1c0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821c0c8:	0005303a 	rdctl	r2,status
 821c0cc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821c0d0:	e0fffe17 	ldw	r3,-8(fp)
 821c0d4:	00bfff84 	movi	r2,-2
 821c0d8:	1884703a 	and	r2,r3,r2
 821c0dc:	1001703a 	wrctl	status,r2
  
  return context;
 821c0e0:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 821c0e4:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
 821c0e8:	e0ffff03 	ldbu	r3,-4(fp)
 821c0ec:	008209b4 	movhi	r2,2086
 821c0f0:	10b6b204 	addi	r2,r2,-9528
 821c0f4:	18c7883a 	add	r3,r3,r3
 821c0f8:	18c7883a 	add	r3,r3,r3
 821c0fc:	10c5883a 	add	r2,r2,r3
 821c100:	10800017 	ldw	r2,0(r2)
 821c104:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
 821c108:	e0bff917 	ldw	r2,-28(fp)
 821c10c:	1000061e 	bne	r2,zero,821c128 <OSTimeDlyResume+0x90>
 821c110:	e0bff717 	ldw	r2,-36(fp)
 821c114:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821c118:	e0bff817 	ldw	r2,-32(fp)
 821c11c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 821c120:	008010c4 	movi	r2,67
 821c124:	00004c06 	br	821c258 <OSTimeDlyResume+0x1c0>
    }
    if (ptcb == OS_TCB_RESERVED) {
 821c128:	e0bff917 	ldw	r2,-28(fp)
 821c12c:	10800058 	cmpnei	r2,r2,1
 821c130:	1000061e 	bne	r2,zero,821c14c <OSTimeDlyResume+0xb4>
 821c134:	e0bff717 	ldw	r2,-36(fp)
 821c138:	e0bffa15 	stw	r2,-24(fp)
 821c13c:	e0bffa17 	ldw	r2,-24(fp)
 821c140:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 821c144:	008010c4 	movi	r2,67
 821c148:	00004306 	br	821c258 <OSTimeDlyResume+0x1c0>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
 821c14c:	e0bff917 	ldw	r2,-28(fp)
 821c150:	10800b8b 	ldhu	r2,46(r2)
 821c154:	10bfffcc 	andi	r2,r2,65535
 821c158:	1000061e 	bne	r2,zero,821c174 <OSTimeDlyResume+0xdc>
 821c15c:	e0bff717 	ldw	r2,-36(fp)
 821c160:	e0bffb15 	stw	r2,-20(fp)
 821c164:	e0bffb17 	ldw	r2,-20(fp)
 821c168:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
 821c16c:	00801404 	movi	r2,80
 821c170:	00003906 	br	821c258 <OSTimeDlyResume+0x1c0>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
 821c174:	e0bff917 	ldw	r2,-28(fp)
 821c178:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 821c17c:	e0bff917 	ldw	r2,-28(fp)
 821c180:	10800c03 	ldbu	r2,48(r2)
 821c184:	10803fcc 	andi	r2,r2,255
 821c188:	10800dcc 	andi	r2,r2,55
 821c18c:	10000b26 	beq	r2,zero,821c1bc <OSTimeDlyResume+0x124>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
 821c190:	e0bff917 	ldw	r2,-28(fp)
 821c194:	10c00c03 	ldbu	r3,48(r2)
 821c198:	00bff204 	movi	r2,-56
 821c19c:	1884703a 	and	r2,r3,r2
 821c1a0:	1007883a 	mov	r3,r2
 821c1a4:	e0bff917 	ldw	r2,-28(fp)
 821c1a8:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
 821c1ac:	e0bff917 	ldw	r2,-28(fp)
 821c1b0:	00c00044 	movi	r3,1
 821c1b4:	10c00c45 	stb	r3,49(r2)
 821c1b8:	00000206 	br	821c1c4 <OSTimeDlyResume+0x12c>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
 821c1bc:	e0bff917 	ldw	r2,-28(fp)
 821c1c0:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
 821c1c4:	e0bff917 	ldw	r2,-28(fp)
 821c1c8:	10800c03 	ldbu	r2,48(r2)
 821c1cc:	10803fcc 	andi	r2,r2,255
 821c1d0:	1080020c 	andi	r2,r2,8
 821c1d4:	10001b1e 	bne	r2,zero,821c244 <OSTimeDlyResume+0x1ac>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
 821c1d8:	e0bff917 	ldw	r2,-28(fp)
 821c1dc:	10c00d83 	ldbu	r3,54(r2)
 821c1e0:	d0a07703 	ldbu	r2,-32292(gp)
 821c1e4:	1884b03a 	or	r2,r3,r2
 821c1e8:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 821c1ec:	e0bff917 	ldw	r2,-28(fp)
 821c1f0:	10800d03 	ldbu	r2,52(r2)
 821c1f4:	10c03fcc 	andi	r3,r2,255
 821c1f8:	e0bff917 	ldw	r2,-28(fp)
 821c1fc:	10800d03 	ldbu	r2,52(r2)
 821c200:	11003fcc 	andi	r4,r2,255
 821c204:	d0a07744 	addi	r2,gp,-32291
 821c208:	2085883a 	add	r2,r4,r2
 821c20c:	11000003 	ldbu	r4,0(r2)
 821c210:	e0bff917 	ldw	r2,-28(fp)
 821c214:	10800d43 	ldbu	r2,53(r2)
 821c218:	2084b03a 	or	r2,r4,r2
 821c21c:	1009883a 	mov	r4,r2
 821c220:	d0a07744 	addi	r2,gp,-32291
 821c224:	1885883a 	add	r2,r3,r2
 821c228:	11000005 	stb	r4,0(r2)
 821c22c:	e0bff717 	ldw	r2,-36(fp)
 821c230:	e0bffc15 	stw	r2,-16(fp)
 821c234:	e0bffc17 	ldw	r2,-16(fp)
 821c238:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
 821c23c:	82164a00 	call	82164a0 <OS_Sched>
 821c240:	00000406 	br	821c254 <OSTimeDlyResume+0x1bc>
 821c244:	e0bff717 	ldw	r2,-36(fp)
 821c248:	e0bffd15 	stw	r2,-12(fp)
 821c24c:	e0bffd17 	ldw	r2,-12(fp)
 821c250:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
 821c254:	0005883a 	mov	r2,zero
}
 821c258:	e037883a 	mov	sp,fp
 821c25c:	dfc00117 	ldw	ra,4(sp)
 821c260:	df000017 	ldw	fp,0(sp)
 821c264:	dec00204 	addi	sp,sp,8
 821c268:	f800283a 	ret

0821c26c <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
 821c26c:	defffb04 	addi	sp,sp,-20
 821c270:	df000415 	stw	fp,16(sp)
 821c274:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821c278:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821c27c:	0005303a 	rdctl	r2,status
 821c280:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821c284:	e0fffe17 	ldw	r3,-8(fp)
 821c288:	00bfff84 	movi	r2,-2
 821c28c:	1884703a 	and	r2,r3,r2
 821c290:	1001703a 	wrctl	status,r2
  
  return context;
 821c294:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 821c298:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
 821c29c:	d0a07b17 	ldw	r2,-32276(gp)
 821c2a0:	e0bffd15 	stw	r2,-12(fp)
 821c2a4:	e0bffc17 	ldw	r2,-16(fp)
 821c2a8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821c2ac:	e0bfff17 	ldw	r2,-4(fp)
 821c2b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
 821c2b4:	e0bffd17 	ldw	r2,-12(fp)
}
 821c2b8:	e037883a 	mov	sp,fp
 821c2bc:	df000017 	ldw	fp,0(sp)
 821c2c0:	dec00104 	addi	sp,sp,4
 821c2c4:	f800283a 	ret

0821c2c8 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
 821c2c8:	defffb04 	addi	sp,sp,-20
 821c2cc:	df000415 	stw	fp,16(sp)
 821c2d0:	df000404 	addi	fp,sp,16
 821c2d4:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 821c2d8:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821c2dc:	0005303a 	rdctl	r2,status
 821c2e0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821c2e4:	e0fffd17 	ldw	r3,-12(fp)
 821c2e8:	00bfff84 	movi	r2,-2
 821c2ec:	1884703a 	and	r2,r3,r2
 821c2f0:	1001703a 	wrctl	status,r2
  
  return context;
 821c2f4:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 821c2f8:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
 821c2fc:	e0bfff17 	ldw	r2,-4(fp)
 821c300:	d0a07b15 	stw	r2,-32276(gp)
 821c304:	e0bffc17 	ldw	r2,-16(fp)
 821c308:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821c30c:	e0bffe17 	ldw	r2,-8(fp)
 821c310:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 821c314:	0001883a 	nop
 821c318:	e037883a 	mov	sp,fp
 821c31c:	df000017 	ldw	fp,0(sp)
 821c320:	dec00104 	addi	sp,sp,4
 821c324:	f800283a 	ret

0821c328 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 821c328:	defffd04 	addi	sp,sp,-12
 821c32c:	dfc00215 	stw	ra,8(sp)
 821c330:	df000115 	stw	fp,4(sp)
 821c334:	df000104 	addi	fp,sp,4
 821c338:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 821c33c:	d1604404 	addi	r5,gp,-32496
 821c340:	e13fff17 	ldw	r4,-4(fp)
 821c344:	823bc5c0 	call	823bc5c <alt_dev_llist_insert>
}
 821c348:	e037883a 	mov	sp,fp
 821c34c:	dfc00117 	ldw	ra,4(sp)
 821c350:	df000017 	ldw	fp,0(sp)
 821c354:	dec00204 	addi	sp,sp,8
 821c358:	f800283a 	ret

0821c35c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 821c35c:	defffd04 	addi	sp,sp,-12
 821c360:	dfc00215 	stw	ra,8(sp)
 821c364:	df000115 	stw	fp,4(sp)
 821c368:	df000104 	addi	fp,sp,4
 821c36c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CPU, cpu);
 821c370:	823cafc0 	call	823cafc <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 821c374:	00800044 	movi	r2,1
 821c378:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 821c37c:	0001883a 	nop
 821c380:	e037883a 	mov	sp,fp
 821c384:	dfc00117 	ldw	ra,4(sp)
 821c388:	df000017 	ldw	fp,0(sp)
 821c38c:	dec00204 	addi	sp,sp,8
 821c390:	f800283a 	ret

0821c394 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 821c394:	defffa04 	addi	sp,sp,-24
 821c398:	dfc00515 	stw	ra,20(sp)
 821c39c:	df000415 	stw	fp,16(sp)
 821c3a0:	df000404 	addi	fp,sp,16
    ALTERA_AVALON_TIMER_INIT ( HIGH_RES_TIMER, high_res_timer);
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
 821c3a4:	01c01904 	movi	r7,100
 821c3a8:	000d883a 	mov	r6,zero
 821c3ac:	000b883a 	mov	r5,zero
 821c3b0:	01024034 	movhi	r4,2304
 821c3b4:	821f0440 	call	821f044 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 821c3b8:	01800044 	movi	r6,1
 821c3bc:	000b883a 	mov	r5,zero
 821c3c0:	01020974 	movhi	r4,2085
 821c3c4:	210a3c04 	addi	r4,r4,10480
 821c3c8:	821c7300 	call	821c730 <altera_avalon_jtag_uart_init>
 821c3cc:	01020974 	movhi	r4,2085
 821c3d0:	210a3204 	addi	r4,r4,10440
 821c3d4:	821c3280 	call	821c328 <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD, lcd);
 821c3d8:	01020974 	movhi	r4,2085
 821c3dc:	210e5704 	addi	r4,r4,14684
 821c3e0:	821e0780 	call	821e078 <altera_avalon_lcd_16207_init>
 821c3e4:	01020974 	movhi	r4,2085
 821c3e8:	210e4d04 	addi	r4,r4,14644
 821c3ec:	821c3280 	call	821c328 <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
 821c3f0:	01800084 	movi	r6,2
 821c3f4:	000b883a 	mov	r5,zero
 821c3f8:	01020974 	movhi	r4,2085
 821c3fc:	210e9604 	addi	r4,r4,14936
 821c400:	821ef240 	call	821ef24 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
 821c404:	018000c4 	movi	r6,3
 821c408:	000b883a 	mov	r5,zero
 821c40c:	01020974 	movhi	r4,2085
 821c410:	210ea204 	addi	r4,r4,14984
 821c414:	821ef240 	call	821ef24 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
 821c418:	0001883a 	nop
    ALTERA_ETH_TSE_INIT ( TSE_MAC, tse_mac);
 821c41c:	e03ffc15 	stw	zero,-16(fp)
 821c420:	00800044 	movi	r2,1
 821c424:	e0bffd15 	stw	r2,-12(fp)
 821c428:	e0bffd17 	ldw	r2,-12(fp)
 821c42c:	00800216 	blt	zero,r2,821c438 <alt_sys_init+0xa4>
 821c430:	00800044 	movi	r2,1
 821c434:	e0bffd15 	stw	r2,-12(fp)
 821c438:	e03ffc15 	stw	zero,-16(fp)
 821c43c:	00005a06 	br	821c5a8 <alt_sys_init+0x214>
 821c440:	008209b4 	movhi	r2,2086
 821c444:	10b6c704 	addi	r2,r2,-9444
 821c448:	e0fffc17 	ldw	r3,-16(fp)
 821c44c:	18c00724 	muli	r3,r3,28
 821c450:	10c5883a 	add	r2,r2,r3
 821c454:	10000015 	stw	zero,0(r2)
 821c458:	008209b4 	movhi	r2,2086
 821c45c:	10b6c704 	addi	r2,r2,-9444
 821c460:	e0fffc17 	ldw	r3,-16(fp)
 821c464:	18c00724 	muli	r3,r3,28
 821c468:	10c5883a 	add	r2,r2,r3
 821c46c:	10800104 	addi	r2,r2,4
 821c470:	10000015 	stw	zero,0(r2)
 821c474:	d0e02917 	ldw	r3,-32604(gp)
 821c478:	008209b4 	movhi	r2,2086
 821c47c:	10b6c704 	addi	r2,r2,-9444
 821c480:	e13ffc17 	ldw	r4,-16(fp)
 821c484:	21000724 	muli	r4,r4,28
 821c488:	1105883a 	add	r2,r2,r4
 821c48c:	10800204 	addi	r2,r2,8
 821c490:	10c00015 	stw	r3,0(r2)
 821c494:	008209b4 	movhi	r2,2086
 821c498:	10b6c704 	addi	r2,r2,-9444
 821c49c:	e0fffc17 	ldw	r3,-16(fp)
 821c4a0:	18c00724 	muli	r3,r3,28
 821c4a4:	10c5883a 	add	r2,r2,r3
 821c4a8:	10c00304 	addi	r3,r2,12
 821c4ac:	008208b4 	movhi	r2,2082
 821c4b0:	10902c04 	addi	r2,r2,16560
 821c4b4:	18800015 	stw	r2,0(r3)
 821c4b8:	e0bffc17 	ldw	r2,-16(fp)
 821c4bc:	10c00724 	muli	r3,r2,28
 821c4c0:	008209b4 	movhi	r2,2086
 821c4c4:	10b6c704 	addi	r2,r2,-9444
 821c4c8:	1885883a 	add	r2,r3,r2
 821c4cc:	d0e02e04 	addi	r3,gp,-32584
 821c4d0:	e0fffe15 	stw	r3,-8(fp)
 821c4d4:	e0bfff15 	stw	r2,-4(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 821c4d8:	e0bfff17 	ldw	r2,-4(fp)
 821c4dc:	e0fffe17 	ldw	r3,-8(fp)
 821c4e0:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 821c4e4:	e0bffe17 	ldw	r2,-8(fp)
 821c4e8:	10c00017 	ldw	r3,0(r2)
 821c4ec:	e0bfff17 	ldw	r2,-4(fp)
 821c4f0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 821c4f4:	e0bffe17 	ldw	r2,-8(fp)
 821c4f8:	10800017 	ldw	r2,0(r2)
 821c4fc:	e0ffff17 	ldw	r3,-4(fp)
 821c500:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 821c504:	e0bffe17 	ldw	r2,-8(fp)
 821c508:	e0ffff17 	ldw	r3,-4(fp)
 821c50c:	10c00015 	stw	r3,0(r2)
 821c510:	d0a08003 	ldbu	r2,-32256(gp)
 821c514:	11003fcc 	andi	r4,r2,255
 821c518:	e0bffc17 	ldw	r2,-16(fp)
 821c51c:	10c00724 	muli	r3,r2,28
 821c520:	008209b4 	movhi	r2,2086
 821c524:	10b6c704 	addi	r2,r2,-9444
 821c528:	1887883a 	add	r3,r3,r2
 821c52c:	008209b4 	movhi	r2,2086
 821c530:	10b70704 	addi	r2,r2,-9188
 821c534:	21000324 	muli	r4,r4,12
 821c538:	1105883a 	add	r2,r2,r4
 821c53c:	10c00015 	stw	r3,0(r2)
 821c540:	d0a08003 	ldbu	r2,-32256(gp)
 821c544:	10c03fcc 	andi	r3,r2,255
 821c548:	008209b4 	movhi	r2,2086
 821c54c:	10b70704 	addi	r2,r2,-9188
 821c550:	18c00324 	muli	r3,r3,12
 821c554:	10c5883a 	add	r2,r2,r3
 821c558:	10c00104 	addi	r3,r2,4
 821c55c:	00820034 	movhi	r2,2048
 821c560:	108c0004 	addi	r2,r2,12288
 821c564:	18800015 	stw	r2,0(r3)
 821c568:	d0a08003 	ldbu	r2,-32256(gp)
 821c56c:	10c03fcc 	andi	r3,r2,255
 821c570:	e0bffc17 	ldw	r2,-16(fp)
 821c574:	1009883a 	mov	r4,r2
 821c578:	008209b4 	movhi	r2,2086
 821c57c:	10b70704 	addi	r2,r2,-9188
 821c580:	18c00324 	muli	r3,r3,12
 821c584:	10c5883a 	add	r2,r2,r3
 821c588:	10800204 	addi	r2,r2,8
 821c58c:	11000005 	stb	r4,0(r2)
 821c590:	d0a08003 	ldbu	r2,-32256(gp)
 821c594:	10800044 	addi	r2,r2,1
 821c598:	d0a08005 	stb	r2,-32256(gp)
 821c59c:	e0bffc17 	ldw	r2,-16(fp)
 821c5a0:	10800044 	addi	r2,r2,1
 821c5a4:	e0bffc15 	stw	r2,-16(fp)
 821c5a8:	e0fffc17 	ldw	r3,-16(fp)
 821c5ac:	e0bffd17 	ldw	r2,-12(fp)
 821c5b0:	18bfa316 	blt	r3,r2,821c440 <alt_sys_init+0xac>
}
 821c5b4:	0001883a 	nop
 821c5b8:	e037883a 	mov	sp,fp
 821c5bc:	dfc00117 	ldw	ra,4(sp)
 821c5c0:	df000017 	ldw	fp,0(sp)
 821c5c4:	dec00204 	addi	sp,sp,8
 821c5c8:	f800283a 	ret

0821c5cc <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 821c5cc:	defffa04 	addi	sp,sp,-24
 821c5d0:	dfc00515 	stw	ra,20(sp)
 821c5d4:	df000415 	stw	fp,16(sp)
 821c5d8:	df000404 	addi	fp,sp,16
 821c5dc:	e13ffd15 	stw	r4,-12(fp)
 821c5e0:	e17ffe15 	stw	r5,-8(fp)
 821c5e4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 821c5e8:	e0bffd17 	ldw	r2,-12(fp)
 821c5ec:	10800017 	ldw	r2,0(r2)
 821c5f0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 821c5f4:	e0bffc17 	ldw	r2,-16(fp)
 821c5f8:	10c00a04 	addi	r3,r2,40
 821c5fc:	e0bffd17 	ldw	r2,-12(fp)
 821c600:	10800217 	ldw	r2,8(r2)
 821c604:	100f883a 	mov	r7,r2
 821c608:	e1bfff17 	ldw	r6,-4(fp)
 821c60c:	e17ffe17 	ldw	r5,-8(fp)
 821c610:	1809883a 	mov	r4,r3
 821c614:	821cd780 	call	821cd78 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 821c618:	e037883a 	mov	sp,fp
 821c61c:	dfc00117 	ldw	ra,4(sp)
 821c620:	df000017 	ldw	fp,0(sp)
 821c624:	dec00204 	addi	sp,sp,8
 821c628:	f800283a 	ret

0821c62c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 821c62c:	defffa04 	addi	sp,sp,-24
 821c630:	dfc00515 	stw	ra,20(sp)
 821c634:	df000415 	stw	fp,16(sp)
 821c638:	df000404 	addi	fp,sp,16
 821c63c:	e13ffd15 	stw	r4,-12(fp)
 821c640:	e17ffe15 	stw	r5,-8(fp)
 821c644:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 821c648:	e0bffd17 	ldw	r2,-12(fp)
 821c64c:	10800017 	ldw	r2,0(r2)
 821c650:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 821c654:	e0bffc17 	ldw	r2,-16(fp)
 821c658:	10c00a04 	addi	r3,r2,40
 821c65c:	e0bffd17 	ldw	r2,-12(fp)
 821c660:	10800217 	ldw	r2,8(r2)
 821c664:	100f883a 	mov	r7,r2
 821c668:	e1bfff17 	ldw	r6,-4(fp)
 821c66c:	e17ffe17 	ldw	r5,-8(fp)
 821c670:	1809883a 	mov	r4,r3
 821c674:	821d0340 	call	821d034 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 821c678:	e037883a 	mov	sp,fp
 821c67c:	dfc00117 	ldw	ra,4(sp)
 821c680:	df000017 	ldw	fp,0(sp)
 821c684:	dec00204 	addi	sp,sp,8
 821c688:	f800283a 	ret

0821c68c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 821c68c:	defffc04 	addi	sp,sp,-16
 821c690:	dfc00315 	stw	ra,12(sp)
 821c694:	df000215 	stw	fp,8(sp)
 821c698:	df000204 	addi	fp,sp,8
 821c69c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 821c6a0:	e0bfff17 	ldw	r2,-4(fp)
 821c6a4:	10800017 	ldw	r2,0(r2)
 821c6a8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 821c6ac:	e0bffe17 	ldw	r2,-8(fp)
 821c6b0:	10c00a04 	addi	r3,r2,40
 821c6b4:	e0bfff17 	ldw	r2,-4(fp)
 821c6b8:	10800217 	ldw	r2,8(r2)
 821c6bc:	100b883a 	mov	r5,r2
 821c6c0:	1809883a 	mov	r4,r3
 821c6c4:	821cc200 	call	821cc20 <altera_avalon_jtag_uart_close>
}
 821c6c8:	e037883a 	mov	sp,fp
 821c6cc:	dfc00117 	ldw	ra,4(sp)
 821c6d0:	df000017 	ldw	fp,0(sp)
 821c6d4:	dec00204 	addi	sp,sp,8
 821c6d8:	f800283a 	ret

0821c6dc <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 821c6dc:	defffa04 	addi	sp,sp,-24
 821c6e0:	dfc00515 	stw	ra,20(sp)
 821c6e4:	df000415 	stw	fp,16(sp)
 821c6e8:	df000404 	addi	fp,sp,16
 821c6ec:	e13ffd15 	stw	r4,-12(fp)
 821c6f0:	e17ffe15 	stw	r5,-8(fp)
 821c6f4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 821c6f8:	e0bffd17 	ldw	r2,-12(fp)
 821c6fc:	10800017 	ldw	r2,0(r2)
 821c700:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 821c704:	e0bffc17 	ldw	r2,-16(fp)
 821c708:	10800a04 	addi	r2,r2,40
 821c70c:	e1bfff17 	ldw	r6,-4(fp)
 821c710:	e17ffe17 	ldw	r5,-8(fp)
 821c714:	1009883a 	mov	r4,r2
 821c718:	821cc880 	call	821cc88 <altera_avalon_jtag_uart_ioctl>
}
 821c71c:	e037883a 	mov	sp,fp
 821c720:	dfc00117 	ldw	ra,4(sp)
 821c724:	df000017 	ldw	fp,0(sp)
 821c728:	dec00204 	addi	sp,sp,8
 821c72c:	f800283a 	ret

0821c730 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 821c730:	defff104 	addi	sp,sp,-60
 821c734:	dfc00e15 	stw	ra,56(sp)
 821c738:	df000d15 	stw	fp,52(sp)
 821c73c:	df000d04 	addi	fp,sp,52
 821c740:	e13ff915 	stw	r4,-28(fp)
 821c744:	e17ffa15 	stw	r5,-24(fp)
 821c748:	e1bffb15 	stw	r6,-20(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
 821c74c:	e0bff917 	ldw	r2,-28(fp)
 821c750:	10800c04 	addi	r2,r2,48
 821c754:	e0bff415 	stw	r2,-48(fp)
 821c758:	e03ff80d 	sth	zero,-32(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
 821c75c:	e0bff80b 	ldhu	r2,-32(fp)
 821c760:	e0fff884 	addi	r3,fp,-30
 821c764:	180b883a 	mov	r5,r3
 821c768:	1009883a 	mov	r4,r2
 821c76c:	821700c0 	call	821700c <OSFlagCreate>
 821c770:	1007883a 	mov	r3,r2
 821c774:	e0bff417 	ldw	r2,-48(fp)
 821c778:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
 821c77c:	e0bff917 	ldw	r2,-28(fp)
 821c780:	10800a04 	addi	r2,r2,40
 821c784:	e0bff515 	stw	r2,-44(fp)
 821c788:	00800044 	movi	r2,1
 821c78c:	e0bff78d 	sth	r2,-34(fp)
 821c790:	e0bff78b 	ldhu	r2,-34(fp)
 821c794:	1009883a 	mov	r4,r2
 821c798:	8219d200 	call	8219d20 <OSSemCreate>
 821c79c:	1007883a 	mov	r3,r2
 821c7a0:	e0bff517 	ldw	r2,-44(fp)
 821c7a4:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 821c7a8:	e0bff917 	ldw	r2,-28(fp)
 821c7ac:	10800b04 	addi	r2,r2,44
 821c7b0:	e0bff615 	stw	r2,-40(fp)
 821c7b4:	00800044 	movi	r2,1
 821c7b8:	e0bff70d 	sth	r2,-36(fp)
 821c7bc:	e0bff70b 	ldhu	r2,-36(fp)
 821c7c0:	1009883a 	mov	r4,r2
 821c7c4:	8219d200 	call	8219d20 <OSSemCreate>
 821c7c8:	1007883a 	mov	r3,r2
 821c7cc:	e0bff617 	ldw	r2,-40(fp)
 821c7d0:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 821c7d4:	e0bff917 	ldw	r2,-28(fp)
 821c7d8:	00c00044 	movi	r3,1
 821c7dc:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 821c7e0:	e0bff917 	ldw	r2,-28(fp)
 821c7e4:	10800017 	ldw	r2,0(r2)
 821c7e8:	10800104 	addi	r2,r2,4
 821c7ec:	1007883a 	mov	r3,r2
 821c7f0:	e0bff917 	ldw	r2,-28(fp)
 821c7f4:	10800817 	ldw	r2,32(r2)
 821c7f8:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 821c7fc:	e0bffa17 	ldw	r2,-24(fp)
 821c800:	e0fffb17 	ldw	r3,-20(fp)
 821c804:	d8000015 	stw	zero,0(sp)
 821c808:	e1fff917 	ldw	r7,-28(fp)
 821c80c:	018208b4 	movhi	r6,2082
 821c810:	31b21e04 	addi	r6,r6,-14216
 821c814:	180b883a 	mov	r5,r3
 821c818:	1009883a 	mov	r4,r2
 821c81c:	823be500 	call	823be50 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 821c820:	e0bff917 	ldw	r2,-28(fp)
 821c824:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 821c828:	e0bff917 	ldw	r2,-28(fp)
 821c82c:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 821c830:	d0e0b817 	ldw	r3,-32032(gp)
 821c834:	e1fff917 	ldw	r7,-28(fp)
 821c838:	018208b4 	movhi	r6,2082
 821c83c:	31b2c704 	addi	r6,r6,-13540
 821c840:	180b883a 	mov	r5,r3
 821c844:	1009883a 	mov	r4,r2
 821c848:	823b9440 	call	823b944 <alt_alarm_start>
 821c84c:	1000040e 	bge	r2,zero,821c860 <altera_avalon_jtag_uart_init+0x130>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 821c850:	e0fff917 	ldw	r3,-28(fp)
 821c854:	00a00034 	movhi	r2,32768
 821c858:	10bfffc4 	addi	r2,r2,-1
 821c85c:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 821c860:	0001883a 	nop
 821c864:	e037883a 	mov	sp,fp
 821c868:	dfc00117 	ldw	ra,4(sp)
 821c86c:	df000017 	ldw	fp,0(sp)
 821c870:	dec00204 	addi	sp,sp,8
 821c874:	f800283a 	ret

0821c878 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 821c878:	defff204 	addi	sp,sp,-56
 821c87c:	dfc00d15 	stw	ra,52(sp)
 821c880:	df000c15 	stw	fp,48(sp)
 821c884:	df000c04 	addi	fp,sp,48
 821c888:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 821c88c:	e0bfff17 	ldw	r2,-4(fp)
 821c890:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
 821c894:	e0bff617 	ldw	r2,-40(fp)
 821c898:	10800017 	ldw	r2,0(r2)
 821c89c:	e0bff715 	stw	r2,-36(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 821c8a0:	e0bff717 	ldw	r2,-36(fp)
 821c8a4:	10800104 	addi	r2,r2,4
 821c8a8:	10800037 	ldwio	r2,0(r2)
 821c8ac:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 821c8b0:	e0bff817 	ldw	r2,-32(fp)
 821c8b4:	1080c00c 	andi	r2,r2,768
 821c8b8:	10009126 	beq	r2,zero,821cb00 <altera_avalon_jtag_uart_irq+0x288>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 821c8bc:	e0bff817 	ldw	r2,-32(fp)
 821c8c0:	1080400c 	andi	r2,r2,256
 821c8c4:	10004726 	beq	r2,zero,821c9e4 <altera_avalon_jtag_uart_irq+0x16c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 821c8c8:	00800074 	movhi	r2,1
 821c8cc:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821c8d0:	e0bff617 	ldw	r2,-40(fp)
 821c8d4:	10800d17 	ldw	r2,52(r2)
 821c8d8:	10800044 	addi	r2,r2,1
 821c8dc:	1081ffcc 	andi	r2,r2,2047
 821c8e0:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
 821c8e4:	e0bff617 	ldw	r2,-40(fp)
 821c8e8:	10c00e17 	ldw	r3,56(r2)
 821c8ec:	e0bff917 	ldw	r2,-28(fp)
 821c8f0:	18802726 	beq	r3,r2,821c990 <altera_avalon_jtag_uart_irq+0x118>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 821c8f4:	e0bff717 	ldw	r2,-36(fp)
 821c8f8:	10800037 	ldwio	r2,0(r2)
 821c8fc:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 821c900:	e0bff417 	ldw	r2,-48(fp)
 821c904:	10a0000c 	andi	r2,r2,32768
 821c908:	10002326 	beq	r2,zero,821c998 <altera_avalon_jtag_uart_irq+0x120>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 821c90c:	e0bff617 	ldw	r2,-40(fp)
 821c910:	10800d17 	ldw	r2,52(r2)
 821c914:	e0fff417 	ldw	r3,-48(fp)
 821c918:	1809883a 	mov	r4,r3
 821c91c:	e0fff617 	ldw	r3,-40(fp)
 821c920:	1885883a 	add	r2,r3,r2
 821c924:	10801104 	addi	r2,r2,68
 821c928:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821c92c:	e0bff617 	ldw	r2,-40(fp)
 821c930:	10800d17 	ldw	r2,52(r2)
 821c934:	10800044 	addi	r2,r2,1
 821c938:	10c1ffcc 	andi	r3,r2,2047
 821c93c:	e0bff617 	ldw	r2,-40(fp)
 821c940:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
 821c944:	e0bff617 	ldw	r2,-40(fp)
 821c948:	10800c17 	ldw	r2,48(r2)
 821c94c:	e0bffb15 	stw	r2,-20(fp)
 821c950:	00800044 	movi	r2,1
 821c954:	e0bffc0d 	sth	r2,-16(fp)
 821c958:	00800044 	movi	r2,1
 821c95c:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 821c960:	d0a06b43 	ldbu	r2,-32339(gp)
 821c964:	10803fcc 	andi	r2,r2,255
 821c968:	103fd926 	beq	r2,zero,821c8d0 <altera_avalon_jtag_uart_irq+0x58>
  {
    OSFlagPost (group, flags, opt, &err);
 821c96c:	e0bffc0b 	ldhu	r2,-16(fp)
 821c970:	e0fffc83 	ldbu	r3,-14(fp)
 821c974:	e13ffdc4 	addi	r4,fp,-9
 821c978:	200f883a 	mov	r7,r4
 821c97c:	180d883a 	mov	r6,r3
 821c980:	100b883a 	mov	r5,r2
 821c984:	e13ffb17 	ldw	r4,-20(fp)
 821c988:	8217be80 	call	8217be8 <OSFlagPost>
      }
 821c98c:	003fd006 	br	821c8d0 <altera_avalon_jtag_uart_irq+0x58>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 821c990:	0001883a 	nop
 821c994:	00000106 	br	821c99c <altera_avalon_jtag_uart_irq+0x124>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 821c998:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 821c99c:	e0bff417 	ldw	r2,-48(fp)
 821c9a0:	10bfffec 	andhi	r2,r2,65535
 821c9a4:	10000f26 	beq	r2,zero,821c9e4 <altera_avalon_jtag_uart_irq+0x16c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 821c9a8:	e0bff617 	ldw	r2,-40(fp)
 821c9ac:	10c00817 	ldw	r3,32(r2)
 821c9b0:	00bfff84 	movi	r2,-2
 821c9b4:	1886703a 	and	r3,r3,r2
 821c9b8:	e0bff617 	ldw	r2,-40(fp)
 821c9bc:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 821c9c0:	e0bff717 	ldw	r2,-36(fp)
 821c9c4:	10800104 	addi	r2,r2,4
 821c9c8:	1007883a 	mov	r3,r2
 821c9cc:	e0bff617 	ldw	r2,-40(fp)
 821c9d0:	10800817 	ldw	r2,32(r2)
 821c9d4:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 821c9d8:	e0bff717 	ldw	r2,-36(fp)
 821c9dc:	10800104 	addi	r2,r2,4
 821c9e0:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 821c9e4:	e0bff817 	ldw	r2,-32(fp)
 821c9e8:	1080800c 	andi	r2,r2,512
 821c9ec:	103fac26 	beq	r2,zero,821c8a0 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 821c9f0:	e0bff817 	ldw	r2,-32(fp)
 821c9f4:	1004d43a 	srli	r2,r2,16
 821c9f8:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 821c9fc:	00002606 	br	821ca98 <altera_avalon_jtag_uart_irq+0x220>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 821ca00:	e0bff717 	ldw	r2,-36(fp)
 821ca04:	e0fff617 	ldw	r3,-40(fp)
 821ca08:	18c01017 	ldw	r3,64(r3)
 821ca0c:	e13ff617 	ldw	r4,-40(fp)
 821ca10:	20c7883a 	add	r3,r4,r3
 821ca14:	18c21104 	addi	r3,r3,2116
 821ca18:	18c00003 	ldbu	r3,0(r3)
 821ca1c:	18c03fcc 	andi	r3,r3,255
 821ca20:	18c0201c 	xori	r3,r3,128
 821ca24:	18ffe004 	addi	r3,r3,-128
 821ca28:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821ca2c:	e0bff617 	ldw	r2,-40(fp)
 821ca30:	10801017 	ldw	r2,64(r2)
 821ca34:	10800044 	addi	r2,r2,1
 821ca38:	10c1ffcc 	andi	r3,r2,2047
 821ca3c:	e0bff617 	ldw	r2,-40(fp)
 821ca40:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
 821ca44:	e0bff617 	ldw	r2,-40(fp)
 821ca48:	10800c17 	ldw	r2,48(r2)
 821ca4c:	e0bffa15 	stw	r2,-24(fp)
 821ca50:	00800084 	movi	r2,2
 821ca54:	e0bffd0d 	sth	r2,-12(fp)
 821ca58:	00800044 	movi	r2,1
 821ca5c:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 821ca60:	d0a06b43 	ldbu	r2,-32339(gp)
 821ca64:	10803fcc 	andi	r2,r2,255
 821ca68:	10000826 	beq	r2,zero,821ca8c <altera_avalon_jtag_uart_irq+0x214>
  {
    OSFlagPost (group, flags, opt, &err);
 821ca6c:	e0bffd0b 	ldhu	r2,-12(fp)
 821ca70:	e0fffd83 	ldbu	r3,-10(fp)
 821ca74:	e13ffe04 	addi	r4,fp,-8
 821ca78:	200f883a 	mov	r7,r4
 821ca7c:	180d883a 	mov	r6,r3
 821ca80:	100b883a 	mov	r5,r2
 821ca84:	e13ffa17 	ldw	r4,-24(fp)
 821ca88:	8217be80 	call	8217be8 <OSFlagPost>

        space--;
 821ca8c:	e0bff517 	ldw	r2,-44(fp)
 821ca90:	10bfffc4 	addi	r2,r2,-1
 821ca94:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 821ca98:	e0bff517 	ldw	r2,-44(fp)
 821ca9c:	10000526 	beq	r2,zero,821cab4 <altera_avalon_jtag_uart_irq+0x23c>
 821caa0:	e0bff617 	ldw	r2,-40(fp)
 821caa4:	10c01017 	ldw	r3,64(r2)
 821caa8:	e0bff617 	ldw	r2,-40(fp)
 821caac:	10800f17 	ldw	r2,60(r2)
 821cab0:	18bfd31e 	bne	r3,r2,821ca00 <altera_avalon_jtag_uart_irq+0x188>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 821cab4:	e0bff517 	ldw	r2,-44(fp)
 821cab8:	103f7926 	beq	r2,zero,821c8a0 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 821cabc:	e0bff617 	ldw	r2,-40(fp)
 821cac0:	10c00817 	ldw	r3,32(r2)
 821cac4:	00bfff44 	movi	r2,-3
 821cac8:	1886703a 	and	r3,r3,r2
 821cacc:	e0bff617 	ldw	r2,-40(fp)
 821cad0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 821cad4:	e0bff617 	ldw	r2,-40(fp)
 821cad8:	10800017 	ldw	r2,0(r2)
 821cadc:	10800104 	addi	r2,r2,4
 821cae0:	1007883a 	mov	r3,r2
 821cae4:	e0bff617 	ldw	r2,-40(fp)
 821cae8:	10800817 	ldw	r2,32(r2)
 821caec:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 821caf0:	e0bff717 	ldw	r2,-36(fp)
 821caf4:	10800104 	addi	r2,r2,4
 821caf8:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 821cafc:	003f6806 	br	821c8a0 <altera_avalon_jtag_uart_irq+0x28>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 821cb00:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 821cb04:	0001883a 	nop
 821cb08:	e037883a 	mov	sp,fp
 821cb0c:	dfc00117 	ldw	ra,4(sp)
 821cb10:	df000017 	ldw	fp,0(sp)
 821cb14:	dec00204 	addi	sp,sp,8
 821cb18:	f800283a 	ret

0821cb1c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 821cb1c:	defff904 	addi	sp,sp,-28
 821cb20:	dfc00615 	stw	ra,24(sp)
 821cb24:	df000515 	stw	fp,20(sp)
 821cb28:	df000504 	addi	fp,sp,20
 821cb2c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 821cb30:	e0bfff17 	ldw	r2,-4(fp)
 821cb34:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 821cb38:	e0bffb17 	ldw	r2,-20(fp)
 821cb3c:	10800017 	ldw	r2,0(r2)
 821cb40:	10800104 	addi	r2,r2,4
 821cb44:	10800037 	ldwio	r2,0(r2)
 821cb48:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 821cb4c:	e0bffc17 	ldw	r2,-16(fp)
 821cb50:	1081000c 	andi	r2,r2,1024
 821cb54:	10000b26 	beq	r2,zero,821cb84 <altera_avalon_jtag_uart_timeout+0x68>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 821cb58:	e0bffb17 	ldw	r2,-20(fp)
 821cb5c:	10800017 	ldw	r2,0(r2)
 821cb60:	10800104 	addi	r2,r2,4
 821cb64:	1007883a 	mov	r3,r2
 821cb68:	e0bffb17 	ldw	r2,-20(fp)
 821cb6c:	10800817 	ldw	r2,32(r2)
 821cb70:	10810014 	ori	r2,r2,1024
 821cb74:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 821cb78:	e0bffb17 	ldw	r2,-20(fp)
 821cb7c:	10000915 	stw	zero,36(r2)
 821cb80:	00002106 	br	821cc08 <altera_avalon_jtag_uart_timeout+0xec>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 821cb84:	e0bffb17 	ldw	r2,-20(fp)
 821cb88:	10c00917 	ldw	r3,36(r2)
 821cb8c:	00a00034 	movhi	r2,32768
 821cb90:	10bfff04 	addi	r2,r2,-4
 821cb94:	10c01c36 	bltu	r2,r3,821cc08 <altera_avalon_jtag_uart_timeout+0xec>
    sp->host_inactive++;
 821cb98:	e0bffb17 	ldw	r2,-20(fp)
 821cb9c:	10800917 	ldw	r2,36(r2)
 821cba0:	10c00044 	addi	r3,r2,1
 821cba4:	e0bffb17 	ldw	r2,-20(fp)
 821cba8:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
 821cbac:	e0bffb17 	ldw	r2,-20(fp)
 821cbb0:	10c00917 	ldw	r3,36(r2)
 821cbb4:	e0bffb17 	ldw	r2,-20(fp)
 821cbb8:	10800117 	ldw	r2,4(r2)
 821cbbc:	18801236 	bltu	r3,r2,821cc08 <altera_avalon_jtag_uart_timeout+0xec>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
 821cbc0:	e0bffb17 	ldw	r2,-20(fp)
 821cbc4:	10800c17 	ldw	r2,48(r2)
 821cbc8:	e0bffd15 	stw	r2,-12(fp)
 821cbcc:	00800104 	movi	r2,4
 821cbd0:	e0bffe0d 	sth	r2,-8(fp)
 821cbd4:	00800044 	movi	r2,1
 821cbd8:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 821cbdc:	d0a06b43 	ldbu	r2,-32339(gp)
 821cbe0:	10803fcc 	andi	r2,r2,255
 821cbe4:	10000826 	beq	r2,zero,821cc08 <altera_avalon_jtag_uart_timeout+0xec>
  {
    OSFlagPost (group, flags, opt, &err);
 821cbe8:	e0bffe0b 	ldhu	r2,-8(fp)
 821cbec:	e0fffe83 	ldbu	r3,-6(fp)
 821cbf0:	e13ffec4 	addi	r4,fp,-5
 821cbf4:	200f883a 	mov	r7,r4
 821cbf8:	180d883a 	mov	r6,r3
 821cbfc:	100b883a 	mov	r5,r2
 821cc00:	e13ffd17 	ldw	r4,-12(fp)
 821cc04:	8217be80 	call	8217be8 <OSFlagPost>
 821cc08:	d0a0b817 	ldw	r2,-32032(gp)
    }
  }

  return alt_ticks_per_second();
}
 821cc0c:	e037883a 	mov	sp,fp
 821cc10:	dfc00117 	ldw	ra,4(sp)
 821cc14:	df000017 	ldw	fp,0(sp)
 821cc18:	dec00204 	addi	sp,sp,8
 821cc1c:	f800283a 	ret

0821cc20 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 821cc20:	defffd04 	addi	sp,sp,-12
 821cc24:	df000215 	stw	fp,8(sp)
 821cc28:	df000204 	addi	fp,sp,8
 821cc2c:	e13ffe15 	stw	r4,-8(fp)
 821cc30:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 821cc34:	00000506 	br	821cc4c <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 821cc38:	e0bfff17 	ldw	r2,-4(fp)
 821cc3c:	1090000c 	andi	r2,r2,16384
 821cc40:	10000226 	beq	r2,zero,821cc4c <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 821cc44:	00bffd44 	movi	r2,-11
 821cc48:	00000b06 	br	821cc78 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 821cc4c:	e0bffe17 	ldw	r2,-8(fp)
 821cc50:	10c01017 	ldw	r3,64(r2)
 821cc54:	e0bffe17 	ldw	r2,-8(fp)
 821cc58:	10800f17 	ldw	r2,60(r2)
 821cc5c:	18800526 	beq	r3,r2,821cc74 <altera_avalon_jtag_uart_close+0x54>
 821cc60:	e0bffe17 	ldw	r2,-8(fp)
 821cc64:	10c00917 	ldw	r3,36(r2)
 821cc68:	e0bffe17 	ldw	r2,-8(fp)
 821cc6c:	10800117 	ldw	r2,4(r2)
 821cc70:	18bff136 	bltu	r3,r2,821cc38 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 821cc74:	0005883a 	mov	r2,zero
}
 821cc78:	e037883a 	mov	sp,fp
 821cc7c:	df000017 	ldw	fp,0(sp)
 821cc80:	dec00104 	addi	sp,sp,4
 821cc84:	f800283a 	ret

0821cc88 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 821cc88:	defffa04 	addi	sp,sp,-24
 821cc8c:	df000515 	stw	fp,20(sp)
 821cc90:	df000504 	addi	fp,sp,20
 821cc94:	e13ffd15 	stw	r4,-12(fp)
 821cc98:	e17ffe15 	stw	r5,-8(fp)
 821cc9c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 821cca0:	00bff9c4 	movi	r2,-25
 821cca4:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 821cca8:	e0bffe17 	ldw	r2,-8(fp)
 821ccac:	10da8060 	cmpeqi	r3,r2,27137
 821ccb0:	1800031e 	bne	r3,zero,821ccc0 <altera_avalon_jtag_uart_ioctl+0x38>
 821ccb4:	109a80a0 	cmpeqi	r2,r2,27138
 821ccb8:	1000181e 	bne	r2,zero,821cd1c <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 821ccbc:	00002906 	br	821cd64 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 821ccc0:	e0bffd17 	ldw	r2,-12(fp)
 821ccc4:	10c00117 	ldw	r3,4(r2)
 821ccc8:	00a00034 	movhi	r2,32768
 821cccc:	10bfffc4 	addi	r2,r2,-1
 821ccd0:	18802126 	beq	r3,r2,821cd58 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 821ccd4:	e0bfff17 	ldw	r2,-4(fp)
 821ccd8:	10800017 	ldw	r2,0(r2)
 821ccdc:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 821cce0:	e0bffc17 	ldw	r2,-16(fp)
 821cce4:	10800090 	cmplti	r2,r2,2
 821cce8:	1000061e 	bne	r2,zero,821cd04 <altera_avalon_jtag_uart_ioctl+0x7c>
 821ccec:	e0fffc17 	ldw	r3,-16(fp)
 821ccf0:	00a00034 	movhi	r2,32768
 821ccf4:	10bfffc4 	addi	r2,r2,-1
 821ccf8:	18800226 	beq	r3,r2,821cd04 <altera_avalon_jtag_uart_ioctl+0x7c>
 821ccfc:	e0bffc17 	ldw	r2,-16(fp)
 821cd00:	00000206 	br	821cd0c <altera_avalon_jtag_uart_ioctl+0x84>
 821cd04:	00a00034 	movhi	r2,32768
 821cd08:	10bfff84 	addi	r2,r2,-2
 821cd0c:	e0fffd17 	ldw	r3,-12(fp)
 821cd10:	18800115 	stw	r2,4(r3)
      rc = 0;
 821cd14:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 821cd18:	00000f06 	br	821cd58 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 821cd1c:	e0bffd17 	ldw	r2,-12(fp)
 821cd20:	10c00117 	ldw	r3,4(r2)
 821cd24:	00a00034 	movhi	r2,32768
 821cd28:	10bfffc4 	addi	r2,r2,-1
 821cd2c:	18800c26 	beq	r3,r2,821cd60 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 821cd30:	e0bffd17 	ldw	r2,-12(fp)
 821cd34:	10c00917 	ldw	r3,36(r2)
 821cd38:	e0bffd17 	ldw	r2,-12(fp)
 821cd3c:	10800117 	ldw	r2,4(r2)
 821cd40:	1885803a 	cmpltu	r2,r3,r2
 821cd44:	10c03fcc 	andi	r3,r2,255
 821cd48:	e0bfff17 	ldw	r2,-4(fp)
 821cd4c:	10c00015 	stw	r3,0(r2)
      rc = 0;
 821cd50:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 821cd54:	00000206 	br	821cd60 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 821cd58:	0001883a 	nop
 821cd5c:	00000106 	br	821cd64 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 821cd60:	0001883a 	nop

  default:
    break;
  }

  return rc;
 821cd64:	e0bffb17 	ldw	r2,-20(fp)
}
 821cd68:	e037883a 	mov	sp,fp
 821cd6c:	df000017 	ldw	fp,0(sp)
 821cd70:	dec00104 	addi	sp,sp,4
 821cd74:	f800283a 	ret

0821cd78 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 821cd78:	deffed04 	addi	sp,sp,-76
 821cd7c:	dfc01215 	stw	ra,72(sp)
 821cd80:	df001115 	stw	fp,68(sp)
 821cd84:	df001104 	addi	fp,sp,68
 821cd88:	e13ffc15 	stw	r4,-16(fp)
 821cd8c:	e17ffd15 	stw	r5,-12(fp)
 821cd90:	e1bffe15 	stw	r6,-8(fp)
 821cd94:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 821cd98:	e0bffd17 	ldw	r2,-12(fp)
 821cd9c:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 821cda0:	e0bffc17 	ldw	r2,-16(fp)
 821cda4:	10800a17 	ldw	r2,40(r2)
 821cda8:	e0bff815 	stw	r2,-32(fp)
 821cdac:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 821cdb0:	e0bff90b 	ldhu	r2,-28(fp)
 821cdb4:	e0fffb04 	addi	r3,fp,-20
 821cdb8:	180d883a 	mov	r6,r3
 821cdbc:	100b883a 	mov	r5,r2
 821cdc0:	e13ff817 	ldw	r4,-32(fp)
 821cdc4:	821a0380 	call	821a038 <OSSemPend>

  while (space > 0)
 821cdc8:	00006106 	br	821cf50 <altera_avalon_jtag_uart_read+0x1d8>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 821cdcc:	e0bffc17 	ldw	r2,-16(fp)
 821cdd0:	10800d17 	ldw	r2,52(r2)
 821cdd4:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
 821cdd8:	e0bffc17 	ldw	r2,-16(fp)
 821cddc:	10800e17 	ldw	r2,56(r2)
 821cde0:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
 821cde4:	e0fff317 	ldw	r3,-52(fp)
 821cde8:	e0bff417 	ldw	r2,-48(fp)
 821cdec:	18800536 	bltu	r3,r2,821ce04 <altera_avalon_jtag_uart_read+0x8c>
        n = in - out;
 821cdf0:	e0fff317 	ldw	r3,-52(fp)
 821cdf4:	e0bff417 	ldw	r2,-48(fp)
 821cdf8:	1885c83a 	sub	r2,r3,r2
 821cdfc:	e0bff115 	stw	r2,-60(fp)
 821ce00:	00000406 	br	821ce14 <altera_avalon_jtag_uart_read+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 821ce04:	00c20004 	movi	r3,2048
 821ce08:	e0bff417 	ldw	r2,-48(fp)
 821ce0c:	1885c83a 	sub	r2,r3,r2
 821ce10:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
 821ce14:	e0bff117 	ldw	r2,-60(fp)
 821ce18:	10001e26 	beq	r2,zero,821ce94 <altera_avalon_jtag_uart_read+0x11c>
        break; /* No more data available */

      if (n > space)
 821ce1c:	e0fffe17 	ldw	r3,-8(fp)
 821ce20:	e0bff117 	ldw	r2,-60(fp)
 821ce24:	1880022e 	bgeu	r3,r2,821ce30 <altera_avalon_jtag_uart_read+0xb8>
        n = space;
 821ce28:	e0bffe17 	ldw	r2,-8(fp)
 821ce2c:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 821ce30:	e0bffc17 	ldw	r2,-16(fp)
 821ce34:	10c01104 	addi	r3,r2,68
 821ce38:	e0bff417 	ldw	r2,-48(fp)
 821ce3c:	1885883a 	add	r2,r3,r2
 821ce40:	e1bff117 	ldw	r6,-60(fp)
 821ce44:	100b883a 	mov	r5,r2
 821ce48:	e13ff017 	ldw	r4,-64(fp)
 821ce4c:	8202e8c0 	call	8202e8c <memcpy>
      ptr   += n;
 821ce50:	e0fff017 	ldw	r3,-64(fp)
 821ce54:	e0bff117 	ldw	r2,-60(fp)
 821ce58:	1885883a 	add	r2,r3,r2
 821ce5c:	e0bff015 	stw	r2,-64(fp)
      space -= n;
 821ce60:	e0fffe17 	ldw	r3,-8(fp)
 821ce64:	e0bff117 	ldw	r2,-60(fp)
 821ce68:	1885c83a 	sub	r2,r3,r2
 821ce6c:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821ce70:	e0fff417 	ldw	r3,-48(fp)
 821ce74:	e0bff117 	ldw	r2,-60(fp)
 821ce78:	1885883a 	add	r2,r3,r2
 821ce7c:	10c1ffcc 	andi	r3,r2,2047
 821ce80:	e0bffc17 	ldw	r2,-16(fp)
 821ce84:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
 821ce88:	e0bffe17 	ldw	r2,-8(fp)
 821ce8c:	00bfcf16 	blt	zero,r2,821cdcc <altera_avalon_jtag_uart_read+0x54>
 821ce90:	00000106 	br	821ce98 <altera_avalon_jtag_uart_read+0x120>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 821ce94:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 821ce98:	e0fff017 	ldw	r3,-64(fp)
 821ce9c:	e0bffd17 	ldw	r2,-12(fp)
 821cea0:	18802e1e 	bne	r3,r2,821cf5c <altera_avalon_jtag_uart_read+0x1e4>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 821cea4:	e0bfff17 	ldw	r2,-4(fp)
 821cea8:	1090000c 	andi	r2,r2,16384
 821ceac:	10002d1e 	bne	r2,zero,821cf64 <altera_avalon_jtag_uart_read+0x1ec>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
 821ceb0:	d0a06b43 	ldbu	r2,-32339(gp)
 821ceb4:	10803fcc 	andi	r2,r2,255
 821ceb8:	10800058 	cmpnei	r2,r2,1
 821cebc:	1000161e 	bne	r2,zero,821cf18 <altera_avalon_jtag_uart_read+0x1a0>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
 821cec0:	e0bffc17 	ldw	r2,-16(fp)
 821cec4:	10800c17 	ldw	r2,48(r2)
 821cec8:	e0bff215 	stw	r2,-56(fp)
 821cecc:	00800144 	movi	r2,5
 821ced0:	e0bff98d 	sth	r2,-26(fp)
 821ced4:	00bfe0c4 	movi	r2,-125
 821ced8:	e0bffa05 	stb	r2,-24(fp)
 821cedc:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 821cee0:	d0a06b43 	ldbu	r2,-32339(gp)
 821cee4:	10803fcc 	andi	r2,r2,255
 821cee8:	10001526 	beq	r2,zero,821cf40 <altera_avalon_jtag_uart_read+0x1c8>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 821ceec:	e0fff98b 	ldhu	r3,-26(fp)
 821cef0:	e13ffa03 	ldbu	r4,-24(fp)
 821cef4:	e17ffa8b 	ldhu	r5,-22(fp)
 821cef8:	e0bffb44 	addi	r2,fp,-19
 821cefc:	d8800015 	stw	r2,0(sp)
 821cf00:	280f883a 	mov	r7,r5
 821cf04:	200d883a 	mov	r6,r4
 821cf08:	180b883a 	mov	r5,r3
 821cf0c:	e13ff217 	ldw	r4,-56(fp)
 821cf10:	82175d00 	call	82175d0 <OSFlagPend>
 821cf14:	00000a06 	br	821cf40 <altera_avalon_jtag_uart_read+0x1c8>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 821cf18:	0001883a 	nop
 821cf1c:	e0bffc17 	ldw	r2,-16(fp)
 821cf20:	10c00d17 	ldw	r3,52(r2)
 821cf24:	e0bff317 	ldw	r2,-52(fp)
 821cf28:	1880051e 	bne	r3,r2,821cf40 <altera_avalon_jtag_uart_read+0x1c8>
 821cf2c:	e0bffc17 	ldw	r2,-16(fp)
 821cf30:	10c00917 	ldw	r3,36(r2)
 821cf34:	e0bffc17 	ldw	r2,-16(fp)
 821cf38:	10800117 	ldw	r2,4(r2)
 821cf3c:	18bff736 	bltu	r3,r2,821cf1c <altera_avalon_jtag_uart_read+0x1a4>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 821cf40:	e0bffc17 	ldw	r2,-16(fp)
 821cf44:	10c00d17 	ldw	r3,52(r2)
 821cf48:	e0bff317 	ldw	r2,-52(fp)
 821cf4c:	18800726 	beq	r3,r2,821cf6c <altera_avalon_jtag_uart_read+0x1f4>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 821cf50:	e0bffe17 	ldw	r2,-8(fp)
 821cf54:	00bf9d16 	blt	zero,r2,821cdcc <altera_avalon_jtag_uart_read+0x54>
 821cf58:	00000506 	br	821cf70 <altera_avalon_jtag_uart_read+0x1f8>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 821cf5c:	0001883a 	nop
 821cf60:	00000306 	br	821cf70 <altera_avalon_jtag_uart_read+0x1f8>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 821cf64:	0001883a 	nop
 821cf68:	00000106 	br	821cf70 <altera_avalon_jtag_uart_read+0x1f8>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 821cf6c:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 821cf70:	e0bffc17 	ldw	r2,-16(fp)
 821cf74:	10800a17 	ldw	r2,40(r2)
 821cf78:	1009883a 	mov	r4,r2
 821cf7c:	821a3b00 	call	821a3b0 <OSSemPost>

  if (ptr != buffer)
 821cf80:	e0fff017 	ldw	r3,-64(fp)
 821cf84:	e0bffd17 	ldw	r2,-12(fp)
 821cf88:	18801826 	beq	r3,r2,821cfec <altera_avalon_jtag_uart_read+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821cf8c:	0005303a 	rdctl	r2,status
 821cf90:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821cf94:	e0fff717 	ldw	r3,-36(fp)
 821cf98:	00bfff84 	movi	r2,-2
 821cf9c:	1884703a 	and	r2,r3,r2
 821cfa0:	1001703a 	wrctl	status,r2
  
  return context;
 821cfa4:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 821cfa8:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 821cfac:	e0bffc17 	ldw	r2,-16(fp)
 821cfb0:	10800817 	ldw	r2,32(r2)
 821cfb4:	10c00054 	ori	r3,r2,1
 821cfb8:	e0bffc17 	ldw	r2,-16(fp)
 821cfbc:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 821cfc0:	e0bffc17 	ldw	r2,-16(fp)
 821cfc4:	10800017 	ldw	r2,0(r2)
 821cfc8:	10800104 	addi	r2,r2,4
 821cfcc:	1007883a 	mov	r3,r2
 821cfd0:	e0bffc17 	ldw	r2,-16(fp)
 821cfd4:	10800817 	ldw	r2,32(r2)
 821cfd8:	18800035 	stwio	r2,0(r3)
 821cfdc:	e0bff617 	ldw	r2,-40(fp)
 821cfe0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821cfe4:	e0bff517 	ldw	r2,-44(fp)
 821cfe8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 821cfec:	e0fff017 	ldw	r3,-64(fp)
 821cff0:	e0bffd17 	ldw	r2,-12(fp)
 821cff4:	18800426 	beq	r3,r2,821d008 <altera_avalon_jtag_uart_read+0x290>
    return ptr - buffer;
 821cff8:	e0fff017 	ldw	r3,-64(fp)
 821cffc:	e0bffd17 	ldw	r2,-12(fp)
 821d000:	1885c83a 	sub	r2,r3,r2
 821d004:	00000606 	br	821d020 <altera_avalon_jtag_uart_read+0x2a8>
  else if (flags & O_NONBLOCK)
 821d008:	e0bfff17 	ldw	r2,-4(fp)
 821d00c:	1090000c 	andi	r2,r2,16384
 821d010:	10000226 	beq	r2,zero,821d01c <altera_avalon_jtag_uart_read+0x2a4>
    return -EWOULDBLOCK;
 821d014:	00bffd44 	movi	r2,-11
 821d018:	00000106 	br	821d020 <altera_avalon_jtag_uart_read+0x2a8>
  else
    return -EIO;
 821d01c:	00bffec4 	movi	r2,-5
}
 821d020:	e037883a 	mov	sp,fp
 821d024:	dfc00117 	ldw	ra,4(sp)
 821d028:	df000017 	ldw	fp,0(sp)
 821d02c:	dec00204 	addi	sp,sp,8
 821d030:	f800283a 	ret

0821d034 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 821d034:	deffed04 	addi	sp,sp,-76
 821d038:	dfc01215 	stw	ra,72(sp)
 821d03c:	df001115 	stw	fp,68(sp)
 821d040:	df001104 	addi	fp,sp,68
 821d044:	e13ffc15 	stw	r4,-16(fp)
 821d048:	e17ffd15 	stw	r5,-12(fp)
 821d04c:	e1bffe15 	stw	r6,-8(fp)
 821d050:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 821d054:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 821d058:	e0bffd17 	ldw	r2,-12(fp)
 821d05c:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 821d060:	e0bffc17 	ldw	r2,-16(fp)
 821d064:	10800b17 	ldw	r2,44(r2)
 821d068:	e0bff815 	stw	r2,-32(fp)
 821d06c:	e03ff90d 	sth	zero,-28(fp)
 821d070:	e0bff90b 	ldhu	r2,-28(fp)
 821d074:	e0fffb44 	addi	r3,fp,-19
 821d078:	180d883a 	mov	r6,r3
 821d07c:	100b883a 	mov	r5,r2
 821d080:	e13ff817 	ldw	r4,-32(fp)
 821d084:	821a0380 	call	821a038 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 821d088:	00003706 	br	821d168 <altera_avalon_jtag_uart_write+0x134>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 821d08c:	e0bffc17 	ldw	r2,-16(fp)
 821d090:	10800f17 	ldw	r2,60(r2)
 821d094:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
 821d098:	e0bffc17 	ldw	r2,-16(fp)
 821d09c:	10801017 	ldw	r2,64(r2)
 821d0a0:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
 821d0a4:	e0fff417 	ldw	r3,-48(fp)
 821d0a8:	e0bff017 	ldw	r2,-64(fp)
 821d0ac:	1880062e 	bgeu	r3,r2,821d0c8 <altera_avalon_jtag_uart_write+0x94>
        n = out - 1 - in;
 821d0b0:	e0fff017 	ldw	r3,-64(fp)
 821d0b4:	e0bff417 	ldw	r2,-48(fp)
 821d0b8:	1885c83a 	sub	r2,r3,r2
 821d0bc:	10bfffc4 	addi	r2,r2,-1
 821d0c0:	e0bff115 	stw	r2,-60(fp)
 821d0c4:	00000b06 	br	821d0f4 <altera_avalon_jtag_uart_write+0xc0>
      else if (out > 0)
 821d0c8:	e0bff017 	ldw	r2,-64(fp)
 821d0cc:	10000526 	beq	r2,zero,821d0e4 <altera_avalon_jtag_uart_write+0xb0>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 821d0d0:	00c20004 	movi	r3,2048
 821d0d4:	e0bff417 	ldw	r2,-48(fp)
 821d0d8:	1885c83a 	sub	r2,r3,r2
 821d0dc:	e0bff115 	stw	r2,-60(fp)
 821d0e0:	00000406 	br	821d0f4 <altera_avalon_jtag_uart_write+0xc0>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 821d0e4:	00c1ffc4 	movi	r3,2047
 821d0e8:	e0bff417 	ldw	r2,-48(fp)
 821d0ec:	1885c83a 	sub	r2,r3,r2
 821d0f0:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
 821d0f4:	e0bff117 	ldw	r2,-60(fp)
 821d0f8:	10001e26 	beq	r2,zero,821d174 <altera_avalon_jtag_uart_write+0x140>
        break;

      if (n > count)
 821d0fc:	e0fffe17 	ldw	r3,-8(fp)
 821d100:	e0bff117 	ldw	r2,-60(fp)
 821d104:	1880022e 	bgeu	r3,r2,821d110 <altera_avalon_jtag_uart_write+0xdc>
        n = count;
 821d108:	e0bffe17 	ldw	r2,-8(fp)
 821d10c:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 821d110:	e0bffc17 	ldw	r2,-16(fp)
 821d114:	10c21104 	addi	r3,r2,2116
 821d118:	e0bff417 	ldw	r2,-48(fp)
 821d11c:	1885883a 	add	r2,r3,r2
 821d120:	e1bff117 	ldw	r6,-60(fp)
 821d124:	e17ffd17 	ldw	r5,-12(fp)
 821d128:	1009883a 	mov	r4,r2
 821d12c:	8202e8c0 	call	8202e8c <memcpy>
      ptr   += n;
 821d130:	e0fffd17 	ldw	r3,-12(fp)
 821d134:	e0bff117 	ldw	r2,-60(fp)
 821d138:	1885883a 	add	r2,r3,r2
 821d13c:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 821d140:	e0fffe17 	ldw	r3,-8(fp)
 821d144:	e0bff117 	ldw	r2,-60(fp)
 821d148:	1885c83a 	sub	r2,r3,r2
 821d14c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 821d150:	e0fff417 	ldw	r3,-48(fp)
 821d154:	e0bff117 	ldw	r2,-60(fp)
 821d158:	1885883a 	add	r2,r3,r2
 821d15c:	10c1ffcc 	andi	r3,r2,2047
 821d160:	e0bffc17 	ldw	r2,-16(fp)
 821d164:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 821d168:	e0bffe17 	ldw	r2,-8(fp)
 821d16c:	00bfc716 	blt	zero,r2,821d08c <altera_avalon_jtag_uart_write+0x58>
 821d170:	00000106 	br	821d178 <altera_avalon_jtag_uart_write+0x144>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 821d174:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821d178:	0005303a 	rdctl	r2,status
 821d17c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821d180:	e0fff717 	ldw	r3,-36(fp)
 821d184:	00bfff84 	movi	r2,-2
 821d188:	1884703a 	and	r2,r3,r2
 821d18c:	1001703a 	wrctl	status,r2
  
  return context;
 821d190:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 821d194:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 821d198:	e0bffc17 	ldw	r2,-16(fp)
 821d19c:	10800817 	ldw	r2,32(r2)
 821d1a0:	10c00094 	ori	r3,r2,2
 821d1a4:	e0bffc17 	ldw	r2,-16(fp)
 821d1a8:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 821d1ac:	e0bffc17 	ldw	r2,-16(fp)
 821d1b0:	10800017 	ldw	r2,0(r2)
 821d1b4:	10800104 	addi	r2,r2,4
 821d1b8:	1007883a 	mov	r3,r2
 821d1bc:	e0bffc17 	ldw	r2,-16(fp)
 821d1c0:	10800817 	ldw	r2,32(r2)
 821d1c4:	18800035 	stwio	r2,0(r3)
 821d1c8:	e0bff617 	ldw	r2,-40(fp)
 821d1cc:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821d1d0:	e0bff317 	ldw	r2,-52(fp)
 821d1d4:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 821d1d8:	e0bffe17 	ldw	r2,-8(fp)
 821d1dc:	00802a0e 	bge	zero,r2,821d288 <altera_avalon_jtag_uart_write+0x254>
    {
      if (flags & O_NONBLOCK)
 821d1e0:	e0bfff17 	ldw	r2,-4(fp)
 821d1e4:	1090000c 	andi	r2,r2,16384
 821d1e8:	10002a1e 	bne	r2,zero,821d294 <altera_avalon_jtag_uart_write+0x260>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
 821d1ec:	d0a06b43 	ldbu	r2,-32339(gp)
 821d1f0:	10803fcc 	andi	r2,r2,255
 821d1f4:	10800058 	cmpnei	r2,r2,1
 821d1f8:	1000161e 	bne	r2,zero,821d254 <altera_avalon_jtag_uart_write+0x220>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
 821d1fc:	e0bffc17 	ldw	r2,-16(fp)
 821d200:	10800c17 	ldw	r2,48(r2)
 821d204:	e0bff515 	stw	r2,-44(fp)
 821d208:	00800184 	movi	r2,6
 821d20c:	e0bff98d 	sth	r2,-26(fp)
 821d210:	00bfe0c4 	movi	r2,-125
 821d214:	e0bffa05 	stb	r2,-24(fp)
 821d218:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 821d21c:	d0a06b43 	ldbu	r2,-32339(gp)
 821d220:	10803fcc 	andi	r2,r2,255
 821d224:	10001526 	beq	r2,zero,821d27c <altera_avalon_jtag_uart_write+0x248>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 821d228:	e0fff98b 	ldhu	r3,-26(fp)
 821d22c:	e13ffa03 	ldbu	r4,-24(fp)
 821d230:	e17ffa8b 	ldhu	r5,-22(fp)
 821d234:	e0bffb04 	addi	r2,fp,-20
 821d238:	d8800015 	stw	r2,0(sp)
 821d23c:	280f883a 	mov	r7,r5
 821d240:	200d883a 	mov	r6,r4
 821d244:	180b883a 	mov	r5,r3
 821d248:	e13ff517 	ldw	r4,-44(fp)
 821d24c:	82175d00 	call	82175d0 <OSFlagPend>
 821d250:	00000a06 	br	821d27c <altera_avalon_jtag_uart_write+0x248>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 821d254:	0001883a 	nop
 821d258:	e0bffc17 	ldw	r2,-16(fp)
 821d25c:	10c01017 	ldw	r3,64(r2)
 821d260:	e0bff017 	ldw	r2,-64(fp)
 821d264:	1880051e 	bne	r3,r2,821d27c <altera_avalon_jtag_uart_write+0x248>
 821d268:	e0bffc17 	ldw	r2,-16(fp)
 821d26c:	10c00917 	ldw	r3,36(r2)
 821d270:	e0bffc17 	ldw	r2,-16(fp)
 821d274:	10800117 	ldw	r2,4(r2)
 821d278:	18bff736 	bltu	r3,r2,821d258 <altera_avalon_jtag_uart_write+0x224>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 821d27c:	e0bffc17 	ldw	r2,-16(fp)
 821d280:	10800917 	ldw	r2,36(r2)
 821d284:	1000051e 	bne	r2,zero,821d29c <altera_avalon_jtag_uart_write+0x268>
         break;
    }
  }
  while (count > 0);
 821d288:	e0bffe17 	ldw	r2,-8(fp)
 821d28c:	00bfb616 	blt	zero,r2,821d168 <altera_avalon_jtag_uart_write+0x134>
 821d290:	00000306 	br	821d2a0 <altera_avalon_jtag_uart_write+0x26c>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 821d294:	0001883a 	nop
 821d298:	00000106 	br	821d2a0 <altera_avalon_jtag_uart_write+0x26c>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 821d29c:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 821d2a0:	e0bffc17 	ldw	r2,-16(fp)
 821d2a4:	10800b17 	ldw	r2,44(r2)
 821d2a8:	1009883a 	mov	r4,r2
 821d2ac:	821a3b00 	call	821a3b0 <OSSemPost>

  if (ptr != start)
 821d2b0:	e0fffd17 	ldw	r3,-12(fp)
 821d2b4:	e0bff217 	ldw	r2,-56(fp)
 821d2b8:	18800426 	beq	r3,r2,821d2cc <altera_avalon_jtag_uart_write+0x298>
    return ptr - start;
 821d2bc:	e0fffd17 	ldw	r3,-12(fp)
 821d2c0:	e0bff217 	ldw	r2,-56(fp)
 821d2c4:	1885c83a 	sub	r2,r3,r2
 821d2c8:	00000606 	br	821d2e4 <altera_avalon_jtag_uart_write+0x2b0>
  else if (flags & O_NONBLOCK)
 821d2cc:	e0bfff17 	ldw	r2,-4(fp)
 821d2d0:	1090000c 	andi	r2,r2,16384
 821d2d4:	10000226 	beq	r2,zero,821d2e0 <altera_avalon_jtag_uart_write+0x2ac>
    return -EWOULDBLOCK;
 821d2d8:	00bffd44 	movi	r2,-11
 821d2dc:	00000106 	br	821d2e4 <altera_avalon_jtag_uart_write+0x2b0>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 821d2e0:	00bffec4 	movi	r2,-5
}
 821d2e4:	e037883a 	mov	sp,fp
 821d2e8:	dfc00117 	ldw	ra,4(sp)
 821d2ec:	df000017 	ldw	fp,0(sp)
 821d2f0:	dec00204 	addi	sp,sp,8
 821d2f4:	f800283a 	ret

0821d2f8 <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
 821d2f8:	defffa04 	addi	sp,sp,-24
 821d2fc:	dfc00515 	stw	ra,20(sp)
 821d300:	df000415 	stw	fp,16(sp)
 821d304:	df000404 	addi	fp,sp,16
 821d308:	e13ffe15 	stw	r4,-8(fp)
 821d30c:	2805883a 	mov	r2,r5
 821d310:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
 821d314:	e0bffe17 	ldw	r2,-8(fp)
 821d318:	10800017 	ldw	r2,0(r2)
 821d31c:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 821d320:	008003f4 	movhi	r2,15
 821d324:	10909004 	addi	r2,r2,16960
 821d328:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 821d32c:	e0bffe17 	ldw	r2,-8(fp)
 821d330:	10800803 	ldbu	r2,32(r2)
 821d334:	10803fcc 	andi	r2,r2,255
 821d338:	1080201c 	xori	r2,r2,128
 821d33c:	10bfe004 	addi	r2,r2,-128
 821d340:	1000151e 	bne	r2,zero,821d398 <lcd_write_command+0xa0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d344:	00000906 	br	821d36c <lcd_write_command+0x74>
    if (--i == 0)
 821d348:	e0bffc17 	ldw	r2,-16(fp)
 821d34c:	10bfffc4 	addi	r2,r2,-1
 821d350:	e0bffc15 	stw	r2,-16(fp)
 821d354:	e0bffc17 	ldw	r2,-16(fp)
 821d358:	1000041e 	bne	r2,zero,821d36c <lcd_write_command+0x74>
    {
      sp->broken = 1;
 821d35c:	e0bffe17 	ldw	r2,-8(fp)
 821d360:	00c00044 	movi	r3,1
 821d364:	10c00805 	stb	r3,32(r2)
      return;
 821d368:	00000c06 	br	821d39c <lcd_write_command+0xa4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d36c:	e0bffd17 	ldw	r2,-12(fp)
 821d370:	10800104 	addi	r2,r2,4
 821d374:	10800037 	ldwio	r2,0(r2)
 821d378:	1080200c 	andi	r2,r2,128
 821d37c:	103ff21e 	bne	r2,zero,821d348 <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 821d380:	01001904 	movi	r4,100
 821d384:	823c8b40 	call	823c8b4 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
 821d388:	e0bffd17 	ldw	r2,-12(fp)
 821d38c:	e0ffff03 	ldbu	r3,-4(fp)
 821d390:	10c00035 	stwio	r3,0(r2)
 821d394:	00000106 	br	821d39c <lcd_write_command+0xa4>
   */
  int i = 1000000;

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;
 821d398:	0001883a 	nop
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
}
 821d39c:	e037883a 	mov	sp,fp
 821d3a0:	dfc00117 	ldw	ra,4(sp)
 821d3a4:	df000017 	ldw	fp,0(sp)
 821d3a8:	dec00204 	addi	sp,sp,8
 821d3ac:	f800283a 	ret

0821d3b0 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
 821d3b0:	defffa04 	addi	sp,sp,-24
 821d3b4:	dfc00515 	stw	ra,20(sp)
 821d3b8:	df000415 	stw	fp,16(sp)
 821d3bc:	df000404 	addi	fp,sp,16
 821d3c0:	e13ffe15 	stw	r4,-8(fp)
 821d3c4:	2805883a 	mov	r2,r5
 821d3c8:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
 821d3cc:	e0bffe17 	ldw	r2,-8(fp)
 821d3d0:	10800017 	ldw	r2,0(r2)
 821d3d4:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 821d3d8:	008003f4 	movhi	r2,15
 821d3dc:	10909004 	addi	r2,r2,16960
 821d3e0:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 821d3e4:	e0bffe17 	ldw	r2,-8(fp)
 821d3e8:	10800803 	ldbu	r2,32(r2)
 821d3ec:	10803fcc 	andi	r2,r2,255
 821d3f0:	1080201c 	xori	r2,r2,128
 821d3f4:	10bfe004 	addi	r2,r2,-128
 821d3f8:	10001d1e 	bne	r2,zero,821d470 <lcd_write_data+0xc0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d3fc:	00000906 	br	821d424 <lcd_write_data+0x74>
    if (--i == 0)
 821d400:	e0bffc17 	ldw	r2,-16(fp)
 821d404:	10bfffc4 	addi	r2,r2,-1
 821d408:	e0bffc15 	stw	r2,-16(fp)
 821d40c:	e0bffc17 	ldw	r2,-16(fp)
 821d410:	1000041e 	bne	r2,zero,821d424 <lcd_write_data+0x74>
    {
      sp->broken = 1;
 821d414:	e0bffe17 	ldw	r2,-8(fp)
 821d418:	00c00044 	movi	r3,1
 821d41c:	10c00805 	stb	r3,32(r2)
      return;
 821d420:	00001406 	br	821d474 <lcd_write_data+0xc4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 821d424:	e0bffd17 	ldw	r2,-12(fp)
 821d428:	10800104 	addi	r2,r2,4
 821d42c:	10800037 	ldwio	r2,0(r2)
 821d430:	1080200c 	andi	r2,r2,128
 821d434:	103ff21e 	bne	r2,zero,821d400 <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 821d438:	01001904 	movi	r4,100
 821d43c:	823c8b40 	call	823c8b4 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
 821d440:	e0bffd17 	ldw	r2,-12(fp)
 821d444:	10800204 	addi	r2,r2,8
 821d448:	1007883a 	mov	r3,r2
 821d44c:	e0bfff03 	ldbu	r2,-4(fp)
 821d450:	18800035 	stwio	r2,0(r3)

  sp->address++;
 821d454:	e0bffe17 	ldw	r2,-8(fp)
 821d458:	108008c3 	ldbu	r2,35(r2)
 821d45c:	10800044 	addi	r2,r2,1
 821d460:	1007883a 	mov	r3,r2
 821d464:	e0bffe17 	ldw	r2,-8(fp)
 821d468:	10c008c5 	stb	r3,35(r2)
 821d46c:	00000106 	br	821d474 <lcd_write_data+0xc4>
   */
  int i = 1000000;

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;
 821d470:	0001883a 	nop
  usleep(100);

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);

  sp->address++;
}
 821d474:	e037883a 	mov	sp,fp
 821d478:	dfc00117 	ldw	ra,4(sp)
 821d47c:	df000017 	ldw	fp,0(sp)
 821d480:	dec00204 	addi	sp,sp,8
 821d484:	f800283a 	ret

0821d488 <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
 821d488:	defffc04 	addi	sp,sp,-16
 821d48c:	dfc00315 	stw	ra,12(sp)
 821d490:	df000215 	stw	fp,8(sp)
 821d494:	df000204 	addi	fp,sp,8
 821d498:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
 821d49c:	01400044 	movi	r5,1
 821d4a0:	e13fff17 	ldw	r4,-4(fp)
 821d4a4:	821d2f80 	call	821d2f8 <lcd_write_command>

  sp->x = 0;
 821d4a8:	e0bfff17 	ldw	r2,-4(fp)
 821d4ac:	10000845 	stb	zero,33(r2)
  sp->y = 0;
 821d4b0:	e0bfff17 	ldw	r2,-4(fp)
 821d4b4:	10000885 	stb	zero,34(r2)
  sp->address = 0;
 821d4b8:	e0bfff17 	ldw	r2,-4(fp)
 821d4bc:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d4c0:	e03ffe15 	stw	zero,-8(fp)
 821d4c4:	00001b06 	br	821d534 <lcd_clear_screen+0xac>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
 821d4c8:	e0bffe17 	ldw	r2,-8(fp)
 821d4cc:	108018e4 	muli	r2,r2,99
 821d4d0:	10801004 	addi	r2,r2,64
 821d4d4:	e0ffff17 	ldw	r3,-4(fp)
 821d4d8:	1885883a 	add	r2,r3,r2
 821d4dc:	01801444 	movi	r6,81
 821d4e0:	01400804 	movi	r5,32
 821d4e4:	1009883a 	mov	r4,r2
 821d4e8:	82031300 	call	8203130 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
 821d4ec:	e0bffe17 	ldw	r2,-8(fp)
 821d4f0:	108018e4 	muli	r2,r2,99
 821d4f4:	10800c04 	addi	r2,r2,48
 821d4f8:	e0ffff17 	ldw	r3,-4(fp)
 821d4fc:	1885883a 	add	r2,r3,r2
 821d500:	01800404 	movi	r6,16
 821d504:	01400804 	movi	r5,32
 821d508:	1009883a 	mov	r4,r2
 821d50c:	82031300 	call	8203130 <memset>
    sp->line[y].width = 0;
 821d510:	e0ffff17 	ldw	r3,-4(fp)
 821d514:	e0bffe17 	ldw	r2,-8(fp)
 821d518:	108018e4 	muli	r2,r2,99
 821d51c:	1885883a 	add	r2,r3,r2
 821d520:	10802444 	addi	r2,r2,145
 821d524:	10000005 	stb	zero,0(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d528:	e0bffe17 	ldw	r2,-8(fp)
 821d52c:	10800044 	addi	r2,r2,1
 821d530:	e0bffe15 	stw	r2,-8(fp)
 821d534:	e0bffe17 	ldw	r2,-8(fp)
 821d538:	10800090 	cmplti	r2,r2,2
 821d53c:	103fe21e 	bne	r2,zero,821d4c8 <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
 821d540:	0001883a 	nop
 821d544:	e037883a 	mov	sp,fp
 821d548:	dfc00117 	ldw	ra,4(sp)
 821d54c:	df000017 	ldw	fp,0(sp)
 821d550:	dec00204 	addi	sp,sp,8
 821d554:	f800283a 	ret

0821d558 <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
 821d558:	defff704 	addi	sp,sp,-36
 821d55c:	dfc00815 	stw	ra,32(sp)
 821d560:	df000715 	stw	fp,28(sp)
 821d564:	df000704 	addi	fp,sp,28
 821d568:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
 821d56c:	e0bfff17 	ldw	r2,-4(fp)
 821d570:	10800943 	ldbu	r2,37(r2)
 821d574:	10803fcc 	andi	r2,r2,255
 821d578:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d57c:	e03ff915 	stw	zero,-28(fp)
 821d580:	00006706 	br	821d720 <lcd_repaint_screen+0x1c8>
  {
    int width  = sp->line[y].width;
 821d584:	e0ffff17 	ldw	r3,-4(fp)
 821d588:	e0bff917 	ldw	r2,-28(fp)
 821d58c:	108018e4 	muli	r2,r2,99
 821d590:	1885883a 	add	r2,r3,r2
 821d594:	10802444 	addi	r2,r2,145
 821d598:	10800003 	ldbu	r2,0(r2)
 821d59c:	10803fcc 	andi	r2,r2,255
 821d5a0:	1080201c 	xori	r2,r2,128
 821d5a4:	10bfe004 	addi	r2,r2,-128
 821d5a8:	e0bffd15 	stw	r2,-12(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
 821d5ac:	e0ffff17 	ldw	r3,-4(fp)
 821d5b0:	e0bff917 	ldw	r2,-28(fp)
 821d5b4:	108018e4 	muli	r2,r2,99
 821d5b8:	1885883a 	add	r2,r3,r2
 821d5bc:	10802484 	addi	r2,r2,146
 821d5c0:	10800003 	ldbu	r2,0(r2)
 821d5c4:	10c03fcc 	andi	r3,r2,255
 821d5c8:	e0bffc17 	ldw	r2,-16(fp)
 821d5cc:	1885383a 	mul	r2,r3,r2
 821d5d0:	1005d23a 	srai	r2,r2,8
 821d5d4:	e0bffb15 	stw	r2,-20(fp)
    if (offset >= width)
 821d5d8:	e0fffb17 	ldw	r3,-20(fp)
 821d5dc:	e0bffd17 	ldw	r2,-12(fp)
 821d5e0:	18800116 	blt	r3,r2,821d5e8 <lcd_repaint_screen+0x90>
      offset = 0;
 821d5e4:	e03ffb15 	stw	zero,-20(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 821d5e8:	e03ffa15 	stw	zero,-24(fp)
 821d5ec:	00004606 	br	821d708 <lcd_repaint_screen+0x1b0>
    {
      char c = sp->line[y].data[(x + offset) % width];
 821d5f0:	e0fffa17 	ldw	r3,-24(fp)
 821d5f4:	e0bffb17 	ldw	r2,-20(fp)
 821d5f8:	1885883a 	add	r2,r3,r2
 821d5fc:	e17ffd17 	ldw	r5,-12(fp)
 821d600:	1009883a 	mov	r4,r2
 821d604:	8202b180 	call	8202b18 <__modsi3>
 821d608:	1009883a 	mov	r4,r2
 821d60c:	e0ffff17 	ldw	r3,-4(fp)
 821d610:	e0bff917 	ldw	r2,-28(fp)
 821d614:	108018e4 	muli	r2,r2,99
 821d618:	1885883a 	add	r2,r3,r2
 821d61c:	1105883a 	add	r2,r2,r4
 821d620:	10801004 	addi	r2,r2,64
 821d624:	10800003 	ldbu	r2,0(r2)
 821d628:	e0bffe05 	stb	r2,-8(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
 821d62c:	e0ffff17 	ldw	r3,-4(fp)
 821d630:	e0bff917 	ldw	r2,-28(fp)
 821d634:	108018e4 	muli	r2,r2,99
 821d638:	1887883a 	add	r3,r3,r2
 821d63c:	e0bffa17 	ldw	r2,-24(fp)
 821d640:	1885883a 	add	r2,r3,r2
 821d644:	10800c04 	addi	r2,r2,48
 821d648:	10800003 	ldbu	r2,0(r2)
 821d64c:	10c03fcc 	andi	r3,r2,255
 821d650:	18c0201c 	xori	r3,r3,128
 821d654:	18ffe004 	addi	r3,r3,-128
 821d658:	e0bffe07 	ldb	r2,-8(fp)
 821d65c:	18802726 	beq	r3,r2,821d6fc <lcd_repaint_screen+0x1a4>
      {
        unsigned char address = x + colstart[y];
 821d660:	e0fff917 	ldw	r3,-28(fp)
 821d664:	d0a02a04 	addi	r2,gp,-32600
 821d668:	1885883a 	add	r2,r3,r2
 821d66c:	10800003 	ldbu	r2,0(r2)
 821d670:	1007883a 	mov	r3,r2
 821d674:	e0bffa17 	ldw	r2,-24(fp)
 821d678:	1885883a 	add	r2,r3,r2
 821d67c:	e0bffe45 	stb	r2,-7(fp)

        if (address != sp->address)
 821d680:	e0fffe43 	ldbu	r3,-7(fp)
 821d684:	e0bfff17 	ldw	r2,-4(fp)
 821d688:	108008c3 	ldbu	r2,35(r2)
 821d68c:	10803fcc 	andi	r2,r2,255
 821d690:	1080201c 	xori	r2,r2,128
 821d694:	10bfe004 	addi	r2,r2,-128
 821d698:	18800a26 	beq	r3,r2,821d6c4 <lcd_repaint_screen+0x16c>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
 821d69c:	e0fffe43 	ldbu	r3,-7(fp)
 821d6a0:	00bfe004 	movi	r2,-128
 821d6a4:	1884b03a 	or	r2,r3,r2
 821d6a8:	10803fcc 	andi	r2,r2,255
 821d6ac:	100b883a 	mov	r5,r2
 821d6b0:	e13fff17 	ldw	r4,-4(fp)
 821d6b4:	821d2f80 	call	821d2f8 <lcd_write_command>
          sp->address = address;
 821d6b8:	e0fffe43 	ldbu	r3,-7(fp)
 821d6bc:	e0bfff17 	ldw	r2,-4(fp)
 821d6c0:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
 821d6c4:	e0bffe03 	ldbu	r2,-8(fp)
 821d6c8:	10803fcc 	andi	r2,r2,255
 821d6cc:	100b883a 	mov	r5,r2
 821d6d0:	e13fff17 	ldw	r4,-4(fp)
 821d6d4:	821d3b00 	call	821d3b0 <lcd_write_data>
        sp->line[y].visible[x] = c;
 821d6d8:	e0ffff17 	ldw	r3,-4(fp)
 821d6dc:	e0bff917 	ldw	r2,-28(fp)
 821d6e0:	108018e4 	muli	r2,r2,99
 821d6e4:	1887883a 	add	r3,r3,r2
 821d6e8:	e0bffa17 	ldw	r2,-24(fp)
 821d6ec:	1885883a 	add	r2,r3,r2
 821d6f0:	10800c04 	addi	r2,r2,48
 821d6f4:	e0fffe03 	ldbu	r3,-8(fp)
 821d6f8:	10c00005 	stb	r3,0(r2)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 821d6fc:	e0bffa17 	ldw	r2,-24(fp)
 821d700:	10800044 	addi	r2,r2,1
 821d704:	e0bffa15 	stw	r2,-24(fp)
 821d708:	e0bffa17 	ldw	r2,-24(fp)
 821d70c:	10800410 	cmplti	r2,r2,16
 821d710:	103fb71e 	bne	r2,zero,821d5f0 <lcd_repaint_screen+0x98>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d714:	e0bff917 	ldw	r2,-28(fp)
 821d718:	10800044 	addi	r2,r2,1
 821d71c:	e0bff915 	stw	r2,-28(fp)
 821d720:	e0bff917 	ldw	r2,-28(fp)
 821d724:	10800090 	cmplti	r2,r2,2
 821d728:	103f961e 	bne	r2,zero,821d584 <lcd_repaint_screen+0x2c>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
 821d72c:	0001883a 	nop
 821d730:	e037883a 	mov	sp,fp
 821d734:	dfc00117 	ldw	ra,4(sp)
 821d738:	df000017 	ldw	fp,0(sp)
 821d73c:	dec00204 	addi	sp,sp,8
 821d740:	f800283a 	ret

0821d744 <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
 821d744:	defffc04 	addi	sp,sp,-16
 821d748:	dfc00315 	stw	ra,12(sp)
 821d74c:	df000215 	stw	fp,8(sp)
 821d750:	df000204 	addi	fp,sp,8
 821d754:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d758:	e03ffe15 	stw	zero,-8(fp)
 821d75c:	00001d06 	br	821d7d4 <lcd_scroll_up+0x90>
  {
    if (y < ALT_LCD_HEIGHT-1)
 821d760:	e0bffe17 	ldw	r2,-8(fp)
 821d764:	00800f16 	blt	zero,r2,821d7a4 <lcd_scroll_up+0x60>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
 821d768:	e0bffe17 	ldw	r2,-8(fp)
 821d76c:	108018e4 	muli	r2,r2,99
 821d770:	10801004 	addi	r2,r2,64
 821d774:	e0ffff17 	ldw	r3,-4(fp)
 821d778:	1889883a 	add	r4,r3,r2
 821d77c:	e0bffe17 	ldw	r2,-8(fp)
 821d780:	10800044 	addi	r2,r2,1
 821d784:	108018e4 	muli	r2,r2,99
 821d788:	10801004 	addi	r2,r2,64
 821d78c:	e0ffff17 	ldw	r3,-4(fp)
 821d790:	1885883a 	add	r2,r3,r2
 821d794:	01801404 	movi	r6,80
 821d798:	100b883a 	mov	r5,r2
 821d79c:	8202e8c0 	call	8202e8c <memcpy>
 821d7a0:	00000906 	br	821d7c8 <lcd_scroll_up+0x84>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
 821d7a4:	e0bffe17 	ldw	r2,-8(fp)
 821d7a8:	108018e4 	muli	r2,r2,99
 821d7ac:	10801004 	addi	r2,r2,64
 821d7b0:	e0ffff17 	ldw	r3,-4(fp)
 821d7b4:	1885883a 	add	r2,r3,r2
 821d7b8:	01801404 	movi	r6,80
 821d7bc:	01400804 	movi	r5,32
 821d7c0:	1009883a 	mov	r4,r2
 821d7c4:	82031300 	call	8203130 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821d7c8:	e0bffe17 	ldw	r2,-8(fp)
 821d7cc:	10800044 	addi	r2,r2,1
 821d7d0:	e0bffe15 	stw	r2,-8(fp)
 821d7d4:	e0bffe17 	ldw	r2,-8(fp)
 821d7d8:	10800090 	cmplti	r2,r2,2
 821d7dc:	103fe01e 	bne	r2,zero,821d760 <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
 821d7e0:	e0bfff17 	ldw	r2,-4(fp)
 821d7e4:	10800883 	ldbu	r2,34(r2)
 821d7e8:	10bfffc4 	addi	r2,r2,-1
 821d7ec:	1007883a 	mov	r3,r2
 821d7f0:	e0bfff17 	ldw	r2,-4(fp)
 821d7f4:	10c00885 	stb	r3,34(r2)
}
 821d7f8:	0001883a 	nop
 821d7fc:	e037883a 	mov	sp,fp
 821d800:	dfc00117 	ldw	ra,4(sp)
 821d804:	df000017 	ldw	fp,0(sp)
 821d808:	dec00204 	addi	sp,sp,8
 821d80c:	f800283a 	ret

0821d810 <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
 821d810:	defff904 	addi	sp,sp,-28
 821d814:	dfc00615 	stw	ra,24(sp)
 821d818:	df000515 	stw	fp,20(sp)
 821d81c:	df000504 	addi	fp,sp,20
 821d820:	e13ffe15 	stw	r4,-8(fp)
 821d824:	2805883a 	mov	r2,r5
 821d828:	e0bfff05 	stb	r2,-4(fp)
  int parm1 = 0, parm2 = 0;
 821d82c:	e03ffb15 	stw	zero,-20(fp)
 821d830:	e03ffc15 	stw	zero,-16(fp)

  if (sp->escape[0] == '[')
 821d834:	e0bffe17 	ldw	r2,-8(fp)
 821d838:	10800a03 	ldbu	r2,40(r2)
 821d83c:	10803fcc 	andi	r2,r2,255
 821d840:	1080201c 	xori	r2,r2,128
 821d844:	10bfe004 	addi	r2,r2,-128
 821d848:	108016d8 	cmpnei	r2,r2,91
 821d84c:	1000411e 	bne	r2,zero,821d954 <lcd_handle_escape+0x144>
  {
    char * ptr = sp->escape+1;
 821d850:	e0bffe17 	ldw	r2,-8(fp)
 821d854:	10800a04 	addi	r2,r2,40
 821d858:	10800044 	addi	r2,r2,1
 821d85c:	e0bffd15 	stw	r2,-12(fp)
    while (isdigit(*ptr))
 821d860:	00000c06 	br	821d894 <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
 821d864:	e0bffb17 	ldw	r2,-20(fp)
 821d868:	10c002a4 	muli	r3,r2,10
 821d86c:	e0bffd17 	ldw	r2,-12(fp)
 821d870:	11000044 	addi	r4,r2,1
 821d874:	e13ffd15 	stw	r4,-12(fp)
 821d878:	10800003 	ldbu	r2,0(r2)
 821d87c:	10803fcc 	andi	r2,r2,255
 821d880:	1080201c 	xori	r2,r2,128
 821d884:	10bfe004 	addi	r2,r2,-128
 821d888:	10bff404 	addi	r2,r2,-48
 821d88c:	1885883a 	add	r2,r3,r2
 821d890:	e0bffb15 	stw	r2,-20(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
 821d894:	d0e00017 	ldw	r3,-32768(gp)
 821d898:	e0bffd17 	ldw	r2,-12(fp)
 821d89c:	10800003 	ldbu	r2,0(r2)
 821d8a0:	10803fcc 	andi	r2,r2,255
 821d8a4:	1080201c 	xori	r2,r2,128
 821d8a8:	10bfe004 	addi	r2,r2,-128
 821d8ac:	10800044 	addi	r2,r2,1
 821d8b0:	1885883a 	add	r2,r3,r2
 821d8b4:	10800003 	ldbu	r2,0(r2)
 821d8b8:	10803fcc 	andi	r2,r2,255
 821d8bc:	1080010c 	andi	r2,r2,4
 821d8c0:	103fe81e 	bne	r2,zero,821d864 <lcd_handle_escape+0x54>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
 821d8c4:	e0bffd17 	ldw	r2,-12(fp)
 821d8c8:	10800003 	ldbu	r2,0(r2)
 821d8cc:	10803fcc 	andi	r2,r2,255
 821d8d0:	1080201c 	xori	r2,r2,128
 821d8d4:	10bfe004 	addi	r2,r2,-128
 821d8d8:	10800ed8 	cmpnei	r2,r2,59
 821d8dc:	10001f1e 	bne	r2,zero,821d95c <lcd_handle_escape+0x14c>
    {
      ptr++;
 821d8e0:	e0bffd17 	ldw	r2,-12(fp)
 821d8e4:	10800044 	addi	r2,r2,1
 821d8e8:	e0bffd15 	stw	r2,-12(fp)
      while (isdigit(*ptr))
 821d8ec:	00000c06 	br	821d920 <lcd_handle_escape+0x110>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
 821d8f0:	e0bffc17 	ldw	r2,-16(fp)
 821d8f4:	10c002a4 	muli	r3,r2,10
 821d8f8:	e0bffd17 	ldw	r2,-12(fp)
 821d8fc:	11000044 	addi	r4,r2,1
 821d900:	e13ffd15 	stw	r4,-12(fp)
 821d904:	10800003 	ldbu	r2,0(r2)
 821d908:	10803fcc 	andi	r2,r2,255
 821d90c:	1080201c 	xori	r2,r2,128
 821d910:	10bfe004 	addi	r2,r2,-128
 821d914:	10bff404 	addi	r2,r2,-48
 821d918:	1885883a 	add	r2,r3,r2
 821d91c:	e0bffc15 	stw	r2,-16(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
 821d920:	d0e00017 	ldw	r3,-32768(gp)
 821d924:	e0bffd17 	ldw	r2,-12(fp)
 821d928:	10800003 	ldbu	r2,0(r2)
 821d92c:	10803fcc 	andi	r2,r2,255
 821d930:	1080201c 	xori	r2,r2,128
 821d934:	10bfe004 	addi	r2,r2,-128
 821d938:	10800044 	addi	r2,r2,1
 821d93c:	1885883a 	add	r2,r3,r2
 821d940:	10800003 	ldbu	r2,0(r2)
 821d944:	10803fcc 	andi	r2,r2,255
 821d948:	1080010c 	andi	r2,r2,4
 821d94c:	103fe81e 	bne	r2,zero,821d8f0 <lcd_handle_escape+0xe0>
 821d950:	00000206 	br	821d95c <lcd_handle_escape+0x14c>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
 821d954:	00bfffc4 	movi	r2,-1
 821d958:	e0bffb15 	stw	r2,-20(fp)

  switch (c)
 821d95c:	e0bfff07 	ldb	r2,-4(fp)
 821d960:	10c012a0 	cmpeqi	r3,r2,74
 821d964:	1800291e 	bne	r3,zero,821da0c <lcd_handle_escape+0x1fc>
 821d968:	10c012c8 	cmpgei	r3,r2,75
 821d96c:	1800031e 	bne	r3,zero,821d97c <lcd_handle_escape+0x16c>
 821d970:	10801220 	cmpeqi	r2,r2,72
 821d974:	1000061e 	bne	r2,zero,821d990 <lcd_handle_escape+0x180>
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
  }
}
 821d978:	00004a06 	br	821daa4 <lcd_handle_escape+0x294>
    }
  }
  else
    parm1 = -1;

  switch (c)
 821d97c:	10c012e0 	cmpeqi	r3,r2,75
 821d980:	1800281e 	bne	r3,zero,821da24 <lcd_handle_escape+0x214>
 821d984:	108019a0 	cmpeqi	r2,r2,102
 821d988:	1000011e 	bne	r2,zero,821d990 <lcd_handle_escape+0x180>
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
  }
}
 821d98c:	00004506 	br	821daa4 <lcd_handle_escape+0x294>

  switch (c)
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
 821d990:	e0bffc17 	ldw	r2,-16(fp)
 821d994:	0080050e 	bge	zero,r2,821d9ac <lcd_handle_escape+0x19c>
      sp->x = parm2 - 1;
 821d998:	e0bffc17 	ldw	r2,-16(fp)
 821d99c:	10bfffc4 	addi	r2,r2,-1
 821d9a0:	1007883a 	mov	r3,r2
 821d9a4:	e0bffe17 	ldw	r2,-8(fp)
 821d9a8:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
 821d9ac:	e0bffb17 	ldw	r2,-20(fp)
 821d9b0:	0080370e 	bge	zero,r2,821da90 <lcd_handle_escape+0x280>
    {
      sp->y = parm1 - 1;
 821d9b4:	e0bffb17 	ldw	r2,-20(fp)
 821d9b8:	10bfffc4 	addi	r2,r2,-1
 821d9bc:	1007883a 	mov	r3,r2
 821d9c0:	e0bffe17 	ldw	r2,-8(fp)
 821d9c4:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
 821d9c8:	e0bffe17 	ldw	r2,-8(fp)
 821d9cc:	10800883 	ldbu	r2,34(r2)
 821d9d0:	10803fcc 	andi	r2,r2,255
 821d9d4:	10800170 	cmpltui	r2,r2,5
 821d9d8:	1000061e 	bne	r2,zero,821d9f4 <lcd_handle_escape+0x1e4>
        sp->y = ALT_LCD_HEIGHT * 2;
 821d9dc:	e0bffe17 	ldw	r2,-8(fp)
 821d9e0:	00c00104 	movi	r3,4
 821d9e4:	10c00885 	stb	r3,34(r2)
      while (sp->y > ALT_LCD_HEIGHT)
 821d9e8:	00000206 	br	821d9f4 <lcd_handle_escape+0x1e4>
        lcd_scroll_up(sp);
 821d9ec:	e13ffe17 	ldw	r4,-8(fp)
 821d9f0:	821d7440 	call	821d744 <lcd_scroll_up>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
 821d9f4:	e0bffe17 	ldw	r2,-8(fp)
 821d9f8:	10800883 	ldbu	r2,34(r2)
 821d9fc:	10803fcc 	andi	r2,r2,255
 821da00:	108000e8 	cmpgeui	r2,r2,3
 821da04:	103ff91e 	bne	r2,zero,821d9ec <lcd_handle_escape+0x1dc>
        lcd_scroll_up(sp);
    }
    break;
 821da08:	00002106 	br	821da90 <lcd_handle_escape+0x280>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
 821da0c:	e0bffb17 	ldw	r2,-20(fp)
 821da10:	10800098 	cmpnei	r2,r2,2
 821da14:	1000201e 	bne	r2,zero,821da98 <lcd_handle_escape+0x288>
      lcd_clear_screen(sp);
 821da18:	e13ffe17 	ldw	r4,-8(fp)
 821da1c:	821d4880 	call	821d488 <lcd_clear_screen>
    break;
 821da20:	00001d06 	br	821da98 <lcd_handle_escape+0x288>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
 821da24:	e0bffb17 	ldw	r2,-20(fp)
 821da28:	00801d16 	blt	zero,r2,821daa0 <lcd_handle_escape+0x290>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 821da2c:	e0bffe17 	ldw	r2,-8(fp)
 821da30:	10800843 	ldbu	r2,33(r2)
 821da34:	10803fcc 	andi	r2,r2,255
 821da38:	10801428 	cmpgeui	r2,r2,80
 821da3c:	1000181e 	bne	r2,zero,821daa0 <lcd_handle_escape+0x290>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
 821da40:	e0bffe17 	ldw	r2,-8(fp)
 821da44:	10800883 	ldbu	r2,34(r2)
 821da48:	10803fcc 	andi	r2,r2,255
 821da4c:	108018e4 	muli	r2,r2,99
 821da50:	10801004 	addi	r2,r2,64
 821da54:	e0fffe17 	ldw	r3,-8(fp)
 821da58:	1887883a 	add	r3,r3,r2
 821da5c:	e0bffe17 	ldw	r2,-8(fp)
 821da60:	10800843 	ldbu	r2,33(r2)
 821da64:	10803fcc 	andi	r2,r2,255
 821da68:	1889883a 	add	r4,r3,r2
 821da6c:	e0bffe17 	ldw	r2,-8(fp)
 821da70:	10800843 	ldbu	r2,33(r2)
 821da74:	10803fcc 	andi	r2,r2,255
 821da78:	00c01404 	movi	r3,80
 821da7c:	1885c83a 	sub	r2,r3,r2
 821da80:	100d883a 	mov	r6,r2
 821da84:	01400804 	movi	r5,32
 821da88:	82031300 	call	8203130 <memset>
    }
    break;
 821da8c:	00000406 	br	821daa0 <lcd_handle_escape+0x290>
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
        lcd_scroll_up(sp);
    }
    break;
 821da90:	0001883a 	nop
 821da94:	00000306 	br	821daa4 <lcd_handle_escape+0x294>
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
      lcd_clear_screen(sp);
    break;
 821da98:	0001883a 	nop
 821da9c:	00000106 	br	821daa4 <lcd_handle_escape+0x294>
    if (parm1 < 1)
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
 821daa0:	0001883a 	nop
  }
}
 821daa4:	0001883a 	nop
 821daa8:	e037883a 	mov	sp,fp
 821daac:	dfc00117 	ldw	ra,4(sp)
 821dab0:	df000017 	ldw	fp,0(sp)
 821dab4:	dec00204 	addi	sp,sp,8
 821dab8:	f800283a 	ret

0821dabc <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
 821dabc:	defff104 	addi	sp,sp,-60
 821dac0:	dfc00e15 	stw	ra,56(sp)
 821dac4:	df000d15 	stw	fp,52(sp)
 821dac8:	df000d04 	addi	fp,sp,52
 821dacc:	e13ffc15 	stw	r4,-16(fp)
 821dad0:	e17ffd15 	stw	r5,-12(fp)
 821dad4:	e1bffe15 	stw	r6,-8(fp)
 821dad8:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
 821dadc:	e0bffe17 	ldw	r2,-8(fp)
 821dae0:	e0fffd17 	ldw	r3,-12(fp)
 821dae4:	1885883a 	add	r2,r3,r2
 821dae8:	e0bff615 	stw	r2,-40(fp)

  /* When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
 821daec:	e0bffc17 	ldw	r2,-16(fp)
 821daf0:	10803e17 	ldw	r2,248(r2)
 821daf4:	e0bffa15 	stw	r2,-24(fp)
 821daf8:	e03ffb0d 	sth	zero,-20(fp)
 821dafc:	e0bffb0b 	ldhu	r2,-20(fp)
 821db00:	e0fffb84 	addi	r3,fp,-18
 821db04:	180d883a 	mov	r6,r3
 821db08:	100b883a 	mov	r5,r2
 821db0c:	e13ffa17 	ldw	r4,-24(fp)
 821db10:	821a0380 	call	821a038 <OSSemPend>

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
 821db14:	e0bffc17 	ldw	r2,-16(fp)
 821db18:	00c00044 	movi	r3,1
 821db1c:	10c009c5 	stb	r3,39(r2)

  for ( ; ptr < end ; ptr++)
 821db20:	00009906 	br	821dd88 <altera_avalon_lcd_16207_write+0x2cc>
  {
    char c = *ptr;
 821db24:	e0bffd17 	ldw	r2,-12(fp)
 821db28:	10800003 	ldbu	r2,0(r2)
 821db2c:	e0bff705 	stb	r2,-36(fp)

    if (sp->esccount >= 0)
 821db30:	e0bffc17 	ldw	r2,-16(fp)
 821db34:	10800903 	ldbu	r2,36(r2)
 821db38:	10803fcc 	andi	r2,r2,255
 821db3c:	1080201c 	xori	r2,r2,128
 821db40:	10bfe004 	addi	r2,r2,-128
 821db44:	10003716 	blt	r2,zero,821dc24 <altera_avalon_lcd_16207_write+0x168>
    {
      unsigned int esccount = sp->esccount;
 821db48:	e0bffc17 	ldw	r2,-16(fp)
 821db4c:	10800903 	ldbu	r2,36(r2)
 821db50:	10803fcc 	andi	r2,r2,255
 821db54:	1080201c 	xori	r2,r2,128
 821db58:	10bfe004 	addi	r2,r2,-128
 821db5c:	e0bff815 	stw	r2,-32(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 821db60:	e0bff817 	ldw	r2,-32(fp)
 821db64:	1000031e 	bne	r2,zero,821db74 <altera_avalon_lcd_16207_write+0xb8>
 821db68:	e0bff707 	ldb	r2,-36(fp)
 821db6c:	108016d8 	cmpnei	r2,r2,91
 821db70:	10000d1e 	bne	r2,zero,821dba8 <altera_avalon_lcd_16207_write+0xec>
 821db74:	e0bff817 	ldw	r2,-32(fp)
 821db78:	10001826 	beq	r2,zero,821dbdc <altera_avalon_lcd_16207_write+0x120>
          (esccount > 0 && !isdigit(c) && c != ';'))
 821db7c:	d0e00017 	ldw	r3,-32768(gp)
 821db80:	e0bff707 	ldb	r2,-36(fp)
 821db84:	10800044 	addi	r2,r2,1
 821db88:	1885883a 	add	r2,r3,r2
 821db8c:	10800003 	ldbu	r2,0(r2)
 821db90:	10803fcc 	andi	r2,r2,255
 821db94:	1080010c 	andi	r2,r2,4
 821db98:	1000101e 	bne	r2,zero,821dbdc <altera_avalon_lcd_16207_write+0x120>
 821db9c:	e0bff707 	ldb	r2,-36(fp)
 821dba0:	10800ee0 	cmpeqi	r2,r2,59
 821dba4:	10000d1e 	bne	r2,zero,821dbdc <altera_avalon_lcd_16207_write+0x120>
      {
        sp->escape[esccount] = 0;
 821dba8:	e0fffc17 	ldw	r3,-16(fp)
 821dbac:	e0bff817 	ldw	r2,-32(fp)
 821dbb0:	1885883a 	add	r2,r3,r2
 821dbb4:	10800a04 	addi	r2,r2,40
 821dbb8:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
 821dbbc:	e0bff707 	ldb	r2,-36(fp)
 821dbc0:	100b883a 	mov	r5,r2
 821dbc4:	e13ffc17 	ldw	r4,-16(fp)
 821dbc8:	821d8100 	call	821d810 <lcd_handle_escape>

        sp->esccount = -1;
 821dbcc:	e0bffc17 	ldw	r2,-16(fp)
 821dbd0:	00ffffc4 	movi	r3,-1
 821dbd4:	10c00905 	stb	r3,36(r2)
 821dbd8:	00006806 	br	821dd7c <altera_avalon_lcd_16207_write+0x2c0>
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
 821dbdc:	e0bffc17 	ldw	r2,-16(fp)
 821dbe0:	10800903 	ldbu	r2,36(r2)
 821dbe4:	10803fcc 	andi	r2,r2,255
 821dbe8:	108001e8 	cmpgeui	r2,r2,7
 821dbec:	1000631e 	bne	r2,zero,821dd7c <altera_avalon_lcd_16207_write+0x2c0>
      {
        sp->escape[esccount] = c;
 821dbf0:	e0fffc17 	ldw	r3,-16(fp)
 821dbf4:	e0bff817 	ldw	r2,-32(fp)
 821dbf8:	1885883a 	add	r2,r3,r2
 821dbfc:	10800a04 	addi	r2,r2,40
 821dc00:	e0fff703 	ldbu	r3,-36(fp)
 821dc04:	10c00005 	stb	r3,0(r2)
        sp->esccount++;
 821dc08:	e0bffc17 	ldw	r2,-16(fp)
 821dc0c:	10800903 	ldbu	r2,36(r2)
 821dc10:	10800044 	addi	r2,r2,1
 821dc14:	1007883a 	mov	r3,r2
 821dc18:	e0bffc17 	ldw	r2,-16(fp)
 821dc1c:	10c00905 	stb	r3,36(r2)
 821dc20:	00005606 	br	821dd7c <altera_avalon_lcd_16207_write+0x2c0>
      }
    }
    else if (c == 27) /* ESC */
 821dc24:	e0bff707 	ldb	r2,-36(fp)
 821dc28:	108006d8 	cmpnei	r2,r2,27
 821dc2c:	1000031e 	bne	r2,zero,821dc3c <altera_avalon_lcd_16207_write+0x180>
    {
      sp->esccount = 0;
 821dc30:	e0bffc17 	ldw	r2,-16(fp)
 821dc34:	10000905 	stb	zero,36(r2)
 821dc38:	00005006 	br	821dd7c <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\r')
 821dc3c:	e0bff707 	ldb	r2,-36(fp)
 821dc40:	10800358 	cmpnei	r2,r2,13
 821dc44:	1000031e 	bne	r2,zero,821dc54 <altera_avalon_lcd_16207_write+0x198>
    {
      sp->x = 0;
 821dc48:	e0bffc17 	ldw	r2,-16(fp)
 821dc4c:	10000845 	stb	zero,33(r2)
 821dc50:	00004a06 	br	821dd7c <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\n')
 821dc54:	e0bff707 	ldb	r2,-36(fp)
 821dc58:	10800298 	cmpnei	r2,r2,10
 821dc5c:	1000101e 	bne	r2,zero,821dca0 <altera_avalon_lcd_16207_write+0x1e4>
    {
      sp->x = 0;
 821dc60:	e0bffc17 	ldw	r2,-16(fp)
 821dc64:	10000845 	stb	zero,33(r2)
      sp->y++;
 821dc68:	e0bffc17 	ldw	r2,-16(fp)
 821dc6c:	10800883 	ldbu	r2,34(r2)
 821dc70:	10800044 	addi	r2,r2,1
 821dc74:	1007883a 	mov	r3,r2
 821dc78:	e0bffc17 	ldw	r2,-16(fp)
 821dc7c:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
 821dc80:	e0bffc17 	ldw	r2,-16(fp)
 821dc84:	10800883 	ldbu	r2,34(r2)
 821dc88:	10803fcc 	andi	r2,r2,255
 821dc8c:	108000f0 	cmpltui	r2,r2,3
 821dc90:	10003a1e 	bne	r2,zero,821dd7c <altera_avalon_lcd_16207_write+0x2c0>
        lcd_scroll_up(sp);
 821dc94:	e13ffc17 	ldw	r4,-16(fp)
 821dc98:	821d7440 	call	821d744 <lcd_scroll_up>
 821dc9c:	00003706 	br	821dd7c <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (c == '\b')
 821dca0:	e0bff707 	ldb	r2,-36(fp)
 821dca4:	10800218 	cmpnei	r2,r2,8
 821dca8:	10000b1e 	bne	r2,zero,821dcd8 <altera_avalon_lcd_16207_write+0x21c>
    {
      if (sp->x > 0)
 821dcac:	e0bffc17 	ldw	r2,-16(fp)
 821dcb0:	10800843 	ldbu	r2,33(r2)
 821dcb4:	10803fcc 	andi	r2,r2,255
 821dcb8:	10003026 	beq	r2,zero,821dd7c <altera_avalon_lcd_16207_write+0x2c0>
        sp->x--;
 821dcbc:	e0bffc17 	ldw	r2,-16(fp)
 821dcc0:	10800843 	ldbu	r2,33(r2)
 821dcc4:	10bfffc4 	addi	r2,r2,-1
 821dcc8:	1007883a 	mov	r3,r2
 821dccc:	e0bffc17 	ldw	r2,-16(fp)
 821dcd0:	10c00845 	stb	r3,33(r2)
 821dcd4:	00002906 	br	821dd7c <altera_avalon_lcd_16207_write+0x2c0>
    }
    else if (isprint(c))
 821dcd8:	d0e00017 	ldw	r3,-32768(gp)
 821dcdc:	e0bff707 	ldb	r2,-36(fp)
 821dce0:	10800044 	addi	r2,r2,1
 821dce4:	1885883a 	add	r2,r3,r2
 821dce8:	10800003 	ldbu	r2,0(r2)
 821dcec:	10803fcc 	andi	r2,r2,255
 821dcf0:	1080201c 	xori	r2,r2,128
 821dcf4:	10bfe004 	addi	r2,r2,-128
 821dcf8:	108025cc 	andi	r2,r2,151
 821dcfc:	10001f26 	beq	r2,zero,821dd7c <altera_avalon_lcd_16207_write+0x2c0>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
 821dd00:	e0bffc17 	ldw	r2,-16(fp)
 821dd04:	10800883 	ldbu	r2,34(r2)
 821dd08:	10803fcc 	andi	r2,r2,255
 821dd0c:	108000b0 	cmpltui	r2,r2,2
 821dd10:	1000021e 	bne	r2,zero,821dd1c <altera_avalon_lcd_16207_write+0x260>
        lcd_scroll_up(sp);
 821dd14:	e13ffc17 	ldw	r4,-16(fp)
 821dd18:	821d7440 	call	821d744 <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 821dd1c:	e0bffc17 	ldw	r2,-16(fp)
 821dd20:	10800843 	ldbu	r2,33(r2)
 821dd24:	10803fcc 	andi	r2,r2,255
 821dd28:	10801428 	cmpgeui	r2,r2,80
 821dd2c:	10000d1e 	bne	r2,zero,821dd64 <altera_avalon_lcd_16207_write+0x2a8>
        sp->line[sp->y].data[sp->x] = c;
 821dd30:	e0bffc17 	ldw	r2,-16(fp)
 821dd34:	10800883 	ldbu	r2,34(r2)
 821dd38:	10c03fcc 	andi	r3,r2,255
 821dd3c:	e0bffc17 	ldw	r2,-16(fp)
 821dd40:	10800843 	ldbu	r2,33(r2)
 821dd44:	10803fcc 	andi	r2,r2,255
 821dd48:	e13ffc17 	ldw	r4,-16(fp)
 821dd4c:	18c018e4 	muli	r3,r3,99
 821dd50:	20c7883a 	add	r3,r4,r3
 821dd54:	1885883a 	add	r2,r3,r2
 821dd58:	10801004 	addi	r2,r2,64
 821dd5c:	e0fff703 	ldbu	r3,-36(fp)
 821dd60:	10c00005 	stb	r3,0(r2)

      sp->x++;
 821dd64:	e0bffc17 	ldw	r2,-16(fp)
 821dd68:	10800843 	ldbu	r2,33(r2)
 821dd6c:	10800044 	addi	r2,r2,1
 821dd70:	1007883a 	mov	r3,r2
 821dd74:	e0bffc17 	ldw	r2,-16(fp)
 821dd78:	10c00845 	stb	r3,33(r2)

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
 821dd7c:	e0bffd17 	ldw	r2,-12(fp)
 821dd80:	10800044 	addi	r2,r2,1
 821dd84:	e0bffd15 	stw	r2,-12(fp)
 821dd88:	e0fffd17 	ldw	r3,-12(fp)
 821dd8c:	e0bff617 	ldw	r2,-40(fp)
 821dd90:	18bf6436 	bltu	r3,r2,821db24 <altera_avalon_lcd_16207_write+0x68>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
 821dd94:	00800404 	movi	r2,16
 821dd98:	e0bff415 	stw	r2,-48(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821dd9c:	e03ff315 	stw	zero,-52(fp)
 821dda0:	00003706 	br	821de80 <altera_avalon_lcd_16207_write+0x3c4>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 821dda4:	00801404 	movi	r2,80
 821dda8:	e0bff515 	stw	r2,-44(fp)
 821ddac:	00001106 	br	821ddf4 <altera_avalon_lcd_16207_write+0x338>
      if (sp->line[y].data[width-1] != ' ')
 821ddb0:	e0bff517 	ldw	r2,-44(fp)
 821ddb4:	10bfffc4 	addi	r2,r2,-1
 821ddb8:	e13ffc17 	ldw	r4,-16(fp)
 821ddbc:	e0fff317 	ldw	r3,-52(fp)
 821ddc0:	18c018e4 	muli	r3,r3,99
 821ddc4:	20c7883a 	add	r3,r4,r3
 821ddc8:	1885883a 	add	r2,r3,r2
 821ddcc:	10801004 	addi	r2,r2,64
 821ddd0:	10800003 	ldbu	r2,0(r2)
 821ddd4:	10803fcc 	andi	r2,r2,255
 821ddd8:	1080201c 	xori	r2,r2,128
 821dddc:	10bfe004 	addi	r2,r2,-128
 821dde0:	10800820 	cmpeqi	r2,r2,32
 821dde4:	10000626 	beq	r2,zero,821de00 <altera_avalon_lcd_16207_write+0x344>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 821dde8:	e0bff517 	ldw	r2,-44(fp)
 821ddec:	10bfffc4 	addi	r2,r2,-1
 821ddf0:	e0bff515 	stw	r2,-44(fp)
 821ddf4:	e0bff517 	ldw	r2,-44(fp)
 821ddf8:	00bfed16 	blt	zero,r2,821ddb0 <altera_avalon_lcd_16207_write+0x2f4>
 821ddfc:	00000106 	br	821de04 <altera_avalon_lcd_16207_write+0x348>
      if (sp->line[y].data[width-1] != ' ')
        break;
 821de00:	0001883a 	nop

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
 821de04:	e0bff517 	ldw	r2,-44(fp)
 821de08:	10800448 	cmpgei	r2,r2,17
 821de0c:	1000031e 	bne	r2,zero,821de1c <altera_avalon_lcd_16207_write+0x360>
      width = ALT_LCD_WIDTH;
 821de10:	00800404 	movi	r2,16
 821de14:	e0bff515 	stw	r2,-44(fp)
 821de18:	00000306 	br	821de28 <altera_avalon_lcd_16207_write+0x36c>
    else
      width++;
 821de1c:	e0bff517 	ldw	r2,-44(fp)
 821de20:	10800044 	addi	r2,r2,1
 821de24:	e0bff515 	stw	r2,-44(fp)

    sp->line[y].width = width;
 821de28:	e0bff517 	ldw	r2,-44(fp)
 821de2c:	1009883a 	mov	r4,r2
 821de30:	e0fffc17 	ldw	r3,-16(fp)
 821de34:	e0bff317 	ldw	r2,-52(fp)
 821de38:	108018e4 	muli	r2,r2,99
 821de3c:	1885883a 	add	r2,r3,r2
 821de40:	10802444 	addi	r2,r2,145
 821de44:	11000005 	stb	r4,0(r2)
    if (widthmax < width)
 821de48:	e0fff417 	ldw	r3,-48(fp)
 821de4c:	e0bff517 	ldw	r2,-44(fp)
 821de50:	1880020e 	bge	r3,r2,821de5c <altera_avalon_lcd_16207_write+0x3a0>
      widthmax = width;
 821de54:	e0bff517 	ldw	r2,-44(fp)
 821de58:	e0bff415 	stw	r2,-48(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
 821de5c:	e0fffc17 	ldw	r3,-16(fp)
 821de60:	e0bff317 	ldw	r2,-52(fp)
 821de64:	108018e4 	muli	r2,r2,99
 821de68:	1885883a 	add	r2,r3,r2
 821de6c:	10802484 	addi	r2,r2,146
 821de70:	10000005 	stb	zero,0(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821de74:	e0bff317 	ldw	r2,-52(fp)
 821de78:	10800044 	addi	r2,r2,1
 821de7c:	e0bff315 	stw	r2,-52(fp)
 821de80:	e0bff317 	ldw	r2,-52(fp)
 821de84:	10800090 	cmplti	r2,r2,2
 821de88:	103fc61e 	bne	r2,zero,821dda4 <altera_avalon_lcd_16207_write+0x2e8>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
 821de8c:	e0bff417 	ldw	r2,-48(fp)
 821de90:	10800448 	cmpgei	r2,r2,17
 821de94:	1000031e 	bne	r2,zero,821dea4 <altera_avalon_lcd_16207_write+0x3e8>
    sp->scrollmax = 0;
 821de98:	e0bffc17 	ldw	r2,-16(fp)
 821de9c:	10000985 	stb	zero,38(r2)
 821dea0:	00002e06 	br	821df5c <altera_avalon_lcd_16207_write+0x4a0>
  else
  {
    widthmax *= 2;
 821dea4:	e0bff417 	ldw	r2,-48(fp)
 821dea8:	1085883a 	add	r2,r2,r2
 821deac:	e0bff415 	stw	r2,-48(fp)
    sp->scrollmax = widthmax;
 821deb0:	e0bff417 	ldw	r2,-48(fp)
 821deb4:	1007883a 	mov	r3,r2
 821deb8:	e0bffc17 	ldw	r2,-16(fp)
 821debc:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821dec0:	e03ff315 	stw	zero,-52(fp)
 821dec4:	00002206 	br	821df50 <altera_avalon_lcd_16207_write+0x494>
      if (sp->line[y].width > ALT_LCD_WIDTH)
 821dec8:	e0fffc17 	ldw	r3,-16(fp)
 821decc:	e0bff317 	ldw	r2,-52(fp)
 821ded0:	108018e4 	muli	r2,r2,99
 821ded4:	1885883a 	add	r2,r3,r2
 821ded8:	10802444 	addi	r2,r2,145
 821dedc:	10800003 	ldbu	r2,0(r2)
 821dee0:	10803fcc 	andi	r2,r2,255
 821dee4:	1080201c 	xori	r2,r2,128
 821dee8:	10bfe004 	addi	r2,r2,-128
 821deec:	10800450 	cmplti	r2,r2,17
 821def0:	1000141e 	bne	r2,zero,821df44 <altera_avalon_lcd_16207_write+0x488>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
 821def4:	e0fffc17 	ldw	r3,-16(fp)
 821def8:	e0bff317 	ldw	r2,-52(fp)
 821defc:	108018e4 	muli	r2,r2,99
 821df00:	1885883a 	add	r2,r3,r2
 821df04:	10802444 	addi	r2,r2,145
 821df08:	10800003 	ldbu	r2,0(r2)
 821df0c:	10803fcc 	andi	r2,r2,255
 821df10:	1080201c 	xori	r2,r2,128
 821df14:	10bfe004 	addi	r2,r2,-128
 821df18:	1004923a 	slli	r2,r2,8
 821df1c:	e17ff417 	ldw	r5,-48(fp)
 821df20:	1009883a 	mov	r4,r2
 821df24:	8202a940 	call	8202a94 <__divsi3>
 821df28:	1009883a 	mov	r4,r2
 821df2c:	e0fffc17 	ldw	r3,-16(fp)
 821df30:	e0bff317 	ldw	r2,-52(fp)
 821df34:	108018e4 	muli	r2,r2,99
 821df38:	1885883a 	add	r2,r3,r2
 821df3c:	10802484 	addi	r2,r2,146
 821df40:	11000005 	stb	r4,0(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 821df44:	e0bff317 	ldw	r2,-52(fp)
 821df48:	10800044 	addi	r2,r2,1
 821df4c:	e0bff315 	stw	r2,-52(fp)
 821df50:	e0bff317 	ldw	r2,-52(fp)
 821df54:	10800090 	cmplti	r2,r2,2
 821df58:	103fdb1e 	bne	r2,zero,821dec8 <altera_avalon_lcd_16207_write+0x40c>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
 821df5c:	e0bffc17 	ldw	r2,-16(fp)
 821df60:	10800943 	ldbu	r2,37(r2)
 821df64:	10803fcc 	andi	r2,r2,255
 821df68:	e0bff915 	stw	r2,-28(fp)

    lcd_repaint_screen(sp);
 821df6c:	e13ffc17 	ldw	r4,-16(fp)
 821df70:	821d5580 	call	821d558 <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
 821df74:	e0bffc17 	ldw	r2,-16(fp)
 821df78:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
 821df7c:	e0bffc17 	ldw	r2,-16(fp)
 821df80:	10800943 	ldbu	r2,37(r2)
 821df84:	10c03fcc 	andi	r3,r2,255
 821df88:	e0bff917 	ldw	r2,-28(fp)
 821df8c:	18800426 	beq	r3,r2,821dfa0 <altera_avalon_lcd_16207_write+0x4e4>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
 821df90:	e0bffc17 	ldw	r2,-16(fp)
 821df94:	00c00044 	movi	r3,1
 821df98:	10c009c5 	stb	r3,39(r2)
  }
 821df9c:	003fef06 	br	821df5c <altera_avalon_lcd_16207_write+0x4a0>
    sp->active = 0;

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
      break;
 821dfa0:	0001883a 	nop

  /* Now that access to the display is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
 821dfa4:	e0bffc17 	ldw	r2,-16(fp)
 821dfa8:	10803e17 	ldw	r2,248(r2)
 821dfac:	1009883a 	mov	r4,r2
 821dfb0:	821a3b00 	call	821a3b0 <OSSemPost>

  return len;
 821dfb4:	e0bffe17 	ldw	r2,-8(fp)
}
 821dfb8:	e037883a 	mov	sp,fp
 821dfbc:	dfc00117 	ldw	ra,4(sp)
 821dfc0:	df000017 	ldw	fp,0(sp)
 821dfc4:	dec00204 	addi	sp,sp,8
 821dfc8:	f800283a 	ret

0821dfcc <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
 821dfcc:	defffc04 	addi	sp,sp,-16
 821dfd0:	dfc00315 	stw	ra,12(sp)
 821dfd4:	df000215 	stw	fp,8(sp)
 821dfd8:	df000204 	addi	fp,sp,8
 821dfdc:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
 821dfe0:	e0bfff17 	ldw	r2,-4(fp)
 821dfe4:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
 821dfe8:	e0bffe17 	ldw	r2,-8(fp)
 821dfec:	10800943 	ldbu	r2,37(r2)
 821dff0:	10803fcc 	andi	r2,r2,255
 821dff4:	10c00044 	addi	r3,r2,1
 821dff8:	e0bffe17 	ldw	r2,-8(fp)
 821dffc:	10800983 	ldbu	r2,38(r2)
 821e000:	10803fcc 	andi	r2,r2,255
 821e004:	18800316 	blt	r3,r2,821e014 <alt_lcd_16207_timeout+0x48>
    sp->scrollpos = 0;
 821e008:	e0bffe17 	ldw	r2,-8(fp)
 821e00c:	10000945 	stb	zero,37(r2)
 821e010:	00000606 	br	821e02c <alt_lcd_16207_timeout+0x60>
  else
    sp->scrollpos = sp->scrollpos + 1;
 821e014:	e0bffe17 	ldw	r2,-8(fp)
 821e018:	10800943 	ldbu	r2,37(r2)
 821e01c:	10800044 	addi	r2,r2,1
 821e020:	1007883a 	mov	r3,r2
 821e024:	e0bffe17 	ldw	r2,-8(fp)
 821e028:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
 821e02c:	e0bffe17 	ldw	r2,-8(fp)
 821e030:	10800983 	ldbu	r2,38(r2)
 821e034:	10803fcc 	andi	r2,r2,255
 821e038:	10000826 	beq	r2,zero,821e05c <alt_lcd_16207_timeout+0x90>
 821e03c:	e0bffe17 	ldw	r2,-8(fp)
 821e040:	108009c3 	ldbu	r2,39(r2)
 821e044:	10803fcc 	andi	r2,r2,255
 821e048:	1080201c 	xori	r2,r2,128
 821e04c:	10bfe004 	addi	r2,r2,-128
 821e050:	1000021e 	bne	r2,zero,821e05c <alt_lcd_16207_timeout+0x90>
    lcd_repaint_screen(sp);
 821e054:	e13ffe17 	ldw	r4,-8(fp)
 821e058:	821d5580 	call	821d558 <lcd_repaint_screen>

  return sp->period;
 821e05c:	e0bffe17 	ldw	r2,-8(fp)
 821e060:	10800717 	ldw	r2,28(r2)
}
 821e064:	e037883a 	mov	sp,fp
 821e068:	dfc00117 	ldw	ra,4(sp)
 821e06c:	df000017 	ldw	fp,0(sp)
 821e070:	dec00204 	addi	sp,sp,8
 821e074:	f800283a 	ret

0821e078 <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
 821e078:	defff804 	addi	sp,sp,-32
 821e07c:	dfc00715 	stw	ra,28(sp)
 821e080:	df000615 	stw	fp,24(sp)
 821e084:	df000604 	addi	fp,sp,24
 821e088:	e13ffd15 	stw	r4,-12(fp)
  unsigned int base = sp->base;
 821e08c:	e0bffd17 	ldw	r2,-12(fp)
 821e090:	10800017 	ldw	r2,0(r2)
 821e094:	e0bffa15 	stw	r2,-24(fp)

  /* Mark the device as functional */
  sp->broken = 0;
 821e098:	e0bffd17 	ldw	r2,-12(fp)
 821e09c:	10000805 	stb	zero,32(r2)

  ALT_SEM_CREATE (&sp->write_lock, 1);
 821e0a0:	e0bffd17 	ldw	r2,-12(fp)
 821e0a4:	10803e04 	addi	r2,r2,248
 821e0a8:	e0bffb15 	stw	r2,-20(fp)
 821e0ac:	00800044 	movi	r2,1
 821e0b0:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 821e0b4:	e0bffc0b 	ldhu	r2,-16(fp)
 821e0b8:	1009883a 	mov	r4,r2
 821e0bc:	8219d200 	call	8219d20 <OSSemCreate>
 821e0c0:	1007883a 	mov	r3,r2
 821e0c4:	e0bffb17 	ldw	r2,-20(fp)
 821e0c8:	10c00015 	stw	r3,0(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
 821e0cc:	010ea604 	movi	r4,15000
 821e0d0:	823c8b40 	call	823c8b4 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 821e0d4:	e0bffa17 	ldw	r2,-24(fp)
 821e0d8:	00c00c04 	movi	r3,48
 821e0dc:	10c00035 	stwio	r3,0(r2)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
 821e0e0:	01040104 	movi	r4,4100
 821e0e4:	823c8b40 	call	823c8b4 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 821e0e8:	e0bffa17 	ldw	r2,-24(fp)
 821e0ec:	00c00c04 	movi	r3,48
 821e0f0:	10c00035 	stwio	r3,0(r2)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
 821e0f4:	0100fa04 	movi	r4,1000
 821e0f8:	823c8b40 	call	823c8b4 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 821e0fc:	e0bffa17 	ldw	r2,-24(fp)
 821e100:	00c00c04 	movi	r3,48
 821e104:	10c00035 	stwio	r3,0(r2)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
 821e108:	01400e04 	movi	r5,56
 821e10c:	e13ffd17 	ldw	r4,-12(fp)
 821e110:	821d2f80 	call	821d2f8 <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
 821e114:	01400204 	movi	r5,8
 821e118:	e13ffd17 	ldw	r4,-12(fp)
 821e11c:	821d2f80 	call	821d2f8 <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
 821e120:	e13ffd17 	ldw	r4,-12(fp)
 821e124:	821d4880 	call	821d488 <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
 821e128:	01400184 	movi	r5,6
 821e12c:	e13ffd17 	ldw	r4,-12(fp)
 821e130:	821d2f80 	call	821d2f8 <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
 821e134:	01400304 	movi	r5,12
 821e138:	e13ffd17 	ldw	r4,-12(fp)
 821e13c:	821d2f80 	call	821d2f8 <lcd_write_command>

  sp->esccount = -1;
 821e140:	e0bffd17 	ldw	r2,-12(fp)
 821e144:	00ffffc4 	movi	r3,-1
 821e148:	10c00905 	stb	r3,36(r2)
  memset(sp->escape, 0, sizeof(sp->escape));
 821e14c:	e0bffd17 	ldw	r2,-12(fp)
 821e150:	10800a04 	addi	r2,r2,40
 821e154:	01800204 	movi	r6,8
 821e158:	000b883a 	mov	r5,zero
 821e15c:	1009883a 	mov	r4,r2
 821e160:	82031300 	call	8203130 <memset>

  sp->scrollpos = 0;
 821e164:	e0bffd17 	ldw	r2,-12(fp)
 821e168:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
 821e16c:	e0bffd17 	ldw	r2,-12(fp)
 821e170:	10000985 	stb	zero,38(r2)
  sp->active = 0;
 821e174:	e0bffd17 	ldw	r2,-12(fp)
 821e178:	100009c5 	stb	zero,39(r2)
 821e17c:	d0a0b817 	ldw	r2,-32032(gp)

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
 821e180:	01400284 	movi	r5,10
 821e184:	1009883a 	mov	r4,r2
 821e188:	8202b8c0 	call	8202b8c <__udivsi3>
 821e18c:	1007883a 	mov	r3,r2
 821e190:	e0bffd17 	ldw	r2,-12(fp)
 821e194:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
 821e198:	e0bffd17 	ldw	r2,-12(fp)
 821e19c:	10c00104 	addi	r3,r2,4
 821e1a0:	e0bffd17 	ldw	r2,-12(fp)
 821e1a4:	10800717 	ldw	r2,28(r2)
 821e1a8:	e1fffd17 	ldw	r7,-12(fp)
 821e1ac:	018208b4 	movhi	r6,2082
 821e1b0:	31b7f304 	addi	r6,r6,-8244
 821e1b4:	100b883a 	mov	r5,r2
 821e1b8:	1809883a 	mov	r4,r3
 821e1bc:	823b9440 	call	823b944 <alt_alarm_start>
}
 821e1c0:	0001883a 	nop
 821e1c4:	e037883a 	mov	sp,fp
 821e1c8:	dfc00117 	ldw	ra,4(sp)
 821e1cc:	df000017 	ldw	fp,0(sp)
 821e1d0:	dec00204 	addi	sp,sp,8
 821e1d4:	f800283a 	ret

0821e1d8 <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
 821e1d8:	defffa04 	addi	sp,sp,-24
 821e1dc:	dfc00515 	stw	ra,20(sp)
 821e1e0:	df000415 	stw	fp,16(sp)
 821e1e4:	df000404 	addi	fp,sp,16
 821e1e8:	e13ffd15 	stw	r4,-12(fp)
 821e1ec:	e17ffe15 	stw	r5,-8(fp)
 821e1f0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
 821e1f4:	e0bffd17 	ldw	r2,-12(fp)
 821e1f8:	10800017 	ldw	r2,0(r2)
 821e1fc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
 821e200:	e0bffc17 	ldw	r2,-16(fp)
 821e204:	10c00a04 	addi	r3,r2,40
 821e208:	e0bffd17 	ldw	r2,-12(fp)
 821e20c:	10800217 	ldw	r2,8(r2)
 821e210:	100f883a 	mov	r7,r2
 821e214:	e1bfff17 	ldw	r6,-4(fp)
 821e218:	e17ffe17 	ldw	r5,-8(fp)
 821e21c:	1809883a 	mov	r4,r3
 821e220:	821dabc0 	call	821dabc <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
 821e224:	e037883a 	mov	sp,fp
 821e228:	dfc00117 	ldw	ra,4(sp)
 821e22c:	df000017 	ldw	fp,0(sp)
 821e230:	dec00204 	addi	sp,sp,8
 821e234:	f800283a 	ret

0821e238 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 821e238:	defffe04 	addi	sp,sp,-8
 821e23c:	dfc00115 	stw	ra,4(sp)
 821e240:	df000015 	stw	fp,0(sp)
 821e244:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 821e248:	d0a04717 	ldw	r2,-32484(gp)
 821e24c:	10000326 	beq	r2,zero,821e25c <alt_get_errno+0x24>
 821e250:	d0a04717 	ldw	r2,-32484(gp)
 821e254:	103ee83a 	callr	r2
 821e258:	00000106 	br	821e260 <alt_get_errno+0x28>
 821e25c:	d0a06304 	addi	r2,gp,-32372
}
 821e260:	e037883a 	mov	sp,fp
 821e264:	dfc00117 	ldw	ra,4(sp)
 821e268:	df000017 	ldw	fp,0(sp)
 821e26c:	dec00204 	addi	sp,sp,8
 821e270:	f800283a 	ret

0821e274 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 821e274:	defffc04 	addi	sp,sp,-16
 821e278:	df000315 	stw	fp,12(sp)
 821e27c:	df000304 	addi	fp,sp,12
 821e280:	e13ffe15 	stw	r4,-8(fp)
 821e284:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 821e288:	e0bffe17 	ldw	r2,-8(fp)
 821e28c:	10800317 	ldw	r2,12(r2)
 821e290:	10800037 	ldwio	r2,0(r2)
 821e294:	1080040c 	andi	r2,r2,16
 821e298:	10000226 	beq	r2,zero,821e2a4 <alt_avalon_sgdma_do_async_transfer+0x30>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
 821e29c:	00bffc04 	movi	r2,-16
 821e2a0:	00003906 	br	821e388 <alt_avalon_sgdma_do_async_transfer+0x114>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821e2a4:	e0bffe17 	ldw	r2,-8(fp)
 821e2a8:	10800317 	ldw	r2,12(r2)
 821e2ac:	10800404 	addi	r2,r2,16
 821e2b0:	e0fffe17 	ldw	r3,-8(fp)
 821e2b4:	18c00317 	ldw	r3,12(r3)
 821e2b8:	18c00404 	addi	r3,r3,16
 821e2bc:	19000037 	ldwio	r4,0(r3)
 821e2c0:	00fff7c4 	movi	r3,-33
 821e2c4:	20c6703a 	and	r3,r4,r3
 821e2c8:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821e2cc:	e0bffe17 	ldw	r2,-8(fp)
 821e2d0:	10800317 	ldw	r2,12(r2)
 821e2d4:	00c03fc4 	movi	r3,255
 821e2d8:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 821e2dc:	e0bffe17 	ldw	r2,-8(fp)
 821e2e0:	10800317 	ldw	r2,12(r2)
 821e2e4:	10800804 	addi	r2,r2,32
 821e2e8:	e0ffff17 	ldw	r3,-4(fp)
 821e2ec:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
 821e2f0:	e0bffe17 	ldw	r2,-8(fp)
 821e2f4:	10800917 	ldw	r2,36(r2)
 821e2f8:	10001126 	beq	r2,zero,821e340 <alt_avalon_sgdma_do_async_transfer+0xcc>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e2fc:	e0bffe17 	ldw	r2,-8(fp)
 821e300:	10800317 	ldw	r2,12(r2)
 821e304:	10800404 	addi	r2,r2,16
 821e308:	10800037 	ldwio	r2,0(r2)
 821e30c:	e0bffd15 	stw	r2,-12(fp)

    control |= (dev->chain_control                          |
 821e310:	e0bffe17 	ldw	r2,-8(fp)
 821e314:	10c00b17 	ldw	r3,44(r2)
 821e318:	e0bffd17 	ldw	r2,-12(fp)
 821e31c:	1884b03a 	or	r2,r3,r2
 821e320:	10801814 	ori	r2,r2,96
 821e324:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e328:	e0bffe17 	ldw	r2,-8(fp)
 821e32c:	10800317 	ldw	r2,12(r2)
 821e330:	10800404 	addi	r2,r2,16
 821e334:	e0fffd17 	ldw	r3,-12(fp)
 821e338:	10c00035 	stwio	r3,0(r2)
 821e33c:	00001106 	br	821e384 <alt_avalon_sgdma_do_async_transfer+0x110>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e340:	e0bffe17 	ldw	r2,-8(fp)
 821e344:	10800317 	ldw	r2,12(r2)
 821e348:	10800404 	addi	r2,r2,16
 821e34c:	10800037 	ldwio	r2,0(r2)
 821e350:	e0bffd15 	stw	r2,-12(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
 821e354:	e0bffd17 	ldw	r2,-12(fp)
 821e358:	10801814 	ori	r2,r2,96
 821e35c:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
 821e360:	e0fffd17 	ldw	r3,-12(fp)
 821e364:	00bffbc4 	movi	r2,-17
 821e368:	1884703a 	and	r2,r3,r2
 821e36c:	e0bffd15 	stw	r2,-12(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e370:	e0bffe17 	ldw	r2,-8(fp)
 821e374:	10800317 	ldw	r2,12(r2)
 821e378:	10800404 	addi	r2,r2,16
 821e37c:	e0fffd17 	ldw	r3,-12(fp)
 821e380:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
 821e384:	0005883a 	mov	r2,zero
}
 821e388:	e037883a 	mov	sp,fp
 821e38c:	df000017 	ldw	fp,0(sp)
 821e390:	dec00104 	addi	sp,sp,4
 821e394:	f800283a 	ret

0821e398 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 821e398:	defffc04 	addi	sp,sp,-16
 821e39c:	df000315 	stw	fp,12(sp)
 821e3a0:	df000304 	addi	fp,sp,12
 821e3a4:	e13ffe15 	stw	r4,-8(fp)
 821e3a8:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 821e3ac:	0001883a 	nop
 821e3b0:	e0bffe17 	ldw	r2,-8(fp)
 821e3b4:	10800317 	ldw	r2,12(r2)
 821e3b8:	10800037 	ldwio	r2,0(r2)
 821e3bc:	1080040c 	andi	r2,r2,16
 821e3c0:	103ffb1e 	bne	r2,zero,821e3b0 <alt_avalon_sgdma_do_sync_transfer+0x18>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821e3c4:	e0bffe17 	ldw	r2,-8(fp)
 821e3c8:	10800317 	ldw	r2,12(r2)
 821e3cc:	10800404 	addi	r2,r2,16
 821e3d0:	e0fffe17 	ldw	r3,-8(fp)
 821e3d4:	18c00317 	ldw	r3,12(r3)
 821e3d8:	18c00404 	addi	r3,r3,16
 821e3dc:	19000037 	ldwio	r4,0(r3)
 821e3e0:	00fff7c4 	movi	r3,-33
 821e3e4:	20c6703a 	and	r3,r4,r3
 821e3e8:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821e3ec:	e0bffe17 	ldw	r2,-8(fp)
 821e3f0:	10800317 	ldw	r2,12(r2)
 821e3f4:	00c03fc4 	movi	r3,255
 821e3f8:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 821e3fc:	e0bffe17 	ldw	r2,-8(fp)
 821e400:	10800317 	ldw	r2,12(r2)
 821e404:	10800804 	addi	r2,r2,32
 821e408:	e0ffff17 	ldw	r3,-4(fp)
 821e40c:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821e410:	e0bffe17 	ldw	r2,-8(fp)
 821e414:	10800317 	ldw	r2,12(r2)
 821e418:	10800404 	addi	r2,r2,16
 821e41c:	e0fffe17 	ldw	r3,-8(fp)
 821e420:	18c00317 	ldw	r3,12(r3)
 821e424:	18c00404 	addi	r3,r3,16
 821e428:	18c00037 	ldwio	r3,0(r3)
 821e42c:	18c01814 	ori	r3,r3,96
 821e430:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 821e434:	0001883a 	nop
 821e438:	e0bffe17 	ldw	r2,-8(fp)
 821e43c:	10800317 	ldw	r2,12(r2)
 821e440:	10800037 	ldwio	r2,0(r2)
 821e444:	1080040c 	andi	r2,r2,16
 821e448:	103ffb1e 	bne	r2,zero,821e438 <alt_avalon_sgdma_do_sync_transfer+0xa0>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 821e44c:	e0bffe17 	ldw	r2,-8(fp)
 821e450:	10800317 	ldw	r2,12(r2)
 821e454:	10800404 	addi	r2,r2,16
 821e458:	e0fffe17 	ldw	r3,-8(fp)
 821e45c:	18c00317 	ldw	r3,12(r3)
 821e460:	18c00404 	addi	r3,r3,16
 821e464:	19000037 	ldwio	r4,0(r3)
 821e468:	00fff7c4 	movi	r3,-33
 821e46c:	20c6703a 	and	r3,r4,r3
 821e470:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
 821e474:	e0bffe17 	ldw	r2,-8(fp)
 821e478:	10800317 	ldw	r2,12(r2)
 821e47c:	10800037 	ldwio	r2,0(r2)
 821e480:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821e484:	e0bffe17 	ldw	r2,-8(fp)
 821e488:	10800317 	ldw	r2,12(r2)
 821e48c:	00c03fc4 	movi	r3,255
 821e490:	10c00035 	stwio	r3,0(r2)

  return status;
 821e494:	e0bffd03 	ldbu	r2,-12(fp)
}
 821e498:	e037883a 	mov	sp,fp
 821e49c:	df000017 	ldw	fp,0(sp)
 821e4a0:	dec00104 	addi	sp,sp,4
 821e4a4:	f800283a 	ret

0821e4a8 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
 821e4a8:	defff404 	addi	sp,sp,-48
 821e4ac:	dfc00b15 	stw	ra,44(sp)
 821e4b0:	df000a15 	stw	fp,40(sp)
 821e4b4:	df000a04 	addi	fp,sp,40
 821e4b8:	e13ffb15 	stw	r4,-20(fp)
 821e4bc:	e17ffc15 	stw	r5,-16(fp)
 821e4c0:	e1bffd15 	stw	r6,-12(fp)
 821e4c4:	e1fffe15 	stw	r7,-8(fp)
 821e4c8:	e0800217 	ldw	r2,8(fp)
 821e4cc:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
 821e4d0:	e0bfff0b 	ldhu	r2,-4(fp)
 821e4d4:	d8000415 	stw	zero,16(sp)
 821e4d8:	d8000315 	stw	zero,12(sp)
 821e4dc:	e0c00417 	ldw	r3,16(fp)
 821e4e0:	d8c00215 	stw	r3,8(sp)
 821e4e4:	e0c00317 	ldw	r3,12(fp)
 821e4e8:	d8c00115 	stw	r3,4(sp)
 821e4ec:	d8800015 	stw	r2,0(sp)
 821e4f0:	e1fffe17 	ldw	r7,-8(fp)
 821e4f4:	e1bffd17 	ldw	r6,-12(fp)
 821e4f8:	e17ffc17 	ldw	r5,-16(fp)
 821e4fc:	e13ffb17 	ldw	r4,-20(fp)
 821e500:	821e51c0 	call	821e51c <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
 821e504:	0001883a 	nop
 821e508:	e037883a 	mov	sp,fp
 821e50c:	dfc00117 	ldw	ra,4(sp)
 821e510:	df000017 	ldw	fp,0(sp)
 821e514:	dec00204 	addi	sp,sp,8
 821e518:	f800283a 	ret

0821e51c <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
 821e51c:	defff204 	addi	sp,sp,-56
 821e520:	dfc00d15 	stw	ra,52(sp)
 821e524:	df000c15 	stw	fp,48(sp)
 821e528:	df000c04 	addi	fp,sp,48
 821e52c:	e13ffb15 	stw	r4,-20(fp)
 821e530:	e17ffc15 	stw	r5,-16(fp)
 821e534:	e1bffd15 	stw	r6,-12(fp)
 821e538:	e1fffe15 	stw	r7,-8(fp)
 821e53c:	e0800217 	ldw	r2,8(fp)
 821e540:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 821e544:	e0bfff0b 	ldhu	r2,-4(fp)
 821e548:	d8000615 	stw	zero,24(sp)
 821e54c:	e0c00617 	ldw	r3,24(fp)
 821e550:	d8c00515 	stw	r3,20(sp)
 821e554:	e0c00517 	ldw	r3,20(fp)
 821e558:	d8c00415 	stw	r3,16(sp)
 821e55c:	e0c00417 	ldw	r3,16(fp)
 821e560:	d8c00315 	stw	r3,12(sp)
 821e564:	e0c00317 	ldw	r3,12(fp)
 821e568:	d8c00215 	stw	r3,8(sp)
 821e56c:	d8000115 	stw	zero,4(sp)
 821e570:	d8800015 	stw	r2,0(sp)
 821e574:	e1fffe17 	ldw	r7,-8(fp)
 821e578:	e1bffd17 	ldw	r6,-12(fp)
 821e57c:	e17ffc17 	ldw	r5,-16(fp)
 821e580:	e13ffb17 	ldw	r4,-20(fp)
 821e584:	821eab00 	call	821eab0 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
 821e588:	0001883a 	nop
 821e58c:	e037883a 	mov	sp,fp
 821e590:	dfc00117 	ldw	ra,4(sp)
 821e594:	df000017 	ldw	fp,0(sp)
 821e598:	dec00204 	addi	sp,sp,8
 821e59c:	f800283a 	ret

0821e5a0 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
 821e5a0:	defff804 	addi	sp,sp,-32
 821e5a4:	dfc00715 	stw	ra,28(sp)
 821e5a8:	df000615 	stw	fp,24(sp)
 821e5ac:	df000604 	addi	fp,sp,24
 821e5b0:	e13ffc15 	stw	r4,-16(fp)
 821e5b4:	e17ffd15 	stw	r5,-12(fp)
 821e5b8:	e1bffe15 	stw	r6,-8(fp)
 821e5bc:	3805883a 	mov	r2,r7
 821e5c0:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
 821e5c4:	e0ffff0b 	ldhu	r3,-4(fp)
 821e5c8:	d8000115 	stw	zero,4(sp)
 821e5cc:	e0800217 	ldw	r2,8(fp)
 821e5d0:	d8800015 	stw	r2,0(sp)
 821e5d4:	180f883a 	mov	r7,r3
 821e5d8:	e1bffe17 	ldw	r6,-8(fp)
 821e5dc:	e17ffd17 	ldw	r5,-12(fp)
 821e5e0:	e13ffc17 	ldw	r4,-16(fp)
 821e5e4:	821e6000 	call	821e600 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
 821e5e8:	0001883a 	nop
 821e5ec:	e037883a 	mov	sp,fp
 821e5f0:	dfc00117 	ldw	ra,4(sp)
 821e5f4:	df000017 	ldw	fp,0(sp)
 821e5f8:	dec00204 	addi	sp,sp,8
 821e5fc:	f800283a 	ret

0821e600 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
 821e600:	defff304 	addi	sp,sp,-52
 821e604:	dfc00c15 	stw	ra,48(sp)
 821e608:	df000b15 	stw	fp,44(sp)
 821e60c:	df000b04 	addi	fp,sp,44
 821e610:	e13ffc15 	stw	r4,-16(fp)
 821e614:	e17ffd15 	stw	r5,-12(fp)
 821e618:	e1bffe15 	stw	r6,-8(fp)
 821e61c:	3805883a 	mov	r2,r7
 821e620:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 821e624:	e0bfff0b 	ldhu	r2,-4(fp)
 821e628:	d8000615 	stw	zero,24(sp)
 821e62c:	e0c00317 	ldw	r3,12(fp)
 821e630:	d8c00515 	stw	r3,20(sp)
 821e634:	d8000415 	stw	zero,16(sp)
 821e638:	e0c00217 	ldw	r3,8(fp)
 821e63c:	d8c00315 	stw	r3,12(sp)
 821e640:	d8000215 	stw	zero,8(sp)
 821e644:	d8000115 	stw	zero,4(sp)
 821e648:	d8800015 	stw	r2,0(sp)
 821e64c:	e1fffe17 	ldw	r7,-8(fp)
 821e650:	000d883a 	mov	r6,zero
 821e654:	e17ffd17 	ldw	r5,-12(fp)
 821e658:	e13ffc17 	ldw	r4,-16(fp)
 821e65c:	821eab00 	call	821eab0 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
 821e660:	0001883a 	nop
 821e664:	e037883a 	mov	sp,fp
 821e668:	dfc00117 	ldw	ra,4(sp)
 821e66c:	df000017 	ldw	fp,0(sp)
 821e670:	dec00204 	addi	sp,sp,8
 821e674:	f800283a 	ret

0821e678 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
 821e678:	defff404 	addi	sp,sp,-48
 821e67c:	dfc00b15 	stw	ra,44(sp)
 821e680:	df000a15 	stw	fp,40(sp)
 821e684:	df000a04 	addi	fp,sp,40
 821e688:	e13ffb15 	stw	r4,-20(fp)
 821e68c:	e17ffc15 	stw	r5,-16(fp)
 821e690:	e1bffd15 	stw	r6,-12(fp)
 821e694:	3807883a 	mov	r3,r7
 821e698:	e0800517 	ldw	r2,20(fp)
 821e69c:	e0fffe0d 	sth	r3,-8(fp)
 821e6a0:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
 821e6a4:	e0fffe0b 	ldhu	r3,-8(fp)
 821e6a8:	e0bfff03 	ldbu	r2,-4(fp)
 821e6ac:	d8800415 	stw	r2,16(sp)
 821e6b0:	d8000315 	stw	zero,12(sp)
 821e6b4:	e0800417 	ldw	r2,16(fp)
 821e6b8:	d8800215 	stw	r2,8(sp)
 821e6bc:	e0800317 	ldw	r2,12(fp)
 821e6c0:	d8800115 	stw	r2,4(sp)
 821e6c4:	e0800217 	ldw	r2,8(fp)
 821e6c8:	d8800015 	stw	r2,0(sp)
 821e6cc:	180f883a 	mov	r7,r3
 821e6d0:	e1bffd17 	ldw	r6,-12(fp)
 821e6d4:	e17ffc17 	ldw	r5,-16(fp)
 821e6d8:	e13ffb17 	ldw	r4,-20(fp)
 821e6dc:	821e6f80 	call	821e6f8 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
 821e6e0:	0001883a 	nop
 821e6e4:	e037883a 	mov	sp,fp
 821e6e8:	dfc00117 	ldw	ra,4(sp)
 821e6ec:	df000017 	ldw	fp,0(sp)
 821e6f0:	dec00204 	addi	sp,sp,8
 821e6f4:	f800283a 	ret

0821e6f8 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
 821e6f8:	defff204 	addi	sp,sp,-56
 821e6fc:	dfc00d15 	stw	ra,52(sp)
 821e700:	df000c15 	stw	fp,48(sp)
 821e704:	df000c04 	addi	fp,sp,48
 821e708:	e13ffb15 	stw	r4,-20(fp)
 821e70c:	e17ffc15 	stw	r5,-16(fp)
 821e710:	e1bffd15 	stw	r6,-12(fp)
 821e714:	3807883a 	mov	r3,r7
 821e718:	e0800617 	ldw	r2,24(fp)
 821e71c:	e0fffe0d 	sth	r3,-8(fp)
 821e720:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 821e724:	e0bffe0b 	ldhu	r2,-8(fp)
 821e728:	e0ffff03 	ldbu	r3,-4(fp)
 821e72c:	d8c00615 	stw	r3,24(sp)
 821e730:	d8000515 	stw	zero,20(sp)
 821e734:	e0c00517 	ldw	r3,20(fp)
 821e738:	d8c00415 	stw	r3,16(sp)
 821e73c:	e0c00317 	ldw	r3,12(fp)
 821e740:	d8c00315 	stw	r3,12(sp)
 821e744:	e0c00217 	ldw	r3,8(fp)
 821e748:	d8c00215 	stw	r3,8(sp)
 821e74c:	e0c00417 	ldw	r3,16(fp)
 821e750:	d8c00115 	stw	r3,4(sp)
 821e754:	d8800015 	stw	r2,0(sp)
 821e758:	000f883a 	mov	r7,zero
 821e75c:	e1bffd17 	ldw	r6,-12(fp)
 821e760:	e17ffc17 	ldw	r5,-16(fp)
 821e764:	e13ffb17 	ldw	r4,-20(fp)
 821e768:	821eab00 	call	821eab0 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
 821e76c:	0001883a 	nop
 821e770:	e037883a 	mov	sp,fp
 821e774:	dfc00117 	ldw	ra,4(sp)
 821e778:	df000017 	ldw	fp,0(sp)
 821e77c:	dec00204 	addi	sp,sp,8
 821e780:	f800283a 	ret

0821e784 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
 821e784:	defffb04 	addi	sp,sp,-20
 821e788:	df000415 	stw	fp,16(sp)
 821e78c:	df000404 	addi	fp,sp,16
 821e790:	e13ffc15 	stw	r4,-16(fp)
 821e794:	e17ffd15 	stw	r5,-12(fp)
 821e798:	e1bffe15 	stw	r6,-8(fp)
 821e79c:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
 821e7a0:	e0bffc17 	ldw	r2,-16(fp)
 821e7a4:	e0fffd17 	ldw	r3,-12(fp)
 821e7a8:	10c00915 	stw	r3,36(r2)
  dev->callback_context = context;
 821e7ac:	e0bffc17 	ldw	r2,-16(fp)
 821e7b0:	e0ffff17 	ldw	r3,-4(fp)
 821e7b4:	10c00a15 	stw	r3,40(r2)
  dev->chain_control    = chain_control;
 821e7b8:	e0bffc17 	ldw	r2,-16(fp)
 821e7bc:	e0fffe17 	ldw	r3,-8(fp)
 821e7c0:	10c00b15 	stw	r3,44(r2)
}
 821e7c4:	0001883a 	nop
 821e7c8:	e037883a 	mov	sp,fp
 821e7cc:	df000017 	ldw	fp,0(sp)
 821e7d0:	dec00104 	addi	sp,sp,4
 821e7d4:	f800283a 	ret

0821e7d8 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
 821e7d8:	defffd04 	addi	sp,sp,-12
 821e7dc:	df000215 	stw	fp,8(sp)
 821e7e0:	df000204 	addi	fp,sp,8
 821e7e4:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e7e8:	e0bfff17 	ldw	r2,-4(fp)
 821e7ec:	10800317 	ldw	r2,12(r2)
 821e7f0:	10800404 	addi	r2,r2,16
 821e7f4:	10800037 	ldwio	r2,0(r2)
 821e7f8:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 821e7fc:	e0bffe17 	ldw	r2,-8(fp)
 821e800:	10800814 	ori	r2,r2,32
 821e804:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e808:	e0bfff17 	ldw	r2,-4(fp)
 821e80c:	10800317 	ldw	r2,12(r2)
 821e810:	10800404 	addi	r2,r2,16
 821e814:	e0fffe17 	ldw	r3,-8(fp)
 821e818:	10c00035 	stwio	r3,0(r2)
}
 821e81c:	0001883a 	nop
 821e820:	e037883a 	mov	sp,fp
 821e824:	df000017 	ldw	fp,0(sp)
 821e828:	dec00104 	addi	sp,sp,4
 821e82c:	f800283a 	ret

0821e830 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
 821e830:	defffd04 	addi	sp,sp,-12
 821e834:	df000215 	stw	fp,8(sp)
 821e838:	df000204 	addi	fp,sp,8
 821e83c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e840:	e0bfff17 	ldw	r2,-4(fp)
 821e844:	10800317 	ldw	r2,12(r2)
 821e848:	10800404 	addi	r2,r2,16
 821e84c:	10800037 	ldwio	r2,0(r2)
 821e850:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 821e854:	e0fffe17 	ldw	r3,-8(fp)
 821e858:	00bff7c4 	movi	r2,-33
 821e85c:	1884703a 	and	r2,r3,r2
 821e860:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821e864:	e0bfff17 	ldw	r2,-4(fp)
 821e868:	10800317 	ldw	r2,12(r2)
 821e86c:	10800404 	addi	r2,r2,16
 821e870:	e0fffe17 	ldw	r3,-8(fp)
 821e874:	10c00035 	stwio	r3,0(r2)
}
 821e878:	0001883a 	nop
 821e87c:	e037883a 	mov	sp,fp
 821e880:	df000017 	ldw	fp,0(sp)
 821e884:	dec00104 	addi	sp,sp,4
 821e888:	f800283a 	ret

0821e88c <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
 821e88c:	defffe04 	addi	sp,sp,-8
 821e890:	df000115 	stw	fp,4(sp)
 821e894:	df000104 	addi	fp,sp,4
 821e898:	e13fff15 	stw	r4,-4(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
 821e89c:	e0bfff17 	ldw	r2,-4(fp)
 821e8a0:	10800784 	addi	r2,r2,30
 821e8a4:	10800023 	ldbuio	r2,0(r2)
 821e8a8:	10803fcc 	andi	r2,r2,255
 821e8ac:	10801fcc 	andi	r2,r2,127
 821e8b0:	10000226 	beq	r2,zero,821e8bc <alt_avalon_sgdma_check_descriptor_status+0x30>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
 821e8b4:	00bffec4 	movi	r2,-5
 821e8b8:	00000906 	br	821e8e0 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
 821e8bc:	e0bfff17 	ldw	r2,-4(fp)
 821e8c0:	108007c4 	addi	r2,r2,31
 821e8c4:	10800023 	ldbuio	r2,0(r2)
 821e8c8:	10803fcc 	andi	r2,r2,255
 821e8cc:	1080200c 	andi	r2,r2,128
 821e8d0:	10000226 	beq	r2,zero,821e8dc <alt_avalon_sgdma_check_descriptor_status+0x50>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
 821e8d4:	00bfe244 	movi	r2,-119
 821e8d8:	00000106 	br	821e8e0 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

    return 0;
 821e8dc:	0005883a 	mov	r2,zero
}
 821e8e0:	e037883a 	mov	sp,fp
 821e8e4:	df000017 	ldw	fp,0(sp)
 821e8e8:	dec00104 	addi	sp,sp,4
 821e8ec:	f800283a 	ret

0821e8f0 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
 821e8f0:	defffc04 	addi	sp,sp,-16
 821e8f4:	dfc00315 	stw	ra,12(sp)
 821e8f8:	df000215 	stw	fp,8(sp)
 821e8fc:	df000204 	addi	fp,sp,8
 821e900:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
 821e904:	d1602b04 	addi	r5,gp,-32596
 821e908:	e13fff17 	ldw	r4,-4(fp)
 821e90c:	823bdc00 	call	823bdc0 <alt_find_dev>
 821e910:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
 821e914:	e0bffe17 	ldw	r2,-8(fp)
 821e918:	1000041e 	bne	r2,zero,821e92c <alt_avalon_sgdma_open+0x3c>
    ALT_ERRNO = ENODEV;
 821e91c:	821e2380 	call	821e238 <alt_get_errno>
 821e920:	1007883a 	mov	r3,r2
 821e924:	008004c4 	movi	r2,19
 821e928:	18800015 	stw	r2,0(r3)
  }

  return dev;
 821e92c:	e0bffe17 	ldw	r2,-8(fp)
}
 821e930:	e037883a 	mov	sp,fp
 821e934:	dfc00117 	ldw	ra,4(sp)
 821e938:	df000017 	ldw	fp,0(sp)
 821e93c:	dec00204 	addi	sp,sp,8
 821e940:	f800283a 	ret

0821e944 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
 821e944:	defff104 	addi	sp,sp,-60
 821e948:	dfc00e15 	stw	ra,56(sp)
 821e94c:	df000d15 	stw	fp,52(sp)
 821e950:	df000d04 	addi	fp,sp,52
 821e954:	e13ffa15 	stw	r4,-24(fp)
 821e958:	e17ffb15 	stw	r5,-20(fp)
 821e95c:	e1bffc15 	stw	r6,-16(fp)
 821e960:	e1fffd15 	stw	r7,-12(fp)
 821e964:	e0c00217 	ldw	r3,8(fp)
 821e968:	e0800617 	ldw	r2,24(fp)
 821e96c:	e0fffe0d 	sth	r3,-8(fp)
 821e970:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
 821e974:	e0bffe0b 	ldhu	r2,-8(fp)
 821e978:	e0ffff03 	ldbu	r3,-4(fp)
 821e97c:	d8c00615 	stw	r3,24(sp)
 821e980:	d8000515 	stw	zero,20(sp)
 821e984:	d8000415 	stw	zero,16(sp)
 821e988:	e0c00517 	ldw	r3,20(fp)
 821e98c:	d8c00315 	stw	r3,12(sp)
 821e990:	e0c00417 	ldw	r3,16(fp)
 821e994:	d8c00215 	stw	r3,8(sp)
 821e998:	e0c00317 	ldw	r3,12(fp)
 821e99c:	d8c00115 	stw	r3,4(sp)
 821e9a0:	d8800015 	stw	r2,0(sp)
 821e9a4:	e1fffd17 	ldw	r7,-12(fp)
 821e9a8:	e1bffc17 	ldw	r6,-16(fp)
 821e9ac:	e17ffb17 	ldw	r5,-20(fp)
 821e9b0:	e13ffa17 	ldw	r4,-24(fp)
 821e9b4:	821eab00 	call	821eab0 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
 821e9b8:	0001883a 	nop
 821e9bc:	e037883a 	mov	sp,fp
 821e9c0:	dfc00117 	ldw	ra,4(sp)
 821e9c4:	df000017 	ldw	fp,0(sp)
 821e9c8:	dec00204 	addi	sp,sp,8
 821e9cc:	f800283a 	ret

0821e9d0 <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
 821e9d0:	defffc04 	addi	sp,sp,-16
 821e9d4:	df000315 	stw	fp,12(sp)
 821e9d8:	df000304 	addi	fp,sp,12
 821e9dc:	e13ffe15 	stw	r4,-8(fp)
 821e9e0:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821e9e4:	e0bffe17 	ldw	r2,-8(fp)
 821e9e8:	10800317 	ldw	r2,12(r2)
 821e9ec:	10800404 	addi	r2,r2,16
 821e9f0:	10800037 	ldwio	r2,0(r2)
 821e9f4:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
 821e9f8:	e0fffd17 	ldw	r3,-12(fp)
 821e9fc:	00a00434 	movhi	r2,32784
 821ea00:	10bfffc4 	addi	r2,r2,-1
 821ea04:	1884703a 	and	r2,r3,r2
 821ea08:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
 821ea0c:	e0bfff17 	ldw	r2,-4(fp)
 821ea10:	1004953a 	slli	r2,r2,20
 821ea14:	10dffc2c 	andhi	r3,r2,32752

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
 821ea18:	e0bffd17 	ldw	r2,-12(fp)
 821ea1c:	1884b03a 	or	r2,r3,r2
 821ea20:	10800134 	orhi	r2,r2,4
 821ea24:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821ea28:	e0bffe17 	ldw	r2,-8(fp)
 821ea2c:	10800317 	ldw	r2,12(r2)
 821ea30:	10800404 	addi	r2,r2,16
 821ea34:	e0fffd17 	ldw	r3,-12(fp)
 821ea38:	10c00035 	stwio	r3,0(r2)
  
  return;
 821ea3c:	0001883a 	nop
}
 821ea40:	e037883a 	mov	sp,fp
 821ea44:	df000017 	ldw	fp,0(sp)
 821ea48:	dec00104 	addi	sp,sp,4
 821ea4c:	f800283a 	ret

0821ea50 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
 821ea50:	defffd04 	addi	sp,sp,-12
 821ea54:	df000215 	stw	fp,8(sp)
 821ea58:	df000204 	addi	fp,sp,8
 821ea5c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821ea60:	e0bfff17 	ldw	r2,-4(fp)
 821ea64:	10800317 	ldw	r2,12(r2)
 821ea68:	10800404 	addi	r2,r2,16
 821ea6c:	10800037 	ldwio	r2,0(r2)
 821ea70:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
 821ea74:	e0fffe17 	ldw	r3,-8(fp)
 821ea78:	00bfff34 	movhi	r2,65532
 821ea7c:	10bfffc4 	addi	r2,r2,-1
 821ea80:	1884703a 	and	r2,r3,r2
 821ea84:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 821ea88:	e0bfff17 	ldw	r2,-4(fp)
 821ea8c:	10800317 	ldw	r2,12(r2)
 821ea90:	10800404 	addi	r2,r2,16
 821ea94:	e0fffe17 	ldw	r3,-8(fp)
 821ea98:	10c00035 	stwio	r3,0(r2)
  
  return;
 821ea9c:	0001883a 	nop
}
 821eaa0:	e037883a 	mov	sp,fp
 821eaa4:	df000017 	ldw	fp,0(sp)
 821eaa8:	dec00104 	addi	sp,sp,4
 821eaac:	f800283a 	ret

0821eab0 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
 821eab0:	defff804 	addi	sp,sp,-32
 821eab4:	dfc00715 	stw	ra,28(sp)
 821eab8:	df000615 	stw	fp,24(sp)
 821eabc:	df000604 	addi	fp,sp,24
 821eac0:	e13ffa15 	stw	r4,-24(fp)
 821eac4:	e17ffb15 	stw	r5,-20(fp)
 821eac8:	e1bffc15 	stw	r6,-16(fp)
 821eacc:	e1fffd15 	stw	r7,-12(fp)
 821ead0:	e0c00217 	ldw	r3,8(fp)
 821ead4:	e0800817 	ldw	r2,32(fp)
 821ead8:	e0fffe0d 	sth	r3,-8(fp)
 821eadc:	e0bfff05 	stb	r2,-4(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
 821eae0:	e0bffb17 	ldw	r2,-20(fp)
 821eae4:	108007c4 	addi	r2,r2,31
 821eae8:	e0fffb17 	ldw	r3,-20(fp)
 821eaec:	18c007c3 	ldbu	r3,31(r3)
 821eaf0:	19003fcc 	andi	r4,r3,255
 821eaf4:	00ffdfc4 	movi	r3,-129
 821eaf8:	20c6703a 	and	r3,r4,r3
 821eafc:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
 821eb00:	e0bffa17 	ldw	r2,-24(fp)
 821eb04:	e0fffc17 	ldw	r3,-16(fp)
 821eb08:	19403fcc 	andi	r5,r3,255
 821eb0c:	10c00003 	ldbu	r3,0(r2)
 821eb10:	1806703a 	and	r3,r3,zero
 821eb14:	1809883a 	mov	r4,r3
 821eb18:	2807883a 	mov	r3,r5
 821eb1c:	20c6b03a 	or	r3,r4,r3
 821eb20:	10c00005 	stb	r3,0(r2)
 821eb24:	e0fffc17 	ldw	r3,-16(fp)
 821eb28:	1806d23a 	srli	r3,r3,8
 821eb2c:	19403fcc 	andi	r5,r3,255
 821eb30:	10c00043 	ldbu	r3,1(r2)
 821eb34:	1806703a 	and	r3,r3,zero
 821eb38:	1809883a 	mov	r4,r3
 821eb3c:	2807883a 	mov	r3,r5
 821eb40:	20c6b03a 	or	r3,r4,r3
 821eb44:	10c00045 	stb	r3,1(r2)
 821eb48:	e0fffc17 	ldw	r3,-16(fp)
 821eb4c:	1806d43a 	srli	r3,r3,16
 821eb50:	19403fcc 	andi	r5,r3,255
 821eb54:	10c00083 	ldbu	r3,2(r2)
 821eb58:	1806703a 	and	r3,r3,zero
 821eb5c:	1809883a 	mov	r4,r3
 821eb60:	2807883a 	mov	r3,r5
 821eb64:	20c6b03a 	or	r3,r4,r3
 821eb68:	10c00085 	stb	r3,2(r2)
 821eb6c:	e0fffc17 	ldw	r3,-16(fp)
 821eb70:	180ad63a 	srli	r5,r3,24
 821eb74:	10c000c3 	ldbu	r3,3(r2)
 821eb78:	1806703a 	and	r3,r3,zero
 821eb7c:	1809883a 	mov	r4,r3
 821eb80:	2807883a 	mov	r3,r5
 821eb84:	20c6b03a 	or	r3,r4,r3
 821eb88:	10c000c5 	stb	r3,3(r2)
  desc->write_addr               = write_addr;
 821eb8c:	e0bffa17 	ldw	r2,-24(fp)
 821eb90:	e0fffd17 	ldw	r3,-12(fp)
 821eb94:	19403fcc 	andi	r5,r3,255
 821eb98:	10c00203 	ldbu	r3,8(r2)
 821eb9c:	1806703a 	and	r3,r3,zero
 821eba0:	1809883a 	mov	r4,r3
 821eba4:	2807883a 	mov	r3,r5
 821eba8:	20c6b03a 	or	r3,r4,r3
 821ebac:	10c00205 	stb	r3,8(r2)
 821ebb0:	e0fffd17 	ldw	r3,-12(fp)
 821ebb4:	1806d23a 	srli	r3,r3,8
 821ebb8:	19403fcc 	andi	r5,r3,255
 821ebbc:	10c00243 	ldbu	r3,9(r2)
 821ebc0:	1806703a 	and	r3,r3,zero
 821ebc4:	1809883a 	mov	r4,r3
 821ebc8:	2807883a 	mov	r3,r5
 821ebcc:	20c6b03a 	or	r3,r4,r3
 821ebd0:	10c00245 	stb	r3,9(r2)
 821ebd4:	e0fffd17 	ldw	r3,-12(fp)
 821ebd8:	1806d43a 	srli	r3,r3,16
 821ebdc:	19403fcc 	andi	r5,r3,255
 821ebe0:	10c00283 	ldbu	r3,10(r2)
 821ebe4:	1806703a 	and	r3,r3,zero
 821ebe8:	1809883a 	mov	r4,r3
 821ebec:	2807883a 	mov	r3,r5
 821ebf0:	20c6b03a 	or	r3,r4,r3
 821ebf4:	10c00285 	stb	r3,10(r2)
 821ebf8:	e0fffd17 	ldw	r3,-12(fp)
 821ebfc:	180ad63a 	srli	r5,r3,24
 821ec00:	10c002c3 	ldbu	r3,11(r2)
 821ec04:	1806703a 	and	r3,r3,zero
 821ec08:	1809883a 	mov	r4,r3
 821ec0c:	2807883a 	mov	r3,r5
 821ec10:	20c6b03a 	or	r3,r4,r3
 821ec14:	10c002c5 	stb	r3,11(r2)
  desc->next                     = (alt_u32 *) next;
 821ec18:	e0bffa17 	ldw	r2,-24(fp)
 821ec1c:	e0fffb17 	ldw	r3,-20(fp)
 821ec20:	19403fcc 	andi	r5,r3,255
 821ec24:	10c00403 	ldbu	r3,16(r2)
 821ec28:	1806703a 	and	r3,r3,zero
 821ec2c:	1809883a 	mov	r4,r3
 821ec30:	2807883a 	mov	r3,r5
 821ec34:	20c6b03a 	or	r3,r4,r3
 821ec38:	10c00405 	stb	r3,16(r2)
 821ec3c:	e0fffb17 	ldw	r3,-20(fp)
 821ec40:	1806d23a 	srli	r3,r3,8
 821ec44:	19403fcc 	andi	r5,r3,255
 821ec48:	10c00443 	ldbu	r3,17(r2)
 821ec4c:	1806703a 	and	r3,r3,zero
 821ec50:	1809883a 	mov	r4,r3
 821ec54:	2807883a 	mov	r3,r5
 821ec58:	20c6b03a 	or	r3,r4,r3
 821ec5c:	10c00445 	stb	r3,17(r2)
 821ec60:	e0fffb17 	ldw	r3,-20(fp)
 821ec64:	1806d43a 	srli	r3,r3,16
 821ec68:	19403fcc 	andi	r5,r3,255
 821ec6c:	10c00483 	ldbu	r3,18(r2)
 821ec70:	1806703a 	and	r3,r3,zero
 821ec74:	1809883a 	mov	r4,r3
 821ec78:	2807883a 	mov	r3,r5
 821ec7c:	20c6b03a 	or	r3,r4,r3
 821ec80:	10c00485 	stb	r3,18(r2)
 821ec84:	e0fffb17 	ldw	r3,-20(fp)
 821ec88:	180ad63a 	srli	r5,r3,24
 821ec8c:	10c004c3 	ldbu	r3,19(r2)
 821ec90:	1806703a 	and	r3,r3,zero
 821ec94:	1809883a 	mov	r4,r3
 821ec98:	2807883a 	mov	r3,r5
 821ec9c:	20c6b03a 	or	r3,r4,r3
 821eca0:	10c004c5 	stb	r3,19(r2)
  desc->read_addr_pad            = 0x0;
 821eca4:	e0bffa17 	ldw	r2,-24(fp)
 821eca8:	10c00103 	ldbu	r3,4(r2)
 821ecac:	1806703a 	and	r3,r3,zero
 821ecb0:	10c00105 	stb	r3,4(r2)
 821ecb4:	10c00143 	ldbu	r3,5(r2)
 821ecb8:	1806703a 	and	r3,r3,zero
 821ecbc:	10c00145 	stb	r3,5(r2)
 821ecc0:	10c00183 	ldbu	r3,6(r2)
 821ecc4:	1806703a 	and	r3,r3,zero
 821ecc8:	10c00185 	stb	r3,6(r2)
 821eccc:	10c001c3 	ldbu	r3,7(r2)
 821ecd0:	1806703a 	and	r3,r3,zero
 821ecd4:	10c001c5 	stb	r3,7(r2)
  desc->write_addr_pad           = 0x0;
 821ecd8:	e0bffa17 	ldw	r2,-24(fp)
 821ecdc:	10c00303 	ldbu	r3,12(r2)
 821ece0:	1806703a 	and	r3,r3,zero
 821ece4:	10c00305 	stb	r3,12(r2)
 821ece8:	10c00343 	ldbu	r3,13(r2)
 821ecec:	1806703a 	and	r3,r3,zero
 821ecf0:	10c00345 	stb	r3,13(r2)
 821ecf4:	10c00383 	ldbu	r3,14(r2)
 821ecf8:	1806703a 	and	r3,r3,zero
 821ecfc:	10c00385 	stb	r3,14(r2)
 821ed00:	10c003c3 	ldbu	r3,15(r2)
 821ed04:	1806703a 	and	r3,r3,zero
 821ed08:	10c003c5 	stb	r3,15(r2)
  desc->next_pad                 = 0x0;
 821ed0c:	e0bffa17 	ldw	r2,-24(fp)
 821ed10:	10c00503 	ldbu	r3,20(r2)
 821ed14:	1806703a 	and	r3,r3,zero
 821ed18:	10c00505 	stb	r3,20(r2)
 821ed1c:	10c00543 	ldbu	r3,21(r2)
 821ed20:	1806703a 	and	r3,r3,zero
 821ed24:	10c00545 	stb	r3,21(r2)
 821ed28:	10c00583 	ldbu	r3,22(r2)
 821ed2c:	1806703a 	and	r3,r3,zero
 821ed30:	10c00585 	stb	r3,22(r2)
 821ed34:	10c005c3 	ldbu	r3,23(r2)
 821ed38:	1806703a 	and	r3,r3,zero
 821ed3c:	10c005c5 	stb	r3,23(r2)
  desc->bytes_to_transfer        = length_or_eop;
 821ed40:	e0bffa17 	ldw	r2,-24(fp)
 821ed44:	e0fffe17 	ldw	r3,-8(fp)
 821ed48:	19403fcc 	andi	r5,r3,255
 821ed4c:	10c00603 	ldbu	r3,24(r2)
 821ed50:	1806703a 	and	r3,r3,zero
 821ed54:	1809883a 	mov	r4,r3
 821ed58:	2807883a 	mov	r3,r5
 821ed5c:	20c6b03a 	or	r3,r4,r3
 821ed60:	10c00605 	stb	r3,24(r2)
 821ed64:	e0fffe17 	ldw	r3,-8(fp)
 821ed68:	1806d23a 	srli	r3,r3,8
 821ed6c:	19403fcc 	andi	r5,r3,255
 821ed70:	10c00643 	ldbu	r3,25(r2)
 821ed74:	1806703a 	and	r3,r3,zero
 821ed78:	1809883a 	mov	r4,r3
 821ed7c:	2807883a 	mov	r3,r5
 821ed80:	20c6b03a 	or	r3,r4,r3
 821ed84:	10c00645 	stb	r3,25(r2)
  desc->actual_bytes_transferred = 0;
 821ed88:	e0bffa17 	ldw	r2,-24(fp)
 821ed8c:	10c00703 	ldbu	r3,28(r2)
 821ed90:	1806703a 	and	r3,r3,zero
 821ed94:	10c00705 	stb	r3,28(r2)
 821ed98:	10c00743 	ldbu	r3,29(r2)
 821ed9c:	1806703a 	and	r3,r3,zero
 821eda0:	10c00745 	stb	r3,29(r2)
  desc->status                   = 0x0;
 821eda4:	e0bffa17 	ldw	r2,-24(fp)
 821eda8:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
 821edac:	e0800617 	ldw	r2,24(fp)
 821edb0:	1007883a 	mov	r3,r2
 821edb4:	e0bffa17 	ldw	r2,-24(fp)
 821edb8:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
 821edbc:	e0800717 	ldw	r2,28(fp)
 821edc0:	1007883a 	mov	r3,r2
 821edc4:	e0bffa17 	ldw	r2,-24(fp)
 821edc8:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 821edcc:	e0800317 	ldw	r2,12(fp)
 821edd0:	10000226 	beq	r2,zero,821eddc <alt_avalon_sgdma_construct_descriptor_burst+0x32c>
 821edd4:	00bfe044 	movi	r2,-127
 821edd8:	00000106 	br	821ede0 <alt_avalon_sgdma_construct_descriptor_burst+0x330>
 821eddc:	00bfe004 	movi	r2,-128
 821ede0:	e0c00417 	ldw	r3,16(fp)
 821ede4:	18000226 	beq	r3,zero,821edf0 <alt_avalon_sgdma_construct_descriptor_burst+0x340>
 821ede8:	00c00084 	movi	r3,2
 821edec:	00000106 	br	821edf4 <alt_avalon_sgdma_construct_descriptor_burst+0x344>
 821edf0:	0007883a 	mov	r3,zero
 821edf4:	10c4b03a 	or	r2,r2,r3
 821edf8:	1007883a 	mov	r3,r2
 821edfc:	e0800517 	ldw	r2,20(fp)
 821ee00:	10000226 	beq	r2,zero,821ee0c <alt_avalon_sgdma_construct_descriptor_burst+0x35c>
 821ee04:	00800104 	movi	r2,4
 821ee08:	00000106 	br	821ee10 <alt_avalon_sgdma_construct_descriptor_burst+0x360>
 821ee0c:	0005883a 	mov	r2,zero
 821ee10:	1884b03a 	or	r2,r3,r2
 821ee14:	1007883a 	mov	r3,r2
 821ee18:	e0bfff03 	ldbu	r2,-4(fp)
 821ee1c:	10000426 	beq	r2,zero,821ee30 <alt_avalon_sgdma_construct_descriptor_burst+0x380>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
 821ee20:	e0bfff03 	ldbu	r2,-4(fp)
 821ee24:	108003cc 	andi	r2,r2,15
 821ee28:	100490fa 	slli	r2,r2,3
 821ee2c:	00000106 	br	821ee34 <alt_avalon_sgdma_construct_descriptor_burst+0x384>
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 821ee30:	0005883a 	mov	r2,zero
 821ee34:	1884b03a 	or	r2,r3,r2
 821ee38:	1007883a 	mov	r3,r2
 821ee3c:	e0bffa17 	ldw	r2,-24(fp)
 821ee40:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
 821ee44:	01400804 	movi	r5,32
 821ee48:	e13ffa17 	ldw	r4,-24(fp)
 821ee4c:	823bb7c0 	call	823bb7c <alt_dcache_flush>
}
 821ee50:	0001883a 	nop
 821ee54:	e037883a 	mov	sp,fp
 821ee58:	dfc00117 	ldw	ra,4(sp)
 821ee5c:	df000017 	ldw	fp,0(sp)
 821ee60:	dec00204 	addi	sp,sp,8
 821ee64:	f800283a 	ret

0821ee68 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
 821ee68:	defff904 	addi	sp,sp,-28
 821ee6c:	dfc00615 	stw	ra,24(sp)
 821ee70:	df000515 	stw	fp,20(sp)
 821ee74:	df000504 	addi	fp,sp,20
 821ee78:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
 821ee7c:	e0bfff17 	ldw	r2,-4(fp)
 821ee80:	e0bffb15 	stw	r2,-20(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 821ee84:	e0bffb17 	ldw	r2,-20(fp)
 821ee88:	10800317 	ldw	r2,12(r2)
 821ee8c:	10800404 	addi	r2,r2,16
 821ee90:	e0fffb17 	ldw	r3,-20(fp)
 821ee94:	18c00317 	ldw	r3,12(r3)
 821ee98:	18c00404 	addi	r3,r3,16
 821ee9c:	18c00037 	ldwio	r3,0(r3)
 821eea0:	18e00034 	orhi	r3,r3,32768
 821eea4:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 821eea8:	e0bffb17 	ldw	r2,-20(fp)
 821eeac:	10800317 	ldw	r2,12(r2)
 821eeb0:	10800404 	addi	r2,r2,16
 821eeb4:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
 821eeb8:	e0bffb17 	ldw	r2,-20(fp)
 821eebc:	10800917 	ldw	r2,36(r2)
 821eec0:	10001226 	beq	r2,zero,821ef0c <alt_avalon_sgdma_irq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821eec4:	0005303a 	rdctl	r2,status
 821eec8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821eecc:	e0fffd17 	ldw	r3,-12(fp)
 821eed0:	00bfff84 	movi	r2,-2
 821eed4:	1884703a 	and	r2,r3,r2
 821eed8:	1001703a 	wrctl	status,r2
  
  return context;
 821eedc:	e0bffd17 	ldw	r2,-12(fp)
    cpu_sr = alt_irq_disable_all();
 821eee0:	e0bffc15 	stw	r2,-16(fp)
    (dev->callback)(dev->callback_context);
 821eee4:	e0bffb17 	ldw	r2,-20(fp)
 821eee8:	10800917 	ldw	r2,36(r2)
 821eeec:	e0fffb17 	ldw	r3,-20(fp)
 821eef0:	18c00a17 	ldw	r3,40(r3)
 821eef4:	1809883a 	mov	r4,r3
 821eef8:	103ee83a 	callr	r2
 821eefc:	e0bffc17 	ldw	r2,-16(fp)
 821ef00:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821ef04:	e0bffe17 	ldw	r2,-8(fp)
 821ef08:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
 821ef0c:	0001883a 	nop
 821ef10:	e037883a 	mov	sp,fp
 821ef14:	dfc00117 	ldw	ra,4(sp)
 821ef18:	df000017 	ldw	fp,0(sp)
 821ef1c:	dec00204 	addi	sp,sp,8
 821ef20:	f800283a 	ret

0821ef24 <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
 821ef24:	defffa04 	addi	sp,sp,-24
 821ef28:	dfc00515 	stw	ra,20(sp)
 821ef2c:	df000415 	stw	fp,16(sp)
 821ef30:	df000404 	addi	fp,sp,16
 821ef34:	e13ffd15 	stw	r4,-12(fp)
 821ef38:	e17ffe15 	stw	r5,-8(fp)
 821ef3c:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821ef40:	e0bffd17 	ldw	r2,-12(fp)
 821ef44:	10800317 	ldw	r2,12(r2)
 821ef48:	10800404 	addi	r2,r2,16
 821ef4c:	00c00074 	movhi	r3,1
 821ef50:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 821ef54:	e0bffd17 	ldw	r2,-12(fp)
 821ef58:	10800317 	ldw	r2,12(r2)
 821ef5c:	10800404 	addi	r2,r2,16
 821ef60:	00c00074 	movhi	r3,1
 821ef64:	10c00035 	stwio	r3,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
 821ef68:	e0bffd17 	ldw	r2,-12(fp)
 821ef6c:	10800317 	ldw	r2,12(r2)
 821ef70:	10800404 	addi	r2,r2,16
 821ef74:	0007883a 	mov	r3,zero
 821ef78:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 821ef7c:	e0bffd17 	ldw	r2,-12(fp)
 821ef80:	10800317 	ldw	r2,12(r2)
 821ef84:	00c03fc4 	movi	r3,255
 821ef88:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
 821ef8c:	d1602b04 	addi	r5,gp,-32596
 821ef90:	e13ffd17 	ldw	r4,-12(fp)
 821ef94:	823bc5c0 	call	823bc5c <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
 821ef98:	d8000015 	stw	zero,0(sp)
 821ef9c:	e1fffd17 	ldw	r7,-12(fp)
 821efa0:	018208b4 	movhi	r6,2082
 821efa4:	31bb9a04 	addi	r6,r6,-4504
 821efa8:	e17fff17 	ldw	r5,-4(fp)
 821efac:	e13ffe17 	ldw	r4,-8(fp)
 821efb0:	823be500 	call	823be50 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
 821efb4:	0001883a 	nop
 821efb8:	e037883a 	mov	sp,fp
 821efbc:	dfc00117 	ldw	ra,4(sp)
 821efc0:	df000017 	ldw	fp,0(sp)
 821efc4:	dec00204 	addi	sp,sp,8
 821efc8:	f800283a 	ret

0821efcc <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 821efcc:	defffa04 	addi	sp,sp,-24
 821efd0:	dfc00515 	stw	ra,20(sp)
 821efd4:	df000415 	stw	fp,16(sp)
 821efd8:	df000404 	addi	fp,sp,16
 821efdc:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 821efe0:	0007883a 	mov	r3,zero
 821efe4:	e0bfff17 	ldw	r2,-4(fp)
 821efe8:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 821efec:	e0bfff17 	ldw	r2,-4(fp)
 821eff0:	10800104 	addi	r2,r2,4
 821eff4:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 821eff8:	0005303a 	rdctl	r2,status
 821effc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 821f000:	e0fffd17 	ldw	r3,-12(fp)
 821f004:	00bfff84 	movi	r2,-2
 821f008:	1884703a 	and	r2,r3,r2
 821f00c:	1001703a 	wrctl	status,r2
  
  return context;
 821f010:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 821f014:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
 821f018:	823c6f00 	call	823c6f0 <alt_tick>
 821f01c:	e0bffc17 	ldw	r2,-16(fp)
 821f020:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 821f024:	e0bffe17 	ldw	r2,-8(fp)
 821f028:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 821f02c:	0001883a 	nop
 821f030:	e037883a 	mov	sp,fp
 821f034:	dfc00117 	ldw	ra,4(sp)
 821f038:	df000017 	ldw	fp,0(sp)
 821f03c:	dec00204 	addi	sp,sp,8
 821f040:	f800283a 	ret

0821f044 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 821f044:	defff804 	addi	sp,sp,-32
 821f048:	dfc00715 	stw	ra,28(sp)
 821f04c:	df000615 	stw	fp,24(sp)
 821f050:	df000604 	addi	fp,sp,24
 821f054:	e13ffc15 	stw	r4,-16(fp)
 821f058:	e17ffd15 	stw	r5,-12(fp)
 821f05c:	e1bffe15 	stw	r6,-8(fp)
 821f060:	e1ffff15 	stw	r7,-4(fp)
 821f064:	e0bfff17 	ldw	r2,-4(fp)
 821f068:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 821f06c:	d0a0b817 	ldw	r2,-32032(gp)
 821f070:	1000021e 	bne	r2,zero,821f07c <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
 821f074:	e0bffb17 	ldw	r2,-20(fp)
 821f078:	d0a0b815 	stw	r2,-32032(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 821f07c:	e0bffc17 	ldw	r2,-16(fp)
 821f080:	10800104 	addi	r2,r2,4
 821f084:	00c001c4 	movi	r3,7
 821f088:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 821f08c:	d8000015 	stw	zero,0(sp)
 821f090:	e1fffc17 	ldw	r7,-16(fp)
 821f094:	018208b4 	movhi	r6,2082
 821f098:	31bbf304 	addi	r6,r6,-4148
 821f09c:	e17ffe17 	ldw	r5,-8(fp)
 821f0a0:	e13ffd17 	ldw	r4,-12(fp)
 821f0a4:	823be500 	call	823be50 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 821f0a8:	0001883a 	nop
 821f0ac:	e037883a 	mov	sp,fp
 821f0b0:	dfc00117 	ldw	ra,4(sp)
 821f0b4:	df000017 	ldw	fp,0(sp)
 821f0b8:	dec00204 	addi	sp,sp,8
 821f0bc:	f800283a 	ret

0821f0c0 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
 821f0c0:	defffb04 	addi	sp,sp,-20
 821f0c4:	df000115 	stw	fp,4(sp)
 821f0c8:	df000104 	addi	fp,sp,4
 821f0cc:	e13fff15 	stw	r4,-4(fp)
 821f0d0:	e1400115 	stw	r5,4(fp)
 821f0d4:	e1800215 	stw	r6,8(fp)
 821f0d8:	e1c00315 	stw	r7,12(fp)
 821f0dc:	0001883a 	nop
 821f0e0:	e037883a 	mov	sp,fp
 821f0e4:	df000017 	ldw	fp,0(sp)
 821f0e8:	dec00404 	addi	sp,sp,16
 821f0ec:	f800283a 	ret

0821f0f0 <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
 821f0f0:	defffb04 	addi	sp,sp,-20
 821f0f4:	df000415 	stw	fp,16(sp)
 821f0f8:	df000404 	addi	fp,sp,16
 821f0fc:	e13ffc15 	stw	r4,-16(fp)
 821f100:	e17ffd15 	stw	r5,-12(fp)
 821f104:	e1bffe15 	stw	r6,-8(fp)
 821f108:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
 821f10c:	e0fffd17 	ldw	r3,-12(fp)
 821f110:	e0bffc17 	ldw	r2,-16(fp)
 821f114:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
 821f118:	e0fffe17 	ldw	r3,-8(fp)
 821f11c:	e0bffc17 	ldw	r2,-16(fp)
 821f120:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
 821f124:	e0ffff17 	ldw	r3,-4(fp)
 821f128:	e0bffc17 	ldw	r2,-16(fp)
 821f12c:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
 821f130:	e0c00117 	ldw	r3,4(fp)
 821f134:	e0bffc17 	ldw	r2,-16(fp)
 821f138:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
 821f13c:	0005883a 	mov	r2,zero
}
 821f140:	e037883a 	mov	sp,fp
 821f144:	df000017 	ldw	fp,0(sp)
 821f148:	dec00104 	addi	sp,sp,4
 821f14c:	f800283a 	ret

0821f150 <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
 821f150:	defffa04 	addi	sp,sp,-24
 821f154:	dfc00515 	stw	ra,20(sp)
 821f158:	df000415 	stw	fp,16(sp)
 821f15c:	df000404 	addi	fp,sp,16
 821f160:	e13ffe15 	stw	r4,-8(fp)
 821f164:	e17fff15 	stw	r5,-4(fp)

  alt_32 timeout;
  alt_u8 result = 0;
 821f168:	e03ffd05 	stb	zero,-12(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
 821f16c:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 821f170:	00000b06 	br	821f1a0 <tse_mac_sTxWrite+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 821f174:	e0fffc17 	ldw	r3,-16(fp)
 821f178:	18800044 	addi	r2,r3,1
 821f17c:	e0bffc15 	stw	r2,-16(fp)
 821f180:	008003f4 	movhi	r2,15
 821f184:	10909004 	addi	r2,r2,16960
 821f188:	1880051e 	bne	r3,r2,821f1a0 <tse_mac_sTxWrite+0x50>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
 821f18c:	01020974 	movhi	r4,2085
 821f190:	2137e504 	addi	r4,r4,-8300
 821f194:	82035a00 	call	82035a0 <puts>
            return ENP_RESOURCE;  // avoid being stuck here
 821f198:	00bffa84 	movi	r2,-22
 821f19c:	00002006 	br	821f220 <tse_mac_sTxWrite+0xd0>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 821f1a0:	e0bffe17 	ldw	r2,-8(fp)
 821f1a4:	10800117 	ldw	r2,4(r2)
 821f1a8:	10800317 	ldw	r2,12(r2)
 821f1ac:	10800037 	ldwio	r2,0(r2)
 821f1b0:	1080040c 	andi	r2,r2,16
 821f1b4:	103fef1e 	bne	r2,zero,821f174 <tse_mac_sTxWrite+0x24>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
 821f1b8:	e0bffe17 	ldw	r2,-8(fp)
 821f1bc:	10800117 	ldw	r2,4(r2)
 821f1c0:	10800317 	ldw	r2,12(r2)
 821f1c4:	10800404 	addi	r2,r2,16
 821f1c8:	0007883a 	mov	r3,zero
 821f1cc:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
 821f1d0:	e0bffe17 	ldw	r2,-8(fp)
 821f1d4:	10800117 	ldw	r2,4(r2)
 821f1d8:	10800317 	ldw	r2,12(r2)
 821f1dc:	00c03fc4 	movi	r3,255
 821f1e0:	10c00035 	stwio	r3,0(r2)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
 821f1e4:	e0bffe17 	ldw	r2,-8(fp)
 821f1e8:	10800117 	ldw	r2,4(r2)
 821f1ec:	e17fff17 	ldw	r5,-4(fp)
 821f1f0:	1009883a 	mov	r4,r2
 821f1f4:	821e3980 	call	821e398 <alt_avalon_sgdma_do_sync_transfer>
 821f1f8:	e0bffd05 	stb	r2,-12(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  if (result != 0)
 821f1fc:	e0bffd03 	ldbu	r2,-12(fp)
 821f200:	10000226 	beq	r2,zero,821f20c <tse_mac_sTxWrite+0xbc>
    return -1;
 821f204:	00bfffc4 	movi	r2,-1
 821f208:	00000506 	br	821f220 <tse_mac_sTxWrite+0xd0>
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
 821f20c:	e0bfff17 	ldw	r2,-4(fp)
 821f210:	10800704 	addi	r2,r2,28
 821f214:	10800037 	ldwio	r2,0(r2)
 821f218:	e0bffd8d 	sth	r2,-10(fp)

  return actualBytesTransferred;
 821f21c:	e0bffd8b 	ldhu	r2,-10(fp)
}
 821f220:	e037883a 	mov	sp,fp
 821f224:	dfc00117 	ldw	ra,4(sp)
 821f228:	df000017 	ldw	fp,0(sp)
 821f22c:	dec00204 	addi	sp,sp,8
 821f230:	f800283a 	ret

0821f234 <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
 821f234:	defffa04 	addi	sp,sp,-24
 821f238:	dfc00515 	stw	ra,20(sp)
 821f23c:	df000415 	stw	fp,16(sp)
 821f240:	df000404 	addi	fp,sp,16
 821f244:	e13ffe15 	stw	r4,-8(fp)
 821f248:	e17fff15 	stw	r5,-4(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
 821f24c:	e03ffd05 	stb	zero,-12(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
 821f250:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 821f254:	00000b06 	br	821f284 <tse_mac_aRxRead+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 821f258:	e0fffc17 	ldw	r3,-16(fp)
 821f25c:	18800044 	addi	r2,r3,1
 821f260:	e0bffc15 	stw	r2,-16(fp)
 821f264:	008003f4 	movhi	r2,15
 821f268:	10909004 	addi	r2,r2,16960
 821f26c:	1880051e 	bne	r3,r2,821f284 <tse_mac_aRxRead+0x50>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
 821f270:	01020974 	movhi	r4,2085
 821f274:	2137ec04 	addi	r4,r4,-8272
 821f278:	82035a00 	call	82035a0 <puts>
        return ENP_RESOURCE;  // avoid being stuck here
 821f27c:	00bffa84 	movi	r2,-22
 821f280:	00001106 	br	821f2c8 <tse_mac_aRxRead+0x94>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 821f284:	e0bffe17 	ldw	r2,-8(fp)
 821f288:	10800217 	ldw	r2,8(r2)
 821f28c:	10800317 	ldw	r2,12(r2)
 821f290:	10800037 	ldwio	r2,0(r2)
 821f294:	1080040c 	andi	r2,r2,16
 821f298:	103fef1e 	bne	r2,zero,821f258 <tse_mac_aRxRead+0x24>
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
 821f29c:	e0bffe17 	ldw	r2,-8(fp)
 821f2a0:	10800217 	ldw	r2,8(r2)
 821f2a4:	e17fff17 	ldw	r5,-4(fp)
 821f2a8:	1009883a 	mov	r4,r2
 821f2ac:	821e2740 	call	821e274 <alt_avalon_sgdma_do_async_transfer>
 821f2b0:	e0bffd05 	stb	r2,-12(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);
  
  if (result != 0)
 821f2b4:	e0bffd03 	ldbu	r2,-12(fp)
 821f2b8:	10000226 	beq	r2,zero,821f2c4 <tse_mac_aRxRead+0x90>
    return -1;
 821f2bc:	00bfffc4 	movi	r2,-1
 821f2c0:	00000106 	br	821f2c8 <tse_mac_aRxRead+0x94>
 
  return SUCCESS;
 821f2c4:	0005883a 	mov	r2,zero
}
 821f2c8:	e037883a 	mov	sp,fp
 821f2cc:	dfc00117 	ldw	ra,4(sp)
 821f2d0:	df000017 	ldw	fp,0(sp)
 821f2d4:	dec00204 	addi	sp,sp,8
 821f2d8:	f800283a 	ret

0821f2dc <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
 821f2dc:	defffc04 	addi	sp,sp,-16
 821f2e0:	df000315 	stw	fp,12(sp)
 821f2e4:	df000304 	addi	fp,sp,12
 821f2e8:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 821f2ec:	e0bfff17 	ldw	r2,-4(fp)
 821f2f0:	10800204 	addi	r2,r2,8
 821f2f4:	10800037 	ldwio	r2,0(r2)
 821f2f8:	e0bffe15 	stw	r2,-8(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
 821f2fc:	e0bfff17 	ldw	r2,-4(fp)
 821f300:	10800204 	addi	r2,r2,8
 821f304:	00c80204 	movi	r3,8200
 821f308:	10c00035 	stwio	r3,0(r2)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
 821f30c:	e03ffd15 	stw	zero,-12(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
 821f310:	00000306 	br	821f320 <tse_mac_SwReset+0x44>
 821f314:	e0bffd17 	ldw	r2,-12(fp)
 821f318:	10800044 	addi	r2,r2,1
 821f31c:	e0bffd15 	stw	r2,-12(fp)
 821f320:	e0bfff17 	ldw	r2,-4(fp)
 821f324:	10800204 	addi	r2,r2,8
 821f328:	10800037 	ldwio	r2,0(r2)
 821f32c:	1088000c 	andi	r2,r2,8192
 821f330:	10000326 	beq	r2,zero,821f340 <tse_mac_SwReset+0x64>
 821f334:	e0bffd17 	ldw	r2,-12(fp)
 821f338:	1089c410 	cmplti	r2,r2,10000
 821f33c:	103ff51e 	bne	r2,zero,821f314 <tse_mac_SwReset+0x38>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
 821f340:	e0bfff17 	ldw	r2,-4(fp)
 821f344:	10800204 	addi	r2,r2,8
 821f348:	e0fffe17 	ldw	r3,-8(fp)
 821f34c:	10c00035 	stwio	r3,0(r2)
    return SUCCESS;
 821f350:	0005883a 	mov	r2,zero
}
 821f354:	e037883a 	mov	sp,fp
 821f358:	df000017 	ldw	fp,0(sp)
 821f35c:	dec00104 	addi	sp,sp,4
 821f360:	f800283a 	ret

0821f364 <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
 821f364:	defffd04 	addi	sp,sp,-12
 821f368:	df000215 	stw	fp,8(sp)
 821f36c:	df000204 	addi	fp,sp,8
 821f370:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 821f374:	e0bfff17 	ldw	r2,-4(fp)
 821f378:	10800204 	addi	r2,r2,8
 821f37c:	10800037 	ldwio	r2,0(r2)
 821f380:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
 821f384:	e0fffe17 	ldw	r3,-8(fp)
 821f388:	00bffdc4 	movi	r2,-9
 821f38c:	1884703a 	and	r2,r3,r2
 821f390:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 821f394:	e0bfff17 	ldw	r2,-4(fp)
 821f398:	10800204 	addi	r2,r2,8
 821f39c:	e0fffe17 	ldw	r3,-8(fp)
 821f3a0:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 821f3a4:	0005883a 	mov	r2,zero
}
 821f3a8:	e037883a 	mov	sp,fp
 821f3ac:	df000017 	ldw	fp,0(sp)
 821f3b0:	dec00104 	addi	sp,sp,4
 821f3b4:	f800283a 	ret

0821f3b8 <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
 821f3b8:	defffd04 	addi	sp,sp,-12
 821f3bc:	df000215 	stw	fp,8(sp)
 821f3c0:	df000204 	addi	fp,sp,8
 821f3c4:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 821f3c8:	e0bfff17 	ldw	r2,-4(fp)
 821f3cc:	10800204 	addi	r2,r2,8
 821f3d0:	10800037 	ldwio	r2,0(r2)
 821f3d4:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 821f3d8:	e0bffe17 	ldw	r2,-8(fp)
 821f3dc:	10800214 	ori	r2,r2,8
 821f3e0:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 821f3e4:	e0bfff17 	ldw	r2,-4(fp)
 821f3e8:	10800204 	addi	r2,r2,8
 821f3ec:	e0fffe17 	ldw	r3,-8(fp)
 821f3f0:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 821f3f4:	0005883a 	mov	r2,zero
}
 821f3f8:	e037883a 	mov	sp,fp
 821f3fc:	df000017 	ldw	fp,0(sp)
 821f400:	dec00104 	addi	sp,sp,4
 821f404:	f800283a 	ret

0821f408 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
 821f408:	defffb04 	addi	sp,sp,-20
 821f40c:	dfc00415 	stw	ra,16(sp)
 821f410:	df000315 	stw	fp,12(sp)
 821f414:	dc000215 	stw	r16,8(sp)
 821f418:	df000304 	addi	fp,sp,12
 821f41c:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 821f420:	e03ffd15 	stw	zero,-12(fp)
 821f424:	00002906 	br	821f4cc <alt_tse_phy_add_profile+0xc4>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
 821f428:	008209b4 	movhi	r2,2086
 821f42c:	10b70304 	addi	r2,r2,-9204
 821f430:	e0fffd17 	ldw	r3,-12(fp)
 821f434:	18c7883a 	add	r3,r3,r3
 821f438:	18c7883a 	add	r3,r3,r3
 821f43c:	10c5883a 	add	r2,r2,r3
 821f440:	10800017 	ldw	r2,0(r2)
 821f444:	10c01417 	ldw	r3,80(r2)
 821f448:	e0bffe17 	ldw	r2,-8(fp)
 821f44c:	10801417 	ldw	r2,80(r2)
 821f450:	18801b1e 	bne	r3,r2,821f4c0 <alt_tse_phy_add_profile+0xb8>
 821f454:	008209b4 	movhi	r2,2086
 821f458:	10b70304 	addi	r2,r2,-9204
 821f45c:	e0fffd17 	ldw	r3,-12(fp)
 821f460:	18c7883a 	add	r3,r3,r3
 821f464:	18c7883a 	add	r3,r3,r3
 821f468:	10c5883a 	add	r2,r2,r3
 821f46c:	10800017 	ldw	r2,0(r2)
 821f470:	10c01503 	ldbu	r3,84(r2)
 821f474:	e0bffe17 	ldw	r2,-8(fp)
 821f478:	10801503 	ldbu	r2,84(r2)
 821f47c:	18c03fcc 	andi	r3,r3,255
 821f480:	10803fcc 	andi	r2,r2,255
 821f484:	18800e1e 	bne	r3,r2,821f4c0 <alt_tse_phy_add_profile+0xb8>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
 821f488:	e0bffe17 	ldw	r2,-8(fp)
 821f48c:	10801417 	ldw	r2,80(r2)
 821f490:	1007883a 	mov	r3,r2
 821f494:	e0bffe17 	ldw	r2,-8(fp)
 821f498:	10801503 	ldbu	r2,84(r2)
 821f49c:	10803fcc 	andi	r2,r2,255
 821f4a0:	100d883a 	mov	r6,r2
 821f4a4:	180b883a 	mov	r5,r3
 821f4a8:	01020974 	movhi	r4,2085
 821f4ac:	2137f304 	addi	r4,r4,-8244
 821f4b0:	820331c0 	call	820331c <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
 821f4b4:	01020974 	movhi	r4,2085
 821f4b8:	21380704 	addi	r4,r4,-8164
 821f4bc:	82035a00 	call	82035a0 <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 821f4c0:	e0bffd17 	ldw	r2,-12(fp)
 821f4c4:	10800044 	addi	r2,r2,1
 821f4c8:	e0bffd15 	stw	r2,-12(fp)
 821f4cc:	d0a07f03 	ldbu	r2,-32260(gp)
 821f4d0:	10803fcc 	andi	r2,r2,255
 821f4d4:	e0fffd17 	ldw	r3,-12(fp)
 821f4d8:	18bfd316 	blt	r3,r2,821f428 <alt_tse_phy_add_profile+0x20>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
 821f4dc:	d0a07f03 	ldbu	r2,-32260(gp)
 821f4e0:	14003fcc 	andi	r16,r2,255
 821f4e4:	01001904 	movi	r4,100
 821f4e8:	824b6900 	call	824b690 <malloc>
 821f4ec:	1009883a 	mov	r4,r2
 821f4f0:	008209b4 	movhi	r2,2086
 821f4f4:	10b70304 	addi	r2,r2,-9204
 821f4f8:	8407883a 	add	r3,r16,r16
 821f4fc:	18c7883a 	add	r3,r3,r3
 821f500:	10c5883a 	add	r2,r2,r3
 821f504:	11000015 	stw	r4,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
 821f508:	d0a07f03 	ldbu	r2,-32260(gp)
 821f50c:	10c03fcc 	andi	r3,r2,255
 821f510:	008209b4 	movhi	r2,2086
 821f514:	10b70304 	addi	r2,r2,-9204
 821f518:	18c7883a 	add	r3,r3,r3
 821f51c:	18c7883a 	add	r3,r3,r3
 821f520:	10c5883a 	add	r2,r2,r3
 821f524:	10800017 	ldw	r2,0(r2)
 821f528:	1000081e 	bne	r2,zero,821f54c <alt_tse_phy_add_profile+0x144>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
 821f52c:	d0a07f03 	ldbu	r2,-32260(gp)
 821f530:	10803fcc 	andi	r2,r2,255
 821f534:	100b883a 	mov	r5,r2
 821f538:	01020974 	movhi	r4,2085
 821f53c:	21381f04 	addi	r4,r4,-8068
 821f540:	820331c0 	call	820331c <printf>
        return ALTERA_TSE_MALLOC_FAILED;
 821f544:	00bfffc4 	movi	r2,-1
 821f548:	00002206 	br	821f5d4 <alt_tse_phy_add_profile+0x1cc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
 821f54c:	d0a07f03 	ldbu	r2,-32260(gp)
 821f550:	10c03fcc 	andi	r3,r2,255
 821f554:	008209b4 	movhi	r2,2086
 821f558:	10b70304 	addi	r2,r2,-9204
 821f55c:	18c7883a 	add	r3,r3,r3
 821f560:	18c7883a 	add	r3,r3,r3
 821f564:	10c5883a 	add	r2,r2,r3
 821f568:	10c00017 	ldw	r3,0(r2)
 821f56c:	e0bffe17 	ldw	r2,-8(fp)
 821f570:	1009883a 	mov	r4,r2
 821f574:	00801904 	movi	r2,100
 821f578:	100d883a 	mov	r6,r2
 821f57c:	200b883a 	mov	r5,r4
 821f580:	1809883a 	mov	r4,r3
 821f584:	8202e8c0 	call	8202e8c <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
 821f588:	d0a07f03 	ldbu	r2,-32260(gp)
 821f58c:	10c03fcc 	andi	r3,r2,255
 821f590:	008209b4 	movhi	r2,2086
 821f594:	10b70304 	addi	r2,r2,-9204
 821f598:	18c7883a 	add	r3,r3,r3
 821f59c:	18c7883a 	add	r3,r3,r3
 821f5a0:	10c5883a 	add	r2,r2,r3
 821f5a4:	10800017 	ldw	r2,0(r2)
 821f5a8:	1007883a 	mov	r3,r2
 821f5ac:	e0bffe17 	ldw	r2,-8(fp)
 821f5b0:	100b883a 	mov	r5,r2
 821f5b4:	1809883a 	mov	r4,r3
 821f5b8:	824b6b80 	call	824b6b8 <strcpy>
    
    phy_profile_count++;
 821f5bc:	d0a07f03 	ldbu	r2,-32260(gp)
 821f5c0:	10800044 	addi	r2,r2,1
 821f5c4:	d0a07f05 	stb	r2,-32260(gp)
    
    return phy_profile_count - 1;
 821f5c8:	d0a07f03 	ldbu	r2,-32260(gp)
 821f5cc:	10803fcc 	andi	r2,r2,255
 821f5d0:	10bfffc4 	addi	r2,r2,-1
}
 821f5d4:	e6ffff04 	addi	sp,fp,-4
 821f5d8:	dfc00217 	ldw	ra,8(sp)
 821f5dc:	df000117 	ldw	fp,4(sp)
 821f5e0:	dc000017 	ldw	r16,0(sp)
 821f5e4:	dec00304 	addi	sp,sp,12
 821f5e8:	f800283a 	ret

0821f5ec <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
 821f5ec:	defff204 	addi	sp,sp,-56
 821f5f0:	dfc00d15 	stw	ra,52(sp)
 821f5f4:	df000c15 	stw	fp,48(sp)
 821f5f8:	dc000b15 	stw	r16,44(sp)
 821f5fc:	df000c04 	addi	fp,sp,48
 821f600:	e13ffb15 	stw	r4,-20(fp)
 821f604:	e17ffc15 	stw	r5,-16(fp)
 821f608:	e1bffd15 	stw	r6,-12(fp)
 821f60c:	e1fffe15 	stw	r7,-8(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
 821f610:	e0bffb17 	ldw	r2,-20(fp)
 821f614:	e0bffa15 	stw	r2,-24(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
 821f618:	e0bffc17 	ldw	r2,-16(fp)
 821f61c:	e0bff615 	stw	r2,-40(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
 821f620:	e0bffd17 	ldw	r2,-12(fp)
 821f624:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
 821f628:	e0bffe17 	ldw	r2,-8(fp)
 821f62c:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
 821f630:	e0800217 	ldw	r2,8(fp)
 821f634:	e0bff915 	stw	r2,-28(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
 821f638:	e0bffa17 	ldw	r2,-24(fp)
 821f63c:	10800303 	ldbu	r2,12(r2)
 821f640:	10803fcc 	andi	r2,r2,255
 821f644:	1000031e 	bne	r2,zero,821f654 <alt_tse_system_add_sys+0x68>
		loop_end = 1;
 821f648:	00800044 	movi	r2,1
 821f64c:	e0bff515 	stw	r2,-44(fp)
 821f650:	00000e06 	br	821f68c <alt_tse_system_add_sys+0xa0>
	}
	else if(pmac->tse_num_of_channel > 0) {
 821f654:	e0bffa17 	ldw	r2,-24(fp)
 821f658:	10800303 	ldbu	r2,12(r2)
 821f65c:	10803fcc 	andi	r2,r2,255
 821f660:	10000526 	beq	r2,zero,821f678 <alt_tse_system_add_sys+0x8c>
		loop_end = pmac->tse_num_of_channel; 
 821f664:	e0bffa17 	ldw	r2,-24(fp)
 821f668:	10800303 	ldbu	r2,12(r2)
 821f66c:	10803fcc 	andi	r2,r2,255
 821f670:	e0bff515 	stw	r2,-44(fp)
 821f674:	00000506 	br	821f68c <alt_tse_system_add_sys+0xa0>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
 821f678:	01020974 	movhi	r4,2085
 821f67c:	21382e04 	addi	r4,r4,-8008
 821f680:	82035a00 	call	82035a0 <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821f684:	00bfffc4 	movi	r2,-1
 821f688:	00025106 	br	821ffd0 <alt_tse_system_add_sys+0x9e4>
	}

	for(i = 0; i < loop_end; i++) {
 821f68c:	e03ff415 	stw	zero,-48(fp)
 821f690:	00024b06 	br	821ffc0 <alt_tse_system_add_sys+0x9d4>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
 821f694:	d0a07f83 	ldbu	r2,-32258(gp)
 821f698:	10803fcc 	andi	r2,r2,255
 821f69c:	1080201c 	xori	r2,r2,128
 821f6a0:	10bfe004 	addi	r2,r2,-128
 821f6a4:	10800110 	cmplti	r2,r2,4
 821f6a8:	10000c1e 	bne	r2,zero,821f6dc <alt_tse_system_add_sys+0xf0>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
 821f6ac:	01020974 	movhi	r4,2085
 821f6b0:	21383a04 	addi	r4,r4,-7960
 821f6b4:	82035a00 	call	82035a0 <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
 821f6b8:	d0a07f83 	ldbu	r2,-32258(gp)
 821f6bc:	10803fcc 	andi	r2,r2,255
 821f6c0:	1080201c 	xori	r2,r2,128
 821f6c4:	10bfe004 	addi	r2,r2,-128
 821f6c8:	100d883a 	mov	r6,r2
 821f6cc:	01400104 	movi	r5,4
 821f6d0:	01020974 	movhi	r4,2085
 821f6d4:	21384a04 	addi	r4,r4,-7896
 821f6d8:	820331c0 	call	820331c <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
 821f6dc:	e0bffa17 	ldw	r2,-24(fp)
 821f6e0:	1000081e 	bne	r2,zero,821f704 <alt_tse_system_add_sys+0x118>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 821f6e4:	01020974 	movhi	r4,2085
 821f6e8:	21385904 	addi	r4,r4,-7836
 821f6ec:	82035a00 	call	82035a0 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
 821f6f0:	01020974 	movhi	r4,2085
 821f6f4:	21386304 	addi	r4,r4,-7796
 821f6f8:	82035a00 	call	82035a0 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821f6fc:	00bfffc4 	movi	r2,-1
 821f700:	00023306 	br	821ffd0 <alt_tse_system_add_sys+0x9e4>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
 821f704:	d0a07f83 	ldbu	r2,-32258(gp)
 821f708:	11003fcc 	andi	r4,r2,255
 821f70c:	2100201c 	xori	r4,r4,128
 821f710:	213fe004 	addi	r4,r4,-128
 821f714:	e0bffa17 	ldw	r2,-24(fp)
 821f718:	10800017 	ldw	r2,0(r2)
 821f71c:	e0fff417 	ldw	r3,-48(fp)
 821f720:	180692ba 	slli	r3,r3,10
 821f724:	10c7883a 	add	r3,r2,r3
 821f728:	00820974 	movhi	r2,2085
 821f72c:	1087c104 	addi	r2,r2,7940
 821f730:	21001224 	muli	r4,r4,72
 821f734:	1105883a 	add	r2,r2,r4
 821f738:	10c00015 	stw	r3,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
 821f73c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f740:	11003fcc 	andi	r4,r2,255
 821f744:	2100201c 	xori	r4,r4,128
 821f748:	213fe004 	addi	r4,r4,-128
 821f74c:	e0bffa17 	ldw	r2,-24(fp)
 821f750:	10c0010b 	ldhu	r3,4(r2)
 821f754:	00820974 	movhi	r2,2085
 821f758:	1087c104 	addi	r2,r2,7940
 821f75c:	21001224 	muli	r4,r4,72
 821f760:	1105883a 	add	r2,r2,r4
 821f764:	10800104 	addi	r2,r2,4
 821f768:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
 821f76c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f770:	11003fcc 	andi	r4,r2,255
 821f774:	2100201c 	xori	r4,r4,128
 821f778:	213fe004 	addi	r4,r4,-128
 821f77c:	e0bffa17 	ldw	r2,-24(fp)
 821f780:	10c0018b 	ldhu	r3,6(r2)
 821f784:	00820974 	movhi	r2,2085
 821f788:	1087c104 	addi	r2,r2,7940
 821f78c:	21001224 	muli	r4,r4,72
 821f790:	1105883a 	add	r2,r2,r4
 821f794:	10800184 	addi	r2,r2,6
 821f798:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
 821f79c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f7a0:	11003fcc 	andi	r4,r2,255
 821f7a4:	2100201c 	xori	r4,r4,128
 821f7a8:	213fe004 	addi	r4,r4,-128
 821f7ac:	e0bffa17 	ldw	r2,-24(fp)
 821f7b0:	10c00203 	ldbu	r3,8(r2)
 821f7b4:	00820974 	movhi	r2,2085
 821f7b8:	1087c104 	addi	r2,r2,7940
 821f7bc:	21001224 	muli	r4,r4,72
 821f7c0:	1105883a 	add	r2,r2,r4
 821f7c4:	10800204 	addi	r2,r2,8
 821f7c8:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
 821f7cc:	d0a07f83 	ldbu	r2,-32258(gp)
 821f7d0:	11003fcc 	andi	r4,r2,255
 821f7d4:	2100201c 	xori	r4,r4,128
 821f7d8:	213fe004 	addi	r4,r4,-128
 821f7dc:	e0bffa17 	ldw	r2,-24(fp)
 821f7e0:	10c00243 	ldbu	r3,9(r2)
 821f7e4:	00820974 	movhi	r2,2085
 821f7e8:	1087c104 	addi	r2,r2,7940
 821f7ec:	21001224 	muli	r4,r4,72
 821f7f0:	1105883a 	add	r2,r2,r4
 821f7f4:	10800244 	addi	r2,r2,9
 821f7f8:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
 821f7fc:	d0a07f83 	ldbu	r2,-32258(gp)
 821f800:	11003fcc 	andi	r4,r2,255
 821f804:	2100201c 	xori	r4,r4,128
 821f808:	213fe004 	addi	r4,r4,-128
 821f80c:	e0bffa17 	ldw	r2,-24(fp)
 821f810:	10c00283 	ldbu	r3,10(r2)
 821f814:	00820974 	movhi	r2,2085
 821f818:	1087c104 	addi	r2,r2,7940
 821f81c:	21001224 	muli	r4,r4,72
 821f820:	1105883a 	add	r2,r2,r4
 821f824:	10800284 	addi	r2,r2,10
 821f828:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
 821f82c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f830:	11003fcc 	andi	r4,r2,255
 821f834:	2100201c 	xori	r4,r4,128
 821f838:	213fe004 	addi	r4,r4,-128
 821f83c:	e0bffa17 	ldw	r2,-24(fp)
 821f840:	10c002c3 	ldbu	r3,11(r2)
 821f844:	00820974 	movhi	r2,2085
 821f848:	1087c104 	addi	r2,r2,7940
 821f84c:	21001224 	muli	r4,r4,72
 821f850:	1105883a 	add	r2,r2,r4
 821f854:	108002c4 	addi	r2,r2,11
 821f858:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
 821f85c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f860:	11003fcc 	andi	r4,r2,255
 821f864:	2100201c 	xori	r4,r4,128
 821f868:	213fe004 	addi	r4,r4,-128
 821f86c:	e0bffa17 	ldw	r2,-24(fp)
 821f870:	10c00303 	ldbu	r3,12(r2)
 821f874:	00820974 	movhi	r2,2085
 821f878:	1087c104 	addi	r2,r2,7940
 821f87c:	21001224 	muli	r4,r4,72
 821f880:	1105883a 	add	r2,r2,r4
 821f884:	10800304 	addi	r2,r2,12
 821f888:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
 821f88c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f890:	11003fcc 	andi	r4,r2,255
 821f894:	2100201c 	xori	r4,r4,128
 821f898:	213fe004 	addi	r4,r4,-128
 821f89c:	e0bffa17 	ldw	r2,-24(fp)
 821f8a0:	10c00343 	ldbu	r3,13(r2)
 821f8a4:	00820974 	movhi	r2,2085
 821f8a8:	1087c104 	addi	r2,r2,7940
 821f8ac:	21001224 	muli	r4,r4,72
 821f8b0:	1105883a 	add	r2,r2,r4
 821f8b4:	10800344 	addi	r2,r2,13
 821f8b8:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
 821f8bc:	d0a07f83 	ldbu	r2,-32258(gp)
 821f8c0:	11003fcc 	andi	r4,r2,255
 821f8c4:	2100201c 	xori	r4,r4,128
 821f8c8:	213fe004 	addi	r4,r4,-128
 821f8cc:	e0bffa17 	ldw	r2,-24(fp)
 821f8d0:	10c00383 	ldbu	r3,14(r2)
 821f8d4:	00820974 	movhi	r2,2085
 821f8d8:	1087c104 	addi	r2,r2,7940
 821f8dc:	21001224 	muli	r4,r4,72
 821f8e0:	1105883a 	add	r2,r2,r4
 821f8e4:	10800384 	addi	r2,r2,14
 821f8e8:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
 821f8ec:	d0a07f83 	ldbu	r2,-32258(gp)
 821f8f0:	11003fcc 	andi	r4,r2,255
 821f8f4:	2100201c 	xori	r4,r4,128
 821f8f8:	213fe004 	addi	r4,r4,-128
 821f8fc:	e0bffa17 	ldw	r2,-24(fp)
 821f900:	10c003c3 	ldbu	r3,15(r2)
 821f904:	00820974 	movhi	r2,2085
 821f908:	1087c104 	addi	r2,r2,7940
 821f90c:	21001224 	muli	r4,r4,72
 821f910:	1105883a 	add	r2,r2,r4
 821f914:	108003c4 	addi	r2,r2,15
 821f918:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
 821f91c:	d0a07f83 	ldbu	r2,-32258(gp)
 821f920:	11003fcc 	andi	r4,r2,255
 821f924:	2100201c 	xori	r4,r4,128
 821f928:	213fe004 	addi	r4,r4,-128
 821f92c:	e0bffa17 	ldw	r2,-24(fp)
 821f930:	10c00403 	ldbu	r3,16(r2)
 821f934:	00820974 	movhi	r2,2085
 821f938:	1087c104 	addi	r2,r2,7940
 821f93c:	21001224 	muli	r4,r4,72
 821f940:	1105883a 	add	r2,r2,r4
 821f944:	10800404 	addi	r2,r2,16
 821f948:	10c00005 	stb	r3,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
 821f94c:	e0bff617 	ldw	r2,-40(fp)
 821f950:	10000d1e 	bne	r2,zero,821f988 <alt_tse_system_add_sys+0x39c>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
 821f954:	01020974 	movhi	r4,2085
 821f958:	21387504 	addi	r4,r4,-7724
 821f95c:	82035a00 	call	82035a0 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
 821f960:	d0a07f83 	ldbu	r2,-32258(gp)
 821f964:	10803fcc 	andi	r2,r2,255
 821f968:	1080201c 	xori	r2,r2,128
 821f96c:	10bfe004 	addi	r2,r2,-128
 821f970:	100b883a 	mov	r5,r2
 821f974:	01020974 	movhi	r4,2085
 821f978:	21388004 	addi	r4,r4,-7680
 821f97c:	820331c0 	call	820331c <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 821f980:	00bfffc4 	movi	r2,-1
 821f984:	00019206 	br	821ffd0 <alt_tse_system_add_sys+0x9e4>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
 821f988:	d0a07f83 	ldbu	r2,-32258(gp)
 821f98c:	14003fcc 	andi	r16,r2,255
 821f990:	8400201c 	xori	r16,r16,128
 821f994:	843fe004 	addi	r16,r16,-128
 821f998:	e0bff617 	ldw	r2,-40(fp)
 821f99c:	10800017 	ldw	r2,0(r2)
 821f9a0:	1009883a 	mov	r4,r2
 821f9a4:	8203edc0 	call	8203edc <strlen>
 821f9a8:	10800044 	addi	r2,r2,1
 821f9ac:	1009883a 	mov	r4,r2
 821f9b0:	824b6900 	call	824b690 <malloc>
 821f9b4:	1009883a 	mov	r4,r2
 821f9b8:	00820974 	movhi	r2,2085
 821f9bc:	1087c104 	addi	r2,r2,7940
 821f9c0:	80c01224 	muli	r3,r16,72
 821f9c4:	10c5883a 	add	r2,r2,r3
 821f9c8:	10800504 	addi	r2,r2,20
 821f9cc:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
 821f9d0:	d0a07f83 	ldbu	r2,-32258(gp)
 821f9d4:	10c03fcc 	andi	r3,r2,255
 821f9d8:	18c0201c 	xori	r3,r3,128
 821f9dc:	18ffe004 	addi	r3,r3,-128
 821f9e0:	00820974 	movhi	r2,2085
 821f9e4:	1087c104 	addi	r2,r2,7940
 821f9e8:	18c01224 	muli	r3,r3,72
 821f9ec:	10c5883a 	add	r2,r2,r3
 821f9f0:	10800504 	addi	r2,r2,20
 821f9f4:	10800017 	ldw	r2,0(r2)
 821f9f8:	10000a1e 	bne	r2,zero,821fa24 <alt_tse_system_add_sys+0x438>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
 821f9fc:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa00:	10803fcc 	andi	r2,r2,255
 821fa04:	1080201c 	xori	r2,r2,128
 821fa08:	10bfe004 	addi	r2,r2,-128
 821fa0c:	100b883a 	mov	r5,r2
 821fa10:	01020974 	movhi	r4,2085
 821fa14:	21389804 	addi	r4,r4,-7584
 821fa18:	820331c0 	call	820331c <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 821fa1c:	00bfffc4 	movi	r2,-1
 821fa20:	00016b06 	br	821ffd0 <alt_tse_system_add_sys+0x9e4>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
 821fa24:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa28:	10c03fcc 	andi	r3,r2,255
 821fa2c:	18c0201c 	xori	r3,r3,128
 821fa30:	18ffe004 	addi	r3,r3,-128
 821fa34:	00820974 	movhi	r2,2085
 821fa38:	1087c104 	addi	r2,r2,7940
 821fa3c:	18c01224 	muli	r3,r3,72
 821fa40:	10c5883a 	add	r2,r2,r3
 821fa44:	10800504 	addi	r2,r2,20
 821fa48:	10c00017 	ldw	r3,0(r2)
 821fa4c:	e0bff617 	ldw	r2,-40(fp)
 821fa50:	10800017 	ldw	r2,0(r2)
 821fa54:	100b883a 	mov	r5,r2
 821fa58:	1809883a 	mov	r4,r3
 821fa5c:	824b6b80 	call	824b6b8 <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
 821fa60:	d0a07f83 	ldbu	r2,-32258(gp)
 821fa64:	14003fcc 	andi	r16,r2,255
 821fa68:	8400201c 	xori	r16,r16,128
 821fa6c:	843fe004 	addi	r16,r16,-128
 821fa70:	e0bff617 	ldw	r2,-40(fp)
 821fa74:	10800117 	ldw	r2,4(r2)
 821fa78:	1009883a 	mov	r4,r2
 821fa7c:	8203edc0 	call	8203edc <strlen>
 821fa80:	10800044 	addi	r2,r2,1
 821fa84:	1009883a 	mov	r4,r2
 821fa88:	824b6900 	call	824b690 <malloc>
 821fa8c:	1009883a 	mov	r4,r2
 821fa90:	00820974 	movhi	r2,2085
 821fa94:	1087c104 	addi	r2,r2,7940
 821fa98:	80c01224 	muli	r3,r16,72
 821fa9c:	10c5883a 	add	r2,r2,r3
 821faa0:	10800604 	addi	r2,r2,24
 821faa4:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
 821faa8:	d0a07f83 	ldbu	r2,-32258(gp)
 821faac:	10c03fcc 	andi	r3,r2,255
 821fab0:	18c0201c 	xori	r3,r3,128
 821fab4:	18ffe004 	addi	r3,r3,-128
 821fab8:	00820974 	movhi	r2,2085
 821fabc:	1087c104 	addi	r2,r2,7940
 821fac0:	18c01224 	muli	r3,r3,72
 821fac4:	10c5883a 	add	r2,r2,r3
 821fac8:	10800604 	addi	r2,r2,24
 821facc:	10800017 	ldw	r2,0(r2)
 821fad0:	10000a1e 	bne	r2,zero,821fafc <alt_tse_system_add_sys+0x510>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
 821fad4:	d0a07f83 	ldbu	r2,-32258(gp)
 821fad8:	10803fcc 	andi	r2,r2,255
 821fadc:	1080201c 	xori	r2,r2,128
 821fae0:	10bfe004 	addi	r2,r2,-128
 821fae4:	100b883a 	mov	r5,r2
 821fae8:	01020974 	movhi	r4,2085
 821faec:	2138ab04 	addi	r4,r4,-7508
 821faf0:	820331c0 	call	820331c <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 821faf4:	00bfffc4 	movi	r2,-1
 821faf8:	00013506 	br	821ffd0 <alt_tse_system_add_sys+0x9e4>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
 821fafc:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb00:	10c03fcc 	andi	r3,r2,255
 821fb04:	18c0201c 	xori	r3,r3,128
 821fb08:	18ffe004 	addi	r3,r3,-128
 821fb0c:	00820974 	movhi	r2,2085
 821fb10:	1087c104 	addi	r2,r2,7940
 821fb14:	18c01224 	muli	r3,r3,72
 821fb18:	10c5883a 	add	r2,r2,r3
 821fb1c:	10800604 	addi	r2,r2,24
 821fb20:	10c00017 	ldw	r3,0(r2)
 821fb24:	e0bff617 	ldw	r2,-40(fp)
 821fb28:	10800117 	ldw	r2,4(r2)
 821fb2c:	100b883a 	mov	r5,r2
 821fb30:	1809883a 	mov	r4,r3
 821fb34:	824b6b80 	call	824b6b8 <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
 821fb38:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb3c:	11003fcc 	andi	r4,r2,255
 821fb40:	2100201c 	xori	r4,r4,128
 821fb44:	213fe004 	addi	r4,r4,-128
 821fb48:	e0bff617 	ldw	r2,-40(fp)
 821fb4c:	10c0020b 	ldhu	r3,8(r2)
 821fb50:	00820974 	movhi	r2,2085
 821fb54:	1087c104 	addi	r2,r2,7940
 821fb58:	21001224 	muli	r4,r4,72
 821fb5c:	1105883a 	add	r2,r2,r4
 821fb60:	10800704 	addi	r2,r2,28
 821fb64:	10c0000d 	sth	r3,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
 821fb68:	e0bff717 	ldw	r2,-36(fp)
 821fb6c:	1000151e 	bne	r2,zero,821fbc4 <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
 821fb70:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb74:	10c03fcc 	andi	r3,r2,255
 821fb78:	18c0201c 	xori	r3,r3,128
 821fb7c:	18ffe004 	addi	r3,r3,-128
 821fb80:	00820974 	movhi	r2,2085
 821fb84:	1087c104 	addi	r2,r2,7940
 821fb88:	18c01224 	muli	r3,r3,72
 821fb8c:	10c5883a 	add	r2,r2,r3
 821fb90:	10800784 	addi	r2,r2,30
 821fb94:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
 821fb98:	d0a07f83 	ldbu	r2,-32258(gp)
 821fb9c:	10c03fcc 	andi	r3,r2,255
 821fba0:	18c0201c 	xori	r3,r3,128
 821fba4:	18ffe004 	addi	r3,r3,-128
 821fba8:	00820974 	movhi	r2,2085
 821fbac:	1087c104 	addi	r2,r2,7940
 821fbb0:	18c01224 	muli	r3,r3,72
 821fbb4:	10c5883a 	add	r2,r2,r3
 821fbb8:	10800804 	addi	r2,r2,32
 821fbbc:	10000015 	stw	zero,0(r2)
 821fbc0:	00001806 	br	821fc24 <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
 821fbc4:	d0a07f83 	ldbu	r2,-32258(gp)
 821fbc8:	11003fcc 	andi	r4,r2,255
 821fbcc:	2100201c 	xori	r4,r4,128
 821fbd0:	213fe004 	addi	r4,r4,-128
 821fbd4:	e0bff717 	ldw	r2,-36(fp)
 821fbd8:	10c00003 	ldbu	r3,0(r2)
 821fbdc:	00820974 	movhi	r2,2085
 821fbe0:	1087c104 	addi	r2,r2,7940
 821fbe4:	21001224 	muli	r4,r4,72
 821fbe8:	1105883a 	add	r2,r2,r4
 821fbec:	10800784 	addi	r2,r2,30
 821fbf0:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
 821fbf4:	d0a07f83 	ldbu	r2,-32258(gp)
 821fbf8:	11003fcc 	andi	r4,r2,255
 821fbfc:	2100201c 	xori	r4,r4,128
 821fc00:	213fe004 	addi	r4,r4,-128
 821fc04:	e0bff717 	ldw	r2,-36(fp)
 821fc08:	10c00117 	ldw	r3,4(r2)
 821fc0c:	00820974 	movhi	r2,2085
 821fc10:	1087c104 	addi	r2,r2,7940
 821fc14:	21001224 	muli	r4,r4,72
 821fc18:	1105883a 	add	r2,r2,r4
 821fc1c:	10800804 	addi	r2,r2,32
 821fc20:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
 821fc24:	e0bff817 	ldw	r2,-32(fp)
 821fc28:	1000471e 	bne	r2,zero,821fd48 <alt_tse_system_add_sys+0x75c>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
 821fc2c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fc30:	10c03fcc 	andi	r3,r2,255
 821fc34:	18c0201c 	xori	r3,r3,128
 821fc38:	18ffe004 	addi	r3,r3,-128
 821fc3c:	00820974 	movhi	r2,2085
 821fc40:	1087c104 	addi	r2,r2,7940
 821fc44:	18c01224 	muli	r3,r3,72
 821fc48:	10c5883a 	add	r2,r2,r3
 821fc4c:	10800904 	addi	r2,r2,36
 821fc50:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
 821fc54:	d0a07f83 	ldbu	r2,-32258(gp)
 821fc58:	10c03fcc 	andi	r3,r2,255
 821fc5c:	18c0201c 	xori	r3,r3,128
 821fc60:	18ffe004 	addi	r3,r3,-128
 821fc64:	00820974 	movhi	r2,2085
 821fc68:	1087c104 	addi	r2,r2,7940
 821fc6c:	18c01224 	muli	r3,r3,72
 821fc70:	10c5883a 	add	r2,r2,r3
 821fc74:	10800a04 	addi	r2,r2,40
 821fc78:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
 821fc7c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fc80:	10c03fcc 	andi	r3,r2,255
 821fc84:	18c0201c 	xori	r3,r3,128
 821fc88:	18ffe004 	addi	r3,r3,-128
 821fc8c:	00820974 	movhi	r2,2085
 821fc90:	1087c104 	addi	r2,r2,7940
 821fc94:	18c01224 	muli	r3,r3,72
 821fc98:	10c5883a 	add	r2,r2,r3
 821fc9c:	10800b04 	addi	r2,r2,44
 821fca0:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
 821fca4:	d0a07f83 	ldbu	r2,-32258(gp)
 821fca8:	10c03fcc 	andi	r3,r2,255
 821fcac:	18c0201c 	xori	r3,r3,128
 821fcb0:	18ffe004 	addi	r3,r3,-128
 821fcb4:	00820974 	movhi	r2,2085
 821fcb8:	1087c104 	addi	r2,r2,7940
 821fcbc:	18c01224 	muli	r3,r3,72
 821fcc0:	10c5883a 	add	r2,r2,r3
 821fcc4:	10800c04 	addi	r2,r2,48
 821fcc8:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
 821fccc:	d0a07f83 	ldbu	r2,-32258(gp)
 821fcd0:	10c03fcc 	andi	r3,r2,255
 821fcd4:	18c0201c 	xori	r3,r3,128
 821fcd8:	18ffe004 	addi	r3,r3,-128
 821fcdc:	00820974 	movhi	r2,2085
 821fce0:	1087c104 	addi	r2,r2,7940
 821fce4:	18c01224 	muli	r3,r3,72
 821fce8:	10c5883a 	add	r2,r2,r3
 821fcec:	10800d04 	addi	r2,r2,52
 821fcf0:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
 821fcf4:	d0a07f83 	ldbu	r2,-32258(gp)
 821fcf8:	10c03fcc 	andi	r3,r2,255
 821fcfc:	18c0201c 	xori	r3,r3,128
 821fd00:	18ffe004 	addi	r3,r3,-128
 821fd04:	00820974 	movhi	r2,2085
 821fd08:	1087c104 	addi	r2,r2,7940
 821fd0c:	18c01224 	muli	r3,r3,72
 821fd10:	10c5883a 	add	r2,r2,r3
 821fd14:	10800e04 	addi	r2,r2,56
 821fd18:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
 821fd1c:	d0a07f83 	ldbu	r2,-32258(gp)
 821fd20:	10c03fcc 	andi	r3,r2,255
 821fd24:	18c0201c 	xori	r3,r3,128
 821fd28:	18ffe004 	addi	r3,r3,-128
 821fd2c:	00820974 	movhi	r2,2085
 821fd30:	1087c104 	addi	r2,r2,7940
 821fd34:	18c01224 	muli	r3,r3,72
 821fd38:	10c5883a 	add	r2,r2,r3
 821fd3c:	10800f04 	addi	r2,r2,60
 821fd40:	10000015 	stw	zero,0(r2)
 821fd44:	00005406 	br	821fe98 <alt_tse_system_add_sys+0x8ac>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
 821fd48:	d0a07f83 	ldbu	r2,-32258(gp)
 821fd4c:	11003fcc 	andi	r4,r2,255
 821fd50:	2100201c 	xori	r4,r4,128
 821fd54:	213fe004 	addi	r4,r4,-128
 821fd58:	e0bff817 	ldw	r2,-32(fp)
 821fd5c:	10c00003 	ldbu	r3,0(r2)
 821fd60:	00820974 	movhi	r2,2085
 821fd64:	1087c104 	addi	r2,r2,7940
 821fd68:	21001224 	muli	r4,r4,72
 821fd6c:	1105883a 	add	r2,r2,r4
 821fd70:	10800904 	addi	r2,r2,36
 821fd74:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
 821fd78:	d0a07f83 	ldbu	r2,-32258(gp)
 821fd7c:	11003fcc 	andi	r4,r2,255
 821fd80:	2100201c 	xori	r4,r4,128
 821fd84:	213fe004 	addi	r4,r4,-128
 821fd88:	e0bff817 	ldw	r2,-32(fp)
 821fd8c:	10c00117 	ldw	r3,4(r2)
 821fd90:	00820974 	movhi	r2,2085
 821fd94:	1087c104 	addi	r2,r2,7940
 821fd98:	21001224 	muli	r4,r4,72
 821fd9c:	1105883a 	add	r2,r2,r4
 821fda0:	10800a04 	addi	r2,r2,40
 821fda4:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
 821fda8:	d0a07f83 	ldbu	r2,-32258(gp)
 821fdac:	11003fcc 	andi	r4,r2,255
 821fdb0:	2100201c 	xori	r4,r4,128
 821fdb4:	213fe004 	addi	r4,r4,-128
 821fdb8:	e0bff817 	ldw	r2,-32(fp)
 821fdbc:	10c00217 	ldw	r3,8(r2)
 821fdc0:	00820974 	movhi	r2,2085
 821fdc4:	1087c104 	addi	r2,r2,7940
 821fdc8:	21001224 	muli	r4,r4,72
 821fdcc:	1105883a 	add	r2,r2,r4
 821fdd0:	10800b04 	addi	r2,r2,44
 821fdd4:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
 821fdd8:	d0a07f83 	ldbu	r2,-32258(gp)
 821fddc:	11003fcc 	andi	r4,r2,255
 821fde0:	2100201c 	xori	r4,r4,128
 821fde4:	213fe004 	addi	r4,r4,-128
 821fde8:	e0bff817 	ldw	r2,-32(fp)
 821fdec:	10c00317 	ldw	r3,12(r2)
 821fdf0:	00820974 	movhi	r2,2085
 821fdf4:	1087c104 	addi	r2,r2,7940
 821fdf8:	21001224 	muli	r4,r4,72
 821fdfc:	1105883a 	add	r2,r2,r4
 821fe00:	10800c04 	addi	r2,r2,48
 821fe04:	10c00015 	stw	r3,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
 821fe08:	d0a07f83 	ldbu	r2,-32258(gp)
 821fe0c:	11003fcc 	andi	r4,r2,255
 821fe10:	2100201c 	xori	r4,r4,128
 821fe14:	213fe004 	addi	r4,r4,-128
 821fe18:	e0bff817 	ldw	r2,-32(fp)
 821fe1c:	10c00417 	ldw	r3,16(r2)
 821fe20:	00820974 	movhi	r2,2085
 821fe24:	1087c104 	addi	r2,r2,7940
 821fe28:	21001224 	muli	r4,r4,72
 821fe2c:	1105883a 	add	r2,r2,r4
 821fe30:	10800d04 	addi	r2,r2,52
 821fe34:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
 821fe38:	d0a07f83 	ldbu	r2,-32258(gp)
 821fe3c:	11003fcc 	andi	r4,r2,255
 821fe40:	2100201c 	xori	r4,r4,128
 821fe44:	213fe004 	addi	r4,r4,-128
 821fe48:	e0bff817 	ldw	r2,-32(fp)
 821fe4c:	10c00517 	ldw	r3,20(r2)
 821fe50:	00820974 	movhi	r2,2085
 821fe54:	1087c104 	addi	r2,r2,7940
 821fe58:	21001224 	muli	r4,r4,72
 821fe5c:	1105883a 	add	r2,r2,r4
 821fe60:	10800e04 	addi	r2,r2,56
 821fe64:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
 821fe68:	d0a07f83 	ldbu	r2,-32258(gp)
 821fe6c:	11003fcc 	andi	r4,r2,255
 821fe70:	2100201c 	xori	r4,r4,128
 821fe74:	213fe004 	addi	r4,r4,-128
 821fe78:	e0bff817 	ldw	r2,-32(fp)
 821fe7c:	10c00617 	ldw	r3,24(r2)
 821fe80:	00820974 	movhi	r2,2085
 821fe84:	1087c104 	addi	r2,r2,7940
 821fe88:	21001224 	muli	r4,r4,72
 821fe8c:	1105883a 	add	r2,r2,r4
 821fe90:	10800f04 	addi	r2,r2,60
 821fe94:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
 821fe98:	e0bff917 	ldw	r2,-28(fp)
 821fe9c:	1000161e 	bne	r2,zero,821fef8 <alt_tse_system_add_sys+0x90c>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
 821fea0:	d0a07f83 	ldbu	r2,-32258(gp)
 821fea4:	10c03fcc 	andi	r3,r2,255
 821fea8:	18c0201c 	xori	r3,r3,128
 821feac:	18ffe004 	addi	r3,r3,-128
 821feb0:	00820974 	movhi	r2,2085
 821feb4:	1087c104 	addi	r2,r2,7940
 821feb8:	18c01224 	muli	r3,r3,72
 821febc:	10c5883a 	add	r2,r2,r3
 821fec0:	10801004 	addi	r2,r2,64
 821fec4:	00ffffc4 	movi	r3,-1
 821fec8:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
 821fecc:	d0a07f83 	ldbu	r2,-32258(gp)
 821fed0:	10c03fcc 	andi	r3,r2,255
 821fed4:	18c0201c 	xori	r3,r3,128
 821fed8:	18ffe004 	addi	r3,r3,-128
 821fedc:	00820974 	movhi	r2,2085
 821fee0:	1087c104 	addi	r2,r2,7940
 821fee4:	18c01224 	muli	r3,r3,72
 821fee8:	10c5883a 	add	r2,r2,r3
 821feec:	10801104 	addi	r2,r2,68
 821fef0:	10000015 	stw	zero,0(r2)
 821fef4:	00001806 	br	821ff58 <alt_tse_system_add_sys+0x96c>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
 821fef8:	d0a07f83 	ldbu	r2,-32258(gp)
 821fefc:	11003fcc 	andi	r4,r2,255
 821ff00:	2100201c 	xori	r4,r4,128
 821ff04:	213fe004 	addi	r4,r4,-128
 821ff08:	e0bff917 	ldw	r2,-28(fp)
 821ff0c:	10c00017 	ldw	r3,0(r2)
 821ff10:	00820974 	movhi	r2,2085
 821ff14:	1087c104 	addi	r2,r2,7940
 821ff18:	21001224 	muli	r4,r4,72
 821ff1c:	1105883a 	add	r2,r2,r4
 821ff20:	10801004 	addi	r2,r2,64
 821ff24:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
 821ff28:	d0a07f83 	ldbu	r2,-32258(gp)
 821ff2c:	11003fcc 	andi	r4,r2,255
 821ff30:	2100201c 	xori	r4,r4,128
 821ff34:	213fe004 	addi	r4,r4,-128
 821ff38:	e0bff917 	ldw	r2,-28(fp)
 821ff3c:	10c00117 	ldw	r3,4(r2)
 821ff40:	00820974 	movhi	r2,2085
 821ff44:	1087c104 	addi	r2,r2,7940
 821ff48:	21001224 	muli	r4,r4,72
 821ff4c:	1105883a 	add	r2,r2,r4
 821ff50:	10801104 	addi	r2,r2,68
 821ff54:	10c00015 	stw	r3,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
 821ff58:	e0bff617 	ldw	r2,-40(fp)
 821ff5c:	10800304 	addi	r2,r2,12
 821ff60:	e0bff615 	stw	r2,-40(fp)
		if(pmem) pmem++;
 821ff64:	e0bff717 	ldw	r2,-36(fp)
 821ff68:	10000326 	beq	r2,zero,821ff78 <alt_tse_system_add_sys+0x98c>
 821ff6c:	e0bff717 	ldw	r2,-36(fp)
 821ff70:	10800204 	addi	r2,r2,8
 821ff74:	e0bff715 	stw	r2,-36(fp)
		if(pfifo) pfifo++;
 821ff78:	e0bff817 	ldw	r2,-32(fp)
 821ff7c:	10000326 	beq	r2,zero,821ff8c <alt_tse_system_add_sys+0x9a0>
 821ff80:	e0bff817 	ldw	r2,-32(fp)
 821ff84:	10800704 	addi	r2,r2,28
 821ff88:	e0bff815 	stw	r2,-32(fp)
		if(pphy) pphy++;
 821ff8c:	e0bff917 	ldw	r2,-28(fp)
 821ff90:	10000326 	beq	r2,zero,821ffa0 <alt_tse_system_add_sys+0x9b4>
 821ff94:	e0bff917 	ldw	r2,-28(fp)
 821ff98:	10800204 	addi	r2,r2,8
 821ff9c:	e0bff915 	stw	r2,-28(fp)
		
		tse_system_count++;
 821ffa0:	d0a07f83 	ldbu	r2,-32258(gp)
 821ffa4:	10800044 	addi	r2,r2,1
 821ffa8:	d0a07f85 	stb	r2,-32258(gp)
		max_mac_system = tse_system_count;
 821ffac:	d0a07f83 	ldbu	r2,-32258(gp)
 821ffb0:	d0a02d05 	stb	r2,-32588(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
 821ffb4:	e0bff417 	ldw	r2,-48(fp)
 821ffb8:	10800044 	addi	r2,r2,1
 821ffbc:	e0bff415 	stw	r2,-48(fp)
 821ffc0:	e0fff417 	ldw	r3,-48(fp)
 821ffc4:	e0bff517 	ldw	r2,-44(fp)
 821ffc8:	18bdb216 	blt	r3,r2,821f694 <alt_tse_system_add_sys+0xa8>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
 821ffcc:	0005883a 	mov	r2,zero
	
}
 821ffd0:	e6ffff04 	addi	sp,fp,-4
 821ffd4:	dfc00217 	ldw	ra,8(sp)
 821ffd8:	df000117 	ldw	fp,4(sp)
 821ffdc:	dc000017 	ldw	r16,0(sp)
 821ffe0:	dec00304 	addi	sp,sp,12
 821ffe4:	f800283a 	ret

0821ffe8 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
 821ffe8:	defff904 	addi	sp,sp,-28
 821ffec:	dfc00615 	stw	ra,24(sp)
 821fff0:	df000515 	stw	fp,20(sp)
 821fff4:	df000504 	addi	fp,sp,20
 821fff8:	e13ffe15 	stw	r4,-8(fp)
 821fffc:	2805883a 	mov	r2,r5
 8220000:	e0bfff05 	stb	r2,-4(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 8220004:	e03ffb15 	stw	zero,-20(fp)
 8220008:	00004806 	br	822012c <alt_tse_sys_enable_mdio_sharing+0x144>
		psys_mac = psys_mac_list[i];
 822000c:	e0bffb17 	ldw	r2,-20(fp)
 8220010:	1085883a 	add	r2,r2,r2
 8220014:	1085883a 	add	r2,r2,r2
 8220018:	1007883a 	mov	r3,r2
 822001c:	e0bffe17 	ldw	r2,-8(fp)
 8220020:	10c5883a 	add	r2,r2,r3
 8220024:	10800017 	ldw	r2,0(r2)
 8220028:	e0bffd15 	stw	r2,-12(fp)
		
		if(psys_mac == 0) {
 822002c:	e0bffd17 	ldw	r2,-12(fp)
 8220030:	1000081e 	bne	r2,zero,8220054 <alt_tse_sys_enable_mdio_sharing+0x6c>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 8220034:	01020974 	movhi	r4,2085
 8220038:	21385904 	addi	r4,r4,-7836
 822003c:	82035a00 	call	82035a0 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
 8220040:	01020974 	movhi	r4,2085
 8220044:	2138be04 	addi	r4,r4,-7432
 8220048:	82035a00 	call	82035a0 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 822004c:	00bfffc4 	movi	r2,-1
 8220050:	00003a06 	br	822013c <alt_tse_sys_enable_mdio_sharing+0x154>
		}
		
		for(j = 0; j < max_mac_system; j++) {
 8220054:	e03ffc15 	stw	zero,-16(fp)
 8220058:	00002d06 	br	8220110 <alt_tse_sys_enable_mdio_sharing+0x128>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
 822005c:	e0bffd17 	ldw	r2,-12(fp)
 8220060:	10c00017 	ldw	r3,0(r2)
 8220064:	00820974 	movhi	r2,2085
 8220068:	1087c104 	addi	r2,r2,7940
 822006c:	e13ffc17 	ldw	r4,-16(fp)
 8220070:	21001224 	muli	r4,r4,72
 8220074:	1105883a 	add	r2,r2,r4
 8220078:	10800017 	ldw	r2,0(r2)
 822007c:	1880211e 	bne	r3,r2,8220104 <alt_tse_sys_enable_mdio_sharing+0x11c>
				if(tse_mac_device[j].tse_multichannel_mac) {
 8220080:	00820974 	movhi	r2,2085
 8220084:	1087c104 	addi	r2,r2,7940
 8220088:	e0fffc17 	ldw	r3,-16(fp)
 822008c:	18c01224 	muli	r3,r3,72
 8220090:	10c5883a 	add	r2,r2,r3
 8220094:	108002c4 	addi	r2,r2,11
 8220098:	10800003 	ldbu	r2,0(r2)
 822009c:	10803fcc 	andi	r2,r2,255
 82200a0:	10000826 	beq	r2,zero,82200c4 <alt_tse_sys_enable_mdio_sharing+0xdc>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
 82200a4:	01020974 	movhi	r4,2085
 82200a8:	2138d204 	addi	r4,r4,-7352
 82200ac:	82035a00 	call	82035a0 <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
 82200b0:	01020974 	movhi	r4,2085
 82200b4:	2138e304 	addi	r4,r4,-7284
 82200b8:	82035a00 	call	82035a0 <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
 82200bc:	00bfffc4 	movi	r2,-1
 82200c0:	00001e06 	br	822013c <alt_tse_sys_enable_mdio_sharing+0x154>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
 82200c4:	00820974 	movhi	r2,2085
 82200c8:	1087c104 	addi	r2,r2,7940
 82200cc:	e0fffc17 	ldw	r3,-16(fp)
 82200d0:	18c01224 	muli	r3,r3,72
 82200d4:	10c5883a 	add	r2,r2,r3
 82200d8:	10800344 	addi	r2,r2,13
 82200dc:	00c00044 	movi	r3,1
 82200e0:	10c00005 	stb	r3,0(r2)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
 82200e4:	00820974 	movhi	r2,2085
 82200e8:	1087c104 	addi	r2,r2,7940
 82200ec:	e0fffc17 	ldw	r3,-16(fp)
 82200f0:	18c01224 	muli	r3,r3,72
 82200f4:	10c5883a 	add	r2,r2,r3
 82200f8:	10800384 	addi	r2,r2,14
 82200fc:	e0ffff03 	ldbu	r3,-4(fp)
 8220100:	10c00005 	stb	r3,0(r2)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
 8220104:	e0bffc17 	ldw	r2,-16(fp)
 8220108:	10800044 	addi	r2,r2,1
 822010c:	e0bffc15 	stw	r2,-16(fp)
 8220110:	d0a02d03 	ldbu	r2,-32588(gp)
 8220114:	10803fcc 	andi	r2,r2,255
 8220118:	e0fffc17 	ldw	r3,-16(fp)
 822011c:	18bfcf16 	blt	r3,r2,822005c <alt_tse_sys_enable_mdio_sharing+0x74>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 8220120:	e0bffb17 	ldw	r2,-20(fp)
 8220124:	10800044 	addi	r2,r2,1
 8220128:	e0bffb15 	stw	r2,-20(fp)
 822012c:	e0bfff03 	ldbu	r2,-4(fp)
 8220130:	e0fffb17 	ldw	r3,-20(fp)
 8220134:	18bfb516 	blt	r3,r2,822000c <alt_tse_sys_enable_mdio_sharing+0x24>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
 8220138:	0005883a 	mov	r2,zero
}
 822013c:	e037883a 	mov	sp,fp
 8220140:	dfc00117 	ldw	ra,4(sp)
 8220144:	df000017 	ldw	fp,0(sp)
 8220148:	dec00204 	addi	sp,sp,8
 822014c:	f800283a 	ret

08220150 <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
 8220150:	defffc04 	addi	sp,sp,-16
 8220154:	dfc00315 	stw	ra,12(sp)
 8220158:	df000215 	stw	fp,8(sp)
 822015c:	df000204 	addi	fp,sp,8
 8220160:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 8220164:	e13fff17 	ldw	r4,-4(fp)
 8220168:	82203380 	call	8220338 <alt_tse_get_mac_info>
 822016c:	10800317 	ldw	r2,12(r2)
 8220170:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
 8220174:	e13ffe17 	ldw	r4,-8(fp)
 8220178:	82235080 	call	8223508 <alt_tse_phy_get_common_speed>
}
 822017c:	e037883a 	mov	sp,fp
 8220180:	dfc00117 	ldw	ra,4(sp)
 8220184:	df000017 	ldw	fp,0(sp)
 8220188:	dec00204 	addi	sp,sp,8
 822018c:	f800283a 	ret

08220190 <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
 8220190:	defffb04 	addi	sp,sp,-20
 8220194:	dfc00415 	stw	ra,16(sp)
 8220198:	df000315 	stw	fp,12(sp)
 822019c:	df000304 	addi	fp,sp,12
 82201a0:	e13ffe15 	stw	r4,-8(fp)
 82201a4:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 82201a8:	e13ffe17 	ldw	r4,-8(fp)
 82201ac:	82203380 	call	8220338 <alt_tse_get_mac_info>
 82201b0:	10800317 	ldw	r2,12(r2)
 82201b4:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
 82201b8:	e17fff17 	ldw	r5,-4(fp)
 82201bc:	e13ffd17 	ldw	r4,-12(fp)
 82201c0:	82238300 	call	8223830 <alt_tse_phy_set_common_speed>
}
 82201c4:	e037883a 	mov	sp,fp
 82201c8:	dfc00117 	ldw	ra,4(sp)
 82201cc:	df000017 	ldw	fp,0(sp)
 82201d0:	dec00204 	addi	sp,sp,8
 82201d4:	f800283a 	ret

082201d8 <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
 82201d8:	defffd04 	addi	sp,sp,-12
 82201dc:	df000215 	stw	fp,8(sp)
 82201e0:	df000204 	addi	fp,sp,8
 82201e4:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 82201e8:	e03ffe15 	stw	zero,-8(fp)
 82201ec:	00000c06 	br	8220220 <alt_tse_get_system_index+0x48>
        if(psys_info == &tse_mac_device[i]) {
 82201f0:	e0bffe17 	ldw	r2,-8(fp)
 82201f4:	10c01224 	muli	r3,r2,72
 82201f8:	00820974 	movhi	r2,2085
 82201fc:	1087c104 	addi	r2,r2,7940
 8220200:	1887883a 	add	r3,r3,r2
 8220204:	e0bfff17 	ldw	r2,-4(fp)
 8220208:	1880021e 	bne	r3,r2,8220214 <alt_tse_get_system_index+0x3c>
            return i;
 822020c:	e0bffe17 	ldw	r2,-8(fp)
 8220210:	00000806 	br	8220234 <alt_tse_get_system_index+0x5c>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 8220214:	e0bffe17 	ldw	r2,-8(fp)
 8220218:	10800044 	addi	r2,r2,1
 822021c:	e0bffe15 	stw	r2,-8(fp)
 8220220:	d0a02d03 	ldbu	r2,-32588(gp)
 8220224:	10803fcc 	andi	r2,r2,255
 8220228:	e0fffe17 	ldw	r3,-8(fp)
 822022c:	18bff016 	blt	r3,r2,82201f0 <alt_tse_get_system_index+0x18>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 8220230:	00bfffc4 	movi	r2,-1
}
 8220234:	e037883a 	mov	sp,fp
 8220238:	df000017 	ldw	fp,0(sp)
 822023c:	dec00104 	addi	sp,sp,4
 8220240:	f800283a 	ret

08220244 <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
 8220244:	defffd04 	addi	sp,sp,-12
 8220248:	df000215 	stw	fp,8(sp)
 822024c:	df000204 	addi	fp,sp,8
 8220250:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 8220254:	e03ffe15 	stw	zero,-8(fp)
 8220258:	00000e06 	br	8220294 <alt_tse_get_mac_group_index+0x50>
        if(pmac_group == pmac_groups[i]) {
 822025c:	008209b4 	movhi	r2,2086
 8220260:	10b6ff04 	addi	r2,r2,-9220
 8220264:	e0fffe17 	ldw	r3,-8(fp)
 8220268:	18c7883a 	add	r3,r3,r3
 822026c:	18c7883a 	add	r3,r3,r3
 8220270:	10c5883a 	add	r2,r2,r3
 8220274:	10c00017 	ldw	r3,0(r2)
 8220278:	e0bfff17 	ldw	r2,-4(fp)
 822027c:	1880021e 	bne	r3,r2,8220288 <alt_tse_get_mac_group_index+0x44>
            return i;
 8220280:	e0bffe17 	ldw	r2,-8(fp)
 8220284:	00000806 	br	82202a8 <alt_tse_get_mac_group_index+0x64>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 8220288:	e0bffe17 	ldw	r2,-8(fp)
 822028c:	10800044 	addi	r2,r2,1
 8220290:	e0bffe15 	stw	r2,-8(fp)
 8220294:	d0a07f43 	ldbu	r2,-32259(gp)
 8220298:	10803fcc 	andi	r2,r2,255
 822029c:	e0fffe17 	ldw	r3,-8(fp)
 82202a0:	18bfee16 	blt	r3,r2,822025c <alt_tse_get_mac_group_index+0x18>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 82202a4:	00bfffc4 	movi	r2,-1
}
 82202a8:	e037883a 	mov	sp,fp
 82202ac:	df000017 	ldw	fp,0(sp)
 82202b0:	dec00104 	addi	sp,sp,4
 82202b4:	f800283a 	ret

082202b8 <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
 82202b8:	defffd04 	addi	sp,sp,-12
 82202bc:	df000215 	stw	fp,8(sp)
 82202c0:	df000204 	addi	fp,sp,8
 82202c4:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 82202c8:	e03ffe15 	stw	zero,-8(fp)
 82202cc:	00000f06 	br	822030c <alt_tse_get_mac_info_index+0x54>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
 82202d0:	e0bfff17 	ldw	r2,-4(fp)
 82202d4:	10c00317 	ldw	r3,12(r2)
 82202d8:	e0bffe17 	ldw	r2,-8(fp)
 82202dc:	10800044 	addi	r2,r2,1
 82202e0:	1085883a 	add	r2,r2,r2
 82202e4:	1085883a 	add	r2,r2,r2
 82202e8:	1885883a 	add	r2,r3,r2
 82202ec:	10c00017 	ldw	r3,0(r2)
 82202f0:	e0bfff17 	ldw	r2,-4(fp)
 82202f4:	1880021e 	bne	r3,r2,8220300 <alt_tse_get_mac_info_index+0x48>
            return i;
 82202f8:	e0bffe17 	ldw	r2,-8(fp)
 82202fc:	00000a06 	br	8220328 <alt_tse_get_mac_info_index+0x70>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 8220300:	e0bffe17 	ldw	r2,-8(fp)
 8220304:	10800044 	addi	r2,r2,1
 8220308:	e0bffe15 	stw	r2,-8(fp)
 822030c:	e0bfff17 	ldw	r2,-4(fp)
 8220310:	10800317 	ldw	r2,12(r2)
 8220314:	10800003 	ldbu	r2,0(r2)
 8220318:	10803fcc 	andi	r2,r2,255
 822031c:	e0fffe17 	ldw	r3,-8(fp)
 8220320:	18bfeb16 	blt	r3,r2,82202d0 <alt_tse_get_mac_info_index+0x18>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
 8220324:	00bfffc4 	movi	r2,-1
}
 8220328:	e037883a 	mov	sp,fp
 822032c:	df000017 	ldw	fp,0(sp)
 8220330:	dec00104 	addi	sp,sp,4
 8220334:	f800283a 	ret

08220338 <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
 8220338:	defffa04 	addi	sp,sp,-24
 822033c:	df000515 	stw	fp,20(sp)
 8220340:	df000504 	addi	fp,sp,20
 8220344:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
 8220348:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 822034c:	e03ffe15 	stw	zero,-8(fp)
    
    for(i = 0; i < mac_group_count; i++) {
 8220350:	e03ffb15 	stw	zero,-20(fp)
 8220354:	00002506 	br	82203ec <alt_tse_get_mac_info+0xb4>
        pmac_group = pmac_groups[i];
 8220358:	008209b4 	movhi	r2,2086
 822035c:	10b6ff04 	addi	r2,r2,-9220
 8220360:	e0fffb17 	ldw	r3,-20(fp)
 8220364:	18c7883a 	add	r3,r3,r3
 8220368:	18c7883a 	add	r3,r3,r3
 822036c:	10c5883a 	add	r2,r2,r3
 8220370:	10800017 	ldw	r2,0(r2)
 8220374:	e0bffd15 	stw	r2,-12(fp)
        for(j = 0; j < pmac_group->channel; j++) {
 8220378:	e03ffc15 	stw	zero,-16(fp)
 822037c:	00001306 	br	82203cc <alt_tse_get_mac_info+0x94>
            pmac_info = pmac_group->pmac_info[j];
 8220380:	e0fffd17 	ldw	r3,-12(fp)
 8220384:	e0bffc17 	ldw	r2,-16(fp)
 8220388:	10800044 	addi	r2,r2,1
 822038c:	1085883a 	add	r2,r2,r2
 8220390:	1085883a 	add	r2,r2,r2
 8220394:	1885883a 	add	r2,r3,r2
 8220398:	10800017 	ldw	r2,0(r2)
 822039c:	e0bffe15 	stw	r2,-8(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
 82203a0:	e0bffe17 	ldw	r2,-8(fp)
 82203a4:	10800217 	ldw	r2,8(r2)
 82203a8:	10800017 	ldw	r2,0(r2)
 82203ac:	1007883a 	mov	r3,r2
 82203b0:	e0bfff17 	ldw	r2,-4(fp)
 82203b4:	1880021e 	bne	r3,r2,82203c0 <alt_tse_get_mac_info+0x88>
                return pmac_info;
 82203b8:	e0bffe17 	ldw	r2,-8(fp)
 82203bc:	00001006 	br	8220400 <alt_tse_get_mac_info+0xc8>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
 82203c0:	e0bffc17 	ldw	r2,-16(fp)
 82203c4:	10800044 	addi	r2,r2,1
 82203c8:	e0bffc15 	stw	r2,-16(fp)
 82203cc:	e0bffd17 	ldw	r2,-12(fp)
 82203d0:	10800003 	ldbu	r2,0(r2)
 82203d4:	10803fcc 	andi	r2,r2,255
 82203d8:	e0fffc17 	ldw	r3,-16(fp)
 82203dc:	18bfe816 	blt	r3,r2,8220380 <alt_tse_get_mac_info+0x48>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
 82203e0:	e0bffb17 	ldw	r2,-20(fp)
 82203e4:	10800044 	addi	r2,r2,1
 82203e8:	e0bffb15 	stw	r2,-20(fp)
 82203ec:	d0a07f43 	ldbu	r2,-32259(gp)
 82203f0:	10803fcc 	andi	r2,r2,255
 82203f4:	e0fffb17 	ldw	r3,-20(fp)
 82203f8:	18bfd716 	blt	r3,r2,8220358 <alt_tse_get_mac_info+0x20>
                return pmac_info;
            }
        }        
    }
    
    return 0;
 82203fc:	0005883a 	mov	r2,zero
}
 8220400:	e037883a 	mov	sp,fp
 8220404:	df000017 	ldw	fp,0(sp)
 8220408:	dec00104 	addi	sp,sp,4
 822040c:	f800283a 	ret

08220410 <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
 8220410:	defffc04 	addi	sp,sp,-16
 8220414:	df000315 	stw	fp,12(sp)
 8220418:	df000304 	addi	fp,sp,12
 822041c:	e13ffe15 	stw	r4,-8(fp)
 8220420:	2805883a 	mov	r2,r5
 8220424:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 8220428:	e0bffe17 	ldw	r2,-8(fp)
 822042c:	10800204 	addi	r2,r2,8
 8220430:	10800037 	ldwio	r2,0(r2)
 8220434:	e0bffd15 	stw	r2,-12(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
 8220438:	e0bfff03 	ldbu	r2,-4(fp)
 822043c:	10800098 	cmpnei	r2,r2,2
 8220440:	1000091e 	bne	r2,zero,8220468 <alt_tse_mac_set_speed+0x58>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8220444:	e0bffd17 	ldw	r2,-12(fp)
 8220448:	10800214 	ori	r2,r2,8
 822044c:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8220450:	e0fffd17 	ldw	r3,-12(fp)
 8220454:	00bf8034 	movhi	r2,65024
 8220458:	10bfffc4 	addi	r2,r2,-1
 822045c:	1884703a 	and	r2,r3,r2
 8220460:	e0bffd15 	stw	r2,-12(fp)
 8220464:	00001906 	br	82204cc <alt_tse_mac_set_speed+0xbc>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
 8220468:	e0bfff03 	ldbu	r2,-4(fp)
 822046c:	10800058 	cmpnei	r2,r2,1
 8220470:	10000a1e 	bne	r2,zero,822049c <alt_tse_mac_set_speed+0x8c>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8220474:	e0fffd17 	ldw	r3,-12(fp)
 8220478:	00bffdc4 	movi	r2,-9
 822047c:	1884703a 	and	r2,r3,r2
 8220480:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8220484:	e0fffd17 	ldw	r3,-12(fp)
 8220488:	00bf8034 	movhi	r2,65024
 822048c:	10bfffc4 	addi	r2,r2,-1
 8220490:	1884703a 	and	r2,r3,r2
 8220494:	e0bffd15 	stw	r2,-12(fp)
 8220498:	00000c06 	br	82204cc <alt_tse_mac_set_speed+0xbc>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
 822049c:	e0bfff03 	ldbu	r2,-4(fp)
 82204a0:	1000081e 	bne	r2,zero,82204c4 <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 82204a4:	e0fffd17 	ldw	r3,-12(fp)
 82204a8:	00bffdc4 	movi	r2,-9
 82204ac:	1884703a 	and	r2,r3,r2
 82204b0:	e0bffd15 	stw	r2,-12(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 82204b4:	e0bffd17 	ldw	r2,-12(fp)
 82204b8:	10808034 	orhi	r2,r2,512
 82204bc:	e0bffd15 	stw	r2,-12(fp)
 82204c0:	00000206 	br	82204cc <alt_tse_mac_set_speed+0xbc>
  }  
  else {
    return ENP_PARAM;
 82204c4:	00bffd84 	movi	r2,-10
 82204c8:	00000506 	br	82204e0 <alt_tse_mac_set_speed+0xd0>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 82204cc:	e0bffe17 	ldw	r2,-8(fp)
 82204d0:	10800204 	addi	r2,r2,8
 82204d4:	e0fffd17 	ldw	r3,-12(fp)
 82204d8:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 82204dc:	0005883a 	mov	r2,zero
}
 82204e0:	e037883a 	mov	sp,fp
 82204e4:	df000017 	ldw	fp,0(sp)
 82204e8:	dec00104 	addi	sp,sp,4
 82204ec:	f800283a 	ret

082204f0 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
 82204f0:	defffc04 	addi	sp,sp,-16
 82204f4:	df000315 	stw	fp,12(sp)
 82204f8:	df000304 	addi	fp,sp,12
 82204fc:	e13ffe15 	stw	r4,-8(fp)
 8220500:	2805883a 	mov	r2,r5
 8220504:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 8220508:	e0bffe17 	ldw	r2,-8(fp)
 822050c:	10800204 	addi	r2,r2,8
 8220510:	10800037 	ldwio	r2,0(r2)
 8220514:	e0bffd15 	stw	r2,-12(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 8220518:	e0bfff03 	ldbu	r2,-4(fp)
 822051c:	1000041e 	bne	r2,zero,8220530 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8220520:	e0bffd17 	ldw	r2,-12(fp)
 8220524:	10810014 	ori	r2,r2,1024
 8220528:	e0bffd15 	stw	r2,-12(fp)
 822052c:	00000a06 	br	8220558 <alt_tse_mac_set_duplex+0x68>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
 8220530:	e0bfff03 	ldbu	r2,-4(fp)
 8220534:	10800058 	cmpnei	r2,r2,1
 8220538:	1000051e 	bne	r2,zero,8220550 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 822053c:	e0fffd17 	ldw	r3,-12(fp)
 8220540:	00beffc4 	movi	r2,-1025
 8220544:	1884703a 	and	r2,r3,r2
 8220548:	e0bffd15 	stw	r2,-12(fp)
 822054c:	00000206 	br	8220558 <alt_tse_mac_set_duplex+0x68>
  }
  else {
    return ENP_PARAM;
 8220550:	00bffd84 	movi	r2,-10
 8220554:	00000506 	br	822056c <alt_tse_mac_set_duplex+0x7c>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 8220558:	e0bffe17 	ldw	r2,-8(fp)
 822055c:	10800204 	addi	r2,r2,8
 8220560:	e0fffd17 	ldw	r3,-12(fp)
 8220564:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 8220568:	0005883a 	mov	r2,zero

}
 822056c:	e037883a 	mov	sp,fp
 8220570:	df000017 	ldw	fp,0(sp)
 8220574:	dec00104 	addi	sp,sp,4
 8220578:	f800283a 	ret

0822057c <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
 822057c:	defff404 	addi	sp,sp,-48
 8220580:	dfc00b15 	stw	ra,44(sp)
 8220584:	df000a15 	stw	fp,40(sp)
 8220588:	df000a04 	addi	fp,sp,40
 822058c:	e13fff15 	stw	r4,-4(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220590:	00800044 	movi	r2,1
 8220594:	e0bff705 	stb	r2,-36(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
 8220598:	00800044 	movi	r2,1
 822059c:	e0bff745 	stb	r2,-35(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 82205a0:	e0bff743 	ldbu	r2,-35(fp)
 82205a4:	10c0004c 	andi	r3,r2,1
 82205a8:	e0bff703 	ldbu	r2,-36(fp)
 82205ac:	10800098 	cmpnei	r2,r2,2
 82205b0:	1000021e 	bne	r2,zero,82205bc <getPHYSpeed+0x40>
 82205b4:	00800084 	movi	r2,2
 82205b8:	00000106 	br	82205c0 <getPHYSpeed+0x44>
 82205bc:	0005883a 	mov	r2,zero
 82205c0:	1886b03a 	or	r3,r3,r2
 82205c4:	e0bff703 	ldbu	r2,-36(fp)
 82205c8:	10800058 	cmpnei	r2,r2,1
 82205cc:	1000021e 	bne	r2,zero,82205d8 <getPHYSpeed+0x5c>
 82205d0:	00800104 	movi	r2,4
 82205d4:	00000106 	br	82205dc <getPHYSpeed+0x60>
 82205d8:	0005883a 	mov	r2,zero
 82205dc:	1886b03a 	or	r3,r3,r2
 82205e0:	e0bff703 	ldbu	r2,-36(fp)
 82205e4:	1000021e 	bne	r2,zero,82205f0 <getPHYSpeed+0x74>
 82205e8:	00800204 	movi	r2,8
 82205ec:	00000106 	br	82205f4 <getPHYSpeed+0x78>
 82205f0:	0005883a 	mov	r2,zero
 82205f4:	1886b03a 	or	r3,r3,r2
 82205f8:	e0bff703 	ldbu	r2,-36(fp)
 82205fc:	108000d8 	cmpnei	r2,r2,3
 8220600:	1000021e 	bne	r2,zero,822060c <getPHYSpeed+0x90>
 8220604:	00800074 	movhi	r2,1
 8220608:	00000106 	br	8220610 <getPHYSpeed+0x94>
 822060c:	0005883a 	mov	r2,zero
 8220610:	1884b03a 	or	r2,r3,r2
 8220614:	e0bff815 	stw	r2,-32(fp)
    
    alt_tse_phy_info *pphy = 0;
 8220618:	e03ff915 	stw	zero,-28(fp)
    alt_tse_mac_info *pmac_info = 0;
 822061c:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_group *pmac_group = 0;
 8220620:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_system_info *psys = 0;
 8220624:	e03ffc15 	stw	zero,-16(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 8220628:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = 0;
 822062c:	e03ffd45 	stb	zero,-11(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
 8220630:	d0a07fc3 	ldbu	r2,-32257(gp)
 8220634:	10803fcc 	andi	r2,r2,255
 8220638:	1000031e 	bne	r2,zero,8220648 <getPHYSpeed+0xcc>
        alt_tse_phy_init();
 822063c:	822257c0 	call	822257c <alt_tse_phy_init>
        is_init = 1;
 8220640:	00800044 	movi	r2,1
 8220644:	d0a07fc5 	stb	r2,-32257(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
 8220648:	e13fff17 	ldw	r4,-4(fp)
 822064c:	82203380 	call	8220338 <alt_tse_get_mac_info>
 8220650:	e0bffa15 	stw	r2,-24(fp)
    
    if(pmac_info == 0) {
 8220654:	e0bffa17 	ldw	r2,-24(fp)
 8220658:	1000481e 	bne	r2,zero,822077c <getPHYSpeed+0x200>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 822065c:	00800044 	movi	r2,1
 8220660:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220664:	00800044 	movi	r2,1
 8220668:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
 822066c:	e0bff743 	ldbu	r2,-35(fp)
 8220670:	10c0004c 	andi	r3,r2,1
 8220674:	e0bff703 	ldbu	r2,-36(fp)
 8220678:	10800098 	cmpnei	r2,r2,2
 822067c:	1000021e 	bne	r2,zero,8220688 <getPHYSpeed+0x10c>
 8220680:	00800084 	movi	r2,2
 8220684:	00000106 	br	822068c <getPHYSpeed+0x110>
 8220688:	0005883a 	mov	r2,zero
 822068c:	1886b03a 	or	r3,r3,r2
 8220690:	e0bff703 	ldbu	r2,-36(fp)
 8220694:	10800058 	cmpnei	r2,r2,1
 8220698:	1000021e 	bne	r2,zero,82206a4 <getPHYSpeed+0x128>
 822069c:	00800104 	movi	r2,4
 82206a0:	00000106 	br	82206a8 <getPHYSpeed+0x12c>
 82206a4:	0005883a 	mov	r2,zero
 82206a8:	1886b03a 	or	r3,r3,r2
 82206ac:	e0bff703 	ldbu	r2,-36(fp)
 82206b0:	1000021e 	bne	r2,zero,82206bc <getPHYSpeed+0x140>
 82206b4:	00800204 	movi	r2,8
 82206b8:	00000106 	br	82206c0 <getPHYSpeed+0x144>
 82206bc:	0005883a 	mov	r2,zero
 82206c0:	1886b03a 	or	r3,r3,r2
 82206c4:	e0bff703 	ldbu	r2,-36(fp)
 82206c8:	108000d8 	cmpnei	r2,r2,3
 82206cc:	1000021e 	bne	r2,zero,82206d8 <getPHYSpeed+0x15c>
 82206d0:	00800074 	movhi	r2,1
 82206d4:	00000106 	br	82206dc <getPHYSpeed+0x160>
 82206d8:	0005883a 	mov	r2,zero
 82206dc:	1884b03a 	or	r2,r3,r2
 82206e0:	10802034 	orhi	r2,r2,128
 82206e4:	e0bff815 	stw	r2,-32(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
 82206e8:	e0bff703 	ldbu	r2,-36(fp)
 82206ec:	108000a0 	cmpeqi	r2,r2,2
 82206f0:	10000e1e 	bne	r2,zero,822072c <getPHYSpeed+0x1b0>
 82206f4:	e0bff703 	ldbu	r2,-36(fp)
 82206f8:	10800060 	cmpeqi	r2,r2,1
 82206fc:	1000081e 	bne	r2,zero,8220720 <getPHYSpeed+0x1a4>
 8220700:	e0bff703 	ldbu	r2,-36(fp)
 8220704:	1000031e 	bne	r2,zero,8220714 <getPHYSpeed+0x198>
 8220708:	00820974 	movhi	r2,2085
 822070c:	10b8f204 	addi	r2,r2,-7224
 8220710:	00000806 	br	8220734 <getPHYSpeed+0x1b8>
 8220714:	00820974 	movhi	r2,2085
 8220718:	10b8f304 	addi	r2,r2,-7220
 822071c:	00000506 	br	8220734 <getPHYSpeed+0x1b8>
 8220720:	00820974 	movhi	r2,2085
 8220724:	10b8f504 	addi	r2,r2,-7212
 8220728:	00000206 	br	8220734 <getPHYSpeed+0x1b8>
 822072c:	00820974 	movhi	r2,2085
 8220730:	10b8f604 	addi	r2,r2,-7208
 8220734:	e0fff743 	ldbu	r3,-35(fp)
 8220738:	18c00058 	cmpnei	r3,r3,1
 822073c:	1800031e 	bne	r3,zero,822074c <getPHYSpeed+0x1d0>
 8220740:	00c20974 	movhi	r3,2085
 8220744:	18f8f804 	addi	r3,r3,-7200
 8220748:	00000206 	br	8220754 <getPHYSpeed+0x1d8>
 822074c:	00c20974 	movhi	r3,2085
 8220750:	18f8fa04 	addi	r3,r3,-7192
 8220754:	180d883a 	mov	r6,r3
 8220758:	100b883a 	mov	r5,r2
 822075c:	01020974 	movhi	r4,2085
 8220760:	2138fc04 	addi	r4,r4,-7184
 8220764:	820331c0 	call	820331c <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
 8220768:	01020974 	movhi	r4,2085
 822076c:	21391404 	addi	r4,r4,-7088
 8220770:	82035a00 	call	82035a0 <puts>
        return result;
 8220774:	e0bff817 	ldw	r2,-32(fp)
 8220778:	00021d06 	br	8220ff0 <getPHYSpeed+0xa74>
    }
    
    pphy = pmac_info->pphy_info;
 822077c:	e0bffa17 	ldw	r2,-24(fp)
 8220780:	10800117 	ldw	r2,4(r2)
 8220784:	e0bff915 	stw	r2,-28(fp)
    pmac_group = pmac_info->pmac_group;
 8220788:	e0bffa17 	ldw	r2,-24(fp)
 822078c:	10800317 	ldw	r2,12(r2)
 8220790:	e0bffb15 	stw	r2,-20(fp)
    psys = pmac_info->psys_info;
 8220794:	e0bffa17 	ldw	r2,-24(fp)
 8220798:	10800217 	ldw	r2,8(r2)
 822079c:	e0bffc15 	stw	r2,-16(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82207a0:	e13ffa17 	ldw	r4,-24(fp)
 82207a4:	82202b80 	call	82202b8 <alt_tse_get_mac_info_index>
 82207a8:	e0bffd05 	stb	r2,-12(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 82207ac:	e13ffb17 	ldw	r4,-20(fp)
 82207b0:	82202440 	call	8220244 <alt_tse_get_mac_group_index>
 82207b4:	e0bffd45 	stb	r2,-11(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
 82207b8:	e0bffb17 	ldw	r2,-20(fp)
 82207bc:	10800117 	ldw	r2,4(r2)
 82207c0:	10800217 	ldw	r2,8(r2)
 82207c4:	10800203 	ldbu	r2,8(r2)
 82207c8:	10803fcc 	andi	r2,r2,255
 82207cc:	10005a1e 	bne	r2,zero,8220938 <getPHYSpeed+0x3bc>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 82207d0:	00800044 	movi	r2,1
 82207d4:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 82207d8:	00800044 	movi	r2,1
 82207dc:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
 82207e0:	e0bff743 	ldbu	r2,-35(fp)
 82207e4:	10c0004c 	andi	r3,r2,1
 82207e8:	e0bff703 	ldbu	r2,-36(fp)
 82207ec:	10800098 	cmpnei	r2,r2,2
 82207f0:	1000021e 	bne	r2,zero,82207fc <getPHYSpeed+0x280>
 82207f4:	00800084 	movi	r2,2
 82207f8:	00000106 	br	8220800 <getPHYSpeed+0x284>
 82207fc:	0005883a 	mov	r2,zero
 8220800:	1886b03a 	or	r3,r3,r2
 8220804:	e0bff703 	ldbu	r2,-36(fp)
 8220808:	10800058 	cmpnei	r2,r2,1
 822080c:	1000021e 	bne	r2,zero,8220818 <getPHYSpeed+0x29c>
 8220810:	00800104 	movi	r2,4
 8220814:	00000106 	br	822081c <getPHYSpeed+0x2a0>
 8220818:	0005883a 	mov	r2,zero
 822081c:	1886b03a 	or	r3,r3,r2
 8220820:	e0bff703 	ldbu	r2,-36(fp)
 8220824:	1000021e 	bne	r2,zero,8220830 <getPHYSpeed+0x2b4>
 8220828:	00800204 	movi	r2,8
 822082c:	00000106 	br	8220834 <getPHYSpeed+0x2b8>
 8220830:	0005883a 	mov	r2,zero
 8220834:	1886b03a 	or	r3,r3,r2
 8220838:	e0bff703 	ldbu	r2,-36(fp)
 822083c:	108000d8 	cmpnei	r2,r2,3
 8220840:	1000021e 	bne	r2,zero,822084c <getPHYSpeed+0x2d0>
 8220844:	00800074 	movhi	r2,1
 8220848:	00000106 	br	8220850 <getPHYSpeed+0x2d4>
 822084c:	0005883a 	mov	r2,zero
 8220850:	1884b03a 	or	r2,r3,r2
 8220854:	10801034 	orhi	r2,r2,64
 8220858:	e0bff815 	stw	r2,-32(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
 822085c:	010003f4 	movhi	r4,15
 8220860:	21109004 	addi	r4,r4,16960
 8220864:	823c8b40 	call	823c8b4 <usleep>
        if(psys->tse_phy_cfg) {
 8220868:	e0bffc17 	ldw	r2,-16(fp)
 822086c:	10801117 	ldw	r2,68(r2)
 8220870:	10000d26 	beq	r2,zero,82208a8 <getPHYSpeed+0x32c>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
 8220874:	e0bffd47 	ldb	r2,-11(fp)
 8220878:	e0fffd07 	ldb	r3,-12(fp)
 822087c:	180d883a 	mov	r6,r3
 8220880:	100b883a 	mov	r5,r2
 8220884:	01020974 	movhi	r4,2085
 8220888:	21392504 	addi	r4,r4,-7020
 822088c:	820331c0 	call	820331c <printf>
        	result = psys->tse_phy_cfg(pmac);
 8220890:	e0bffc17 	ldw	r2,-16(fp)
 8220894:	10801117 	ldw	r2,68(r2)
 8220898:	e13fff17 	ldw	r4,-4(fp)
 822089c:	103ee83a 	callr	r2
 82208a0:	e0bff815 	stw	r2,-32(fp)
 82208a4:	00002206 	br	8220930 <getPHYSpeed+0x3b4>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 82208a8:	e13ffd47 	ldb	r4,-11(fp)
 82208ac:	e0bff703 	ldbu	r2,-36(fp)
 82208b0:	108000a0 	cmpeqi	r2,r2,2
 82208b4:	10000e1e 	bne	r2,zero,82208f0 <getPHYSpeed+0x374>
 82208b8:	e0bff703 	ldbu	r2,-36(fp)
 82208bc:	10800060 	cmpeqi	r2,r2,1
 82208c0:	1000081e 	bne	r2,zero,82208e4 <getPHYSpeed+0x368>
 82208c4:	e0bff703 	ldbu	r2,-36(fp)
 82208c8:	1000031e 	bne	r2,zero,82208d8 <getPHYSpeed+0x35c>
 82208cc:	00820974 	movhi	r2,2085
 82208d0:	10b8f204 	addi	r2,r2,-7224
 82208d4:	00000806 	br	82208f8 <getPHYSpeed+0x37c>
 82208d8:	00820974 	movhi	r2,2085
 82208dc:	10b8f304 	addi	r2,r2,-7220
 82208e0:	00000506 	br	82208f8 <getPHYSpeed+0x37c>
 82208e4:	00820974 	movhi	r2,2085
 82208e8:	10b8f504 	addi	r2,r2,-7212
 82208ec:	00000206 	br	82208f8 <getPHYSpeed+0x37c>
 82208f0:	00820974 	movhi	r2,2085
 82208f4:	10b8f604 	addi	r2,r2,-7208
 82208f8:	e0fff743 	ldbu	r3,-35(fp)
 82208fc:	18c00058 	cmpnei	r3,r3,1
 8220900:	1800031e 	bne	r3,zero,8220910 <getPHYSpeed+0x394>
 8220904:	00c20974 	movhi	r3,2085
 8220908:	18f8f804 	addi	r3,r3,-7200
 822090c:	00000206 	br	8220918 <getPHYSpeed+0x39c>
 8220910:	00c20974 	movhi	r3,2085
 8220914:	18f8fa04 	addi	r3,r3,-7192
 8220918:	180f883a 	mov	r7,r3
 822091c:	100d883a 	mov	r6,r2
 8220920:	200b883a 	mov	r5,r4
 8220924:	01020974 	movhi	r4,2085
 8220928:	21393704 	addi	r4,r4,-6948
 822092c:	820331c0 	call	820331c <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
 8220930:	e0bff817 	ldw	r2,-32(fp)
 8220934:	0001ae06 	br	8220ff0 <getPHYSpeed+0xa74>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8220938:	e0bffb17 	ldw	r2,-20(fp)
 822093c:	10800117 	ldw	r2,4(r2)
 8220940:	10800217 	ldw	r2,8(r2)
 8220944:	10800017 	ldw	r2,0(r2)
 8220948:	e0bffe15 	stw	r2,-8(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
 822094c:	e0bff917 	ldw	r2,-28(fp)
 8220950:	1000491e 	bne	r2,zero,8220a78 <getPHYSpeed+0x4fc>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220954:	00800044 	movi	r2,1
 8220958:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 822095c:	00800044 	movi	r2,1
 8220960:	e0bff745 	stb	r2,-35(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
 8220964:	e0bff743 	ldbu	r2,-35(fp)
 8220968:	10c0004c 	andi	r3,r2,1
 822096c:	e0bff703 	ldbu	r2,-36(fp)
 8220970:	10800098 	cmpnei	r2,r2,2
 8220974:	1000021e 	bne	r2,zero,8220980 <getPHYSpeed+0x404>
 8220978:	00800084 	movi	r2,2
 822097c:	00000106 	br	8220984 <getPHYSpeed+0x408>
 8220980:	0005883a 	mov	r2,zero
 8220984:	1886b03a 	or	r3,r3,r2
 8220988:	e0bff703 	ldbu	r2,-36(fp)
 822098c:	10800058 	cmpnei	r2,r2,1
 8220990:	1000021e 	bne	r2,zero,822099c <getPHYSpeed+0x420>
 8220994:	00800104 	movi	r2,4
 8220998:	00000106 	br	82209a0 <getPHYSpeed+0x424>
 822099c:	0005883a 	mov	r2,zero
 82209a0:	1886b03a 	or	r3,r3,r2
 82209a4:	e0bff703 	ldbu	r2,-36(fp)
 82209a8:	1000021e 	bne	r2,zero,82209b4 <getPHYSpeed+0x438>
 82209ac:	00800204 	movi	r2,8
 82209b0:	00000106 	br	82209b8 <getPHYSpeed+0x43c>
 82209b4:	0005883a 	mov	r2,zero
 82209b8:	1886b03a 	or	r3,r3,r2
 82209bc:	e0bff703 	ldbu	r2,-36(fp)
 82209c0:	108000d8 	cmpnei	r2,r2,3
 82209c4:	1000021e 	bne	r2,zero,82209d0 <getPHYSpeed+0x454>
 82209c8:	00800074 	movhi	r2,1
 82209cc:	00000106 	br	82209d4 <getPHYSpeed+0x458>
 82209d0:	0005883a 	mov	r2,zero
 82209d4:	1884b03a 	or	r2,r3,r2
 82209d8:	10800834 	orhi	r2,r2,32
 82209dc:	e0bff815 	stw	r2,-32(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 82209e0:	e13ffd47 	ldb	r4,-11(fp)
 82209e4:	e17ffd07 	ldb	r5,-12(fp)
 82209e8:	e0bff703 	ldbu	r2,-36(fp)
 82209ec:	108000a0 	cmpeqi	r2,r2,2
 82209f0:	10000e1e 	bne	r2,zero,8220a2c <getPHYSpeed+0x4b0>
 82209f4:	e0bff703 	ldbu	r2,-36(fp)
 82209f8:	10800060 	cmpeqi	r2,r2,1
 82209fc:	1000081e 	bne	r2,zero,8220a20 <getPHYSpeed+0x4a4>
 8220a00:	e0bff703 	ldbu	r2,-36(fp)
 8220a04:	1000031e 	bne	r2,zero,8220a14 <getPHYSpeed+0x498>
 8220a08:	00820974 	movhi	r2,2085
 8220a0c:	10b8f204 	addi	r2,r2,-7224
 8220a10:	00000806 	br	8220a34 <getPHYSpeed+0x4b8>
 8220a14:	00820974 	movhi	r2,2085
 8220a18:	10b8f304 	addi	r2,r2,-7220
 8220a1c:	00000506 	br	8220a34 <getPHYSpeed+0x4b8>
 8220a20:	00820974 	movhi	r2,2085
 8220a24:	10b8f504 	addi	r2,r2,-7212
 8220a28:	00000206 	br	8220a34 <getPHYSpeed+0x4b8>
 8220a2c:	00820974 	movhi	r2,2085
 8220a30:	10b8f604 	addi	r2,r2,-7208
 8220a34:	e0fff743 	ldbu	r3,-35(fp)
 8220a38:	18c00058 	cmpnei	r3,r3,1
 8220a3c:	1800031e 	bne	r3,zero,8220a4c <getPHYSpeed+0x4d0>
 8220a40:	00c20974 	movhi	r3,2085
 8220a44:	18f8f804 	addi	r3,r3,-7200
 8220a48:	00000206 	br	8220a54 <getPHYSpeed+0x4d8>
 8220a4c:	00c20974 	movhi	r3,2085
 8220a50:	18f8fa04 	addi	r3,r3,-7192
 8220a54:	d8c00015 	stw	r3,0(sp)
 8220a58:	100f883a 	mov	r7,r2
 8220a5c:	280d883a 	mov	r6,r5
 8220a60:	200b883a 	mov	r5,r4
 8220a64:	01020974 	movhi	r4,2085
 8220a68:	21394904 	addi	r4,r4,-6876
 8220a6c:	820331c0 	call	820331c <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
 8220a70:	e0bff817 	ldw	r2,-32(fp)
 8220a74:	00015e06 	br	8220ff0 <getPHYSpeed+0xa74>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 8220a78:	e0bffa17 	ldw	r2,-24(fp)
 8220a7c:	10800003 	ldbu	r2,0(r2)
 8220a80:	10803fcc 	andi	r2,r2,255
 8220a84:	10800058 	cmpnei	r2,r2,1
 8220a88:	1000081e 	bne	r2,zero,8220aac <getPHYSpeed+0x530>
			alt_tse_phy_set_adv_1000(pphy, 0);
 8220a8c:	000b883a 	mov	r5,zero
 8220a90:	e13ff917 	ldw	r4,-28(fp)
 8220a94:	8222f480 	call	8222f48 <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8220a98:	01400134 	movhi	r5,4
 8220a9c:	29742404 	addi	r5,r5,-12144
 8220aa0:	e13ff917 	ldw	r4,-28(fp)
 8220aa4:	82226940 	call	8222694 <alt_tse_phy_restart_an>
 8220aa8:	00000f06 	br	8220ae8 <getPHYSpeed+0x56c>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 8220aac:	e0bffa17 	ldw	r2,-24(fp)
 8220ab0:	10800003 	ldbu	r2,0(r2)
 8220ab4:	10803fcc 	andi	r2,r2,255
 8220ab8:	10800098 	cmpnei	r2,r2,2
 8220abc:	10000a1e 	bne	r2,zero,8220ae8 <getPHYSpeed+0x56c>
			alt_tse_phy_set_adv_100(pphy, 0);
 8220ac0:	000b883a 	mov	r5,zero
 8220ac4:	e13ff917 	ldw	r4,-28(fp)
 8220ac8:	822310c0 	call	822310c <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
 8220acc:	000b883a 	mov	r5,zero
 8220ad0:	e13ff917 	ldw	r4,-28(fp)
 8220ad4:	82233600 	call	8223360 <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8220ad8:	01400134 	movhi	r5,4
 8220adc:	29742404 	addi	r5,r5,-12144
 8220ae0:	e13ff917 	ldw	r4,-28(fp)
 8220ae4:	82226940 	call	8222694 <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
 8220ae8:	01400134 	movhi	r5,4
 8220aec:	29742404 	addi	r5,r5,-12144
 8220af0:	e13ff917 	ldw	r4,-28(fp)
 8220af4:	82228500 	call	8222850 <alt_tse_phy_check_link>
 8220af8:	10bfffd8 	cmpnei	r2,r2,-1
 8220afc:	1000491e 	bne	r2,zero,8220c24 <getPHYSpeed+0x6a8>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220b00:	00800044 	movi	r2,1
 8220b04:	e0bff705 	stb	r2,-36(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220b08:	00800044 	movi	r2,1
 8220b0c:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
 8220b10:	e0bff743 	ldbu	r2,-35(fp)
 8220b14:	10c0004c 	andi	r3,r2,1
 8220b18:	e0bff703 	ldbu	r2,-36(fp)
 8220b1c:	10800098 	cmpnei	r2,r2,2
 8220b20:	1000021e 	bne	r2,zero,8220b2c <getPHYSpeed+0x5b0>
 8220b24:	00800084 	movi	r2,2
 8220b28:	00000106 	br	8220b30 <getPHYSpeed+0x5b4>
 8220b2c:	0005883a 	mov	r2,zero
 8220b30:	1886b03a 	or	r3,r3,r2
 8220b34:	e0bff703 	ldbu	r2,-36(fp)
 8220b38:	10800058 	cmpnei	r2,r2,1
 8220b3c:	1000021e 	bne	r2,zero,8220b48 <getPHYSpeed+0x5cc>
 8220b40:	00800104 	movi	r2,4
 8220b44:	00000106 	br	8220b4c <getPHYSpeed+0x5d0>
 8220b48:	0005883a 	mov	r2,zero
 8220b4c:	1886b03a 	or	r3,r3,r2
 8220b50:	e0bff703 	ldbu	r2,-36(fp)
 8220b54:	1000021e 	bne	r2,zero,8220b60 <getPHYSpeed+0x5e4>
 8220b58:	00800204 	movi	r2,8
 8220b5c:	00000106 	br	8220b64 <getPHYSpeed+0x5e8>
 8220b60:	0005883a 	mov	r2,zero
 8220b64:	1886b03a 	or	r3,r3,r2
 8220b68:	e0bff703 	ldbu	r2,-36(fp)
 8220b6c:	108000d8 	cmpnei	r2,r2,3
 8220b70:	1000021e 	bne	r2,zero,8220b7c <getPHYSpeed+0x600>
 8220b74:	00800074 	movhi	r2,1
 8220b78:	00000106 	br	8220b80 <getPHYSpeed+0x604>
 8220b7c:	0005883a 	mov	r2,zero
 8220b80:	1884b03a 	or	r2,r3,r2
 8220b84:	10800234 	orhi	r2,r2,8
 8220b88:	e0bff815 	stw	r2,-32(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 8220b8c:	e13ffd47 	ldb	r4,-11(fp)
 8220b90:	e17ffd07 	ldb	r5,-12(fp)
 8220b94:	e0bff703 	ldbu	r2,-36(fp)
 8220b98:	108000a0 	cmpeqi	r2,r2,2
 8220b9c:	10000e1e 	bne	r2,zero,8220bd8 <getPHYSpeed+0x65c>
 8220ba0:	e0bff703 	ldbu	r2,-36(fp)
 8220ba4:	10800060 	cmpeqi	r2,r2,1
 8220ba8:	1000081e 	bne	r2,zero,8220bcc <getPHYSpeed+0x650>
 8220bac:	e0bff703 	ldbu	r2,-36(fp)
 8220bb0:	1000031e 	bne	r2,zero,8220bc0 <getPHYSpeed+0x644>
 8220bb4:	00820974 	movhi	r2,2085
 8220bb8:	10b8f204 	addi	r2,r2,-7224
 8220bbc:	00000806 	br	8220be0 <getPHYSpeed+0x664>
 8220bc0:	00820974 	movhi	r2,2085
 8220bc4:	10b8f304 	addi	r2,r2,-7220
 8220bc8:	00000506 	br	8220be0 <getPHYSpeed+0x664>
 8220bcc:	00820974 	movhi	r2,2085
 8220bd0:	10b8f504 	addi	r2,r2,-7212
 8220bd4:	00000206 	br	8220be0 <getPHYSpeed+0x664>
 8220bd8:	00820974 	movhi	r2,2085
 8220bdc:	10b8f604 	addi	r2,r2,-7208
 8220be0:	e0fff743 	ldbu	r3,-35(fp)
 8220be4:	18c00058 	cmpnei	r3,r3,1
 8220be8:	1800031e 	bne	r3,zero,8220bf8 <getPHYSpeed+0x67c>
 8220bec:	00c20974 	movhi	r3,2085
 8220bf0:	18f8f804 	addi	r3,r3,-7200
 8220bf4:	00000206 	br	8220c00 <getPHYSpeed+0x684>
 8220bf8:	00c20974 	movhi	r3,2085
 8220bfc:	18f8fa04 	addi	r3,r3,-7192
 8220c00:	d8c00015 	stw	r3,0(sp)
 8220c04:	100f883a 	mov	r7,r2
 8220c08:	280d883a 	mov	r6,r5
 8220c0c:	200b883a 	mov	r5,r4
 8220c10:	01020974 	movhi	r4,2085
 8220c14:	21395a04 	addi	r4,r4,-6808
 8220c18:	820331c0 	call	820331c <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
 8220c1c:	e0bff817 	ldw	r2,-32(fp)
 8220c20:	0000f306 	br	8220ff0 <getPHYSpeed+0xa74>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
 8220c24:	e0bffe17 	ldw	r2,-8(fp)
 8220c28:	10801004 	addi	r2,r2,64
 8220c2c:	e0fff917 	ldw	r3,-28(fp)
 8220c30:	18c00003 	ldbu	r3,0(r3)
 8220c34:	18c03fcc 	andi	r3,r3,255
 8220c38:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 8220c3c:	d8000015 	stw	zero,0(sp)
 8220c40:	01c00044 	movi	r7,1
 8220c44:	01800384 	movi	r6,14
 8220c48:	000b883a 	mov	r5,zero
 8220c4c:	e13ff917 	ldw	r4,-28(fp)
 8220c50:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
 8220c54:	e0bff917 	ldw	r2,-28(fp)
 8220c58:	10800517 	ldw	r2,20(r2)
 8220c5c:	10002b1e 	bne	r2,zero,8220d0c <getPHYSpeed+0x790>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
 8220c60:	e0bffd47 	ldb	r2,-11(fp)
 8220c64:	e0fffd07 	ldb	r3,-12(fp)
 8220c68:	180d883a 	mov	r6,r3
 8220c6c:	100b883a 	mov	r5,r2
 8220c70:	01020974 	movhi	r4,2085
 8220c74:	21396e04 	addi	r4,r4,-6728
 8220c78:	820331c0 	call	820331c <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220c7c:	00800044 	movi	r2,1
 8220c80:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220c84:	00800044 	movi	r2,1
 8220c88:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
 8220c8c:	e0bff743 	ldbu	r2,-35(fp)
 8220c90:	10c0004c 	andi	r3,r2,1
 8220c94:	e0bff703 	ldbu	r2,-36(fp)
 8220c98:	10800098 	cmpnei	r2,r2,2
 8220c9c:	1000021e 	bne	r2,zero,8220ca8 <getPHYSpeed+0x72c>
 8220ca0:	00800084 	movi	r2,2
 8220ca4:	00000106 	br	8220cac <getPHYSpeed+0x730>
 8220ca8:	0005883a 	mov	r2,zero
 8220cac:	1886b03a 	or	r3,r3,r2
 8220cb0:	e0bff703 	ldbu	r2,-36(fp)
 8220cb4:	10800058 	cmpnei	r2,r2,1
 8220cb8:	1000021e 	bne	r2,zero,8220cc4 <getPHYSpeed+0x748>
 8220cbc:	00800104 	movi	r2,4
 8220cc0:	00000106 	br	8220cc8 <getPHYSpeed+0x74c>
 8220cc4:	0005883a 	mov	r2,zero
 8220cc8:	1886b03a 	or	r3,r3,r2
 8220ccc:	e0bff703 	ldbu	r2,-36(fp)
 8220cd0:	1000021e 	bne	r2,zero,8220cdc <getPHYSpeed+0x760>
 8220cd4:	00800204 	movi	r2,8
 8220cd8:	00000106 	br	8220ce0 <getPHYSpeed+0x764>
 8220cdc:	0005883a 	mov	r2,zero
 8220ce0:	1886b03a 	or	r3,r3,r2
 8220ce4:	e0bff703 	ldbu	r2,-36(fp)
 8220ce8:	108000d8 	cmpnei	r2,r2,3
 8220cec:	1000021e 	bne	r2,zero,8220cf8 <getPHYSpeed+0x77c>
 8220cf0:	00800074 	movhi	r2,1
 8220cf4:	00000106 	br	8220cfc <getPHYSpeed+0x780>
 8220cf8:	0005883a 	mov	r2,zero
 8220cfc:	1884b03a 	or	r2,r3,r2
 8220d00:	10800134 	orhi	r2,r2,4
 8220d04:	e0bff815 	stw	r2,-32(fp)
 8220d08:	00009406 	br	8220f5c <getPHYSpeed+0x9e0>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
 8220d0c:	e0bff917 	ldw	r2,-28(fp)
 8220d10:	10800517 	ldw	r2,20(r2)
 8220d14:	10801817 	ldw	r2,96(r2)
 8220d18:	10002626 	beq	r2,zero,8220db4 <getPHYSpeed+0x838>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
 8220d1c:	e0bff917 	ldw	r2,-28(fp)
 8220d20:	10800517 	ldw	r2,20(r2)
 8220d24:	10801817 	ldw	r2,96(r2)
 8220d28:	e13ffe17 	ldw	r4,-8(fp)
 8220d2c:	103ee83a 	callr	r2
 8220d30:	e0bff815 	stw	r2,-32(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 8220d34:	e0bff817 	ldw	r2,-32(fp)
 8220d38:	1080008c 	andi	r2,r2,2
 8220d3c:	10000c1e 	bne	r2,zero,8220d70 <getPHYSpeed+0x7f4>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
 8220d40:	e0bff817 	ldw	r2,-32(fp)
 8220d44:	1080010c 	andi	r2,r2,4
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 8220d48:	1000071e 	bne	r2,zero,8220d68 <getPHYSpeed+0x7ec>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
 8220d4c:	e0bff817 	ldw	r2,-32(fp)
 8220d50:	1080020c 	andi	r2,r2,8
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 8220d54:	10000226 	beq	r2,zero,8220d60 <getPHYSpeed+0x7e4>
 8220d58:	0005883a 	mov	r2,zero
 8220d5c:	00000506 	br	8220d74 <getPHYSpeed+0x7f8>
 8220d60:	008000c4 	movi	r2,3
 8220d64:	00000306 	br	8220d74 <getPHYSpeed+0x7f8>
 8220d68:	00800044 	movi	r2,1
 8220d6c:	00000106 	br	8220d74 <getPHYSpeed+0x7f8>
 8220d70:	00800084 	movi	r2,2
 8220d74:	e0bff705 	stb	r2,-36(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
 8220d78:	e0bff817 	ldw	r2,-32(fp)
 8220d7c:	1080004c 	andi	r2,r2,1
 8220d80:	1004c03a 	cmpne	r2,r2,zero
 8220d84:	e0bff745 	stb	r2,-35(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
 8220d88:	e0bff817 	ldw	r2,-32(fp)
 8220d8c:	1080006c 	andhi	r2,r2,1
 8220d90:	10007226 	beq	r2,zero,8220f5c <getPHYSpeed+0x9e0>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
 8220d94:	e0bffd47 	ldb	r2,-11(fp)
 8220d98:	e0fffd07 	ldb	r3,-12(fp)
 8220d9c:	180d883a 	mov	r6,r3
 8220da0:	100b883a 	mov	r5,r2
 8220da4:	01020974 	movhi	r4,2085
 8220da8:	21397c04 	addi	r4,r4,-6672
 8220dac:	820331c0 	call	820331c <printf>
 8220db0:	00006a06 	br	8220f5c <getPHYSpeed+0x9e0>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
 8220db4:	e0bff917 	ldw	r2,-28(fp)
 8220db8:	10800517 	ldw	r2,20(r2)
 8220dbc:	10801583 	ldbu	r2,86(r2)
 8220dc0:	10803fcc 	andi	r2,r2,255
 8220dc4:	10002b1e 	bne	r2,zero,8220e74 <getPHYSpeed+0x8f8>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
 8220dc8:	e0bffd47 	ldb	r2,-11(fp)
 8220dcc:	e0fffd07 	ldb	r3,-12(fp)
 8220dd0:	180d883a 	mov	r6,r3
 8220dd4:	100b883a 	mov	r5,r2
 8220dd8:	01020974 	movhi	r4,2085
 8220ddc:	21398904 	addi	r4,r4,-6620
 8220de0:	820331c0 	call	820331c <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 8220de4:	00800044 	movi	r2,1
 8220de8:	e0bff705 	stb	r2,-36(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 8220dec:	00800044 	movi	r2,1
 8220df0:	e0bff745 	stb	r2,-35(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
 8220df4:	e0bff743 	ldbu	r2,-35(fp)
 8220df8:	10c0004c 	andi	r3,r2,1
 8220dfc:	e0bff703 	ldbu	r2,-36(fp)
 8220e00:	10800098 	cmpnei	r2,r2,2
 8220e04:	1000021e 	bne	r2,zero,8220e10 <getPHYSpeed+0x894>
 8220e08:	00800084 	movi	r2,2
 8220e0c:	00000106 	br	8220e14 <getPHYSpeed+0x898>
 8220e10:	0005883a 	mov	r2,zero
 8220e14:	1886b03a 	or	r3,r3,r2
 8220e18:	e0bff703 	ldbu	r2,-36(fp)
 8220e1c:	10800058 	cmpnei	r2,r2,1
 8220e20:	1000021e 	bne	r2,zero,8220e2c <getPHYSpeed+0x8b0>
 8220e24:	00800104 	movi	r2,4
 8220e28:	00000106 	br	8220e30 <getPHYSpeed+0x8b4>
 8220e2c:	0005883a 	mov	r2,zero
 8220e30:	1886b03a 	or	r3,r3,r2
 8220e34:	e0bff703 	ldbu	r2,-36(fp)
 8220e38:	1000021e 	bne	r2,zero,8220e44 <getPHYSpeed+0x8c8>
 8220e3c:	00800204 	movi	r2,8
 8220e40:	00000106 	br	8220e48 <getPHYSpeed+0x8cc>
 8220e44:	0005883a 	mov	r2,zero
 8220e48:	1886b03a 	or	r3,r3,r2
 8220e4c:	e0bff703 	ldbu	r2,-36(fp)
 8220e50:	108000d8 	cmpnei	r2,r2,3
 8220e54:	1000021e 	bne	r2,zero,8220e60 <getPHYSpeed+0x8e4>
 8220e58:	00800074 	movhi	r2,1
 8220e5c:	00000106 	br	8220e64 <getPHYSpeed+0x8e8>
 8220e60:	0005883a 	mov	r2,zero
 8220e64:	1884b03a 	or	r2,r3,r2
 8220e68:	108000b4 	orhi	r2,r2,2
 8220e6c:	e0bff815 	stw	r2,-32(fp)
 8220e70:	00003a06 	br	8220f5c <getPHYSpeed+0x9e0>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 8220e74:	e0bff917 	ldw	r2,-28(fp)
 8220e78:	10800517 	ldw	r2,20(r2)
 8220e7c:	10801583 	ldbu	r2,86(r2)
 8220e80:	10c03fcc 	andi	r3,r2,255
 8220e84:	e0bff917 	ldw	r2,-28(fp)
 8220e88:	10800517 	ldw	r2,20(r2)
 8220e8c:	108015c3 	ldbu	r2,87(r2)
 8220e90:	10803fcc 	andi	r2,r2,255
 8220e94:	01c00084 	movi	r7,2
 8220e98:	100d883a 	mov	r6,r2
 8220e9c:	180b883a 	mov	r5,r3
 8220ea0:	e13ff917 	ldw	r4,-28(fp)
 8220ea4:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8220ea8:	e0bff705 	stb	r2,-36(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 8220eac:	e0bff917 	ldw	r2,-28(fp)
 8220eb0:	10800517 	ldw	r2,20(r2)
 8220eb4:	10801583 	ldbu	r2,86(r2)
 8220eb8:	10c03fcc 	andi	r3,r2,255
 8220ebc:	e0bff917 	ldw	r2,-28(fp)
 8220ec0:	10800517 	ldw	r2,20(r2)
 8220ec4:	10801603 	ldbu	r2,88(r2)
 8220ec8:	10803fcc 	andi	r2,r2,255
 8220ecc:	01c00044 	movi	r7,1
 8220ed0:	100d883a 	mov	r6,r2
 8220ed4:	180b883a 	mov	r5,r3
 8220ed8:	e13ff917 	ldw	r4,-28(fp)
 8220edc:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8220ee0:	e0bff745 	stb	r2,-35(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 8220ee4:	e0bff743 	ldbu	r2,-35(fp)
 8220ee8:	10c0004c 	andi	r3,r2,1
 8220eec:	e0bff703 	ldbu	r2,-36(fp)
 8220ef0:	10800098 	cmpnei	r2,r2,2
 8220ef4:	1000021e 	bne	r2,zero,8220f00 <getPHYSpeed+0x984>
 8220ef8:	00800084 	movi	r2,2
 8220efc:	00000106 	br	8220f04 <getPHYSpeed+0x988>
 8220f00:	0005883a 	mov	r2,zero
 8220f04:	1886b03a 	or	r3,r3,r2
 8220f08:	e0bff703 	ldbu	r2,-36(fp)
 8220f0c:	10800058 	cmpnei	r2,r2,1
 8220f10:	1000021e 	bne	r2,zero,8220f1c <getPHYSpeed+0x9a0>
 8220f14:	00800104 	movi	r2,4
 8220f18:	00000106 	br	8220f20 <getPHYSpeed+0x9a4>
 8220f1c:	0005883a 	mov	r2,zero
 8220f20:	1886b03a 	or	r3,r3,r2
 8220f24:	e0bff703 	ldbu	r2,-36(fp)
 8220f28:	1000021e 	bne	r2,zero,8220f34 <getPHYSpeed+0x9b8>
 8220f2c:	00800204 	movi	r2,8
 8220f30:	00000106 	br	8220f38 <getPHYSpeed+0x9bc>
 8220f34:	0005883a 	mov	r2,zero
 8220f38:	1886b03a 	or	r3,r3,r2
 8220f3c:	e0bff703 	ldbu	r2,-36(fp)
 8220f40:	108000d8 	cmpnei	r2,r2,3
 8220f44:	1000021e 	bne	r2,zero,8220f50 <getPHYSpeed+0x9d4>
 8220f48:	00800074 	movhi	r2,1
 8220f4c:	00000106 	br	8220f54 <getPHYSpeed+0x9d8>
 8220f50:	0005883a 	mov	r2,zero
 8220f54:	1884b03a 	or	r2,r3,r2
 8220f58:	e0bff815 	stw	r2,-32(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 8220f5c:	e13ffd47 	ldb	r4,-11(fp)
 8220f60:	e17ffd07 	ldb	r5,-12(fp)
 8220f64:	e0bff703 	ldbu	r2,-36(fp)
 8220f68:	108000a0 	cmpeqi	r2,r2,2
 8220f6c:	10000e1e 	bne	r2,zero,8220fa8 <getPHYSpeed+0xa2c>
 8220f70:	e0bff703 	ldbu	r2,-36(fp)
 8220f74:	10800060 	cmpeqi	r2,r2,1
 8220f78:	1000081e 	bne	r2,zero,8220f9c <getPHYSpeed+0xa20>
 8220f7c:	e0bff703 	ldbu	r2,-36(fp)
 8220f80:	1000031e 	bne	r2,zero,8220f90 <getPHYSpeed+0xa14>
 8220f84:	00820974 	movhi	r2,2085
 8220f88:	10b8f204 	addi	r2,r2,-7224
 8220f8c:	00000806 	br	8220fb0 <getPHYSpeed+0xa34>
 8220f90:	00820974 	movhi	r2,2085
 8220f94:	10b8f304 	addi	r2,r2,-7220
 8220f98:	00000506 	br	8220fb0 <getPHYSpeed+0xa34>
 8220f9c:	00820974 	movhi	r2,2085
 8220fa0:	10b8f504 	addi	r2,r2,-7212
 8220fa4:	00000206 	br	8220fb0 <getPHYSpeed+0xa34>
 8220fa8:	00820974 	movhi	r2,2085
 8220fac:	10b8f604 	addi	r2,r2,-7208
 8220fb0:	e0fff743 	ldbu	r3,-35(fp)
 8220fb4:	18c00058 	cmpnei	r3,r3,1
 8220fb8:	1800031e 	bne	r3,zero,8220fc8 <getPHYSpeed+0xa4c>
 8220fbc:	00c20974 	movhi	r3,2085
 8220fc0:	18f8f804 	addi	r3,r3,-7200
 8220fc4:	00000206 	br	8220fd0 <getPHYSpeed+0xa54>
 8220fc8:	00c20974 	movhi	r3,2085
 8220fcc:	18f8fa04 	addi	r3,r3,-7192
 8220fd0:	d8c00015 	stw	r3,0(sp)
 8220fd4:	100f883a 	mov	r7,r2
 8220fd8:	280d883a 	mov	r6,r5
 8220fdc:	200b883a 	mov	r5,r4
 8220fe0:	01020974 	movhi	r4,2085
 8220fe4:	2139a004 	addi	r4,r4,-6528
 8220fe8:	820331c0 	call	820331c <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
 8220fec:	e0bff817 	ldw	r2,-32(fp)
}
 8220ff0:	e037883a 	mov	sp,fp
 8220ff4:	dfc00117 	ldw	ra,4(sp)
 8220ff8:	df000017 	ldw	fp,0(sp)
 8220ffc:	dec00204 	addi	sp,sp,8
 8221000:	f800283a 	ret

08221004 <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
 8221004:	defffd04 	addi	sp,sp,-12
 8221008:	df000215 	stw	fp,8(sp)
 822100c:	df000204 	addi	fp,sp,8
 8221010:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8221014:	e0bfff17 	ldw	r2,-4(fp)
 8221018:	10800617 	ldw	r2,24(r2)
 822101c:	10800317 	ldw	r2,12(r2)
 8221020:	10800117 	ldw	r2,4(r2)
 8221024:	10800217 	ldw	r2,8(r2)
 8221028:	10800017 	ldw	r2,0(r2)
 822102c:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
 8221030:	e0bffe17 	ldw	r2,-8(fp)
 8221034:	10801004 	addi	r2,r2,64
 8221038:	10800037 	ldwio	r2,0(r2)
}
 822103c:	e037883a 	mov	sp,fp
 8221040:	df000017 	ldw	fp,0(sp)
 8221044:	dec00104 	addi	sp,sp,4
 8221048:	f800283a 	ret

0822104c <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
 822104c:	defffc04 	addi	sp,sp,-16
 8221050:	df000315 	stw	fp,12(sp)
 8221054:	df000304 	addi	fp,sp,12
 8221058:	e13ffe15 	stw	r4,-8(fp)
 822105c:	2805883a 	mov	r2,r5
 8221060:	e0bfff05 	stb	r2,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8221064:	e0bffe17 	ldw	r2,-8(fp)
 8221068:	10800617 	ldw	r2,24(r2)
 822106c:	10800317 	ldw	r2,12(r2)
 8221070:	10800117 	ldw	r2,4(r2)
 8221074:	10800217 	ldw	r2,8(r2)
 8221078:	10800017 	ldw	r2,0(r2)
 822107c:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
 8221080:	e0bffd17 	ldw	r2,-12(fp)
 8221084:	10801004 	addi	r2,r2,64
 8221088:	e0ffff03 	ldbu	r3,-4(fp)
 822108c:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 8221090:	0005883a 	mov	r2,zero
}
 8221094:	e037883a 	mov	sp,fp
 8221098:	df000017 	ldw	fp,0(sp)
 822109c:	dec00104 	addi	sp,sp,4
 82210a0:	f800283a 	ret

082210a4 <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
 82210a4:	defff604 	addi	sp,sp,-40
 82210a8:	df000915 	stw	fp,36(sp)
 82210ac:	df000904 	addi	fp,sp,36
 82210b0:	e13ffb15 	stw	r4,-20(fp)
 82210b4:	3009883a 	mov	r4,r6
 82210b8:	3807883a 	mov	r3,r7
 82210bc:	e0800117 	ldw	r2,4(fp)
 82210c0:	e17ffc05 	stb	r5,-16(fp)
 82210c4:	e13ffd05 	stb	r4,-12(fp)
 82210c8:	e0fffe05 	stb	r3,-8(fp)
 82210cc:	e0bfff0d 	sth	r2,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 82210d0:	e0bffb17 	ldw	r2,-20(fp)
 82210d4:	10800617 	ldw	r2,24(r2)
 82210d8:	10800317 	ldw	r2,12(r2)
 82210dc:	10800117 	ldw	r2,4(r2)
 82210e0:	10800217 	ldw	r2,8(r2)
 82210e4:	10800017 	ldw	r2,0(r2)
 82210e8:	e0bff915 	stw	r2,-28(fp)
    
    bit_mask = 0x00;
 82210ec:	e03ff70d 	sth	zero,-36(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 82210f0:	e03ff815 	stw	zero,-32(fp)
 82210f4:	00000906 	br	822111c <alt_tse_phy_wr_mdio_reg+0x78>
    {
        bit_mask <<= 1;
 82210f8:	e0bff70b 	ldhu	r2,-36(fp)
 82210fc:	1085883a 	add	r2,r2,r2
 8221100:	e0bff70d 	sth	r2,-36(fp)
        bit_mask |= 0x01;        
 8221104:	e0bff70b 	ldhu	r2,-36(fp)
 8221108:	10800054 	ori	r2,r2,1
 822110c:	e0bff70d 	sth	r2,-36(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 8221110:	e0bff817 	ldw	r2,-32(fp)
 8221114:	10800044 	addi	r2,r2,1
 8221118:	e0bff815 	stw	r2,-32(fp)
 822111c:	e0bffe03 	ldbu	r2,-8(fp)
 8221120:	e0fff817 	ldw	r3,-32(fp)
 8221124:	18bff416 	blt	r3,r2,82210f8 <alt_tse_phy_wr_mdio_reg+0x54>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
 8221128:	e0fff70b 	ldhu	r3,-36(fp)
 822112c:	e0bffd03 	ldbu	r2,-12(fp)
 8221130:	1884983a 	sll	r2,r3,r2
 8221134:	e0bff70d 	sth	r2,-36(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 8221138:	e0bff917 	ldw	r2,-28(fp)
 822113c:	10c0a004 	addi	r3,r2,640
 8221140:	e0bffc03 	ldbu	r2,-16(fp)
 8221144:	1085883a 	add	r2,r2,r2
 8221148:	1085883a 	add	r2,r2,r2
 822114c:	1885883a 	add	r2,r3,r2
 8221150:	10800037 	ldwio	r2,0(r2)
 8221154:	e0bffa0d 	sth	r2,-24(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
 8221158:	e0bff70b 	ldhu	r2,-36(fp)
 822115c:	0084303a 	nor	r2,zero,r2
 8221160:	1007883a 	mov	r3,r2
 8221164:	e0bffa0b 	ldhu	r2,-24(fp)
 8221168:	1884703a 	and	r2,r3,r2
 822116c:	e0bffa0d 	sth	r2,-24(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
 8221170:	e0ffff0b 	ldhu	r3,-4(fp)
 8221174:	e0bffd03 	ldbu	r2,-12(fp)
 8221178:	1884983a 	sll	r2,r3,r2
 822117c:	1007883a 	mov	r3,r2
 8221180:	e0bff70b 	ldhu	r2,-36(fp)
 8221184:	1884703a 	and	r2,r3,r2
 8221188:	1007883a 	mov	r3,r2
 822118c:	e0bffa0b 	ldhu	r2,-24(fp)
 8221190:	1884b03a 	or	r2,r3,r2
 8221194:	e0bffa0d 	sth	r2,-24(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
 8221198:	e0bff917 	ldw	r2,-28(fp)
 822119c:	10c0a004 	addi	r3,r2,640
 82211a0:	e0bffc03 	ldbu	r2,-16(fp)
 82211a4:	1085883a 	add	r2,r2,r2
 82211a8:	1085883a 	add	r2,r2,r2
 82211ac:	1885883a 	add	r2,r3,r2
 82211b0:	e0fffa0b 	ldhu	r3,-24(fp)
 82211b4:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 82211b8:	0005883a 	mov	r2,zero
    
}
 82211bc:	e037883a 	mov	sp,fp
 82211c0:	df000017 	ldw	fp,0(sp)
 82211c4:	dec00104 	addi	sp,sp,4
 82211c8:	f800283a 	ret

082211cc <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
 82211cc:	defff704 	addi	sp,sp,-36
 82211d0:	df000815 	stw	fp,32(sp)
 82211d4:	df000804 	addi	fp,sp,32
 82211d8:	e13ffc15 	stw	r4,-16(fp)
 82211dc:	2809883a 	mov	r4,r5
 82211e0:	3007883a 	mov	r3,r6
 82211e4:	3805883a 	mov	r2,r7
 82211e8:	e13ffd05 	stb	r4,-12(fp)
 82211ec:	e0fffe05 	stb	r3,-8(fp)
 82211f0:	e0bfff05 	stb	r2,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 82211f4:	e0bffc17 	ldw	r2,-16(fp)
 82211f8:	10800617 	ldw	r2,24(r2)
 82211fc:	10800317 	ldw	r2,12(r2)
 8221200:	10800117 	ldw	r2,4(r2)
 8221204:	10800217 	ldw	r2,8(r2)
 8221208:	10800017 	ldw	r2,0(r2)
 822120c:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
 8221210:	e03ff815 	stw	zero,-32(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 8221214:	e03ff915 	stw	zero,-28(fp)
 8221218:	00000906 	br	8221240 <alt_tse_phy_rd_mdio_reg+0x74>
    {
        bit_mask <<= 1;
 822121c:	e0bff817 	ldw	r2,-32(fp)
 8221220:	1085883a 	add	r2,r2,r2
 8221224:	e0bff815 	stw	r2,-32(fp)
        bit_mask |= 0x01;        
 8221228:	e0bff817 	ldw	r2,-32(fp)
 822122c:	10800054 	ori	r2,r2,1
 8221230:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 8221234:	e0bff917 	ldw	r2,-28(fp)
 8221238:	10800044 	addi	r2,r2,1
 822123c:	e0bff915 	stw	r2,-28(fp)
 8221240:	e0bfff03 	ldbu	r2,-4(fp)
 8221244:	e0fff917 	ldw	r3,-28(fp)
 8221248:	18bff416 	blt	r3,r2,822121c <alt_tse_phy_rd_mdio_reg+0x50>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 822124c:	e0bffa17 	ldw	r2,-24(fp)
 8221250:	10c0a004 	addi	r3,r2,640
 8221254:	e0bffd03 	ldbu	r2,-12(fp)
 8221258:	1085883a 	add	r2,r2,r2
 822125c:	1085883a 	add	r2,r2,r2
 8221260:	1885883a 	add	r2,r3,r2
 8221264:	10800037 	ldwio	r2,0(r2)
 8221268:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
 822126c:	e0fffb0b 	ldhu	r3,-20(fp)
 8221270:	e0bffe03 	ldbu	r2,-8(fp)
 8221274:	1885d83a 	sra	r2,r3,r2
 8221278:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
 822127c:	e0fffb0b 	ldhu	r3,-20(fp)
 8221280:	e0bff817 	ldw	r2,-32(fp)
 8221284:	1884703a 	and	r2,r3,r2
}
 8221288:	e037883a 	mov	sp,fp
 822128c:	df000017 	ldw	fp,0(sp)
 8221290:	dec00104 	addi	sp,sp,4
 8221294:	f800283a 	ret

08221298 <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
 8221298:	deff9a04 	addi	sp,sp,-408
 822129c:	dfc06515 	stw	ra,404(sp)
 82212a0:	df006415 	stw	fp,400(sp)
 82212a4:	df006404 	addi	fp,sp,400
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
 82212a8:	e0ff9c04 	addi	r3,fp,-400
 82212ac:	00801904 	movi	r2,100
 82212b0:	100d883a 	mov	r6,r2
 82212b4:	000b883a 	mov	r5,zero
 82212b8:	1809883a 	mov	r4,r3
 82212bc:	82031300 	call	8203130 <memset>
 82212c0:	009d9cb4 	movhi	r2,30322
 82212c4:	10985344 	addi	r2,r2,24909
 82212c8:	e0bf9c15 	stw	r2,-400(fp)
 82212cc:	00881b34 	movhi	r2,8300
 82212d0:	109b1944 	addi	r2,r2,27749
 82212d4:	e0bf9d15 	stw	r2,-396(fp)
 82212d8:	008c5174 	movhi	r2,12613
 82212dc:	108e0e04 	addi	r2,r2,14392
 82212e0:	e0bf9e15 	stw	r2,-392(fp)
 82212e4:	00800c74 	movhi	r2,49
 82212e8:	108c4c44 	addi	r2,r2,12593
 82212ec:	e0bf9f15 	stw	r2,-388(fp)
 82212f0:	e0bfa004 	addi	r2,fp,-384
 82212f4:	00c01004 	movi	r3,64
 82212f8:	180d883a 	mov	r6,r3
 82212fc:	000b883a 	mov	r5,zero
 8221300:	1009883a 	mov	r4,r2
 8221304:	82031300 	call	8203130 <memset>
 8221308:	009410c4 	movi	r2,20547
 822130c:	e0bfb015 	stw	r2,-320(fp)
 8221310:	00800304 	movi	r2,12
 8221314:	e0bfb105 	stb	r2,-316(fp)
 8221318:	00800084 	movi	r2,2
 822131c:	e0bfb145 	stb	r2,-315(fp)
 8221320:	00800444 	movi	r2,17
 8221324:	e0bfb185 	stb	r2,-314(fp)
 8221328:	00800384 	movi	r2,14
 822132c:	e0bfb1c5 	stb	r2,-313(fp)
 8221330:	00800344 	movi	r2,13
 8221334:	e0bfb205 	stb	r2,-312(fp)
 8221338:	00800284 	movi	r2,10
 822133c:	e0bfb245 	stb	r2,-311(fp)
 8221340:	008208b4 	movhi	r2,2082
 8221344:	108f3a04 	addi	r2,r2,15592
 8221348:	e0bfb315 	stw	r2,-308(fp)
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
 822134c:	e0bfb504 	addi	r2,fp,-300
 8221350:	00c01904 	movi	r3,100
 8221354:	180d883a 	mov	r6,r3
 8221358:	000b883a 	mov	r5,zero
 822135c:	1009883a 	mov	r4,r2
 8221360:	82031300 	call	8203130 <memset>
 8221364:	009d9cb4 	movhi	r2,30322
 8221368:	10985344 	addi	r2,r2,24909
 822136c:	e0bfb515 	stw	r2,-300(fp)
 8221370:	00881b34 	movhi	r2,8300
 8221374:	109b1944 	addi	r2,r2,27749
 8221378:	e0bfb615 	stw	r2,-296(fp)
 822137c:	00991874 	movhi	r2,25697
 8221380:	109d5444 	addi	r2,r2,30033
 8221384:	e0bfb715 	stw	r2,-292(fp)
 8221388:	00965234 	movhi	r2,22856
 822138c:	10940804 	addi	r2,r2,20512
 8221390:	e0bfb815 	stw	r2,-288(fp)
 8221394:	00914e34 	movhi	r2,17720
 8221398:	108e0804 	addi	r2,r2,14368
 822139c:	e0bfb915 	stw	r2,-284(fp)
 82213a0:	008d4d34 	movhi	r2,13620
 82213a4:	108c4c44 	addi	r2,r2,12593
 82213a8:	e0bfba15 	stw	r2,-280(fp)
 82213ac:	e03fbb15 	stw	zero,-276(fp)
 82213b0:	e03fbc15 	stw	zero,-272(fp)
 82213b4:	e03fbd15 	stw	zero,-268(fp)
 82213b8:	e03fbe15 	stw	zero,-264(fp)
 82213bc:	e03fbf15 	stw	zero,-260(fp)
 82213c0:	e03fc015 	stw	zero,-256(fp)
 82213c4:	e03fc115 	stw	zero,-252(fp)
 82213c8:	e03fc215 	stw	zero,-248(fp)
 82213cc:	e03fc315 	stw	zero,-244(fp)
 82213d0:	e03fc415 	stw	zero,-240(fp)
 82213d4:	e03fc515 	stw	zero,-236(fp)
 82213d8:	e03fc615 	stw	zero,-232(fp)
 82213dc:	e03fc715 	stw	zero,-228(fp)
 82213e0:	e03fc815 	stw	zero,-224(fp)
 82213e4:	009410c4 	movi	r2,20547
 82213e8:	e0bfc915 	stw	r2,-220(fp)
 82213ec:	00800344 	movi	r2,13
 82213f0:	e0bfca05 	stb	r2,-216(fp)
 82213f4:	00800084 	movi	r2,2
 82213f8:	e0bfca45 	stb	r2,-215(fp)
 82213fc:	00800444 	movi	r2,17
 8221400:	e0bfca85 	stb	r2,-214(fp)
 8221404:	00800384 	movi	r2,14
 8221408:	e0bfcac5 	stb	r2,-213(fp)
 822140c:	00800344 	movi	r2,13
 8221410:	e0bfcb05 	stb	r2,-212(fp)
 8221414:	00800284 	movi	r2,10
 8221418:	e0bfcb45 	stb	r2,-211(fp)
 822141c:	008208b4 	movhi	r2,2082
 8221420:	108f3a04 	addi	r2,r2,15592
 8221424:	e0bfcc15 	stw	r2,-208(fp)
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
 8221428:	e0bfce04 	addi	r2,fp,-200
 822142c:	00c01904 	movi	r3,100
 8221430:	180d883a 	mov	r6,r3
 8221434:	000b883a 	mov	r5,zero
 8221438:	1009883a 	mov	r4,r2
 822143c:	82031300 	call	8203130 <memset>
 8221440:	009a5d34 	movhi	r2,26996
 8221444:	10985384 	addi	r2,r2,24910
 8221448:	e0bfce15 	stw	r2,-200(fp)
 822144c:	009b1874 	movhi	r2,27745
 8221450:	109b9bc4 	addi	r2,r2,28271
 8221454:	e0bfcf15 	stw	r2,-196(fp)
 8221458:	008e1434 	movhi	r2,14416
 822145c:	10910804 	addi	r2,r2,17440
 8221460:	e0bfd015 	stw	r2,-192(fp)
 8221464:	008d4db4 	movhi	r2,13622
 8221468:	108e0cc4 	addi	r2,r2,14387
 822146c:	e0bfd115 	stw	r2,-188(fp)
 8221470:	e03fd215 	stw	zero,-184(fp)
 8221474:	e0bfd304 	addi	r2,fp,-180
 8221478:	00c00f04 	movi	r3,60
 822147c:	180d883a 	mov	r6,r3
 8221480:	000b883a 	mov	r5,zero
 8221484:	1009883a 	mov	r4,r2
 8221488:	82031300 	call	8203130 <memset>
 822148c:	00800234 	movhi	r2,8
 8221490:	108005c4 	addi	r2,r2,23
 8221494:	e0bfe215 	stw	r2,-120(fp)
 8221498:	008001c4 	movi	r2,7
 822149c:	e0bfe305 	stb	r2,-116(fp)
 82214a0:	00800284 	movi	r2,10
 82214a4:	e0bfe345 	stb	r2,-115(fp)
 82214a8:	00800444 	movi	r2,17
 82214ac:	e0bfe385 	stb	r2,-114(fp)
 82214b0:	008000c4 	movi	r2,3
 82214b4:	e0bfe3c5 	stb	r2,-113(fp)
 82214b8:	00800044 	movi	r2,1
 82214bc:	e0bfe405 	stb	r2,-112(fp)
 82214c0:	00800084 	movi	r2,2
 82214c4:	e0bfe445 	stb	r2,-111(fp)
                      
    /* -------------------------------------- */
    /* National 10/100 PHY on PHYWORKX board  */
    /* -------------------------------------- */ 
                      
    alt_tse_phy_profile DP83848C = {"National DP83848C",  /* National DP83848C                                          */
 82214c8:	00820974 	movhi	r2,2085
 82214cc:	10b9ac04 	addi	r2,r2,-6480
 82214d0:	e0ffe704 	addi	r3,fp,-100
 82214d4:	1009883a 	mov	r4,r2
 82214d8:	00801904 	movi	r2,100
 82214dc:	100d883a 	mov	r6,r2
 82214e0:	200b883a 	mov	r5,r4
 82214e4:	1809883a 	mov	r4,r3
 82214e8:	8202e8c0 	call	8202e8c <memcpy>
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
 82214ec:	e13f9c04 	addi	r4,fp,-400
 82214f0:	821f4080 	call	821f408 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
 82214f4:	e0bfb504 	addi	r2,fp,-300
 82214f8:	1009883a 	mov	r4,r2
 82214fc:	821f4080 	call	821f408 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
 8221500:	e0bfce04 	addi	r2,fp,-200
 8221504:	1009883a 	mov	r4,r2
 8221508:	821f4080 	call	821f408 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
 822150c:	e0bfe704 	addi	r2,fp,-100
 8221510:	1009883a 	mov	r4,r2
 8221514:	821f4080 	call	821f408 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
 8221518:	d0a07f03 	ldbu	r2,-32260(gp)
 822151c:	10803fcc 	andi	r2,r2,255
}
 8221520:	e037883a 	mov	sp,fp
 8221524:	dfc00117 	ldw	ra,4(sp)
 8221528:	df000017 	ldw	fp,0(sp)
 822152c:	dec00204 	addi	sp,sp,8
 8221530:	f800283a 	ret

08221534 <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
 8221534:	defffd04 	addi	sp,sp,-12
 8221538:	dfc00215 	stw	ra,8(sp)
 822153c:	df000115 	stw	fp,4(sp)
 8221540:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
 8221544:	d0a07f03 	ldbu	r2,-32260(gp)
 8221548:	10803fcc 	andi	r2,r2,255
 822154c:	100b883a 	mov	r5,r2
 8221550:	01020974 	movhi	r4,2085
 8221554:	2139c504 	addi	r4,r4,-6380
 8221558:	821f0c00 	call	821f0c0 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
 822155c:	e03fff05 	stb	zero,-4(fp)
 8221560:	00006d06 	br	8221718 <alt_tse_phy_print_profile+0x1e4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
 8221564:	e0bfff07 	ldb	r2,-4(fp)
 8221568:	100b883a 	mov	r5,r2
 822156c:	01020974 	movhi	r4,2085
 8221570:	2139d404 	addi	r4,r4,-6320
 8221574:	821f0c00 	call	821f0c0 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
 8221578:	e0ffff07 	ldb	r3,-4(fp)
 822157c:	008209b4 	movhi	r2,2086
 8221580:	10b70304 	addi	r2,r2,-9204
 8221584:	18c7883a 	add	r3,r3,r3
 8221588:	18c7883a 	add	r3,r3,r3
 822158c:	10c5883a 	add	r2,r2,r3
 8221590:	10800017 	ldw	r2,0(r2)
 8221594:	100b883a 	mov	r5,r2
 8221598:	01020974 	movhi	r4,2085
 822159c:	2139d904 	addi	r4,r4,-6300
 82215a0:	821f0c00 	call	821f0c0 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
 82215a4:	e0ffff07 	ldb	r3,-4(fp)
 82215a8:	008209b4 	movhi	r2,2086
 82215ac:	10b70304 	addi	r2,r2,-9204
 82215b0:	18c7883a 	add	r3,r3,r3
 82215b4:	18c7883a 	add	r3,r3,r3
 82215b8:	10c5883a 	add	r2,r2,r3
 82215bc:	10800017 	ldw	r2,0(r2)
 82215c0:	10801417 	ldw	r2,80(r2)
 82215c4:	100b883a 	mov	r5,r2
 82215c8:	01020974 	movhi	r4,2085
 82215cc:	2139df04 	addi	r4,r4,-6276
 82215d0:	821f0c00 	call	821f0c0 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
 82215d4:	e0ffff07 	ldb	r3,-4(fp)
 82215d8:	008209b4 	movhi	r2,2086
 82215dc:	10b70304 	addi	r2,r2,-9204
 82215e0:	18c7883a 	add	r3,r3,r3
 82215e4:	18c7883a 	add	r3,r3,r3
 82215e8:	10c5883a 	add	r2,r2,r3
 82215ec:	10800017 	ldw	r2,0(r2)
 82215f0:	10801503 	ldbu	r2,84(r2)
 82215f4:	10803fcc 	andi	r2,r2,255
 82215f8:	100b883a 	mov	r5,r2
 82215fc:	01020974 	movhi	r4,2085
 8221600:	2139e604 	addi	r4,r4,-6248
 8221604:	821f0c00 	call	821f0c0 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
 8221608:	e0ffff07 	ldb	r3,-4(fp)
 822160c:	008209b4 	movhi	r2,2086
 8221610:	10b70304 	addi	r2,r2,-9204
 8221614:	18c7883a 	add	r3,r3,r3
 8221618:	18c7883a 	add	r3,r3,r3
 822161c:	10c5883a 	add	r2,r2,r3
 8221620:	10800017 	ldw	r2,0(r2)
 8221624:	10801543 	ldbu	r2,85(r2)
 8221628:	10803fcc 	andi	r2,r2,255
 822162c:	100b883a 	mov	r5,r2
 8221630:	01020974 	movhi	r4,2085
 8221634:	2139ed04 	addi	r4,r4,-6220
 8221638:	821f0c00 	call	821f0c0 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
 822163c:	e0ffff07 	ldb	r3,-4(fp)
 8221640:	008209b4 	movhi	r2,2086
 8221644:	10b70304 	addi	r2,r2,-9204
 8221648:	18c7883a 	add	r3,r3,r3
 822164c:	18c7883a 	add	r3,r3,r3
 8221650:	10c5883a 	add	r2,r2,r3
 8221654:	10800017 	ldw	r2,0(r2)
 8221658:	10801583 	ldbu	r2,86(r2)
 822165c:	10803fcc 	andi	r2,r2,255
 8221660:	100b883a 	mov	r5,r2
 8221664:	01020974 	movhi	r4,2085
 8221668:	2139f404 	addi	r4,r4,-6192
 822166c:	821f0c00 	call	821f0c0 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
 8221670:	e0ffff07 	ldb	r3,-4(fp)
 8221674:	008209b4 	movhi	r2,2086
 8221678:	10b70304 	addi	r2,r2,-9204
 822167c:	18c7883a 	add	r3,r3,r3
 8221680:	18c7883a 	add	r3,r3,r3
 8221684:	10c5883a 	add	r2,r2,r3
 8221688:	10800017 	ldw	r2,0(r2)
 822168c:	108015c3 	ldbu	r2,87(r2)
 8221690:	10803fcc 	andi	r2,r2,255
 8221694:	100b883a 	mov	r5,r2
 8221698:	01020974 	movhi	r4,2085
 822169c:	2139fb04 	addi	r4,r4,-6164
 82216a0:	821f0c00 	call	821f0c0 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
 82216a4:	e0ffff07 	ldb	r3,-4(fp)
 82216a8:	008209b4 	movhi	r2,2086
 82216ac:	10b70304 	addi	r2,r2,-9204
 82216b0:	18c7883a 	add	r3,r3,r3
 82216b4:	18c7883a 	add	r3,r3,r3
 82216b8:	10c5883a 	add	r2,r2,r3
 82216bc:	10800017 	ldw	r2,0(r2)
 82216c0:	10801603 	ldbu	r2,88(r2)
 82216c4:	10803fcc 	andi	r2,r2,255
 82216c8:	100b883a 	mov	r5,r2
 82216cc:	01020974 	movhi	r4,2085
 82216d0:	213a0104 	addi	r4,r4,-6140
 82216d4:	821f0c00 	call	821f0c0 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 82216d8:	e0ffff07 	ldb	r3,-4(fp)
 82216dc:	008209b4 	movhi	r2,2086
 82216e0:	10b70304 	addi	r2,r2,-9204
 82216e4:	18c7883a 	add	r3,r3,r3
 82216e8:	18c7883a 	add	r3,r3,r3
 82216ec:	10c5883a 	add	r2,r2,r3
 82216f0:	10800017 	ldw	r2,0(r2)
 82216f4:	10801643 	ldbu	r2,89(r2)
 82216f8:	10803fcc 	andi	r2,r2,255
 82216fc:	100b883a 	mov	r5,r2
 8221700:	01020974 	movhi	r4,2085
 8221704:	213a0704 	addi	r4,r4,-6116
 8221708:	821f0c00 	call	821f0c0 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
 822170c:	e0bfff03 	ldbu	r2,-4(fp)
 8221710:	10800044 	addi	r2,r2,1
 8221714:	e0bfff05 	stb	r2,-4(fp)
 8221718:	e0ffff07 	ldb	r3,-4(fp)
 822171c:	d0a07f03 	ldbu	r2,-32260(gp)
 8221720:	10803fcc 	andi	r2,r2,255
 8221724:	18bf8f16 	blt	r3,r2,8221564 <alt_tse_phy_print_profile+0x30>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
 8221728:	d0a07f03 	ldbu	r2,-32260(gp)
 822172c:	10803fcc 	andi	r2,r2,255
}
 8221730:	e037883a 	mov	sp,fp
 8221734:	dfc00117 	ldw	ra,4(sp)
 8221738:	df000017 	ldw	fp,0(sp)
 822173c:	dec00204 	addi	sp,sp,8
 8221740:	f800283a 	ret

08221744 <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
 8221744:	defffa04 	addi	sp,sp,-24
 8221748:	dfc00515 	stw	ra,20(sp)
 822174c:	df000415 	stw	fp,16(sp)
 8221750:	df000404 	addi	fp,sp,16
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
 8221754:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 8221758:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_system_info *psys = 0;
 822175c:	e03fff15 	stw	zero,-4(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
 8221760:	d0207f45 	stb	zero,-32259(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 8221764:	e03ffc05 	stb	zero,-16(fp)
 8221768:	00019506 	br	8221dc0 <alt_tse_mac_group_init+0x67c>
        psys = &tse_mac_device[i];
 822176c:	e0bffc07 	ldb	r2,-16(fp)
 8221770:	10c01224 	muli	r3,r2,72
 8221774:	00820974 	movhi	r2,2085
 8221778:	1087c104 	addi	r2,r2,7940
 822177c:	1885883a 	add	r2,r3,r2
 8221780:	e0bfff15 	stw	r2,-4(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
 8221784:	e0bfff17 	ldw	r2,-4(fp)
 8221788:	10800517 	ldw	r2,20(r2)
 822178c:	10018926 	beq	r2,zero,8221db4 <alt_tse_mac_group_init+0x670>
 8221790:	e0bfff17 	ldw	r2,-4(fp)
 8221794:	10800617 	ldw	r2,24(r2)
 8221798:	10018626 	beq	r2,zero,8221db4 <alt_tse_mac_group_init+0x670>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
 822179c:	d0a07f43 	ldbu	r2,-32259(gp)
 82217a0:	10c03fcc 	andi	r3,r2,255
 82217a4:	e0bfff17 	ldw	r2,-4(fp)
 82217a8:	10800017 	ldw	r2,0(r2)
 82217ac:	100d883a 	mov	r6,r2
 82217b0:	180b883a 	mov	r5,r3
 82217b4:	01020974 	movhi	r4,2085
 82217b8:	213a0d04 	addi	r4,r4,-6092
 82217bc:	820331c0 	call	820331c <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
 82217c0:	01000504 	movi	r4,20
 82217c4:	824b6900 	call	824b690 <malloc>
 82217c8:	e0bffd15 	stw	r2,-12(fp)
            if(!pmac_group) {
 82217cc:	e0bffd17 	ldw	r2,-12(fp)
 82217d0:	1000081e 	bne	r2,zero,82217f4 <alt_tse_mac_group_init+0xb0>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
 82217d4:	d0a07f43 	ldbu	r2,-32259(gp)
 82217d8:	10803fcc 	andi	r2,r2,255
 82217dc:	100b883a 	mov	r5,r2
 82217e0:	01020974 	movhi	r4,2085
 82217e4:	213a1904 	addi	r4,r4,-6044
 82217e8:	820331c0 	call	820331c <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 82217ec:	00bfffc4 	movi	r2,-1
 82217f0:	00017806 	br	8221dd4 <alt_tse_mac_group_init+0x690>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
 82217f4:	e0bfff17 	ldw	r2,-4(fp)
 82217f8:	108002c3 	ldbu	r2,11(r2)
 82217fc:	10803fcc 	andi	r2,r2,255
 8221800:	10001226 	beq	r2,zero,822184c <alt_tse_mac_group_init+0x108>
                pmac_group->channel = psys->tse_num_of_channel;
 8221804:	e0bfff17 	ldw	r2,-4(fp)
 8221808:	10c00303 	ldbu	r3,12(r2)
 822180c:	e0bffd17 	ldw	r2,-12(fp)
 8221810:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
 8221814:	01020974 	movhi	r4,2085
 8221818:	213a2704 	addi	r4,r4,-5988
 822181c:	821f0c00 	call	821f0c0 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
 8221820:	e0bffd17 	ldw	r2,-12(fp)
 8221824:	10800003 	ldbu	r2,0(r2)
 8221828:	10803fcc 	andi	r2,r2,255
 822182c:	100b883a 	mov	r5,r2
 8221830:	01020974 	movhi	r4,2085
 8221834:	213a3204 	addi	r4,r4,-5944
 8221838:	821f0c00 	call	821f0c0 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 822183c:	01020974 	movhi	r4,2085
 8221840:	213a3d04 	addi	r4,r4,-5900
 8221844:	821f0c00 	call	821f0c0 <no_printf>
 8221848:	00001f06 	br	82218c8 <alt_tse_mac_group_init+0x184>
            }
            else if(psys->tse_mdio_shared) {
 822184c:	e0bfff17 	ldw	r2,-4(fp)
 8221850:	10800343 	ldbu	r2,13(r2)
 8221854:	10803fcc 	andi	r2,r2,255
 8221858:	10001226 	beq	r2,zero,82218a4 <alt_tse_mac_group_init+0x160>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
 822185c:	e0bfff17 	ldw	r2,-4(fp)
 8221860:	10c00383 	ldbu	r3,14(r2)
 8221864:	e0bffd17 	ldw	r2,-12(fp)
 8221868:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 822186c:	01020974 	movhi	r4,2085
 8221870:	213a4804 	addi	r4,r4,-5856
 8221874:	821f0c00 	call	821f0c0 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 8221878:	01020974 	movhi	r4,2085
 822187c:	213a3d04 	addi	r4,r4,-5900
 8221880:	821f0c00 	call	821f0c0 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
 8221884:	e0bffd17 	ldw	r2,-12(fp)
 8221888:	10800003 	ldbu	r2,0(r2)
 822188c:	10803fcc 	andi	r2,r2,255
 8221890:	100b883a 	mov	r5,r2
 8221894:	01020974 	movhi	r4,2085
 8221898:	213a5304 	addi	r4,r4,-5812
 822189c:	821f0c00 	call	821f0c0 <no_printf>
 82218a0:	00000906 	br	82218c8 <alt_tse_mac_group_init+0x184>
            }
            else {
                pmac_group->channel = 1;
 82218a4:	e0bffd17 	ldw	r2,-12(fp)
 82218a8:	00c00044 	movi	r3,1
 82218ac:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 82218b0:	01020974 	movhi	r4,2085
 82218b4:	213a4804 	addi	r4,r4,-5856
 82218b8:	821f0c00 	call	821f0c0 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
 82218bc:	01020974 	movhi	r4,2085
 82218c0:	213a5e04 	addi	r4,r4,-5768
 82218c4:	821f0c00 	call	821f0c0 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 82218c8:	e03ffc45 	stb	zero,-15(fp)
 82218cc:	00012206 	br	8221d58 <alt_tse_mac_group_init+0x614>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
 82218d0:	01000404 	movi	r4,16
 82218d4:	824b6900 	call	824b690 <malloc>
 82218d8:	e0bffe15 	stw	r2,-8(fp)
                if(!pmac_info) {
 82218dc:	e0bffe17 	ldw	r2,-8(fp)
 82218e0:	10000a1e 	bne	r2,zero,822190c <alt_tse_mac_group_init+0x1c8>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
 82218e4:	d0a07f43 	ldbu	r2,-32259(gp)
 82218e8:	10803fcc 	andi	r2,r2,255
 82218ec:	e0fffc47 	ldb	r3,-15(fp)
 82218f0:	180d883a 	mov	r6,r3
 82218f4:	100b883a 	mov	r5,r2
 82218f8:	01020974 	movhi	r4,2085
 82218fc:	213a6904 	addi	r4,r4,-5724
 8221900:	820331c0 	call	820331c <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
 8221904:	00bfffc4 	movi	r2,-1
 8221908:	00013206 	br	8221dd4 <alt_tse_mac_group_init+0x690>
                }
                
                pmac_info->pmac_group = pmac_group;
 822190c:	e0bffe17 	ldw	r2,-8(fp)
 8221910:	e0fffd17 	ldw	r3,-12(fp)
 8221914:	10c00315 	stw	r3,12(r2)
                
                pmac_info->pphy_info = 0;
 8221918:	e0bffe17 	ldw	r2,-8(fp)
 822191c:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
 8221920:	e0fffc07 	ldb	r3,-16(fp)
 8221924:	e0bffc47 	ldb	r2,-15(fp)
 8221928:	1885883a 	add	r2,r3,r2
 822192c:	10c01224 	muli	r3,r2,72
 8221930:	00820974 	movhi	r2,2085
 8221934:	1087c104 	addi	r2,r2,7940
 8221938:	1887883a 	add	r3,r3,r2
 822193c:	e0bffe17 	ldw	r2,-8(fp)
 8221940:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
 8221944:	e0bffe17 	ldw	r2,-8(fp)
 8221948:	10800217 	ldw	r2,8(r2)
 822194c:	10800517 	ldw	r2,20(r2)
 8221950:	10000426 	beq	r2,zero,8221964 <alt_tse_mac_group_init+0x220>
 8221954:	e0bffe17 	ldw	r2,-8(fp)
 8221958:	10800217 	ldw	r2,8(r2)
 822195c:	10800617 	ldw	r2,24(r2)
 8221960:	1000091e 	bne	r2,zero,8221988 <alt_tse_mac_group_init+0x244>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
 8221964:	e0fffc07 	ldb	r3,-16(fp)
 8221968:	e0bffc47 	ldb	r2,-15(fp)
 822196c:	1885883a 	add	r2,r3,r2
 8221970:	100b883a 	mov	r5,r2
 8221974:	01020974 	movhi	r4,2085
 8221978:	213a7b04 	addi	r4,r4,-5652
 822197c:	820331c0 	call	820331c <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
 8221980:	00bfffc4 	movi	r2,-1
 8221984:	00011306 	br	8221dd4 <alt_tse_mac_group_init+0x690>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
 8221988:	e0bffe17 	ldw	r2,-8(fp)
 822198c:	10800217 	ldw	r2,8(r2)
 8221990:	10800243 	ldbu	r2,9(r2)
 8221994:	10803fcc 	andi	r2,r2,255
 8221998:	10000d26 	beq	r2,zero,82219d0 <alt_tse_mac_group_init+0x28c>
                    if(pmac_info->psys_info->tse_maclite_gige) {
 822199c:	e0bffe17 	ldw	r2,-8(fp)
 82219a0:	10800217 	ldw	r2,8(r2)
 82219a4:	10800283 	ldbu	r2,10(r2)
 82219a8:	10803fcc 	andi	r2,r2,255
 82219ac:	10000426 	beq	r2,zero,82219c0 <alt_tse_mac_group_init+0x27c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
 82219b0:	e0bffe17 	ldw	r2,-8(fp)
 82219b4:	00c00084 	movi	r3,2
 82219b8:	10c00005 	stb	r3,0(r2)
 82219bc:	00000606 	br	82219d8 <alt_tse_mac_group_init+0x294>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
 82219c0:	e0bffe17 	ldw	r2,-8(fp)
 82219c4:	00c00044 	movi	r3,1
 82219c8:	10c00005 	stb	r3,0(r2)
 82219cc:	00000206 	br	82219d8 <alt_tse_mac_group_init+0x294>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
 82219d0:	e0bffe17 	ldw	r2,-8(fp)
 82219d4:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 82219d8:	e0bffe17 	ldw	r2,-8(fp)
 82219dc:	10800217 	ldw	r2,8(r2)
 82219e0:	10800343 	ldbu	r2,13(r2)
 82219e4:	10803fcc 	andi	r2,r2,255
 82219e8:	10006626 	beq	r2,zero,8221b84 <alt_tse_mac_group_init+0x440>
 82219ec:	e0bffe17 	ldw	r2,-8(fp)
 82219f0:	10800217 	ldw	r2,8(r2)
 82219f4:	108002c3 	ldbu	r2,11(r2)
 82219f8:	10803fcc 	andi	r2,r2,255
 82219fc:	1000611e 	bne	r2,zero,8221b84 <alt_tse_mac_group_init+0x440>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 8221a00:	e0fffc47 	ldb	r3,-15(fp)
 8221a04:	e0bffe17 	ldw	r2,-8(fp)
 8221a08:	10800217 	ldw	r2,8(r2)
 8221a0c:	10800017 	ldw	r2,0(r2)
 8221a10:	100d883a 	mov	r6,r2
 8221a14:	180b883a 	mov	r5,r3
 8221a18:	01020974 	movhi	r4,2085
 8221a1c:	213a8a04 	addi	r4,r4,-5592
 8221a20:	821f0c00 	call	821f0c0 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
 8221a24:	e13ffc47 	ldb	r4,-15(fp)
 8221a28:	e0fffc07 	ldb	r3,-16(fp)
 8221a2c:	e0bffc47 	ldb	r2,-15(fp)
 8221a30:	1885883a 	add	r2,r3,r2
 8221a34:	100d883a 	mov	r6,r2
 8221a38:	200b883a 	mov	r5,r4
 8221a3c:	01020974 	movhi	r4,2085
 8221a40:	213a9604 	addi	r4,r4,-5544
 8221a44:	821f0c00 	call	821f0c0 <no_printf>
                    
                	switch(pmac_info->mac_type) {
 8221a48:	e0bffe17 	ldw	r2,-8(fp)
 8221a4c:	10800003 	ldbu	r2,0(r2)
 8221a50:	10803fcc 	andi	r2,r2,255
 8221a54:	10c00060 	cmpeqi	r3,r2,1
 8221a58:	18000c1e 	bne	r3,zero,8221a8c <alt_tse_mac_group_init+0x348>
 8221a5c:	10c000a0 	cmpeqi	r3,r2,2
 8221a60:	1800021e 	bne	r3,zero,8221a6c <alt_tse_mac_group_init+0x328>
 8221a64:	10001126 	beq	r2,zero,8221aac <alt_tse_mac_group_init+0x368>
 8221a68:	00001806 	br	8221acc <alt_tse_mac_group_init+0x388>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
 8221a6c:	e0bffc47 	ldb	r2,-15(fp)
 8221a70:	01820974 	movhi	r6,2085
 8221a74:	31baa504 	addi	r6,r6,-5484
 8221a78:	100b883a 	mov	r5,r2
 8221a7c:	01020974 	movhi	r4,2085
 8221a80:	213aaa04 	addi	r4,r4,-5464
 8221a84:	821f0c00 	call	821f0c0 <no_printf>
                            break;
 8221a88:	00001806 	br	8221aec <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
 8221a8c:	e0bffc47 	ldb	r2,-15(fp)
 8221a90:	01820974 	movhi	r6,2085
 8221a94:	31bab504 	addi	r6,r6,-5420
 8221a98:	100b883a 	mov	r5,r2
 8221a9c:	01020974 	movhi	r4,2085
 8221aa0:	213aaa04 	addi	r4,r4,-5464
 8221aa4:	821f0c00 	call	821f0c0 <no_printf>
                            break;
 8221aa8:	00001006 	br	8221aec <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
 8221aac:	e0bffc47 	ldb	r2,-15(fp)
 8221ab0:	01820974 	movhi	r6,2085
 8221ab4:	31babb04 	addi	r6,r6,-5396
 8221ab8:	100b883a 	mov	r5,r2
 8221abc:	01020974 	movhi	r4,2085
 8221ac0:	213aaa04 	addi	r4,r4,-5464
 8221ac4:	821f0c00 	call	821f0c0 <no_printf>
                            break;
 8221ac8:	00000806 	br	8221aec <alt_tse_mac_group_init+0x3a8>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
 8221acc:	e0bffc47 	ldb	r2,-15(fp)
 8221ad0:	01820974 	movhi	r6,2085
 8221ad4:	31b8f304 	addi	r6,r6,-7220
 8221ad8:	100b883a 	mov	r5,r2
 8221adc:	01020974 	movhi	r4,2085
 8221ae0:	213aaa04 	addi	r4,r4,-5464
 8221ae4:	821f0c00 	call	821f0c0 <no_printf>
                            break;
 8221ae8:	0001883a 	nop
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 8221aec:	e0bffe17 	ldw	r2,-8(fp)
 8221af0:	10800217 	ldw	r2,8(r2)
 8221af4:	108003c3 	ldbu	r2,15(r2)
 8221af8:	10803fcc 	andi	r2,r2,255
 8221afc:	10008b26 	beq	r2,zero,8221d2c <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 8221b00:	e0fffc47 	ldb	r3,-15(fp)
 8221b04:	e0bffe17 	ldw	r2,-8(fp)
 8221b08:	10800217 	ldw	r2,8(r2)
 8221b0c:	108003c3 	ldbu	r2,15(r2)
 8221b10:	10803fcc 	andi	r2,r2,255
 8221b14:	10000326 	beq	r2,zero,8221b24 <alt_tse_mac_group_init+0x3e0>
 8221b18:	00820974 	movhi	r2,2085
 8221b1c:	10bac204 	addi	r2,r2,-5368
 8221b20:	00000206 	br	8221b2c <alt_tse_mac_group_init+0x3e8>
 8221b24:	00820974 	movhi	r2,2085
 8221b28:	10bac304 	addi	r2,r2,-5364
 8221b2c:	100d883a 	mov	r6,r2
 8221b30:	180b883a 	mov	r5,r3
 8221b34:	01020974 	movhi	r4,2085
 8221b38:	213ac404 	addi	r4,r4,-5360
 8221b3c:	821f0c00 	call	821f0c0 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
 8221b40:	e0fffc47 	ldb	r3,-15(fp)
 8221b44:	e0bffe17 	ldw	r2,-8(fp)
 8221b48:	10800217 	ldw	r2,8(r2)
 8221b4c:	10800403 	ldbu	r2,16(r2)
 8221b50:	10803fcc 	andi	r2,r2,255
 8221b54:	10000326 	beq	r2,zero,8221b64 <alt_tse_mac_group_init+0x420>
 8221b58:	00820974 	movhi	r2,2085
 8221b5c:	10bac204 	addi	r2,r2,-5368
 8221b60:	00000206 	br	8221b6c <alt_tse_mac_group_init+0x428>
 8221b64:	00820974 	movhi	r2,2085
 8221b68:	10bac304 	addi	r2,r2,-5364
 8221b6c:	100d883a 	mov	r6,r2
 8221b70:	180b883a 	mov	r5,r3
 8221b74:	01020974 	movhi	r4,2085
 8221b78:	213acf04 	addi	r4,r4,-5316
 8221b7c:	821f0c00 	call	821f0c0 <no_printf>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
                            break;
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 8221b80:	00006a06 	br	8221d2c <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
 8221b84:	e0bffc47 	ldb	r2,-15(fp)
 8221b88:	1000421e 	bne	r2,zero,8221c94 <alt_tse_mac_group_init+0x550>
	                    switch(pmac_info->mac_type) {
 8221b8c:	e0bffe17 	ldw	r2,-8(fp)
 8221b90:	10800003 	ldbu	r2,0(r2)
 8221b94:	10803fcc 	andi	r2,r2,255
 8221b98:	10c00060 	cmpeqi	r3,r2,1
 8221b9c:	18000a1e 	bne	r3,zero,8221bc8 <alt_tse_mac_group_init+0x484>
 8221ba0:	10c000a0 	cmpeqi	r3,r2,2
 8221ba4:	1800021e 	bne	r3,zero,8221bb0 <alt_tse_mac_group_init+0x46c>
 8221ba8:	10000d26 	beq	r2,zero,8221be0 <alt_tse_mac_group_init+0x49c>
 8221bac:	00001206 	br	8221bf8 <alt_tse_mac_group_init+0x4b4>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
 8221bb0:	01420974 	movhi	r5,2085
 8221bb4:	297aa504 	addi	r5,r5,-5484
 8221bb8:	01020974 	movhi	r4,2085
 8221bbc:	213ada04 	addi	r4,r4,-5272
 8221bc0:	821f0c00 	call	821f0c0 <no_printf>
	                            break;
 8221bc4:	00001206 	br	8221c10 <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
 8221bc8:	01420974 	movhi	r5,2085
 8221bcc:	297ab504 	addi	r5,r5,-5420
 8221bd0:	01020974 	movhi	r4,2085
 8221bd4:	213ada04 	addi	r4,r4,-5272
 8221bd8:	821f0c00 	call	821f0c0 <no_printf>
	                            break;
 8221bdc:	00000c06 	br	8221c10 <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
 8221be0:	01420974 	movhi	r5,2085
 8221be4:	297abb04 	addi	r5,r5,-5396
 8221be8:	01020974 	movhi	r4,2085
 8221bec:	213ada04 	addi	r4,r4,-5272
 8221bf0:	821f0c00 	call	821f0c0 <no_printf>
	                            break;
 8221bf4:	00000606 	br	8221c10 <alt_tse_mac_group_init+0x4cc>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
 8221bf8:	01420974 	movhi	r5,2085
 8221bfc:	2978f304 	addi	r5,r5,-7220
 8221c00:	01020974 	movhi	r4,2085
 8221c04:	213ada04 	addi	r4,r4,-5272
 8221c08:	821f0c00 	call	821f0c0 <no_printf>
                                    break;
 8221c0c:	0001883a 	nop
			    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
 8221c10:	e0bffe17 	ldw	r2,-8(fp)
 8221c14:	10800217 	ldw	r2,8(r2)
 8221c18:	108003c3 	ldbu	r2,15(r2)
 8221c1c:	10803fcc 	andi	r2,r2,255
 8221c20:	10001c26 	beq	r2,zero,8221c94 <alt_tse_mac_group_init+0x550>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 8221c24:	e0bffe17 	ldw	r2,-8(fp)
 8221c28:	10800217 	ldw	r2,8(r2)
 8221c2c:	108003c3 	ldbu	r2,15(r2)
 8221c30:	10803fcc 	andi	r2,r2,255
 8221c34:	10000326 	beq	r2,zero,8221c44 <alt_tse_mac_group_init+0x500>
 8221c38:	00820974 	movhi	r2,2085
 8221c3c:	10bac204 	addi	r2,r2,-5368
 8221c40:	00000206 	br	8221c4c <alt_tse_mac_group_init+0x508>
 8221c44:	00820974 	movhi	r2,2085
 8221c48:	10bac304 	addi	r2,r2,-5364
 8221c4c:	100b883a 	mov	r5,r2
 8221c50:	01020974 	movhi	r4,2085
 8221c54:	213ae504 	addi	r4,r4,-5228
 8221c58:	821f0c00 	call	821f0c0 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
 8221c5c:	e0bffe17 	ldw	r2,-8(fp)
 8221c60:	10800217 	ldw	r2,8(r2)
 8221c64:	10800403 	ldbu	r2,16(r2)
 8221c68:	10803fcc 	andi	r2,r2,255
 8221c6c:	10000326 	beq	r2,zero,8221c7c <alt_tse_mac_group_init+0x538>
 8221c70:	00820974 	movhi	r2,2085
 8221c74:	10bac204 	addi	r2,r2,-5368
 8221c78:	00000206 	br	8221c84 <alt_tse_mac_group_init+0x540>
 8221c7c:	00820974 	movhi	r2,2085
 8221c80:	10bac304 	addi	r2,r2,-5364
 8221c84:	100b883a 	mov	r5,r2
 8221c88:	01020974 	movhi	r4,2085
 8221c8c:	213af004 	addi	r4,r4,-5184
 8221c90:	821f0c00 	call	821f0c0 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
 8221c94:	e0bffe17 	ldw	r2,-8(fp)
 8221c98:	10800217 	ldw	r2,8(r2)
 8221c9c:	108002c3 	ldbu	r2,11(r2)
 8221ca0:	10803fcc 	andi	r2,r2,255
 8221ca4:	10001326 	beq	r2,zero,8221cf4 <alt_tse_mac_group_init+0x5b0>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 8221ca8:	e0fffc47 	ldb	r3,-15(fp)
 8221cac:	e0bffe17 	ldw	r2,-8(fp)
 8221cb0:	10800217 	ldw	r2,8(r2)
 8221cb4:	10800017 	ldw	r2,0(r2)
 8221cb8:	100d883a 	mov	r6,r2
 8221cbc:	180b883a 	mov	r5,r3
 8221cc0:	01020974 	movhi	r4,2085
 8221cc4:	213afb04 	addi	r4,r4,-5140
 8221cc8:	821f0c00 	call	821f0c0 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
 8221ccc:	e13ffc47 	ldb	r4,-15(fp)
 8221cd0:	e0fffc07 	ldb	r3,-16(fp)
 8221cd4:	e0bffc47 	ldb	r2,-15(fp)
 8221cd8:	1885883a 	add	r2,r3,r2
 8221cdc:	100d883a 	mov	r6,r2
 8221ce0:	200b883a 	mov	r5,r4
 8221ce4:	01020974 	movhi	r4,2085
 8221ce8:	213b0704 	addi	r4,r4,-5092
 8221cec:	821f0c00 	call	821f0c0 <no_printf>
 8221cf0:	00000e06 	br	8221d2c <alt_tse_mac_group_init+0x5e8>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
 8221cf4:	e0bffe17 	ldw	r2,-8(fp)
 8221cf8:	10800217 	ldw	r2,8(r2)
 8221cfc:	10800017 	ldw	r2,0(r2)
 8221d00:	100b883a 	mov	r5,r2
 8221d04:	01020974 	movhi	r4,2085
 8221d08:	213b1604 	addi	r4,r4,-5032
 8221d0c:	821f0c00 	call	821f0c0 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
 8221d10:	e0fffc07 	ldb	r3,-16(fp)
 8221d14:	e0bffc47 	ldb	r2,-15(fp)
 8221d18:	1885883a 	add	r2,r3,r2
 8221d1c:	100b883a 	mov	r5,r2
 8221d20:	01020974 	movhi	r4,2085
 8221d24:	213b2204 	addi	r4,r4,-4984
 8221d28:	821f0c00 	call	821f0c0 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
 8221d2c:	e0bffc47 	ldb	r2,-15(fp)
 8221d30:	e0fffd17 	ldw	r3,-12(fp)
 8221d34:	10800044 	addi	r2,r2,1
 8221d38:	1085883a 	add	r2,r2,r2
 8221d3c:	1085883a 	add	r2,r2,r2
 8221d40:	1885883a 	add	r2,r3,r2
 8221d44:	e0fffe17 	ldw	r3,-8(fp)
 8221d48:	10c00015 	stw	r3,0(r2)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 8221d4c:	e0bffc43 	ldbu	r2,-15(fp)
 8221d50:	10800044 	addi	r2,r2,1
 8221d54:	e0bffc45 	stb	r2,-15(fp)
 8221d58:	e0fffc47 	ldb	r3,-15(fp)
 8221d5c:	e0bffd17 	ldw	r2,-12(fp)
 8221d60:	10800003 	ldbu	r2,0(r2)
 8221d64:	10803fcc 	andi	r2,r2,255
 8221d68:	18bed916 	blt	r3,r2,82218d0 <alt_tse_mac_group_init+0x18c>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
 8221d6c:	d0a07f43 	ldbu	r2,-32259(gp)
 8221d70:	10c03fcc 	andi	r3,r2,255
 8221d74:	008209b4 	movhi	r2,2086
 8221d78:	10b6ff04 	addi	r2,r2,-9220
 8221d7c:	18c7883a 	add	r3,r3,r3
 8221d80:	18c7883a 	add	r3,r3,r3
 8221d84:	10c5883a 	add	r2,r2,r3
 8221d88:	e0fffd17 	ldw	r3,-12(fp)
 8221d8c:	10c00015 	stw	r3,0(r2)
            
            mac_group_count++;
 8221d90:	d0a07f43 	ldbu	r2,-32259(gp)
 8221d94:	10800044 	addi	r2,r2,1
 8221d98:	d0a07f45 	stb	r2,-32259(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
 8221d9c:	e0bffd17 	ldw	r2,-12(fp)
 8221da0:	10c00003 	ldbu	r3,0(r2)
 8221da4:	e0bffc03 	ldbu	r2,-16(fp)
 8221da8:	1885883a 	add	r2,r3,r2
 8221dac:	10bfffc4 	addi	r2,r2,-1
 8221db0:	e0bffc05 	stb	r2,-16(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 8221db4:	e0bffc03 	ldbu	r2,-16(fp)
 8221db8:	10800044 	addi	r2,r2,1
 8221dbc:	e0bffc05 	stb	r2,-16(fp)
 8221dc0:	e0fffc07 	ldb	r3,-16(fp)
 8221dc4:	d0a02d03 	ldbu	r2,-32588(gp)
 8221dc8:	10803fcc 	andi	r2,r2,255
 8221dcc:	18be6716 	blt	r3,r2,822176c <alt_tse_mac_group_init+0x28>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
 8221dd0:	0005883a 	mov	r2,zero
}
 8221dd4:	e037883a 	mov	sp,fp
 8221dd8:	dfc00117 	ldw	ra,4(sp)
 8221ddc:	df000017 	ldw	fp,0(sp)
 8221de0:	dec00204 	addi	sp,sp,8
 8221de4:	f800283a 	ret

08221de8 <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
 8221de8:	deffed04 	addi	sp,sp,-76
 8221dec:	dfc01215 	stw	ra,72(sp)
 8221df0:	df001115 	stw	fp,68(sp)
 8221df4:	df001104 	addi	fp,sp,68
 8221df8:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
 8221dfc:	e03ff515 	stw	zero,-44(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
 8221e00:	e03ff315 	stw	zero,-52(fp)
    
    alt_8 phy_info_count = 0;
 8221e04:	e03ff405 	stb	zero,-48(fp)
    
    alt_tse_phy_info *pphy = 0;
 8221e08:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
 8221e0c:	e03ff715 	stw	zero,-36(fp)
    alt_tse_system_info *psys = 0;
 8221e10:	e03ff815 	stw	zero,-32(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 8221e14:	e0bfff17 	ldw	r2,-4(fp)
 8221e18:	10800117 	ldw	r2,4(r2)
 8221e1c:	10800217 	ldw	r2,8(r2)
 8221e20:	10800017 	ldw	r2,0(r2)
 8221e24:	e0bff915 	stw	r2,-28(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 8221e28:	e0bff917 	ldw	r2,-28(fp)
 8221e2c:	10801004 	addi	r2,r2,64
 8221e30:	10800037 	ldwio	r2,0(r2)
 8221e34:	e0bffa15 	stw	r2,-24(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8221e38:	e13fff17 	ldw	r4,-4(fp)
 8221e3c:	82202440 	call	8220244 <alt_tse_get_mac_group_index>
 8221e40:	e0bffb05 	stb	r2,-20(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 8221e44:	e03ff005 	stb	zero,-64(fp)
 8221e48:	0000cb06 	br	8222178 <alt_tse_mac_get_phy+0x390>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
 8221e4c:	e0bff917 	ldw	r2,-28(fp)
 8221e50:	10801004 	addi	r2,r2,64
 8221e54:	e0fff003 	ldbu	r3,-64(fp)
 8221e58:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
 8221e5c:	e0bff917 	ldw	r2,-28(fp)
 8221e60:	1080a204 	addi	r2,r2,648
 8221e64:	10800037 	ldwio	r2,0(r2)
 8221e68:	e0bffc15 	stw	r2,-16(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
 8221e6c:	e0bff917 	ldw	r2,-28(fp)
 8221e70:	1080a304 	addi	r2,r2,652
 8221e74:	10800037 	ldwio	r2,0(r2)
 8221e78:	e0bff515 	stw	r2,-44(fp)
        
        /* PHY found */
        if (phyid != phyid2)
 8221e7c:	e0fffc17 	ldw	r3,-16(fp)
 8221e80:	e0bff517 	ldw	r2,-44(fp)
 8221e84:	1880b926 	beq	r3,r2,822216c <alt_tse_mac_get_phy+0x384>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
 8221e88:	01000704 	movi	r4,28
 8221e8c:	824b6900 	call	824b690 <malloc>
 8221e90:	e0bff615 	stw	r2,-40(fp)
            if(!pphy) {
 8221e94:	e0bff617 	ldw	r2,-40(fp)
 8221e98:	1000091e 	bne	r2,zero,8221ec0 <alt_tse_mac_get_phy+0xd8>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
 8221e9c:	e0bffb07 	ldb	r2,-20(fp)
 8221ea0:	e0fff407 	ldb	r3,-48(fp)
 8221ea4:	180d883a 	mov	r6,r3
 8221ea8:	100b883a 	mov	r5,r2
 8221eac:	01020974 	movhi	r4,2085
 8221eb0:	213b3104 	addi	r4,r4,-4924
 8221eb4:	820331c0 	call	820331c <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 8221eb8:	00bfffc4 	movi	r2,-1
 8221ebc:	0000ce06 	br	82221f8 <alt_tse_mac_get_phy+0x410>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
 8221ec0:	e0bff617 	ldw	r2,-40(fp)
 8221ec4:	e0fff003 	ldbu	r3,-64(fp)
 8221ec8:	10c00005 	stb	r3,0(r2)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 8221ecc:	e0bffc17 	ldw	r2,-16(fp)
 8221ed0:	100691ba 	slli	r3,r2,6
 8221ed4:	e0bff517 	ldw	r2,-44(fp)
 8221ed8:	1005d2ba 	srai	r2,r2,10
 8221edc:	10800fcc 	andi	r2,r2,63
 8221ee0:	1884b03a 	or	r2,r3,r2
 8221ee4:	e0bffd15 	stw	r2,-12(fp)
            model_number = (phyid2 >> 4) & 0x3f;
 8221ee8:	e0bff517 	ldw	r2,-44(fp)
 8221eec:	1005d13a 	srai	r2,r2,4
 8221ef0:	10800fcc 	andi	r2,r2,63
 8221ef4:	e0bffe05 	stb	r2,-8(fp)
            revision_number = phyid2 & 0x0f;
 8221ef8:	e0bff517 	ldw	r2,-44(fp)
 8221efc:	108003cc 	andi	r2,r2,15
 8221f00:	e0bffe45 	stb	r2,-7(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
 8221f04:	e03ff205 	stb	zero,-56(fp)
            for(i = 0; i < phy_profile_count; i++) {
 8221f08:	e03ff115 	stw	zero,-60(fp)
 8221f0c:	00003406 	br	8221fe0 <alt_tse_mac_get_phy+0x1f8>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 8221f10:	008209b4 	movhi	r2,2086
 8221f14:	10b70304 	addi	r2,r2,-9204
 8221f18:	e0fff117 	ldw	r3,-60(fp)
 8221f1c:	18c7883a 	add	r3,r3,r3
 8221f20:	18c7883a 	add	r3,r3,r3
 8221f24:	10c5883a 	add	r2,r2,r3
 8221f28:	10800017 	ldw	r2,0(r2)
 8221f2c:	10c01417 	ldw	r3,80(r2)
 8221f30:	e0bffd17 	ldw	r2,-12(fp)
 8221f34:	1880271e 	bne	r3,r2,8221fd4 <alt_tse_mac_get_phy+0x1ec>
 8221f38:	008209b4 	movhi	r2,2086
 8221f3c:	10b70304 	addi	r2,r2,-9204
 8221f40:	e0fff117 	ldw	r3,-60(fp)
 8221f44:	18c7883a 	add	r3,r3,r3
 8221f48:	18c7883a 	add	r3,r3,r3
 8221f4c:	10c5883a 	add	r2,r2,r3
 8221f50:	10800017 	ldw	r2,0(r2)
 8221f54:	10801503 	ldbu	r2,84(r2)
 8221f58:	10c03fcc 	andi	r3,r2,255
 8221f5c:	e0bffe03 	ldbu	r2,-8(fp)
 8221f60:	18801c1e 	bne	r3,r2,8221fd4 <alt_tse_mac_get_phy+0x1ec>
                {
                    pphy->pphy_profile = pphy_profiles[i];
 8221f64:	008209b4 	movhi	r2,2086
 8221f68:	10b70304 	addi	r2,r2,-9204
 8221f6c:	e0fff117 	ldw	r3,-60(fp)
 8221f70:	18c7883a 	add	r3,r3,r3
 8221f74:	18c7883a 	add	r3,r3,r3
 8221f78:	10c5883a 	add	r2,r2,r3
 8221f7c:	10c00017 	ldw	r3,0(r2)
 8221f80:	e0bff617 	ldw	r2,-40(fp)
 8221f84:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
 8221f88:	008209b4 	movhi	r2,2086
 8221f8c:	10b70304 	addi	r2,r2,-9204
 8221f90:	e0fff117 	ldw	r3,-60(fp)
 8221f94:	18c7883a 	add	r3,r3,r3
 8221f98:	18c7883a 	add	r3,r3,r3
 8221f9c:	10c5883a 	add	r2,r2,r3
 8221fa0:	10800017 	ldw	r2,0(r2)
 8221fa4:	1009883a 	mov	r4,r2
 8221fa8:	e0bff003 	ldbu	r2,-64(fp)
 8221fac:	e0fffb07 	ldb	r3,-20(fp)
 8221fb0:	180f883a 	mov	r7,r3
 8221fb4:	100d883a 	mov	r6,r2
 8221fb8:	200b883a 	mov	r5,r4
 8221fbc:	01020974 	movhi	r4,2085
 8221fc0:	213b4004 	addi	r4,r4,-4864
 8221fc4:	820331c0 	call	820331c <printf>
                    is_phy_in_profile = 1;
 8221fc8:	00800044 	movi	r2,1
 8221fcc:	e0bff205 	stb	r2,-56(fp)
                    break;
 8221fd0:	00000706 	br	8221ff0 <alt_tse_mac_get_phy+0x208>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
 8221fd4:	e0bff117 	ldw	r2,-60(fp)
 8221fd8:	10800044 	addi	r2,r2,1
 8221fdc:	e0bff115 	stw	r2,-60(fp)
 8221fe0:	d0a07f03 	ldbu	r2,-32260(gp)
 8221fe4:	10803fcc 	andi	r2,r2,255
 8221fe8:	e0fff117 	ldw	r3,-60(fp)
 8221fec:	18bfc816 	blt	r3,r2,8221f10 <alt_tse_mac_get_phy+0x128>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
 8221ff0:	e0bff203 	ldbu	r2,-56(fp)
 8221ff4:	10000f1e 	bne	r2,zero,8222034 <alt_tse_mac_get_phy+0x24c>
                pphy->pphy_profile = 0;
 8221ff8:	e0bff617 	ldw	r2,-40(fp)
 8221ffc:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
 8222000:	e0bff003 	ldbu	r2,-64(fp)
 8222004:	e0fffb07 	ldb	r3,-20(fp)
 8222008:	180d883a 	mov	r6,r3
 822200c:	100b883a 	mov	r5,r2
 8222010:	01020974 	movhi	r4,2085
 8222014:	213b5004 	addi	r4,r4,-4800
 8222018:	820331c0 	call	820331c <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
 822201c:	01020974 	movhi	r4,2085
 8222020:	213b6104 	addi	r4,r4,-4732
 8222024:	82035a00 	call	82035a0 <puts>
                return_value++;
 8222028:	e0bff317 	ldw	r2,-52(fp)
 822202c:	10800044 	addi	r2,r2,1
 8222030:	e0bff315 	stw	r2,-52(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
 8222034:	e0bffd17 	ldw	r2,-12(fp)
 8222038:	100b883a 	mov	r5,r2
 822203c:	01020974 	movhi	r4,2085
 8222040:	213b6e04 	addi	r4,r4,-4680
 8222044:	821f0c00 	call	821f0c0 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
 8222048:	e0bffe03 	ldbu	r2,-8(fp)
 822204c:	100b883a 	mov	r5,r2
 8222050:	01020974 	movhi	r4,2085
 8222054:	213b7904 	addi	r4,r4,-4636
 8222058:	821f0c00 	call	821f0c0 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
 822205c:	e0bffe43 	ldbu	r2,-7(fp)
 8222060:	100b883a 	mov	r5,r2
 8222064:	01020974 	movhi	r4,2085
 8222068:	213b8404 	addi	r4,r4,-4592
 822206c:	821f0c00 	call	821f0c0 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
 8222070:	e17ff617 	ldw	r5,-40(fp)
 8222074:	e13fff17 	ldw	r4,-4(fp)
 8222078:	822220c0 	call	822220c <alt_tse_mac_associate_phy>
 822207c:	1000351e 	bne	r2,zero,8222154 <alt_tse_mac_get_phy+0x36c>
            	
            	pmac_info = pphy->pmac_info;
 8222080:	e0bff617 	ldw	r2,-40(fp)
 8222084:	10800617 	ldw	r2,24(r2)
 8222088:	e0bff715 	stw	r2,-36(fp)
            	psys = pmac_info->psys_info;
 822208c:	e0bff717 	ldw	r2,-36(fp)
 8222090:	10800217 	ldw	r2,8(r2)
 8222094:	e0bff815 	stw	r2,-32(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 8222098:	d8000015 	stw	zero,0(sp)
 822209c:	01c00044 	movi	r7,1
 82220a0:	01800384 	movi	r6,14
 82220a4:	000b883a 	mov	r5,zero
 82220a8:	e13ff617 	ldw	r4,-40(fp)
 82220ac:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
 82220b0:	01400044 	movi	r5,1
 82220b4:	e13ff617 	ldw	r4,-40(fp)
 82220b8:	8222f480 	call	8222f48 <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
 82220bc:	01400044 	movi	r5,1
 82220c0:	e13ff617 	ldw	r4,-40(fp)
 82220c4:	822310c0 	call	822310c <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
 82220c8:	01400044 	movi	r5,1
 82220cc:	e13ff617 	ldw	r4,-40(fp)
 82220d0:	82233600 	call	8223360 <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
 82220d4:	014003f4 	movhi	r5,15
 82220d8:	29509004 	addi	r5,r5,16960
 82220dc:	e13ff617 	ldw	r4,-40(fp)
 82220e0:	82226940 	call	8222694 <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
 82220e4:	e0bff617 	ldw	r2,-40(fp)
 82220e8:	10800517 	ldw	r2,20(r2)
 82220ec:	10000f26 	beq	r2,zero,822212c <alt_tse_mac_get_phy+0x344>
		            if(pphy->pphy_profile->phy_cfg) {
 82220f0:	e0bff617 	ldw	r2,-40(fp)
 82220f4:	10800517 	ldw	r2,20(r2)
 82220f8:	10801717 	ldw	r2,92(r2)
 82220fc:	10000b26 	beq	r2,zero,822212c <alt_tse_mac_get_phy+0x344>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
 8222100:	e0bff617 	ldw	r2,-40(fp)
 8222104:	10800517 	ldw	r2,20(r2)
 8222108:	100b883a 	mov	r5,r2
 822210c:	01020974 	movhi	r4,2085
 8222110:	213b8f04 	addi	r4,r4,-4548
 8222114:	821f0c00 	call	821f0c0 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
 8222118:	e0bff617 	ldw	r2,-40(fp)
 822211c:	10800517 	ldw	r2,20(r2)
 8222120:	10801717 	ldw	r2,92(r2)
 8222124:	e13ff917 	ldw	r4,-28(fp)
 8222128:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
 822212c:	e0bff817 	ldw	r2,-32(fp)
 8222130:	10801117 	ldw	r2,68(r2)
 8222134:	10000726 	beq	r2,zero,8222154 <alt_tse_mac_get_phy+0x36c>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
 8222138:	01020974 	movhi	r4,2085
 822213c:	213b9d04 	addi	r4,r4,-4492
 8222140:	821f0c00 	call	821f0c0 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
 8222144:	e0bff817 	ldw	r2,-32(fp)
 8222148:	10801117 	ldw	r2,68(r2)
 822214c:	e13ff917 	ldw	r4,-28(fp)
 8222150:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
 8222154:	01020974 	movhi	r4,2085
 8222158:	213bab04 	addi	r4,r4,-4436
 822215c:	821f0c00 	call	821f0c0 <no_printf>
	            
            phy_info_count++;
 8222160:	e0bff403 	ldbu	r2,-48(fp)
 8222164:	10800044 	addi	r2,r2,1
 8222168:	e0bff405 	stb	r2,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 822216c:	e0bff003 	ldbu	r2,-64(fp)
 8222170:	10800044 	addi	r2,r2,1
 8222174:	e0bff005 	stb	r2,-64(fp)
 8222178:	e0bff003 	ldbu	r2,-64(fp)
 822217c:	10800830 	cmpltui	r2,r2,32
 8222180:	103f321e 	bne	r2,zero,8221e4c <alt_tse_mac_get_phy+0x64>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
 8222184:	e0bfff17 	ldw	r2,-4(fp)
 8222188:	10800003 	ldbu	r2,0(r2)
 822218c:	10c03fcc 	andi	r3,r2,255
 8222190:	e0bff407 	ldb	r2,-48(fp)
 8222194:	18801326 	beq	r3,r2,82221e4 <alt_tse_mac_get_phy+0x3fc>
        if(phy_info_count == 0) {
 8222198:	e0bff407 	ldb	r2,-48(fp)
 822219c:	1000061e 	bne	r2,zero,82221b8 <alt_tse_mac_get_phy+0x3d0>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
 82221a0:	e0bffb07 	ldb	r2,-20(fp)
 82221a4:	100b883a 	mov	r5,r2
 82221a8:	01020974 	movhi	r4,2085
 82221ac:	213bac04 	addi	r4,r4,-4432
 82221b0:	820331c0 	call	820331c <printf>
 82221b4:	00000b06 	br	82221e4 <alt_tse_mac_get_phy+0x3fc>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
 82221b8:	e0fffb07 	ldb	r3,-20(fp)
 82221bc:	e13ff407 	ldb	r4,-48(fp)
 82221c0:	e0bfff17 	ldw	r2,-4(fp)
 82221c4:	10800003 	ldbu	r2,0(r2)
 82221c8:	10803fcc 	andi	r2,r2,255
 82221cc:	100f883a 	mov	r7,r2
 82221d0:	200d883a 	mov	r6,r4
 82221d4:	180b883a 	mov	r5,r3
 82221d8:	01020974 	movhi	r4,2085
 82221dc:	213bb804 	addi	r4,r4,-4384
 82221e0:	820331c0 	call	820331c <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 82221e4:	e0bff917 	ldw	r2,-28(fp)
 82221e8:	10801004 	addi	r2,r2,64
 82221ec:	e0fffa17 	ldw	r3,-24(fp)
 82221f0:	10c00035 	stwio	r3,0(r2)
    
    return return_value;
 82221f4:	e0bff317 	ldw	r2,-52(fp)
}
 82221f8:	e037883a 	mov	sp,fp
 82221fc:	dfc00117 	ldw	ra,4(sp)
 8222200:	df000017 	ldw	fp,0(sp)
 8222204:	dec00204 	addi	sp,sp,8
 8222208:	f800283a 	ret

0822220c <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
 822220c:	defff604 	addi	sp,sp,-40
 8222210:	dfc00915 	stw	ra,36(sp)
 8222214:	df000815 	stw	fp,32(sp)
 8222218:	df000804 	addi	fp,sp,32
 822221c:	e13ffe15 	stw	r4,-8(fp)
 8222220:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
 8222224:	e03ff915 	stw	zero,-28(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
 8222228:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
 822222c:	e03ffc15 	stw	zero,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 8222230:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8222234:	e13ffe17 	ldw	r4,-8(fp)
 8222238:	82202440 	call	8220244 <alt_tse_get_mac_group_index>
 822223c:	e0bffd45 	stb	r2,-11(fp)
    alt_8 sys_info_index = 0;
 8222240:	e03ffd85 	stb	zero,-10(fp)
    
    is_mapped = 0;
 8222244:	e03ffa05 	stb	zero,-24(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
 8222248:	e03ff815 	stw	zero,-32(fp)
 822224c:	00002c06 	br	8222300 <alt_tse_mac_associate_phy+0xf4>
        pmac_info = pmac_group->pmac_info[i];
 8222250:	e0fffe17 	ldw	r3,-8(fp)
 8222254:	e0bff817 	ldw	r2,-32(fp)
 8222258:	10800044 	addi	r2,r2,1
 822225c:	1085883a 	add	r2,r2,r2
 8222260:	1085883a 	add	r2,r2,r2
 8222264:	1885883a 	add	r2,r3,r2
 8222268:	10800017 	ldw	r2,0(r2)
 822226c:	e0bffc15 	stw	r2,-16(fp)
        psys = pmac_info->psys_info;
 8222270:	e0bffc17 	ldw	r2,-16(fp)
 8222274:	10800217 	ldw	r2,8(r2)
 8222278:	e0bffb15 	stw	r2,-20(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
 822227c:	e0bffb17 	ldw	r2,-20(fp)
 8222280:	10c01017 	ldw	r3,64(r2)
 8222284:	e0bfff17 	ldw	r2,-4(fp)
 8222288:	10800003 	ldbu	r2,0(r2)
 822228c:	10803fcc 	andi	r2,r2,255
 8222290:	1880181e 	bne	r3,r2,82222f4 <alt_tse_mac_associate_phy+0xe8>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222294:	e13ffc17 	ldw	r4,-16(fp)
 8222298:	82202b80 	call	82202b8 <alt_tse_get_mac_info_index>
 822229c:	e0bffd05 	stb	r2,-12(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
 82222a0:	e13ffb17 	ldw	r4,-20(fp)
 82222a4:	82201d80 	call	82201d8 <alt_tse_get_system_index>
 82222a8:	e0bffd85 	stb	r2,-10(fp)
	        
            pmac_info->pphy_info = pphy;
 82222ac:	e0bffc17 	ldw	r2,-16(fp)
 82222b0:	e0ffff17 	ldw	r3,-4(fp)
 82222b4:	10c00115 	stw	r3,4(r2)
            pphy->pmac_info = pmac_info;
 82222b8:	e0bfff17 	ldw	r2,-4(fp)
 82222bc:	e0fffc17 	ldw	r3,-16(fp)
 82222c0:	10c00615 	stw	r3,24(r2)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 82222c4:	e0bffd47 	ldb	r2,-11(fp)
 82222c8:	e0fffd07 	ldb	r3,-12(fp)
 82222cc:	e13ffd87 	ldb	r4,-10(fp)
 82222d0:	200f883a 	mov	r7,r4
 82222d4:	180d883a 	mov	r6,r3
 82222d8:	100b883a 	mov	r5,r2
 82222dc:	01020974 	movhi	r4,2085
 82222e0:	213bd704 	addi	r4,r4,-4260
 82222e4:	820331c0 	call	820331c <printf>
            is_mapped = 1;
 82222e8:	00800044 	movi	r2,1
 82222ec:	e0bffa05 	stb	r2,-24(fp)
            break;
 82222f0:	00000806 	br	8222314 <alt_tse_mac_associate_phy+0x108>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
 82222f4:	e0bff817 	ldw	r2,-32(fp)
 82222f8:	10800044 	addi	r2,r2,1
 82222fc:	e0bff815 	stw	r2,-32(fp)
 8222300:	e0bffe17 	ldw	r2,-8(fp)
 8222304:	10800003 	ldbu	r2,0(r2)
 8222308:	10803fcc 	andi	r2,r2,255
 822230c:	e0fff817 	ldw	r3,-32(fp)
 8222310:	18bfcf16 	blt	r3,r2,8222250 <alt_tse_mac_associate_phy+0x44>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
 8222314:	e0bffa03 	ldbu	r2,-24(fp)
 8222318:	10003d1e 	bne	r2,zero,8222410 <alt_tse_mac_associate_phy+0x204>
        for(i = 0; i < pmac_group->channel; i++) {
 822231c:	e03ff815 	stw	zero,-32(fp)
 8222320:	00003606 	br	82223fc <alt_tse_mac_associate_phy+0x1f0>
            pmac_info = pmac_group->pmac_info[i];
 8222324:	e0fffe17 	ldw	r3,-8(fp)
 8222328:	e0bff817 	ldw	r2,-32(fp)
 822232c:	10800044 	addi	r2,r2,1
 8222330:	1085883a 	add	r2,r2,r2
 8222334:	1085883a 	add	r2,r2,r2
 8222338:	1885883a 	add	r2,r3,r2
 822233c:	10800017 	ldw	r2,0(r2)
 8222340:	e0bffc15 	stw	r2,-16(fp)
            psys = pmac_info->psys_info;
 8222344:	e0bffc17 	ldw	r2,-16(fp)
 8222348:	10800217 	ldw	r2,8(r2)
 822234c:	e0bffb15 	stw	r2,-20(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
 8222350:	e0bffb17 	ldw	r2,-20(fp)
 8222354:	10800517 	ldw	r2,20(r2)
 8222358:	10002426 	beq	r2,zero,82223ec <alt_tse_mac_associate_phy+0x1e0>
 822235c:	e0bffb17 	ldw	r2,-20(fp)
 8222360:	10800617 	ldw	r2,24(r2)
 8222364:	10002126 	beq	r2,zero,82223ec <alt_tse_mac_associate_phy+0x1e0>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
 8222368:	e0bffb17 	ldw	r2,-20(fp)
 822236c:	10801017 	ldw	r2,64(r2)
 8222370:	10bfffd8 	cmpnei	r2,r2,-1
 8222374:	10001e1e 	bne	r2,zero,82223f0 <alt_tse_mac_associate_phy+0x1e4>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222378:	e13ffc17 	ldw	r4,-16(fp)
 822237c:	82202b80 	call	82202b8 <alt_tse_get_mac_info_index>
 8222380:	e0bffd05 	stb	r2,-12(fp)
                sys_info_index = alt_tse_get_system_index(psys);
 8222384:	e13ffb17 	ldw	r4,-20(fp)
 8222388:	82201d80 	call	82201d8 <alt_tse_get_system_index>
 822238c:	e0bffd85 	stb	r2,-10(fp)
                
                pmac_info->pphy_info = pphy;
 8222390:	e0bffc17 	ldw	r2,-16(fp)
 8222394:	e0ffff17 	ldw	r3,-4(fp)
 8222398:	10c00115 	stw	r3,4(r2)
                pphy->pmac_info = pmac_info;
 822239c:	e0bfff17 	ldw	r2,-4(fp)
 82223a0:	e0fffc17 	ldw	r3,-16(fp)
 82223a4:	10c00615 	stw	r3,24(r2)
                psys->tse_phy_mdio_address = pphy->mdio_address;
 82223a8:	e0bfff17 	ldw	r2,-4(fp)
 82223ac:	10800003 	ldbu	r2,0(r2)
 82223b0:	10c03fcc 	andi	r3,r2,255
 82223b4:	e0bffb17 	ldw	r2,-20(fp)
 82223b8:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 82223bc:	e0bffd47 	ldb	r2,-11(fp)
 82223c0:	e0fffd07 	ldb	r3,-12(fp)
 82223c4:	e13ffd87 	ldb	r4,-10(fp)
 82223c8:	200f883a 	mov	r7,r4
 82223cc:	180d883a 	mov	r6,r3
 82223d0:	100b883a 	mov	r5,r2
 82223d4:	01020974 	movhi	r4,2085
 82223d8:	213be704 	addi	r4,r4,-4196
 82223dc:	820331c0 	call	820331c <printf>
                is_mapped = 1;
 82223e0:	00800044 	movi	r2,1
 82223e4:	e0bffa05 	stb	r2,-24(fp)
                break;
 82223e8:	00000906 	br	8222410 <alt_tse_mac_associate_phy+0x204>
            pmac_info = pmac_group->pmac_info[i];
            psys = pmac_info->psys_info;
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
            	continue;
 82223ec:	0001883a 	nop
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
 82223f0:	e0bff817 	ldw	r2,-32(fp)
 82223f4:	10800044 	addi	r2,r2,1
 82223f8:	e0bff815 	stw	r2,-32(fp)
 82223fc:	e0bffe17 	ldw	r2,-8(fp)
 8222400:	10800003 	ldbu	r2,0(r2)
 8222404:	10803fcc 	andi	r2,r2,255
 8222408:	e0fff817 	ldw	r3,-32(fp)
 822240c:	18bfc516 	blt	r3,r2,8222324 <alt_tse_mac_associate_phy+0x118>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
 8222410:	e0bffa03 	ldbu	r2,-24(fp)
 8222414:	1000091e 	bne	r2,zero,822243c <alt_tse_mac_associate_phy+0x230>
    	pphy->pmac_info = 0;
 8222418:	e0bfff17 	ldw	r2,-4(fp)
 822241c:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
 8222420:	e0bffd47 	ldb	r2,-11(fp)
 8222424:	100b883a 	mov	r5,r2
 8222428:	01020974 	movhi	r4,2085
 822242c:	213bf804 	addi	r4,r4,-4128
 8222430:	820331c0 	call	820331c <printf>
        return_value = TSE_PHY_MAP_ERROR;
 8222434:	00bfffc4 	movi	r2,-1
 8222438:	e0bff915 	stw	r2,-28(fp)
    }
    
    return return_value;
 822243c:	e0bff917 	ldw	r2,-28(fp)
}
 8222440:	e037883a 	mov	sp,fp
 8222444:	dfc00117 	ldw	ra,4(sp)
 8222448:	df000017 	ldw	fp,0(sp)
 822244c:	dec00204 	addi	sp,sp,8
 8222450:	f800283a 	ret

08222454 <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
 8222454:	defff804 	addi	sp,sp,-32
 8222458:	dfc00715 	stw	ra,28(sp)
 822245c:	df000615 	stw	fp,24(sp)
 8222460:	df000604 	addi	fp,sp,24
 8222464:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
 8222468:	e0bfff17 	ldw	r2,-4(fp)
 822246c:	10800217 	ldw	r2,8(r2)
 8222470:	e0bffa15 	stw	r2,-24(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
 8222474:	e0bffa17 	ldw	r2,-24(fp)
 8222478:	10800017 	ldw	r2,0(r2)
 822247c:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8222480:	e0bfff17 	ldw	r2,-4(fp)
 8222484:	10800317 	ldw	r2,12(r2)
 8222488:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 822248c:	e13fff17 	ldw	r4,-4(fp)
 8222490:	82202b80 	call	82202b8 <alt_tse_get_mac_info_index>
 8222494:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8222498:	e13ffc17 	ldw	r4,-16(fp)
 822249c:	82202440 	call	8220244 <alt_tse_get_mac_group_index>
 82224a0:	e0bffd45 	stb	r2,-11(fp)

    if(psys->tse_pcs_ena) {
 82224a4:	e0bffa17 	ldw	r2,-24(fp)
 82224a8:	108003c3 	ldbu	r2,15(r2)
 82224ac:	10803fcc 	andi	r2,r2,255
 82224b0:	10002c26 	beq	r2,zero,8222564 <alt_tse_phy_cfg_pcs+0x110>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
 82224b4:	e0bffd47 	ldb	r2,-11(fp)
 82224b8:	e0fffd07 	ldb	r3,-12(fp)
 82224bc:	180d883a 	mov	r6,r3
 82224c0:	100b883a 	mov	r5,r2
 82224c4:	01020974 	movhi	r4,2085
 82224c8:	213c2904 	addi	r4,r4,-3932
 82224cc:	820331c0 	call	820331c <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
 82224d0:	e0bffb17 	ldw	r2,-20(fp)
 82224d4:	10808004 	addi	r2,r2,512
 82224d8:	10801404 	addi	r2,r2,80
 82224dc:	10800037 	ldwio	r2,0(r2)
 82224e0:	e0bffe15 	stw	r2,-8(fp)
        
        if(psys->tse_pcs_sgmii) {
 82224e4:	e0bffa17 	ldw	r2,-24(fp)
 82224e8:	10800403 	ldbu	r2,16(r2)
 82224ec:	10803fcc 	andi	r2,r2,255
 82224f0:	10000e26 	beq	r2,zero,822252c <alt_tse_phy_cfg_pcs+0xd8>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
 82224f4:	e0bffd47 	ldb	r2,-11(fp)
 82224f8:	e0fffd07 	ldb	r3,-12(fp)
 82224fc:	180d883a 	mov	r6,r3
 8222500:	100b883a 	mov	r5,r2
 8222504:	01020974 	movhi	r4,2085
 8222508:	213c3704 	addi	r4,r4,-3876
 822250c:	820331c0 	call	820331c <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
 8222510:	e0bffb17 	ldw	r2,-20(fp)
 8222514:	10808004 	addi	r2,r2,512
 8222518:	10801404 	addi	r2,r2,80
 822251c:	e0fffe17 	ldw	r3,-8(fp)
 8222520:	18c000d4 	ori	r3,r3,3
 8222524:	10c00035 	stwio	r3,0(r2)
 8222528:	00000e06 	br	8222564 <alt_tse_phy_cfg_pcs+0x110>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
 822252c:	e0bffd47 	ldb	r2,-11(fp)
 8222530:	e0fffd07 	ldb	r3,-12(fp)
 8222534:	180d883a 	mov	r6,r3
 8222538:	100b883a 	mov	r5,r2
 822253c:	01020974 	movhi	r4,2085
 8222540:	213c4304 	addi	r4,r4,-3828
 8222544:	820331c0 	call	820331c <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
 8222548:	e0bffb17 	ldw	r2,-20(fp)
 822254c:	10808004 	addi	r2,r2,512
 8222550:	10801404 	addi	r2,r2,80
 8222554:	e13ffe17 	ldw	r4,-8(fp)
 8222558:	00ffff04 	movi	r3,-4
 822255c:	20c6703a 	and	r3,r4,r3
 8222560:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
 8222564:	0005883a 	mov	r2,zero
}
 8222568:	e037883a 	mov	sp,fp
 822256c:	dfc00117 	ldw	ra,4(sp)
 8222570:	df000017 	ldw	fp,0(sp)
 8222574:	dec00204 	addi	sp,sp,8
 8222578:	f800283a 	ret

0822257c <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
 822257c:	defffb04 	addi	sp,sp,-20
 8222580:	dfc00415 	stw	ra,16(sp)
 8222584:	df000315 	stw	fp,12(sp)
 8222588:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
 822258c:	e03ffd05 	stb	zero,-12(fp)
	alt_8 j = 0;
 8222590:	e03ffd45 	stb	zero,-11(fp)
    
    alt_tse_mac_group *pmac_group = 0;
 8222594:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
 8222598:	e03fff15 	stw	zero,-4(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
 822259c:	82212980 	call	8221298 <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
 82225a0:	82215340 	call	8221534 <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
 82225a4:	82217440 	call	8221744 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 82225a8:	e03ffd05 	stb	zero,-12(fp)
 82225ac:	00002f06 	br	822266c <alt_tse_phy_init+0xf0>
        pmac_group = pmac_groups[i];
 82225b0:	e0fffd07 	ldb	r3,-12(fp)
 82225b4:	008209b4 	movhi	r2,2086
 82225b8:	10b6ff04 	addi	r2,r2,-9220
 82225bc:	18c7883a 	add	r3,r3,r3
 82225c0:	18c7883a 	add	r3,r3,r3
 82225c4:	10c5883a 	add	r2,r2,r3
 82225c8:	10800017 	ldw	r2,0(r2)
 82225cc:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
 82225d0:	e0bffe17 	ldw	r2,-8(fp)
 82225d4:	10800117 	ldw	r2,4(r2)
 82225d8:	10800217 	ldw	r2,8(r2)
 82225dc:	10800203 	ldbu	r2,8(r2)
 82225e0:	10803fcc 	andi	r2,r2,255
 82225e4:	10000326 	beq	r2,zero,82225f4 <alt_tse_phy_init+0x78>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
 82225e8:	e13ffe17 	ldw	r4,-8(fp)
 82225ec:	8221de80 	call	8221de8 <alt_tse_mac_get_phy>
 82225f0:	00000706 	br	8222610 <alt_tse_phy_init+0x94>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
 82225f4:	e0bffd07 	ldb	r2,-12(fp)
 82225f8:	e0fffd47 	ldb	r3,-11(fp)
 82225fc:	180d883a 	mov	r6,r3
 8222600:	100b883a 	mov	r5,r2
 8222604:	01020974 	movhi	r4,2085
 8222608:	213c4f04 	addi	r4,r4,-3780
 822260c:	820331c0 	call	820331c <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 8222610:	e03ffd45 	stb	zero,-11(fp)
 8222614:	00000d06 	br	822264c <alt_tse_phy_init+0xd0>
            pmac_info = pmac_group->pmac_info[j];
 8222618:	e0bffd47 	ldb	r2,-11(fp)
 822261c:	e0fffe17 	ldw	r3,-8(fp)
 8222620:	10800044 	addi	r2,r2,1
 8222624:	1085883a 	add	r2,r2,r2
 8222628:	1085883a 	add	r2,r2,r2
 822262c:	1885883a 	add	r2,r3,r2
 8222630:	10800017 	ldw	r2,0(r2)
 8222634:	e0bfff15 	stw	r2,-4(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
 8222638:	e13fff17 	ldw	r4,-4(fp)
 822263c:	82224540 	call	8222454 <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 8222640:	e0bffd43 	ldbu	r2,-11(fp)
 8222644:	10800044 	addi	r2,r2,1
 8222648:	e0bffd45 	stb	r2,-11(fp)
 822264c:	e0fffd47 	ldb	r3,-11(fp)
 8222650:	e0bffe17 	ldw	r2,-8(fp)
 8222654:	10800003 	ldbu	r2,0(r2)
 8222658:	10803fcc 	andi	r2,r2,255
 822265c:	18bfee16 	blt	r3,r2,8222618 <alt_tse_phy_init+0x9c>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 8222660:	e0bffd03 	ldbu	r2,-12(fp)
 8222664:	10800044 	addi	r2,r2,1
 8222668:	e0bffd05 	stb	r2,-12(fp)
 822266c:	e0fffd07 	ldb	r3,-12(fp)
 8222670:	d0a07f43 	ldbu	r2,-32259(gp)
 8222674:	10803fcc 	andi	r2,r2,255
 8222678:	18bfcd16 	blt	r3,r2,82225b0 <alt_tse_phy_init+0x34>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
 822267c:	0005883a 	mov	r2,zero
}
 8222680:	e037883a 	mov	sp,fp
 8222684:	dfc00117 	ldw	ra,4(sp)
 8222688:	df000017 	ldw	fp,0(sp)
 822268c:	dec00204 	addi	sp,sp,8
 8222690:	f800283a 	ret

08222694 <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 8222694:	defff704 	addi	sp,sp,-36
 8222698:	dfc00815 	stw	ra,32(sp)
 822269c:	df000715 	stw	fp,28(sp)
 82226a0:	df000704 	addi	fp,sp,28
 82226a4:	e13ffe15 	stw	r4,-8(fp)
 82226a8:	e17fff15 	stw	r5,-4(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 82226ac:	e0bffe17 	ldw	r2,-8(fp)
 82226b0:	10800617 	ldw	r2,24(r2)
 82226b4:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 82226b8:	e0bffb17 	ldw	r2,-20(fp)
 82226bc:	10800317 	ldw	r2,12(r2)
 82226c0:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82226c4:	e13ffb17 	ldw	r4,-20(fp)
 82226c8:	82202b80 	call	82202b8 <alt_tse_get_mac_info_index>
 82226cc:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 82226d0:	e13ffc17 	ldw	r4,-16(fp)
 82226d4:	82202440 	call	8220244 <alt_tse_get_mac_group_index>
 82226d8:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 82226dc:	e13ffe17 	ldw	r4,-8(fp)
 82226e0:	82210040 	call	8221004 <alt_tse_phy_rd_mdio_addr>
 82226e4:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 82226e8:	e0bffe17 	ldw	r2,-8(fp)
 82226ec:	10800003 	ldbu	r2,0(r2)
 82226f0:	10803fcc 	andi	r2,r2,255
 82226f4:	100b883a 	mov	r5,r2
 82226f8:	e13ffe17 	ldw	r4,-8(fp)
 82226fc:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 8222700:	01c00044 	movi	r7,1
 8222704:	018000c4 	movi	r6,3
 8222708:	01400044 	movi	r5,1
 822270c:	e13ffe17 	ldw	r4,-8(fp)
 8222710:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222714:	10000d1e 	bne	r2,zero,822274c <alt_tse_phy_restart_an+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 8222718:	e0bffd47 	ldb	r2,-11(fp)
 822271c:	e0fffd07 	ldb	r3,-12(fp)
 8222720:	180d883a 	mov	r6,r3
 8222724:	100b883a 	mov	r5,r2
 8222728:	01020974 	movhi	r4,2085
 822272c:	213c6504 	addi	r4,r4,-3692
 8222730:	820331c0 	call	820331c <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222734:	e0bffd83 	ldbu	r2,-10(fp)
 8222738:	100b883a 	mov	r5,r2
 822273c:	e13ffe17 	ldw	r4,-8(fp)
 8222740:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
 8222744:	00bfff84 	movi	r2,-2
 8222748:	00003c06 	br	822283c <alt_tse_phy_restart_an+0x1a8>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
 822274c:	00800044 	movi	r2,1
 8222750:	d8800015 	stw	r2,0(sp)
 8222754:	01c00044 	movi	r7,1
 8222758:	01800304 	movi	r6,12
 822275c:	000b883a 	mov	r5,zero
 8222760:	e13ffe17 	ldw	r4,-8(fp)
 8222764:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
 8222768:	00800044 	movi	r2,1
 822276c:	d8800015 	stw	r2,0(sp)
 8222770:	01c00044 	movi	r7,1
 8222774:	01800244 	movi	r6,9
 8222778:	000b883a 	mov	r5,zero
 822277c:	e13ffe17 	ldw	r4,-8(fp)
 8222780:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
 8222784:	e0bffd47 	ldb	r2,-11(fp)
 8222788:	e0fffd07 	ldb	r3,-12(fp)
 822278c:	180d883a 	mov	r6,r3
 8222790:	100b883a 	mov	r5,r2
 8222794:	01020974 	movhi	r4,2085
 8222798:	213c7504 	addi	r4,r4,-3628
 822279c:	820331c0 	call	820331c <printf>
    
    alt_32 timeout = 0;
 82227a0:	e03ffa15 	stw	zero,-24(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 82227a4:	00001306 	br	82227f4 <alt_tse_phy_restart_an+0x160>
        if(timeout++ > timeout_threshold) {
 82227a8:	e0bffa17 	ldw	r2,-24(fp)
 82227ac:	10c00044 	addi	r3,r2,1
 82227b0:	e0fffa15 	stw	r3,-24(fp)
 82227b4:	1007883a 	mov	r3,r2
 82227b8:	e0bfff17 	ldw	r2,-4(fp)
 82227bc:	10c00d2e 	bgeu	r2,r3,82227f4 <alt_tse_phy_restart_an+0x160>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
 82227c0:	e0bffd47 	ldb	r2,-11(fp)
 82227c4:	e0fffd07 	ldb	r3,-12(fp)
 82227c8:	180d883a 	mov	r6,r3
 82227cc:	100b883a 	mov	r5,r2
 82227d0:	01020974 	movhi	r4,2085
 82227d4:	213c8704 	addi	r4,r4,-3556
 82227d8:	820331c0 	call	820331c <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 82227dc:	e0bffd83 	ldbu	r2,-10(fp)
 82227e0:	100b883a 	mov	r5,r2
 82227e4:	e13ffe17 	ldw	r4,-8(fp)
 82227e8:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
 82227ec:	00bfffc4 	movi	r2,-1
 82227f0:	00001206 	br	822283c <alt_tse_phy_restart_an+0x1a8>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 82227f4:	01c00044 	movi	r7,1
 82227f8:	01800144 	movi	r6,5
 82227fc:	01400044 	movi	r5,1
 8222800:	e13ffe17 	ldw	r4,-8(fp)
 8222804:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222808:	103fe726 	beq	r2,zero,82227a8 <alt_tse_phy_restart_an+0x114>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
 822280c:	e0bffd47 	ldb	r2,-11(fp)
 8222810:	e0fffd07 	ldb	r3,-12(fp)
 8222814:	180d883a 	mov	r6,r3
 8222818:	100b883a 	mov	r5,r2
 822281c:	01020974 	movhi	r4,2085
 8222820:	213c9304 	addi	r4,r4,-3508
 8222824:	820331c0 	call	820331c <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222828:	e0bffd83 	ldbu	r2,-10(fp)
 822282c:	100b883a 	mov	r5,r2
 8222830:	e13ffe17 	ldw	r4,-8(fp)
 8222834:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
 8222838:	0005883a 	mov	r2,zero
}
 822283c:	e037883a 	mov	sp,fp
 8222840:	dfc00117 	ldw	ra,4(sp)
 8222844:	df000017 	ldw	fp,0(sp)
 8222848:	dec00204 	addi	sp,sp,8
 822284c:	f800283a 	ret

08222850 <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 8222850:	defff904 	addi	sp,sp,-28
 8222854:	dfc00615 	stw	ra,24(sp)
 8222858:	df000515 	stw	fp,20(sp)
 822285c:	df000504 	addi	fp,sp,20
 8222860:	e13ffe15 	stw	r4,-8(fp)
 8222864:	e17fff15 	stw	r5,-4(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8222868:	e0bffe17 	ldw	r2,-8(fp)
 822286c:	10800617 	ldw	r2,24(r2)
 8222870:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8222874:	e0bffb17 	ldw	r2,-20(fp)
 8222878:	10800317 	ldw	r2,12(r2)
 822287c:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222880:	e13ffb17 	ldw	r4,-20(fp)
 8222884:	82202b80 	call	82202b8 <alt_tse_get_mac_info_index>
 8222888:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
 822288c:	e13ffc17 	ldw	r4,-16(fp)
 8222890:	82202440 	call	8220244 <alt_tse_get_mac_group_index>
 8222894:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 8222898:	e13ffe17 	ldw	r4,-8(fp)
 822289c:	82210040 	call	8221004 <alt_tse_phy_rd_mdio_addr>
 82228a0:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 82228a4:	e0bffe17 	ldw	r2,-8(fp)
 82228a8:	10800003 	ldbu	r2,0(r2)
 82228ac:	10803fcc 	andi	r2,r2,255
 82228b0:	100b883a 	mov	r5,r2
 82228b4:	e13ffe17 	ldw	r4,-8(fp)
 82228b8:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
 82228bc:	e0bffd47 	ldb	r2,-11(fp)
 82228c0:	e0fffd07 	ldb	r3,-12(fp)
 82228c4:	180d883a 	mov	r6,r3
 82228c8:	100b883a 	mov	r5,r2
 82228cc:	01020974 	movhi	r4,2085
 82228d0:	213c9f04 	addi	r4,r4,-3460
 82228d4:	820331c0 	call	820331c <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 82228d8:	01c00044 	movi	r7,1
 82228dc:	01800384 	movi	r6,14
 82228e0:	000b883a 	mov	r5,zero
 82228e4:	e13ffe17 	ldw	r4,-8(fp)
 82228e8:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 82228ec:	1000061e 	bne	r2,zero,8222908 <alt_tse_phy_check_link+0xb8>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
 82228f0:	01c00044 	movi	r7,1
 82228f4:	01800144 	movi	r6,5
 82228f8:	01400044 	movi	r5,1
 82228fc:	e13ffe17 	ldw	r4,-8(fp)
 8222900:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 8222904:	1000191e 	bne	r2,zero,822296c <alt_tse_phy_check_link+0x11c>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
 8222908:	e0bffd47 	ldb	r2,-11(fp)
 822290c:	e0fffd07 	ldb	r3,-12(fp)
 8222910:	180d883a 	mov	r6,r3
 8222914:	100b883a 	mov	r5,r2
 8222918:	01020974 	movhi	r4,2085
 822291c:	213caa04 	addi	r4,r4,-3416
 8222920:	820331c0 	call	820331c <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
 8222924:	e17fff17 	ldw	r5,-4(fp)
 8222928:	e13ffe17 	ldw	r4,-8(fp)
 822292c:	82226940 	call	8222694 <alt_tse_phy_restart_an>
 8222930:	10bfffd8 	cmpnei	r2,r2,-1
 8222934:	10000d1e 	bne	r2,zero,822296c <alt_tse_phy_check_link+0x11c>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
 8222938:	e0bffd47 	ldb	r2,-11(fp)
 822293c:	e0fffd07 	ldb	r3,-12(fp)
 8222940:	180d883a 	mov	r6,r3
 8222944:	100b883a 	mov	r5,r2
 8222948:	01020974 	movhi	r4,2085
 822294c:	213cbe04 	addi	r4,r4,-3336
 8222950:	820331c0 	call	820331c <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222954:	e0bffd83 	ldbu	r2,-10(fp)
 8222958:	100b883a 	mov	r5,r2
 822295c:	e13ffe17 	ldw	r4,-8(fp)
 8222960:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
 8222964:	00bfffc4 	movi	r2,-1
 8222968:	00000c06 	br	822299c <alt_tse_phy_check_link+0x14c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
 822296c:	e0bffd47 	ldb	r2,-11(fp)
 8222970:	e0fffd07 	ldb	r3,-12(fp)
 8222974:	180d883a 	mov	r6,r3
 8222978:	100b883a 	mov	r5,r2
 822297c:	01020974 	movhi	r4,2085
 8222980:	213ccb04 	addi	r4,r4,-3284
 8222984:	820331c0 	call	820331c <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222988:	e0bffd83 	ldbu	r2,-10(fp)
 822298c:	100b883a 	mov	r5,r2
 8222990:	e13ffe17 	ldw	r4,-8(fp)
 8222994:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
 8222998:	0005883a 	mov	r2,zero
}
 822299c:	e037883a 	mov	sp,fp
 82229a0:	dfc00117 	ldw	ra,4(sp)
 82229a4:	df000017 	ldw	fp,0(sp)
 82229a8:	dec00204 	addi	sp,sp,8
 82229ac:	f800283a 	ret

082229b0 <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
 82229b0:	defff904 	addi	sp,sp,-28
 82229b4:	dfc00615 	stw	ra,24(sp)
 82229b8:	df000515 	stw	fp,20(sp)
 82229bc:	df000504 	addi	fp,sp,20
 82229c0:	e13fff15 	stw	r4,-4(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
 82229c4:	e03ffb15 	stw	zero,-20(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 82229c8:	e0bfff17 	ldw	r2,-4(fp)
 82229cc:	10800617 	ldw	r2,24(r2)
 82229d0:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 82229d4:	e0bffc17 	ldw	r2,-16(fp)
 82229d8:	10800317 	ldw	r2,12(r2)
 82229dc:	e0bffd15 	stw	r2,-12(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82229e0:	e13ffc17 	ldw	r4,-16(fp)
 82229e4:	82202b80 	call	82202b8 <alt_tse_get_mac_info_index>
 82229e8:	e0bffe05 	stb	r2,-8(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
 82229ec:	e13ffd17 	ldw	r4,-12(fp)
 82229f0:	82202440 	call	8220244 <alt_tse_get_mac_group_index>
 82229f4:	e0bffe45 	stb	r2,-7(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 82229f8:	e13fff17 	ldw	r4,-4(fp)
 82229fc:	82210040 	call	8221004 <alt_tse_phy_rd_mdio_addr>
 8222a00:	e0bffe85 	stb	r2,-6(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8222a04:	e0bfff17 	ldw	r2,-4(fp)
 8222a08:	10800003 	ldbu	r2,0(r2)
 8222a0c:	10803fcc 	andi	r2,r2,255
 8222a10:	100b883a 	mov	r5,r2
 8222a14:	e13fff17 	ldw	r4,-4(fp)
 8222a18:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 8222a1c:	01c00044 	movi	r7,1
 8222a20:	018000c4 	movi	r6,3
 8222a24:	01400044 	movi	r5,1
 8222a28:	e13fff17 	ldw	r4,-4(fp)
 8222a2c:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222a30:	10000d1e 	bne	r2,zero,8222a68 <alt_tse_phy_get_cap+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 8222a34:	e0bffe47 	ldb	r2,-7(fp)
 8222a38:	e0fffe07 	ldb	r3,-8(fp)
 8222a3c:	180d883a 	mov	r6,r3
 8222a40:	100b883a 	mov	r5,r2
 8222a44:	01020974 	movhi	r4,2085
 8222a48:	213c6504 	addi	r4,r4,-3692
 8222a4c:	820331c0 	call	820331c <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222a50:	e0bffe83 	ldbu	r2,-6(fp)
 8222a54:	100b883a 	mov	r5,r2
 8222a58:	e13fff17 	ldw	r4,-4(fp)
 8222a5c:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
 8222a60:	00bfff84 	movi	r2,-2
 8222a64:	00013306 	br	8222f34 <alt_tse_phy_get_cap+0x584>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8222a68:	01400134 	movhi	r5,4
 8222a6c:	29742404 	addi	r5,r5,-12144
 8222a70:	e13fff17 	ldw	r4,-4(fp)
 8222a74:	82226940 	call	8222694 <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
 8222a78:	01c00044 	movi	r7,1
 8222a7c:	01800144 	movi	r6,5
 8222a80:	01400044 	movi	r5,1
 8222a84:	e13fff17 	ldw	r4,-4(fp)
 8222a88:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222a8c:	1000021e 	bne	r2,zero,8222a98 <alt_tse_phy_get_cap+0xe8>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
 8222a90:	00bfffc4 	movi	r2,-1
 8222a94:	e0bffb15 	stw	r2,-20(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
 8222a98:	01c00044 	movi	r7,1
 8222a9c:	018003c4 	movi	r6,15
 8222aa0:	014003c4 	movi	r5,15
 8222aa4:	e13fff17 	ldw	r4,-4(fp)
 8222aa8:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222aac:	1007883a 	mov	r3,r2
 8222ab0:	e0bfff17 	ldw	r2,-4(fp)
 8222ab4:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
 8222ab8:	01c00044 	movi	r7,1
 8222abc:	01800384 	movi	r6,14
 8222ac0:	014003c4 	movi	r5,15
 8222ac4:	e13fff17 	ldw	r4,-4(fp)
 8222ac8:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222acc:	1007883a 	mov	r3,r2
 8222ad0:	e0bfff17 	ldw	r2,-4(fp)
 8222ad4:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
 8222ad8:	01c00044 	movi	r7,1
 8222adc:	01800344 	movi	r6,13
 8222ae0:	014003c4 	movi	r5,15
 8222ae4:	e13fff17 	ldw	r4,-4(fp)
 8222ae8:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222aec:	1007883a 	mov	r3,r2
 8222af0:	e0bfff17 	ldw	r2,-4(fp)
 8222af4:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 8222af8:	01c00044 	movi	r7,1
 8222afc:	01800304 	movi	r6,12
 8222b00:	014003c4 	movi	r5,15
 8222b04:	e13fff17 	ldw	r4,-4(fp)
 8222b08:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222b0c:	1007883a 	mov	r3,r2
 8222b10:	e0bfff17 	ldw	r2,-4(fp)
 8222b14:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 8222b18:	01c00044 	movi	r7,1
 8222b1c:	018003c4 	movi	r6,15
 8222b20:	01400044 	movi	r5,1
 8222b24:	e13fff17 	ldw	r4,-4(fp)
 8222b28:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222b2c:	1007883a 	mov	r3,r2
 8222b30:	e0bfff17 	ldw	r2,-4(fp)
 8222b34:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 8222b38:	01c00044 	movi	r7,1
 8222b3c:	01800384 	movi	r6,14
 8222b40:	01400044 	movi	r5,1
 8222b44:	e13fff17 	ldw	r4,-4(fp)
 8222b48:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222b4c:	1007883a 	mov	r3,r2
 8222b50:	e0bfff17 	ldw	r2,-4(fp)
 8222b54:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 8222b58:	01c00044 	movi	r7,1
 8222b5c:	01800344 	movi	r6,13
 8222b60:	01400044 	movi	r5,1
 8222b64:	e13fff17 	ldw	r4,-4(fp)
 8222b68:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222b6c:	1007883a 	mov	r3,r2
 8222b70:	e0bfff17 	ldw	r2,-4(fp)
 8222b74:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
 8222b78:	01c00044 	movi	r7,1
 8222b7c:	01800284 	movi	r6,10
 8222b80:	01400044 	movi	r5,1
 8222b84:	e13fff17 	ldw	r4,-4(fp)
 8222b88:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222b8c:	1007883a 	mov	r3,r2
 8222b90:	e0bfff17 	ldw	r2,-4(fp)
 8222b94:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
 8222b98:	01c00044 	movi	r7,1
 8222b9c:	01800244 	movi	r6,9
 8222ba0:	01400044 	movi	r5,1
 8222ba4:	e13fff17 	ldw	r4,-4(fp)
 8222ba8:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222bac:	1007883a 	mov	r3,r2
 8222bb0:	e0bfff17 	ldw	r2,-4(fp)
 8222bb4:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 8222bb8:	01c00044 	movi	r7,1
 8222bbc:	01800304 	movi	r6,12
 8222bc0:	01400044 	movi	r5,1
 8222bc4:	e13fff17 	ldw	r4,-4(fp)
 8222bc8:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222bcc:	1007883a 	mov	r3,r2
 8222bd0:	e0bfff17 	ldw	r2,-4(fp)
 8222bd4:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 8222bd8:	01c00044 	movi	r7,1
 8222bdc:	018002c4 	movi	r6,11
 8222be0:	01400044 	movi	r5,1
 8222be4:	e13fff17 	ldw	r4,-4(fp)
 8222be8:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222bec:	1007883a 	mov	r3,r2
 8222bf0:	e0bfff17 	ldw	r2,-4(fp)
 8222bf4:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
 8222bf8:	01c00044 	movi	r7,1
 8222bfc:	018002c4 	movi	r6,11
 8222c00:	01400284 	movi	r5,10
 8222c04:	e13fff17 	ldw	r4,-4(fp)
 8222c08:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222c0c:	1007883a 	mov	r3,r2
 8222c10:	e0bfff17 	ldw	r2,-4(fp)
 8222c14:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
 8222c18:	01c00044 	movi	r7,1
 8222c1c:	01800284 	movi	r6,10
 8222c20:	01400284 	movi	r5,10
 8222c24:	e13fff17 	ldw	r4,-4(fp)
 8222c28:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222c2c:	1007883a 	mov	r3,r2
 8222c30:	e0bfff17 	ldw	r2,-4(fp)
 8222c34:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
 8222c38:	01c00044 	movi	r7,1
 8222c3c:	01800244 	movi	r6,9
 8222c40:	01400144 	movi	r5,5
 8222c44:	e13fff17 	ldw	r4,-4(fp)
 8222c48:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222c4c:	1007883a 	mov	r3,r2
 8222c50:	e0bfff17 	ldw	r2,-4(fp)
 8222c54:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
 8222c58:	01c00044 	movi	r7,1
 8222c5c:	01800204 	movi	r6,8
 8222c60:	01400144 	movi	r5,5
 8222c64:	e13fff17 	ldw	r4,-4(fp)
 8222c68:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222c6c:	1007883a 	mov	r3,r2
 8222c70:	e0bfff17 	ldw	r2,-4(fp)
 8222c74:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
 8222c78:	01c00044 	movi	r7,1
 8222c7c:	018001c4 	movi	r6,7
 8222c80:	01400144 	movi	r5,5
 8222c84:	e13fff17 	ldw	r4,-4(fp)
 8222c88:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222c8c:	1007883a 	mov	r3,r2
 8222c90:	e0bfff17 	ldw	r2,-4(fp)
 8222c94:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
 8222c98:	01c00044 	movi	r7,1
 8222c9c:	01800184 	movi	r6,6
 8222ca0:	01400144 	movi	r5,5
 8222ca4:	e13fff17 	ldw	r4,-4(fp)
 8222ca8:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222cac:	1007883a 	mov	r3,r2
 8222cb0:	e0bfff17 	ldw	r2,-4(fp)
 8222cb4:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
 8222cb8:	01c00044 	movi	r7,1
 8222cbc:	01800144 	movi	r6,5
 8222cc0:	01400144 	movi	r5,5
 8222cc4:	e13fff17 	ldw	r4,-4(fp)
 8222cc8:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222ccc:	1007883a 	mov	r3,r2
 8222cd0:	e0bfff17 	ldw	r2,-4(fp)
 8222cd4:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
 8222cd8:	e0bffe47 	ldb	r2,-7(fp)
 8222cdc:	e0fffe07 	ldb	r3,-8(fp)
 8222ce0:	180d883a 	mov	r6,r3
 8222ce4:	100b883a 	mov	r5,r2
 8222ce8:	01020974 	movhi	r4,2085
 8222cec:	213cd604 	addi	r4,r4,-3240
 8222cf0:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
 8222cf4:	e0bfff17 	ldw	r2,-4(fp)
 8222cf8:	10800043 	ldbu	r2,1(r2)
 8222cfc:	10803fcc 	andi	r2,r2,255
 8222d00:	100b883a 	mov	r5,r2
 8222d04:	01020974 	movhi	r4,2085
 8222d08:	213ce104 	addi	r4,r4,-3196
 8222d0c:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
 8222d10:	e0bfff17 	ldw	r2,-4(fp)
 8222d14:	10800083 	ldbu	r2,2(r2)
 8222d18:	10803fcc 	andi	r2,r2,255
 8222d1c:	100b883a 	mov	r5,r2
 8222d20:	01020974 	movhi	r4,2085
 8222d24:	213ceb04 	addi	r4,r4,-3156
 8222d28:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
 8222d2c:	e0bfff17 	ldw	r2,-4(fp)
 8222d30:	108000c3 	ldbu	r2,3(r2)
 8222d34:	10803fcc 	andi	r2,r2,255
 8222d38:	100b883a 	mov	r5,r2
 8222d3c:	01020974 	movhi	r4,2085
 8222d40:	213cf504 	addi	r4,r4,-3116
 8222d44:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
 8222d48:	e0bfff17 	ldw	r2,-4(fp)
 8222d4c:	10800103 	ldbu	r2,4(r2)
 8222d50:	10803fcc 	andi	r2,r2,255
 8222d54:	100b883a 	mov	r5,r2
 8222d58:	01020974 	movhi	r4,2085
 8222d5c:	213cff04 	addi	r4,r4,-3076
 8222d60:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
 8222d64:	e0bfff17 	ldw	r2,-4(fp)
 8222d68:	10800143 	ldbu	r2,5(r2)
 8222d6c:	10803fcc 	andi	r2,r2,255
 8222d70:	100b883a 	mov	r5,r2
 8222d74:	01020974 	movhi	r4,2085
 8222d78:	213d0904 	addi	r4,r4,-3036
 8222d7c:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
 8222d80:	e0bfff17 	ldw	r2,-4(fp)
 8222d84:	10800183 	ldbu	r2,6(r2)
 8222d88:	10803fcc 	andi	r2,r2,255
 8222d8c:	100b883a 	mov	r5,r2
 8222d90:	01020974 	movhi	r4,2085
 8222d94:	213d1304 	addi	r4,r4,-2996
 8222d98:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
 8222d9c:	e0bfff17 	ldw	r2,-4(fp)
 8222da0:	108001c3 	ldbu	r2,7(r2)
 8222da4:	10803fcc 	andi	r2,r2,255
 8222da8:	100b883a 	mov	r5,r2
 8222dac:	01020974 	movhi	r4,2085
 8222db0:	213d1d04 	addi	r4,r4,-2956
 8222db4:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
 8222db8:	e0bfff17 	ldw	r2,-4(fp)
 8222dbc:	10800203 	ldbu	r2,8(r2)
 8222dc0:	10803fcc 	andi	r2,r2,255
 8222dc4:	100b883a 	mov	r5,r2
 8222dc8:	01020974 	movhi	r4,2085
 8222dcc:	213d2704 	addi	r4,r4,-2916
 8222dd0:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
 8222dd4:	e0bfff17 	ldw	r2,-4(fp)
 8222dd8:	10800243 	ldbu	r2,9(r2)
 8222ddc:	10803fcc 	andi	r2,r2,255
 8222de0:	100b883a 	mov	r5,r2
 8222de4:	01020974 	movhi	r4,2085
 8222de8:	213d3104 	addi	r4,r4,-2876
 8222dec:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
 8222df0:	e0bfff17 	ldw	r2,-4(fp)
 8222df4:	10800283 	ldbu	r2,10(r2)
 8222df8:	10803fcc 	andi	r2,r2,255
 8222dfc:	100b883a 	mov	r5,r2
 8222e00:	01020974 	movhi	r4,2085
 8222e04:	213d3b04 	addi	r4,r4,-2836
 8222e08:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
 8222e0c:	e0bfff17 	ldw	r2,-4(fp)
 8222e10:	108002c3 	ldbu	r2,11(r2)
 8222e14:	10803fcc 	andi	r2,r2,255
 8222e18:	100b883a 	mov	r5,r2
 8222e1c:	01020974 	movhi	r4,2085
 8222e20:	213d4504 	addi	r4,r4,-2796
 8222e24:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "\n");
 8222e28:	01020974 	movhi	r4,2085
 8222e2c:	213bab04 	addi	r4,r4,-4436
 8222e30:	821f0c00 	call	821f0c0 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
 8222e34:	e0bffe47 	ldb	r2,-7(fp)
 8222e38:	e0fffe07 	ldb	r3,-8(fp)
 8222e3c:	180d883a 	mov	r6,r3
 8222e40:	100b883a 	mov	r5,r2
 8222e44:	01020974 	movhi	r4,2085
 8222e48:	213d4f04 	addi	r4,r4,-2756
 8222e4c:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
 8222e50:	e0bfff17 	ldw	r2,-4(fp)
 8222e54:	10800303 	ldbu	r2,12(r2)
 8222e58:	10803fcc 	andi	r2,r2,255
 8222e5c:	100b883a 	mov	r5,r2
 8222e60:	01020974 	movhi	r4,2085
 8222e64:	213cf504 	addi	r4,r4,-3116
 8222e68:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
 8222e6c:	e0bfff17 	ldw	r2,-4(fp)
 8222e70:	10800343 	ldbu	r2,13(r2)
 8222e74:	10803fcc 	andi	r2,r2,255
 8222e78:	100b883a 	mov	r5,r2
 8222e7c:	01020974 	movhi	r4,2085
 8222e80:	213cff04 	addi	r4,r4,-3076
 8222e84:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
 8222e88:	e0bfff17 	ldw	r2,-4(fp)
 8222e8c:	10800383 	ldbu	r2,14(r2)
 8222e90:	10803fcc 	andi	r2,r2,255
 8222e94:	100b883a 	mov	r5,r2
 8222e98:	01020974 	movhi	r4,2085
 8222e9c:	213d0904 	addi	r4,r4,-3036
 8222ea0:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
 8222ea4:	e0bfff17 	ldw	r2,-4(fp)
 8222ea8:	108003c3 	ldbu	r2,15(r2)
 8222eac:	10803fcc 	andi	r2,r2,255
 8222eb0:	100b883a 	mov	r5,r2
 8222eb4:	01020974 	movhi	r4,2085
 8222eb8:	213d5c04 	addi	r4,r4,-2704
 8222ebc:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
 8222ec0:	e0bfff17 	ldw	r2,-4(fp)
 8222ec4:	10800403 	ldbu	r2,16(r2)
 8222ec8:	10803fcc 	andi	r2,r2,255
 8222ecc:	100b883a 	mov	r5,r2
 8222ed0:	01020974 	movhi	r4,2085
 8222ed4:	213d6604 	addi	r4,r4,-2664
 8222ed8:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
 8222edc:	e0bfff17 	ldw	r2,-4(fp)
 8222ee0:	10800443 	ldbu	r2,17(r2)
 8222ee4:	10803fcc 	andi	r2,r2,255
 8222ee8:	100b883a 	mov	r5,r2
 8222eec:	01020974 	movhi	r4,2085
 8222ef0:	213d7004 	addi	r4,r4,-2624
 8222ef4:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
 8222ef8:	e0bfff17 	ldw	r2,-4(fp)
 8222efc:	10800483 	ldbu	r2,18(r2)
 8222f00:	10803fcc 	andi	r2,r2,255
 8222f04:	100b883a 	mov	r5,r2
 8222f08:	01020974 	movhi	r4,2085
 8222f0c:	213d7a04 	addi	r4,r4,-2584
 8222f10:	821f0c00 	call	821f0c0 <no_printf>
    tse_dprintf(6, "\n");
 8222f14:	01020974 	movhi	r4,2085
 8222f18:	213bab04 	addi	r4,r4,-4436
 8222f1c:	821f0c00 	call	821f0c0 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 8222f20:	e0bffe83 	ldbu	r2,-6(fp)
 8222f24:	100b883a 	mov	r5,r2
 8222f28:	e13fff17 	ldw	r4,-4(fp)
 8222f2c:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
 8222f30:	e0bffb17 	ldw	r2,-20(fp)
    
}
 8222f34:	e037883a 	mov	sp,fp
 8222f38:	dfc00117 	ldw	ra,4(sp)
 8222f3c:	df000017 	ldw	fp,0(sp)
 8222f40:	dec00204 	addi	sp,sp,8
 8222f44:	f800283a 	ret

08222f48 <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
 8222f48:	defff804 	addi	sp,sp,-32
 8222f4c:	dfc00715 	stw	ra,28(sp)
 8222f50:	df000615 	stw	fp,24(sp)
 8222f54:	df000604 	addi	fp,sp,24
 8222f58:	e13ffe15 	stw	r4,-8(fp)
 8222f5c:	2805883a 	mov	r2,r5
 8222f60:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8222f64:	e0bffe17 	ldw	r2,-8(fp)
 8222f68:	10800617 	ldw	r2,24(r2)
 8222f6c:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8222f70:	e0bffb17 	ldw	r2,-20(fp)
 8222f74:	10800317 	ldw	r2,12(r2)
 8222f78:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8222f7c:	e13ffb17 	ldw	r4,-20(fp)
 8222f80:	82202b80 	call	82202b8 <alt_tse_get_mac_info_index>
 8222f84:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8222f88:	e13ffc17 	ldw	r4,-16(fp)
 8222f8c:	82202440 	call	8220244 <alt_tse_get_mac_group_index>
 8222f90:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 8222f94:	e13ffe17 	ldw	r4,-8(fp)
 8222f98:	82210040 	call	8221004 <alt_tse_phy_rd_mdio_addr>
 8222f9c:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8222fa0:	e0bffe17 	ldw	r2,-8(fp)
 8222fa4:	10800003 	ldbu	r2,0(r2)
 8222fa8:	10803fcc 	andi	r2,r2,255
 8222fac:	100b883a 	mov	r5,r2
 8222fb0:	e13ffe17 	ldw	r4,-8(fp)
 8222fb4:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 8222fb8:	e0bfff03 	ldbu	r2,-4(fp)
 8222fbc:	10002d26 	beq	r2,zero,8223074 <alt_tse_phy_set_adv_1000+0x12c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
 8222fc0:	01c00044 	movi	r7,1
 8222fc4:	01800344 	movi	r6,13
 8222fc8:	014003c4 	movi	r5,15
 8222fcc:	e13ffe17 	ldw	r4,-8(fp)
 8222fd0:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8222fd4:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
 8222fd8:	e0bffdc3 	ldbu	r2,-9(fp)
 8222fdc:	d8800015 	stw	r2,0(sp)
 8222fe0:	01c00044 	movi	r7,1
 8222fe4:	01800244 	movi	r6,9
 8222fe8:	01400244 	movi	r5,9
 8222fec:	e13ffe17 	ldw	r4,-8(fp)
 8222ff0:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8222ff4:	e0bffd47 	ldb	r2,-11(fp)
 8222ff8:	e0fffd07 	ldb	r3,-12(fp)
 8222ffc:	e13ffdc3 	ldbu	r4,-9(fp)
 8223000:	200f883a 	mov	r7,r4
 8223004:	180d883a 	mov	r6,r3
 8223008:	100b883a 	mov	r5,r2
 822300c:	01020974 	movhi	r4,2085
 8223010:	213d8404 	addi	r4,r4,-2544
 8223014:	821f0c00 	call	821f0c0 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 8223018:	01c00044 	movi	r7,1
 822301c:	01800304 	movi	r6,12
 8223020:	014003c4 	movi	r5,15
 8223024:	e13ffe17 	ldw	r4,-8(fp)
 8223028:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 822302c:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
 8223030:	e0bffdc3 	ldbu	r2,-9(fp)
 8223034:	d8800015 	stw	r2,0(sp)
 8223038:	01c00044 	movi	r7,1
 822303c:	01800204 	movi	r6,8
 8223040:	01400244 	movi	r5,9
 8223044:	e13ffe17 	ldw	r4,-8(fp)
 8223048:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 822304c:	e0bffd47 	ldb	r2,-11(fp)
 8223050:	e0fffd07 	ldb	r3,-12(fp)
 8223054:	e13ffdc3 	ldbu	r4,-9(fp)
 8223058:	200f883a 	mov	r7,r4
 822305c:	180d883a 	mov	r6,r3
 8223060:	100b883a 	mov	r5,r2
 8223064:	01020974 	movhi	r4,2085
 8223068:	213d9704 	addi	r4,r4,-2468
 822306c:	821f0c00 	call	821f0c0 <no_printf>
 8223070:	00001c06 	br	82230e4 <alt_tse_phy_set_adv_1000+0x19c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
 8223074:	d8000015 	stw	zero,0(sp)
 8223078:	01c00044 	movi	r7,1
 822307c:	01800244 	movi	r6,9
 8223080:	01400244 	movi	r5,9
 8223084:	e13ffe17 	ldw	r4,-8(fp)
 8223088:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 822308c:	e0bffd47 	ldb	r2,-11(fp)
 8223090:	e0fffd07 	ldb	r3,-12(fp)
 8223094:	000f883a 	mov	r7,zero
 8223098:	180d883a 	mov	r6,r3
 822309c:	100b883a 	mov	r5,r2
 82230a0:	01020974 	movhi	r4,2085
 82230a4:	213d8404 	addi	r4,r4,-2544
 82230a8:	821f0c00 	call	821f0c0 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
 82230ac:	d8000015 	stw	zero,0(sp)
 82230b0:	01c00044 	movi	r7,1
 82230b4:	01800204 	movi	r6,8
 82230b8:	01400244 	movi	r5,9
 82230bc:	e13ffe17 	ldw	r4,-8(fp)
 82230c0:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 82230c4:	e0bffd47 	ldb	r2,-11(fp)
 82230c8:	e0fffd07 	ldb	r3,-12(fp)
 82230cc:	000f883a 	mov	r7,zero
 82230d0:	180d883a 	mov	r6,r3
 82230d4:	100b883a 	mov	r5,r2
 82230d8:	01020974 	movhi	r4,2085
 82230dc:	213daa04 	addi	r4,r4,-2392
 82230e0:	821f0c00 	call	821f0c0 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
 82230e4:	e0bffd83 	ldbu	r2,-10(fp)
 82230e8:	100b883a 	mov	r5,r2
 82230ec:	e13ffe17 	ldw	r4,-8(fp)
 82230f0:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
 82230f4:	0005883a 	mov	r2,zero
}
 82230f8:	e037883a 	mov	sp,fp
 82230fc:	dfc00117 	ldw	ra,4(sp)
 8223100:	df000017 	ldw	fp,0(sp)
 8223104:	dec00204 	addi	sp,sp,8
 8223108:	f800283a 	ret

0822310c <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
 822310c:	defff804 	addi	sp,sp,-32
 8223110:	dfc00715 	stw	ra,28(sp)
 8223114:	df000615 	stw	fp,24(sp)
 8223118:	df000604 	addi	fp,sp,24
 822311c:	e13ffe15 	stw	r4,-8(fp)
 8223120:	2805883a 	mov	r2,r5
 8223124:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 8223128:	e0bffe17 	ldw	r2,-8(fp)
 822312c:	10800617 	ldw	r2,24(r2)
 8223130:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8223134:	e0bffb17 	ldw	r2,-20(fp)
 8223138:	10800317 	ldw	r2,12(r2)
 822313c:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8223140:	e13ffb17 	ldw	r4,-20(fp)
 8223144:	82202b80 	call	82202b8 <alt_tse_get_mac_info_index>
 8223148:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 822314c:	e13ffc17 	ldw	r4,-16(fp)
 8223150:	82202440 	call	8220244 <alt_tse_get_mac_group_index>
 8223154:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 8223158:	e13ffe17 	ldw	r4,-8(fp)
 822315c:	82210040 	call	8221004 <alt_tse_phy_rd_mdio_addr>
 8223160:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8223164:	e0bffe17 	ldw	r2,-8(fp)
 8223168:	10800003 	ldbu	r2,0(r2)
 822316c:	10803fcc 	andi	r2,r2,255
 8223170:	100b883a 	mov	r5,r2
 8223174:	e13ffe17 	ldw	r4,-8(fp)
 8223178:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 822317c:	e0bfff03 	ldbu	r2,-4(fp)
 8223180:	10004326 	beq	r2,zero,8223290 <alt_tse_phy_set_adv_100+0x184>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 8223184:	01c00044 	movi	r7,1
 8223188:	018003c4 	movi	r6,15
 822318c:	01400044 	movi	r5,1
 8223190:	e13ffe17 	ldw	r4,-8(fp)
 8223194:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8223198:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
 822319c:	e0bffdc3 	ldbu	r2,-9(fp)
 82231a0:	d8800015 	stw	r2,0(sp)
 82231a4:	01c00044 	movi	r7,1
 82231a8:	01800244 	movi	r6,9
 82231ac:	01400104 	movi	r5,4
 82231b0:	e13ffe17 	ldw	r4,-8(fp)
 82231b4:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
 82231b8:	e0bffd47 	ldb	r2,-11(fp)
 82231bc:	e0fffd07 	ldb	r3,-12(fp)
 82231c0:	e13ffdc3 	ldbu	r4,-9(fp)
 82231c4:	200f883a 	mov	r7,r4
 82231c8:	180d883a 	mov	r6,r3
 82231cc:	100b883a 	mov	r5,r2
 82231d0:	01020974 	movhi	r4,2085
 82231d4:	213dbc04 	addi	r4,r4,-2320
 82231d8:	821f0c00 	call	821f0c0 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 82231dc:	01c00044 	movi	r7,1
 82231e0:	01800384 	movi	r6,14
 82231e4:	01400044 	movi	r5,1
 82231e8:	e13ffe17 	ldw	r4,-8(fp)
 82231ec:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 82231f0:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
 82231f4:	e0bffdc3 	ldbu	r2,-9(fp)
 82231f8:	d8800015 	stw	r2,0(sp)
 82231fc:	01c00044 	movi	r7,1
 8223200:	01800204 	movi	r6,8
 8223204:	01400104 	movi	r5,4
 8223208:	e13ffe17 	ldw	r4,-8(fp)
 822320c:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8223210:	e0bffd47 	ldb	r2,-11(fp)
 8223214:	e0fffd07 	ldb	r3,-12(fp)
 8223218:	e13ffdc3 	ldbu	r4,-9(fp)
 822321c:	200f883a 	mov	r7,r4
 8223220:	180d883a 	mov	r6,r3
 8223224:	100b883a 	mov	r5,r2
 8223228:	01020974 	movhi	r4,2085
 822322c:	213dcc04 	addi	r4,r4,-2256
 8223230:	821f0c00 	call	821f0c0 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 8223234:	01c00044 	movi	r7,1
 8223238:	01800344 	movi	r6,13
 822323c:	01400044 	movi	r5,1
 8223240:	e13ffe17 	ldw	r4,-8(fp)
 8223244:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8223248:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
 822324c:	e0bffdc3 	ldbu	r2,-9(fp)
 8223250:	d8800015 	stw	r2,0(sp)
 8223254:	01c00044 	movi	r7,1
 8223258:	018001c4 	movi	r6,7
 822325c:	01400104 	movi	r5,4
 8223260:	e13ffe17 	ldw	r4,-8(fp)
 8223264:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 8223268:	e0bffd47 	ldb	r2,-11(fp)
 822326c:	e0fffd07 	ldb	r3,-12(fp)
 8223270:	e13ffdc3 	ldbu	r4,-9(fp)
 8223274:	200f883a 	mov	r7,r4
 8223278:	180d883a 	mov	r6,r3
 822327c:	100b883a 	mov	r5,r2
 8223280:	01020974 	movhi	r4,2085
 8223284:	213ddf04 	addi	r4,r4,-2180
 8223288:	821f0c00 	call	821f0c0 <no_printf>
 822328c:	00002a06 	br	8223338 <alt_tse_phy_set_adv_100+0x22c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
 8223290:	d8000015 	stw	zero,0(sp)
 8223294:	01c00044 	movi	r7,1
 8223298:	01800244 	movi	r6,9
 822329c:	01400104 	movi	r5,4
 82232a0:	e13ffe17 	ldw	r4,-8(fp)
 82232a4:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
 82232a8:	e0bffd47 	ldb	r2,-11(fp)
 82232ac:	e0fffd07 	ldb	r3,-12(fp)
 82232b0:	000f883a 	mov	r7,zero
 82232b4:	180d883a 	mov	r6,r3
 82232b8:	100b883a 	mov	r5,r2
 82232bc:	01020974 	movhi	r4,2085
 82232c0:	213dbc04 	addi	r4,r4,-2320
 82232c4:	821f0c00 	call	821f0c0 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
 82232c8:	d8000015 	stw	zero,0(sp)
 82232cc:	01c00044 	movi	r7,1
 82232d0:	01800204 	movi	r6,8
 82232d4:	01400104 	movi	r5,4
 82232d8:	e13ffe17 	ldw	r4,-8(fp)
 82232dc:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 82232e0:	e0bffd47 	ldb	r2,-11(fp)
 82232e4:	e0fffd07 	ldb	r3,-12(fp)
 82232e8:	000f883a 	mov	r7,zero
 82232ec:	180d883a 	mov	r6,r3
 82232f0:	100b883a 	mov	r5,r2
 82232f4:	01020974 	movhi	r4,2085
 82232f8:	213dcc04 	addi	r4,r4,-2256
 82232fc:	821f0c00 	call	821f0c0 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
 8223300:	d8000015 	stw	zero,0(sp)
 8223304:	01c00044 	movi	r7,1
 8223308:	018001c4 	movi	r6,7
 822330c:	01400104 	movi	r5,4
 8223310:	e13ffe17 	ldw	r4,-8(fp)
 8223314:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 8223318:	e0bffd47 	ldb	r2,-11(fp)
 822331c:	e0fffd07 	ldb	r3,-12(fp)
 8223320:	000f883a 	mov	r7,zero
 8223324:	180d883a 	mov	r6,r3
 8223328:	100b883a 	mov	r5,r2
 822332c:	01020974 	movhi	r4,2085
 8223330:	213ddf04 	addi	r4,r4,-2180
 8223334:	821f0c00 	call	821f0c0 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
 8223338:	e0bffd83 	ldbu	r2,-10(fp)
 822333c:	100b883a 	mov	r5,r2
 8223340:	e13ffe17 	ldw	r4,-8(fp)
 8223344:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 8223348:	0005883a 	mov	r2,zero
}
 822334c:	e037883a 	mov	sp,fp
 8223350:	dfc00117 	ldw	ra,4(sp)
 8223354:	df000017 	ldw	fp,0(sp)
 8223358:	dec00204 	addi	sp,sp,8
 822335c:	f800283a 	ret

08223360 <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
 8223360:	defff504 	addi	sp,sp,-44
 8223364:	dfc00a15 	stw	ra,40(sp)
 8223368:	df000915 	stw	fp,36(sp)
 822336c:	df000904 	addi	fp,sp,36
 8223370:	e13ffe15 	stw	r4,-8(fp)
 8223374:	2805883a 	mov	r2,r5
 8223378:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 822337c:	e0bffe17 	ldw	r2,-8(fp)
 8223380:	10800617 	ldw	r2,24(r2)
 8223384:	e0bff815 	stw	r2,-32(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 8223388:	e0bff817 	ldw	r2,-32(fp)
 822338c:	10800317 	ldw	r2,12(r2)
 8223390:	e0bff915 	stw	r2,-28(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 8223394:	e13ff817 	ldw	r4,-32(fp)
 8223398:	82202b80 	call	82202b8 <alt_tse_get_mac_info_index>
 822339c:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 82233a0:	e13ff917 	ldw	r4,-28(fp)
 82233a4:	82202440 	call	8220244 <alt_tse_get_mac_group_index>
 82233a8:	e0bffb15 	stw	r2,-20(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 82233ac:	e13ffe17 	ldw	r4,-8(fp)
 82233b0:	82210040 	call	8221004 <alt_tse_phy_rd_mdio_addr>
 82233b4:	e0bffc15 	stw	r2,-16(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 82233b8:	e0bffe17 	ldw	r2,-8(fp)
 82233bc:	10800003 	ldbu	r2,0(r2)
 82233c0:	10803fcc 	andi	r2,r2,255
 82233c4:	100b883a 	mov	r5,r2
 82233c8:	e13ffe17 	ldw	r4,-8(fp)
 82233cc:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 82233d0:	e0bfff03 	ldbu	r2,-4(fp)
 82233d4:	10002926 	beq	r2,zero,822347c <alt_tse_phy_set_adv_10+0x11c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 82233d8:	01c00044 	movi	r7,1
 82233dc:	01800304 	movi	r6,12
 82233e0:	01400044 	movi	r5,1
 82233e4:	e13ffe17 	ldw	r4,-8(fp)
 82233e8:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 82233ec:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
 82233f0:	e0bffd03 	ldbu	r2,-12(fp)
 82233f4:	d8800015 	stw	r2,0(sp)
 82233f8:	01c00044 	movi	r7,1
 82233fc:	01800184 	movi	r6,6
 8223400:	01400104 	movi	r5,4
 8223404:	e13ffe17 	ldw	r4,-8(fp)
 8223408:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 822340c:	e0bffd03 	ldbu	r2,-12(fp)
 8223410:	100f883a 	mov	r7,r2
 8223414:	e1bffa17 	ldw	r6,-24(fp)
 8223418:	e17ffb17 	ldw	r5,-20(fp)
 822341c:	01020974 	movhi	r4,2085
 8223420:	213df204 	addi	r4,r4,-2104
 8223424:	821f0c00 	call	821f0c0 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 8223428:	01c00044 	movi	r7,1
 822342c:	018002c4 	movi	r6,11
 8223430:	01400044 	movi	r5,1
 8223434:	e13ffe17 	ldw	r4,-8(fp)
 8223438:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 822343c:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
 8223440:	e0bffd03 	ldbu	r2,-12(fp)
 8223444:	d8800015 	stw	r2,0(sp)
 8223448:	01c00044 	movi	r7,1
 822344c:	01800144 	movi	r6,5
 8223450:	01400104 	movi	r5,4
 8223454:	e13ffe17 	ldw	r4,-8(fp)
 8223458:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 822345c:	e0bffd03 	ldbu	r2,-12(fp)
 8223460:	100f883a 	mov	r7,r2
 8223464:	e1bffa17 	ldw	r6,-24(fp)
 8223468:	e17ffb17 	ldw	r5,-20(fp)
 822346c:	01020974 	movhi	r4,2085
 8223470:	213e0504 	addi	r4,r4,-2028
 8223474:	821f0c00 	call	821f0c0 <no_printf>
 8223478:	00001806 	br	82234dc <alt_tse_phy_set_adv_10+0x17c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
 822347c:	d8000015 	stw	zero,0(sp)
 8223480:	01c00044 	movi	r7,1
 8223484:	01800184 	movi	r6,6
 8223488:	01400104 	movi	r5,4
 822348c:	e13ffe17 	ldw	r4,-8(fp)
 8223490:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 8223494:	000f883a 	mov	r7,zero
 8223498:	e1bffa17 	ldw	r6,-24(fp)
 822349c:	e17ffb17 	ldw	r5,-20(fp)
 82234a0:	01020974 	movhi	r4,2085
 82234a4:	213df204 	addi	r4,r4,-2104
 82234a8:	821f0c00 	call	821f0c0 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
 82234ac:	d8000015 	stw	zero,0(sp)
 82234b0:	01c00044 	movi	r7,1
 82234b4:	01800144 	movi	r6,5
 82234b8:	01400104 	movi	r5,4
 82234bc:	e13ffe17 	ldw	r4,-8(fp)
 82234c0:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 82234c4:	000f883a 	mov	r7,zero
 82234c8:	e1bffa17 	ldw	r6,-24(fp)
 82234cc:	e17ffb17 	ldw	r5,-20(fp)
 82234d0:	01020974 	movhi	r4,2085
 82234d4:	213e0504 	addi	r4,r4,-2028
 82234d8:	821f0c00 	call	821f0c0 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 82234dc:	e0bffc17 	ldw	r2,-16(fp)
 82234e0:	10803fcc 	andi	r2,r2,255
 82234e4:	100b883a 	mov	r5,r2
 82234e8:	e13ffe17 	ldw	r4,-8(fp)
 82234ec:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 82234f0:	0005883a 	mov	r2,zero
}
 82234f4:	e037883a 	mov	sp,fp
 82234f8:	dfc00117 	ldw	ra,4(sp)
 82234fc:	df000017 	ldw	fp,0(sp)
 8223500:	dec00204 	addi	sp,sp,8
 8223504:	f800283a 	ret

08223508 <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
 8223508:	defff604 	addi	sp,sp,-40
 822350c:	dfc00915 	stw	ra,36(sp)
 8223510:	df000815 	stw	fp,32(sp)
 8223514:	df000804 	addi	fp,sp,32
 8223518:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
 822351c:	00800044 	movi	r2,1
 8223520:	e0bff905 	stb	r2,-28(fp)
	alt_u8 common_100 = 1;
 8223524:	00800044 	movi	r2,1
 8223528:	e0bff945 	stb	r2,-27(fp)
	alt_u8 common_10 = 1;
 822352c:	00800044 	movi	r2,1
 8223530:	e0bff985 	stb	r2,-26(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
 8223534:	00800044 	movi	r2,1
 8223538:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
 822353c:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_phy_info *pphy = 0;
 8223540:	e03ffd15 	stw	zero,-12(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8223544:	e13fff17 	ldw	r4,-4(fp)
 8223548:	82202440 	call	8220244 <alt_tse_get_mac_group_index>
 822354c:	e0bffe05 	stb	r2,-8(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 8223550:	e03ff815 	stw	zero,-32(fp)
 8223554:	00001c06 	br	82235c8 <alt_tse_phy_get_common_speed+0xc0>
        pmac_info = pmac_group->pmac_info[i];
 8223558:	e0ffff17 	ldw	r3,-4(fp)
 822355c:	e0bff817 	ldw	r2,-32(fp)
 8223560:	10800044 	addi	r2,r2,1
 8223564:	1085883a 	add	r2,r2,r2
 8223568:	1085883a 	add	r2,r2,r2
 822356c:	1885883a 	add	r2,r3,r2
 8223570:	10800017 	ldw	r2,0(r2)
 8223574:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 8223578:	e0bffc17 	ldw	r2,-16(fp)
 822357c:	10800117 	ldw	r2,4(r2)
 8223580:	e0bffd15 	stw	r2,-12(fp)
        
        /* run only if PHY connected */
        if(pphy) {
 8223584:	e0bffd17 	ldw	r2,-12(fp)
 8223588:	10000926 	beq	r2,zero,82235b0 <alt_tse_phy_get_common_speed+0xa8>
            alt_tse_phy_set_adv_1000(pphy, 1);
 822358c:	01400044 	movi	r5,1
 8223590:	e13ffd17 	ldw	r4,-12(fp)
 8223594:	8222f480 	call	8222f48 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 8223598:	01400044 	movi	r5,1
 822359c:	e13ffd17 	ldw	r4,-12(fp)
 82235a0:	822310c0 	call	822310c <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 82235a4:	01400044 	movi	r5,1
 82235a8:	e13ffd17 	ldw	r4,-12(fp)
 82235ac:	82233600 	call	8223360 <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
 82235b0:	01020974 	movhi	r4,2085
 82235b4:	213bab04 	addi	r4,r4,-4436
 82235b8:	821f0c00 	call	821f0c0 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 82235bc:	e0bff817 	ldw	r2,-32(fp)
 82235c0:	10800044 	addi	r2,r2,1
 82235c4:	e0bff815 	stw	r2,-32(fp)
 82235c8:	e0bfff17 	ldw	r2,-4(fp)
 82235cc:	10800003 	ldbu	r2,0(r2)
 82235d0:	10803fcc 	andi	r2,r2,255
 82235d4:	e0fff817 	ldw	r3,-32(fp)
 82235d8:	18bfdf16 	blt	r3,r2,8223558 <alt_tse_phy_get_common_speed+0x50>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 82235dc:	e03ff815 	stw	zero,-32(fp)
 82235e0:	00005606 	br	822373c <alt_tse_phy_get_common_speed+0x234>

        pmac_info = pmac_group->pmac_info[i];
 82235e4:	e0ffff17 	ldw	r3,-4(fp)
 82235e8:	e0bff817 	ldw	r2,-32(fp)
 82235ec:	10800044 	addi	r2,r2,1
 82235f0:	1085883a 	add	r2,r2,r2
 82235f4:	1085883a 	add	r2,r2,r2
 82235f8:	1885883a 	add	r2,r3,r2
 82235fc:	10800017 	ldw	r2,0(r2)
 8223600:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 8223604:	e0bffc17 	ldw	r2,-16(fp)
 8223608:	10800117 	ldw	r2,4(r2)
 822360c:	e0bffd15 	stw	r2,-12(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 8223610:	e0bffd17 	ldw	r2,-12(fp)
 8223614:	10004326 	beq	r2,zero,8223724 <alt_tse_phy_get_common_speed+0x21c>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
 8223618:	e13ffd17 	ldw	r4,-12(fp)
 822361c:	82229b00 	call	82229b0 <alt_tse_phy_get_cap>
 8223620:	1000421e 	bne	r2,zero,822372c <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
 8223624:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 8223628:	e0bffc17 	ldw	r2,-16(fp)
 822362c:	10800003 	ldbu	r2,0(r2)
 8223630:	10803fcc 	andi	r2,r2,255
 8223634:	10800058 	cmpnei	r2,r2,1
 8223638:	1000021e 	bne	r2,zero,8223644 <alt_tse_phy_get_common_speed+0x13c>
            common_1000 = 0;
 822363c:	e03ff905 	stb	zero,-28(fp)
 8223640:	00000706 	br	8223660 <alt_tse_phy_get_common_speed+0x158>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 8223644:	e0bffc17 	ldw	r2,-16(fp)
 8223648:	10800003 	ldbu	r2,0(r2)
 822364c:	10803fcc 	andi	r2,r2,255
 8223650:	10800098 	cmpnei	r2,r2,2
 8223654:	1000021e 	bne	r2,zero,8223660 <alt_tse_phy_get_common_speed+0x158>
            common_100 = 0;
 8223658:	e03ff945 	stb	zero,-27(fp)
            common_10 = 0;            
 822365c:	e03ff985 	stb	zero,-26(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
 8223660:	e0bffd17 	ldw	r2,-12(fp)
 8223664:	10c000c3 	ldbu	r3,3(r2)
 8223668:	e0bffd17 	ldw	r2,-12(fp)
 822366c:	10800303 	ldbu	r2,12(r2)
 8223670:	1884703a 	and	r2,r3,r2
 8223674:	1007883a 	mov	r3,r2
 8223678:	e0bff903 	ldbu	r2,-28(fp)
 822367c:	1884703a 	and	r2,r3,r2
 8223680:	e0bff905 	stb	r2,-28(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 8223684:	e0bffd17 	ldw	r2,-12(fp)
 8223688:	10c00183 	ldbu	r3,6(r2)
 822368c:	e0bffd17 	ldw	r2,-12(fp)
 8223690:	108003c3 	ldbu	r2,15(r2)
 8223694:	1884703a 	and	r2,r3,r2
 8223698:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
 822369c:	e0bffd17 	ldw	r2,-12(fp)
 82236a0:	10c001c3 	ldbu	r3,7(r2)
 82236a4:	e0bffd17 	ldw	r2,-12(fp)
 82236a8:	10800403 	ldbu	r2,16(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 82236ac:	1884703a 	and	r2,r3,r2
 82236b0:	2084b03a 	or	r2,r4,r2
 82236b4:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
 82236b8:	e0bffd17 	ldw	r2,-12(fp)
 82236bc:	10c00143 	ldbu	r3,5(r2)
 82236c0:	e0bffd17 	ldw	r2,-12(fp)
 82236c4:	10800383 	ldbu	r2,14(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 82236c8:	1884703a 	and	r2,r3,r2
 82236cc:	2084b03a 	or	r2,r4,r2
 82236d0:	1007883a 	mov	r3,r2
 82236d4:	e0bff943 	ldbu	r2,-27(fp)
 82236d8:	1884703a 	and	r2,r3,r2
 82236dc:	e0bff945 	stb	r2,-27(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 82236e0:	e0bffd17 	ldw	r2,-12(fp)
 82236e4:	10c00283 	ldbu	r3,10(r2)
 82236e8:	e0bffd17 	ldw	r2,-12(fp)
 82236ec:	10800443 	ldbu	r2,17(r2)
 82236f0:	1884703a 	and	r2,r3,r2
 82236f4:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));
 82236f8:	e0bffd17 	ldw	r2,-12(fp)
 82236fc:	10c002c3 	ldbu	r3,11(r2)
 8223700:	e0bffd17 	ldw	r2,-12(fp)
 8223704:	10800483 	ldbu	r2,18(r2)
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 8223708:	1884703a 	and	r2,r3,r2
 822370c:	2084b03a 	or	r2,r4,r2
 8223710:	1007883a 	mov	r3,r2
 8223714:	e0bff983 	ldbu	r2,-26(fp)
 8223718:	1884703a 	and	r2,r3,r2
 822371c:	e0bff985 	stb	r2,-26(fp)
 8223720:	00000306 	br	8223730 <alt_tse_phy_get_common_speed+0x228>
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 8223724:	0001883a 	nop
 8223728:	00000106 	br	8223730 <alt_tse_phy_get_common_speed+0x228>
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
            continue;
 822372c:	0001883a 	nop
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 8223730:	e0bff817 	ldw	r2,-32(fp)
 8223734:	10800044 	addi	r2,r2,1
 8223738:	e0bff815 	stw	r2,-32(fp)
 822373c:	e0bfff17 	ldw	r2,-4(fp)
 8223740:	10800003 	ldbu	r2,0(r2)
 8223744:	10803fcc 	andi	r2,r2,255
 8223748:	e0fff817 	ldw	r3,-32(fp)
 822374c:	18bfa516 	blt	r3,r2,82235e4 <alt_tse_phy_get_common_speed+0xdc>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
 8223750:	e0bffb03 	ldbu	r2,-20(fp)
 8223754:	10800058 	cmpnei	r2,r2,1
 8223758:	1000081e 	bne	r2,zero,822377c <alt_tse_phy_get_common_speed+0x274>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 822375c:	00bfffc4 	movi	r2,-1
 8223760:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
 8223764:	e0bffe07 	ldb	r2,-8(fp)
 8223768:	100b883a 	mov	r5,r2
 822376c:	01020974 	movhi	r4,2085
 8223770:	213e1804 	addi	r4,r4,-1952
 8223774:	820331c0 	call	820331c <printf>
 8223778:	00002706 	br	8223818 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_1000) {
 822377c:	e0bff903 	ldbu	r2,-28(fp)
 8223780:	10000926 	beq	r2,zero,82237a8 <alt_tse_phy_get_common_speed+0x2a0>
        common_speed = TSE_PHY_SPEED_1000;
 8223784:	00800084 	movi	r2,2
 8223788:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
 822378c:	e0bffe07 	ldb	r2,-8(fp)
 8223790:	0180fa04 	movi	r6,1000
 8223794:	100b883a 	mov	r5,r2
 8223798:	01020974 	movhi	r4,2085
 822379c:	213e2a04 	addi	r4,r4,-1880
 82237a0:	820331c0 	call	820331c <printf>
 82237a4:	00001c06 	br	8223818 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_100) {
 82237a8:	e0bff943 	ldbu	r2,-27(fp)
 82237ac:	10000926 	beq	r2,zero,82237d4 <alt_tse_phy_get_common_speed+0x2cc>
        common_speed = TSE_PHY_SPEED_100;
 82237b0:	00800044 	movi	r2,1
 82237b4:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
 82237b8:	e0bffe07 	ldb	r2,-8(fp)
 82237bc:	01801904 	movi	r6,100
 82237c0:	100b883a 	mov	r5,r2
 82237c4:	01020974 	movhi	r4,2085
 82237c8:	213e2a04 	addi	r4,r4,-1880
 82237cc:	820331c0 	call	820331c <printf>
 82237d0:	00001106 	br	8223818 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_10) {
 82237d4:	e0bff983 	ldbu	r2,-26(fp)
 82237d8:	10000826 	beq	r2,zero,82237fc <alt_tse_phy_get_common_speed+0x2f4>
        common_speed = TSE_PHY_SPEED_10;
 82237dc:	e03ffa15 	stw	zero,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
 82237e0:	e0bffe07 	ldb	r2,-8(fp)
 82237e4:	01800284 	movi	r6,10
 82237e8:	100b883a 	mov	r5,r2
 82237ec:	01020974 	movhi	r4,2085
 82237f0:	213e2a04 	addi	r4,r4,-1880
 82237f4:	820331c0 	call	820331c <printf>
 82237f8:	00000706 	br	8223818 <alt_tse_phy_get_common_speed+0x310>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 82237fc:	00bfffc4 	movi	r2,-1
 8223800:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
 8223804:	e0bffe07 	ldb	r2,-8(fp)
 8223808:	100b883a 	mov	r5,r2
 822380c:	01020974 	movhi	r4,2085
 8223810:	213e3704 	addi	r4,r4,-1828
 8223814:	820331c0 	call	820331c <printf>

    return common_speed;
 8223818:	e0bffa17 	ldw	r2,-24(fp)
}
 822381c:	e037883a 	mov	sp,fp
 8223820:	dfc00117 	ldw	ra,4(sp)
 8223824:	df000017 	ldw	fp,0(sp)
 8223828:	dec00204 	addi	sp,sp,8
 822382c:	f800283a 	ret

08223830 <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
 8223830:	defff004 	addi	sp,sp,-64
 8223834:	dfc00f15 	stw	ra,60(sp)
 8223838:	df000e15 	stw	fp,56(sp)
 822383c:	dc400d15 	stw	r17,52(sp)
 8223840:	dc000c15 	stw	r16,48(sp)
 8223844:	df000e04 	addi	fp,sp,56
 8223848:	e13ffc15 	stw	r4,-16(fp)
 822384c:	e17ffd15 	stw	r5,-12(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
 8223850:	e03ff515 	stw	zero,-44(fp)
    alt_tse_mac_info *pmac_info = 0;
 8223854:	e03ff615 	stw	zero,-40(fp)
    alt_tse_system_info *psys = 0;
 8223858:	e03ff715 	stw	zero,-36(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 822385c:	e03ff805 	stb	zero,-32(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 8223860:	e13ffc17 	ldw	r4,-16(fp)
 8223864:	82202440 	call	8220244 <alt_tse_get_mac_group_index>
 8223868:	e0bff845 	stb	r2,-31(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 822386c:	e0bffc17 	ldw	r2,-16(fp)
 8223870:	10800117 	ldw	r2,4(r2)
 8223874:	10800217 	ldw	r2,8(r2)
 8223878:	10800017 	ldw	r2,0(r2)
 822387c:	e0bff915 	stw	r2,-28(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 8223880:	e0bff917 	ldw	r2,-28(fp)
 8223884:	10801004 	addi	r2,r2,64
 8223888:	10800037 	ldwio	r2,0(r2)
 822388c:	e0bffa15 	stw	r2,-24(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
 8223890:	e0bffd17 	ldw	r2,-12(fp)
 8223894:	10000316 	blt	r2,zero,82238a4 <alt_tse_phy_set_common_speed+0x74>
 8223898:	e0bffd17 	ldw	r2,-12(fp)
 822389c:	108000d0 	cmplti	r2,r2,3
 82238a0:	10000c1e 	bne	r2,zero,82238d4 <alt_tse_phy_set_common_speed+0xa4>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
 82238a4:	e0bff847 	ldb	r2,-31(fp)
 82238a8:	e1bffd17 	ldw	r6,-12(fp)
 82238ac:	100b883a 	mov	r5,r2
 82238b0:	01020974 	movhi	r4,2085
 82238b4:	213e4404 	addi	r4,r4,-1776
 82238b8:	820331c0 	call	820331c <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 82238bc:	e0bff917 	ldw	r2,-28(fp)
 82238c0:	10801004 	addi	r2,r2,64
 82238c4:	e0fffa17 	ldw	r3,-24(fp)
 82238c8:	10c00035 	stwio	r3,0(r2)
        return TSE_PHY_SPEED_NO_COMMON;
 82238cc:	00bfffc4 	movi	r2,-1
 82238d0:	0000fe06 	br	8223ccc <alt_tse_phy_set_common_speed+0x49c>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 82238d4:	e03ff315 	stw	zero,-52(fp)
 82238d8:	0000dc06 	br	8223c4c <alt_tse_phy_set_common_speed+0x41c>
        pmac_info = pmac_group->pmac_info[i];
 82238dc:	e0fffc17 	ldw	r3,-16(fp)
 82238e0:	e0bff317 	ldw	r2,-52(fp)
 82238e4:	10800044 	addi	r2,r2,1
 82238e8:	1085883a 	add	r2,r2,r2
 82238ec:	1085883a 	add	r2,r2,r2
 82238f0:	1885883a 	add	r2,r3,r2
 82238f4:	10800017 	ldw	r2,0(r2)
 82238f8:	e0bff615 	stw	r2,-40(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 82238fc:	e13ff617 	ldw	r4,-40(fp)
 8223900:	82202b80 	call	82202b8 <alt_tse_get_mac_info_index>
 8223904:	e0bff805 	stb	r2,-32(fp)

        pphy = pmac_info->pphy_info;
 8223908:	e0bff617 	ldw	r2,-40(fp)
 822390c:	10800117 	ldw	r2,4(r2)
 8223910:	e0bff515 	stw	r2,-44(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 8223914:	e0bff517 	ldw	r2,-44(fp)
 8223918:	1000c826 	beq	r2,zero,8223c3c <alt_tse_phy_set_common_speed+0x40c>
            continue;
        }
        
        psys = pmac_info->psys_info; 
 822391c:	e0bff617 	ldw	r2,-40(fp)
 8223920:	10800217 	ldw	r2,8(r2)
 8223924:	e0bff715 	stw	r2,-36(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 8223928:	e0bff517 	ldw	r2,-44(fp)
 822392c:	10800003 	ldbu	r2,0(r2)
 8223930:	10803fcc 	andi	r2,r2,255
 8223934:	100b883a 	mov	r5,r2
 8223938:	e13ff517 	ldw	r4,-44(fp)
 822393c:	822104c0 	call	822104c <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223940:	e0bff517 	ldw	r2,-44(fp)
 8223944:	108000c3 	ldbu	r2,3(r2)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 8223948:	10803fcc 	andi	r2,r2,255
 822394c:	10000c1e 	bne	r2,zero,8223980 <alt_tse_phy_set_common_speed+0x150>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223950:	e0bff517 	ldw	r2,-44(fp)
 8223954:	10800103 	ldbu	r2,4(r2)
 8223958:	10803fcc 	andi	r2,r2,255
 822395c:	1000081e 	bne	r2,zero,8223980 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 8223960:	e0bff517 	ldw	r2,-44(fp)
 8223964:	10800043 	ldbu	r2,1(r2)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 8223968:	10803fcc 	andi	r2,r2,255
 822396c:	1000041e 	bne	r2,zero,8223980 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 8223970:	e0bff517 	ldw	r2,-44(fp)
 8223974:	10800083 	ldbu	r2,2(r2)
 8223978:	10803fcc 	andi	r2,r2,255
 822397c:	10000226 	beq	r2,zero,8223988 <alt_tse_phy_set_common_speed+0x158>
 8223980:	00800044 	movi	r2,1
 8223984:	00000106 	br	822398c <alt_tse_phy_set_common_speed+0x15c>
 8223988:	0005883a 	mov	r2,zero
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 822398c:	e0bffb05 	stb	r2,-20(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
 8223990:	e0bffb03 	ldbu	r2,-20(fp)
 8223994:	1000101e 	bne	r2,zero,82239d8 <alt_tse_phy_set_common_speed+0x1a8>
 8223998:	e0bffd17 	ldw	r2,-12(fp)
 822399c:	10800098 	cmpnei	r2,r2,2
 82239a0:	10000d1e 	bne	r2,zero,82239d8 <alt_tse_phy_set_common_speed+0x1a8>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
 82239a4:	e0bff847 	ldb	r2,-31(fp)
 82239a8:	e0fff807 	ldb	r3,-32(fp)
 82239ac:	180d883a 	mov	r6,r3
 82239b0:	100b883a 	mov	r5,r2
 82239b4:	01020974 	movhi	r4,2085
 82239b8:	213e5804 	addi	r4,r4,-1696
 82239bc:	820331c0 	call	820331c <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 82239c0:	e0bff917 	ldw	r2,-28(fp)
 82239c4:	10801004 	addi	r2,r2,64
 82239c8:	e0fffa17 	ldw	r3,-24(fp)
 82239cc:	10c00035 	stwio	r3,0(r2)
            return TSE_PHY_SPEED_NO_COMMON;
 82239d0:	00bfffc4 	movi	r2,-1
 82239d4:	0000bd06 	br	8223ccc <alt_tse_phy_set_common_speed+0x49c>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 82239d8:	01c00044 	movi	r7,1
 82239dc:	018000c4 	movi	r6,3
 82239e0:	01400044 	movi	r5,1
 82239e4:	e13ff517 	ldw	r4,-44(fp)
 82239e8:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 82239ec:	1000141e 	bne	r2,zero,8223a40 <alt_tse_phy_set_common_speed+0x210>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
 82239f0:	e0bffb03 	ldbu	r2,-20(fp)
 82239f4:	10000926 	beq	r2,zero,8223a1c <alt_tse_phy_set_common_speed+0x1ec>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
 82239f8:	e0bffd17 	ldw	r2,-12(fp)
 82239fc:	1005d07a 	srai	r2,r2,1
 8223a00:	10bfffcc 	andi	r2,r2,65535
 8223a04:	d8800015 	stw	r2,0(sp)
 8223a08:	01c00044 	movi	r7,1
 8223a0c:	01800184 	movi	r6,6
 8223a10:	000b883a 	mov	r5,zero
 8223a14:	e13ff517 	ldw	r4,-44(fp)
 8223a18:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
 8223a1c:	e0bffd17 	ldw	r2,-12(fp)
 8223a20:	10bfffcc 	andi	r2,r2,65535
 8223a24:	d8800015 	stw	r2,0(sp)
 8223a28:	01c00044 	movi	r7,1
 8223a2c:	01800344 	movi	r6,13
 8223a30:	000b883a 	mov	r5,zero
 8223a34:	e13ff517 	ldw	r4,-44(fp)
 8223a38:	82210a40 	call	82210a4 <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
 8223a3c:	00008006 	br	8223c40 <alt_tse_phy_set_common_speed+0x410>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
 8223a40:	e0bffd17 	ldw	r2,-12(fp)
 8223a44:	10800098 	cmpnei	r2,r2,2
 8223a48:	10000a1e 	bne	r2,zero,8223a74 <alt_tse_phy_set_common_speed+0x244>
            alt_tse_phy_set_adv_1000(pphy, 1);
 8223a4c:	01400044 	movi	r5,1
 8223a50:	e13ff517 	ldw	r4,-44(fp)
 8223a54:	8222f480 	call	8222f48 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 8223a58:	01400044 	movi	r5,1
 8223a5c:	e13ff517 	ldw	r4,-44(fp)
 8223a60:	822310c0 	call	822310c <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 8223a64:	01400044 	movi	r5,1
 8223a68:	e13ff517 	ldw	r4,-44(fp)
 8223a6c:	82233600 	call	8223360 <alt_tse_phy_set_adv_10>
 8223a70:	00002206 	br	8223afc <alt_tse_phy_set_common_speed+0x2cc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
 8223a74:	e0bffd17 	ldw	r2,-12(fp)
 8223a78:	10800058 	cmpnei	r2,r2,1
 8223a7c:	10000a1e 	bne	r2,zero,8223aa8 <alt_tse_phy_set_common_speed+0x278>
            alt_tse_phy_set_adv_1000(pphy, 0);
 8223a80:	000b883a 	mov	r5,zero
 8223a84:	e13ff517 	ldw	r4,-44(fp)
 8223a88:	8222f480 	call	8222f48 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 8223a8c:	01400044 	movi	r5,1
 8223a90:	e13ff517 	ldw	r4,-44(fp)
 8223a94:	822310c0 	call	822310c <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 8223a98:	01400044 	movi	r5,1
 8223a9c:	e13ff517 	ldw	r4,-44(fp)
 8223aa0:	82233600 	call	8223360 <alt_tse_phy_set_adv_10>
 8223aa4:	00001506 	br	8223afc <alt_tse_phy_set_common_speed+0x2cc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
 8223aa8:	e0bffd17 	ldw	r2,-12(fp)
 8223aac:	10000a1e 	bne	r2,zero,8223ad8 <alt_tse_phy_set_common_speed+0x2a8>
            alt_tse_phy_set_adv_1000(pphy, 0);
 8223ab0:	000b883a 	mov	r5,zero
 8223ab4:	e13ff517 	ldw	r4,-44(fp)
 8223ab8:	8222f480 	call	8222f48 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 8223abc:	000b883a 	mov	r5,zero
 8223ac0:	e13ff517 	ldw	r4,-44(fp)
 8223ac4:	822310c0 	call	822310c <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 8223ac8:	01400044 	movi	r5,1
 8223acc:	e13ff517 	ldw	r4,-44(fp)
 8223ad0:	82233600 	call	8223360 <alt_tse_phy_set_adv_10>
 8223ad4:	00000906 	br	8223afc <alt_tse_phy_set_common_speed+0x2cc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
 8223ad8:	000b883a 	mov	r5,zero
 8223adc:	e13ff517 	ldw	r4,-44(fp)
 8223ae0:	8222f480 	call	8222f48 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 8223ae4:	000b883a 	mov	r5,zero
 8223ae8:	e13ff517 	ldw	r4,-44(fp)
 8223aec:	822310c0 	call	822310c <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
 8223af0:	000b883a 	mov	r5,zero
 8223af4:	e13ff517 	ldw	r4,-44(fp)
 8223af8:	82233600 	call	8223360 <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
 8223afc:	01c00044 	movi	r7,1
 8223b00:	01800144 	movi	r6,5
 8223b04:	01400044 	movi	r5,1
 8223b08:	e13ff517 	ldw	r4,-44(fp)
 8223b0c:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8223b10:	10800058 	cmpnei	r2,r2,1
 8223b14:	10003b1e 	bne	r2,zero,8223c04 <alt_tse_phy_set_common_speed+0x3d4>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
 8223b18:	e0bffb03 	ldbu	r2,-20(fp)
 8223b1c:	10000f26 	beq	r2,zero,8223b5c <alt_tse_phy_set_common_speed+0x32c>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 8223b20:	e0bff517 	ldw	r2,-44(fp)
 8223b24:	10800517 	ldw	r2,20(r2)
 8223b28:	10801583 	ldbu	r2,86(r2)
 8223b2c:	10c03fcc 	andi	r3,r2,255
 8223b30:	e0bff517 	ldw	r2,-44(fp)
 8223b34:	10800517 	ldw	r2,20(r2)
 8223b38:	108015c3 	ldbu	r2,87(r2)
 8223b3c:	10803fcc 	andi	r2,r2,255
 8223b40:	01c00084 	movi	r7,2
 8223b44:	100d883a 	mov	r6,r2
 8223b48:	180b883a 	mov	r5,r3
 8223b4c:	e13ff517 	ldw	r4,-44(fp)
 8223b50:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8223b54:	e0bff405 	stb	r2,-48(fp)
 8223b58:	00000e06 	br	8223b94 <alt_tse_phy_set_common_speed+0x364>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
 8223b5c:	e0bff517 	ldw	r2,-44(fp)
 8223b60:	10800517 	ldw	r2,20(r2)
 8223b64:	10801583 	ldbu	r2,86(r2)
 8223b68:	10c03fcc 	andi	r3,r2,255
 8223b6c:	e0bff517 	ldw	r2,-44(fp)
 8223b70:	10800517 	ldw	r2,20(r2)
 8223b74:	108015c3 	ldbu	r2,87(r2)
 8223b78:	10803fcc 	andi	r2,r2,255
 8223b7c:	01c00044 	movi	r7,1
 8223b80:	100d883a 	mov	r6,r2
 8223b84:	180b883a 	mov	r5,r3
 8223b88:	e13ff517 	ldw	r4,-44(fp)
 8223b8c:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8223b90:	e0bff405 	stb	r2,-48(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
 8223b94:	e0fff403 	ldbu	r3,-48(fp)
 8223b98:	e0bffd17 	ldw	r2,-12(fp)
 8223b9c:	18800426 	beq	r3,r2,8223bb0 <alt_tse_phy_set_common_speed+0x380>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 8223ba0:	01400134 	movhi	r5,4
 8223ba4:	29742404 	addi	r5,r5,-12144
 8223ba8:	e13ff517 	ldw	r4,-44(fp)
 8223bac:	82226940 	call	8222694 <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 8223bb0:	e0bff517 	ldw	r2,-44(fp)
 8223bb4:	10800517 	ldw	r2,20(r2)
 8223bb8:	10801583 	ldbu	r2,86(r2)
 8223bbc:	10c03fcc 	andi	r3,r2,255
 8223bc0:	e0bff517 	ldw	r2,-44(fp)
 8223bc4:	10800517 	ldw	r2,20(r2)
 8223bc8:	10801603 	ldbu	r2,88(r2)
 8223bcc:	10803fcc 	andi	r2,r2,255
 8223bd0:	01c00044 	movi	r7,1
 8223bd4:	100d883a 	mov	r6,r2
 8223bd8:	180b883a 	mov	r5,r3
 8223bdc:	e13ff517 	ldw	r4,-44(fp)
 8223be0:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8223be4:	e0bffb45 	stb	r2,-19(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
 8223be8:	e0bff717 	ldw	r2,-36(fp)
 8223bec:	10800017 	ldw	r2,0(r2)
 8223bf0:	1007883a 	mov	r3,r2
 8223bf4:	e0bffb43 	ldbu	r2,-19(fp)
 8223bf8:	100b883a 	mov	r5,r2
 8223bfc:	1809883a 	mov	r4,r3
 8223c00:	82204f00 	call	82204f0 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
 8223c04:	e43ff847 	ldb	r16,-31(fp)
 8223c08:	e47ff807 	ldb	r17,-32(fp)
 8223c0c:	01c00404 	movi	r7,16
 8223c10:	000d883a 	mov	r6,zero
 8223c14:	01400044 	movi	r5,1
 8223c18:	e13ff517 	ldw	r4,-44(fp)
 8223c1c:	82211cc0 	call	82211cc <alt_tse_phy_rd_mdio_reg>
 8223c20:	100f883a 	mov	r7,r2
 8223c24:	880d883a 	mov	r6,r17
 8223c28:	800b883a 	mov	r5,r16
 8223c2c:	01020974 	movhi	r4,2085
 8223c30:	213e6f04 	addi	r4,r4,-1604
 8223c34:	820331c0 	call	820331c <printf>
 8223c38:	00000106 	br	8223c40 <alt_tse_phy_set_common_speed+0x410>

        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 8223c3c:	0001883a 	nop
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 8223c40:	e0bff317 	ldw	r2,-52(fp)
 8223c44:	10800044 	addi	r2,r2,1
 8223c48:	e0bff315 	stw	r2,-52(fp)
 8223c4c:	e0bffc17 	ldw	r2,-16(fp)
 8223c50:	10800003 	ldbu	r2,0(r2)
 8223c54:	10803fcc 	andi	r2,r2,255
 8223c58:	e0fff317 	ldw	r3,-52(fp)
 8223c5c:	18bf1f16 	blt	r3,r2,82238dc <alt_tse_phy_set_common_speed+0xac>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
 8223c60:	e0fff847 	ldb	r3,-31(fp)
 8223c64:	e0bffd17 	ldw	r2,-12(fp)
 8223c68:	108000a0 	cmpeqi	r2,r2,2
 8223c6c:	1000071e 	bne	r2,zero,8223c8c <alt_tse_phy_set_common_speed+0x45c>
 8223c70:	e0bffd17 	ldw	r2,-12(fp)
 8223c74:	10800058 	cmpnei	r2,r2,1
 8223c78:	1000021e 	bne	r2,zero,8223c84 <alt_tse_phy_set_common_speed+0x454>
 8223c7c:	00801904 	movi	r2,100
 8223c80:	00000306 	br	8223c90 <alt_tse_phy_set_common_speed+0x460>
 8223c84:	00800284 	movi	r2,10
 8223c88:	00000106 	br	8223c90 <alt_tse_phy_set_common_speed+0x460>
 8223c8c:	0080fa04 	movi	r2,1000
 8223c90:	100d883a 	mov	r6,r2
 8223c94:	180b883a 	mov	r5,r3
 8223c98:	01020974 	movhi	r4,2085
 8223c9c:	213e7b04 	addi	r4,r4,-1556
 8223ca0:	820331c0 	call	820331c <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
 8223ca4:	e0bffd17 	ldw	r2,-12(fp)
 8223ca8:	10803fcc 	andi	r2,r2,255
 8223cac:	100b883a 	mov	r5,r2
 8223cb0:	e13ff917 	ldw	r4,-28(fp)
 8223cb4:	82204100 	call	8220410 <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 8223cb8:	e0bff917 	ldw	r2,-28(fp)
 8223cbc:	10801004 	addi	r2,r2,64
 8223cc0:	e0fffa17 	ldw	r3,-24(fp)
 8223cc4:	10c00035 	stwio	r3,0(r2)
        
    return common_speed;
 8223cc8:	e0bffd17 	ldw	r2,-12(fp)
}
 8223ccc:	e6fffe04 	addi	sp,fp,-8
 8223cd0:	dfc00317 	ldw	ra,12(sp)
 8223cd4:	df000217 	ldw	fp,8(sp)
 8223cd8:	dc400117 	ldw	r17,4(sp)
 8223cdc:	dc000017 	ldw	r16,0(sp)
 8223ce0:	dec00404 	addi	sp,sp,16
 8223ce4:	f800283a 	ret

08223ce8 <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
 8223ce8:	defffc04 	addi	sp,sp,-16
 8223cec:	dfc00315 	stw	ra,12(sp)
 8223cf0:	df000215 	stw	fp,8(sp)
 8223cf4:	df000204 	addi	fp,sp,8
 8223cf8:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & PCS_ST_an_done) == 0) {
 8223cfc:	e0bfff17 	ldw	r2,-4(fp)
 8223d00:	1080a104 	addi	r2,r2,644
 8223d04:	10800037 	ldwio	r2,0(r2)
 8223d08:	1080080c 	andi	r2,r2,32
 8223d0c:	1000161e 	bne	r2,zero,8223d68 <marvell_phy_cfg+0x80>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
 8223d10:	01020974 	movhi	r4,2085
 8223d14:	213e8c04 	addi	r4,r4,-1488
 8223d18:	82035a00 	call	82035a0 <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
 8223d1c:	e0bfff17 	ldw	r2,-4(fp)
 8223d20:	1080a004 	addi	r2,r2,640
 8223d24:	10801004 	addi	r2,r2,64
 8223d28:	00c01e04 	movi	r3,120
 8223d2c:	10c00035 	stwio	r3,0(r2)
        tse_dprintf(5, "MARVELL : PHY reset\n");
 8223d30:	01020974 	movhi	r4,2085
 8223d34:	213e9504 	addi	r4,r4,-1452
 8223d38:	82035a00 	call	82035a0 <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223d3c:	e0bfff17 	ldw	r2,-4(fp)
 8223d40:	1080a004 	addi	r2,r2,640
 8223d44:	10800037 	ldwio	r2,0(r2)
 8223d48:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);        
 8223d4c:	e0bfff17 	ldw	r2,-4(fp)
 8223d50:	1080a004 	addi	r2,r2,640
 8223d54:	e13ffe0b 	ldhu	r4,-8(fp)
 8223d58:	00e00004 	movi	r3,-32768
 8223d5c:	20c6b03a 	or	r3,r4,r3
 8223d60:	18ffffcc 	andi	r3,r3,65535
 8223d64:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
 8223d68:	0005883a 	mov	r2,zero
}
 8223d6c:	e037883a 	mov	sp,fp
 8223d70:	dfc00117 	ldw	ra,4(sp)
 8223d74:	df000017 	ldw	fp,0(sp)
 8223d78:	dec00204 	addi	sp,sp,8
 8223d7c:	f800283a 	ret

08223d80 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
 8223d80:	defffc04 	addi	sp,sp,-16
 8223d84:	dfc00315 	stw	ra,12(sp)
 8223d88:	df000215 	stw	fp,8(sp)
 8223d8c:	df000204 	addi	fp,sp,8
 8223d90:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 8223d94:	e0bfff17 	ldw	r2,-4(fp)
 8223d98:	1080bb04 	addi	r2,r2,748
 8223d9c:	10800037 	ldwio	r2,0(r2)
 8223da0:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 8223da4:	e0fffe0b 	ldhu	r3,-8(fp)
 8223da8:	00bffc04 	movi	r2,-16
 8223dac:	1884703a 	and	r2,r3,r2
 8223db0:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
 8223db4:	01020974 	movhi	r4,2085
 8223db8:	213e9a04 	addi	r4,r4,-1432
 8223dbc:	82035a00 	call	82035a0 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
 8223dc0:	e0bfff17 	ldw	r2,-4(fp)
 8223dc4:	1080bb04 	addi	r2,r2,748
 8223dc8:	e0fffe0b 	ldhu	r3,-8(fp)
 8223dcc:	18c003d4 	ori	r3,r3,15
 8223dd0:	18ffffcc 	andi	r3,r3,65535
 8223dd4:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 8223dd8:	01020974 	movhi	r4,2085
 8223ddc:	213ea604 	addi	r4,r4,-1384
 8223de0:	82035a00 	call	82035a0 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 8223de4:	e0bfff17 	ldw	r2,-4(fp)
 8223de8:	1080b404 	addi	r2,r2,720
 8223dec:	10800037 	ldwio	r2,0(r2)
 8223df0:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 8223df4:	e0fffe0b 	ldhu	r3,-8(fp)
 8223df8:	00bfdf44 	movi	r2,-131
 8223dfc:	1884703a 	and	r2,r3,r2
 8223e00:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 8223e04:	e0bfff17 	ldw	r2,-4(fp)
 8223e08:	1080b404 	addi	r2,r2,720
 8223e0c:	e0fffe0b 	ldhu	r3,-8(fp)
 8223e10:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 8223e14:	01020974 	movhi	r4,2085
 8223e18:	213e9504 	addi	r4,r4,-1452
 8223e1c:	82035a00 	call	82035a0 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223e20:	e0bfff17 	ldw	r2,-4(fp)
 8223e24:	1080a004 	addi	r2,r2,640
 8223e28:	10800037 	ldwio	r2,0(r2)
 8223e2c:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 8223e30:	e0bfff17 	ldw	r2,-4(fp)
 8223e34:	1080a004 	addi	r2,r2,640
 8223e38:	e13ffe0b 	ldhu	r4,-8(fp)
 8223e3c:	00e00004 	movi	r3,-32768
 8223e40:	20c6b03a 	or	r3,r4,r3
 8223e44:	18ffffcc 	andi	r3,r3,65535
 8223e48:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 8223e4c:	00800044 	movi	r2,1
}
 8223e50:	e037883a 	mov	sp,fp
 8223e54:	dfc00117 	ldw	ra,4(sp)
 8223e58:	df000017 	ldw	fp,0(sp)
 8223e5c:	dec00204 	addi	sp,sp,8
 8223e60:	f800283a 	ret

08223e64 <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
 8223e64:	defffc04 	addi	sp,sp,-16
 8223e68:	dfc00315 	stw	ra,12(sp)
 8223e6c:	df000215 	stw	fp,8(sp)
 8223e70:	df000204 	addi	fp,sp,8
 8223e74:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 8223e78:	e0bfff17 	ldw	r2,-4(fp)
 8223e7c:	1080bb04 	addi	r2,r2,748
 8223e80:	10800037 	ldwio	r2,0(r2)
 8223e84:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 8223e88:	e0fffe0b 	ldhu	r3,-8(fp)
 8223e8c:	00bffc04 	movi	r2,-16
 8223e90:	1884703a 	and	r2,r3,r2
 8223e94:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
 8223e98:	01020974 	movhi	r4,2085
 8223e9c:	213eb004 	addi	r4,r4,-1344
 8223ea0:	82035a00 	call	82035a0 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
 8223ea4:	e0bfff17 	ldw	r2,-4(fp)
 8223ea8:	1080bb04 	addi	r2,r2,748
 8223eac:	e0fffe0b 	ldhu	r3,-8(fp)
 8223eb0:	18c00114 	ori	r3,r3,4
 8223eb4:	18ffffcc 	andi	r3,r3,65535
 8223eb8:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 8223ebc:	01020974 	movhi	r4,2085
 8223ec0:	213ea604 	addi	r4,r4,-1384
 8223ec4:	82035a00 	call	82035a0 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 8223ec8:	e0bfff17 	ldw	r2,-4(fp)
 8223ecc:	1080b404 	addi	r2,r2,720
 8223ed0:	10800037 	ldwio	r2,0(r2)
 8223ed4:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 8223ed8:	e0fffe0b 	ldhu	r3,-8(fp)
 8223edc:	00bfdf44 	movi	r2,-131
 8223ee0:	1884703a 	and	r2,r3,r2
 8223ee4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 8223ee8:	e0bfff17 	ldw	r2,-4(fp)
 8223eec:	1080b404 	addi	r2,r2,720
 8223ef0:	e0fffe0b 	ldhu	r3,-8(fp)
 8223ef4:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
 8223ef8:	01020974 	movhi	r4,2085
 8223efc:	213e9504 	addi	r4,r4,-1452
 8223f00:	82035a00 	call	82035a0 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223f04:	e0bfff17 	ldw	r2,-4(fp)
 8223f08:	1080a004 	addi	r2,r2,640
 8223f0c:	10800037 	ldwio	r2,0(r2)
 8223f10:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 8223f14:	e0bfff17 	ldw	r2,-4(fp)
 8223f18:	1080a004 	addi	r2,r2,640
 8223f1c:	e13ffe0b 	ldhu	r4,-8(fp)
 8223f20:	00e00004 	movi	r3,-32768
 8223f24:	20c6b03a 	or	r3,r4,r3
 8223f28:	18ffffcc 	andi	r3,r3,65535
 8223f2c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 8223f30:	00800044 	movi	r2,1
}
 8223f34:	e037883a 	mov	sp,fp
 8223f38:	dfc00117 	ldw	ra,4(sp)
 8223f3c:	df000017 	ldw	fp,0(sp)
 8223f40:	dec00204 	addi	sp,sp,8
 8223f44:	f800283a 	ret

08223f48 <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
 8223f48:	defffc04 	addi	sp,sp,-16
 8223f4c:	dfc00315 	stw	ra,12(sp)
 8223f50:	df000215 	stw	fp,8(sp)
 8223f54:	df000204 	addi	fp,sp,8
 8223f58:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 8223f5c:	e0bfff17 	ldw	r2,-4(fp)
 8223f60:	1080bb04 	addi	r2,r2,748
 8223f64:	10800037 	ldwio	r2,0(r2)
 8223f68:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 8223f6c:	e0fffe0b 	ldhu	r3,-8(fp)
 8223f70:	00bffc04 	movi	r2,-16
 8223f74:	1884703a 	and	r2,r3,r2
 8223f78:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
 8223f7c:	01020974 	movhi	r4,2085
 8223f80:	213ec504 	addi	r4,r4,-1260
 8223f84:	82035a00 	call	82035a0 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
 8223f88:	e0bfff17 	ldw	r2,-4(fp)
 8223f8c:	1080bb04 	addi	r2,r2,748
 8223f90:	e0fffe0b 	ldhu	r3,-8(fp)
 8223f94:	18c002d4 	ori	r3,r3,11
 8223f98:	18ffffcc 	andi	r3,r3,65535
 8223f9c:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
 8223fa0:	01020974 	movhi	r4,2085
 8223fa4:	213ed404 	addi	r4,r4,-1200
 8223fa8:	82035a00 	call	82035a0 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
 8223fac:	e0bfff17 	ldw	r2,-4(fp)
 8223fb0:	1080b404 	addi	r2,r2,720
 8223fb4:	10800037 	ldwio	r2,0(r2)
 8223fb8:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 8223fbc:	e0fffe0b 	ldhu	r3,-8(fp)
 8223fc0:	00bfdf44 	movi	r2,-131
 8223fc4:	1884703a 	and	r2,r3,r2
 8223fc8:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
 8223fcc:	e0bffe0b 	ldhu	r2,-8(fp)
 8223fd0:	10802094 	ori	r2,r2,130
 8223fd4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
 8223fd8:	e0bfff17 	ldw	r2,-4(fp)
 8223fdc:	1080b404 	addi	r2,r2,720
 8223fe0:	e0fffe0b 	ldhu	r3,-8(fp)
 8223fe4:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 8223fe8:	01020974 	movhi	r4,2085
 8223fec:	213e9504 	addi	r4,r4,-1452
 8223ff0:	82035a00 	call	82035a0 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 8223ff4:	e0bfff17 	ldw	r2,-4(fp)
 8223ff8:	1080a004 	addi	r2,r2,640
 8223ffc:	10800037 	ldwio	r2,0(r2)
 8224000:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 8224004:	e0bfff17 	ldw	r2,-4(fp)
 8224008:	1080a004 	addi	r2,r2,640
 822400c:	e13ffe0b 	ldhu	r4,-8(fp)
 8224010:	00e00004 	movi	r3,-32768
 8224014:	20c6b03a 	or	r3,r4,r3
 8224018:	18ffffcc 	andi	r3,r3,65535
 822401c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 8224020:	00800044 	movi	r2,1
    
}
 8224024:	e037883a 	mov	sp,fp
 8224028:	dfc00117 	ldw	ra,4(sp)
 822402c:	df000017 	ldw	fp,0(sp)
 8224030:	dec00204 	addi	sp,sp,8
 8224034:	f800283a 	ret

08224038 <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
 8224038:	defffc04 	addi	sp,sp,-16
 822403c:	df000315 	stw	fp,12(sp)
 8224040:	df000304 	addi	fp,sp,12
 8224044:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
 8224048:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
 822404c:	e0bfff17 	ldw	r2,-4(fp)
 8224050:	1080b004 	addi	r2,r2,704
 8224054:	10800037 	ldwio	r2,0(r2)
 8224058:	e0bffe15 	stw	r2,-8(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
 822405c:	e0bffe17 	ldw	r2,-8(fp)
 8224060:	1080008c 	andi	r2,r2,2
 8224064:	10000426 	beq	r2,zero,8224078 <DP83848C_link_status_read+0x40>
		link_status |= 0x8;
 8224068:	e0bffd17 	ldw	r2,-12(fp)
 822406c:	10800214 	ori	r2,r2,8
 8224070:	e0bffd15 	stw	r2,-12(fp)
 8224074:	00000306 	br	8224084 <DP83848C_link_status_read+0x4c>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
 8224078:	e0bffd17 	ldw	r2,-12(fp)
 822407c:	10800114 	ori	r2,r2,4
 8224080:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
 8224084:	e0bffe17 	ldw	r2,-8(fp)
 8224088:	1080010c 	andi	r2,r2,4
 822408c:	10000326 	beq	r2,zero,822409c <DP83848C_link_status_read+0x64>
		link_status |= 0x1;
 8224090:	e0bffd17 	ldw	r2,-12(fp)
 8224094:	10800054 	ori	r2,r2,1
 8224098:	e0bffd15 	stw	r2,-12(fp)
	}
	
	return link_status;
 822409c:	e0bffd17 	ldw	r2,-12(fp)
}
 82240a0:	e037883a 	mov	sp,fp
 82240a4:	df000017 	ldw	fp,0(sp)
 82240a8:	dec00104 	addi	sp,sp,4
 82240ac:	f800283a 	ret

082240b0 <altera_eth_tse_init>:
 * @Return ENP_HARDWARE on error, otherwise return SUCCESS
 */

error_t altera_eth_tse_init(
    alt_iniche_dev              *p_dev)
{
 82240b0:	defffa04 	addi	sp,sp,-24
 82240b4:	dfc00515 	stw	ra,20(sp)
 82240b8:	df000415 	stw	fp,16(sp)
 82240bc:	df000404 	addi	fp,sp,16
 82240c0:	e13fff15 	stw	r4,-4(fp)
    int i;
    
    alt_tse_iniche_dev_driver_data *p_driver_data = 0;
 82240c4:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_system_info *psys_info = 0;
 82240c8:	e03ffe15 	stw	zero,-8(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 82240cc:	e03ffc15 	stw	zero,-16(fp)
 82240d0:	00001106 	br	8224118 <altera_eth_tse_init+0x68>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
 82240d4:	008209b4 	movhi	r2,2086
 82240d8:	10b70704 	addi	r2,r2,-9188
 82240dc:	e0fffc17 	ldw	r3,-16(fp)
 82240e0:	18c00324 	muli	r3,r3,12
 82240e4:	10c5883a 	add	r2,r2,r3
 82240e8:	10c00017 	ldw	r3,0(r2)
 82240ec:	e0bfff17 	ldw	r2,-4(fp)
 82240f0:	1880061e 	bne	r3,r2,822410c <altera_eth_tse_init+0x5c>
            p_driver_data = &tse_iniche_dev_driver_data[i];
 82240f4:	e0bffc17 	ldw	r2,-16(fp)
 82240f8:	10c00324 	muli	r3,r2,12
 82240fc:	008209b4 	movhi	r2,2086
 8224100:	10b70704 	addi	r2,r2,-9188
 8224104:	1885883a 	add	r2,r3,r2
 8224108:	e0bffd15 	stw	r2,-12(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 822410c:	e0bffc17 	ldw	r2,-16(fp)
 8224110:	10800044 	addi	r2,r2,1
 8224114:	e0bffc15 	stw	r2,-16(fp)
 8224118:	d0a08003 	ldbu	r2,-32256(gp)
 822411c:	10803fcc 	andi	r2,r2,255
 8224120:	e0fffc17 	ldw	r3,-16(fp)
 8224124:	18bfeb16 	blt	r3,r2,82240d4 <altera_eth_tse_init+0x24>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
            p_driver_data = &tse_iniche_dev_driver_data[i];
        }
    }
    /* If pointer could not found */
    if(p_driver_data == 0) {
 8224128:	e0bffd17 	ldw	r2,-12(fp)
 822412c:	1000021e 	bne	r2,zero,8224138 <altera_eth_tse_init+0x88>
        return ENP_HARDWARE;
 8224130:	00bff744 	movi	r2,-35
 8224134:	00002706 	br	82241d4 <altera_eth_tse_init+0x124>
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 8224138:	e03ffc15 	stw	zero,-16(fp)
 822413c:	00001206 	br	8224188 <altera_eth_tse_init+0xd8>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
 8224140:	00820974 	movhi	r2,2085
 8224144:	1087c104 	addi	r2,r2,7940
 8224148:	e0fffc17 	ldw	r3,-16(fp)
 822414c:	18c01224 	muli	r3,r3,72
 8224150:	10c5883a 	add	r2,r2,r3
 8224154:	10c00017 	ldw	r3,0(r2)
 8224158:	e0bffd17 	ldw	r2,-12(fp)
 822415c:	10800117 	ldw	r2,4(r2)
 8224160:	1880061e 	bne	r3,r2,822417c <altera_eth_tse_init+0xcc>
            psys_info = &tse_mac_device[i];
 8224164:	e0bffc17 	ldw	r2,-16(fp)
 8224168:	10c01224 	muli	r3,r2,72
 822416c:	00820974 	movhi	r2,2085
 8224170:	1087c104 	addi	r2,r2,7940
 8224174:	1885883a 	add	r2,r3,r2
 8224178:	e0bffe15 	stw	r2,-8(fp)
    if(p_driver_data == 0) {
        return ENP_HARDWARE;
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 822417c:	e0bffc17 	ldw	r2,-16(fp)
 8224180:	10800044 	addi	r2,r2,1
 8224184:	e0bffc15 	stw	r2,-16(fp)
 8224188:	d0a02d03 	ldbu	r2,-32588(gp)
 822418c:	10803fcc 	andi	r2,r2,255
 8224190:	e0fffc17 	ldw	r3,-16(fp)
 8224194:	18bfea16 	blt	r3,r2,8224140 <altera_eth_tse_init+0x90>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
            psys_info = &tse_mac_device[i];
        }
    }
    /* If pointer could not found */
    if(psys_info == 0) {
 8224198:	e0bffe17 	ldw	r2,-8(fp)
 822419c:	1000021e 	bne	r2,zero,82241a8 <altera_eth_tse_init+0xf8>
        return ENP_HARDWARE;
 82241a0:	00bff744 	movi	r2,-35
 82241a4:	00000b06 	br	82241d4 <altera_eth_tse_init+0x124>
    }
    
    prep_tse_mac(p_dev->if_num, psys_info + p_driver_data->hw_channel_number);
 82241a8:	e0bfff17 	ldw	r2,-4(fp)
 82241ac:	11000517 	ldw	r4,20(r2)
 82241b0:	e0bffd17 	ldw	r2,-12(fp)
 82241b4:	10800203 	ldbu	r2,8(r2)
 82241b8:	10803fcc 	andi	r2,r2,255
 82241bc:	10801224 	muli	r2,r2,72
 82241c0:	e0fffe17 	ldw	r3,-8(fp)
 82241c4:	1885883a 	add	r2,r3,r2
 82241c8:	100b883a 	mov	r5,r2
 82241cc:	82241e80 	call	82241e8 <prep_tse_mac>
    
    return SUCCESS;
 82241d0:	0005883a 	mov	r2,zero
}
 82241d4:	e037883a 	mov	sp,fp
 82241d8:	dfc00117 	ldw	ra,4(sp)
 82241dc:	df000017 	ldw	fp,0(sp)
 82241e0:	dec00204 	addi	sp,sp,8
 82241e4:	f800283a 	ret

082241e8 <prep_tse_mac>:
 * @Param index     index of the NET structure associated with TSE instance
 * @Param psys_info pointer to the TSE hardware info structure
 * @Return next index of NET
 */
int prep_tse_mac(int index, alt_tse_system_info *psys_info)
{
 82241e8:	defffb04 	addi	sp,sp,-20
 82241ec:	dfc00415 	stw	ra,16(sp)
 82241f0:	df000315 	stw	fp,12(sp)
 82241f4:	df000304 	addi	fp,sp,12
 82241f8:	e13ffe15 	stw	r4,-8(fp)
 82241fc:	e17fff15 	stw	r5,-4(fp)
    NET ifp;
    dprintf("prep_tse_mac %d\n", index);
 8224200:	e17ffe17 	ldw	r5,-8(fp)
 8224204:	01020974 	movhi	r4,2085
 8224208:	213ede04 	addi	r4,r4,-1160
 822420c:	820331c0 	call	820331c <printf>
    {
        tse[index].sem = 0; /*Tx IDLE*/
 8224210:	008209b4 	movhi	r2,2086
 8224214:	10b71304 	addi	r2,r2,-9140
 8224218:	e0fffe17 	ldw	r3,-8(fp)
 822421c:	18c01324 	muli	r3,r3,76
 8224220:	10c5883a 	add	r2,r2,r3
 8224224:	10800c04 	addi	r2,r2,48
 8224228:	10000015 	stw	zero,0(r2)
        tse[index].tse = (void *)psys_info;
 822422c:	008209b4 	movhi	r2,2086
 8224230:	10b71304 	addi	r2,r2,-9140
 8224234:	e0fffe17 	ldw	r3,-8(fp)
 8224238:	18c01324 	muli	r3,r3,76
 822423c:	10c5883a 	add	r2,r2,r3
 8224240:	10801204 	addi	r2,r2,72
 8224244:	e0ffff17 	ldw	r3,-4(fp)
 8224248:	10c00015 	stw	r3,0(r2)

        ifp = nets[index];
 822424c:	008209b4 	movhi	r2,2086
 8224250:	10b82404 	addi	r2,r2,-8048
 8224254:	e0fffe17 	ldw	r3,-8(fp)
 8224258:	18c7883a 	add	r3,r3,r3
 822425c:	18c7883a 	add	r3,r3,r3
 8224260:	10c5883a 	add	r2,r2,r3
 8224264:	10800017 	ldw	r2,0(r2)
 8224268:	e0bffd15 	stw	r2,-12(fp)
        ifp->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN; /* status = down */
 822426c:	e0bffd17 	ldw	r2,-12(fp)
 8224270:	10802717 	ldw	r2,156(r2)
 8224274:	00c00084 	movi	r3,2
 8224278:	10c00615 	stw	r3,24(r2)
        ifp->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_DOWN;   
 822427c:	e0bffd17 	ldw	r2,-12(fp)
 8224280:	10802717 	ldw	r2,156(r2)
 8224284:	00c00084 	movi	r3,2
 8224288:	10c00715 	stw	r3,28(r2)
        ifp->n_mib->ifLastChange =  cticks * (100/TPS);
 822428c:	e0bffd17 	ldw	r2,-12(fp)
 8224290:	10802717 	ldw	r2,156(r2)
 8224294:	d0e0a817 	ldw	r3,-32096(gp)
 8224298:	10c00815 	stw	r3,32(r2)
        ifp->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;
 822429c:	e0bffd17 	ldw	r2,-12(fp)
 82242a0:	10c02717 	ldw	r3,156(r2)
 82242a4:	e0bffe17 	ldw	r2,-8(fp)
 82242a8:	10801324 	muli	r2,r2,76
 82242ac:	11000604 	addi	r4,r2,24
 82242b0:	008209b4 	movhi	r2,2086
 82242b4:	10b71304 	addi	r2,r2,-9140
 82242b8:	2085883a 	add	r2,r4,r2
 82242bc:	18800515 	stw	r2,20(r3)
        ifp->n_mib->ifDescr =       "Altera TSE MAC ethernet";
 82242c0:	e0bffd17 	ldw	r2,-12(fp)
 82242c4:	10c02717 	ldw	r3,156(r2)
 82242c8:	00820974 	movhi	r2,2085
 82242cc:	10bee304 	addi	r2,r2,-1140
 82242d0:	18800115 	stw	r2,4(r3)
        ifp->n_lnh =                ETHHDR_SIZE; /* ethernet header size. was:14 */
 82242d4:	e0bffd17 	ldw	r2,-12(fp)
 82242d8:	00c00404 	movi	r3,16
 82242dc:	10c00815 	stw	r3,32(r2)
        ifp->n_hal =                ALTERA_TSE_HAL_ADDR_LEN;  /* hardware address length */
 82242e0:	e0bffd17 	ldw	r2,-12(fp)
 82242e4:	00c00184 	movi	r3,6
 82242e8:	10c01115 	stw	r3,68(r2)
        ifp->n_mib->ifType =        ETHERNET;   /* device type */
 82242ec:	e0bffd17 	ldw	r2,-12(fp)
 82242f0:	10802717 	ldw	r2,156(r2)
 82242f4:	00c00184 	movi	r3,6
 82242f8:	10c00215 	stw	r3,8(r2)
        ifp->n_mtu =                ALTERA_TSE_MAX_MTU_SIZE;  /* max frame size */
 82242fc:	e0bffd17 	ldw	r2,-12(fp)
 8224300:	00c17a84 	movi	r3,1514
 8224304:	10c00915 	stw	r3,36(r2)
    
        /* install our hardware driver routines */
        ifp->n_init =       tse_mac_init;
 8224308:	e0fffd17 	ldw	r3,-12(fp)
 822430c:	008208b4 	movhi	r2,2082
 8224310:	10911004 	addi	r2,r2,17472
 8224314:	18800215 	stw	r2,8(r3)
        ifp->pkt_send =     NULL;
 8224318:	e0bffd17 	ldw	r2,-12(fp)
 822431c:	10000415 	stw	zero,16(r2)
        ifp->raw_send =     tse_mac_raw_send;
 8224320:	e0fffd17 	ldw	r3,-12(fp)
 8224324:	008208b4 	movhi	r2,2082
 8224328:	1093a804 	addi	r2,r2,20128
 822432c:	18800315 	stw	r2,12(r3)
        ifp->n_close =      tse_mac_close;
 8224330:	e0fffd17 	ldw	r3,-12(fp)
 8224334:	008208b4 	movhi	r2,2082
 8224338:	10959c04 	addi	r2,r2,22128
 822433c:	18800515 	stw	r2,20(r3)
        ifp->n_stats =      (void(*)(void *, int))tse_mac_stats; 
 8224340:	e0fffd17 	ldw	r3,-12(fp)
 8224344:	008208b4 	movhi	r2,2082
 8224348:	10958c04 	addi	r2,r2,22064
 822434c:	18800715 	stw	r2,28(r3)
    
    #ifdef IP_V6
        ifp->n_flags |= (NF_NBPROT | NF_IPV6);
    #else
        ifp->n_flags |= NF_NBPROT;
 8224350:	e0bffd17 	ldw	r2,-12(fp)
 8224354:	10802a17 	ldw	r2,168(r2)
 8224358:	10c00214 	ori	r3,r2,8
 822435c:	e0bffd17 	ldw	r2,-12(fp)
 8224360:	10c02a15 	stw	r3,168(r2)
    #endif
    
        nets[index]->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;   /* ptr to MAC address */
 8224364:	008209b4 	movhi	r2,2086
 8224368:	10b82404 	addi	r2,r2,-8048
 822436c:	e0fffe17 	ldw	r3,-8(fp)
 8224370:	18c7883a 	add	r3,r3,r3
 8224374:	18c7883a 	add	r3,r3,r3
 8224378:	10c5883a 	add	r2,r2,r3
 822437c:	10800017 	ldw	r2,0(r2)
 8224380:	10c02717 	ldw	r3,156(r2)
 8224384:	e0bffe17 	ldw	r2,-8(fp)
 8224388:	10801324 	muli	r2,r2,76
 822438c:	11000604 	addi	r4,r2,24
 8224390:	008209b4 	movhi	r2,2086
 8224394:	10b71304 	addi	r2,r2,-9140
 8224398:	2085883a 	add	r2,r4,r2
 822439c:	18800515 	stw	r2,20(r3)
    
    #ifdef ALT_INICHE
        /* get the MAC address. */
        get_mac_addr(ifp, (unsigned char *)tse[index].mac_addr);
 82243a0:	e0bffe17 	ldw	r2,-8(fp)
 82243a4:	10801324 	muli	r2,r2,76
 82243a8:	10c00604 	addi	r3,r2,24
 82243ac:	008209b4 	movhi	r2,2086
 82243b0:	10b71304 	addi	r2,r2,-9140
 82243b4:	1885883a 	add	r2,r3,r2
 82243b8:	100b883a 	mov	r5,r2
 82243bc:	e13ffd17 	ldw	r4,-12(fp)
 82243c0:	82010c40 	call	82010c4 <get_mac_addr>
    #endif /* ALT_INICHE */
    
        /* set cross-pointers between iface and tse structs */
        tse[index].index = index;
 82243c4:	008209b4 	movhi	r2,2086
 82243c8:	10b71304 	addi	r2,r2,-9140
 82243cc:	e0fffe17 	ldw	r3,-8(fp)
 82243d0:	18c01324 	muli	r3,r3,76
 82243d4:	10c5883a 	add	r2,r2,r3
 82243d8:	e0fffe17 	ldw	r3,-8(fp)
 82243dc:	10c00015 	stw	r3,0(r2)
        tse[index].netp = ifp;
 82243e0:	008209b4 	movhi	r2,2086
 82243e4:	10b71304 	addi	r2,r2,-9140
 82243e8:	e0fffe17 	ldw	r3,-8(fp)
 82243ec:	18c01324 	muli	r3,r3,76
 82243f0:	10c5883a 	add	r2,r2,r3
 82243f4:	10800804 	addi	r2,r2,32
 82243f8:	e0fffd17 	ldw	r3,-12(fp)
 82243fc:	10c00015 	stw	r3,0(r2)
        ifp->n_local = (void*)(&tse[index]);
 8224400:	e0bffe17 	ldw	r2,-8(fp)
 8224404:	10c01324 	muli	r3,r2,76
 8224408:	008209b4 	movhi	r2,2086
 822440c:	10b71304 	addi	r2,r2,-9140
 8224410:	1887883a 	add	r3,r3,r2
 8224414:	e0bffd17 	ldw	r2,-12(fp)
 8224418:	10c02815 	stw	r3,160(r2)
    
        index++;
 822441c:	e0bffe17 	ldw	r2,-8(fp)
 8224420:	10800044 	addi	r2,r2,1
 8224424:	e0bffe15 	stw	r2,-8(fp)
   }
 
   return index;
 8224428:	e0bffe17 	ldw	r2,-8(fp)
}
 822442c:	e037883a 	mov	sp,fp
 8224430:	dfc00117 	ldw	ra,4(sp)
 8224434:	df000017 	ldw	fp,0(sp)
 8224438:	dec00204 	addi	sp,sp,8
 822443c:	f800283a 	ret

08224440 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface)
{
 8224440:	defff004 	addi	sp,sp,-64
 8224444:	dfc00f15 	stw	ra,60(sp)
 8224448:	df000e15 	stw	fp,56(sp)
 822444c:	df000e04 	addi	fp,sp,56
 8224450:	e13fff15 	stw	r4,-4(fp)
   int dat;
   int speed, duplex, result, x;
   int status = SUCCESS;
 8224454:	e03ff815 	stw	zero,-32(fp)
   
   alt_sgdma_dev *sgdma_tx_dev;
   alt_sgdma_dev *sgdma_rx_dev;
   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
 8224458:	008209b4 	movhi	r2,2086
 822445c:	10b71304 	addi	r2,r2,-9140
 8224460:	e0ffff17 	ldw	r3,-4(fp)
 8224464:	18c01324 	muli	r3,r3,76
 8224468:	10c5883a 	add	r2,r2,r3
 822446c:	10801204 	addi	r2,r2,72
 8224470:	10800017 	ldw	r2,0(r2)
 8224474:	e0bff915 	stw	r2,-28(fp)
   
   dprintf("[tse_mac_init]\n");
 8224478:	01020974 	movhi	r4,2085
 822447c:	213ee904 	addi	r4,r4,-1116
 8224480:	82035a00 	call	82035a0 <puts>
#ifdef PRINTIF
    dprintf("tse_mac_init %d\n", iface);
#endif    

    if (tse_hw->ext_desc_mem == 1) {
 8224484:	e0bff917 	ldw	r2,-28(fp)
 8224488:	10800783 	ldbu	r2,30(r2)
 822448c:	10803fcc 	andi	r2,r2,255
 8224490:	10800058 	cmpnei	r2,r2,1
 8224494:	10000b1e 	bne	r2,zero,82244c4 <tse_mac_init+0x84>
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
 8224498:	e0bff917 	ldw	r2,-28(fp)
 822449c:	10800817 	ldw	r2,32(r2)
 82244a0:	1009883a 	mov	r4,r2
 82244a4:	008209b4 	movhi	r2,2086
 82244a8:	10b71304 	addi	r2,r2,-9140
 82244ac:	e0ffff17 	ldw	r3,-4(fp)
 82244b0:	18c01324 	muli	r3,r3,76
 82244b4:	10c5883a 	add	r2,r2,r3
 82244b8:	10800f04 	addi	r2,r2,60
 82244bc:	11000015 	stw	r4,0(r2)
 82244c0:	00001206 	br	822450c <tse_mac_init+0xcc>
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
 82244c4:	01002804 	movi	r4,160
 82244c8:	823c83c0 	call	823c83c <alt_uncached_malloc>
 82244cc:	e0bff515 	stw	r2,-44(fp)
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 82244d0:	00000306 	br	82244e0 <tse_mac_init+0xa0>
        {
            temp_desc++;
 82244d4:	e0bff517 	ldw	r2,-44(fp)
 82244d8:	10800044 	addi	r2,r2,1
 82244dc:	e0bff515 	stw	r2,-44(fp)
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 82244e0:	e0bff517 	ldw	r2,-44(fp)
 82244e4:	108007cc 	andi	r2,r2,31
 82244e8:	103ffa1e 	bne	r2,zero,82244d4 <tse_mac_init+0x94>
        {
            temp_desc++;
        }
        tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
 82244ec:	008209b4 	movhi	r2,2086
 82244f0:	10b71304 	addi	r2,r2,-9140
 82244f4:	e0ffff17 	ldw	r3,-4(fp)
 82244f8:	18c01324 	muli	r3,r3,76
 82244fc:	10c5883a 	add	r2,r2,r3
 8224500:	10800f04 	addi	r2,r2,60
 8224504:	e0fff517 	ldw	r3,-44(fp)
 8224508:	10c00015 	stw	r3,0(r2)
    }

   
   /* Get the Rx and Tx SGDMA addresses */
   sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
 822450c:	e0bff917 	ldw	r2,-28(fp)
 8224510:	10800517 	ldw	r2,20(r2)
 8224514:	1009883a 	mov	r4,r2
 8224518:	821e8f00 	call	821e8f0 <alt_avalon_sgdma_open>
 822451c:	e0bffa15 	stw	r2,-24(fp)
   
   if(!sgdma_tx_dev) {
 8224520:	e0bffa17 	ldw	r2,-24(fp)
 8224524:	1000051e 	bne	r2,zero,822453c <tse_mac_init+0xfc>
      dprintf("[altera_eth_tse_init] Error opening TX SGDMA\n");
 8224528:	01020974 	movhi	r4,2085
 822452c:	213eed04 	addi	r4,r4,-1100
 8224530:	82035a00 	call	82035a0 <puts>
      return ENP_RESOURCE;
 8224534:	00bffa84 	movi	r2,-22
 8224538:	00025406 	br	8224e8c <tse_mac_init+0xa4c>
   }
  
   sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
 822453c:	e0bff917 	ldw	r2,-28(fp)
 8224540:	10800617 	ldw	r2,24(r2)
 8224544:	1009883a 	mov	r4,r2
 8224548:	821e8f00 	call	821e8f0 <alt_avalon_sgdma_open>
 822454c:	e0bffb15 	stw	r2,-20(fp)
   if(!sgdma_rx_dev) {
 8224550:	e0bffb17 	ldw	r2,-20(fp)
 8224554:	1000051e 	bne	r2,zero,822456c <tse_mac_init+0x12c>
      dprintf("[altera_eth_tse_init] Error opening RX SGDMA\n");
 8224558:	01020974 	movhi	r4,2085
 822455c:	213ef904 	addi	r4,r4,-1052
 8224560:	82035a00 	call	82035a0 <puts>
      return ENP_RESOURCE;
 8224564:	00bffa84 	movi	r2,-22
 8224568:	00024806 	br	8224e8c <tse_mac_init+0xa4c>
   }

   /* Initialize mtip_mac_trans_info structure with values from <system.h>*/
   tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
 822456c:	e0bfff17 	ldw	r2,-4(fp)
 8224570:	10801324 	muli	r2,r2,76
 8224574:	10c00104 	addi	r3,r2,4
 8224578:	008209b4 	movhi	r2,2086
 822457c:	10b71304 	addi	r2,r2,-9140
 8224580:	1887883a 	add	r3,r3,r2
 8224584:	e0bff917 	ldw	r2,-28(fp)
 8224588:	10800017 	ldw	r2,0(r2)
 822458c:	e13ffa17 	ldw	r4,-24(fp)
 8224590:	e17ffb17 	ldw	r5,-20(fp)
 8224594:	d8000015 	stw	zero,0(sp)
 8224598:	280f883a 	mov	r7,r5
 822459c:	200d883a 	mov	r6,r4
 82245a0:	100b883a 	mov	r5,r2
 82245a4:	1809883a 	mov	r4,r3
 82245a8:	821f0f00 	call	821f0f0 <tse_mac_initTransInfo2>
                                   (unsigned int)sgdma_tx_dev,            
                                   (unsigned int)sgdma_rx_dev,
                                   0);

   /* Reset RX-side SGDMA */
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,
 82245ac:	008209b4 	movhi	r2,2086
 82245b0:	10b71304 	addi	r2,r2,-9140
 82245b4:	e0ffff17 	ldw	r3,-4(fp)
 82245b8:	18c01324 	muli	r3,r3,76
 82245bc:	10c5883a 	add	r2,r2,r3
 82245c0:	10800304 	addi	r2,r2,12
 82245c4:	10800017 	ldw	r2,0(r2)
 82245c8:	10800317 	ldw	r2,12(r2)
 82245cc:	10800404 	addi	r2,r2,16
 82245d0:	00c00074 	movhi	r3,1
 82245d4:	10c00035 	stwio	r3,0(r2)
     ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
 82245d8:	008209b4 	movhi	r2,2086
 82245dc:	10b71304 	addi	r2,r2,-9140
 82245e0:	e0ffff17 	ldw	r3,-4(fp)
 82245e4:	18c01324 	muli	r3,r3,76
 82245e8:	10c5883a 	add	r2,r2,r3
 82245ec:	10800304 	addi	r2,r2,12
 82245f0:	10800017 	ldw	r2,0(r2)
 82245f4:	10800317 	ldw	r2,12(r2)
 82245f8:	10800404 	addi	r2,r2,16
 82245fc:	0007883a 	mov	r3,zero
 8224600:	10c00035 	stwio	r3,0(r2)
   
   tse[iface].interruptNR = tse_hw->tse_sgdma_rx_irq;
 8224604:	e0bff917 	ldw	r2,-28(fp)
 8224608:	1080070b 	ldhu	r2,28(r2)
 822460c:	10ffffcc 	andi	r3,r2,65535
 8224610:	008209b4 	movhi	r2,2086
 8224614:	10b71304 	addi	r2,r2,-9140
 8224618:	e13fff17 	ldw	r4,-4(fp)
 822461c:	21001324 	muli	r4,r4,76
 8224620:	1105883a 	add	r2,r2,r4
 8224624:	10800904 	addi	r2,r2,36
 8224628:	10c00015 	stw	r3,0(r2)

   /* reset the PHY if necessary */   
   result = getPHYSpeed(tse[iface].mi.base);
 822462c:	008209b4 	movhi	r2,2086
 8224630:	10b71304 	addi	r2,r2,-9140
 8224634:	e0ffff17 	ldw	r3,-4(fp)
 8224638:	18c01324 	muli	r3,r3,76
 822463c:	10c5883a 	add	r2,r2,r3
 8224640:	10800104 	addi	r2,r2,4
 8224644:	10800017 	ldw	r2,0(r2)
 8224648:	1009883a 	mov	r4,r2
 822464c:	822057c0 	call	822057c <getPHYSpeed>
 8224650:	e0bffc15 	stw	r2,-16(fp)
   speed = (result >> 1) & 0x07;
 8224654:	e0bffc17 	ldw	r2,-16(fp)
 8224658:	1005d07a 	srai	r2,r2,1
 822465c:	108001cc 	andi	r2,r2,7
 8224660:	e0bffd15 	stw	r2,-12(fp)
   duplex = result & 0x01;
 8224664:	e0bffc17 	ldw	r2,-16(fp)
 8224668:	1080004c 	andi	r2,r2,1
 822466c:	e0bffe15 	stw	r2,-8(fp)
    
   /* reset the mac */ 
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
 8224670:	008209b4 	movhi	r2,2086
 8224674:	10b71304 	addi	r2,r2,-9140
 8224678:	e0ffff17 	ldw	r3,-4(fp)
 822467c:	18c01324 	muli	r3,r3,76
 8224680:	10c5883a 	add	r2,r2,r3
 8224684:	10800104 	addi	r2,r2,4
 8224688:	10800017 	ldw	r2,0(r2)
 822468c:	10800204 	addi	r2,r2,8
 8224690:	00c800c4 	movi	r3,8195
 8224694:	10c00035 	stwio	r3,0(r2)
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
 8224698:	e03ff415 	stw	zero,-48(fp)
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 822469c:	00000506 	br	82246b4 <tse_mac_init+0x274>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
 82246a0:	e0bff417 	ldw	r2,-48(fp)
 82246a4:	10c00044 	addi	r3,r2,1
 82246a8:	e0fff415 	stw	r3,-48(fp)
 82246ac:	1089c450 	cmplti	r2,r2,10001
 82246b0:	10000c26 	beq	r2,zero,82246e4 <tse_mac_init+0x2a4>
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 82246b4:	008209b4 	movhi	r2,2086
 82246b8:	10b71304 	addi	r2,r2,-9140
 82246bc:	e0ffff17 	ldw	r3,-4(fp)
 82246c0:	18c01324 	muli	r3,r3,76
 82246c4:	10c5883a 	add	r2,r2,r3
 82246c8:	10800104 	addi	r2,r2,4
 82246cc:	10800017 	ldw	r2,0(r2)
 82246d0:	10800204 	addi	r2,r2,8
 82246d4:	10800037 	ldwio	r2,0(r2)
 82246d8:	1088000c 	andi	r2,r2,8192
 82246dc:	103ff01e 	bne	r2,zero,82246a0 <tse_mac_init+0x260>
 82246e0:	00000106 	br	82246e8 <tse_mac_init+0x2a8>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
       break;
 82246e4:	0001883a 	nop
     }
   }
   if(x >= 10000) {
 82246e8:	e0bff417 	ldw	r2,-48(fp)
 82246ec:	1089c410 	cmplti	r2,r2,10000
 82246f0:	1000031e 	bne	r2,zero,8224700 <tse_mac_init+0x2c0>
     dprintf("TSEMAC SW reset bit never cleared!\n");
 82246f4:	01020974 	movhi	r4,2085
 82246f8:	213f0504 	addi	r4,r4,-1004
 82246fc:	82035a00 	call	82035a0 <puts>
   }

   dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 8224700:	008209b4 	movhi	r2,2086
 8224704:	10b71304 	addi	r2,r2,-9140
 8224708:	e0ffff17 	ldw	r3,-4(fp)
 822470c:	18c01324 	muli	r3,r3,76
 8224710:	10c5883a 	add	r2,r2,r3
 8224714:	10800104 	addi	r2,r2,4
 8224718:	10800017 	ldw	r2,0(r2)
 822471c:	10800204 	addi	r2,r2,8
 8224720:	10800037 	ldwio	r2,0(r2)
 8224724:	e0bff315 	stw	r2,-52(fp)
   if( (dat & 0x03) != 0 ) {
 8224728:	e0bff317 	ldw	r2,-52(fp)
 822472c:	108000cc 	andi	r2,r2,3
 8224730:	10000526 	beq	r2,zero,8224748 <tse_mac_init+0x308>
     dprintf("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat);
 8224734:	e17ff317 	ldw	r5,-52(fp)
 8224738:	01020974 	movhi	r4,2085
 822473c:	213f0e04 	addi	r4,r4,-968
 8224740:	820331c0 	call	820331c <printf>
 8224744:	00000506 	br	822475c <tse_mac_init+0x31c>
   } 
   else {
     dprintf("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat);
 8224748:	e1bff317 	ldw	r6,-52(fp)
 822474c:	e17ff417 	ldw	r5,-48(fp)
 8224750:	01020974 	movhi	r4,2085
 8224754:	213f2204 	addi	r4,r4,-888
 8224758:	820331c0 	call	820331c <printf>
  
    /* Hack code to determine the Channel number <- Someone please fix this ugly code in the future */
    extern alt_u8 mac_group_count;
    extern alt_tse_mac_group *pmac_groups[TSE_MAX_MAC_IN_SYSTEM];
      
    if(tse_hw->use_shared_fifo == 1) {
 822475c:	e0bff917 	ldw	r2,-28(fp)
 8224760:	10800903 	ldbu	r2,36(r2)
 8224764:	10803fcc 	andi	r2,r2,255
 8224768:	10800058 	cmpnei	r2,r2,1
 822476c:	1000331e 	bne	r2,zero,822483c <tse_mac_init+0x3fc>
      int channel_loop = 0;
 8224770:	e03ff615 	stw	zero,-40(fp)
      int mac_loop = 0;
 8224774:	e03ff715 	stw	zero,-36(fp)
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 8224778:	e03ff615 	stw	zero,-40(fp)
 822477c:	00002b06 	br	822482c <tse_mac_init+0x3ec>
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 8224780:	e03ff715 	stw	zero,-36(fp)
 8224784:	00001b06 	br	82247f4 <tse_mac_init+0x3b4>
          if (pmac_groups[channel_loop]->pmac_info[mac_loop]->psys_info == tse_hw) {
 8224788:	008209b4 	movhi	r2,2086
 822478c:	10b6ff04 	addi	r2,r2,-9220
 8224790:	e0fff617 	ldw	r3,-40(fp)
 8224794:	18c7883a 	add	r3,r3,r3
 8224798:	18c7883a 	add	r3,r3,r3
 822479c:	10c5883a 	add	r2,r2,r3
 82247a0:	10c00017 	ldw	r3,0(r2)
 82247a4:	e0bff717 	ldw	r2,-36(fp)
 82247a8:	10800044 	addi	r2,r2,1
 82247ac:	1085883a 	add	r2,r2,r2
 82247b0:	1085883a 	add	r2,r2,r2
 82247b4:	1885883a 	add	r2,r3,r2
 82247b8:	10800017 	ldw	r2,0(r2)
 82247bc:	10c00217 	ldw	r3,8(r2)
 82247c0:	e0bff917 	ldw	r2,-28(fp)
 82247c4:	1880081e 	bne	r3,r2,82247e8 <tse_mac_init+0x3a8>
            tse[iface].channel = mac_loop;
 82247c8:	008209b4 	movhi	r2,2086
 82247cc:	10b71304 	addi	r2,r2,-9140
 82247d0:	e0ffff17 	ldw	r3,-4(fp)
 82247d4:	18c01324 	muli	r3,r3,76
 82247d8:	10c5883a 	add	r2,r2,r3
 82247dc:	10800d04 	addi	r2,r2,52
 82247e0:	e0fff717 	ldw	r3,-36(fp)
 82247e4:	10c00015 	stw	r3,0(r2)
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 82247e8:	e0bff717 	ldw	r2,-36(fp)
 82247ec:	10800044 	addi	r2,r2,1
 82247f0:	e0bff715 	stw	r2,-36(fp)
 82247f4:	008209b4 	movhi	r2,2086
 82247f8:	10b6ff04 	addi	r2,r2,-9220
 82247fc:	e0fff617 	ldw	r3,-40(fp)
 8224800:	18c7883a 	add	r3,r3,r3
 8224804:	18c7883a 	add	r3,r3,r3
 8224808:	10c5883a 	add	r2,r2,r3
 822480c:	10800017 	ldw	r2,0(r2)
 8224810:	10800003 	ldbu	r2,0(r2)
 8224814:	10803fcc 	andi	r2,r2,255
 8224818:	e0fff717 	ldw	r3,-36(fp)
 822481c:	18bfda16 	blt	r3,r2,8224788 <tse_mac_init+0x348>
      
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 8224820:	e0bff617 	ldw	r2,-40(fp)
 8224824:	10800044 	addi	r2,r2,1
 8224828:	e0bff615 	stw	r2,-40(fp)
 822482c:	d0a07f43 	ldbu	r2,-32259(gp)
 8224830:	10803fcc 	andi	r2,r2,255
 8224834:	e0fff617 	ldw	r3,-40(fp)
 8224838:	18bfd116 	blt	r3,r2,8224780 <tse_mac_init+0x340>
        }
      }
    }
    /* End of Hack code */
  
  if(tse_hw->use_shared_fifo == 1) {
 822483c:	e0bff917 	ldw	r2,-28(fp)
 8224840:	10800903 	ldbu	r2,36(r2)
 8224844:	10803fcc 	andi	r2,r2,255
 8224848:	10800058 	cmpnei	r2,r2,1
 822484c:	10000f1e 	bne	r2,zero,822488c <tse_mac_init+0x44c>
      IOWR_ALTERA_MULTI_CHAN_FIFO_SEC_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,tse_hw->tse_shared_fifo_rx_depth);
 8224850:	e0bff917 	ldw	r2,-28(fp)
 8224854:	10800d17 	ldw	r2,52(r2)
 8224858:	1007883a 	mov	r3,r2
 822485c:	e0bff917 	ldw	r2,-28(fp)
 8224860:	10800f17 	ldw	r2,60(r2)
 8224864:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_MULTI_CHAN_FIFO_ALMOST_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,((tse_hw->tse_shared_fifo_rx_depth) - 140));
 8224868:	e0bff917 	ldw	r2,-28(fp)
 822486c:	10800d17 	ldw	r2,52(r2)
 8224870:	10800204 	addi	r2,r2,8
 8224874:	1007883a 	mov	r3,r2
 8224878:	e0bff917 	ldw	r2,-28(fp)
 822487c:	10800f17 	ldw	r2,60(r2)
 8224880:	10bfdd04 	addi	r2,r2,-140
 8224884:	18800035 	stwio	r2,0(r3)
 8224888:	00006006 	br	8224a0c <tse_mac_init+0x5cc>
  }
  else {
      /* Initialize MAC registers */
      IOWR_ALTERA_TSEMAC_FRM_LENGTH(tse[iface].mi.base, ALTERA_TSE_MAC_MAX_FRAME_LENGTH); 
 822488c:	008209b4 	movhi	r2,2086
 8224890:	10b71304 	addi	r2,r2,-9140
 8224894:	e0ffff17 	ldw	r3,-4(fp)
 8224898:	18c01324 	muli	r3,r3,76
 822489c:	10c5883a 	add	r2,r2,r3
 82248a0:	10800104 	addi	r2,r2,4
 82248a4:	10800017 	ldw	r2,0(r2)
 82248a8:	10800504 	addi	r2,r2,20
 82248ac:	00c17b84 	movi	r3,1518
 82248b0:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 82248b4:	008209b4 	movhi	r2,2086
 82248b8:	10b71304 	addi	r2,r2,-9140
 82248bc:	e0ffff17 	ldw	r3,-4(fp)
 82248c0:	18c01324 	muli	r3,r3,76
 82248c4:	10c5883a 	add	r2,r2,r3
 82248c8:	10800104 	addi	r2,r2,4
 82248cc:	10800017 	ldw	r2,0(r2)
 82248d0:	10800b04 	addi	r2,r2,44
 82248d4:	00c00204 	movi	r3,8
 82248d8:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(tse[iface].mi.base, 8);
 82248dc:	008209b4 	movhi	r2,2086
 82248e0:	10b71304 	addi	r2,r2,-9140
 82248e4:	e0ffff17 	ldw	r3,-4(fp)
 82248e8:	18c01324 	muli	r3,r3,76
 82248ec:	10c5883a 	add	r2,r2,r3
 82248f0:	10800104 	addi	r2,r2,4
 82248f4:	10800017 	ldw	r2,0(r2)
 82248f8:	10800c04 	addi	r2,r2,48
 82248fc:	00c00204 	movi	r3,8
 8224900:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 8224904:	008209b4 	movhi	r2,2086
 8224908:	10b71304 	addi	r2,r2,-9140
 822490c:	e0ffff17 	ldw	r3,-4(fp)
 8224910:	18c01324 	muli	r3,r3,76
 8224914:	10c5883a 	add	r2,r2,r3
 8224918:	10800104 	addi	r2,r2,4
 822491c:	10800017 	ldw	r2,0(r2)
 8224920:	10800d04 	addi	r2,r2,52
 8224924:	00c00204 	movi	r3,8
 8224928:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(tse[iface].mi.base,  3);
 822492c:	008209b4 	movhi	r2,2086
 8224930:	10b71304 	addi	r2,r2,-9140
 8224934:	e0ffff17 	ldw	r3,-4(fp)
 8224938:	18c01324 	muli	r3,r3,76
 822493c:	10c5883a 	add	r2,r2,r3
 8224940:	10800104 	addi	r2,r2,4
 8224944:	10800017 	ldw	r2,0(r2)
 8224948:	10800e04 	addi	r2,r2,56
 822494c:	00c000c4 	movi	r3,3
 8224950:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_tx_depth - 16); //1024/4;  
 8224954:	008209b4 	movhi	r2,2086
 8224958:	10b71304 	addi	r2,r2,-9140
 822495c:	e0ffff17 	ldw	r3,-4(fp)
 8224960:	18c01324 	muli	r3,r3,76
 8224964:	10c5883a 	add	r2,r2,r3
 8224968:	10800104 	addi	r2,r2,4
 822496c:	10800017 	ldw	r2,0(r2)
 8224970:	10800904 	addi	r2,r2,36
 8224974:	e0fff917 	ldw	r3,-28(fp)
 8224978:	18c0010b 	ldhu	r3,4(r3)
 822497c:	18ffffcc 	andi	r3,r3,65535
 8224980:	18fffc04 	addi	r3,r3,-16
 8224984:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(tse[iface].mi.base,  0); //32/4; // start transmit when there are 48 bytes
 8224988:	008209b4 	movhi	r2,2086
 822498c:	10b71304 	addi	r2,r2,-9140
 8224990:	e0ffff17 	ldw	r3,-4(fp)
 8224994:	18c01324 	muli	r3,r3,76
 8224998:	10c5883a 	add	r2,r2,r3
 822499c:	10800104 	addi	r2,r2,4
 82249a0:	10800017 	ldw	r2,0(r2)
 82249a4:	10800a04 	addi	r2,r2,40
 82249a8:	0007883a 	mov	r3,zero
 82249ac:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_rx_depth - 16); //4000/4);
 82249b0:	008209b4 	movhi	r2,2086
 82249b4:	10b71304 	addi	r2,r2,-9140
 82249b8:	e0ffff17 	ldw	r3,-4(fp)
 82249bc:	18c01324 	muli	r3,r3,76
 82249c0:	10c5883a 	add	r2,r2,r3
 82249c4:	10800104 	addi	r2,r2,4
 82249c8:	10800017 	ldw	r2,0(r2)
 82249cc:	10800704 	addi	r2,r2,28
 82249d0:	e0fff917 	ldw	r3,-28(fp)
 82249d4:	18c0018b 	ldhu	r3,6(r3)
 82249d8:	18ffffcc 	andi	r3,r3,65535
 82249dc:	18fffc04 	addi	r3,r3,-16
 82249e0:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(tse[iface].mi.base,  0);
 82249e4:	008209b4 	movhi	r2,2086
 82249e8:	10b71304 	addi	r2,r2,-9140
 82249ec:	e0ffff17 	ldw	r3,-4(fp)
 82249f0:	18c01324 	muli	r3,r3,76
 82249f4:	10c5883a 	add	r2,r2,r3
 82249f8:	10800104 	addi	r2,r2,4
 82249fc:	10800017 	ldw	r2,0(r2)
 8224a00:	10800804 	addi	r2,r2,32
 8224a04:	0007883a 	mov	r3,zero
 8224a08:	10c00035 	stwio	r3,0(r2)
      tse[iface].rxShift16OK = 0;
    }
  } /* if(ETHHDR_BIAS == 0) */
 
  if(ETHHDR_BIAS == 2) {
    IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
 8224a0c:	008209b4 	movhi	r2,2086
 8224a10:	10b71304 	addi	r2,r2,-9140
 8224a14:	e0ffff17 	ldw	r3,-4(fp)
 8224a18:	18c01324 	muli	r3,r3,76
 8224a1c:	10c5883a 	add	r2,r2,r3
 8224a20:	10800104 	addi	r2,r2,4
 8224a24:	10800017 	ldw	r2,0(r2)
 8224a28:	10803a04 	addi	r2,r2,232
 8224a2c:	00c00134 	movhi	r3,4
 8224a30:	10c00035 	stwio	r3,0(r2)
 
    /*
     * check if the MAC supports the 16-bit shift option allowing us
     * to send BIASed frames without copying. Used by the send function later.
     */
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
 8224a34:	008209b4 	movhi	r2,2086
 8224a38:	10b71304 	addi	r2,r2,-9140
 8224a3c:	e0ffff17 	ldw	r3,-4(fp)
 8224a40:	18c01324 	muli	r3,r3,76
 8224a44:	10c5883a 	add	r2,r2,r3
 8224a48:	10800104 	addi	r2,r2,4
 8224a4c:	10800017 	ldw	r2,0(r2)
 8224a50:	10803a04 	addi	r2,r2,232
 8224a54:	10800037 	ldwio	r2,0(r2)
 8224a58:	1080012c 	andhi	r2,r2,4
 8224a5c:	10001e26 	beq	r2,zero,8224ad8 <tse_mac_init+0x698>
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
 8224a60:	008209b4 	movhi	r2,2086
 8224a64:	10b71304 	addi	r2,r2,-9140
 8224a68:	e0ffff17 	ldw	r3,-4(fp)
 8224a6c:	18c01324 	muli	r3,r3,76
 8224a70:	10c5883a 	add	r2,r2,r3
 8224a74:	10800a04 	addi	r2,r2,40
 8224a78:	00c00044 	movi	r3,1
 8224a7c:	10c00015 	stw	r3,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
      return ENP_LOGIC;
    }
  
    /* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 8224a80:	008209b4 	movhi	r2,2086
 8224a84:	10b71304 	addi	r2,r2,-9140
 8224a88:	e0ffff17 	ldw	r3,-4(fp)
 8224a8c:	18c01324 	muli	r3,r3,76
 8224a90:	10c5883a 	add	r2,r2,r3
 8224a94:	10800104 	addi	r2,r2,4
 8224a98:	10800017 	ldw	r2,0(r2)
 8224a9c:	10803b04 	addi	r2,r2,236
 8224aa0:	00c08034 	movhi	r3,512
 8224aa4:	10c00035 	stwio	r3,0(r2)
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
 8224aa8:	008209b4 	movhi	r2,2086
 8224aac:	10b71304 	addi	r2,r2,-9140
 8224ab0:	e0ffff17 	ldw	r3,-4(fp)
 8224ab4:	18c01324 	muli	r3,r3,76
 8224ab8:	10c5883a 	add	r2,r2,r3
 8224abc:	10800104 	addi	r2,r2,4
 8224ac0:	10800017 	ldw	r2,0(r2)
 8224ac4:	10803b04 	addi	r2,r2,236
 8224ac8:	10800037 	ldwio	r2,0(r2)
 8224acc:	1080802c 	andhi	r2,r2,512
 8224ad0:	10001d26 	beq	r2,zero,8224b48 <tse_mac_init+0x708>
 8224ad4:	00000d06 	br	8224b0c <tse_mac_init+0x6cc>
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
    } 
    else {
      tse[iface].txShift16OK = 0;
 8224ad8:	008209b4 	movhi	r2,2086
 8224adc:	10b71304 	addi	r2,r2,-9140
 8224ae0:	e0ffff17 	ldw	r3,-4(fp)
 8224ae4:	18c01324 	muli	r3,r3,76
 8224ae8:	10c5883a 	add	r2,r2,r3
 8224aec:	10800a04 	addi	r2,r2,40
 8224af0:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
 8224af4:	01400084 	movi	r5,2
 8224af8:	01020974 	movhi	r4,2085
 8224afc:	213f2a04 	addi	r4,r4,-856
 8224b00:	820331c0 	call	820331c <printf>
      return ENP_LOGIC;
 8224b04:	00bffd44 	movi	r2,-11
 8224b08:	0000e006 	br	8224e8c <tse_mac_init+0xa4c>
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
 8224b0c:	008209b4 	movhi	r2,2086
 8224b10:	10b71304 	addi	r2,r2,-9140
 8224b14:	e0ffff17 	ldw	r3,-4(fp)
 8224b18:	18c01324 	muli	r3,r3,76
 8224b1c:	10c5883a 	add	r2,r2,r3
 8224b20:	10800b04 	addi	r2,r2,44
 8224b24:	00c00044 	movi	r3,1
 8224b28:	10c00015 	stw	r3,0(r2)
      return ENP_LOGIC;
    }
  } /* if(ETHHDR_BIAS == 2) */
  
  /* enable MAC */
  dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
 8224b2c:	00810034 	movhi	r2,1024
 8224b30:	108080c4 	addi	r2,r2,515
 8224b34:	e0bff315 	stw	r2,-52(fp)
        ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
 8224b38:	e0bffd17 	ldw	r2,-12(fp)
 8224b3c:	10800058 	cmpnei	r2,r2,1
 8224b40:	1000171e 	bne	r2,zero,8224ba0 <tse_mac_init+0x760>
 8224b44:	00000d06 	br	8224b7c <tse_mac_init+0x73c>
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
    } 
    else {
      tse[iface].rxShift16OK = 0;
 8224b48:	008209b4 	movhi	r2,2086
 8224b4c:	10b71304 	addi	r2,r2,-9140
 8224b50:	e0ffff17 	ldw	r3,-4(fp)
 8224b54:	18c01324 	muli	r3,r3,76
 8224b58:	10c5883a 	add	r2,r2,r3
 8224b5c:	10800b04 	addi	r2,r2,44
 8224b60:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETHHDR_BIAS);
 8224b64:	01400084 	movi	r5,2
 8224b68:	01020974 	movhi	r4,2085
 8224b6c:	213f4204 	addi	r4,r4,-760
 8224b70:	820331c0 	call	820331c <printf>
      return ENP_LOGIC;
 8224b74:	00bffd44 	movi	r2,-11
 8224b78:	0000c406 	br	8224e8c <tse_mac_init+0xa4c>
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
    dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8224b7c:	e0bff317 	ldw	r2,-52(fp)
 8224b80:	10800214 	ori	r2,r2,8
 8224b84:	e0bff315 	stw	r2,-52(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224b88:	e0fff317 	ldw	r3,-52(fp)
 8224b8c:	00bf8034 	movhi	r2,65024
 8224b90:	10bfffc4 	addi	r2,r2,-1
 8224b94:	1884703a 	and	r2,r3,r2
 8224b98:	e0bff315 	stw	r2,-52(fp)
 8224b9c:	00002106 	br	8224c24 <tse_mac_init+0x7e4>
  }
  /* 100 Mbps */
  else if(speed == 0x02) {
 8224ba0:	e0bffd17 	ldw	r2,-12(fp)
 8224ba4:	10800098 	cmpnei	r2,r2,2
 8224ba8:	10000a1e 	bne	r2,zero,8224bd4 <tse_mac_init+0x794>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8224bac:	e0fff317 	ldw	r3,-52(fp)
 8224bb0:	00bffdc4 	movi	r2,-9
 8224bb4:	1884703a 	and	r2,r3,r2
 8224bb8:	e0bff315 	stw	r2,-52(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224bbc:	e0fff317 	ldw	r3,-52(fp)
 8224bc0:	00bf8034 	movhi	r2,65024
 8224bc4:	10bfffc4 	addi	r2,r2,-1
 8224bc8:	1884703a 	and	r2,r3,r2
 8224bcc:	e0bff315 	stw	r2,-52(fp)
 8224bd0:	00001406 	br	8224c24 <tse_mac_init+0x7e4>
  }
  /* 10 Mbps */
  else if(speed == 0x04) {
 8224bd4:	e0bffd17 	ldw	r2,-12(fp)
 8224bd8:	10800118 	cmpnei	r2,r2,4
 8224bdc:	1000081e 	bne	r2,zero,8224c00 <tse_mac_init+0x7c0>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8224be0:	e0fff317 	ldw	r3,-52(fp)
 8224be4:	00bffdc4 	movi	r2,-9
 8224be8:	1884703a 	and	r2,r3,r2
 8224bec:	e0bff315 	stw	r2,-52(fp)
	dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224bf0:	e0bff317 	ldw	r2,-52(fp)
 8224bf4:	10808034 	orhi	r2,r2,512
 8224bf8:	e0bff315 	stw	r2,-52(fp)
 8224bfc:	00000906 	br	8224c24 <tse_mac_init+0x7e4>
  }
  /* default to 100 Mbps if returned invalid speed */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 8224c00:	e0fff317 	ldw	r3,-52(fp)
 8224c04:	00bffdc4 	movi	r2,-9
 8224c08:	1884703a 	and	r2,r3,r2
 8224c0c:	e0bff315 	stw	r2,-52(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 8224c10:	e0fff317 	ldw	r3,-52(fp)
 8224c14:	00bf8034 	movhi	r2,65024
 8224c18:	10bfffc4 	addi	r2,r2,-1
 8224c1c:	1884703a 	and	r2,r3,r2
 8224c20:	e0bff315 	stw	r2,-52(fp)
  }
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 8224c24:	e0bffe17 	ldw	r2,-8(fp)
 8224c28:	1000041e 	bne	r2,zero,8224c3c <tse_mac_init+0x7fc>
    dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8224c2c:	e0bff317 	ldw	r2,-52(fp)
 8224c30:	10810014 	ori	r2,r2,1024
 8224c34:	e0bff315 	stw	r2,-52(fp)
 8224c38:	00000406 	br	8224c4c <tse_mac_init+0x80c>
  }
  /* Full Duplex */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 8224c3c:	e0fff317 	ldw	r3,-52(fp)
 8224c40:	00beffc4 	movi	r2,-1025
 8224c44:	1884703a 	and	r2,r3,r2
 8224c48:	e0bff315 	stw	r2,-52(fp)
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
 8224c4c:	008209b4 	movhi	r2,2086
 8224c50:	10b71304 	addi	r2,r2,-9140
 8224c54:	e0ffff17 	ldw	r3,-4(fp)
 8224c58:	18c01324 	muli	r3,r3,76
 8224c5c:	10c5883a 	add	r2,r2,r3
 8224c60:	10800104 	addi	r2,r2,4
 8224c64:	10800017 	ldw	r2,0(r2)
 8224c68:	10800204 	addi	r2,r2,8
 8224c6c:	e0fff317 	ldw	r3,-52(fp)
 8224c70:	10c00035 	stwio	r3,0(r2)
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
 8224c74:	008209b4 	movhi	r2,2086
 8224c78:	10b71304 	addi	r2,r2,-9140
 8224c7c:	e0ffff17 	ldw	r3,-4(fp)
 8224c80:	18c01324 	muli	r3,r3,76
 8224c84:	10c5883a 	add	r2,r2,r3
 8224c88:	10800104 	addi	r2,r2,4
 8224c8c:	10800017 	ldw	r2,0(r2)
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
 8224c90:	10800204 	addi	r2,r2,8
 8224c94:	10800037 	ldwio	r2,0(r2)
 8224c98:	100b883a 	mov	r5,r2
 8224c9c:	01020974 	movhi	r4,2085
 8224ca0:	213f5a04 	addi	r4,r4,-664
 8224ca4:	820331c0 	call	820331c <printf>
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
  
                          
#ifdef ALT_INICHE
   /* Set the MAC address */  
   IOWR_ALTERA_TSEMAC_MAC_0(tse[iface].mi.base,
 8224ca8:	008209b4 	movhi	r2,2086
 8224cac:	10b71304 	addi	r2,r2,-9140
 8224cb0:	e0ffff17 	ldw	r3,-4(fp)
 8224cb4:	18c01324 	muli	r3,r3,76
 8224cb8:	10c5883a 	add	r2,r2,r3
 8224cbc:	10800104 	addi	r2,r2,4
 8224cc0:	10800017 	ldw	r2,0(r2)
 8224cc4:	10c00304 	addi	r3,r2,12
 8224cc8:	008209b4 	movhi	r2,2086
 8224ccc:	10b71304 	addi	r2,r2,-9140
 8224cd0:	e13fff17 	ldw	r4,-4(fp)
 8224cd4:	21001324 	muli	r4,r4,76
 8224cd8:	1105883a 	add	r2,r2,r4
 8224cdc:	10800604 	addi	r2,r2,24
 8224ce0:	10800003 	ldbu	r2,0(r2)
 8224ce4:	11003fcc 	andi	r4,r2,255
 8224ce8:	008209b4 	movhi	r2,2086
 8224cec:	10b71304 	addi	r2,r2,-9140
 8224cf0:	e17fff17 	ldw	r5,-4(fp)
 8224cf4:	29401324 	muli	r5,r5,76
 8224cf8:	1145883a 	add	r2,r2,r5
 8224cfc:	10800644 	addi	r2,r2,25
 8224d00:	10800003 	ldbu	r2,0(r2)
 8224d04:	10803fcc 	andi	r2,r2,255
 8224d08:	1004923a 	slli	r2,r2,8
 8224d0c:	2088b03a 	or	r4,r4,r2
 8224d10:	008209b4 	movhi	r2,2086
 8224d14:	10b71304 	addi	r2,r2,-9140
 8224d18:	e17fff17 	ldw	r5,-4(fp)
 8224d1c:	29401324 	muli	r5,r5,76
 8224d20:	1145883a 	add	r2,r2,r5
 8224d24:	10800684 	addi	r2,r2,26
 8224d28:	10800003 	ldbu	r2,0(r2)
 8224d2c:	10803fcc 	andi	r2,r2,255
 8224d30:	1004943a 	slli	r2,r2,16
 8224d34:	2088b03a 	or	r4,r4,r2
 8224d38:	008209b4 	movhi	r2,2086
 8224d3c:	10b71304 	addi	r2,r2,-9140
 8224d40:	e17fff17 	ldw	r5,-4(fp)
 8224d44:	29401324 	muli	r5,r5,76
 8224d48:	1145883a 	add	r2,r2,r5
 8224d4c:	108006c4 	addi	r2,r2,27
 8224d50:	10800003 	ldbu	r2,0(r2)
 8224d54:	10803fcc 	andi	r2,r2,255
 8224d58:	1004963a 	slli	r2,r2,24
 8224d5c:	2084b03a 	or	r2,r4,r2
 8224d60:	18800035 	stwio	r2,0(r3)
                           ((int)((unsigned char) tse[iface].mac_addr[0]) | 
                            (int)((unsigned char) tse[iface].mac_addr[1] <<  8) |
                            (int)((unsigned char) tse[iface].mac_addr[2] << 16) | 
                            (int)((unsigned char) tse[iface].mac_addr[3] << 24)));
  
   IOWR_ALTERA_TSEMAC_MAC_1(tse[iface].mi.base, 
 8224d64:	008209b4 	movhi	r2,2086
 8224d68:	10b71304 	addi	r2,r2,-9140
 8224d6c:	e0ffff17 	ldw	r3,-4(fp)
 8224d70:	18c01324 	muli	r3,r3,76
 8224d74:	10c5883a 	add	r2,r2,r3
 8224d78:	10800104 	addi	r2,r2,4
 8224d7c:	10800017 	ldw	r2,0(r2)
 8224d80:	10c00404 	addi	r3,r2,16
 8224d84:	008209b4 	movhi	r2,2086
 8224d88:	10b71304 	addi	r2,r2,-9140
 8224d8c:	e13fff17 	ldw	r4,-4(fp)
 8224d90:	21001324 	muli	r4,r4,76
 8224d94:	1105883a 	add	r2,r2,r4
 8224d98:	10800704 	addi	r2,r2,28
 8224d9c:	10800003 	ldbu	r2,0(r2)
 8224da0:	11003fcc 	andi	r4,r2,255
 8224da4:	008209b4 	movhi	r2,2086
 8224da8:	10b71304 	addi	r2,r2,-9140
 8224dac:	e17fff17 	ldw	r5,-4(fp)
 8224db0:	29401324 	muli	r5,r5,76
 8224db4:	1145883a 	add	r2,r2,r5
 8224db8:	10800744 	addi	r2,r2,29
 8224dbc:	10800003 	ldbu	r2,0(r2)
 8224dc0:	10803fcc 	andi	r2,r2,255
 8224dc4:	1004923a 	slli	r2,r2,8
 8224dc8:	2084b03a 	or	r2,r4,r2
 8224dcc:	10bfffcc 	andi	r2,r2,65535
 8224dd0:	18800035 	stwio	r2,0(r3)
   tse[iface].mac_addr[5] = 0xBA;

#endif /* not ALT_INICHE */

   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
 8224dd4:	008209b4 	movhi	r2,2086
 8224dd8:	10b82404 	addi	r2,r2,-8048
 8224ddc:	e0ffff17 	ldw	r3,-4(fp)
 8224de0:	18c7883a 	add	r3,r3,r3
 8224de4:	18c7883a 	add	r3,r3,r3
 8224de8:	10c5883a 	add	r2,r2,r3
 8224dec:	10800017 	ldw	r2,0(r2)
 8224df0:	10802717 	ldw	r2,156(r2)
 8224df4:	00c00044 	movi	r3,1
 8224df8:	10c00615 	stw	r3,24(r2)
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
 8224dfc:	008209b4 	movhi	r2,2086
 8224e00:	10b82404 	addi	r2,r2,-8048
 8224e04:	e0ffff17 	ldw	r3,-4(fp)
 8224e08:	18c7883a 	add	r3,r3,r3
 8224e0c:	18c7883a 	add	r3,r3,r3
 8224e10:	10c5883a 	add	r2,r2,r3
 8224e14:	10800017 	ldw	r2,0(r2)
 8224e18:	10802717 	ldw	r2,156(r2)
 8224e1c:	00c00044 	movi	r3,1
 8224e20:	10c00715 	stw	r3,28(r2)
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 8224e24:	008209b4 	movhi	r2,2086
 8224e28:	10b71304 	addi	r2,r2,-9140
 8224e2c:	e0ffff17 	ldw	r3,-4(fp)
 8224e30:	18c01324 	muli	r3,r3,76
 8224e34:	10c5883a 	add	r2,r2,r3
 8224e38:	10800304 	addi	r2,r2,12
 8224e3c:	11000017 	ldw	r4,0(r2)
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
 8224e40:	e0bfff17 	ldw	r2,-4(fp)
 8224e44:	10c01324 	muli	r3,r2,76
 8224e48:	008209b4 	movhi	r2,2086
 8224e4c:	10b71304 	addi	r2,r2,-9140
 8224e50:	1885883a 	add	r2,r3,r2
   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 8224e54:	100f883a 	mov	r7,r2
 8224e58:	01800604 	movi	r6,24
 8224e5c:	014208b4 	movhi	r5,2082
 8224e60:	29546604 	addi	r5,r5,20888
 8224e64:	821e7840 	call	821e784 <alt_avalon_sgdma_register_callback>
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
    
  status = tse_sgdma_read_init(&tse[iface]);
 8224e68:	e0bfff17 	ldw	r2,-4(fp)
 8224e6c:	10c01324 	muli	r3,r2,76
 8224e70:	008209b4 	movhi	r2,2086
 8224e74:	10b71304 	addi	r2,r2,-9140
 8224e78:	1885883a 	add	r2,r3,r2
 8224e7c:	1009883a 	mov	r4,r2
 8224e80:	82252440 	call	8225244 <tse_sgdma_read_init>
 8224e84:	e0bff815 	stw	r2,-32(fp)
  
  return status;
 8224e88:	e0bff817 	ldw	r2,-32(fp)
}
 8224e8c:	e037883a 	mov	sp,fp
 8224e90:	dfc00117 	ldw	ra,4(sp)
 8224e94:	df000017 	ldw	fp,0(sp)
 8224e98:	dec00204 	addi	sp,sp,8
 8224e9c:	f800283a 	ret

08224ea0 <tse_mac_raw_send>:
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
int tse_mac_raw_send(NET net, char * data, unsigned data_bytes)
{
 8224ea0:	defe6504 	addi	sp,sp,-1644
 8224ea4:	dfc19a15 	stw	ra,1640(sp)
 8224ea8:	df019915 	stw	fp,1636(sp)
 8224eac:	df019904 	addi	fp,sp,1636
 8224eb0:	e13ffd15 	stw	r4,-12(fp)
 8224eb4:	e17ffe15 	stw	r5,-8(fp)
 8224eb8:	e1bfff15 	stw	r6,-4(fp)
   int result,i;
   unsigned len = data_bytes;
 8224ebc:	e0bfff17 	ldw	r2,-4(fp)
 8224ec0:	e0be6e15 	stw	r2,-1608(fp)

   ins_tse_info* tse_ptr = (ins_tse_info*) net->n_local;
 8224ec4:	e0bffd17 	ldw	r2,-12(fp)
 8224ec8:	10802817 	ldw	r2,160(r2)
 8224ecc:	e0be6f15 	stw	r2,-1604(fp)

   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse_ptr->tse;
 8224ed0:	e0be6f17 	ldw	r2,-1604(fp)
 8224ed4:	10801217 	ldw	r2,72(r2)
 8224ed8:	e0be7015 	stw	r2,-1600(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 8224edc:	0005303a 	rdctl	r2,status
 8224ee0:	e0be7615 	stw	r2,-1576(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8224ee4:	e0fe7617 	ldw	r3,-1576(fp)
 8224ee8:	00bfff84 	movi	r2,-2
 8224eec:	1884703a 	and	r2,r3,r2
 8224ef0:	1001703a 	wrctl	status,r2
  
  return context;
 8224ef4:	e0be7617 	ldw	r2,-1576(fp)
   unsigned int* ActualData;
   int cpu_sr;
   /* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
   char buf2[1560];

   OS_ENTER_CRITICAL();
 8224ef8:	e0be7215 	stw	r2,-1592(fp)
   mi = &tse_ptr->mi;
 8224efc:	e0be6f17 	ldw	r2,-1604(fp)
 8224f00:	10800104 	addi	r2,r2,4
 8224f04:	e0be7315 	stw	r2,-1588(fp)
   
   if(tse_ptr->sem!=0) /* Tx is busy*/
 8224f08:	e0be6f17 	ldw	r2,-1604(fp)
 8224f0c:	10800c17 	ldw	r2,48(r2)
 8224f10:	10000926 	beq	r2,zero,8224f38 <tse_mac_raw_send+0x98>
   {
      dprintf("raw_send CALLED AGAIN!!!\n");
 8224f14:	01020974 	movhi	r4,2085
 8224f18:	213f6604 	addi	r4,r4,-616
 8224f1c:	82035a00 	call	82035a0 <puts>
 8224f20:	e0be7217 	ldw	r2,-1592(fp)
 8224f24:	e0be7115 	stw	r2,-1596(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 8224f28:	e0be7117 	ldw	r2,-1596(fp)
 8224f2c:	1001703a 	wrctl	status,r2
      OS_EXIT_CRITICAL();
      return ENP_RESOURCE;
 8224f30:	00bffa84 	movi	r2,-22
 8224f34:	00009306 	br	8225184 <tse_mac_raw_send+0x2e4>
   }
 
   tse_ptr->sem = 1;  
 8224f38:	e0be6f17 	ldw	r2,-1604(fp)
 8224f3c:	00c00044 	movi	r3,1
 8224f40:	10c00c15 	stw	r3,48(r2)

   if(((unsigned long)data & 0x03) == 0) 
 8224f44:	e0bffe17 	ldw	r2,-8(fp)
 8224f48:	108000cc 	andi	r2,r2,3
 8224f4c:	1000031e 	bne	r2,zero,8224f5c <tse_mac_raw_send+0xbc>
   { 
      /* 32-bit aligned start, then header starts ETHHDR_BIAS later => 16 bit shift is ok */    
      ActualData = (unsigned int*)data;  /* base driver will detect 16-bit shift. */
 8224f50:	e0bffe17 	ldw	r2,-8(fp)
 8224f54:	e0be6d15 	stw	r2,-1612(fp)
 8224f58:	00001406 	br	8224fac <tse_mac_raw_send+0x10c>
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 8224f5c:	e03e6c15 	stw	zero,-1616(fp)
 8224f60:	00000d06 	br	8224f98 <tse_mac_raw_send+0xf8>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
 8224f64:	e0be6c17 	ldw	r2,-1616(fp)
 8224f68:	e0fffe17 	ldw	r3,-8(fp)
 8224f6c:	1885883a 	add	r2,r3,r2
 8224f70:	10800023 	ldbuio	r2,0(r2)
 8224f74:	10803fcc 	andi	r2,r2,255
 8224f78:	1009883a 	mov	r4,r2
 8224f7c:	e0fe7704 	addi	r3,fp,-1572
 8224f80:	e0be6c17 	ldw	r2,-1616(fp)
 8224f84:	1885883a 	add	r2,r3,r2
 8224f88:	11000005 	stb	r4,0(r2)
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 8224f8c:	e0be6c17 	ldw	r2,-1616(fp)
 8224f90:	10800044 	addi	r2,r2,1
 8224f94:	e0be6c15 	stw	r2,-1616(fp)
 8224f98:	e0fe6c17 	ldw	r3,-1616(fp)
 8224f9c:	e0be6e17 	ldw	r2,-1608(fp)
 8224fa0:	18bff036 	bltu	r3,r2,8224f64 <tse_mac_raw_send+0xc4>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
      }
      ActualData = (unsigned int*)buf2;
 8224fa4:	e0be7704 	addi	r2,fp,-1572
 8224fa8:	e0be6d15 	stw	r2,-1612(fp)
   }  
   
     // clear bit-31 before passing it to SGDMA Driver
    ActualData = (unsigned int*)alt_remap_cached ((volatile void*) ActualData, 4);
 8224fac:	01400104 	movi	r5,4
 8224fb0:	e13e6d17 	ldw	r4,-1612(fp)
 8224fb4:	823c6200 	call	823c620 <alt_remap_cached>
 8224fb8:	e0be6d15 	stw	r2,-1612(fp)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
 8224fbc:	e0be7017 	ldw	r2,-1600(fp)
 8224fc0:	10800903 	ldbu	r2,36(r2)
 8224fc4:	10803fcc 	andi	r2,r2,255
 8224fc8:	10800058 	cmpnei	r2,r2,1
 8224fcc:	1000271e 	bne	r2,zero,822506c <tse_mac_raw_send+0x1cc>
 8224fd0:	e0be6e17 	ldw	r2,-1608(fp)
 8224fd4:	108003f0 	cmpltui	r2,r2,15
 8224fd8:	1000241e 	bne	r2,zero,822506c <tse_mac_raw_send+0x1cc>
 8224fdc:	e0be6f17 	ldw	r2,-1604(fp)
 8224fe0:	10800d17 	ldw	r2,52(r2)
 8224fe4:	1085883a 	add	r2,r2,r2
 8224fe8:	1085883a 	add	r2,r2,r2
 8224fec:	1007883a 	mov	r3,r2
 8224ff0:	e0be7017 	ldw	r2,-1600(fp)
 8224ff4:	10800b17 	ldw	r2,44(r2)
 8224ff8:	1885883a 	add	r2,r3,r2
 8224ffc:	10800037 	ldwio	r2,0(r2)
 8225000:	10800388 	cmpgei	r2,r2,14
 8225004:	1000191e 	bne	r2,zero,822506c <tse_mac_raw_send+0x1cc>
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 8225008:	e0be6f17 	ldw	r2,-1604(fp)
 822500c:	10c00f17 	ldw	r3,60(r2)
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
 8225010:	e0be6f17 	ldw	r2,-1604(fp)
 8225014:	10800f17 	ldw	r2,60(r2)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 8225018:	11000804 	addi	r4,r2,32
 822501c:	e0be6e17 	ldw	r2,-1608(fp)
 8225020:	117fffcc 	andi	r5,r2,65535
 8225024:	d8000315 	stw	zero,12(sp)
 8225028:	00800044 	movi	r2,1
 822502c:	d8800215 	stw	r2,8(sp)
 8225030:	00800044 	movi	r2,1
 8225034:	d8800115 	stw	r2,4(sp)
 8225038:	d8000015 	stw	zero,0(sp)
 822503c:	280f883a 	mov	r7,r5
 8225040:	e1be6d17 	ldw	r6,-1612(fp)
 8225044:	200b883a 	mov	r5,r4
 8225048:	1809883a 	mov	r4,r3
 822504c:	821e6780 	call	821e678 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           0,                                        // don't read from constant address
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)

        tse_mac_sTxWrite(mi,tse_ptr->desc);
 8225050:	e0be6f17 	ldw	r2,-1604(fp)
 8225054:	10800f17 	ldw	r2,60(r2)
 8225058:	100b883a 	mov	r5,r2
 822505c:	e13e7317 	ldw	r4,-1588(fp)
 8225060:	821f1500 	call	821f150 <tse_mac_sTxWrite>
        result = 0;
 8225064:	e03e6b15 	stw	zero,-1620(fp)
 8225068:	00001e06 	br	82250e4 <tse_mac_raw_send+0x244>
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    
 822506c:	e0be6e17 	ldw	r2,-1608(fp)
 8225070:	108003f0 	cmpltui	r2,r2,15
 8225074:	1000191e 	bne	r2,zero,82250dc <tse_mac_raw_send+0x23c>

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 8225078:	e0be6f17 	ldw	r2,-1604(fp)
 822507c:	10c00f17 	ldw	r3,60(r2)
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
 8225080:	e0be6f17 	ldw	r2,-1604(fp)
 8225084:	10800f17 	ldw	r2,60(r2)
        result = 0;
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 8225088:	11000804 	addi	r4,r2,32
 822508c:	e0be6e17 	ldw	r2,-1608(fp)
 8225090:	117fffcc 	andi	r5,r2,65535
 8225094:	d8000315 	stw	zero,12(sp)
 8225098:	00800044 	movi	r2,1
 822509c:	d8800215 	stw	r2,8(sp)
 82250a0:	00800044 	movi	r2,1
 82250a4:	d8800115 	stw	r2,4(sp)
 82250a8:	d8000015 	stw	zero,0(sp)
 82250ac:	280f883a 	mov	r7,r5
 82250b0:	e1be6d17 	ldw	r6,-1612(fp)
 82250b4:	200b883a 	mov	r5,r4
 82250b8:	1809883a 	mov	r4,r3
 82250bc:	821e6780 	call	821e678 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)
                  
    
       tse_mac_sTxWrite(mi,tse_ptr->desc);
 82250c0:	e0be6f17 	ldw	r2,-1604(fp)
 82250c4:	10800f17 	ldw	r2,60(r2)
 82250c8:	100b883a 	mov	r5,r2
 82250cc:	e13e7317 	ldw	r4,-1588(fp)
 82250d0:	821f1500 	call	821f150 <tse_mac_sTxWrite>
       result = 0;
 82250d4:	e03e6b15 	stw	zero,-1620(fp)
 82250d8:	00000206 	br	82250e4 <tse_mac_raw_send+0x244>

   } else {
       result = -3;
 82250dc:	00bfff44 	movi	r2,-3
 82250e0:	e0be6b15 	stw	r2,-1620(fp)
   }

   if(result < 0)   /* SGDMA not available */
 82250e4:	e0be6b17 	ldw	r2,-1620(fp)
 82250e8:	1000120e 	bge	r2,zero,8225134 <tse_mac_raw_send+0x294>
   {
      dprintf("raw_send() SGDMA not available, ret=%d, len=%d\n",result, len);
 82250ec:	e1be6e17 	ldw	r6,-1608(fp)
 82250f0:	e17e6b17 	ldw	r5,-1620(fp)
 82250f4:	01020974 	movhi	r4,2085
 82250f8:	213f6d04 	addi	r4,r4,-588
 82250fc:	820331c0 	call	820331c <printf>
      net->n_mib->ifOutDiscards++;
 8225100:	e0bffd17 	ldw	r2,-12(fp)
 8225104:	10802717 	ldw	r2,156(r2)
 8225108:	10c01217 	ldw	r3,72(r2)
 822510c:	18c00044 	addi	r3,r3,1
 8225110:	10c01215 	stw	r3,72(r2)
      tse_ptr->sem = 0;
 8225114:	e0be6f17 	ldw	r2,-1604(fp)
 8225118:	10000c15 	stw	zero,48(r2)
 822511c:	e0be7217 	ldw	r2,-1592(fp)
 8225120:	e0be7415 	stw	r2,-1584(fp)
 8225124:	e0be7417 	ldw	r2,-1584(fp)
 8225128:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SEND_DROPPED;   /* ENP_RESOURCE and SEND_DROPPED have the same value! */
 822512c:	00bffa84 	movi	r2,-22
 8225130:	00001406 	br	8225184 <tse_mac_raw_send+0x2e4>
   }
   else   /* = 0, success */
   {
      net->n_mib->ifOutOctets += data_bytes;
 8225134:	e0bffd17 	ldw	r2,-12(fp)
 8225138:	10802717 	ldw	r2,156(r2)
 822513c:	e0fffd17 	ldw	r3,-12(fp)
 8225140:	18c02717 	ldw	r3,156(r3)
 8225144:	19000f17 	ldw	r4,60(r3)
 8225148:	e0ffff17 	ldw	r3,-4(fp)
 822514c:	20c7883a 	add	r3,r4,r3
 8225150:	10c00f15 	stw	r3,60(r2)
      /* we dont know whether it was unicast or not, we count both in <ifOutUcastPkts> */
      net->n_mib->ifOutUcastPkts++;
 8225154:	e0bffd17 	ldw	r2,-12(fp)
 8225158:	10802717 	ldw	r2,156(r2)
 822515c:	10c01017 	ldw	r3,64(r2)
 8225160:	18c00044 	addi	r3,r3,1
 8225164:	10c01015 	stw	r3,64(r2)
      tse_ptr->sem = 0;
 8225168:	e0be6f17 	ldw	r2,-1604(fp)
 822516c:	10000c15 	stw	zero,48(r2)
 8225170:	e0be7217 	ldw	r2,-1592(fp)
 8225174:	e0be7515 	stw	r2,-1580(fp)
 8225178:	e0be7517 	ldw	r2,-1580(fp)
 822517c:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SUCCESS;  /*success */
 8225180:	0005883a 	mov	r2,zero
   }
}
 8225184:	e037883a 	mov	sp,fp
 8225188:	dfc00117 	ldw	ra,4(sp)
 822518c:	df000017 	ldw	fp,0(sp)
 8225190:	dec00204 	addi	sp,sp,8
 8225194:	f800283a 	ret

08225198 <tse_sgdmaRx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
void tse_sgdmaRx_isr(void * context)
{
 8225198:	defffa04 	addi	sp,sp,-24
 822519c:	dfc00515 	stw	ra,20(sp)
 82251a0:	df000415 	stw	fp,16(sp)
 82251a4:	df000404 	addi	fp,sp,16
 82251a8:	e13fff15 	stw	r4,-4(fp)
  ins_tse_info* tse_ptr = (ins_tse_info *) context; 
 82251ac:	e0bfff17 	ldw	r2,-4(fp)
 82251b0:	e0bffc15 	stw	r2,-16(fp)
  alt_u8 sgdma_status;
  
  /* Capture whether there are existing packets on stack rcv queue */
  int initial_rcvdq_len = rcvdq.q_len;
 82251b4:	008209b4 	movhi	r2,2086
 82251b8:	10b75f04 	addi	r2,r2,-8836
 82251bc:	10800217 	ldw	r2,8(r2)
 82251c0:	e0bffd15 	stw	r2,-12(fp)
   * IO read to peripheral that generated the IRQ is done after IO write
   * to negate the interrupt request. This ensures at the IO write reaches 
   * the peripheral (through any high-latency hardware in the system)
   * before the ISR exits.
   */   
  sgdma_status = IORD_ALTERA_AVALON_SGDMA_STATUS(tse_ptr->mi.rx_sgdma->base);
 82251c4:	e0bffc17 	ldw	r2,-16(fp)
 82251c8:	10800317 	ldw	r2,12(r2)
 82251cc:	10800317 	ldw	r2,12(r2)
 82251d0:	10800037 	ldwio	r2,0(r2)
 82251d4:	e0bffe05 	stb	r2,-8(fp)
  
  /* Why are we here; should we be? */
  if(sgdma_status & (ALTERA_AVALON_SGDMA_STATUS_CHAIN_COMPLETED_MSK | 
 82251d8:	e0bffe03 	ldbu	r2,-8(fp)
 82251dc:	1080030c 	andi	r2,r2,12
 82251e0:	10001226 	beq	r2,zero,822522c <tse_sgdmaRx_isr+0x94>
                     ALTERA_AVALON_SGDMA_STATUS_DESC_COMPLETED_MSK) ) {
    /* Handle received packet(s) */
    tse_mac_rcv(tse_ptr); 
 82251e4:	e13ffc17 	ldw	r4,-16(fp)
 82251e8:	82253f00 	call	82253f0 <tse_mac_rcv>
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 82251ec:	e0bffc17 	ldw	r2,-16(fp)
 82251f0:	10c00317 	ldw	r3,12(r2)
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
 82251f4:	e0bffc17 	ldw	r2,-16(fp)
 82251f8:	10800f17 	ldw	r2,60(r2)
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 82251fc:	10801004 	addi	r2,r2,64
 8225200:	100b883a 	mov	r5,r2
 8225204:	1809883a 	mov	r4,r3
 8225208:	821e2740 	call	821e274 <alt_avalon_sgdma_do_async_transfer>
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
#endif
  
    /* Wake up Niche stack if there are new packets are on queue */
    if ((rcvdq.q_len) > initial_rcvdq_len) {
 822520c:	008209b4 	movhi	r2,2086
 8225210:	10b75f04 	addi	r2,r2,-8836
 8225214:	10800217 	ldw	r2,8(r2)
 8225218:	e0fffd17 	ldw	r3,-12(fp)
 822521c:	1880030e 	bge	r3,r2,822522c <tse_sgdmaRx_isr+0x94>
      SignalPktDemux();
 8225220:	d0a0ab17 	ldw	r2,-32084(gp)
 8225224:	1009883a 	mov	r4,r2
 8225228:	821a3b00 	call	821a3b0 <OSSemPost>
    }  
  } /* if (valid SGDMA interrupt) */
}
 822522c:	0001883a 	nop
 8225230:	e037883a 	mov	sp,fp
 8225234:	dfc00117 	ldw	ra,4(sp)
 8225238:	df000017 	ldw	fp,0(sp)
 822523c:	dec00204 	addi	sp,sp,8
 8225240:	f800283a 	ret

08225244 <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
 8225244:	defffa04 	addi	sp,sp,-24
 8225248:	dfc00515 	stw	ra,20(sp)
 822524c:	df000415 	stw	fp,16(sp)
 8225250:	dc000315 	stw	r16,12(sp)
 8225254:	df000404 	addi	fp,sp,16
 8225258:	e13ffe15 	stw	r4,-8(fp)
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 822525c:	e0bffe17 	ldw	r2,-8(fp)
 8225260:	10000e15 	stw	zero,56(r2)
 8225264:	00004406 	br	8225378 <tse_sgdma_read_init+0x134>
  { 
    tse_ptr->pkt_array[tse_ptr->chain_loop] = pk_alloc(ALTERA_TSE_PKT_INIT_LEN+4);
 8225268:	e0bffe17 	ldw	r2,-8(fp)
 822526c:	14000e17 	ldw	r16,56(r2)
 8225270:	01017f04 	movi	r4,1532
 8225274:	822c86c0 	call	822c86c <pk_alloc>
 8225278:	1009883a 	mov	r4,r2
 822527c:	e0fffe17 	ldw	r3,-8(fp)
 8225280:	80800444 	addi	r2,r16,17
 8225284:	1085883a 	add	r2,r2,r2
 8225288:	1085883a 	add	r2,r2,r2
 822528c:	1885883a 	add	r2,r3,r2
 8225290:	11000015 	stw	r4,0(r2)
    
    if (!tse_ptr->pkt_array[tse_ptr->chain_loop])   /* couldn't get a free buffer for rx */
 8225294:	e0bffe17 	ldw	r2,-8(fp)
 8225298:	10800e17 	ldw	r2,56(r2)
 822529c:	e0fffe17 	ldw	r3,-8(fp)
 82252a0:	10800444 	addi	r2,r2,17
 82252a4:	1085883a 	add	r2,r2,r2
 82252a8:	1085883a 	add	r2,r2,r2
 82252ac:	1885883a 	add	r2,r3,r2
 82252b0:	10800017 	ldw	r2,0(r2)
 82252b4:	10000b1e 	bne	r2,zero,82252e4 <tse_sgdma_read_init+0xa0>
    {
      dprintf("[tse_sgdma_read_init] Fatal error: No free packet buffers for RX\n");
 82252b8:	01020974 	movhi	r4,2085
 82252bc:	213f7904 	addi	r4,r4,-540
 82252c0:	82035a00 	call	82035a0 <puts>
      tse_ptr->netp->n_mib->ifInDiscards++;
 82252c4:	e0bffe17 	ldw	r2,-8(fp)
 82252c8:	10800817 	ldw	r2,32(r2)
 82252cc:	10802717 	ldw	r2,156(r2)
 82252d0:	10c00c17 	ldw	r3,48(r2)
 82252d4:	18c00044 	addi	r3,r3,1
 82252d8:	10c00c15 	stw	r3,48(r2)
      
      return ENP_NOBUFFER;
 82252dc:	00bffac4 	movi	r2,-21
 82252e0:	00003d06 	br	82253d8 <tse_sgdma_read_init+0x194>
    }
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 82252e4:	e0bffe17 	ldw	r2,-8(fp)
 82252e8:	10800e17 	ldw	r2,56(r2)
 82252ec:	e0fffe17 	ldw	r3,-8(fp)
 82252f0:	10800444 	addi	r2,r2,17
 82252f4:	1085883a 	add	r2,r2,r2
 82252f8:	1085883a 	add	r2,r2,r2
 82252fc:	1885883a 	add	r2,r3,r2
 8225300:	10800017 	ldw	r2,0(r2)
 8225304:	10800117 	ldw	r2,4(r2)
 8225308:	01400104 	movi	r5,4
 822530c:	1009883a 	mov	r4,r2
 8225310:	823c6200 	call	823c620 <alt_remap_cached>
 8225314:	e0bffd15 	stw	r2,-12(fp)

    alt_avalon_sgdma_construct_stream_to_mem_desc(
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
 8225318:	e0bffe17 	ldw	r2,-8(fp)
 822531c:	10c00f17 	ldw	r3,60(r2)
 8225320:	e0bffe17 	ldw	r2,-8(fp)
 8225324:	10800e17 	ldw	r2,56(r2)
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 8225328:	10800084 	addi	r2,r2,2
 822532c:	1004917a 	slli	r2,r2,5
 8225330:	1889883a 	add	r4,r3,r2
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST], // pointer to "next"
 8225334:	e0bffe17 	ldw	r2,-8(fp)
 8225338:	10c00f17 	ldw	r3,60(r2)
 822533c:	e0bffe17 	ldw	r2,-8(fp)
 8225340:	10800e17 	ldw	r2,56(r2)
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 8225344:	108000c4 	addi	r2,r2,3
 8225348:	1004917a 	slli	r2,r2,5
 822534c:	1885883a 	add	r2,r3,r2
 8225350:	d8000015 	stw	zero,0(sp)
 8225354:	000f883a 	mov	r7,zero
 8225358:	e1bffd17 	ldw	r6,-12(fp)
 822535c:	100b883a 	mov	r5,r2
 8225360:	821e5a00 	call	821e5a0 <alt_avalon_sgdma_construct_stream_to_mem_desc>
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 8225364:	e0bffe17 	ldw	r2,-8(fp)
 8225368:	10800e17 	ldw	r2,56(r2)
 822536c:	10c00044 	addi	r3,r2,1
 8225370:	e0bffe17 	ldw	r2,-8(fp)
 8225374:	10c00e15 	stw	r3,56(r2)
 8225378:	e0bffe17 	ldw	r2,-8(fp)
 822537c:	10800e17 	ldw	r2,56(r2)
 8225380:	00bfb90e 	bge	zero,r2,8225268 <tse_sgdma_read_init+0x24>
            0,                          // read until EOP
            0);                         // don't write to constant address

  } // for

  dprintf("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n", 
 8225384:	e0bffe17 	ldw	r2,-8(fp)
 8225388:	10800e17 	ldw	r2,56(r2)
 822538c:	100b883a 	mov	r5,r2
 8225390:	01020974 	movhi	r4,2085
 8225394:	213f8a04 	addi	r4,r4,-472
 8225398:	820331c0 	call	820331c <printf>
    tse_ptr->chain_loop);
   
  tse_ptr->chain_loop = 0;
 822539c:	e0bffe17 	ldw	r2,-8(fp)
 82253a0:	10000e15 	stw	zero,56(r2)
  tse_ptr->currdescriptor_ptr =  &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 82253a4:	e0bffe17 	ldw	r2,-8(fp)
 82253a8:	10800f17 	ldw	r2,60(r2)
 82253ac:	10c01004 	addi	r3,r2,64
 82253b0:	e0bffe17 	ldw	r2,-8(fp)
 82253b4:	10c01015 	stw	r3,64(r2)

  tse_mac_aRxRead( &tse_ptr->mi, tse_ptr->currdescriptor_ptr);
 82253b8:	e0bffe17 	ldw	r2,-8(fp)
 82253bc:	10c00104 	addi	r3,r2,4
 82253c0:	e0bffe17 	ldw	r2,-8(fp)
 82253c4:	10801017 	ldw	r2,64(r2)
 82253c8:	100b883a 	mov	r5,r2
 82253cc:	1809883a 	mov	r4,r3
 82253d0:	821f2340 	call	821f234 <tse_mac_aRxRead>
  
  return SUCCESS;
 82253d4:	0005883a 	mov	r2,zero
}
 82253d8:	e6ffff04 	addi	sp,fp,-4
 82253dc:	dfc00217 	ldw	ra,8(sp)
 82253e0:	df000117 	ldw	fp,4(sp)
 82253e4:	dc000017 	ldw	r16,0(sp)
 82253e8:	dec00304 	addi	sp,sp,12
 82253ec:	f800283a 	ret

082253f0 <tse_mac_rcv>:
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */

ALT_INLINE void tse_mac_rcv(ins_tse_info* tse_ptr)
{     
 82253f0:	defff704 	addi	sp,sp,-36
 82253f4:	dfc00815 	stw	ra,32(sp)
 82253f8:	df000715 	stw	fp,28(sp)
 82253fc:	df000704 	addi	fp,sp,28
 8225400:	e13fff15 	stw	r4,-4(fp)
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 8225404:	e0bfff17 	ldw	r2,-4(fp)
 8225408:	10c00f17 	ldw	r3,60(r2)
 822540c:	e0bfff17 	ldw	r2,-4(fp)
 8225410:	10800e17 	ldw	r2,56(r2)
 8225414:	10800084 	addi	r2,r2,2
 8225418:	1004917a 	slli	r2,r2,5
 822541c:	1887883a 	add	r3,r3,r2
  PACKET replacement_pkt;
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
 8225420:	e0bfff17 	ldw	r2,-4(fp)
 8225424:	10c01015 	stw	r3,64(r2)
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
  
  /* Grab status bits from descriptor under test. Bypass cache */
  desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
 8225428:	e0bfff17 	ldw	r2,-4(fp)
 822542c:	10801017 	ldw	r2,64(r2)
 8225430:	10800704 	addi	r2,r2,28
 8225434:	10800037 	ldwio	r2,0(r2)
 8225438:	1005d43a 	srai	r2,r2,16
 822543c:	e0bff905 	stb	r2,-28(fp)
  while ( desc_status & 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_TERMINATED_BY_EOP_MSK )
#endif
{      
    /* Correct frame length to actual (this is different from TX side) */
    pklen = IORD_16DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0) - 2;
 8225440:	e0bfff17 	ldw	r2,-4(fp)
 8225444:	10801017 	ldw	r2,64(r2)
 8225448:	10800704 	addi	r2,r2,28
 822544c:	1080002b 	ldhuio	r2,0(r2)
 8225450:	10bfffcc 	andi	r2,r2,65535
 8225454:	10bfff84 	addi	r2,r2,-2
 8225458:	e0bffa15 	stw	r2,-24(fp)
    tse_ptr->netp->n_mib->ifInOctets += (u_long)pklen;
 822545c:	e0bfff17 	ldw	r2,-4(fp)
 8225460:	10800817 	ldw	r2,32(r2)
 8225464:	10802717 	ldw	r2,156(r2)
 8225468:	e0ffff17 	ldw	r3,-4(fp)
 822546c:	18c00817 	ldw	r3,32(r3)
 8225470:	18c02717 	ldw	r3,156(r3)
 8225474:	19000917 	ldw	r4,36(r3)
 8225478:	e0fffa17 	ldw	r3,-24(fp)
 822547c:	20c7883a 	add	r3,r4,r3
 8225480:	10c00915 	stw	r3,36(r2)
  
    rx_packet = tse_ptr->pkt_array[tse_ptr->chain_loop];   
 8225484:	e0bfff17 	ldw	r2,-4(fp)
 8225488:	10800e17 	ldw	r2,56(r2)
 822548c:	e0ffff17 	ldw	r3,-4(fp)
 8225490:	10800444 	addi	r2,r2,17
 8225494:	1085883a 	add	r2,r2,r2
 8225498:	1085883a 	add	r2,r2,r2
 822549c:	1885883a 	add	r2,r3,r2
 82254a0:	10800017 	ldw	r2,0(r2)
 82254a4:	e0bffb15 	stw	r2,-20(fp)
    
    rx_packet->nb_prot = rx_packet->nb_buff + ETHHDR_SIZE;
 82254a8:	e0bffb17 	ldw	r2,-20(fp)
 82254ac:	10800117 	ldw	r2,4(r2)
 82254b0:	10c00404 	addi	r3,r2,16
 82254b4:	e0bffb17 	ldw	r2,-20(fp)
 82254b8:	10c00315 	stw	r3,12(r2)
    rx_packet->nb_plen = pklen - 14;
 82254bc:	e0bffa17 	ldw	r2,-24(fp)
 82254c0:	10bffc84 	addi	r2,r2,-14
 82254c4:	1007883a 	mov	r3,r2
 82254c8:	e0bffb17 	ldw	r2,-20(fp)
 82254cc:	10c00415 	stw	r3,16(r2)
    rx_packet->nb_tstamp = cticks;
 82254d0:	d0a0a817 	ldw	r2,-32096(gp)
 82254d4:	1007883a 	mov	r3,r2
 82254d8:	e0bffb17 	ldw	r2,-20(fp)
 82254dc:	10c00515 	stw	r3,20(r2)
    rx_packet->net = tse_ptr->netp;
 82254e0:	e0bfff17 	ldw	r2,-4(fp)
 82254e4:	10c00817 	ldw	r3,32(r2)
 82254e8:	e0bffb17 	ldw	r2,-20(fp)
 82254ec:	10c00615 	stw	r3,24(r2)
    
    // set packet type for demux routine
    eth = (struct ethhdr *)(rx_packet->nb_buff + ETHHDR_BIAS);
 82254f0:	e0bffb17 	ldw	r2,-20(fp)
 82254f4:	10800117 	ldw	r2,4(r2)
 82254f8:	10800084 	addi	r2,r2,2
 82254fc:	e0bffc15 	stw	r2,-16(fp)
    rx_packet->type = eth->e_type;
 8225500:	e0bffc17 	ldw	r2,-16(fp)
 8225504:	10c0030b 	ldhu	r3,12(r2)
 8225508:	e0bffb17 	ldw	r2,-20(fp)
 822550c:	10c0080d 	sth	r3,32(r2)
    
    if( (desc_status & 
 8225510:	e0bff903 	ldbu	r2,-28(fp)
 8225514:	10801fcc 	andi	r2,r2,127
 8225518:	1000251e 	bne	r2,zero,82255b0 <tse_mac_rcv+0x1c0>
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) == 0)
    {
      replacement_pkt = pk_alloc(ALTERA_TSE_PKT_INIT_LEN + 4);
 822551c:	01017f04 	movi	r4,1532
 8225520:	822c86c0 	call	822c86c <pk_alloc>
 8225524:	e0bffd15 	stw	r2,-12(fp)
      if (!replacement_pkt) { /* couldn't get a free buffer for rx */
 8225528:	e0bffd17 	ldw	r2,-12(fp)
 822552c:	10000a1e 	bne	r2,zero,8225558 <tse_mac_rcv+0x168>
        dprintf("No free buffers for rx\n");
 8225530:	01020974 	movhi	r4,2085
 8225534:	213f9b04 	addi	r4,r4,-404
 8225538:	82035a00 	call	82035a0 <puts>
        tse_ptr->netp->n_mib->ifInDiscards++;
 822553c:	e0bfff17 	ldw	r2,-4(fp)
 8225540:	10800817 	ldw	r2,32(r2)
 8225544:	10802717 	ldw	r2,156(r2)
 8225548:	10c00c17 	ldw	r3,48(r2)
 822554c:	18c00044 	addi	r3,r3,1
 8225550:	10c00c15 	stw	r3,48(r2)
 8225554:	00001906 	br	82255bc <tse_mac_rcv+0x1cc>
      }
      else {
        putq(&rcvdq, tse_ptr->pkt_array[tse_ptr->chain_loop]);
 8225558:	e0bfff17 	ldw	r2,-4(fp)
 822555c:	10800e17 	ldw	r2,56(r2)
 8225560:	e0ffff17 	ldw	r3,-4(fp)
 8225564:	10800444 	addi	r2,r2,17
 8225568:	1085883a 	add	r2,r2,r2
 822556c:	1085883a 	add	r2,r2,r2
 8225570:	1885883a 	add	r2,r3,r2
 8225574:	10800017 	ldw	r2,0(r2)
 8225578:	100b883a 	mov	r5,r2
 822557c:	010209b4 	movhi	r4,2086
 8225580:	21375f04 	addi	r4,r4,-8836
 8225584:	822cdfc0 	call	822cdfc <putq>
        tse_ptr->pkt_array[tse_ptr->chain_loop] = replacement_pkt;
 8225588:	e0bfff17 	ldw	r2,-4(fp)
 822558c:	10800e17 	ldw	r2,56(r2)
 8225590:	e0ffff17 	ldw	r3,-4(fp)
 8225594:	10800444 	addi	r2,r2,17
 8225598:	1085883a 	add	r2,r2,r2
 822559c:	1085883a 	add	r2,r2,r2
 82255a0:	1885883a 	add	r2,r3,r2
 82255a4:	e0fffd17 	ldw	r3,-12(fp)
 82255a8:	10c00015 	stw	r3,0(r2)
 82255ac:	00000306 	br	82255bc <tse_mac_rcv+0x1cc>
      }
    } /* if(descriptor had no errors) */ 
    else {
      dprintf("RX descriptor reported error. packet dropped\n");
 82255b0:	01020974 	movhi	r4,2085
 82255b4:	213fa104 	addi	r4,r4,-380
 82255b8:	82035a00 	call	82035a0 <puts>
    }     
             
    uncached_packet_payload = (alt_u32 *)alt_remap_cached(tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 82255bc:	e0bfff17 	ldw	r2,-4(fp)
 82255c0:	10800e17 	ldw	r2,56(r2)
 82255c4:	e0ffff17 	ldw	r3,-4(fp)
 82255c8:	10800444 	addi	r2,r2,17
 82255cc:	1085883a 	add	r2,r2,r2
 82255d0:	1085883a 	add	r2,r2,r2
 82255d4:	1885883a 	add	r2,r3,r2
 82255d8:	10800017 	ldw	r2,0(r2)
 82255dc:	10800117 	ldw	r2,4(r2)
 82255e0:	01400104 	movi	r5,4
 82255e4:	1009883a 	mov	r4,r2
 82255e8:	823c6200 	call	823c620 <alt_remap_cached>
 82255ec:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Re-cycle previously constructed SGDMA buffer directly rather
     * than calling the SGDMA utility routines. This saves some call/return
     * overhead and only does cache-bypass writes of what we need
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->write_addr, 0, 
 82255f0:	e0bfff17 	ldw	r2,-4(fp)
 82255f4:	10801017 	ldw	r2,64(r2)
 82255f8:	10800204 	addi	r2,r2,8
 82255fc:	e0fffe17 	ldw	r3,-8(fp)
 8225600:	10c00035 	stwio	r3,0(r2)
     *   |31...24|23..16|15.....................0|
     *   |control|status|actual_bytes_transferred|
     * 
     * Set relevant control bits and ensure the rest are cleared.
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0, 
 8225604:	e0bfff17 	ldw	r2,-4(fp)
 8225608:	10801017 	ldw	r2,64(r2)
 822560c:	10800704 	addi	r2,r2,28
 8225610:	00e04034 	movhi	r3,33024
 8225614:	10c00035 	stwio	r3,0(r2)
    
    /* Grab next descriptor status */
    desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
#endif
  } /* while (descriptor terminated by EOP) */
} 
 8225618:	0001883a 	nop
 822561c:	e037883a 	mov	sp,fp
 8225620:	dfc00117 	ldw	ra,4(sp)
 8225624:	df000017 	ldw	fp,0(sp)
 8225628:	dec00204 	addi	sp,sp,8
 822562c:	f800283a 	ret

08225630 <tse_mac_stats>:

int tse_mac_stats(void * pio, int iface)
{
 8225630:	defffc04 	addi	sp,sp,-16
 8225634:	dfc00315 	stw	ra,12(sp)
 8225638:	df000215 	stw	fp,8(sp)
 822563c:	df000204 	addi	fp,sp,8
 8225640:	e13ffe15 	stw	r4,-8(fp)
 8225644:	e17fff15 	stw	r5,-4(fp)
   ns_printf(pio, "tse_mac_stats(), stats will be added later!\n");
 8225648:	01420974 	movhi	r5,2085
 822564c:	297fad04 	addi	r5,r5,-332
 8225650:	e13ffe17 	ldw	r4,-8(fp)
 8225654:	8228d040 	call	8228d04 <ns_printf>
   return SUCCESS;
 8225658:	0005883a 	mov	r2,zero
}
 822565c:	e037883a 	mov	sp,fp
 8225660:	dfc00117 	ldw	ra,4(sp)
 8225664:	df000017 	ldw	fp,0(sp)
 8225668:	dec00204 	addi	sp,sp,8
 822566c:	f800283a 	ret

08225670 <tse_mac_close>:
 * @API TYPE - Public
 * @param  iface    index of the NET interface associated with the TSE MAC.
 * @return SUCCESS
 */
int tse_mac_close(int iface)
{
 8225670:	defffc04 	addi	sp,sp,-16
 8225674:	dfc00315 	stw	ra,12(sp)
 8225678:	df000215 	stw	fp,8(sp)
 822567c:	df000204 	addi	fp,sp,8
 8225680:	e13fff15 	stw	r4,-4(fp)
  int state;
   
  /* status = down */
  nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;    
 8225684:	008209b4 	movhi	r2,2086
 8225688:	10b82404 	addi	r2,r2,-8048
 822568c:	e0ffff17 	ldw	r3,-4(fp)
 8225690:	18c7883a 	add	r3,r3,r3
 8225694:	18c7883a 	add	r3,r3,r3
 8225698:	10c5883a 	add	r2,r2,r3
 822569c:	10800017 	ldw	r2,0(r2)
 82256a0:	10802717 	ldw	r2,156(r2)
 82256a4:	00c00084 	movi	r3,2
 82256a8:	10c00615 	stw	r3,24(r2)

  /* disable the interrupt in the OS*/
  alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma, 0, 0, 0);
 82256ac:	008209b4 	movhi	r2,2086
 82256b0:	10b71304 	addi	r2,r2,-9140
 82256b4:	e0ffff17 	ldw	r3,-4(fp)
 82256b8:	18c01324 	muli	r3,r3,76
 82256bc:	10c5883a 	add	r2,r2,r3
 82256c0:	10800304 	addi	r2,r2,12
 82256c4:	10800017 	ldw	r2,0(r2)
 82256c8:	000f883a 	mov	r7,zero
 82256cc:	000d883a 	mov	r6,zero
 82256d0:	000b883a 	mov	r5,zero
 82256d4:	1009883a 	mov	r4,r2
 82256d8:	821e7840 	call	821e784 <alt_avalon_sgdma_register_callback>
   
  /* Disable Receive path on the device*/
  state = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 82256dc:	008209b4 	movhi	r2,2086
 82256e0:	10b71304 	addi	r2,r2,-9140
 82256e4:	e0ffff17 	ldw	r3,-4(fp)
 82256e8:	18c01324 	muli	r3,r3,76
 82256ec:	10c5883a 	add	r2,r2,r3
 82256f0:	10800104 	addi	r2,r2,4
 82256f4:	10800017 	ldw	r2,0(r2)
 82256f8:	10800204 	addi	r2,r2,8
 82256fc:	10800037 	ldwio	r2,0(r2)
 8225700:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,state & ~ALTERA_TSEMAC_CMD_RX_ENA_MSK); 
 8225704:	008209b4 	movhi	r2,2086
 8225708:	10b71304 	addi	r2,r2,-9140
 822570c:	e0ffff17 	ldw	r3,-4(fp)
 8225710:	18c01324 	muli	r3,r3,76
 8225714:	10c5883a 	add	r2,r2,r3
 8225718:	10800104 	addi	r2,r2,4
 822571c:	10800017 	ldw	r2,0(r2)
 8225720:	10800204 	addi	r2,r2,8
 8225724:	e13ffe17 	ldw	r4,-8(fp)
 8225728:	00ffff44 	movi	r3,-3
 822572c:	20c6703a 	and	r3,r4,r3
 8225730:	10c00035 	stwio	r3,0(r2)
  
  /* status = down */                                     
  nets[iface]->n_mib->ifOperStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;     
 8225734:	008209b4 	movhi	r2,2086
 8225738:	10b82404 	addi	r2,r2,-8048
 822573c:	e0ffff17 	ldw	r3,-4(fp)
 8225740:	18c7883a 	add	r3,r3,r3
 8225744:	18c7883a 	add	r3,r3,r3
 8225748:	10c5883a 	add	r2,r2,r3
 822574c:	10800017 	ldw	r2,0(r2)
 8225750:	10802717 	ldw	r2,156(r2)
 8225754:	00c00084 	movi	r3,2
 8225758:	10c00715 	stw	r3,28(r2)

  return SUCCESS;
 822575c:	0005883a 	mov	r2,zero
}
 8225760:	e037883a 	mov	sp,fp
 8225764:	dfc00117 	ldw	ra,4(sp)
 8225768:	df000017 	ldw	fp,0(sp)
 822576c:	dec00204 	addi	sp,sp,8
 8225770:	f800283a 	ret

08225774 <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
 8225774:	defffd04 	addi	sp,sp,-12
 8225778:	dfc00215 	stw	ra,8(sp)
 822577c:	df000115 	stw	fp,4(sp)
 8225780:	df000104 	addi	fp,sp,4
 8225784:	e13fff15 	stw	r4,-4(fp)
  return (fd < ALT_MAX_FD) ? alt_close (fd) : t_socketclose ((long) fd);
 8225788:	e0bfff17 	ldw	r2,-4(fp)
 822578c:	10800808 	cmpgei	r2,r2,32
 8225790:	1000031e 	bne	r2,zero,82257a0 <close+0x2c>
 8225794:	e13fff17 	ldw	r4,-4(fp)
 8225798:	823baac0 	call	823baac <alt_close>
 822579c:	00000206 	br	82257a8 <close+0x34>
 82257a0:	e13fff17 	ldw	r4,-4(fp)
 82257a4:	82316cc0 	call	82316cc <t_socketclose>
}
 82257a8:	e037883a 	mov	sp,fp
 82257ac:	dfc00117 	ldw	ra,4(sp)
 82257b0:	df000017 	ldw	fp,0(sp)
 82257b4:	dec00204 	addi	sp,sp,8
 82257b8:	f800283a 	ret

082257bc <iniche_devices_init>:
 * total number of interfaces after initialization.
 */

int iniche_devices_init(
    int                         if_count)
{
 82257bc:	defff504 	addi	sp,sp,-44
 82257c0:	dfc00a15 	stw	ra,40(sp)
 82257c4:	df000915 	stw	fp,36(sp)
 82257c8:	df000904 	addi	fp,sp,36
 82257cc:	e13fff15 	stw	r4,-4(fp)
                                netmask,
                                gw;
    int                         use_dhcp;

    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
 82257d0:	d0a02e17 	ldw	r2,-32584(gp)
 82257d4:	e0bff815 	stw	r2,-32(fp)
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));
 82257d8:	d0a02e04 	addi	r2,gp,-32584
 82257dc:	e0bff915 	stw	r2,-28(fp)

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 82257e0:	00003f06 	br	82258e0 <iniche_devices_init+0x124>
    {
        /* Initialize the InterNiche device data record. */
        p_dev->p_driver_data = p_dev;
 82257e4:	e0bff817 	ldw	r2,-32(fp)
 82257e8:	e0fff817 	ldw	r3,-32(fp)
 82257ec:	10c00415 	stw	r3,16(r2)
        p_dev->if_num = if_count;
 82257f0:	e0bff817 	ldw	r2,-32(fp)
 82257f4:	e0ffff17 	ldw	r3,-4(fp)
 82257f8:	10c00515 	stw	r3,20(r2)
        p_dev->p_net = nets[p_dev->if_num];
 82257fc:	e0bff817 	ldw	r2,-32(fp)
 8225800:	10c00517 	ldw	r3,20(r2)
 8225804:	008209b4 	movhi	r2,2086
 8225808:	10b82404 	addi	r2,r2,-8048
 822580c:	18c7883a 	add	r3,r3,r3
 8225810:	18c7883a 	add	r3,r3,r3
 8225814:	10c5883a 	add	r2,r2,r3
 8225818:	10c00017 	ldw	r3,0(r2)
 822581c:	e0bff817 	ldw	r2,-32(fp)
 8225820:	10c00615 	stw	r3,24(r2)

        /* Perform device specific initialization. */
        (*(p_dev->init_func))(p_dev);
 8225824:	e0bff817 	ldw	r2,-32(fp)
 8225828:	10800317 	ldw	r2,12(r2)
 822582c:	e13ff817 	ldw	r4,-32(fp)
 8225830:	103ee83a 	callr	r2

        /* Get the interface IP address. */
        p_net = p_dev->p_net;
 8225834:	e0bff817 	ldw	r2,-32(fp)
 8225838:	10800617 	ldw	r2,24(r2)
 822583c:	e0bffa15 	stw	r2,-24(fp)
                
        if (get_ip_addr(p_dev, &ipaddr, &netmask, &gw, &use_dhcp))
 8225840:	e17ffd04 	addi	r5,fp,-12
 8225844:	e13ffc04 	addi	r4,fp,-16
 8225848:	e0fffb04 	addi	r3,fp,-20
 822584c:	e0bffe04 	addi	r2,fp,-8
 8225850:	d8800015 	stw	r2,0(sp)
 8225854:	280f883a 	mov	r7,r5
 8225858:	200d883a 	mov	r6,r4
 822585c:	180b883a 	mov	r5,r3
 8225860:	e13ff817 	ldw	r4,-32(fp)
 8225864:	82011180 	call	8201118 <get_ip_addr>
 8225868:	10001726 	beq	r2,zero,82258c8 <iniche_devices_init+0x10c>
            /* 
             * OR in the DHCP flag, if enabled. This will allow any
             * application-specific flag setting in get_ip_addr(), such 
             * as enabling AUTOIP, to occur 
             */
            if (use_dhcp) {
 822586c:	e0bffe17 	ldw	r2,-8(fp)
 8225870:	10000526 	beq	r2,zero,8225888 <iniche_devices_init+0xcc>
                p_net->n_flags |= NF_DHCPC;
 8225874:	e0bffa17 	ldw	r2,-24(fp)
 8225878:	10802a17 	ldw	r2,168(r2)
 822587c:	10c04014 	ori	r3,r2,256
 8225880:	e0bffa17 	ldw	r2,-24(fp)
 8225884:	10c02a15 	stw	r3,168(r2)
            }
#endif
            p_net->n_ipaddr = ipaddr;
 8225888:	e0fffb17 	ldw	r3,-20(fp)
 822588c:	e0bffa17 	ldw	r2,-24(fp)
 8225890:	10c00a15 	stw	r3,40(r2)
            p_net->snmask = netmask;
 8225894:	e0fffc17 	ldw	r3,-16(fp)
 8225898:	e0bffa17 	ldw	r2,-24(fp)
 822589c:	10c00c15 	stw	r3,48(r2)
            p_net->n_defgw = gw;
 82258a0:	e0fffd17 	ldw	r3,-12(fp)
 82258a4:	e0bffa17 	ldw	r2,-24(fp)
 82258a8:	10c00d15 	stw	r3,52(r2)
#ifdef IP_MULTICAST
	    p_net->n_mcastlist = mcastlist;
 82258ac:	e0fffa17 	ldw	r3,-24(fp)
 82258b0:	00820934 	movhi	r2,2084
 82258b4:	10b47e04 	addi	r2,r2,-11784
 82258b8:	18802b15 	stw	r2,172(r3)
#if defined (IGMP_V1) || defined (IGMP_V2)
            p_net->igmp_oper_mode = IGMP_MODE_DEFAULT;
 82258bc:	e0bffa17 	ldw	r2,-24(fp)
 82258c0:	00c00084 	movi	r3,2
 82258c4:	10c02f05 	stb	r3,188(r2)
#endif  /* IGMPv1 or IGMPv2 */
#endif  /* IP_MULTICAST */
        }

        /* Initialize next device. */
        if_count++;
 82258c8:	e0bfff17 	ldw	r2,-4(fp)
 82258cc:	10800044 	addi	r2,r2,1
 82258d0:	e0bfff15 	stw	r2,-4(fp)
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
 82258d4:	e0bff817 	ldw	r2,-32(fp)
 82258d8:	10800017 	ldw	r2,0(r2)
 82258dc:	e0bff815 	stw	r2,-32(fp)
    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 82258e0:	e0fff817 	ldw	r3,-32(fp)
 82258e4:	e0bff917 	ldw	r2,-28(fp)
 82258e8:	18bfbe1e 	bne	r3,r2,82257e4 <iniche_devices_init+0x28>
        /* Initialize next device. */
        if_count++;
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
    }

    return (if_count);
 82258ec:	e0bfff17 	ldw	r2,-4(fp)
}
 82258f0:	e037883a 	mov	sp,fp
 82258f4:	dfc00117 	ldw	ra,4(sp)
 82258f8:	df000017 	ldw	fp,0(sp)
 82258fc:	dec00204 	addi	sp,sp,8
 8225900:	f800283a 	ret

08225904 <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
 8225904:	defff904 	addi	sp,sp,-28
 8225908:	dfc00615 	stw	ra,24(sp)
 822590c:	df000515 	stw	fp,20(sp)
 8225910:	df000504 	addi	fp,sp,20
 8225914:	e13ffd15 	stw	r4,-12(fp)
 8225918:	e17ffe15 	stw	r5,-8(fp)
 822591c:	e1bfff15 	stw	r6,-4(fp)
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
 8225920:	e0bffd17 	ldw	r2,-12(fp)
 8225924:	10800808 	cmpgei	r2,r2,32
 8225928:	1000051e 	bne	r2,zero,8225940 <read+0x3c>
 822592c:	e1bfff17 	ldw	r6,-4(fp)
 8225930:	e17ffe17 	ldw	r5,-8(fp)
 8225934:	e13ffd17 	ldw	r4,-12(fp)
 8225938:	823c4c00 	call	823c4c0 <alt_read>
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
 822593c:	00000806 	br	8225960 <read+0x5c>
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
 8225940:	e0bfff17 	ldw	r2,-4(fp)
 8225944:	d8000115 	stw	zero,4(sp)
 8225948:	d8000015 	stw	zero,0(sp)
 822594c:	000f883a 	mov	r7,zero
 8225950:	100d883a 	mov	r6,r2
 8225954:	e17ffe17 	ldw	r5,-8(fp)
 8225958:	e13ffd17 	ldw	r4,-12(fp)
 822595c:	82282a00 	call	82282a0 <bsd_recvfrom>
}
 8225960:	e037883a 	mov	sp,fp
 8225964:	dfc00117 	ldw	ra,4(sp)
 8225968:	df000017 	ldw	fp,0(sp)
 822596c:	dec00204 	addi	sp,sp,8
 8225970:	f800283a 	ret

08225974 <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
 8225974:	defffb04 	addi	sp,sp,-20
 8225978:	dfc00415 	stw	ra,16(sp)
 822597c:	df000315 	stw	fp,12(sp)
 8225980:	df000304 	addi	fp,sp,12
 8225984:	e13ffd15 	stw	r4,-12(fp)
 8225988:	e17ffe15 	stw	r5,-8(fp)
 822598c:	e1bfff15 	stw	r6,-4(fp)
  if (fd < ALT_MAX_FD)
 8225990:	e0bffd17 	ldw	r2,-12(fp)
 8225994:	10800808 	cmpgei	r2,r2,32
 8225998:	1000051e 	bne	r2,zero,82259b0 <write+0x3c>
  {
    return alt_write (fd, ptr, len);
 822599c:	e1bfff17 	ldw	r6,-4(fp)
 82259a0:	e17ffe17 	ldw	r5,-8(fp)
 82259a4:	e13ffd17 	ldw	r4,-12(fp)
 82259a8:	823ca040 	call	823ca04 <alt_write>
 82259ac:	00000606 	br	82259c8 <write+0x54>
  }
  else
  { 
    return send (fd, (void*) ptr, len, 0);
 82259b0:	e0bfff17 	ldw	r2,-4(fp)
 82259b4:	000f883a 	mov	r7,zero
 82259b8:	100d883a 	mov	r6,r2
 82259bc:	e17ffe17 	ldw	r5,-8(fp)
 82259c0:	e13ffd17 	ldw	r4,-12(fp)
 82259c4:	82313f00 	call	82313f0 <t_send>
  }  
}
 82259c8:	e037883a 	mov	sp,fp
 82259cc:	dfc00117 	ldw	ra,4(sp)
 82259d0:	df000017 	ldw	fp,0(sp)
 82259d4:	dec00204 	addi	sp,sp,8
 82259d8:	f800283a 	ret

082259dc <Netinit>:
 * a non-zero error code
 */

int
Netinit()
{
 82259dc:	defffc04 	addi	sp,sp,-16
 82259e0:	dfc00315 	stw	ra,12(sp)
 82259e4:	df000215 	stw	fp,8(sp)
 82259e8:	df000204 	addi	fp,sp,8
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 82259ec:	e03ffe15 	stw	zero,-8(fp)
 82259f0:	00004a06 	br	8225b1c <Netinit+0x140>
   {
      /* sanity check on mtu, et.al. We added this because earlier 
       * drivers were sloppy about setting them, but new
       * logic depends on these sizes.
       */
      if (nets[i]->n_mib->ifType == ETHERNET)   /* ethernet? */
 82259f4:	008209b4 	movhi	r2,2086
 82259f8:	10b82404 	addi	r2,r2,-8048
 82259fc:	e0fffe17 	ldw	r3,-8(fp)
 8225a00:	18c7883a 	add	r3,r3,r3
 8225a04:	18c7883a 	add	r3,r3,r3
 8225a08:	10c5883a 	add	r2,r2,r3
 8225a0c:	10800017 	ldw	r2,0(r2)
 8225a10:	10802717 	ldw	r2,156(r2)
 8225a14:	10800217 	ldw	r2,8(r2)
 8225a18:	10800198 	cmpnei	r2,r2,6
 8225a1c:	1000241e 	bne	r2,zero,8225ab0 <Netinit+0xd4>
      {
         if (nets[i]->n_mtu == 0)   /* let device code override */
 8225a20:	008209b4 	movhi	r2,2086
 8225a24:	10b82404 	addi	r2,r2,-8048
 8225a28:	e0fffe17 	ldw	r3,-8(fp)
 8225a2c:	18c7883a 	add	r3,r3,r3
 8225a30:	18c7883a 	add	r3,r3,r3
 8225a34:	10c5883a 	add	r2,r2,r3
 8225a38:	10800017 	ldw	r2,0(r2)
 8225a3c:	10800917 	ldw	r2,36(r2)
 8225a40:	1000091e 	bne	r2,zero,8225a68 <Netinit+0x8c>
            nets[i]->n_mtu = 1514;
 8225a44:	008209b4 	movhi	r2,2086
 8225a48:	10b82404 	addi	r2,r2,-8048
 8225a4c:	e0fffe17 	ldw	r3,-8(fp)
 8225a50:	18c7883a 	add	r3,r3,r3
 8225a54:	18c7883a 	add	r3,r3,r3
 8225a58:	10c5883a 	add	r2,r2,r3
 8225a5c:	10800017 	ldw	r2,0(r2)
 8225a60:	00c17a84 	movi	r3,1514
 8225a64:	10c00915 	stw	r3,36(r2)

         if (nets[i]->n_lnh == 0)
 8225a68:	008209b4 	movhi	r2,2086
 8225a6c:	10b82404 	addi	r2,r2,-8048
 8225a70:	e0fffe17 	ldw	r3,-8(fp)
 8225a74:	18c7883a 	add	r3,r3,r3
 8225a78:	18c7883a 	add	r3,r3,r3
 8225a7c:	10c5883a 	add	r2,r2,r3
 8225a80:	10800017 	ldw	r2,0(r2)
 8225a84:	10800817 	ldw	r2,32(r2)
 8225a88:	1000091e 	bne	r2,zero,8225ab0 <Netinit+0xd4>
         {
#ifdef IEEE_802_3
            nets[i]->n_lnh = ETHHDR_SIZE + sizeof(struct snap_hdr);
#else
            nets[i]->n_lnh = ETHHDR_SIZE;
 8225a8c:	008209b4 	movhi	r2,2086
 8225a90:	10b82404 	addi	r2,r2,-8048
 8225a94:	e0fffe17 	ldw	r3,-8(fp)
 8225a98:	18c7883a 	add	r3,r3,r3
 8225a9c:	18c7883a 	add	r3,r3,r3
 8225aa0:	10c5883a 	add	r2,r2,r3
 8225aa4:	10800017 	ldw	r2,0(r2)
 8225aa8:	00c00404 	movi	r3,16
 8225aac:	10c00815 	stw	r3,32(r2)
      {
         continue;
      }
#endif   /* IP_V6 */

      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
 8225ab0:	008209b4 	movhi	r2,2086
 8225ab4:	10b82404 	addi	r2,r2,-8048
 8225ab8:	e0fffe17 	ldw	r3,-8(fp)
 8225abc:	18c7883a 	add	r3,r3,r3
 8225ac0:	18c7883a 	add	r3,r3,r3
 8225ac4:	10c5883a 	add	r2,r2,r3
 8225ac8:	10800017 	ldw	r2,0(r2)
 8225acc:	10800817 	ldw	r2,32(r2)
 8225ad0:	d0e08117 	ldw	r3,-32252(gp)
 8225ad4:	10c0010e 	bge	r2,r3,8225adc <Netinit+0x100>
 8225ad8:	1805883a 	mov	r2,r3
 8225adc:	d0a08115 	stw	r2,-32252(gp)
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
 8225ae0:	008209b4 	movhi	r2,2086
 8225ae4:	10b82404 	addi	r2,r2,-8048
 8225ae8:	e0fffe17 	ldw	r3,-8(fp)
 8225aec:	18c7883a 	add	r3,r3,r3
 8225af0:	18c7883a 	add	r3,r3,r3
 8225af4:	10c5883a 	add	r2,r2,r3
 8225af8:	10800017 	ldw	r2,0(r2)
 8225afc:	10800917 	ldw	r2,36(r2)
 8225b00:	d0e08217 	ldw	r3,-32248(gp)
 8225b04:	10c0010e 	bge	r2,r3,8225b0c <Netinit+0x130>
 8225b08:	1805883a 	mov	r2,r3
 8225b0c:	d0a08215 	stw	r2,-32248(gp)
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 8225b10:	e0bffe17 	ldw	r2,-8(fp)
 8225b14:	10800044 	addi	r2,r2,1
 8225b18:	e0bffe15 	stw	r2,-8(fp)
 8225b1c:	d0a08417 	ldw	r2,-32240(gp)
 8225b20:	1007883a 	mov	r3,r2
 8225b24:	e0bffe17 	ldw	r2,-8(fp)
 8225b28:	10ffb216 	blt	r2,r3,82259f4 <Netinit+0x18>
      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
   }

   /* set up the received packet queue */
   rcvdq.q_head = rcvdq.q_tail = NULL;
 8225b2c:	008209b4 	movhi	r2,2086
 8225b30:	10b75f04 	addi	r2,r2,-8836
 8225b34:	10000115 	stw	zero,4(r2)
 8225b38:	008209b4 	movhi	r2,2086
 8225b3c:	10b75f04 	addi	r2,r2,-8836
 8225b40:	10c00117 	ldw	r3,4(r2)
 8225b44:	008209b4 	movhi	r2,2086
 8225b48:	10b75f04 	addi	r2,r2,-8836
 8225b4c:	10c00015 	stw	r3,0(r2)
   rcvdq.q_max = rcvdq.q_min = rcvdq.q_len = 0;
 8225b50:	008209b4 	movhi	r2,2086
 8225b54:	10b75f04 	addi	r2,r2,-8836
 8225b58:	10000215 	stw	zero,8(r2)
 8225b5c:	008209b4 	movhi	r2,2086
 8225b60:	10b75f04 	addi	r2,r2,-8836
 8225b64:	10c00217 	ldw	r3,8(r2)
 8225b68:	008209b4 	movhi	r2,2086
 8225b6c:	10b75f04 	addi	r2,r2,-8836
 8225b70:	10c00415 	stw	r3,16(r2)
 8225b74:	008209b4 	movhi	r2,2086
 8225b78:	10b75f04 	addi	r2,r2,-8836
 8225b7c:	10c00417 	ldw	r3,16(r2)
 8225b80:	008209b4 	movhi	r2,2086
 8225b84:	10b75f04 	addi	r2,r2,-8836
 8225b88:	10c00315 	stw	r3,12(r2)

   /* initialize freeq */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8225b8c:	01000084 	movi	r4,2
 8225b90:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   e = pk_init();
 8225b94:	822c5d00 	call	822c5d0 <pk_init>
 8225b98:	e0bfff15 	stw	r2,-4(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8225b9c:	01000084 	movi	r4,2
 8225ba0:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   if (e)   /* report error (memory ran out?) */
 8225ba4:	e0bfff17 	ldw	r2,-4(fp)
 8225ba8:	10000226 	beq	r2,zero,8225bb4 <Netinit+0x1d8>
      return e;
 8225bac:	e0bfff17 	ldw	r2,-4(fp)
 8225bb0:	0000ff06 	br	8225fb0 <Netinit+0x5d4>

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */
 8225bb4:	010208b4 	movhi	r4,2082
 8225bb8:	21184704 	addi	r4,r4,24860
 8225bbc:	8226a640 	call	8226a64 <exit_hook>

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 8225bc0:	e03ffe15 	stw	zero,-8(fp)
 8225bc4:	0000f506 	br	8225f9c <Netinit+0x5c0>
   {
      if (nets[i]->n_init != NULL)  /* If iface has init routine... */
 8225bc8:	008209b4 	movhi	r2,2086
 8225bcc:	10b82404 	addi	r2,r2,-8048
 8225bd0:	e0fffe17 	ldw	r3,-8(fp)
 8225bd4:	18c7883a 	add	r3,r3,r3
 8225bd8:	18c7883a 	add	r3,r3,r3
 8225bdc:	10c5883a 	add	r2,r2,r3
 8225be0:	10800017 	ldw	r2,0(r2)
 8225be4:	10800217 	ldw	r2,8(r2)
 8225be8:	10009126 	beq	r2,zero,8225e30 <Netinit+0x454>
      {
         if ((e = (*nets[i]->n_init)(i)) != 0)  /* call init routine */
 8225bec:	008209b4 	movhi	r2,2086
 8225bf0:	10b82404 	addi	r2,r2,-8048
 8225bf4:	e0fffe17 	ldw	r3,-8(fp)
 8225bf8:	18c7883a 	add	r3,r3,r3
 8225bfc:	18c7883a 	add	r3,r3,r3
 8225c00:	10c5883a 	add	r2,r2,r3
 8225c04:	10800017 	ldw	r2,0(r2)
 8225c08:	10800217 	ldw	r2,8(r2)
 8225c0c:	e13ffe17 	ldw	r4,-8(fp)
 8225c10:	103ee83a 	callr	r2
 8225c14:	e0bfff15 	stw	r2,-4(fp)
 8225c18:	e0bfff17 	ldw	r2,-4(fp)
 8225c1c:	10001026 	beq	r2,zero,8225c60 <Netinit+0x284>
         {
            dprintf("init error %d on net[%d]\n", e, i);
 8225c20:	e1bffe17 	ldw	r6,-8(fp)
 8225c24:	e17fff17 	ldw	r5,-4(fp)
 8225c28:	01020974 	movhi	r4,2085
 8225c2c:	213fb904 	addi	r4,r4,-284
 8225c30:	820331c0 	call	820331c <printf>
            nets[i]->n_mib->ifOperStatus = NI_DOWN;
 8225c34:	008209b4 	movhi	r2,2086
 8225c38:	10b82404 	addi	r2,r2,-8048
 8225c3c:	e0fffe17 	ldw	r3,-8(fp)
 8225c40:	18c7883a 	add	r3,r3,r3
 8225c44:	18c7883a 	add	r3,r3,r3
 8225c48:	10c5883a 	add	r2,r2,r3
 8225c4c:	10800017 	ldw	r2,0(r2)
 8225c50:	10802717 	ldw	r2,156(r2)
 8225c54:	00c00084 	movi	r3,2
 8225c58:	10c00715 	stw	r3,28(r2)
            continue;   /* ignore ifaces which fail */
 8225c5c:	0000cc06 	br	8225f90 <Netinit+0x5b4>
         }
         /* If interface is ethernet, set bcast flag bit. This
          * should really be done by the init routine, but we handle it
          * here to support MAC drivers which predate the flags field.
          */
         if(nets[i]->n_mib->ifType == ETHERNET)
 8225c60:	008209b4 	movhi	r2,2086
 8225c64:	10b82404 	addi	r2,r2,-8048
 8225c68:	e0fffe17 	ldw	r3,-8(fp)
 8225c6c:	18c7883a 	add	r3,r3,r3
 8225c70:	18c7883a 	add	r3,r3,r3
 8225c74:	10c5883a 	add	r2,r2,r3
 8225c78:	10800017 	ldw	r2,0(r2)
 8225c7c:	10802717 	ldw	r2,156(r2)
 8225c80:	10800217 	ldw	r2,8(r2)
 8225c84:	10800198 	cmpnei	r2,r2,6
 8225c88:	1000111e 	bne	r2,zero,8225cd0 <Netinit+0x2f4>
            nets[i]->n_flags |= NF_BCAST;
 8225c8c:	008209b4 	movhi	r2,2086
 8225c90:	10b82404 	addi	r2,r2,-8048
 8225c94:	e0fffe17 	ldw	r3,-8(fp)
 8225c98:	18c7883a 	add	r3,r3,r3
 8225c9c:	18c7883a 	add	r3,r3,r3
 8225ca0:	10c5883a 	add	r2,r2,r3
 8225ca4:	11000017 	ldw	r4,0(r2)
 8225ca8:	008209b4 	movhi	r2,2086
 8225cac:	10b82404 	addi	r2,r2,-8048
 8225cb0:	e0fffe17 	ldw	r3,-8(fp)
 8225cb4:	18c7883a 	add	r3,r3,r3
 8225cb8:	18c7883a 	add	r3,r3,r3
 8225cbc:	10c5883a 	add	r2,r2,r3
 8225cc0:	10800017 	ldw	r2,0(r2)
 8225cc4:	10802a17 	ldw	r2,168(r2)
 8225cc8:	10800054 	ori	r2,r2,1
 8225ccc:	20802a15 	stw	r2,168(r4)

         /* set ifAdminStatus in case init() routine forgot to. IfOperStatus
          * is not nessecarily up at this point, as in the case of a modem which
          * is now in autoanswer mode.
          */
         nets[i]->n_mib->ifAdminStatus = NI_UP;
 8225cd0:	008209b4 	movhi	r2,2086
 8225cd4:	10b82404 	addi	r2,r2,-8048
 8225cd8:	e0fffe17 	ldw	r3,-8(fp)
 8225cdc:	18c7883a 	add	r3,r3,r3
 8225ce0:	18c7883a 	add	r3,r3,r3
 8225ce4:	10c5883a 	add	r2,r2,r3
 8225ce8:	10800017 	ldw	r2,0(r2)
 8225cec:	10802717 	ldw	r2,156(r2)
 8225cf0:	00c00044 	movi	r3,1
 8225cf4:	10c00615 	stw	r3,24(r2)

         /* assign default names to unnamed ifaces */
         if(nets[i]->name[0] == 0)     /* no name set by prep or init */
 8225cf8:	008209b4 	movhi	r2,2086
 8225cfc:	10b82404 	addi	r2,r2,-8048
 8225d00:	e0fffe17 	ldw	r3,-8(fp)
 8225d04:	18c7883a 	add	r3,r3,r3
 8225d08:	18c7883a 	add	r3,r3,r3
 8225d0c:	10c5883a 	add	r2,r2,r3
 8225d10:	10800017 	ldw	r2,0(r2)
 8225d14:	10800103 	ldbu	r2,4(r2)
 8225d18:	10803fcc 	andi	r2,r2,255
 8225d1c:	1080201c 	xori	r2,r2,128
 8225d20:	10bfe004 	addi	r2,r2,-128
 8225d24:	1000421e 	bne	r2,zero,8225e30 <Netinit+0x454>
         {
            if(nets[i]->n_mib->ifType == ETHERNET)
 8225d28:	008209b4 	movhi	r2,2086
 8225d2c:	10b82404 	addi	r2,r2,-8048
 8225d30:	e0fffe17 	ldw	r3,-8(fp)
 8225d34:	18c7883a 	add	r3,r3,r3
 8225d38:	18c7883a 	add	r3,r3,r3
 8225d3c:	10c5883a 	add	r2,r2,r3
 8225d40:	10800017 	ldw	r2,0(r2)
 8225d44:	10802717 	ldw	r2,156(r2)
 8225d48:	10800217 	ldw	r2,8(r2)
 8225d4c:	10800198 	cmpnei	r2,r2,6
 8225d50:	1000131e 	bne	r2,zero,8225da0 <Netinit+0x3c4>
            {
               nets[i]->name[0] = 'e';    /* "et1", "et2", etc. */
 8225d54:	008209b4 	movhi	r2,2086
 8225d58:	10b82404 	addi	r2,r2,-8048
 8225d5c:	e0fffe17 	ldw	r3,-8(fp)
 8225d60:	18c7883a 	add	r3,r3,r3
 8225d64:	18c7883a 	add	r3,r3,r3
 8225d68:	10c5883a 	add	r2,r2,r3
 8225d6c:	10800017 	ldw	r2,0(r2)
 8225d70:	00c01944 	movi	r3,101
 8225d74:	10c00105 	stb	r3,4(r2)
               nets[i]->name[1] = 't';
 8225d78:	008209b4 	movhi	r2,2086
 8225d7c:	10b82404 	addi	r2,r2,-8048
 8225d80:	e0fffe17 	ldw	r3,-8(fp)
 8225d84:	18c7883a 	add	r3,r3,r3
 8225d88:	18c7883a 	add	r3,r3,r3
 8225d8c:	10c5883a 	add	r2,r2,r3
 8225d90:	10800017 	ldw	r2,0(r2)
 8225d94:	00c01d04 	movi	r3,116
 8225d98:	10c00145 	stb	r3,5(r2)
 8225d9c:	00001206 	br	8225de8 <Netinit+0x40c>
            }
            else
            {
               nets[i]->name[0] = 'i';    /* "if1", "if2", etc. */
 8225da0:	008209b4 	movhi	r2,2086
 8225da4:	10b82404 	addi	r2,r2,-8048
 8225da8:	e0fffe17 	ldw	r3,-8(fp)
 8225dac:	18c7883a 	add	r3,r3,r3
 8225db0:	18c7883a 	add	r3,r3,r3
 8225db4:	10c5883a 	add	r2,r2,r3
 8225db8:	10800017 	ldw	r2,0(r2)
 8225dbc:	00c01a44 	movi	r3,105
 8225dc0:	10c00105 	stb	r3,4(r2)
               nets[i]->name[1] = 'f';
 8225dc4:	008209b4 	movhi	r2,2086
 8225dc8:	10b82404 	addi	r2,r2,-8048
 8225dcc:	e0fffe17 	ldw	r3,-8(fp)
 8225dd0:	18c7883a 	add	r3,r3,r3
 8225dd4:	18c7883a 	add	r3,r3,r3
 8225dd8:	10c5883a 	add	r2,r2,r3
 8225ddc:	10800017 	ldw	r2,0(r2)
 8225de0:	00c01984 	movi	r3,102
 8225de4:	10c00145 	stb	r3,5(r2)
            }
            nets[i]->name[2] = (char)(i + '1');
 8225de8:	008209b4 	movhi	r2,2086
 8225dec:	10b82404 	addi	r2,r2,-8048
 8225df0:	e0fffe17 	ldw	r3,-8(fp)
 8225df4:	18c7883a 	add	r3,r3,r3
 8225df8:	18c7883a 	add	r3,r3,r3
 8225dfc:	10c5883a 	add	r2,r2,r3
 8225e00:	10800017 	ldw	r2,0(r2)
 8225e04:	e0fffe17 	ldw	r3,-8(fp)
 8225e08:	18c00c44 	addi	r3,r3,49
 8225e0c:	10c00185 	stb	r3,6(r2)
            nets[i]->name[3] = '\0';
 8225e10:	008209b4 	movhi	r2,2086
 8225e14:	10b82404 	addi	r2,r2,-8048
 8225e18:	e0fffe17 	ldw	r3,-8(fp)
 8225e1c:	18c7883a 	add	r3,r3,r3
 8225e20:	18c7883a 	add	r3,r3,r3
 8225e24:	10c5883a 	add	r2,r2,r3
 8225e28:	10800017 	ldw	r2,0(r2)
 8225e2c:	100001c5 	stb	zero,7(r2)
         }
      }
      /* check on subnet routing - if no mask then make one */
      fixup_subnet_mask(i);      /* make mask for this net */
 8225e30:	e13ffe17 	ldw	r4,-8(fp)
 8225e34:	8225fc40 	call	8225fc4 <fixup_subnet_mask>

      /* build broadcast addresses */
      if(nets[i]->n_ipaddr != 0)
 8225e38:	008209b4 	movhi	r2,2086
 8225e3c:	10b82404 	addi	r2,r2,-8048
 8225e40:	e0fffe17 	ldw	r3,-8(fp)
 8225e44:	18c7883a 	add	r3,r3,r3
 8225e48:	18c7883a 	add	r3,r3,r3
 8225e4c:	10c5883a 	add	r2,r2,r3
 8225e50:	10800017 	ldw	r2,0(r2)
 8225e54:	10800a17 	ldw	r2,40(r2)
 8225e58:	10004d26 	beq	r2,zero,8225f90 <Netinit+0x5b4>
      {
         nets[i]->n_netbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 8225e5c:	008209b4 	movhi	r2,2086
 8225e60:	10b82404 	addi	r2,r2,-8048
 8225e64:	e0fffe17 	ldw	r3,-8(fp)
 8225e68:	18c7883a 	add	r3,r3,r3
 8225e6c:	18c7883a 	add	r3,r3,r3
 8225e70:	10c5883a 	add	r2,r2,r3
 8225e74:	11000017 	ldw	r4,0(r2)
 8225e78:	008209b4 	movhi	r2,2086
 8225e7c:	10b82404 	addi	r2,r2,-8048
 8225e80:	e0fffe17 	ldw	r3,-8(fp)
 8225e84:	18c7883a 	add	r3,r3,r3
 8225e88:	18c7883a 	add	r3,r3,r3
 8225e8c:	10c5883a 	add	r2,r2,r3
 8225e90:	10800017 	ldw	r2,0(r2)
 8225e94:	11400a17 	ldw	r5,40(r2)
 8225e98:	008209b4 	movhi	r2,2086
 8225e9c:	10b82404 	addi	r2,r2,-8048
 8225ea0:	e0fffe17 	ldw	r3,-8(fp)
 8225ea4:	18c7883a 	add	r3,r3,r3
 8225ea8:	18c7883a 	add	r3,r3,r3
 8225eac:	10c5883a 	add	r2,r2,r3
 8225eb0:	10800017 	ldw	r2,0(r2)
 8225eb4:	10800c17 	ldw	r2,48(r2)
 8225eb8:	0084303a 	nor	r2,zero,r2
 8225ebc:	2884b03a 	or	r2,r5,r2
 8225ec0:	20800e15 	stw	r2,56(r4)
         nets[i]->n_netbr42 = nets[i]->n_ipaddr & nets[i]->snmask;
 8225ec4:	008209b4 	movhi	r2,2086
 8225ec8:	10b82404 	addi	r2,r2,-8048
 8225ecc:	e0fffe17 	ldw	r3,-8(fp)
 8225ed0:	18c7883a 	add	r3,r3,r3
 8225ed4:	18c7883a 	add	r3,r3,r3
 8225ed8:	10c5883a 	add	r2,r2,r3
 8225edc:	11000017 	ldw	r4,0(r2)
 8225ee0:	008209b4 	movhi	r2,2086
 8225ee4:	10b82404 	addi	r2,r2,-8048
 8225ee8:	e0fffe17 	ldw	r3,-8(fp)
 8225eec:	18c7883a 	add	r3,r3,r3
 8225ef0:	18c7883a 	add	r3,r3,r3
 8225ef4:	10c5883a 	add	r2,r2,r3
 8225ef8:	10800017 	ldw	r2,0(r2)
 8225efc:	11400a17 	ldw	r5,40(r2)
 8225f00:	008209b4 	movhi	r2,2086
 8225f04:	10b82404 	addi	r2,r2,-8048
 8225f08:	e0fffe17 	ldw	r3,-8(fp)
 8225f0c:	18c7883a 	add	r3,r3,r3
 8225f10:	18c7883a 	add	r3,r3,r3
 8225f14:	10c5883a 	add	r2,r2,r3
 8225f18:	10800017 	ldw	r2,0(r2)
 8225f1c:	10800c17 	ldw	r2,48(r2)
 8225f20:	2884703a 	and	r2,r5,r2
 8225f24:	20800f15 	stw	r2,60(r4)
         nets[i]->n_subnetbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 8225f28:	008209b4 	movhi	r2,2086
 8225f2c:	10b82404 	addi	r2,r2,-8048
 8225f30:	e0fffe17 	ldw	r3,-8(fp)
 8225f34:	18c7883a 	add	r3,r3,r3
 8225f38:	18c7883a 	add	r3,r3,r3
 8225f3c:	10c5883a 	add	r2,r2,r3
 8225f40:	11000017 	ldw	r4,0(r2)
 8225f44:	008209b4 	movhi	r2,2086
 8225f48:	10b82404 	addi	r2,r2,-8048
 8225f4c:	e0fffe17 	ldw	r3,-8(fp)
 8225f50:	18c7883a 	add	r3,r3,r3
 8225f54:	18c7883a 	add	r3,r3,r3
 8225f58:	10c5883a 	add	r2,r2,r3
 8225f5c:	10800017 	ldw	r2,0(r2)
 8225f60:	11400a17 	ldw	r5,40(r2)
 8225f64:	008209b4 	movhi	r2,2086
 8225f68:	10b82404 	addi	r2,r2,-8048
 8225f6c:	e0fffe17 	ldw	r3,-8(fp)
 8225f70:	18c7883a 	add	r3,r3,r3
 8225f74:	18c7883a 	add	r3,r3,r3
 8225f78:	10c5883a 	add	r2,r2,r3
 8225f7c:	10800017 	ldw	r2,0(r2)
 8225f80:	10800c17 	ldw	r2,48(r2)
 8225f84:	0084303a 	nor	r2,zero,r2
 8225f88:	2884b03a 	or	r2,r5,r2
 8225f8c:	20801015 	stw	r2,64(r4)

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 8225f90:	e0bffe17 	ldw	r2,-8(fp)
 8225f94:	10800044 	addi	r2,r2,1
 8225f98:	e0bffe15 	stw	r2,-8(fp)
 8225f9c:	d0a08417 	ldw	r2,-32240(gp)
 8225fa0:	1007883a 	mov	r3,r2
 8225fa4:	e0bffe17 	ldw	r2,-8(fp)
 8225fa8:	10ff0716 	blt	r2,r3,8225bc8 <Netinit+0x1ec>
#if defined(DYNAMIC_IFACES) && defined(IN_MENUS)
   /* Install dynamic iface menu */
   install_menu(&dynif_menu[0]);
#endif /* DYNAMIC_IFACES && IN_MENUS */

   return(0);
 8225fac:	0005883a 	mov	r2,zero
}
 8225fb0:	e037883a 	mov	sp,fp
 8225fb4:	dfc00117 	ldw	ra,4(sp)
 8225fb8:	df000017 	ldw	fp,0(sp)
 8225fbc:	dec00204 	addi	sp,sp,8
 8225fc0:	f800283a 	ret

08225fc4 <fixup_subnet_mask>:
 * RETURNS: 
 */

void
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
 8225fc4:	defffc04 	addi	sp,sp,-16
 8225fc8:	dfc00315 	stw	ra,12(sp)
 8225fcc:	df000215 	stw	fp,8(sp)
 8225fd0:	df000204 	addi	fp,sp,8
 8225fd4:	e13fff15 	stw	r4,-4(fp)
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
 8225fd8:	008209b4 	movhi	r2,2086
 8225fdc:	10b82404 	addi	r2,r2,-8048
 8225fe0:	e0ffff17 	ldw	r3,-4(fp)
 8225fe4:	18c7883a 	add	r3,r3,r3
 8225fe8:	18c7883a 	add	r3,r3,r3
 8225fec:	10c5883a 	add	r2,r2,r3
 8225ff0:	10800017 	ldw	r2,0(r2)
 8225ff4:	10800c17 	ldw	r2,48(r2)
 8225ff8:	1000421e 	bne	r2,zero,8226104 <fixup_subnet_mask+0x140>
      return;

   /* things depending on IP address class: */
   if ((nets[netnum]->n_ipaddr & AMASK) == AADDR)
 8225ffc:	008209b4 	movhi	r2,2086
 8226000:	10b82404 	addi	r2,r2,-8048
 8226004:	e0ffff17 	ldw	r3,-4(fp)
 8226008:	18c7883a 	add	r3,r3,r3
 822600c:	18c7883a 	add	r3,r3,r3
 8226010:	10c5883a 	add	r2,r2,r3
 8226014:	10800017 	ldw	r2,0(r2)
 8226018:	10800a17 	ldw	r2,40(r2)
 822601c:	1080200c 	andi	r2,r2,128
 8226020:	1000031e 	bne	r2,zero,8226030 <fixup_subnet_mask+0x6c>
      smask = 0xFF000000L;
 8226024:	00bfc034 	movhi	r2,65280
 8226028:	e0bffe15 	stw	r2,-8(fp)
 822602c:	00001f06 	br	82260ac <fixup_subnet_mask+0xe8>
   else if((nets[netnum]->n_ipaddr & BMASK) == BADDR)
 8226030:	008209b4 	movhi	r2,2086
 8226034:	10b82404 	addi	r2,r2,-8048
 8226038:	e0ffff17 	ldw	r3,-4(fp)
 822603c:	18c7883a 	add	r3,r3,r3
 8226040:	18c7883a 	add	r3,r3,r3
 8226044:	10c5883a 	add	r2,r2,r3
 8226048:	10800017 	ldw	r2,0(r2)
 822604c:	10800a17 	ldw	r2,40(r2)
 8226050:	1080300c 	andi	r2,r2,192
 8226054:	10802018 	cmpnei	r2,r2,128
 8226058:	1000031e 	bne	r2,zero,8226068 <fixup_subnet_mask+0xa4>
      smask = 0xFFFF0000L;
 822605c:	00bffff4 	movhi	r2,65535
 8226060:	e0bffe15 	stw	r2,-8(fp)
 8226064:	00001106 	br	82260ac <fixup_subnet_mask+0xe8>
   else if((nets[netnum]->n_ipaddr & CMASK) == CADDR)
 8226068:	008209b4 	movhi	r2,2086
 822606c:	10b82404 	addi	r2,r2,-8048
 8226070:	e0ffff17 	ldw	r3,-4(fp)
 8226074:	18c7883a 	add	r3,r3,r3
 8226078:	18c7883a 	add	r3,r3,r3
 822607c:	10c5883a 	add	r2,r2,r3
 8226080:	10800017 	ldw	r2,0(r2)
 8226084:	10800a17 	ldw	r2,40(r2)
 8226088:	1080380c 	andi	r2,r2,224
 822608c:	10803018 	cmpnei	r2,r2,192
 8226090:	1000031e 	bne	r2,zero,82260a0 <fixup_subnet_mask+0xdc>
      smask = 0xFFFFFF00L;
 8226094:	00bfc004 	movi	r2,-256
 8226098:	e0bffe15 	stw	r2,-8(fp)
 822609c:	00000306 	br	82260ac <fixup_subnet_mask+0xe8>
   else
   {
      dtrap();    /* bad logic or setup values */
 82260a0:	822d4140 	call	822d414 <dtrap>
      smask = 0xFFFFFF00L;
 82260a4:	00bfc004 	movi	r2,-256
 82260a8:	e0bffe15 	stw	r2,-8(fp)
   }
   nets[netnum]->snmask = htonl(smask);
 82260ac:	008209b4 	movhi	r2,2086
 82260b0:	10b82404 	addi	r2,r2,-8048
 82260b4:	e0ffff17 	ldw	r3,-4(fp)
 82260b8:	18c7883a 	add	r3,r3,r3
 82260bc:	18c7883a 	add	r3,r3,r3
 82260c0:	10c5883a 	add	r2,r2,r3
 82260c4:	10800017 	ldw	r2,0(r2)
 82260c8:	e0fffe17 	ldw	r3,-8(fp)
 82260cc:	1808d63a 	srli	r4,r3,24
 82260d0:	e0fffe17 	ldw	r3,-8(fp)
 82260d4:	1806d23a 	srli	r3,r3,8
 82260d8:	18ffc00c 	andi	r3,r3,65280
 82260dc:	20c8b03a 	or	r4,r4,r3
 82260e0:	e0fffe17 	ldw	r3,-8(fp)
 82260e4:	18ffc00c 	andi	r3,r3,65280
 82260e8:	1806923a 	slli	r3,r3,8
 82260ec:	20c8b03a 	or	r4,r4,r3
 82260f0:	e0fffe17 	ldw	r3,-8(fp)
 82260f4:	1806963a 	slli	r3,r3,24
 82260f8:	20c6b03a 	or	r3,r4,r3
 82260fc:	10c00c15 	stw	r3,48(r2)
 8226100:	00000106 	br	8226108 <fixup_subnet_mask+0x144>
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
      return;
 8226104:	0001883a 	nop
   {
      dtrap();    /* bad logic or setup values */
      smask = 0xFFFFFF00L;
   }
   nets[netnum]->snmask = htonl(smask);
}
 8226108:	e037883a 	mov	sp,fp
 822610c:	dfc00117 	ldw	ra,4(sp)
 8226110:	df000017 	ldw	fp,0(sp)
 8226114:	dec00204 	addi	sp,sp,8
 8226118:	f800283a 	ret

0822611c <netclose>:
 * RETURNS: 
 */

void
netclose()
{
 822611c:	defffc04 	addi	sp,sp,-16
 8226120:	dfc00315 	stw	ra,12(sp)
 8226124:	df000215 	stw	fp,8(sp)
 8226128:	df000204 	addi	fp,sp,8
   NET ifp;
   int index = 0;
 822612c:	e03fff15 	stw	zero,-4(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
 8226130:	d0a08317 	ldw	r2,-32244(gp)
 8226134:	1080010c 	andi	r2,r2,4
 8226138:	10000326 	beq	r2,zero,8226148 <netclose+0x2c>
 822613c:	01020974 	movhi	r4,2085
 8226140:	213fc004 	addi	r4,r4,-256
 8226144:	82035a00 	call	82035a0 <puts>
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 8226148:	008209b4 	movhi	r2,2086
 822614c:	10ba6504 	addi	r2,r2,-5740
 8226150:	10800017 	ldw	r2,0(r2)
 8226154:	e0bffe15 	stw	r2,-8(fp)
 8226158:	00002106 	br	82261e0 <netclose+0xc4>
   {
      if (ifp->n_close)
 822615c:	e0bffe17 	ldw	r2,-8(fp)
 8226160:	10800517 	ldw	r2,20(r2)
 8226164:	10000f26 	beq	r2,zero,82261a4 <netclose+0x88>
      {
         dprintf("netclose: closing iface %s\n", ifp->n_mib->ifDescr);
 8226168:	e0bffe17 	ldw	r2,-8(fp)
 822616c:	10802717 	ldw	r2,156(r2)
 8226170:	10800117 	ldw	r2,4(r2)
 8226174:	100b883a 	mov	r5,r2
 8226178:	01020974 	movhi	r4,2085
 822617c:	213fc504 	addi	r4,r4,-236
 8226180:	820331c0 	call	820331c <printf>
         (*(ifp->n_close))(index++);
 8226184:	e0bffe17 	ldw	r2,-8(fp)
 8226188:	10c00517 	ldw	r3,20(r2)
 822618c:	e0bfff17 	ldw	r2,-4(fp)
 8226190:	11000044 	addi	r4,r2,1
 8226194:	e13fff15 	stw	r4,-4(fp)
 8226198:	1009883a 	mov	r4,r2
 822619c:	183ee83a 	callr	r3
 82261a0:	00000c06 	br	82261d4 <netclose+0xb8>
      }
      else
      {
#ifdef NPDEBUG
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
 82261a4:	d0a08317 	ldw	r2,-32244(gp)
 82261a8:	1080010c 	andi	r2,r2,4
 82261ac:	10000626 	beq	r2,zero,82261c8 <netclose+0xac>
 82261b0:	e0bffe17 	ldw	r2,-8(fp)
 82261b4:	10800104 	addi	r2,r2,4
 82261b8:	100b883a 	mov	r5,r2
 82261bc:	01020974 	movhi	r4,2085
 82261c0:	213fcc04 	addi	r4,r4,-208
 82261c4:	820331c0 	call	820331c <printf>
#endif
         index++;
 82261c8:	e0bfff17 	ldw	r2,-4(fp)
 82261cc:	10800044 	addi	r2,r2,1
 82261d0:	e0bfff15 	stw	r2,-4(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 82261d4:	e0bffe17 	ldw	r2,-8(fp)
 82261d8:	10800017 	ldw	r2,0(r2)
 82261dc:	e0bffe15 	stw	r2,-8(fp)
 82261e0:	e0bffe17 	ldw	r2,-8(fp)
 82261e4:	103fdd1e 	bne	r2,zero,822615c <netclose+0x40>
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
#endif
         index++;
      }
   }
}
 82261e8:	0001883a 	nop
 82261ec:	e037883a 	mov	sp,fp
 82261f0:	dfc00117 	ldw	ra,4(sp)
 82261f4:	df000017 	ldw	fp,0(sp)
 82261f8:	dec00204 	addi	sp,sp,8
 82261fc:	f800283a 	ret

08226200 <pktdemux>:
 * RETURNS: void
 */

void
pktdemux()
{
 8226200:	defff904 	addi	sp,sp,-28
 8226204:	dfc00615 	stw	ra,24(sp)
 8226208:	df000515 	stw	fp,20(sp)
 822620c:	df000504 	addi	fp,sp,20
   NET      ifc;                /* interface packet came from */
   IFMIB    mib;
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */
 8226210:	e03ffb15 	stw	zero,-20(fp)

   while (rcvdq.q_len)
 8226214:	0000d906 	br	822657c <pktdemux+0x37c>
   {
      /* If we are low on free packets, don't hog CPU cycles */
      if (pkts++ > bigfreeq.q_len)
 8226218:	e0fffb17 	ldw	r3,-20(fp)
 822621c:	18800044 	addi	r2,r3,1
 8226220:	e0bffb15 	stw	r2,-20(fp)
 8226224:	008209b4 	movhi	r2,2086
 8226228:	10b8cb04 	addi	r2,r2,-7380
 822622c:	10800217 	ldw	r2,8(r2)
 8226230:	10c0020e 	bge	r2,r3,822623c <pktdemux+0x3c>
      {
#ifdef SUPERLOOP
         return;        /* don't hog stack on superloop */
#else    /* SUPERLOOP */
         tk_yield(); /* let application tasks process received packets */
 8226234:	82296b00 	call	82296b0 <tk_yield>
         pkts = 0;   /* reset counter */
 8226238:	e03ffb15 	stw	zero,-20(fp)
#endif   /* SUPERLOOP else */
      }

      /* If we get receive interupt from the net during this
      lock, the MAC driver needs to wait or reschedule */
      LOCK_NET_RESOURCE(RXQ_RESID);
 822623c:	01000044 	movi	r4,1
 8226240:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pkt = (PACKET)q_deq(&rcvdq);
 8226244:	010209b4 	movhi	r4,2086
 8226248:	21375f04 	addi	r4,r4,-8836
 822624c:	822cd440 	call	822cd44 <getq>
 8226250:	e0bffc15 	stw	r2,-16(fp)
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 8226254:	01000044 	movi	r4,1
 8226258:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      if (!pkt) panic("pktdemux: got null pkt");
 822625c:	e0bffc17 	ldw	r2,-16(fp)
 8226260:	1000031e 	bne	r2,zero,8226270 <pktdemux+0x70>
 8226264:	01020974 	movhi	r4,2085
 8226268:	213fd304 	addi	r4,r4,-180
 822626c:	8228aec0 	call	8228aec <panic>
      ifc = pkt->net;
 8226270:	e0bffc17 	ldw	r2,-16(fp)
 8226274:	10800617 	ldw	r2,24(r2)
 8226278:	e0bffd15 	stw	r2,-12(fp)

      mib = ifc->n_mib;
 822627c:	e0bffd17 	ldw	r2,-12(fp)
 8226280:	10802717 	ldw	r2,156(r2)
 8226284:	e0bffe15 	stw	r2,-8(fp)
      /* maintain mib stats for unicast and broadcast */
      if (isbcast(ifc, (u_char*)pkt->nb_buff + ETHHDR_BIAS))
 8226288:	e0bffc17 	ldw	r2,-16(fp)
 822628c:	10800117 	ldw	r2,4(r2)
 8226290:	10800084 	addi	r2,r2,2
 8226294:	100b883a 	mov	r5,r2
 8226298:	e13ffd17 	ldw	r4,-12(fp)
 822629c:	823ec1c0 	call	823ec1c <isbcast>
 82262a0:	10000626 	beq	r2,zero,82262bc <pktdemux+0xbc>
         mib->ifInNUcastPkts++;
 82262a4:	e0bffe17 	ldw	r2,-8(fp)
 82262a8:	10800b17 	ldw	r2,44(r2)
 82262ac:	10c00044 	addi	r3,r2,1
 82262b0:	e0bffe17 	ldw	r2,-8(fp)
 82262b4:	10c00b15 	stw	r3,44(r2)
 82262b8:	00000506 	br	82262d0 <pktdemux+0xd0>
      else
         mib->ifInUcastPkts++;
 82262bc:	e0bffe17 	ldw	r2,-8(fp)
 82262c0:	10800a17 	ldw	r2,40(r2)
 82262c4:	10c00044 	addi	r3,r2,1
 82262c8:	e0bffe17 	ldw	r2,-8(fp)
 82262cc:	10c00a15 	stw	r3,40(r2)

      if(mib->ifAdminStatus == NI_DOWN)
 82262d0:	e0bffe17 	ldw	r2,-8(fp)
 82262d4:	10800617 	ldw	r2,24(r2)
 82262d8:	10800098 	cmpnei	r2,r2,2
 82262dc:	10000c1e 	bne	r2,zero,8226310 <pktdemux+0x110>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 82262e0:	01000084 	movi	r4,2
 82262e4:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free(pkt);  /* dump packet from downed interface */
 82262e8:	e13ffc17 	ldw	r4,-16(fp)
 82262ec:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82262f0:	01000084 	movi	r4,2
 82262f4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         mib->ifInDiscards++;
 82262f8:	e0bffe17 	ldw	r2,-8(fp)
 82262fc:	10800c17 	ldw	r2,48(r2)
 8226300:	10c00044 	addi	r3,r2,1
 8226304:	e0bffe17 	ldw	r2,-8(fp)
 8226308:	10c00c15 	stw	r3,48(r2)
         continue;      /* next packet */
 822630c:	00009b06 	br	822657c <pktdemux+0x37c>
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 8226310:	e0bffc17 	ldw	r2,-16(fp)
 8226314:	10800117 	ldw	r2,4(r2)
 8226318:	10bfff04 	addi	r2,r2,-4
 822631c:	10800003 	ldbu	r2,0(r2)
 8226320:	10803fcc 	andi	r2,r2,255
 8226324:	1080201c 	xori	r2,r2,128
 8226328:	10bfe004 	addi	r2,r2,-128
 822632c:	10801358 	cmpnei	r2,r2,77
 8226330:	10000b1e 	bne	r2,zero,8226360 <pktdemux+0x160>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
 8226334:	e0bffc17 	ldw	r2,-16(fp)
 8226338:	10c00117 	ldw	r3,4(r2)
 822633c:	e0bffc17 	ldw	r2,-16(fp)
 8226340:	10800217 	ldw	r2,8(r2)
 8226344:	1885883a 	add	r2,r3,r2
 8226348:	10800003 	ldbu	r2,0(r2)
         mib->ifInDiscards++;
         continue;      /* next packet */
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 822634c:	10803fcc 	andi	r2,r2,255
 8226350:	1080201c 	xori	r2,r2,128
 8226354:	10bfe004 	addi	r2,r2,-128
 8226358:	10801360 	cmpeqi	r2,r2,77
 822635c:	1000041e 	bne	r2,zero,8226370 <pktdemux+0x170>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
      {
         dtrap();
 8226360:	822d4140 	call	822d414 <dtrap>
         panic("pktdemux: corrupt pkt");
 8226364:	01020974 	movhi	r4,2085
 8226368:	213fd904 	addi	r4,r4,-156
 822636c:	8228aec0 	call	8228aec <panic>
         }
      }
#endif   /* LOSSY_IO */

      /* see if driver set pkt->nb_prot and pkt->type */
      if((ifc->n_flags & NF_NBPROT) == 0)
 8226370:	e0bffd17 	ldw	r2,-12(fp)
 8226374:	10802a17 	ldw	r2,168(r2)
 8226378:	1080020c 	andi	r2,r2,8
 822637c:	1000491e 	bne	r2,zero,82264a4 <pktdemux+0x2a4>
          * probably the right thing to do, but because of this historic
          * inconsistency we don't try to fix it here - the longer size
          * turns out to be harmless since the IP layer fixes the size
          * based on the IP header length field.
          */
         switch(ifc->n_mib->ifType)
 8226380:	e0bffd17 	ldw	r2,-12(fp)
 8226384:	10802717 	ldw	r2,156(r2)
 8226388:	10800217 	ldw	r2,8(r2)
 822638c:	108001a0 	cmpeqi	r2,r2,6
 8226390:	10003626 	beq	r2,zero,822646c <pktdemux+0x26c>
         {
         case ETHERNET:
            /* get pointer to ethernet header */
            eth = (pkt->nb_buff + ETHHDR_BIAS);
 8226394:	e0bffc17 	ldw	r2,-16(fp)
 8226398:	10800117 	ldw	r2,4(r2)
 822639c:	10800084 	addi	r2,r2,2
 82263a0:	e0bfff15 	stw	r2,-4(fp)
            {
               pkt->type = htons((unshort)ET_TYPE_GET(eth));
               pkt->nb_prot = pkt->nb_buff + ETHHDR_SIZE;
            }
#else
            pkt->type = htons((unshort)ET_TYPE_GET(eth));
 82263a4:	e0bfff17 	ldw	r2,-4(fp)
 82263a8:	10800304 	addi	r2,r2,12
 82263ac:	10800003 	ldbu	r2,0(r2)
 82263b0:	10803fcc 	andi	r2,r2,255
 82263b4:	1080201c 	xori	r2,r2,128
 82263b8:	10bfe004 	addi	r2,r2,-128
 82263bc:	1004923a 	slli	r2,r2,8
 82263c0:	1007883a 	mov	r3,r2
 82263c4:	e0bfff17 	ldw	r2,-4(fp)
 82263c8:	10800344 	addi	r2,r2,13
 82263cc:	10800003 	ldbu	r2,0(r2)
 82263d0:	10803fcc 	andi	r2,r2,255
 82263d4:	1080201c 	xori	r2,r2,128
 82263d8:	10bfe004 	addi	r2,r2,-128
 82263dc:	10803fcc 	andi	r2,r2,255
 82263e0:	1885883a 	add	r2,r3,r2
 82263e4:	10bfffcc 	andi	r2,r2,65535
 82263e8:	1004d23a 	srli	r2,r2,8
 82263ec:	1007883a 	mov	r3,r2
 82263f0:	e0bfff17 	ldw	r2,-4(fp)
 82263f4:	10800304 	addi	r2,r2,12
 82263f8:	10800003 	ldbu	r2,0(r2)
 82263fc:	10803fcc 	andi	r2,r2,255
 8226400:	1080201c 	xori	r2,r2,128
 8226404:	10bfe004 	addi	r2,r2,-128
 8226408:	1004923a 	slli	r2,r2,8
 822640c:	1009883a 	mov	r4,r2
 8226410:	e0bfff17 	ldw	r2,-4(fp)
 8226414:	10800344 	addi	r2,r2,13
 8226418:	10800003 	ldbu	r2,0(r2)
 822641c:	10803fcc 	andi	r2,r2,255
 8226420:	1080201c 	xori	r2,r2,128
 8226424:	10bfe004 	addi	r2,r2,-128
 8226428:	10803fcc 	andi	r2,r2,255
 822642c:	2085883a 	add	r2,r4,r2
 8226430:	10bfffcc 	andi	r2,r2,65535
 8226434:	1004923a 	slli	r2,r2,8
 8226438:	1884b03a 	or	r2,r3,r2
 822643c:	1007883a 	mov	r3,r2
 8226440:	e0bffc17 	ldw	r2,-16(fp)
 8226444:	10c0080d 	sth	r3,32(r2)
            pkt->nb_prot = pkt->nb_buff + pkt->net->n_lnh;
 8226448:	e0bffc17 	ldw	r2,-16(fp)
 822644c:	10800117 	ldw	r2,4(r2)
 8226450:	e0fffc17 	ldw	r3,-16(fp)
 8226454:	18c00617 	ldw	r3,24(r3)
 8226458:	18c00817 	ldw	r3,32(r3)
 822645c:	10c7883a 	add	r3,r2,r3
 8226460:	e0bffc17 	ldw	r2,-16(fp)
 8226464:	10c00315 	stw	r3,12(r2)
#endif   /* IEEE_802_3 */
            break;
 8226468:	00000e06 	br	82264a4 <pktdemux+0x2a4>
         case PPPOE:
            /* do not change type yet, for PPPoE */
            break;
#endif   /* USE_PPPOE */
         default:    /* driver bug? */
            dprintf("pktdemux: bad Iface type %ld\n",ifc->n_mib->ifType);
 822646c:	e0bffd17 	ldw	r2,-12(fp)
 8226470:	10802717 	ldw	r2,156(r2)
 8226474:	10800217 	ldw	r2,8(r2)
 8226478:	100b883a 	mov	r5,r2
 822647c:	01020974 	movhi	r4,2085
 8226480:	213fdf04 	addi	r4,r4,-132
 8226484:	820331c0 	call	820331c <printf>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8226488:	01000084 	movi	r4,2
 822648c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
            pk_free(pkt);
 8226490:	e13ffc17 	ldw	r4,-16(fp)
 8226494:	822cbbc0 	call	822cbbc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226498:	01000084 	movi	r4,2
 822649c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
            continue;
 82264a0:	00003606 	br	822657c <pktdemux+0x37c>
         }
      }

      /* pkt->nb_prot and pkt->type are now set. pass pkt to upper layer */
      switch(pkt->type)
 82264a4:	e0bffc17 	ldw	r2,-16(fp)
 82264a8:	1080080b 	ldhu	r2,32(r2)
 82264ac:	10bfffcc 	andi	r2,r2,65535
 82264b0:	10c00220 	cmpeqi	r3,r2,8
 82264b4:	1800031e 	bne	r3,zero,82264c4 <pktdemux+0x2c4>
 82264b8:	10818220 	cmpeqi	r2,r2,1544
 82264bc:	1000081e 	bne	r2,zero,82264e0 <pktdemux+0x2e0>
 82264c0:	00000e06 	br	82264fc <pktdemux+0x2fc>
      {
      case IPTP:     /* IP type */
         LOCK_NET_RESOURCE(NET_RESID);
 82264c4:	0009883a 	mov	r4,zero
 82264c8:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
#ifdef SHARED_IPADDRS
         add_share_route(pkt);
#endif /* SHARED_IPADDRS */
#ifdef IP_V4
         ip_rcv(pkt);
 82264cc:	e13ffc17 	ldw	r4,-16(fp)
 82264d0:	8242a800 	call	8242a80 <ip_rcv>
            /* don't care, it's IPv4 */
            LOCK_NET_RESOURCE(FREEQ_RESID);
            pk_free(pkt);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif
		UNLOCK_NET_RESOURCE(NET_RESID);
 82264d4:	0009883a 	mov	r4,zero
 82264d8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         break;
 82264dc:	00002606 	br	8226578 <pktdemux+0x378>
#ifdef INCLUDE_ARP
      case ARPTP:       /* ARP type */
         LOCK_NET_RESOURCE(NET_RESID);
 82264e0:	0009883a 	mov	r4,zero
 82264e4:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         arprcv(pkt);
 82264e8:	e13ffc17 	ldw	r4,-16(fp)
 82264ec:	823e4040 	call	823e404 <arprcv>
         UNLOCK_NET_RESOURCE(NET_RESID);
 82264f0:	0009883a 	mov	r4,zero
 82264f4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         break;
 82264f8:	00001f06 	br	8226578 <pktdemux+0x378>
         UNLOCK_NET_RESOURCE(NET_RESID);
         break;
#endif
      default:
#ifdef NPDEBUG
         if (NDEBUG & UPCTRACE)
 82264fc:	d0a08317 	ldw	r2,-32244(gp)
 8226500:	1081000c 	andi	r2,r2,1024
 8226504:	10001026 	beq	r2,zero,8226548 <pktdemux+0x348>
            dprintf("pktdemux: bad pkt type 0x%04x\n", ntohs(pkt->type));
 8226508:	e0bffc17 	ldw	r2,-16(fp)
 822650c:	1080080b 	ldhu	r2,32(r2)
 8226510:	10bfffcc 	andi	r2,r2,65535
 8226514:	1004d23a 	srli	r2,r2,8
 8226518:	10bfffcc 	andi	r2,r2,65535
 822651c:	10c03fcc 	andi	r3,r2,255
 8226520:	e0bffc17 	ldw	r2,-16(fp)
 8226524:	1080080b 	ldhu	r2,32(r2)
 8226528:	10bfffcc 	andi	r2,r2,65535
 822652c:	1004923a 	slli	r2,r2,8
 8226530:	10bfffcc 	andi	r2,r2,65535
 8226534:	1884b03a 	or	r2,r3,r2
 8226538:	100b883a 	mov	r5,r2
 822653c:	01020974 	movhi	r4,2085
 8226540:	213fe704 	addi	r4,r4,-100
 8226544:	820331c0 	call	820331c <printf>
#endif   /* NPDEBUG */
         ifc->n_mib->ifInUnknownProtos++;
 8226548:	e0bffd17 	ldw	r2,-12(fp)
 822654c:	10802717 	ldw	r2,156(r2)
 8226550:	10c00e17 	ldw	r3,56(r2)
 8226554:	18c00044 	addi	r3,r3,1
 8226558:	10c00e15 	stw	r3,56(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822655c:	01000084 	movi	r4,2
 8226560:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free(pkt);           /* return to free buffer */
 8226564:	e13ffc17 	ldw	r4,-16(fp)
 8226568:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822656c:	01000084 	movi	r4,2
 8226570:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         break;
 8226574:	0001883a 	nop
      }
      continue;
 8226578:	0001883a 	nop
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */

   while (rcvdq.q_len)
 822657c:	008209b4 	movhi	r2,2086
 8226580:	10b75f04 	addi	r2,r2,-8836
 8226584:	10800217 	ldw	r2,8(r2)
 8226588:	103f231e 	bne	r2,zero,8226218 <pktdemux+0x18>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         break;
      }
      continue;
   }
}
 822658c:	0001883a 	nop
 8226590:	e037883a 	mov	sp,fp
 8226594:	dfc00117 	ldw	ra,4(sp)
 8226598:	df000017 	ldw	fp,0(sp)
 822659c:	dec00204 	addi	sp,sp,8
 82265a0:	f800283a 	ret

082265a4 <c_older>:
 * RETURNS: the older of the two passed tick counts
 */

u_long
c_older(u_long ct1, u_long ct2)
{
 82265a4:	defffd04 	addi	sp,sp,-12
 82265a8:	df000215 	stw	fp,8(sp)
 82265ac:	df000204 	addi	fp,sp,8
 82265b0:	e13ffe15 	stw	r4,-8(fp)
 82265b4:	e17fff15 	stw	r5,-4(fp)

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 82265b8:	d0a0a817 	ldw	r2,-32096(gp)
 82265bc:	10000c0e 	bge	r2,zero,82265f0 <c_older+0x4c>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 82265c0:	d0e0a817 	ldw	r3,-32096(gp)

u_long
c_older(u_long ct1, u_long ct2)
{

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 82265c4:	e0bffe17 	ldw	r2,-8(fp)
 82265c8:	18800336 	bltu	r3,r2,82265d8 <c_older+0x34>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 82265cc:	d0e0a817 	ldw	r3,-32096(gp)
 82265d0:	e0bfff17 	ldw	r2,-4(fp)
 82265d4:	1880062e 	bgeu	r3,r2,82265f0 <c_older+0x4c>
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
 82265d8:	d0a0a817 	ldw	r2,-32096(gp)
u_long
c_older(u_long ct1, u_long ct2)
{

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 82265dc:	e0fffe17 	ldw	r3,-8(fp)
 82265e0:	18800a36 	bltu	r3,r2,822660c <c_older+0x68>
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
 82265e4:	d0a0a817 	ldw	r2,-32096(gp)
 82265e8:	e0ffff17 	ldw	r3,-4(fp)
 82265ec:	18800736 	bltu	r3,r2,822660c <c_older+0x68>
   {
      if (ct1 < ct2)
 82265f0:	e0fffe17 	ldw	r3,-8(fp)
 82265f4:	e0bfff17 	ldw	r2,-4(fp)
 82265f8:	1880022e 	bgeu	r3,r2,8226604 <c_older+0x60>
         return(ct1);      /* then smaller is oldest */
 82265fc:	e0bffe17 	ldw	r2,-8(fp)
 8226600:	00000806 	br	8226624 <c_older+0x80>
      else 
         return(ct2);
 8226604:	e0bfff17 	ldw	r2,-4(fp)
 8226608:	00000606 	br	8226624 <c_older+0x80>
   }

   /* else one is less than cticks, and one is greater.
   the larger value is then the oldest */
   if (ct1 >= ct2)
 822660c:	e0fffe17 	ldw	r3,-8(fp)
 8226610:	e0bfff17 	ldw	r2,-4(fp)
 8226614:	18800236 	bltu	r3,r2,8226620 <c_older+0x7c>
      return(ct1);
 8226618:	e0bffe17 	ldw	r2,-8(fp)
 822661c:	00000106 	br	8226624 <c_older+0x80>
   else
      return(ct2);
 8226620:	e0bfff17 	ldw	r2,-4(fp)
}
 8226624:	e037883a 	mov	sp,fp
 8226628:	df000017 	ldw	fp,0(sp)
 822662c:	dec00104 	addi	sp,sp,4
 8226630:	f800283a 	ret

08226634 <ip2mac>:
 */

int
ip2mac(PACKET pkt,         /* the packet itself, all set but for dest MAC address */
   ip_addr  dest_ip)    /* the IP host or gateway to get MAC addr for */
{
 8226634:	defffb04 	addi	sp,sp,-20
 8226638:	dfc00415 	stw	ra,16(sp)
 822663c:	df000315 	stw	fp,12(sp)
 8226640:	df000304 	addi	fp,sp,12
 8226644:	e13ffe15 	stw	r4,-8(fp)
 8226648:	e17fff15 	stw	r5,-4(fp)
   IFMIB ifmib = pkt->net->n_mib;   /* mib info for this interface */
 822664c:	e0bffe17 	ldw	r2,-8(fp)
 8226650:	10800617 	ldw	r2,24(r2)
 8226654:	10802717 	ldw	r2,156(r2)
 8226658:	e0bffd15 	stw	r2,-12(fp)

   /* Always punt if iface ifAdminStatus is DOWN. ifOperStatus may 
    * be down too, but our packet may be the event required to bring 
    * it up - so don't worry about ifOperStatus here.
    */
   if(ifmib->ifAdminStatus == NI_DOWN)
 822665c:	e0bffd17 	ldw	r2,-12(fp)
 8226660:	10800617 	ldw	r2,24(r2)
 8226664:	10800098 	cmpnei	r2,r2,2
 8226668:	1000081e 	bne	r2,zero,822668c <ip2mac+0x58>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822666c:	01000084 	movi	r4,2
 8226670:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 8226674:	e13ffe17 	ldw	r4,-8(fp)
 8226678:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822667c:	01000084 	movi	r4,2
 8226680:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return(ENP_NO_ROUTE);
 8226684:	00bff7c4 	movi	r2,-33
 8226688:	00004806 	br	82267ac <ip2mac+0x178>
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 822668c:	e0bffe17 	ldw	r2,-8(fp)
 8226690:	10800617 	ldw	r2,24(r2)
 8226694:	10800817 	ldw	r2,32(r2)
 8226698:	10000826 	beq	r2,zero,82266bc <ip2mac+0x88>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
 822669c:	e0bffd17 	ldw	r2,-12(fp)
 82266a0:	10800217 	ldw	r2,8(r2)
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 82266a4:	108005e0 	cmpeqi	r2,r2,23
 82266a8:	1000041e 	bne	r2,zero,82266bc <ip2mac+0x88>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
       (ifmib->ifType == SLIP))
 82266ac:	e0bffd17 	ldw	r2,-12(fp)
 82266b0:	10800217 	ldw	r2,8(r2)
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
 82266b4:	10800718 	cmpnei	r2,r2,28
 82266b8:	1000291e 	bne	r2,zero,8226760 <ip2mac+0x12c>
       (ifmib->ifType == SLIP))
   {
      ifmib->ifOutUcastPkts++;   /* maintain MIB counters */
 82266bc:	e0bffd17 	ldw	r2,-12(fp)
 82266c0:	10801017 	ldw	r2,64(r2)
 82266c4:	10c00044 	addi	r3,r2,1
 82266c8:	e0bffd17 	ldw	r2,-12(fp)
 82266cc:	10c01015 	stw	r3,64(r2)
      ifmib->ifOutOctets += pkt->nb_plen;
 82266d0:	e0bffd17 	ldw	r2,-12(fp)
 82266d4:	10c00f17 	ldw	r3,60(r2)
 82266d8:	e0bffe17 	ldw	r2,-8(fp)
 82266dc:	10800417 	ldw	r2,16(r2)
 82266e0:	1887883a 	add	r3,r3,r2
 82266e4:	e0bffd17 	ldw	r2,-12(fp)
 82266e8:	10c00f15 	stw	r3,60(r2)

      /* send packet on media */
      if (pkt->net->pkt_send) /* favor using packet send */
 82266ec:	e0bffe17 	ldw	r2,-8(fp)
 82266f0:	10800617 	ldw	r2,24(r2)
 82266f4:	10800417 	ldw	r2,16(r2)
 82266f8:	10000626 	beq	r2,zero,8226714 <ip2mac+0xe0>
         pkt->net->pkt_send(pkt);   /* pkt will be freed by MAC code */
 82266fc:	e0bffe17 	ldw	r2,-8(fp)
 8226700:	10800617 	ldw	r2,24(r2)
 8226704:	10800417 	ldw	r2,16(r2)
 8226708:	e13ffe17 	ldw	r4,-8(fp)
 822670c:	103ee83a 	callr	r2
 8226710:	00001106 	br	8226758 <ip2mac+0x124>
      else  /* no packet send; try raw send */
      {
         pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 8226714:	e0bffe17 	ldw	r2,-8(fp)
 8226718:	10800617 	ldw	r2,24(r2)
 822671c:	10800317 	ldw	r2,12(r2)
 8226720:	e0fffe17 	ldw	r3,-8(fp)
 8226724:	19000617 	ldw	r4,24(r3)
 8226728:	e0fffe17 	ldw	r3,-8(fp)
 822672c:	19400317 	ldw	r5,12(r3)
 8226730:	e0fffe17 	ldw	r3,-8(fp)
 8226734:	18c00417 	ldw	r3,16(r3)
 8226738:	180d883a 	mov	r6,r3
 822673c:	103ee83a 	callr	r2
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8226740:	01000084 	movi	r4,2
 8226744:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 8226748:	e13ffe17 	ldw	r4,-8(fp)
 822674c:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226750:	01000084 	movi	r4,2
 8226754:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      }
      return(SUCCESS);
 8226758:	0005883a 	mov	r2,zero
 822675c:	00001306 	br	82267ac <ip2mac+0x178>
   }

   /* don't allow unicast sends if NIC iface has no IP address. This
    * is to prevent DHCP clients from sending prior to assignment.
    */
   if (pkt->net->n_ipaddr == 0L)
 8226760:	e0bffe17 	ldw	r2,-8(fp)
 8226764:	10800617 	ldw	r2,24(r2)
 8226768:	10800a17 	ldw	r2,40(r2)
 822676c:	10000c1e 	bne	r2,zero,82267a0 <ip2mac+0x16c>
   {
      if (pkt->fhost != 0xFFFFFFFF) /* check for broadcast packet */
 8226770:	e0bffe17 	ldw	r2,-8(fp)
 8226774:	10800717 	ldw	r2,28(r2)
 8226778:	10bfffe0 	cmpeqi	r2,r2,-1
 822677c:	1000081e 	bne	r2,zero,82267a0 <ip2mac+0x16c>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8226780:	01000084 	movi	r4,2
 8226784:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 8226788:	e13ffe17 	ldw	r4,-8(fp)
 822678c:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226790:	01000084 	movi	r4,2
 8226794:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         return ENP_SENDERR;
 8226798:	00bff884 	movi	r2,-30
 822679c:	00000306 	br	82267ac <ip2mac+0x178>
      }
   }

#ifdef INCLUDE_ARP   /* must be ethernet or token ring */
   return(send_via_arp(pkt, dest_ip));
 82267a0:	e17fff17 	ldw	r5,-4(fp)
 82267a4:	e13ffe17 	ldw	r4,-8(fp)
 82267a8:	823e6680 	call	823e668 <send_via_arp>
#else
   dtrap();    /* Bad option combination? */
   return ENP_NO_IFACE; /* sent to unknown interface type */
#endif   /* INCLUDE_ARP */
}
 82267ac:	e037883a 	mov	sp,fp
 82267b0:	dfc00117 	ldw	ra,4(sp)
 82267b4:	df000017 	ldw	fp,0(sp)
 82267b8:	dec00204 	addi	sp,sp,8
 82267bc:	f800283a 	ret

082267c0 <ip_startup>:
 * RETURNS: returns NULL if OK, or text of an error message 
 */

char *   
ip_startup()
{
 82267c0:	defffc04 	addi	sp,sp,-16
 82267c4:	dfc00315 	stw	ra,12(sp)
 82267c8:	df000215 	stw	fp,8(sp)
 82267cc:	df000204 	addi	fp,sp,8
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 82267d0:	e03ffe15 	stw	zero,-8(fp)
 82267d4:	00002a06 	br	8226880 <ip_startup+0xc0>
   {
      nets[i] = &netstatic[i];   /* set up array of pointers */
 82267d8:	e0bffe17 	ldw	r2,-8(fp)
 82267dc:	10c03024 	muli	r3,r2,192
 82267e0:	008209b4 	movhi	r2,2086
 82267e4:	10b76404 	addi	r2,r2,-8816
 82267e8:	1889883a 	add	r4,r3,r2
 82267ec:	008209b4 	movhi	r2,2086
 82267f0:	10b82404 	addi	r2,r2,-8048
 82267f4:	e0fffe17 	ldw	r3,-8(fp)
 82267f8:	18c7883a 	add	r3,r3,r3
 82267fc:	18c7883a 	add	r3,r3,r3
 8226800:	10c5883a 	add	r2,r2,r3
 8226804:	11000015 	stw	r4,0(r2)
      nets[i]->n_mib = &nets[i]->mib;   /* set mib pointer */
 8226808:	008209b4 	movhi	r2,2086
 822680c:	10b82404 	addi	r2,r2,-8048
 8226810:	e0fffe17 	ldw	r3,-8(fp)
 8226814:	18c7883a 	add	r3,r3,r3
 8226818:	18c7883a 	add	r3,r3,r3
 822681c:	10c5883a 	add	r2,r2,r3
 8226820:	11000017 	ldw	r4,0(r2)
 8226824:	008209b4 	movhi	r2,2086
 8226828:	10b82404 	addi	r2,r2,-8048
 822682c:	e0fffe17 	ldw	r3,-8(fp)
 8226830:	18c7883a 	add	r3,r3,r3
 8226834:	18c7883a 	add	r3,r3,r3
 8226838:	10c5883a 	add	r2,r2,r3
 822683c:	10800017 	ldw	r2,0(r2)
 8226840:	10801204 	addi	r2,r2,72
 8226844:	20802715 	stw	r2,156(r4)

      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
 8226848:	008209b4 	movhi	r2,2086
 822684c:	10b82404 	addi	r2,r2,-8048
 8226850:	e0fffe17 	ldw	r3,-8(fp)
 8226854:	18c7883a 	add	r3,r3,r3
 8226858:	18c7883a 	add	r3,r3,r3
 822685c:	10c5883a 	add	r2,r2,r3
 8226860:	10800017 	ldw	r2,0(r2)
 8226864:	100b883a 	mov	r5,r2
 8226868:	010209b4 	movhi	r4,2086
 822686c:	213a6504 	addi	r4,r4,-5740
 8226870:	822cdfc0 	call	822cdfc <putq>
{
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 8226874:	e0bffe17 	ldw	r2,-8(fp)
 8226878:	10800044 	addi	r2,r2,1
 822687c:	e0bffe15 	stw	r2,-8(fp)
 8226880:	e0bffe17 	ldw	r2,-8(fp)
 8226884:	10800110 	cmplti	r2,r2,4
 8226888:	103fd31e 	bne	r2,zero,82267d8 <ip_startup+0x18>
      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
   }

   /* call port routine to locate and init network interfaces. */
   ifNumber = (unsigned)prep_ifaces(ifNumber);
 822688c:	d0a08417 	ldw	r2,-32240(gp)
 8226890:	1009883a 	mov	r4,r2
 8226894:	8243a5c0 	call	8243a5c <prep_ifaces>
 8226898:	d0a08415 	stw	r2,-32240(gp)

   if (ifNumber < 1)    /* no static interfaces? */
 822689c:	d0a08417 	ldw	r2,-32240(gp)
 82268a0:	1000031e 	bne	r2,zero,82268b0 <ip_startup+0xf0>
#ifdef DYNAMIC_IFACES
      /* print a debug message and hope user knows what he's doing */
      dprintf("unable to find any working interfaces");
#else /* static ifaces only */
      /* no static and no dynamic interfaces is probably a bug... */
      return("unable to find any working interfaces");
 82268a4:	00820974 	movhi	r2,2085
 82268a8:	10bff804 	addi	r2,r2,-32
 82268ac:	00006806 	br	8226a50 <ip_startup+0x290>
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 82268b0:	d0a08417 	ldw	r2,-32240(gp)
 82268b4:	e0bffe15 	stw	r2,-8(fp)
 82268b8:	00001506 	br	8226910 <ip_startup+0x150>
   {
      qdel(&netlist, (qp)nets[i]);  /* remove from queue */
 82268bc:	008209b4 	movhi	r2,2086
 82268c0:	10b82404 	addi	r2,r2,-8048
 82268c4:	e0fffe17 	ldw	r3,-8(fp)
 82268c8:	18c7883a 	add	r3,r3,r3
 82268cc:	18c7883a 	add	r3,r3,r3
 82268d0:	10c5883a 	add	r2,r2,r3
 82268d4:	10800017 	ldw	r2,0(r2)
 82268d8:	100b883a 	mov	r5,r2
 82268dc:	010209b4 	movhi	r4,2086
 82268e0:	213a6504 	addi	r4,r4,-5740
 82268e4:	822ceac0 	call	822ceac <qdel>
      nets[i] = NULL;               /* remove from array */
 82268e8:	008209b4 	movhi	r2,2086
 82268ec:	10b82404 	addi	r2,r2,-8048
 82268f0:	e0fffe17 	ldw	r3,-8(fp)
 82268f4:	18c7883a 	add	r3,r3,r3
 82268f8:	18c7883a 	add	r3,r3,r3
 82268fc:	10c5883a 	add	r2,r2,r3
 8226900:	10000015 	stw	zero,0(r2)
      return("unable to find any working interfaces");
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 8226904:	e0bffe17 	ldw	r2,-8(fp)
 8226908:	10800044 	addi	r2,r2,1
 822690c:	e0bffe15 	stw	r2,-8(fp)
 8226910:	e0bffe17 	ldw	r2,-8(fp)
 8226914:	10800110 	cmplti	r2,r2,4
 8226918:	103fe81e 	bne	r2,zero,82268bc <ip_startup+0xfc>
   /* The sequence of events when initing the net & interface systems 
    * is very important. Be very carefull about altering the order of 
    * the following statements. 
    */
   /* once these are done, we should call ip_exit before quiting IP */
   clock_init();           /* start clock system */
 822691c:	822d5380 	call	822d538 <clock_init>
   exit_hook(clock_c);
 8226920:	010208f4 	movhi	r4,2083
 8226924:	21355c04 	addi	r4,r4,-10896
 8226928:	8226a640 	call	8226a64 <exit_hook>

   e = Netinit();    /* start net interface(s) */
 822692c:	82259dc0 	call	82259dc <Netinit>
 8226930:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226934:	e0bfff17 	ldw	r2,-4(fp)
 8226938:	10000326 	beq	r2,zero,8226948 <ip_startup+0x188>
   {
      return("unable to initialize net");
 822693c:	00820974 	movhi	r2,2085
 8226940:	10800204 	addi	r2,r2,8
 8226944:	00004206 	br	8226a50 <ip_startup+0x290>
   }

#ifdef INCLUDE_ARP
   e = etainit();          /* startup ARP layer */
 8226948:	823d7c40 	call	823d7c4 <etainit>
 822694c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226950:	e0bfff17 	ldw	r2,-4(fp)
 8226954:	10000426 	beq	r2,zero,8226968 <ip_startup+0x1a8>
   {
      ip_exit();
 8226958:	8226ad40 	call	8226ad4 <ip_exit>
      return("unable to initialize arp");
 822695c:	00820974 	movhi	r2,2085
 8226960:	10800904 	addi	r2,r2,36
 8226964:	00003a06 	br	8226a50 <ip_startup+0x290>
   }
#endif

#ifdef IP_V4
   e = ip_init();       /* start up IP layer */
 8226968:	823ee140 	call	823ee14 <ip_init>
 822696c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226970:	e0bfff17 	ldw	r2,-4(fp)
 8226974:	10000426 	beq	r2,zero,8226988 <ip_startup+0x1c8>
   {
      ip_exit();
 8226978:	8226ad40 	call	8226ad4 <ip_exit>
      return("unable to initialize IP");
 822697c:	00820974 	movhi	r2,2085
 8226980:	10801004 	addi	r2,r2,64
 8226984:	00003206 	br	8226a50 <ip_startup+0x290>

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Join the All hosts group on every interface that IP multicast is
    * supported
    */
   e = igmp_init();         /* Initialize igmp */
 8226988:	8226c280 	call	8226c28 <igmp_init>
 822698c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226990:	e0bfff17 	ldw	r2,-4(fp)
 8226994:	10000326 	beq	r2,zero,82269a4 <ip_startup+0x1e4>
   {
      ip_exit();
 8226998:	8226ad40 	call	8226ad4 <ip_exit>
      return(ipmcfail_str);
 822699c:	d0a03017 	ldw	r2,-32576(gp)
 82269a0:	00002b06 	br	8226a50 <ip_startup+0x290>
   }

   for (i = 0; i < (int)ifNumber; i++)
 82269a4:	e03ffe15 	stw	zero,-8(fp)
 82269a8:	00001b06 	br	8226a18 <ip_startup+0x258>
   {
      if (nets[i]->n_mcastlist != NULL)
 82269ac:	008209b4 	movhi	r2,2086
 82269b0:	10b82404 	addi	r2,r2,-8048
 82269b4:	e0fffe17 	ldw	r3,-8(fp)
 82269b8:	18c7883a 	add	r3,r3,r3
 82269bc:	18c7883a 	add	r3,r3,r3
 82269c0:	10c5883a 	add	r2,r2,r3
 82269c4:	10800017 	ldw	r2,0(r2)
 82269c8:	10802b17 	ldw	r2,172(r2)
 82269cc:	10000f26 	beq	r2,zero,8226a0c <ip_startup+0x24c>
         if ((in_addmulti(&igmp_all_hosts_group, nets[i], 4) == NULL))
 82269d0:	008209b4 	movhi	r2,2086
 82269d4:	10b82404 	addi	r2,r2,-8048
 82269d8:	e0fffe17 	ldw	r3,-8(fp)
 82269dc:	18c7883a 	add	r3,r3,r3
 82269e0:	18c7883a 	add	r3,r3,r3
 82269e4:	10c5883a 	add	r2,r2,r3
 82269e8:	10800017 	ldw	r2,0(r2)
 82269ec:	01800104 	movi	r6,4
 82269f0:	100b883a 	mov	r5,r2
 82269f4:	d1208804 	addi	r4,gp,-32224
 82269f8:	82437a00 	call	82437a0 <in_addmulti>
 82269fc:	1000031e 	bne	r2,zero,8226a0c <ip_startup+0x24c>
      {
         ip_exit();
 8226a00:	8226ad40 	call	8226ad4 <ip_exit>
         return(ipmcfail_str);
 8226a04:	d0a03017 	ldw	r2,-32576(gp)
 8226a08:	00001106 	br	8226a50 <ip_startup+0x290>
   {
      ip_exit();
      return(ipmcfail_str);
   }

   for (i = 0; i < (int)ifNumber; i++)
 8226a0c:	e0bffe17 	ldw	r2,-8(fp)
 8226a10:	10800044 	addi	r2,r2,1
 8226a14:	e0bffe15 	stw	r2,-8(fp)
 8226a18:	d0a08417 	ldw	r2,-32240(gp)
 8226a1c:	1007883a 	mov	r3,r2
 8226a20:	e0bffe17 	ldw	r2,-8(fp)
 8226a24:	10ffe116 	blt	r2,r3,82269ac <ip_startup+0x1ec>
      }
   }
#endif /* IP_MULTICAST and (IGMPv1 or IGMPv2) */   

#ifdef INCLUDE_TCP
   e = tcpinit();
 8226a28:	823ad500 	call	823ad50 <tcpinit>
 8226a2c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 8226a30:	e0bfff17 	ldw	r2,-4(fp)
 8226a34:	10000426 	beq	r2,zero,8226a48 <ip_startup+0x288>
   {
      ip_exit();
 8226a38:	8226ad40 	call	8226ad4 <ip_exit>
      return("unable to initialize TCP");
 8226a3c:	00820974 	movhi	r2,2085
 8226a40:	10801604 	addi	r2,r2,88
 8226a44:	00000206 	br	8226a50 <ip_startup+0x290>
   /* setup event map for (UDP and TCP) socket library's events (such as 
    * those used by tcp_sleep () and tcp_wakeup ()).  These events either 
    * map into operating system primitives such as events or semaphores, 
    * or into task suspend and task resume mechanisms.
    */
   evtmap_setup ();
 8226a48:	8243b040 	call	8243b04 <evtmap_setup>
      return("unable to initialize IP Filter table");
   else
      exit_hook(ipf_cleanup);
#endif

   return(NULL);     /* we got through with no errors */
 8226a4c:	0005883a 	mov	r2,zero
}
 8226a50:	e037883a 	mov	sp,fp
 8226a54:	dfc00117 	ldw	ra,4(sp)
 8226a58:	df000017 	ldw	fp,0(sp)
 8226a5c:	dec00204 	addi	sp,sp,8
 8226a60:	f800283a 	ret

08226a64 <exit_hook>:
 * RETURNS: 
 */

void
exit_hook(void (*func)(void))
{
 8226a64:	defffd04 	addi	sp,sp,-12
 8226a68:	dfc00215 	stw	ra,8(sp)
 8226a6c:	df000115 	stw	fp,4(sp)
 8226a70:	df000104 	addi	fp,sp,4
 8226a74:	e13fff15 	stw	r4,-4(fp)
   if (nclosers >= (NUMCLOSERS-1))
 8226a78:	d0a08517 	ldw	r2,-32236(gp)
 8226a7c:	10800390 	cmplti	r2,r2,14
 8226a80:	1000031e 	bne	r2,zero,8226a90 <exit_hook+0x2c>
      panic("exit_hook");
 8226a84:	01020974 	movhi	r4,2085
 8226a88:	21001d04 	addi	r4,r4,116
 8226a8c:	8228aec0 	call	8228aec <panic>

   closers[++nclosers] = func;
 8226a90:	d0a08517 	ldw	r2,-32236(gp)
 8226a94:	10800044 	addi	r2,r2,1
 8226a98:	d0a08515 	stw	r2,-32236(gp)
 8226a9c:	d0e08517 	ldw	r3,-32236(gp)
 8226aa0:	00820974 	movhi	r2,2085
 8226aa4:	10920304 	addi	r2,r2,18444
 8226aa8:	18c7883a 	add	r3,r3,r3
 8226aac:	18c7883a 	add	r3,r3,r3
 8226ab0:	10c5883a 	add	r2,r2,r3
 8226ab4:	e0ffff17 	ldw	r3,-4(fp)
 8226ab8:	10c00015 	stw	r3,0(r2)
}
 8226abc:	0001883a 	nop
 8226ac0:	e037883a 	mov	sp,fp
 8226ac4:	dfc00117 	ldw	ra,4(sp)
 8226ac8:	df000017 	ldw	fp,0(sp)
 8226acc:	dec00204 	addi	sp,sp,8
 8226ad0:	f800283a 	ret

08226ad4 <ip_exit>:
 * RETURNS: void
 */

void
ip_exit()
{
 8226ad4:	defffd04 	addi	sp,sp,-12
 8226ad8:	dfc00215 	stw	ra,8(sp)
 8226adc:	df000115 	stw	fp,4(sp)
 8226ae0:	df000104 	addi	fp,sp,4
   int   n;

   for (n=nclosers; n; n--)
 8226ae4:	d0a08517 	ldw	r2,-32236(gp)
 8226ae8:	e0bfff15 	stw	r2,-4(fp)
 8226aec:	00002506 	br	8226b84 <ip_exit+0xb0>
   {
#ifdef NPDEBUG
      dprintf("ip_exit: calling func %p\n", closers[n]);
 8226af0:	00820974 	movhi	r2,2085
 8226af4:	10920304 	addi	r2,r2,18444
 8226af8:	e0ffff17 	ldw	r3,-4(fp)
 8226afc:	18c7883a 	add	r3,r3,r3
 8226b00:	18c7883a 	add	r3,r3,r3
 8226b04:	10c5883a 	add	r2,r2,r3
 8226b08:	10800017 	ldw	r2,0(r2)
 8226b0c:	100b883a 	mov	r5,r2
 8226b10:	01020974 	movhi	r4,2085
 8226b14:	21002004 	addi	r4,r4,128
 8226b18:	820331c0 	call	820331c <printf>
#endif
      if(closers[n])
 8226b1c:	00820974 	movhi	r2,2085
 8226b20:	10920304 	addi	r2,r2,18444
 8226b24:	e0ffff17 	ldw	r3,-4(fp)
 8226b28:	18c7883a 	add	r3,r3,r3
 8226b2c:	18c7883a 	add	r3,r3,r3
 8226b30:	10c5883a 	add	r2,r2,r3
 8226b34:	10800017 	ldw	r2,0(r2)
 8226b38:	10000f26 	beq	r2,zero,8226b78 <ip_exit+0xa4>
      {
         (*closers[n])();
 8226b3c:	00820974 	movhi	r2,2085
 8226b40:	10920304 	addi	r2,r2,18444
 8226b44:	e0ffff17 	ldw	r3,-4(fp)
 8226b48:	18c7883a 	add	r3,r3,r3
 8226b4c:	18c7883a 	add	r3,r3,r3
 8226b50:	10c5883a 	add	r2,r2,r3
 8226b54:	10800017 	ldw	r2,0(r2)
 8226b58:	103ee83a 	callr	r2
         closers[n] = NULL;
 8226b5c:	00820974 	movhi	r2,2085
 8226b60:	10920304 	addi	r2,r2,18444
 8226b64:	e0ffff17 	ldw	r3,-4(fp)
 8226b68:	18c7883a 	add	r3,r3,r3
 8226b6c:	18c7883a 	add	r3,r3,r3
 8226b70:	10c5883a 	add	r2,r2,r3
 8226b74:	10000015 	stw	zero,0(r2)
void
ip_exit()
{
   int   n;

   for (n=nclosers; n; n--)
 8226b78:	e0bfff17 	ldw	r2,-4(fp)
 8226b7c:	10bfffc4 	addi	r2,r2,-1
 8226b80:	e0bfff15 	stw	r2,-4(fp)
 8226b84:	e0bfff17 	ldw	r2,-4(fp)
 8226b88:	103fd91e 	bne	r2,zero,8226af0 <ip_exit+0x1c>
      {
         (*closers[n])();
         closers[n] = NULL;
      }
   }
}
 8226b8c:	0001883a 	nop
 8226b90:	e037883a 	mov	sp,fp
 8226b94:	dfc00117 	ldw	ra,4(sp)
 8226b98:	df000017 	ldw	fp,0(sp)
 8226b9c:	dec00204 	addi	sp,sp,8
 8226ba0:	f800283a 	ret

08226ba4 <if_netnumber>:
 * RETURNS: net index for passed net pointer
 */

int
if_netnumber(NET nptr)
{
 8226ba4:	defffb04 	addi	sp,sp,-20
 8226ba8:	dfc00415 	stw	ra,16(sp)
 8226bac:	df000315 	stw	fp,12(sp)
 8226bb0:	df000304 	addi	fp,sp,12
 8226bb4:	e13fff15 	stw	r4,-4(fp)
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 8226bb8:	008209b4 	movhi	r2,2086
 8226bbc:	10ba6504 	addi	r2,r2,-5740
 8226bc0:	10800017 	ldw	r2,0(r2)
 8226bc4:	e0bffe15 	stw	r2,-8(fp)
 8226bc8:	e03ffd15 	stw	zero,-12(fp)
 8226bcc:	00000b06 	br	8226bfc <if_netnumber+0x58>
   {
      if(ifp == nptr)
 8226bd0:	e0fffe17 	ldw	r3,-8(fp)
 8226bd4:	e0bfff17 	ldw	r2,-4(fp)
 8226bd8:	1880021e 	bne	r3,r2,8226be4 <if_netnumber+0x40>
        return (int)i;
 8226bdc:	e0bffd17 	ldw	r2,-12(fp)
 8226be0:	00000c06 	br	8226c14 <if_netnumber+0x70>
if_netnumber(NET nptr)
{
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 8226be4:	e0bffe17 	ldw	r2,-8(fp)
 8226be8:	10800017 	ldw	r2,0(r2)
 8226bec:	e0bffe15 	stw	r2,-8(fp)
 8226bf0:	e0bffd17 	ldw	r2,-12(fp)
 8226bf4:	10800044 	addi	r2,r2,1
 8226bf8:	e0bffd15 	stw	r2,-12(fp)
 8226bfc:	e0bffe17 	ldw	r2,-8(fp)
 8226c00:	103ff31e 	bne	r2,zero,8226bd0 <if_netnumber+0x2c>
   {
      if(ifp == nptr)
        return (int)i;
   }

   panic("bad net ptr");
 8226c04:	01020974 	movhi	r4,2085
 8226c08:	21002704 	addi	r4,r4,156
 8226c0c:	8228aec0 	call	8228aec <panic>
   return 0;
 8226c10:	0005883a 	mov	r2,zero
}
 8226c14:	e037883a 	mov	sp,fp
 8226c18:	dfc00117 	ldw	ra,4(sp)
 8226c1c:	df000017 	ldw	fp,0(sp)
 8226c20:	dec00204 	addi	sp,sp,8
 8226c24:	f800283a 	ret

08226c28 <igmp_init>:
 *
 * OUTPUT: None.
 */

int igmp_init(void)
{
 8226c28:	defffe04 	addi	sp,sp,-8
 8226c2c:	df000115 	stw	fp,4(sp)
 8226c30:	df000104 	addi	fp,sp,4
   NET ifp;

   /*
    * To avoid byte-swapping the same value over and over again.
    */
   igmp_all_hosts_group = htonl(INADDR_ALLHOSTS_GROUP);
 8226c34:	00804034 	movhi	r2,256
 8226c38:	10803804 	addi	r2,r2,224
 8226c3c:	d0a08815 	stw	r2,-32224(gp)
   igmp_all_rtrs_group = htonl(INADDR_ALLRTRS_GROUP);
 8226c40:	00808034 	movhi	r2,512
 8226c44:	10803804 	addi	r2,r2,224
 8226c48:	d0a08915 	stw	r2,-32220(gp)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 8226c4c:	008209b4 	movhi	r2,2086
 8226c50:	10ba6504 	addi	r2,r2,-5740
 8226c54:	10800017 	ldw	r2,0(r2)
 8226c58:	e0bfff15 	stw	r2,-4(fp)
 8226c5c:	00001006 	br	8226ca0 <igmp_init+0x78>
   {
      if (ifp->igmp_oper_mode == IGMP_MODE_V1)
 8226c60:	e0bfff17 	ldw	r2,-4(fp)
 8226c64:	10802f03 	ldbu	r2,188(r2)
 8226c68:	10803fcc 	andi	r2,r2,255
 8226c6c:	10800058 	cmpnei	r2,r2,1
 8226c70:	1000041e 	bne	r2,zero,8226c84 <igmp_init+0x5c>
      {
         ifp->igmpv1_rtr_present = 1;
 8226c74:	e0bfff17 	ldw	r2,-4(fp)
 8226c78:	00c00044 	movi	r3,1
 8226c7c:	10c02d05 	stb	r3,180(r2)
 8226c80:	00000406 	br	8226c94 <igmp_init+0x6c>
      }
      else
      {
         ifp->igmpv1_rtr_present = 0;
 8226c84:	e0bfff17 	ldw	r2,-4(fp)
 8226c88:	10002d05 	stb	zero,180(r2)
         /* not really required, only referred to if IGMPv1 router is 
          * "present" */
         ifp->igmpv1_query_rcvd_time = 0;
 8226c8c:	e0bfff17 	ldw	r2,-4(fp)
 8226c90:	10002e15 	stw	zero,184(r2)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 8226c94:	e0bfff17 	ldw	r2,-4(fp)
 8226c98:	10800017 	ldw	r2,0(r2)
 8226c9c:	e0bfff15 	stw	r2,-4(fp)
 8226ca0:	e0bfff17 	ldw	r2,-4(fp)
 8226ca4:	103fee1e 	bne	r2,zero,8226c60 <igmp_init+0x38>
   }

   /*
    * Call igmp_fasttimo PR_FASTHZ (5) times per second
    */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 8226ca8:	d0a0a817 	ldw	r2,-32096(gp)
 8226cac:	10800504 	addi	r2,r2,20
 8226cb0:	d0a08715 	stw	r2,-32228(gp)

   /* there are no timers running initially */
   igmp_timers_are_running = 0;
 8226cb4:	d0208615 	stw	zero,-32232(gp)

   return IGMP_OK;
 8226cb8:	0005883a 	mov	r2,zero
}
 8226cbc:	e037883a 	mov	sp,fp
 8226cc0:	df000017 	ldw	fp,0(sp)
 8226cc4:	dec00104 	addi	sp,sp,4
 8226cc8:	f800283a 	ret

08226ccc <igmp_input>:
 * returned if the operating mode is not correctly configured
 * to a valid IGMP operating mode.
 */

int igmp_input (PACKET p)
{
 8226ccc:	defffb04 	addi	sp,sp,-20
 8226cd0:	dfc00415 	stw	ra,16(sp)
 8226cd4:	df000315 	stw	fp,12(sp)
 8226cd8:	df000304 	addi	fp,sp,12
 8226cdc:	e13fff15 	stw	r4,-4(fp)
   u_char mode;
   int rc;
     
   ++igmpstats.igmp_total_rcvd;
 8226ce0:	008209b4 	movhi	r2,2086
 8226ce4:	10b82804 	addi	r2,r2,-8032
 8226ce8:	10800017 	ldw	r2,0(r2)
 8226cec:	10c00044 	addi	r3,r2,1
 8226cf0:	008209b4 	movhi	r2,2086
 8226cf4:	10b82804 	addi	r2,r2,-8032
 8226cf8:	10c00015 	stw	r3,0(r2)
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 8226cfc:	e13fff17 	ldw	r4,-4(fp)
 8226d00:	82274900 	call	8227490 <igmp_validate>
 8226d04:	e0bffd15 	stw	r2,-12(fp)
 8226d08:	e0bffd17 	ldw	r2,-12(fp)
 8226d0c:	10001a1e 	bne	r2,zero,8226d78 <igmp_input+0xac>

   /* determine the operating mode for IGMP on the ingress link */
   mode = p->net->igmp_oper_mode;
 8226d10:	e0bfff17 	ldw	r2,-4(fp)
 8226d14:	10800617 	ldw	r2,24(r2)
 8226d18:	10802f03 	ldbu	r2,188(r2)
 8226d1c:	e0bffe05 	stb	r2,-8(fp)
   
   /* feed packet to IGMPv1 or IGMPv2 code based on the operating
    * mode of the ingress link */
   switch (mode)
 8226d20:	e0bffe03 	ldbu	r2,-8(fp)
 8226d24:	10c00060 	cmpeqi	r3,r2,1
 8226d28:	1800031e 	bne	r3,zero,8226d38 <igmp_input+0x6c>
 8226d2c:	108000a0 	cmpeqi	r2,r2,2
 8226d30:	1000041e 	bne	r2,zero,8226d44 <igmp_input+0x78>
 8226d34:	00000606 	br	8226d50 <igmp_input+0x84>
   {
#ifdef IGMP_V1   
      case IGMP_MODE_V1:   
         return (igmpv1_input (p)); 
 8226d38:	e13fff17 	ldw	r4,-4(fp)
 8226d3c:	824535c0 	call	824535c <igmpv1_input>
 8226d40:	00001506 	br	8226d98 <igmp_input+0xcc>
#endif
#ifdef IGMP_V2         
      case IGMP_MODE_V2:       
         return (igmpv2_input (p));
 8226d44:	e13fff17 	ldw	r4,-4(fp)
 8226d48:	82456000 	call	8245600 <igmpv2_input>
 8226d4c:	00001206 	br	8226d98 <igmp_input+0xcc>
#endif
      default:
         ++igmpstats.igmp_bad_oper_mode;     
 8226d50:	008209b4 	movhi	r2,2086
 8226d54:	10b82804 	addi	r2,r2,-8032
 8226d58:	10800d17 	ldw	r2,52(r2)
 8226d5c:	10c00044 	addi	r3,r2,1
 8226d60:	008209b4 	movhi	r2,2086
 8226d64:	10b82804 	addi	r2,r2,-8032
 8226d68:	10c00d15 	stw	r3,52(r2)
         rc = IGMP_ERR;
 8226d6c:	00bfffc4 	movi	r2,-1
 8226d70:	e0bffd15 	stw	r2,-12(fp)
         break;
 8226d74:	00000106 	br	8226d7c <igmp_input+0xb0>
     
   ++igmpstats.igmp_total_rcvd;
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 8226d78:	0001883a 	nop
         break;
   }
   
end:   
   /* return packet buffer back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8226d7c:	01000084 	movi	r4,2
 8226d80:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   pk_free(p);
 8226d84:	e13fff17 	ldw	r4,-4(fp)
 8226d88:	822cbbc0 	call	822cbbc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8226d8c:	01000084 	movi	r4,2
 8226d90:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      
   return rc;
 8226d94:	e0bffd17 	ldw	r2,-12(fp)
}
 8226d98:	e037883a 	mov	sp,fp
 8226d9c:	dfc00117 	ldw	ra,4(sp)
 8226da0:	df000017 	ldw	fp,0(sp)
 8226da4:	dec00204 	addi	sp,sp,8
 8226da8:	f800283a 	ret

08226dac <igmp_fasttimo>:
 *
 * OUTPUT: None.
 */

void igmp_fasttimo (void)
{
 8226dac:	defffc04 	addi	sp,sp,-16
 8226db0:	dfc00315 	stw	ra,12(sp)
 8226db4:	df000215 	stw	fp,8(sp)
 8226db8:	df000204 	addi	fp,sp,8
   struct in_multi * inm;
   NET ifp;
     
   LOCK_NET_RESOURCE (NET_RESID);
 8226dbc:	0009883a 	mov	r4,zero
 8226dc0:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   
   /*
    * Quick check to see if any work needs to be done, in order
    * to minimize the overhead of fasttimo processing.
    */
   if (!igmp_timers_are_running)
 8226dc4:	d0a08617 	ldw	r2,-32232(gp)
 8226dc8:	1000031e 	bne	r2,zero,8226dd8 <igmp_fasttimo+0x2c>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
 8226dcc:	0009883a 	mov	r4,zero
 8226dd0:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return;
 8226dd4:	00004d06 	br	8226f0c <igmp_fasttimo+0x160>
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8226dd8:	008209b4 	movhi	r2,2086
 8226ddc:	10ba6504 	addi	r2,r2,-5740
 8226de0:	10800017 	ldw	r2,0(r2)
 8226de4:	e0bfff15 	stw	r2,-4(fp)
 8226de8:	00004006 	br	8226eec <igmp_fasttimo+0x140>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 8226dec:	e0bfff17 	ldw	r2,-4(fp)
 8226df0:	10802c17 	ldw	r2,176(r2)
 8226df4:	e0bffe15 	stw	r2,-8(fp)
 8226df8:	00003706 	br	8226ed8 <igmp_fasttimo+0x12c>
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
 8226dfc:	e0bffe17 	ldw	r2,-8(fp)
 8226e00:	10800017 	ldw	r2,0(r2)
 8226e04:	10003026 	beq	r2,zero,8226ec8 <igmp_fasttimo+0x11c>
               continue;

         if (inm->inm_timer == 0)   /* timer not set */
 8226e08:	e0bffe17 	ldw	r2,-8(fp)
 8226e0c:	10800317 	ldw	r2,12(r2)
 8226e10:	10002e26 	beq	r2,zero,8226ecc <igmp_fasttimo+0x120>
         {
            /* do nothing */
         }
         else if (--inm->inm_timer == 0)  /* timer expired */
 8226e14:	e0bffe17 	ldw	r2,-8(fp)
 8226e18:	10800317 	ldw	r2,12(r2)
 8226e1c:	10ffffc4 	addi	r3,r2,-1
 8226e20:	e0bffe17 	ldw	r2,-8(fp)
 8226e24:	10c00315 	stw	r3,12(r2)
 8226e28:	e0bffe17 	ldw	r2,-8(fp)
 8226e2c:	10800317 	ldw	r2,12(r2)
 8226e30:	1000261e 	bne	r2,zero,8226ecc <igmp_fasttimo+0x120>
         {
            /* send membership report in appropriate format */
            if (ifp->igmpv1_rtr_present)
 8226e34:	e0bfff17 	ldw	r2,-4(fp)
 8226e38:	10802d03 	ldbu	r2,180(r2)
 8226e3c:	10803fcc 	andi	r2,r2,255
 8226e40:	10000426 	beq	r2,zero,8226e54 <igmp_fasttimo+0xa8>
            {
               /* always true for IGMPv1, may be true for IGMPv2 */
               igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 8226e44:	e17ffe17 	ldw	r5,-8(fp)
 8226e48:	01000484 	movi	r4,18
 8226e4c:	8226f200 	call	8226f20 <igmp_send>
 8226e50:	00000306 	br	8226e60 <igmp_fasttimo+0xb4>
            }
            else
            {
               igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 8226e54:	e17ffe17 	ldw	r5,-8(fp)
 8226e58:	01000584 	movi	r4,22
 8226e5c:	8226f200 	call	8226f20 <igmp_send>

            /* for IGMPv2, indicate that we were the last to send 
             * a Report for this multicast group (relevant for 
             * IGMPv2 only).  also check to see if we should mark 
             * the IGMPv1 router as "absent". */
            if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 8226e60:	e0bfff17 	ldw	r2,-4(fp)
 8226e64:	10802f03 	ldbu	r2,188(r2)
 8226e68:	10803fcc 	andi	r2,r2,255
 8226e6c:	10800098 	cmpnei	r2,r2,2
 8226e70:	1000111e 	bne	r2,zero,8226eb8 <igmp_fasttimo+0x10c>
            {
               inm->last2send_report = IGMP_TRUE;
 8226e74:	e0bffe17 	ldw	r2,-8(fp)
 8226e78:	00c00044 	movi	r3,1
 8226e7c:	10c00405 	stb	r3,16(r2)
               
               if (ifp->igmpv1_rtr_present)
 8226e80:	e0bfff17 	ldw	r2,-4(fp)
 8226e84:	10802d03 	ldbu	r2,180(r2)
 8226e88:	10803fcc 	andi	r2,r2,255
 8226e8c:	10000a26 	beq	r2,zero,8226eb8 <igmp_fasttimo+0x10c>
               {
                  if (cticks > (ifp->igmpv1_query_rcvd_time + (IGMPv1_RTR_PRESENT_TMO * TPS)))
 8226e90:	e0bfff17 	ldw	r2,-4(fp)
 8226e94:	10c02e17 	ldw	r3,184(r2)
 8226e98:	00a71014 	movui	r2,40000
 8226e9c:	1887883a 	add	r3,r3,r2
 8226ea0:	d0a0a817 	ldw	r2,-32096(gp)
 8226ea4:	1880042e 	bgeu	r3,r2,8226eb8 <igmp_fasttimo+0x10c>
                     /* we haven't heard from the IGMPv1 router for a duration
                      * greater than or equal to Version 1 Router Present Timeout 
                      * (400 seconds), and will now update the igmpv1_rtr_present 
                      * variable to reflect that.
                      */
                     ifp->igmpv1_rtr_present = IGMP_FALSE;
 8226ea8:	e0bfff17 	ldw	r2,-4(fp)
 8226eac:	10002d05 	stb	zero,180(r2)
                     ifp->igmpv1_query_rcvd_time = 0;
 8226eb0:	e0bfff17 	ldw	r2,-4(fp)
 8226eb4:	10002e15 	stw	zero,184(r2)
                  }
               }  
            }

            /* decrement the count of running IGMP timers */
            --igmp_timers_are_running;
 8226eb8:	d0a08617 	ldw	r2,-32232(gp)
 8226ebc:	10bfffc4 	addi	r2,r2,-1
 8226ec0:	d0a08615 	stw	r2,-32232(gp)
 8226ec4:	00000106 	br	8226ecc <igmp_fasttimo+0x120>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
               continue;
 8226ec8:	0001883a 	nop
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 8226ecc:	e0bffe17 	ldw	r2,-8(fp)
 8226ed0:	10800517 	ldw	r2,20(r2)
 8226ed4:	e0bffe15 	stw	r2,-8(fp)
 8226ed8:	e0bffe17 	ldw	r2,-8(fp)
 8226edc:	103fc71e 	bne	r2,zero,8226dfc <igmp_fasttimo+0x50>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8226ee0:	e0bfff17 	ldw	r2,-4(fp)
 8226ee4:	10800017 	ldw	r2,0(r2)
 8226ee8:	e0bfff15 	stw	r2,-4(fp)
 8226eec:	e0bfff17 	ldw	r2,-4(fp)
 8226ef0:	103fbe1e 	bne	r2,zero,8226dec <igmp_fasttimo+0x40>
      }     
   }

   /* Setup time for the next call into igmp_fasttimo ()
    * (200 ms later). */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 8226ef4:	d0a0a817 	ldw	r2,-32096(gp)
 8226ef8:	10800504 	addi	r2,r2,20
 8226efc:	d0a08715 	stw	r2,-32228(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 8226f00:	0009883a 	mov	r4,zero
 8226f04:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   
   return;
 8226f08:	0001883a 	nop
}
 8226f0c:	e037883a 	mov	sp,fp
 8226f10:	dfc00117 	ldw	ra,4(sp)
 8226f14:	df000017 	ldw	fp,0(sp)
 8226f18:	dec00204 	addi	sp,sp,8
 8226f1c:	f800283a 	ret

08226f20 <igmp_send>:
 *
 * OUTPUT: None.
 */

void igmp_send (u_char type, struct in_multi * inm)
{
 8226f20:	deffde04 	addi	sp,sp,-136
 8226f24:	dfc02115 	stw	ra,132(sp)
 8226f28:	df002015 	stw	fp,128(sp)
 8226f2c:	df002004 	addi	fp,sp,128
 8226f30:	2005883a 	mov	r2,r4
 8226f34:	e17fff15 	stw	r5,-4(fp)
 8226f38:	e0bffe05 	stb	r2,-8(fp)
   struct igmp * igmp;
   struct ip_moptions * imop;
   struct ip_moptions simo;
   struct ip * pip;
   u_char * tmpp;
   u_char opts [2] = {IP_RTR_ALERT_OPT, EOL_OPT};
 8226f3c:	00800504 	movi	r2,20
 8226f40:	e0bffd05 	stb	r2,-12(fp)
 8226f44:	e03ffd45 	stb	zero,-11(fp)
   u_char reqd_len;

   /* compute length of buffer required for outgoing packet.
    * also account for the length of the IP Router Alert 
    * option, if required. */   
   reqd_len = MaxLnh + sizeof (struct ip) + sizeof (struct igmp);
 8226f48:	d0a08117 	ldw	r2,-32252(gp)
 8226f4c:	10800704 	addi	r2,r2,28
 8226f50:	e0bfe205 	stb	r2,-120(fp)
   if ((type == IGMPv2_LEAVE_GROUP) || 
 8226f54:	e0bffe03 	ldbu	r2,-8(fp)
 8226f58:	108005e0 	cmpeqi	r2,r2,23
 8226f5c:	1000031e 	bne	r2,zero,8226f6c <igmp_send+0x4c>
 8226f60:	e0bffe03 	ldbu	r2,-8(fp)
 8226f64:	10800598 	cmpnei	r2,r2,22
 8226f68:	1000031e 	bne	r2,zero,8226f78 <igmp_send+0x58>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      reqd_len += IP_RTR_ALERT_OPT_SIZE;
 8226f6c:	e0bfe203 	ldbu	r2,-120(fp)
 8226f70:	10800104 	addi	r2,r2,4
 8226f74:	e0bfe205 	stb	r2,-120(fp)
   }

   /* obtain a packet to send the IGMP message */
   LOCK_NET_RESOURCE (FREEQ_RESID);
 8226f78:	01000084 	movi	r4,2
 8226f7c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   p = pk_alloc (reqd_len);
 8226f80:	e0bfe203 	ldbu	r2,-120(fp)
 8226f84:	1009883a 	mov	r4,r2
 8226f88:	822c86c0 	call	822c86c <pk_alloc>
 8226f8c:	e0bfe315 	stw	r2,-116(fp)
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8226f90:	01000084 	movi	r4,2
 8226f94:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   
   /* log an error and return if the allocation fails */   
   if (!p)
 8226f98:	e0bfe317 	ldw	r2,-116(fp)
 8226f9c:	1000081e 	bne	r2,zero,8226fc0 <igmp_send+0xa0>
   {
      ++igmpstats.igmp_pkt_alloc_fail;
 8226fa0:	008209b4 	movhi	r2,2086
 8226fa4:	10b82804 	addi	r2,r2,-8032
 8226fa8:	10800c17 	ldw	r2,48(r2)
 8226fac:	10c00044 	addi	r3,r2,1
 8226fb0:	008209b4 	movhi	r2,2086
 8226fb4:	10b82804 	addi	r2,r2,-8032
 8226fb8:	10c00c15 	stw	r3,48(r2)
 8226fbc:	00007a06 	br	82271a8 <igmp_send+0x288>
      return;
   }

   /* Need to fill in the source and destination ip addresses */
   pip = (struct ip *) p->nb_prot;
 8226fc0:	e0bfe317 	ldw	r2,-116(fp)
 8226fc4:	10800317 	ldw	r2,12(r2)
 8226fc8:	e0bfe415 	stw	r2,-112(fp)
   pip->ip_src = inm->inm_netp->n_ipaddr;
 8226fcc:	e0bfff17 	ldw	r2,-4(fp)
 8226fd0:	10800117 	ldw	r2,4(r2)
 8226fd4:	10c00a17 	ldw	r3,40(r2)
 8226fd8:	e0bfe417 	ldw	r2,-112(fp)
 8226fdc:	10c00315 	stw	r3,12(r2)
   /* Leave Group messages are sent to the all-routers multicast group */
   if (type == IGMPv2_LEAVE_GROUP)
 8226fe0:	e0bffe03 	ldbu	r2,-8(fp)
 8226fe4:	108005d8 	cmpnei	r2,r2,23
 8226fe8:	1000041e 	bne	r2,zero,8226ffc <igmp_send+0xdc>
   {
      /* igmp_all_rtrs_group is already in network byte order */
      pip->ip_dest = igmp_all_rtrs_group;
 8226fec:	d0e08917 	ldw	r3,-32220(gp)
 8226ff0:	e0bfe417 	ldw	r2,-112(fp)
 8226ff4:	10c00415 	stw	r3,16(r2)
 8226ff8:	00000406 	br	822700c <igmp_send+0xec>
   }
   else
      pip->ip_dest = inm->inm_addr;
 8226ffc:	e0bfff17 	ldw	r2,-4(fp)
 8227000:	10c00017 	ldw	r3,0(r2)
 8227004:	e0bfe417 	ldw	r2,-112(fp)
 8227008:	10c00415 	stw	r3,16(r2)
   
   p->fhost = pip->ip_dest;
 822700c:	e0bfe417 	ldw	r2,-112(fp)
 8227010:	10c00417 	ldw	r3,16(r2)
 8227014:	e0bfe317 	ldw	r2,-116(fp)
 8227018:	10c00715 	stw	r3,28(r2)

   tmpp = (((u_char *) p->nb_prot) + sizeof (struct ip));
 822701c:	e0bfe317 	ldw	r2,-116(fp)
 8227020:	10800317 	ldw	r2,12(r2)
 8227024:	10800504 	addi	r2,r2,20
 8227028:	e0bfe015 	stw	r2,-128(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 822702c:	e0bffe03 	ldbu	r2,-8(fp)
 8227030:	108005e0 	cmpeqi	r2,r2,23
 8227034:	1000031e 	bne	r2,zero,8227044 <igmp_send+0x124>
 8227038:	e0bffe03 	ldbu	r2,-8(fp)
 822703c:	10800598 	cmpnei	r2,r2,22
 8227040:	1000061e 	bne	r2,zero,822705c <igmp_send+0x13c>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      /* provide space for ip_write2 () to write option-related data */
      tmpp += IP_RTR_ALERT_OPT_SIZE;
 8227044:	e0bfe017 	ldw	r2,-128(fp)
 8227048:	10800104 	addi	r2,r2,4
 822704c:	e0bfe015 	stw	r2,-128(fp)
      optp = &(opts [0]); /* one option (IP Router Alert) */
 8227050:	e0bffd04 	addi	r2,fp,-12
 8227054:	e0bfe115 	stw	r2,-124(fp)
 8227058:	00000306 	br	8227068 <igmp_send+0x148>
   }
   /* outgoing packet does not require any options */
   else 
      optp = &(opts [1]);
 822705c:	e0bffd04 	addi	r2,fp,-12
 8227060:	10800044 	addi	r2,r2,1
 8227064:	e0bfe115 	stw	r2,-124(fp)
   /* point to the start of the IGMP header */
   igmp = (struct igmp *) tmpp;
 8227068:	e0bfe017 	ldw	r2,-128(fp)
 822706c:	e0bfe515 	stw	r2,-108(fp)
   
   igmp->igmp_type = type;
 8227070:	e0bfe517 	ldw	r2,-108(fp)
 8227074:	e0fffe03 	ldbu	r3,-8(fp)
 8227078:	10c00005 	stb	r3,0(r2)
   igmp->igmp_code = 0;
 822707c:	e0bfe517 	ldw	r2,-108(fp)
 8227080:	10000045 	stb	zero,1(r2)
   
   /* all messages (Report or Leave) have Group Address field 
    * set to the group being reported or left */
   igmp->igmp_group = inm->inm_addr;
 8227084:	e0bfff17 	ldw	r2,-4(fp)
 8227088:	10c00017 	ldw	r3,0(r2)
 822708c:	e0bfe517 	ldw	r2,-108(fp)
 8227090:	10c00115 	stw	r3,4(r2)
   igmp->igmp_cksum = 0;
 8227094:	e0bfe517 	ldw	r2,-108(fp)
 8227098:	1000008d 	sth	zero,2(r2)
   igmp->igmp_cksum = ~cksum((void*)igmp, IGMP_MINLEN>>1);
 822709c:	01400104 	movi	r5,4
 82270a0:	e13fe517 	ldw	r4,-108(fp)
 82270a4:	82286f00 	call	82286f0 <cksum>
 82270a8:	0084303a 	nor	r2,zero,r2
 82270ac:	1007883a 	mov	r3,r2
 82270b0:	e0bfe517 	ldw	r2,-108(fp)
 82270b4:	10c0008d 	sth	r3,2(r2)

   imop = &simo;
 82270b8:	e0bfe704 	addi	r2,fp,-100
 82270bc:	e0bfe615 	stw	r2,-104(fp)
   MEMSET(imop, 0, sizeof(simo));
 82270c0:	01801604 	movi	r6,88
 82270c4:	000b883a 	mov	r5,zero
 82270c8:	e13fe617 	ldw	r4,-104(fp)
 82270cc:	82031300 	call	8203130 <memset>
   imop->imo_multicast_netp = inm->inm_netp;
 82270d0:	e0bfff17 	ldw	r2,-4(fp)
 82270d4:	10c00117 	ldw	r3,4(r2)
 82270d8:	e0bfe617 	ldw	r2,-104(fp)
 82270dc:	10c00015 	stw	r3,0(r2)
   imop->imo_multicast_ttl = 1;
 82270e0:	e0bfe617 	ldw	r2,-104(fp)
 82270e4:	00c00044 	movi	r3,1
 82270e8:	10c00105 	stb	r3,4(r2)
   /* we do not want our own reports to be looped back */
   imop->imo_multicast_loop = 0;
 82270ec:	e0bfe617 	ldw	r2,-104(fp)
 82270f0:	10000145 	stb	zero,5(r2)

   /* set nb_prot to point to the beginning of the IGMP data,
    * and nb_plen to the length of the IGMP data, and attach
    * the multicast options structure to the outgoing packet */
   p->nb_prot = (char *) tmpp;
 82270f4:	e0bfe317 	ldw	r2,-116(fp)
 82270f8:	e0ffe017 	ldw	r3,-128(fp)
 82270fc:	10c00315 	stw	r3,12(r2)
   p->nb_plen = sizeof(struct igmp);
 8227100:	e0bfe317 	ldw	r2,-116(fp)
 8227104:	00c00204 	movi	r3,8
 8227108:	10c00415 	stw	r3,16(r2)
   p->imo = imop;
 822710c:	e0bfe317 	ldw	r2,-116(fp)
 8227110:	e0ffe617 	ldw	r3,-104(fp)
 8227114:	10c00b15 	stw	r3,44(r2)
   
   ip_write2 (IGMP_PROT, p, optp);
 8227118:	e1bfe117 	ldw	r6,-124(fp)
 822711c:	e17fe317 	ldw	r5,-116(fp)
 8227120:	01000084 	movi	r4,2
 8227124:	823f9d00 	call	823f9d0 <ip_write2>

   if (type == IGMPv2_LEAVE_GROUP)
 8227128:	e0bffe03 	ldbu	r2,-8(fp)
 822712c:	108005d8 	cmpnei	r2,r2,23
 8227130:	1000081e 	bne	r2,zero,8227154 <igmp_send+0x234>
      ++igmpstats.igmpv2mode_v2_leave_msgs_sent;
 8227134:	008209b4 	movhi	r2,2086
 8227138:	10b82804 	addi	r2,r2,-8032
 822713c:	10801717 	ldw	r2,92(r2)
 8227140:	10c00044 	addi	r3,r2,1
 8227144:	008209b4 	movhi	r2,2086
 8227148:	10b82804 	addi	r2,r2,-8032
 822714c:	10c01715 	stw	r3,92(r2)
 8227150:	00001506 	br	82271a8 <igmp_send+0x288>
   else if (type == IGMPv2_MEMBERSHIP_REPORT)
 8227154:	e0bffe03 	ldbu	r2,-8(fp)
 8227158:	10800598 	cmpnei	r2,r2,22
 822715c:	1000081e 	bne	r2,zero,8227180 <igmp_send+0x260>
      ++igmpstats.igmpv2mode_v2_reports_sent;
 8227160:	008209b4 	movhi	r2,2086
 8227164:	10b82804 	addi	r2,r2,-8032
 8227168:	10801817 	ldw	r2,96(r2)
 822716c:	10c00044 	addi	r3,r2,1
 8227170:	008209b4 	movhi	r2,2086
 8227174:	10b82804 	addi	r2,r2,-8032
 8227178:	10c01815 	stw	r3,96(r2)
 822717c:	00000a06 	br	82271a8 <igmp_send+0x288>
   else if (type == IGMP_HOST_MEMBERSHIP_REPORT)
 8227180:	e0bffe03 	ldbu	r2,-8(fp)
 8227184:	10800498 	cmpnei	r2,r2,18
 8227188:	1000071e 	bne	r2,zero,82271a8 <igmp_send+0x288>
      ++igmpstats.igmp_v1_reports_sent;
 822718c:	008209b4 	movhi	r2,2086
 8227190:	10b82804 	addi	r2,r2,-8032
 8227194:	10801617 	ldw	r2,88(r2)
 8227198:	10c00044 	addi	r3,r2,1
 822719c:	008209b4 	movhi	r2,2086
 82271a0:	10b82804 	addi	r2,r2,-8032
 82271a4:	10c01615 	stw	r3,88(r2)
}
 82271a8:	e037883a 	mov	sp,fp
 82271ac:	dfc00117 	ldw	ra,4(sp)
 82271b0:	df000017 	ldw	fp,0(sp)
 82271b4:	dec00204 	addi	sp,sp,8
 82271b8:	f800283a 	ret

082271bc <igmp_joingroup>:
 *
 * OUTPUT: None.
 */
 
void igmp_joingroup(struct in_multi * inm)
{
 82271bc:	defffc04 	addi	sp,sp,-16
 82271c0:	dfc00315 	stw	ra,12(sp)
 82271c4:	df000215 	stw	fp,8(sp)
 82271c8:	df000204 	addi	fp,sp,8
 82271cc:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   /* extract the network interface to which this multicast
    * address is "attached" */
   ifp = inm->inm_netp;
 82271d0:	e0bfff17 	ldw	r2,-4(fp)
 82271d4:	10800117 	ldw	r2,4(r2)
 82271d8:	e0bffe15 	stw	r2,-8(fp)

   if (inm->inm_addr == igmp_all_hosts_group)
 82271dc:	e0bfff17 	ldw	r2,-4(fp)
 82271e0:	10c00017 	ldw	r3,0(r2)
 82271e4:	d0a08817 	ldw	r2,-32224(gp)
 82271e8:	1880031e 	bne	r3,r2,82271f8 <igmp_joingroup+0x3c>
   {
      inm->inm_timer = 0;
 82271ec:	e0bfff17 	ldw	r2,-4(fp)
 82271f0:	10000315 	stw	zero,12(r2)
      }

      ++igmp_timers_are_running;
   }
   
   return;
 82271f4:	00008106 	br	82273fc <igmp_joingroup+0x240>
      inm->inm_timer = 0;
   }
   else 
   {
      /* send unsolicited membership report in appropriate format */
      if (ifp->igmpv1_rtr_present)
 82271f8:	e0bffe17 	ldw	r2,-8(fp)
 82271fc:	10802d03 	ldbu	r2,180(r2)
 8227200:	10803fcc 	andi	r2,r2,255
 8227204:	10003926 	beq	r2,zero,82272ec <igmp_joingroup+0x130>
      {
         /* always true for IGMPv1, may be true for IGMPv2 */
         igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 8227208:	e17fff17 	ldw	r5,-4(fp)
 822720c:	01000484 	movi	r4,18
 8227210:	8226f200 	call	8226f20 <igmp_send>
         /* set a delay timer (with a duration of 
          * IGMP_MAX_HOST_REPORT_DELAY) for a second unsolicited report */
         inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 8227214:	008209b4 	movhi	r2,2086
 8227218:	10ba6a04 	addi	r2,r2,-5720
 822721c:	10c00217 	ldw	r3,8(r2)
 8227220:	008209b4 	movhi	r2,2086
 8227224:	10b82404 	addi	r2,r2,-8048
 8227228:	10800017 	ldw	r2,0(r2)
 822722c:	10800a17 	ldw	r2,40(r2)
 8227230:	1008d63a 	srli	r4,r2,24
 8227234:	008209b4 	movhi	r2,2086
 8227238:	10b82404 	addi	r2,r2,-8048
 822723c:	10800017 	ldw	r2,0(r2)
 8227240:	10800a17 	ldw	r2,40(r2)
 8227244:	1004d23a 	srli	r2,r2,8
 8227248:	10bfc00c 	andi	r2,r2,65280
 822724c:	2088b03a 	or	r4,r4,r2
 8227250:	008209b4 	movhi	r2,2086
 8227254:	10b82404 	addi	r2,r2,-8048
 8227258:	10800017 	ldw	r2,0(r2)
 822725c:	10800a17 	ldw	r2,40(r2)
 8227260:	10bfc00c 	andi	r2,r2,65280
 8227264:	1004923a 	slli	r2,r2,8
 8227268:	2088b03a 	or	r4,r4,r2
 822726c:	008209b4 	movhi	r2,2086
 8227270:	10b82404 	addi	r2,r2,-8048
 8227274:	10800017 	ldw	r2,0(r2)
 8227278:	10800a17 	ldw	r2,40(r2)
 822727c:	1004963a 	slli	r2,r2,24
 8227280:	2084b03a 	or	r2,r4,r2
 8227284:	1887883a 	add	r3,r3,r2
 8227288:	e0bfff17 	ldw	r2,-4(fp)
 822728c:	10800017 	ldw	r2,0(r2)
 8227290:	1008d63a 	srli	r4,r2,24
 8227294:	e0bfff17 	ldw	r2,-4(fp)
 8227298:	10800017 	ldw	r2,0(r2)
 822729c:	1004d23a 	srli	r2,r2,8
 82272a0:	10bfc00c 	andi	r2,r2,65280
 82272a4:	2088b03a 	or	r4,r4,r2
 82272a8:	e0bfff17 	ldw	r2,-4(fp)
 82272ac:	10800017 	ldw	r2,0(r2)
 82272b0:	10bfc00c 	andi	r2,r2,65280
 82272b4:	1004923a 	slli	r2,r2,8
 82272b8:	2088b03a 	or	r4,r4,r2
 82272bc:	e0bfff17 	ldw	r2,-4(fp)
 82272c0:	10800017 	ldw	r2,0(r2)
 82272c4:	1004963a 	slli	r2,r2,24
 82272c8:	2084b03a 	or	r2,r4,r2
 82272cc:	1885883a 	add	r2,r3,r2
 82272d0:	01400c84 	movi	r5,50
 82272d4:	1009883a 	mov	r4,r2
 82272d8:	8202bf00 	call	8202bf0 <__umodsi3>
 82272dc:	10c00044 	addi	r3,r2,1
 82272e0:	e0bfff17 	ldw	r2,-4(fp)
 82272e4:	10c00315 	stw	r3,12(r2)
 82272e8:	00003806 	br	82273cc <igmp_joingroup+0x210>
      }
      else
      {
         igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 82272ec:	e17fff17 	ldw	r5,-4(fp)
 82272f0:	01000584 	movi	r4,22
 82272f4:	8226f200 	call	8226f20 <igmp_send>
         /* the delay time duration is the Unsolicited Report Interval */
         inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY ((UNSOLIC_RPT_INTERVAL * PR_FASTHZ), inm->inm_addr);
 82272f8:	008209b4 	movhi	r2,2086
 82272fc:	10ba6a04 	addi	r2,r2,-5720
 8227300:	10c00217 	ldw	r3,8(r2)
 8227304:	008209b4 	movhi	r2,2086
 8227308:	10b82404 	addi	r2,r2,-8048
 822730c:	10800017 	ldw	r2,0(r2)
 8227310:	10800a17 	ldw	r2,40(r2)
 8227314:	1008d63a 	srli	r4,r2,24
 8227318:	008209b4 	movhi	r2,2086
 822731c:	10b82404 	addi	r2,r2,-8048
 8227320:	10800017 	ldw	r2,0(r2)
 8227324:	10800a17 	ldw	r2,40(r2)
 8227328:	1004d23a 	srli	r2,r2,8
 822732c:	10bfc00c 	andi	r2,r2,65280
 8227330:	2088b03a 	or	r4,r4,r2
 8227334:	008209b4 	movhi	r2,2086
 8227338:	10b82404 	addi	r2,r2,-8048
 822733c:	10800017 	ldw	r2,0(r2)
 8227340:	10800a17 	ldw	r2,40(r2)
 8227344:	10bfc00c 	andi	r2,r2,65280
 8227348:	1004923a 	slli	r2,r2,8
 822734c:	2088b03a 	or	r4,r4,r2
 8227350:	008209b4 	movhi	r2,2086
 8227354:	10b82404 	addi	r2,r2,-8048
 8227358:	10800017 	ldw	r2,0(r2)
 822735c:	10800a17 	ldw	r2,40(r2)
 8227360:	1004963a 	slli	r2,r2,24
 8227364:	2084b03a 	or	r2,r4,r2
 8227368:	1887883a 	add	r3,r3,r2
 822736c:	e0bfff17 	ldw	r2,-4(fp)
 8227370:	10800017 	ldw	r2,0(r2)
 8227374:	1008d63a 	srli	r4,r2,24
 8227378:	e0bfff17 	ldw	r2,-4(fp)
 822737c:	10800017 	ldw	r2,0(r2)
 8227380:	1004d23a 	srli	r2,r2,8
 8227384:	10bfc00c 	andi	r2,r2,65280
 8227388:	2088b03a 	or	r4,r4,r2
 822738c:	e0bfff17 	ldw	r2,-4(fp)
 8227390:	10800017 	ldw	r2,0(r2)
 8227394:	10bfc00c 	andi	r2,r2,65280
 8227398:	1004923a 	slli	r2,r2,8
 822739c:	2088b03a 	or	r4,r4,r2
 82273a0:	e0bfff17 	ldw	r2,-4(fp)
 82273a4:	10800017 	ldw	r2,0(r2)
 82273a8:	1004963a 	slli	r2,r2,24
 82273ac:	2084b03a 	or	r2,r4,r2
 82273b0:	1885883a 	add	r2,r3,r2
 82273b4:	01400c84 	movi	r5,50
 82273b8:	1009883a 	mov	r4,r2
 82273bc:	8202bf00 	call	8202bf0 <__umodsi3>
 82273c0:	10c00044 	addi	r3,r2,1
 82273c4:	e0bfff17 	ldw	r2,-4(fp)
 82273c8:	10c00315 	stw	r3,12(r2)
      }
      
      /* for IGMPv2, indicate that we were the last to send 
       * a Report for this multicast group (relevant for 
       * IGMPv2 only). */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 82273cc:	e0bffe17 	ldw	r2,-8(fp)
 82273d0:	10802f03 	ldbu	r2,188(r2)
 82273d4:	10803fcc 	andi	r2,r2,255
 82273d8:	10800098 	cmpnei	r2,r2,2
 82273dc:	1000031e 	bne	r2,zero,82273ec <igmp_joingroup+0x230>
      {
         inm->last2send_report = IGMP_TRUE;
 82273e0:	e0bfff17 	ldw	r2,-4(fp)
 82273e4:	00c00044 	movi	r3,1
 82273e8:	10c00405 	stb	r3,16(r2)
      }

      ++igmp_timers_are_running;
 82273ec:	d0a08617 	ldw	r2,-32232(gp)
 82273f0:	10800044 	addi	r2,r2,1
 82273f4:	d0a08615 	stw	r2,-32232(gp)
   }
   
   return;
 82273f8:	0001883a 	nop
}     
 82273fc:	e037883a 	mov	sp,fp
 8227400:	dfc00117 	ldw	ra,4(sp)
 8227404:	df000017 	ldw	fp,0(sp)
 8227408:	dec00204 	addi	sp,sp,8
 822740c:	f800283a 	ret

08227410 <igmp_leavegroup>:
 *
 * OUTPUT: None.
 */

void igmp_leavegroup (struct in_multi * inm)
{
 8227410:	defffc04 	addi	sp,sp,-16
 8227414:	dfc00315 	stw	ra,12(sp)
 8227418:	df000215 	stw	fp,8(sp)
 822741c:	df000204 	addi	fp,sp,8
 8227420:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = inm->inm_netp;
 8227424:	e0bfff17 	ldw	r2,-4(fp)
 8227428:	10800117 	ldw	r2,4(r2)
 822742c:	e0bffe15 	stw	r2,-8(fp)

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 8227430:	e0bffe17 	ldw	r2,-8(fp)
 8227434:	10802f03 	ldbu	r2,188(r2)
 8227438:	10803fcc 	andi	r2,r2,255
 822743c:	10800098 	cmpnei	r2,r2,2
 8227440:	10000d1e 	bne	r2,zero,8227478 <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
 8227444:	e0bffe17 	ldw	r2,-8(fp)
 8227448:	10802d03 	ldbu	r2,180(r2)
{
   NET ifp;

   ifp = inm->inm_netp;

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 822744c:	10803fcc 	andi	r2,r2,255
 8227450:	1000091e 	bne	r2,zero,8227478 <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
   {
      if (inm->last2send_report == IGMP_TRUE)
 8227454:	e0bfff17 	ldw	r2,-4(fp)
 8227458:	10800403 	ldbu	r2,16(r2)
 822745c:	10803fcc 	andi	r2,r2,255
 8227460:	10800058 	cmpnei	r2,r2,1
 8227464:	1000041e 	bne	r2,zero,8227478 <igmp_leavegroup+0x68>
         igmp_send (IGMPv2_LEAVE_GROUP, inm);
 8227468:	e17fff17 	ldw	r5,-4(fp)
 822746c:	010005c4 	movi	r4,23
 8227470:	8226f200 	call	8226f20 <igmp_send>
   }
   
   return;
 8227474:	0001883a 	nop
 8227478:	0001883a 	nop
}
 822747c:	e037883a 	mov	sp,fp
 8227480:	dfc00117 	ldw	ra,4(sp)
 8227484:	df000017 	ldw	fp,0(sp)
 8227488:	dec00204 	addi	sp,sp,8
 822748c:	f800283a 	ret

08227490 <igmp_validate>:
 *         validation fails; otherwise, it returns
 *         IGMP_OK.
 */

int igmp_validate (PACKET p)
{
 8227490:	defff604 	addi	sp,sp,-40
 8227494:	dfc00915 	stw	ra,36(sp)
 8227498:	df000815 	stw	fp,32(sp)
 822749c:	df000804 	addi	fp,sp,32
 82274a0:	e13fff15 	stw	r4,-4(fp)
   u_short xsum;  
   u_char type;
   ip_addr mcgrp_addr;
   u_char resp_time;

   pip = ip_head (p);
 82274a4:	e0bfff17 	ldw	r2,-4(fp)
 82274a8:	10800317 	ldw	r2,12(r2)
 82274ac:	e0bff815 	stw	r2,-32(fp)

   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */
   igmplen = p->nb_plen - ip_hlen (pip);
 82274b0:	e0bfff17 	ldw	r2,-4(fp)
 82274b4:	10c00417 	ldw	r3,16(r2)
 82274b8:	e0bff817 	ldw	r2,-32(fp)
 82274bc:	10800003 	ldbu	r2,0(r2)
 82274c0:	10803fcc 	andi	r2,r2,255
 82274c4:	108003cc 	andi	r2,r2,15
 82274c8:	1085883a 	add	r2,r2,r2
 82274cc:	1085883a 	add	r2,r2,r2
 82274d0:	1885c83a 	sub	r2,r3,r2
 82274d4:	e0bff915 	stw	r2,-28(fp)

   /* validate length (IGMP_MINLEN is 8 bytes) */
   if (igmplen != IGMP_MINLEN) 
 82274d8:	e0bff917 	ldw	r2,-28(fp)
 82274dc:	10800220 	cmpeqi	r2,r2,8
 82274e0:	1000091e 	bne	r2,zero,8227508 <igmp_validate+0x78>
   {
      ++igmpstats.igmp_badlen_rcvd;
 82274e4:	008209b4 	movhi	r2,2086
 82274e8:	10b82804 	addi	r2,r2,-8032
 82274ec:	10800a17 	ldw	r2,40(r2)
 82274f0:	10c00044 	addi	r3,r2,1
 82274f4:	008209b4 	movhi	r2,2086
 82274f8:	10b82804 	addi	r2,r2,-8032
 82274fc:	10c00a15 	stw	r3,40(r2)
      return ENP_BAD_HEADER;
 8227500:	00bff804 	movi	r2,-32
 8227504:	0000a306 	br	8227794 <igmp_validate+0x304>
   }

   /* validate checksum */
   igmp = (struct igmp *) (ip_data (pip));
 8227508:	e0bff817 	ldw	r2,-32(fp)
 822750c:	10800003 	ldbu	r2,0(r2)
 8227510:	10803fcc 	andi	r2,r2,255
 8227514:	108003cc 	andi	r2,r2,15
 8227518:	1085883a 	add	r2,r2,r2
 822751c:	1085883a 	add	r2,r2,r2
 8227520:	1007883a 	mov	r3,r2
 8227524:	e0bff817 	ldw	r2,-32(fp)
 8227528:	10c5883a 	add	r2,r2,r3
 822752c:	e0bffa15 	stw	r2,-24(fp)
   osum = igmp->igmp_cksum;
 8227530:	e0bffa17 	ldw	r2,-24(fp)
 8227534:	1080008b 	ldhu	r2,2(r2)
 8227538:	e0bffb0d 	sth	r2,-20(fp)
   igmp->igmp_cksum = 0;
 822753c:	e0bffa17 	ldw	r2,-24(fp)
 8227540:	1000008d 	sth	zero,2(r2)
   xsum = ~cksum(igmp, igmplen>>1);
 8227544:	e0bff917 	ldw	r2,-28(fp)
 8227548:	1005d07a 	srai	r2,r2,1
 822754c:	100b883a 	mov	r5,r2
 8227550:	e13ffa17 	ldw	r4,-24(fp)
 8227554:	82286f00 	call	82286f0 <cksum>
 8227558:	0084303a 	nor	r2,zero,r2
 822755c:	e0bffb8d 	sth	r2,-18(fp)
   if (xsum != osum)
 8227560:	e0fffb8b 	ldhu	r3,-18(fp)
 8227564:	e0bffb0b 	ldhu	r2,-20(fp)
 8227568:	18800c26 	beq	r3,r2,822759c <igmp_validate+0x10c>
   {
      igmp->igmp_cksum = osum;
 822756c:	e0bffa17 	ldw	r2,-24(fp)
 8227570:	e0fffb0b 	ldhu	r3,-20(fp)
 8227574:	10c0008d 	sth	r3,2(r2)
      ++igmpstats.igmp_badsum_rcvd;
 8227578:	008209b4 	movhi	r2,2086
 822757c:	10b82804 	addi	r2,r2,-8032
 8227580:	10800b17 	ldw	r2,44(r2)
 8227584:	10c00044 	addi	r3,r2,1
 8227588:	008209b4 	movhi	r2,2086
 822758c:	10b82804 	addi	r2,r2,-8032
 8227590:	10c00b15 	stw	r3,44(r2)
      return ENP_BAD_HEADER;
 8227594:	00bff804 	movi	r2,-32
 8227598:	00007e06 	br	8227794 <igmp_validate+0x304>
   }
   
   /* extract the IGMP packet type, Group Address, and Max Response Time 
    * (unused for IGMPv1) fields from received packet */
   type = igmp->igmp_type;
 822759c:	e0bffa17 	ldw	r2,-24(fp)
 82275a0:	10800003 	ldbu	r2,0(r2)
 82275a4:	e0bffc05 	stb	r2,-16(fp)
   mcgrp_addr = ntohl(igmp->igmp_group); 
 82275a8:	e0bffa17 	ldw	r2,-24(fp)
 82275ac:	10800117 	ldw	r2,4(r2)
 82275b0:	1006d63a 	srli	r3,r2,24
 82275b4:	e0bffa17 	ldw	r2,-24(fp)
 82275b8:	10800117 	ldw	r2,4(r2)
 82275bc:	1004d23a 	srli	r2,r2,8
 82275c0:	10bfc00c 	andi	r2,r2,65280
 82275c4:	1886b03a 	or	r3,r3,r2
 82275c8:	e0bffa17 	ldw	r2,-24(fp)
 82275cc:	10800117 	ldw	r2,4(r2)
 82275d0:	10bfc00c 	andi	r2,r2,65280
 82275d4:	1004923a 	slli	r2,r2,8
 82275d8:	1886b03a 	or	r3,r3,r2
 82275dc:	e0bffa17 	ldw	r2,-24(fp)
 82275e0:	10800117 	ldw	r2,4(r2)
 82275e4:	1004963a 	slli	r2,r2,24
 82275e8:	1884b03a 	or	r2,r3,r2
 82275ec:	e0bffd15 	stw	r2,-12(fp)
   resp_time = igmp->igmp_code;
 82275f0:	e0bffa17 	ldw	r2,-24(fp)
 82275f4:	10800043 	ldbu	r2,1(r2)
 82275f8:	e0bffe05 	stb	r2,-8(fp)
      
   if (type == IGMP_HOST_MEMBERSHIP_QUERY)
 82275fc:	e0bffc03 	ldbu	r2,-16(fp)
 8227600:	10800458 	cmpnei	r2,r2,17
 8227604:	1000301e 	bne	r2,zero,82276c8 <igmp_validate+0x238>
   {
      if ((resp_time == 0) || /* IGMPv1 Query */
 8227608:	e0bffe03 	ldbu	r2,-8(fp)
 822760c:	10000426 	beq	r2,zero,8227620 <igmp_validate+0x190>
 8227610:	e0bffe03 	ldbu	r2,-8(fp)
 8227614:	10000f26 	beq	r2,zero,8227654 <igmp_validate+0x1c4>
          ((resp_time > 0) && (mcgrp_addr == 0))) /* IGMPv2 General Query */     
 8227618:	e0bffd17 	ldw	r2,-12(fp)
 822761c:	10000d1e 	bne	r2,zero,8227654 <igmp_validate+0x1c4>
      {
         /* if this is a IGMPv1 Host Membership Query or a IGMPv2 
          * General Query, it must be addressed to the all-hosts 
          * group */
         if (pip->ip_dest != igmp_all_hosts_group) 
 8227620:	e0bff817 	ldw	r2,-32(fp)
 8227624:	10c00417 	ldw	r3,16(r2)
 8227628:	d0a08817 	ldw	r2,-32224(gp)
 822762c:	18800926 	beq	r3,r2,8227654 <igmp_validate+0x1c4>
         {
            ++igmpstats.igmp_bad_queries_rcvd;
 8227630:	008209b4 	movhi	r2,2086
 8227634:	10b82804 	addi	r2,r2,-8032
 8227638:	10800e17 	ldw	r2,56(r2)
 822763c:	10c00044 	addi	r3,r2,1
 8227640:	008209b4 	movhi	r2,2086
 8227644:	10b82804 	addi	r2,r2,-8032
 8227648:	10c00e15 	stw	r3,56(r2)
            return ENP_BAD_HEADER;
 822764c:	00bff804 	movi	r2,-32
 8227650:	00005006 	br	8227794 <igmp_validate+0x304>
         }     
      }
      
      if ((resp_time > 0) && (mcgrp_addr != 0))
 8227654:	e0bffe03 	ldbu	r2,-8(fp)
 8227658:	10001b26 	beq	r2,zero,82276c8 <igmp_validate+0x238>
 822765c:	e0bffd17 	ldw	r2,-12(fp)
 8227660:	10001926 	beq	r2,zero,82276c8 <igmp_validate+0x238>
      {
         /* this is a IGMPv2 Group-Specific Query. */
         if (p->net->igmp_oper_mode == IGMP_MODE_V1)
 8227664:	e0bfff17 	ldw	r2,-4(fp)
 8227668:	10800617 	ldw	r2,24(r2)
 822766c:	10802f03 	ldbu	r2,188(r2)
 8227670:	10803fcc 	andi	r2,r2,255
 8227674:	10800058 	cmpnei	r2,r2,1
 8227678:	1000021e 	bne	r2,zero,8227684 <igmp_validate+0x1f4>
         {
            /* IGMPv1 code does not understand a IGMPv2 Group-
             * Specific Query */
            return ENP_BAD_HEADER; 
 822767c:	00bff804 	movi	r2,-32
 8227680:	00004406 	br	8227794 <igmp_validate+0x304>
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 8227684:	e0bffd17 	ldw	r2,-12(fp)
 8227688:	10fc002c 	andhi	r3,r2,61440
 822768c:	00b80034 	movhi	r2,57344
 8227690:	1880041e 	bne	r3,r2,82276a4 <igmp_validate+0x214>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
 8227694:	e0bffa17 	ldw	r2,-24(fp)
 8227698:	10c00117 	ldw	r3,4(r2)
 822769c:	d0a08817 	ldw	r2,-32224(gp)
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 82276a0:	1880091e 	bne	r3,r2,82276c8 <igmp_validate+0x238>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
         {
            ++igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd;
 82276a4:	008209b4 	movhi	r2,2086
 82276a8:	10b82804 	addi	r2,r2,-8032
 82276ac:	10801117 	ldw	r2,68(r2)
 82276b0:	10c00044 	addi	r3,r2,1
 82276b4:	008209b4 	movhi	r2,2086
 82276b8:	10b82804 	addi	r2,r2,-8032
 82276bc:	10c01115 	stw	r3,68(r2)
            /* caller will free received packet */
            return ENP_BAD_HEADER;
 82276c0:	00bff804 	movi	r2,-32
 82276c4:	00003306 	br	8227794 <igmp_validate+0x304>
   
   /* check to ensure that a received IGMPv1 or v2 Report has the 
    * same IP host group address in its IP destination field and 
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
 82276c8:	e0bffc03 	ldbu	r2,-16(fp)
 82276cc:	108004a0 	cmpeqi	r2,r2,18
 82276d0:	1000031e 	bne	r2,zero,82276e0 <igmp_validate+0x250>
 82276d4:	e0bffc03 	ldbu	r2,-16(fp)
 82276d8:	10800598 	cmpnei	r2,r2,22
 82276dc:	1000121e 	bne	r2,zero,8227728 <igmp_validate+0x298>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 82276e0:	e0bffa17 	ldw	r2,-24(fp)
 82276e4:	10c00117 	ldw	r3,4(r2)
 82276e8:	e0bff817 	ldw	r2,-32(fp)
 82276ec:	10800417 	ldw	r2,16(r2)
 82276f0:	1880041e 	bne	r3,r2,8227704 <igmp_validate+0x274>
          (!IN_MULTICAST(mcgrp_addr)))
 82276f4:	e0bffd17 	ldw	r2,-12(fp)
 82276f8:	10fc002c 	andhi	r3,r2,61440
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 82276fc:	00b80034 	movhi	r2,57344
 8227700:	18800926 	beq	r3,r2,8227728 <igmp_validate+0x298>
          (!IN_MULTICAST(mcgrp_addr)))
      {
         ++igmpstats.igmp_bad_reports_rcvd;
 8227704:	008209b4 	movhi	r2,2086
 8227708:	10b82804 	addi	r2,r2,-8032
 822770c:	10800f17 	ldw	r2,60(r2)
 8227710:	10c00044 	addi	r3,r2,1
 8227714:	008209b4 	movhi	r2,2086
 8227718:	10b82804 	addi	r2,r2,-8032
 822771c:	10c00f15 	stw	r3,60(r2)
         return ENP_BAD_HEADER;    
 8227720:	00bff804 	movi	r2,-32
 8227724:	00001b06 	br	8227794 <igmp_validate+0x304>

    * Version 1 Host Membership Reports and Version 1 Host Membership Query
    * packets will not be checked for the IP Router Alert option.
    */
#ifdef IGMP_V2    
   if ((type == IGMPv2_LEAVE_GROUP) || 
 8227728:	e0bffc03 	ldbu	r2,-16(fp)
 822772c:	108005e0 	cmpeqi	r2,r2,23
 8227730:	10000a1e 	bne	r2,zero,822775c <igmp_validate+0x2cc>
 8227734:	e0bffc03 	ldbu	r2,-16(fp)
 8227738:	108005a0 	cmpeqi	r2,r2,22
 822773c:	1000071e 	bne	r2,zero,822775c <igmp_validate+0x2cc>
       (type == IGMPv2_MEMBERSHIP_REPORT) ||
 8227740:	e0bffc03 	ldbu	r2,-16(fp)
 8227744:	10800458 	cmpnei	r2,r2,17
 8227748:	1000111e 	bne	r2,zero,8227790 <igmp_validate+0x300>
       ((type == IGMP_HOST_MEMBERSHIP_QUERY) && (igmp->igmp_code > 0)))
 822774c:	e0bffa17 	ldw	r2,-24(fp)
 8227750:	10800043 	ldbu	r2,1(r2)
 8227754:	10803fcc 	andi	r2,r2,255
 8227758:	10000d26 	beq	r2,zero,8227790 <igmp_validate+0x300>
       
   {
      if (!igmpv2_chk4_rtr_alert_opt (pip))
 822775c:	e13ff817 	ldw	r4,-32(fp)
 8227760:	8245b880 	call	8245b88 <igmpv2_chk4_rtr_alert_opt>
 8227764:	10803fcc 	andi	r2,r2,255
 8227768:	1000091e 	bne	r2,zero,8227790 <igmp_validate+0x300>
      { 
         ++igmpstats.igmpv2mode_v2_rtr_alert_missing;
 822776c:	008209b4 	movhi	r2,2086
 8227770:	10b82804 	addi	r2,r2,-8032
 8227774:	10801417 	ldw	r2,80(r2)
 8227778:	10c00044 	addi	r3,r2,1
 822777c:	008209b4 	movhi	r2,2086
 8227780:	10b82804 	addi	r2,r2,-8032
 8227784:	10c01415 	stw	r3,80(r2)
         return ENP_BAD_HEADER;
 8227788:	00bff804 	movi	r2,-32
 822778c:	00000106 	br	8227794 <igmp_validate+0x304>
      }
   }
#endif   

   /* validation successful */
   return IGMP_OK;
 8227790:	0005883a 	mov	r2,zero
}
 8227794:	e037883a 	mov	sp,fp
 8227798:	dfc00117 	ldw	ra,4(sp)
 822779c:	df000017 	ldw	fp,0(sp)
 82277a0:	dec00204 	addi	sp,sp,8
 82277a4:	f800283a 	ret

082277a8 <igmp_print_stats>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */
   
int igmp_print_stats (void * pio)
{  
 82277a8:	defffa04 	addi	sp,sp,-24
 82277ac:	dfc00515 	stw	ra,20(sp)
 82277b0:	df000415 	stw	fp,16(sp)
 82277b4:	df000404 	addi	fp,sp,16
 82277b8:	e13fff15 	stw	r4,-4(fp)
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 82277bc:	008209b4 	movhi	r2,2086
 82277c0:	10ba6504 	addi	r2,r2,-5740
 82277c4:	10800017 	ldw	r2,0(r2)
 82277c8:	e0bffe15 	stw	r2,-8(fp)
 82277cc:	00003b06 	br	82278bc <igmp_print_stats+0x114>
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
                 ifp->name, 
 82277d0:	e0bffe17 	ldw	r2,-8(fp)
 82277d4:	10c00104 	addi	r3,r2,4
                 ifp->igmp_oper_mode, 
 82277d8:	e0bffe17 	ldw	r2,-8(fp)
 82277dc:	10802f03 	ldbu	r2,188(r2)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 82277e0:	11003fcc 	andi	r4,r2,255
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
 82277e4:	e0bffe17 	ldw	r2,-8(fp)
 82277e8:	10802f03 	ldbu	r2,188(r2)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 82277ec:	10803fcc 	andi	r2,r2,255
 82277f0:	10800058 	cmpnei	r2,r2,1
 82277f4:	1000031e 	bne	r2,zero,8227804 <igmp_print_stats+0x5c>
 82277f8:	00820974 	movhi	r2,2085
 82277fc:	10802a04 	addi	r2,r2,168
 8227800:	00000206 	br	822780c <igmp_print_stats+0x64>
 8227804:	00820974 	movhi	r2,2085
 8227808:	10802b04 	addi	r2,r2,172
 822780c:	d8800015 	stw	r2,0(sp)
 8227810:	200f883a 	mov	r7,r4
 8227814:	180d883a 	mov	r6,r3
 8227818:	01420974 	movhi	r5,2085
 822781c:	29402c04 	addi	r5,r5,176
 8227820:	e13fff17 	ldw	r4,-4(fp)
 8227824:	8228d040 	call	8228d04 <ns_printf>
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 8227828:	e0bffe17 	ldw	r2,-8(fp)
 822782c:	10802f03 	ldbu	r2,188(r2)
 8227830:	10803fcc 	andi	r2,r2,255
 8227834:	10800098 	cmpnei	r2,r2,2
 8227838:	1000191e 	bne	r2,zero,82278a0 <igmp_print_stats+0xf8>
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
                    ifp->igmpv1_rtr_present,
 822783c:	e0bffe17 	ldw	r2,-8(fp)
 8227840:	10802d03 	ldbu	r2,180(r2)
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 8227844:	11403fcc 	andi	r5,r2,255
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
 8227848:	e0bffe17 	ldw	r2,-8(fp)
 822784c:	10802d03 	ldbu	r2,180(r2)
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 8227850:	10803fcc 	andi	r2,r2,255
 8227854:	10800058 	cmpnei	r2,r2,1
 8227858:	1000031e 	bne	r2,zero,8227868 <igmp_print_stats+0xc0>
 822785c:	00820974 	movhi	r2,2085
 8227860:	10803104 	addi	r2,r2,196
 8227864:	00000206 	br	8227870 <igmp_print_stats+0xc8>
 8227868:	00820974 	movhi	r2,2085
 822786c:	10803304 	addi	r2,r2,204
 8227870:	e0fffe17 	ldw	r3,-8(fp)
 8227874:	18c02e17 	ldw	r3,184(r3)
 8227878:	d120a817 	ldw	r4,-32096(gp)
 822787c:	d9000115 	stw	r4,4(sp)
 8227880:	d8c00015 	stw	r3,0(sp)
 8227884:	100f883a 	mov	r7,r2
 8227888:	280d883a 	mov	r6,r5
 822788c:	01420974 	movhi	r5,2085
 8227890:	29403504 	addi	r5,r5,212
 8227894:	e13fff17 	ldw	r4,-4(fp)
 8227898:	8228d040 	call	8228d04 <ns_printf>
 822789c:	00000406 	br	82278b0 <igmp_print_stats+0x108>
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
                    ifp->igmpv1_query_rcvd_time,
                    cticks);
      }
      else ns_printf (pio, "\n");
 82278a0:	01420974 	movhi	r5,2085
 82278a4:	29404004 	addi	r5,r5,256
 82278a8:	e13fff17 	ldw	r4,-4(fp)
 82278ac:	8228d040 	call	8228d04 <ns_printf>
   
int igmp_print_stats (void * pio)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 82278b0:	e0bffe17 	ldw	r2,-8(fp)
 82278b4:	10800017 	ldw	r2,0(r2)
 82278b8:	e0bffe15 	stw	r2,-8(fp)
 82278bc:	e0bffe17 	ldw	r2,-8(fp)
 82278c0:	103fc31e 	bne	r2,zero,82277d0 <igmp_print_stats+0x28>
      }
      else ns_printf (pio, "\n");
   }   

   /* rx and timer statistics */
   ns_printf (pio, "[Rx ] IGMP messages rcvd: %lu, timers running: %lu\n", igmpstats.igmp_total_rcvd, igmp_timers_are_running);
 82278c4:	008209b4 	movhi	r2,2086
 82278c8:	10b82804 	addi	r2,r2,-8032
 82278cc:	10800017 	ldw	r2,0(r2)
 82278d0:	d0e08617 	ldw	r3,-32232(gp)
 82278d4:	180f883a 	mov	r7,r3
 82278d8:	100d883a 	mov	r6,r2
 82278dc:	01420974 	movhi	r5,2085
 82278e0:	29404104 	addi	r5,r5,260
 82278e4:	e13fff17 	ldw	r4,-4(fp)
 82278e8:	8228d040 	call	8228d04 <ns_printf>
   
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v1-mode links): %lu\n", igmpstats.igmpv1mode_v1_queries_rcvd);
 82278ec:	008209b4 	movhi	r2,2086
 82278f0:	10b82804 	addi	r2,r2,-8032
 82278f4:	10800117 	ldw	r2,4(r2)
 82278f8:	100d883a 	mov	r6,r2
 82278fc:	01420974 	movhi	r5,2085
 8227900:	29404e04 	addi	r5,r5,312
 8227904:	e13fff17 	ldw	r4,-4(fp)
 8227908:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Reports rcvd: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd);
 822790c:	008209b4 	movhi	r2,2086
 8227910:	10b82804 	addi	r2,r2,-8032
 8227914:	10800217 	ldw	r2,8(r2)
 8227918:	100d883a 	mov	r6,r2
 822791c:	01420974 	movhi	r5,2085
 8227920:	29405f04 	addi	r5,r5,380
 8227924:	e13fff17 	ldw	r4,-4(fp)
 8227928:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer);
 822792c:	008209b4 	movhi	r2,2086
 8227930:	10b82804 	addi	r2,r2,-8032
 8227934:	10800317 	ldw	r2,12(r2)
 8227938:	100d883a 	mov	r6,r2
 822793c:	01420974 	movhi	r5,2085
 8227940:	29406b04 	addi	r5,r5,428
 8227944:	e13fff17 	ldw	r4,-4(fp)
 8227948:	8228d040 	call	8228d04 <ns_printf>
      
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v2-mode links): %lu\n", igmpstats.igmpv2mode_v1_queries_rcvd);
 822794c:	008209b4 	movhi	r2,2086
 8227950:	10b82804 	addi	r2,r2,-8032
 8227954:	10800417 	ldw	r2,16(r2)
 8227958:	100d883a 	mov	r6,r2
 822795c:	01420974 	movhi	r5,2085
 8227960:	29407e04 	addi	r5,r5,504
 8227964:	e13fff17 	ldw	r4,-4(fp)
 8227968:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 General Queries rcvd: %lu, Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_general_queries_rcvd, igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd);
 822796c:	008209b4 	movhi	r2,2086
 8227970:	10b82804 	addi	r2,r2,-8032
 8227974:	10c00517 	ldw	r3,20(r2)
 8227978:	008209b4 	movhi	r2,2086
 822797c:	10b82804 	addi	r2,r2,-8032
 8227980:	10800617 	ldw	r2,24(r2)
 8227984:	100f883a 	mov	r7,r2
 8227988:	180d883a 	mov	r6,r3
 822798c:	01420974 	movhi	r5,2085
 8227990:	29408f04 	addi	r5,r5,572
 8227994:	e13fff17 	ldw	r4,-4(fp)
 8227998:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer);   
 822799c:	008209b4 	movhi	r2,2086
 82279a0:	10b82804 	addi	r2,r2,-8032
 82279a4:	10800717 	ldw	r2,28(r2)
 82279a8:	100d883a 	mov	r6,r2
 82279ac:	01420974 	movhi	r5,2085
 82279b0:	29406b04 	addi	r5,r5,428
 82279b4:	e13fff17 	ldw	r4,-4(fp)
 82279b8:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd with no local timer: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_no_timer);
 82279bc:	008209b4 	movhi	r2,2086
 82279c0:	10b82804 	addi	r2,r2,-8032
 82279c4:	10800817 	ldw	r2,32(r2)
 82279c8:	100d883a 	mov	r6,r2
 82279cc:	01420974 	movhi	r5,2085
 82279d0:	2940a204 	addi	r5,r5,648
 82279d4:	e13fff17 	ldw	r4,-4(fp)
 82279d8:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 Leave Group messages rcvd: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_rcvd);
 82279dc:	008209b4 	movhi	r2,2086
 82279e0:	10b82804 	addi	r2,r2,-8032
 82279e4:	10800917 	ldw	r2,36(r2)
 82279e8:	100d883a 	mov	r6,r2
 82279ec:	01420974 	movhi	r5,2085
 82279f0:	2940b304 	addi	r5,r5,716
 82279f4:	e13fff17 	ldw	r4,-4(fp)
 82279f8:	8228d040 	call	8228d04 <ns_printf>
   
   /* tx statistics */
   ns_printf (pio, "[Tx ] IGMPv2 Leave Group messages sent: %lu, Membership Reports sent: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_sent, igmpstats.igmpv2mode_v2_reports_sent);
 82279fc:	008209b4 	movhi	r2,2086
 8227a00:	10b82804 	addi	r2,r2,-8032
 8227a04:	10c01717 	ldw	r3,92(r2)
 8227a08:	008209b4 	movhi	r2,2086
 8227a0c:	10b82804 	addi	r2,r2,-8032
 8227a10:	10801817 	ldw	r2,96(r2)
 8227a14:	100f883a 	mov	r7,r2
 8227a18:	180d883a 	mov	r6,r3
 8227a1c:	01420974 	movhi	r5,2085
 8227a20:	2940bf04 	addi	r5,r5,764
 8227a24:	e13fff17 	ldw	r4,-4(fp)
 8227a28:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Tx ] IGMPv1 Host Membership Reports sent: %lu\n", igmpstats.igmp_v1_reports_sent);
 8227a2c:	008209b4 	movhi	r2,2086
 8227a30:	10b82804 	addi	r2,r2,-8032
 8227a34:	10801617 	ldw	r2,88(r2)
 8227a38:	100d883a 	mov	r6,r2
 8227a3c:	01420974 	movhi	r5,2085
 8227a40:	2940d204 	addi	r5,r5,840
 8227a44:	e13fff17 	ldw	r4,-4(fp)
 8227a48:	8228d040 	call	8228d04 <ns_printf>

   /* error statistics */
   ns_printf (pio, "[Err] IGMP packets rcvd with bad length: %lu\n", igmpstats.igmp_badlen_rcvd);
 8227a4c:	008209b4 	movhi	r2,2086
 8227a50:	10b82804 	addi	r2,r2,-8032
 8227a54:	10800a17 	ldw	r2,40(r2)
 8227a58:	100d883a 	mov	r6,r2
 8227a5c:	01420974 	movhi	r5,2085
 8227a60:	2940de04 	addi	r5,r5,888
 8227a64:	e13fff17 	ldw	r4,-4(fp)
 8227a68:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets rcvd with bad checksum: %lu\n", igmpstats.igmp_badsum_rcvd);
 8227a6c:	008209b4 	movhi	r2,2086
 8227a70:	10b82804 	addi	r2,r2,-8032
 8227a74:	10800b17 	ldw	r2,44(r2)
 8227a78:	100d883a 	mov	r6,r2
 8227a7c:	01420974 	movhi	r5,2085
 8227a80:	2940ea04 	addi	r5,r5,936
 8227a84:	e13fff17 	ldw	r4,-4(fp)
 8227a88:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Err] Packet buffer allocation failures: %lu, Bad IGMP Oper Mode config: %lu\n",igmpstats.igmp_pkt_alloc_fail, igmpstats.igmp_bad_oper_mode);
 8227a8c:	008209b4 	movhi	r2,2086
 8227a90:	10b82804 	addi	r2,r2,-8032
 8227a94:	10c00c17 	ldw	r3,48(r2)
 8227a98:	008209b4 	movhi	r2,2086
 8227a9c:	10b82804 	addi	r2,r2,-8032
 8227aa0:	10800d17 	ldw	r2,52(r2)
 8227aa4:	100f883a 	mov	r7,r2
 8227aa8:	180d883a 	mov	r6,r3
 8227aac:	01420974 	movhi	r5,2085
 8227ab0:	2940f604 	addi	r5,r5,984
 8227ab4:	e13fff17 	ldw	r4,-4(fp)
 8227ab8:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMP Queries rcvd: %lu, Bad IGMP Reports rcvd: %lu\n", igmpstats.igmp_bad_queries_rcvd, igmpstats.igmp_bad_reports_rcvd); 
 8227abc:	008209b4 	movhi	r2,2086
 8227ac0:	10b82804 	addi	r2,r2,-8032
 8227ac4:	10c00e17 	ldw	r3,56(r2)
 8227ac8:	008209b4 	movhi	r2,2086
 8227acc:	10b82804 	addi	r2,r2,-8032
 8227ad0:	10800f17 	ldw	r2,60(r2)
 8227ad4:	100f883a 	mov	r7,r2
 8227ad8:	180d883a 	mov	r6,r3
 8227adc:	01420974 	movhi	r5,2085
 8227ae0:	29410a04 	addi	r5,r5,1064
 8227ae4:	e13fff17 	ldw	r4,-4(fp)
 8227ae8:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMPv2 Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd);
 8227aec:	008209b4 	movhi	r2,2086
 8227af0:	10b82804 	addi	r2,r2,-8032
 8227af4:	10801117 	ldw	r2,68(r2)
 8227af8:	100d883a 	mov	r6,r2
 8227afc:	01420974 	movhi	r5,2085
 8227b00:	29411a04 	addi	r5,r5,1128
 8227b04:	e13fff17 	ldw	r4,-4(fp)
 8227b08:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Err] IGMPv2 Group-Specific Queries rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd);
 8227b0c:	008209b4 	movhi	r2,2086
 8227b10:	10b82804 	addi	r2,r2,-8032
 8227b14:	10801217 	ldw	r2,72(r2)
 8227b18:	100d883a 	mov	r6,r2
 8227b1c:	01420974 	movhi	r5,2085
 8227b20:	29412704 	addi	r5,r5,1180
 8227b24:	e13fff17 	ldw	r4,-4(fp)
 8227b28:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Err] IGMP Membership Reports rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd);
 8227b2c:	008209b4 	movhi	r2,2086
 8227b30:	10b82804 	addi	r2,r2,-8032
 8227b34:	10801317 	ldw	r2,76(r2)
 8227b38:	100d883a 	mov	r6,r2
 8227b3c:	01420974 	movhi	r5,2085
 8227b40:	29413a04 	addi	r5,r5,1256
 8227b44:	e13fff17 	ldw	r4,-4(fp)
 8227b48:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Err] Number of IGMPv2 messages rcvd without Router Alert option: %lu\n", igmpstats.igmpv2mode_v2_rtr_alert_missing); 
 8227b4c:	008209b4 	movhi	r2,2086
 8227b50:	10b82804 	addi	r2,r2,-8032
 8227b54:	10801417 	ldw	r2,80(r2)
 8227b58:	100d883a 	mov	r6,r2
 8227b5c:	01420974 	movhi	r5,2085
 8227b60:	29414b04 	addi	r5,r5,1324
 8227b64:	e13fff17 	ldw	r4,-4(fp)
 8227b68:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v1-mode links: %lu\n", igmpstats.igmpv1mode_unknown_pkttype);
 8227b6c:	008209b4 	movhi	r2,2086
 8227b70:	10b82804 	addi	r2,r2,-8032
 8227b74:	10801017 	ldw	r2,64(r2)
 8227b78:	100d883a 	mov	r6,r2
 8227b7c:	01420974 	movhi	r5,2085
 8227b80:	29415d04 	addi	r5,r5,1396
 8227b84:	e13fff17 	ldw	r4,-4(fp)
 8227b88:	8228d040 	call	8228d04 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v2-mode links: %lu\n", igmpstats.igmpv2mode_unknown_pkttype);
 8227b8c:	008209b4 	movhi	r2,2086
 8227b90:	10b82804 	addi	r2,r2,-8032
 8227b94:	10801517 	ldw	r2,84(r2)
 8227b98:	100d883a 	mov	r6,r2
 8227b9c:	01420974 	movhi	r5,2085
 8227ba0:	29416d04 	addi	r5,r5,1460
 8227ba4:	e13fff17 	ldw	r4,-4(fp)
 8227ba8:	8228d040 	call	8228d04 <ns_printf>
   
   return IGMP_OK;
 8227bac:	0005883a 	mov	r2,zero
}
 8227bb0:	e037883a 	mov	sp,fp
 8227bb4:	dfc00117 	ldw	ra,4(sp)
 8227bb8:	df000017 	ldw	fp,0(sp)
 8227bbc:	dec00204 	addi	sp,sp,8
 8227bc0:	f800283a 	ret

08227bc4 <bsd_accept>:
 *          The error is available via bsd_errno(s).
 */
BSD_SOCKET
bsd_accept(BSD_SOCKET s,
           struct sockaddr * addr, int * addrlen)
{
 8227bc4:	defff404 	addi	sp,sp,-48
 8227bc8:	dfc00b15 	stw	ra,44(sp)
 8227bcc:	df000a15 	stw	fp,40(sp)
 8227bd0:	df000a04 	addi	fp,sp,40
 8227bd4:	e13ffd15 	stw	r4,-12(fp)
 8227bd8:	e17ffe15 	stw	r5,-8(fp)
 8227bdc:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr laddr;
   long lret;

   so = LONG2SO(s);
 8227be0:	e0bffd17 	ldw	r2,-12(fp)
 8227be4:	10bff804 	addi	r2,r2,-32
 8227be8:	1085883a 	add	r2,r2,r2
 8227bec:	1085883a 	add	r2,r2,r2
 8227bf0:	e0bff715 	stw	r2,-36(fp)
   SOC_CHECK(so);
 8227bf4:	008209b4 	movhi	r2,2086
 8227bf8:	10b96104 	addi	r2,r2,-6780
 8227bfc:	e0bff615 	stw	r2,-40(fp)
 8227c00:	00000606 	br	8227c1c <bsd_accept+0x58>
 8227c04:	e0fff617 	ldw	r3,-40(fp)
 8227c08:	e0bff717 	ldw	r2,-36(fp)
 8227c0c:	18800626 	beq	r3,r2,8227c28 <bsd_accept+0x64>
 8227c10:	e0bff617 	ldw	r2,-40(fp)
 8227c14:	10800017 	ldw	r2,0(r2)
 8227c18:	e0bff615 	stw	r2,-40(fp)
 8227c1c:	e0bff617 	ldw	r2,-40(fp)
 8227c20:	103ff81e 	bne	r2,zero,8227c04 <bsd_accept+0x40>
 8227c24:	00000106 	br	8227c2c <bsd_accept+0x68>
 8227c28:	0001883a 	nop
 8227c2c:	e0fff617 	ldw	r3,-40(fp)
 8227c30:	e0bff717 	ldw	r2,-36(fp)
 8227c34:	18800326 	beq	r3,r2,8227c44 <bsd_accept+0x80>
 8227c38:	822d4140 	call	822d414 <dtrap>
 8227c3c:	00bfffc4 	movi	r2,-1
 8227c40:	00002406 	br	8227cd4 <bsd_accept+0x110>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (addr != NULL)
 8227c44:	e0bffe17 	ldw	r2,-8(fp)
 8227c48:	10000726 	beq	r2,zero,8227c68 <bsd_accept+0xa4>
   {
      if (addrlen == 0)
 8227c4c:	e0bfff17 	ldw	r2,-4(fp)
 8227c50:	1000051e 	bne	r2,zero,8227c68 <bsd_accept+0xa4>
      {
         so->so_error = EFAULT;
 8227c54:	e0bff717 	ldw	r2,-36(fp)
 8227c58:	00c00384 	movi	r3,14
 8227c5c:	10c00615 	stw	r3,24(r2)
         return -1;
 8227c60:	00bfffc4 	movi	r2,-1
 8227c64:	00001b06 	br	8227cd4 <bsd_accept+0x110>
      }
   }

   lret = t_accept(s, &laddr, addrlen);
 8227c68:	e0bff904 	addi	r2,fp,-28
 8227c6c:	e1bfff17 	ldw	r6,-4(fp)
 8227c70:	100b883a 	mov	r5,r2
 8227c74:	e13ffd17 	ldw	r4,-12(fp)
 8227c78:	823056c0 	call	823056c <t_accept>
 8227c7c:	e0bff815 	stw	r2,-32(fp)
    * address: copy the peer's address back into the buffer, but limit
    * the copy to the lesser of the buffer's length and sizeof(struct
    * sockaddr_in), which is all that t_accept() can return as a peer
    * address.  
    */
   if ((lret != -1) && (addr != NULL))
 8227c80:	e0bff817 	ldw	r2,-32(fp)
 8227c84:	10bfffe0 	cmpeqi	r2,r2,-1
 8227c88:	1000111e 	bne	r2,zero,8227cd0 <bsd_accept+0x10c>
 8227c8c:	e0bffe17 	ldw	r2,-8(fp)
 8227c90:	10000f26 	beq	r2,zero,8227cd0 <bsd_accept+0x10c>
   {
      if (*addrlen > sizeof(struct sockaddr_in))
 8227c94:	e0bfff17 	ldw	r2,-4(fp)
 8227c98:	10800017 	ldw	r2,0(r2)
 8227c9c:	10800470 	cmpltui	r2,r2,17
 8227ca0:	1000031e 	bne	r2,zero,8227cb0 <bsd_accept+0xec>
         *addrlen = sizeof(struct sockaddr_in);
 8227ca4:	e0bfff17 	ldw	r2,-4(fp)
 8227ca8:	00c00404 	movi	r3,16
 8227cac:	10c00015 	stw	r3,0(r2)
      MEMCPY(addr, &laddr, *addrlen);
 8227cb0:	e0bfff17 	ldw	r2,-4(fp)
 8227cb4:	10800017 	ldw	r2,0(r2)
 8227cb8:	1007883a 	mov	r3,r2
 8227cbc:	e0bff904 	addi	r2,fp,-28
 8227cc0:	180d883a 	mov	r6,r3
 8227cc4:	100b883a 	mov	r5,r2
 8227cc8:	e13ffe17 	ldw	r4,-8(fp)
 8227ccc:	8202e8c0 	call	8202e8c <memcpy>
   }

   return lret;
 8227cd0:	e0bff817 	ldw	r2,-32(fp)
}
 8227cd4:	e037883a 	mov	sp,fp
 8227cd8:	dfc00117 	ldw	ra,4(sp)
 8227cdc:	df000017 	ldw	fp,0(sp)
 8227ce0:	dec00204 	addi	sp,sp,8
 8227ce4:	f800283a 	ret

08227ce8 <bsd_getpeername>:
 *          available via bsd_errno(s).
 */
int
bsd_getpeername(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 8227ce8:	defff304 	addi	sp,sp,-52
 8227cec:	dfc00c15 	stw	ra,48(sp)
 8227cf0:	df000b15 	stw	fp,44(sp)
 8227cf4:	df000b04 	addi	fp,sp,44
 8227cf8:	e13ffd15 	stw	r4,-12(fp)
 8227cfc:	e17ffe15 	stw	r5,-8(fp)
 8227d00:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 8227d04:	e0bffd17 	ldw	r2,-12(fp)
 8227d08:	10bff804 	addi	r2,r2,-32
 8227d0c:	1085883a 	add	r2,r2,r2
 8227d10:	1085883a 	add	r2,r2,r2
 8227d14:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 8227d18:	008209b4 	movhi	r2,2086
 8227d1c:	10b96104 	addi	r2,r2,-6780
 8227d20:	e0bff515 	stw	r2,-44(fp)
 8227d24:	00000606 	br	8227d40 <bsd_getpeername+0x58>
 8227d28:	e0fff517 	ldw	r3,-44(fp)
 8227d2c:	e0bff617 	ldw	r2,-40(fp)
 8227d30:	18800626 	beq	r3,r2,8227d4c <bsd_getpeername+0x64>
 8227d34:	e0bff517 	ldw	r2,-44(fp)
 8227d38:	10800017 	ldw	r2,0(r2)
 8227d3c:	e0bff515 	stw	r2,-44(fp)
 8227d40:	e0bff517 	ldw	r2,-44(fp)
 8227d44:	103ff81e 	bne	r2,zero,8227d28 <bsd_getpeername+0x40>
 8227d48:	00000106 	br	8227d50 <bsd_getpeername+0x68>
 8227d4c:	0001883a 	nop
 8227d50:	e0fff517 	ldw	r3,-44(fp)
 8227d54:	e0bff617 	ldw	r2,-40(fp)
 8227d58:	18800326 	beq	r3,r2,8227d68 <bsd_getpeername+0x80>
 8227d5c:	822d4140 	call	822d414 <dtrap>
 8227d60:	00bfffc4 	movi	r2,-1
 8227d64:	00002406 	br	8227df8 <bsd_getpeername+0x110>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 8227d68:	e0bfff17 	ldw	r2,-4(fp)
 8227d6c:	1000051e 	bne	r2,zero,8227d84 <bsd_getpeername+0x9c>
   {
      so->so_error = EFAULT;
 8227d70:	e0bff617 	ldw	r2,-40(fp)
 8227d74:	00c00384 	movi	r3,14
 8227d78:	10c00615 	stw	r3,24(r2)
      return -1;
 8227d7c:	00bfffc4 	movi	r2,-1
 8227d80:	00001d06 	br	8227df8 <bsd_getpeername+0x110>
   }
   lnamelen = *namelen;
 8227d84:	e0bfff17 	ldw	r2,-4(fp)
 8227d88:	10800017 	ldw	r2,0(r2)
 8227d8c:	e0bffc15 	stw	r2,-16(fp)

   lret = t_getpeername(s, &lname, &lnamelen);
 8227d90:	e0fffc04 	addi	r3,fp,-16
 8227d94:	e0bff804 	addi	r2,fp,-32
 8227d98:	180d883a 	mov	r6,r3
 8227d9c:	100b883a 	mov	r5,r2
 8227da0:	e13ffd17 	ldw	r4,-12(fp)
 8227da4:	8230a2c0 	call	8230a2c <t_getpeername>
 8227da8:	e0bff715 	stw	r2,-36(fp)
    * t_getpeername() can return as a peer address, and pass the
    * copied length back to the caller.  
    * For IPV6 addresses, or for dual IPV4/IPV6 stack, 
    * the max size is sizeof(struct sockaddr_in6)
    */
   if (lret != -1)
 8227dac:	e0bff717 	ldw	r2,-36(fp)
 8227db0:	10bfffe0 	cmpeqi	r2,r2,-1
 8227db4:	10000f1e 	bne	r2,zero,8227df4 <bsd_getpeername+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 8227db8:	e0bffc17 	ldw	r2,-16(fp)
 8227dbc:	10800470 	cmpltui	r2,r2,17
 8227dc0:	1000021e 	bne	r2,zero,8227dcc <bsd_getpeername+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 8227dc4:	00800404 	movi	r2,16
 8227dc8:	e0bffc15 	stw	r2,-16(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(name, &lname, lnamelen);
 8227dcc:	e0bffc17 	ldw	r2,-16(fp)
 8227dd0:	1007883a 	mov	r3,r2
 8227dd4:	e0bff804 	addi	r2,fp,-32
 8227dd8:	180d883a 	mov	r6,r3
 8227ddc:	100b883a 	mov	r5,r2
 8227de0:	e13ffe17 	ldw	r4,-8(fp)
 8227de4:	8202e8c0 	call	8202e8c <memcpy>
      *namelen = lnamelen;
 8227de8:	e0fffc17 	ldw	r3,-16(fp)
 8227dec:	e0bfff17 	ldw	r2,-4(fp)
 8227df0:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 8227df4:	e0bff717 	ldw	r2,-36(fp)
}
 8227df8:	e037883a 	mov	sp,fp
 8227dfc:	dfc00117 	ldw	ra,4(sp)
 8227e00:	df000017 	ldw	fp,0(sp)
 8227e04:	dec00204 	addi	sp,sp,8
 8227e08:	f800283a 	ret

08227e0c <bsd_getsockname>:
 *          available via bsd_errno(s).
 */
int
bsd_getsockname(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 8227e0c:	defff304 	addi	sp,sp,-52
 8227e10:	dfc00c15 	stw	ra,48(sp)
 8227e14:	df000b15 	stw	fp,44(sp)
 8227e18:	df000b04 	addi	fp,sp,44
 8227e1c:	e13ffd15 	stw	r4,-12(fp)
 8227e20:	e17ffe15 	stw	r5,-8(fp)
 8227e24:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 8227e28:	e0bffd17 	ldw	r2,-12(fp)
 8227e2c:	10bff804 	addi	r2,r2,-32
 8227e30:	1085883a 	add	r2,r2,r2
 8227e34:	1085883a 	add	r2,r2,r2
 8227e38:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 8227e3c:	008209b4 	movhi	r2,2086
 8227e40:	10b96104 	addi	r2,r2,-6780
 8227e44:	e0bff515 	stw	r2,-44(fp)
 8227e48:	00000606 	br	8227e64 <bsd_getsockname+0x58>
 8227e4c:	e0fff517 	ldw	r3,-44(fp)
 8227e50:	e0bff617 	ldw	r2,-40(fp)
 8227e54:	18800626 	beq	r3,r2,8227e70 <bsd_getsockname+0x64>
 8227e58:	e0bff517 	ldw	r2,-44(fp)
 8227e5c:	10800017 	ldw	r2,0(r2)
 8227e60:	e0bff515 	stw	r2,-44(fp)
 8227e64:	e0bff517 	ldw	r2,-44(fp)
 8227e68:	103ff81e 	bne	r2,zero,8227e4c <bsd_getsockname+0x40>
 8227e6c:	00000106 	br	8227e74 <bsd_getsockname+0x68>
 8227e70:	0001883a 	nop
 8227e74:	e0fff517 	ldw	r3,-44(fp)
 8227e78:	e0bff617 	ldw	r2,-40(fp)
 8227e7c:	18800326 	beq	r3,r2,8227e8c <bsd_getsockname+0x80>
 8227e80:	822d4140 	call	822d414 <dtrap>
 8227e84:	00bfffc4 	movi	r2,-1
 8227e88:	00002406 	br	8227f1c <bsd_getsockname+0x110>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 8227e8c:	e0bfff17 	ldw	r2,-4(fp)
 8227e90:	1000051e 	bne	r2,zero,8227ea8 <bsd_getsockname+0x9c>
   {
      so->so_error = EFAULT;
 8227e94:	e0bff617 	ldw	r2,-40(fp)
 8227e98:	00c00384 	movi	r3,14
 8227e9c:	10c00615 	stw	r3,24(r2)
      return -1;
 8227ea0:	00bfffc4 	movi	r2,-1
 8227ea4:	00001d06 	br	8227f1c <bsd_getsockname+0x110>
   }
   lnamelen = *namelen;
 8227ea8:	e0bfff17 	ldw	r2,-4(fp)
 8227eac:	10800017 	ldw	r2,0(r2)
 8227eb0:	e0bffc15 	stw	r2,-16(fp)

   lret = t_getsockname(s, &lname, &lnamelen);
 8227eb4:	e0fffc04 	addi	r3,fp,-16
 8227eb8:	e0bff804 	addi	r2,fp,-32
 8227ebc:	180d883a 	mov	r6,r3
 8227ec0:	100b883a 	mov	r5,r2
 8227ec4:	e13ffd17 	ldw	r4,-12(fp)
 8227ec8:	8230a700 	call	8230a70 <t_getsockname>
 8227ecc:	e0bff715 	stw	r2,-36(fp)
    * copied length back to the caller.  
    * For IPV6 addresses, or for a dual IPV4/IPV6 stack, 
    * the max size copied is sizeof(struct sockaddr_in6)
    *
    */
   if (lret != -1)
 8227ed0:	e0bff717 	ldw	r2,-36(fp)
 8227ed4:	10bfffe0 	cmpeqi	r2,r2,-1
 8227ed8:	10000f1e 	bne	r2,zero,8227f18 <bsd_getsockname+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 8227edc:	e0bffc17 	ldw	r2,-16(fp)
 8227ee0:	10800470 	cmpltui	r2,r2,17
 8227ee4:	1000021e 	bne	r2,zero,8227ef0 <bsd_getsockname+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 8227ee8:	00800404 	movi	r2,16
 8227eec:	e0bffc15 	stw	r2,-16(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);
#endif
      MEMCPY(name, &lname, lnamelen);
 8227ef0:	e0bffc17 	ldw	r2,-16(fp)
 8227ef4:	1007883a 	mov	r3,r2
 8227ef8:	e0bff804 	addi	r2,fp,-32
 8227efc:	180d883a 	mov	r6,r3
 8227f00:	100b883a 	mov	r5,r2
 8227f04:	e13ffe17 	ldw	r4,-8(fp)
 8227f08:	8202e8c0 	call	8202e8c <memcpy>
      *namelen = lnamelen;
 8227f0c:	e0fffc17 	ldw	r3,-16(fp)
 8227f10:	e0bfff17 	ldw	r2,-4(fp)
 8227f14:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 8227f18:	e0bff717 	ldw	r2,-36(fp)
}
 8227f1c:	e037883a 	mov	sp,fp
 8227f20:	dfc00117 	ldw	ra,4(sp)
 8227f24:	df000017 	ldw	fp,0(sp)
 8227f28:	dec00204 	addi	sp,sp,8
 8227f2c:	f800283a 	ret

08227f30 <bsd_i_sockoptlen>:
 * RETURNS: minimum length of the named socket option, in bytes
 */
int 
bsd_i_sockoptlen(int level,
                 int name)
{
 8227f30:	defffd04 	addi	sp,sp,-12
 8227f34:	df000215 	stw	fp,8(sp)
 8227f38:	df000204 	addi	fp,sp,8
 8227f3c:	e13ffe15 	stw	r4,-8(fp)
 8227f40:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(level);

   switch (name)
 8227f44:	e0bfff17 	ldw	r2,-4(fp)
 8227f48:	10c02020 	cmpeqi	r3,r2,128
 8227f4c:	1800341e 	bne	r3,zero,8228020 <bsd_i_sockoptlen+0xf0>
 8227f50:	10c02048 	cmpgei	r3,r2,129
 8227f54:	18001a1e 	bne	r3,zero,8227fc0 <bsd_i_sockoptlen+0x90>
 8227f58:	10c00308 	cmpgei	r3,r2,12
 8227f5c:	18000e1e 	bne	r3,zero,8227f98 <bsd_i_sockoptlen+0x68>
 8227f60:	10c00288 	cmpgei	r3,r2,10
 8227f64:	1800361e 	bne	r3,zero,8228040 <bsd_i_sockoptlen+0x110>
 8227f68:	10c00120 	cmpeqi	r3,r2,4
 8227f6c:	1800301e 	bne	r3,zero,8228030 <bsd_i_sockoptlen+0x100>
 8227f70:	10c00148 	cmpgei	r3,r2,5
 8227f74:	1800031e 	bne	r3,zero,8227f84 <bsd_i_sockoptlen+0x54>
 8227f78:	108000e0 	cmpeqi	r2,r2,3
 8227f7c:	1000341e 	bne	r2,zero,8228050 <bsd_i_sockoptlen+0x120>
 8227f80:	00003506 	br	8228058 <bsd_i_sockoptlen+0x128>
 8227f84:	10c00220 	cmpeqi	r3,r2,8
 8227f88:	1800291e 	bne	r3,zero,8228030 <bsd_i_sockoptlen+0x100>
 8227f8c:	10800260 	cmpeqi	r2,r2,9
 8227f90:	1000291e 	bne	r2,zero,8228038 <bsd_i_sockoptlen+0x108>
 8227f94:	00003006 	br	8228058 <bsd_i_sockoptlen+0x128>
 8227f98:	10c00420 	cmpeqi	r3,r2,16
 8227f9c:	1800241e 	bne	r3,zero,8228030 <bsd_i_sockoptlen+0x100>
 8227fa0:	10c00448 	cmpgei	r3,r2,17
 8227fa4:	1800031e 	bne	r3,zero,8227fb4 <bsd_i_sockoptlen+0x84>
 8227fa8:	10800388 	cmpgei	r2,r2,14
 8227fac:	10002a1e 	bne	r2,zero,8228058 <bsd_i_sockoptlen+0x128>
 8227fb0:	00002506 	br	8228048 <bsd_i_sockoptlen+0x118>
 8227fb4:	10800820 	cmpeqi	r2,r2,32
 8227fb8:	10001d1e 	bne	r2,zero,8228030 <bsd_i_sockoptlen+0x100>
 8227fbc:	00002606 	br	8228058 <bsd_i_sockoptlen+0x128>
 8227fc0:	10c401c8 	cmpgei	r3,r2,4103
 8227fc4:	18000a1e 	bne	r3,zero,8227ff0 <bsd_i_sockoptlen+0xc0>
 8227fc8:	10c40148 	cmpgei	r3,r2,4101
 8227fcc:	1800161e 	bne	r3,zero,8228028 <bsd_i_sockoptlen+0xf8>
 8227fd0:	10c04020 	cmpeqi	r3,r2,256
 8227fd4:	1800161e 	bne	r3,zero,8228030 <bsd_i_sockoptlen+0x100>
 8227fd8:	10c04010 	cmplti	r3,r2,256
 8227fdc:	18001e1e 	bne	r3,zero,8228058 <bsd_i_sockoptlen+0x128>
 8227fe0:	10bbffc4 	addi	r2,r2,-4097
 8227fe4:	108000a8 	cmpgeui	r2,r2,2
 8227fe8:	10001b1e 	bne	r2,zero,8228058 <bsd_i_sockoptlen+0x128>
 8227fec:	00001006 	br	8228030 <bsd_i_sockoptlen+0x100>
 8227ff0:	10c40588 	cmpgei	r3,r2,4118
 8227ff4:	1800051e 	bne	r3,zero,822800c <bsd_i_sockoptlen+0xdc>
 8227ff8:	10c40508 	cmpgei	r3,r2,4116
 8227ffc:	1800061e 	bne	r3,zero,8228018 <bsd_i_sockoptlen+0xe8>
 8228000:	10840248 	cmpgei	r2,r2,4105
 8228004:	1000141e 	bne	r2,zero,8228058 <bsd_i_sockoptlen+0x128>
 8228008:	00000906 	br	8228030 <bsd_i_sockoptlen+0x100>
 822800c:	108405a0 	cmpeqi	r2,r2,4118
 8228010:	1000071e 	bne	r2,zero,8228030 <bsd_i_sockoptlen+0x100>
 8228014:	00001006 	br	8228058 <bsd_i_sockoptlen+0x128>
   {
   case SO_BIO:
   case SO_NBIO:
      /* these don't use an option value */
      return 0;
 8228018:	0005883a 	mov	r2,zero
 822801c:	00000f06 	br	822805c <bsd_i_sockoptlen+0x12c>
   case SO_LINGER:
      /* this option is a struct linger */
      return sizeof(struct linger);
 8228020:	00800204 	movi	r2,8
 8228024:	00000d06 	br	822805c <bsd_i_sockoptlen+0x12c>
   case SO_RCVTIMEO:
   case SO_SNDTIMEO:
      /* these options are type short */
      return sizeof(short);
 8228028:	00800084 	movi	r2,2
 822802c:	00000b06 	br	822805c <bsd_i_sockoptlen+0x12c>
   case SO_RCVBUF:
   case SO_NONBLOCK:
   case SO_ERROR:
   case SO_TYPE:
      /* these options are type int */
      return sizeof(int);
 8228030:	00800104 	movi	r2,4
 8228034:	00000906 	br	822805c <bsd_i_sockoptlen+0x12c>
      return sizeof(int (*)());
#endif /* TCP_ZEROCOPY */
#ifdef IP_MULTICAST
   case IP_MULTICAST_IF:
      /* this option is type ip_addr */
      return sizeof(ip_addr);
 8228038:	00800104 	movi	r2,4
 822803c:	00000706 	br	822805c <bsd_i_sockoptlen+0x12c>
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      /* these options are type u_char */
      return sizeof(u_char);
 8228040:	00800044 	movi	r2,1
 8228044:	00000506 	br	822805c <bsd_i_sockoptlen+0x12c>
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      /* these options are struct ip_mreq */
      return sizeof(struct ip_mreq);
 8228048:	00800204 	movi	r2,8
 822804c:	00000306 	br	822805c <bsd_i_sockoptlen+0x12c>
 * IP_TTL_OPT == SOREUSEADDR. This causes a build erro
 * due to duplicate cases. Removing this one. They both
 * return the same value (sizeof(int)).
 */
  // case IP_TTL_OPT:
      return sizeof(int);
 8228050:	00800104 	movi	r2,4
 8228054:	00000106 	br	822805c <bsd_i_sockoptlen+0x12c>
   default:
      /* we don't know what type these options are */
      return 0;
 8228058:	0005883a 	mov	r2,zero
   }
   
}
 822805c:	e037883a 	mov	sp,fp
 8228060:	df000017 	ldw	fp,0(sp)
 8228064:	dec00104 	addi	sp,sp,4
 8228068:	f800283a 	ret

0822806c <bsd_getsockopt>:
int
bsd_getsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int * optlen)
{
 822806c:	defff504 	addi	sp,sp,-44
 8228070:	dfc00a15 	stw	ra,40(sp)
 8228074:	df000915 	stw	fp,36(sp)
 8228078:	df000904 	addi	fp,sp,36
 822807c:	e13ffc15 	stw	r4,-16(fp)
 8228080:	e17ffd15 	stw	r5,-12(fp)
 8228084:	e1bffe15 	stw	r6,-8(fp)
 8228088:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;
   int loptlen;
   int e;

   so = LONG2SO(s);
 822808c:	e0bffc17 	ldw	r2,-16(fp)
 8228090:	10bff804 	addi	r2,r2,-32
 8228094:	1085883a 	add	r2,r2,r2
 8228098:	1085883a 	add	r2,r2,r2
 822809c:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 82280a0:	008209b4 	movhi	r2,2086
 82280a4:	10b96104 	addi	r2,r2,-6780
 82280a8:	e0bff815 	stw	r2,-32(fp)
 82280ac:	00000606 	br	82280c8 <bsd_getsockopt+0x5c>
 82280b0:	e0fff817 	ldw	r3,-32(fp)
 82280b4:	e0bff917 	ldw	r2,-28(fp)
 82280b8:	18800626 	beq	r3,r2,82280d4 <bsd_getsockopt+0x68>
 82280bc:	e0bff817 	ldw	r2,-32(fp)
 82280c0:	10800017 	ldw	r2,0(r2)
 82280c4:	e0bff815 	stw	r2,-32(fp)
 82280c8:	e0bff817 	ldw	r2,-32(fp)
 82280cc:	103ff81e 	bne	r2,zero,82280b0 <bsd_getsockopt+0x44>
 82280d0:	00000106 	br	82280d8 <bsd_getsockopt+0x6c>
 82280d4:	0001883a 	nop
 82280d8:	e0fff817 	ldw	r3,-32(fp)
 82280dc:	e0bff917 	ldw	r2,-28(fp)
 82280e0:	18800326 	beq	r3,r2,82280f0 <bsd_getsockopt+0x84>
 82280e4:	822d4140 	call	822d414 <dtrap>
 82280e8:	00bfffc4 	movi	r2,-1
 82280ec:	00001d06 	br	8228164 <bsd_getsockopt+0xf8>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   loptlen = bsd_i_sockoptlen(level, name);
 82280f0:	e17ffe17 	ldw	r5,-8(fp)
 82280f4:	e13ffd17 	ldw	r4,-12(fp)
 82280f8:	8227f300 	call	8227f30 <bsd_i_sockoptlen>
 82280fc:	e0bffa15 	stw	r2,-24(fp)
   if ((optlen == NULL) || (*optlen < loptlen))
 8228100:	e0800217 	ldw	r2,8(fp)
 8228104:	10000426 	beq	r2,zero,8228118 <bsd_getsockopt+0xac>
 8228108:	e0800217 	ldw	r2,8(fp)
 822810c:	10c00017 	ldw	r3,0(r2)
 8228110:	e0bffa17 	ldw	r2,-24(fp)
 8228114:	1880050e 	bge	r3,r2,822812c <bsd_getsockopt+0xc0>
   {
      so->so_error = EFAULT;
 8228118:	e0bff917 	ldw	r2,-28(fp)
 822811c:	00c00384 	movi	r3,14
 8228120:	10c00615 	stw	r3,24(r2)
      return -1;
 8228124:	00bfffc4 	movi	r2,-1
 8228128:	00000e06 	br	8228164 <bsd_getsockopt+0xf8>
   }

   e = t_getsockopt(s, level, name, opt, loptlen);
 822812c:	e0bffa17 	ldw	r2,-24(fp)
 8228130:	d8800015 	stw	r2,0(sp)
 8228134:	e1ffff17 	ldw	r7,-4(fp)
 8228138:	e1bffe17 	ldw	r6,-8(fp)
 822813c:	e17ffd17 	ldw	r5,-12(fp)
 8228140:	e13ffc17 	ldw	r4,-16(fp)
 8228144:	8230e500 	call	8230e50 <t_getsockopt>
 8228148:	e0bffb15 	stw	r2,-20(fp)

   /* if it worked, copy the option length back for the caller's use */
   if (e == 0)
 822814c:	e0bffb17 	ldw	r2,-20(fp)
 8228150:	1000031e 	bne	r2,zero,8228160 <bsd_getsockopt+0xf4>
   {
      *optlen = loptlen;
 8228154:	e0800217 	ldw	r2,8(fp)
 8228158:	e0fffa17 	ldw	r3,-24(fp)
 822815c:	10c00015 	stw	r3,0(r2)
   }

   return e;
 8228160:	e0bffb17 	ldw	r2,-20(fp)
   
}
 8228164:	e037883a 	mov	sp,fp
 8228168:	dfc00117 	ldw	ra,4(sp)
 822816c:	df000017 	ldw	fp,0(sp)
 8228170:	dec00204 	addi	sp,sp,8
 8228174:	f800283a 	ret

08228178 <bsd_ioctl>:
 *          available via bsd_errno(s).
 */
int
bsd_ioctl(BSD_SOCKET s, 
          unsigned long request, ...)
{
 8228178:	defff504 	addi	sp,sp,-44
 822817c:	dfc00815 	stw	ra,32(sp)
 8228180:	df000715 	stw	fp,28(sp)
 8228184:	df000704 	addi	fp,sp,28
 8228188:	e13ffe15 	stw	r4,-8(fp)
 822818c:	e17fff15 	stw	r5,-4(fp)
 8228190:	e1800215 	stw	r6,8(fp)
 8228194:	e1c00315 	stw	r7,12(fp)
   struct socket * so;
   va_list argptr;
   int iarg;

   so = LONG2SO(s);
 8228198:	e0bffe17 	ldw	r2,-8(fp)
 822819c:	10bff804 	addi	r2,r2,-32
 82281a0:	1085883a 	add	r2,r2,r2
 82281a4:	1085883a 	add	r2,r2,r2
 82281a8:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 82281ac:	008209b4 	movhi	r2,2086
 82281b0:	10b96104 	addi	r2,r2,-6780
 82281b4:	e0bffa15 	stw	r2,-24(fp)
 82281b8:	00000606 	br	82281d4 <bsd_ioctl+0x5c>
 82281bc:	e0fffa17 	ldw	r3,-24(fp)
 82281c0:	e0bffb17 	ldw	r2,-20(fp)
 82281c4:	18800626 	beq	r3,r2,82281e0 <bsd_ioctl+0x68>
 82281c8:	e0bffa17 	ldw	r2,-24(fp)
 82281cc:	10800017 	ldw	r2,0(r2)
 82281d0:	e0bffa15 	stw	r2,-24(fp)
 82281d4:	e0bffa17 	ldw	r2,-24(fp)
 82281d8:	103ff81e 	bne	r2,zero,82281bc <bsd_ioctl+0x44>
 82281dc:	00000106 	br	82281e4 <bsd_ioctl+0x6c>
 82281e0:	0001883a 	nop
 82281e4:	e0fffa17 	ldw	r3,-24(fp)
 82281e8:	e0bffb17 	ldw	r2,-20(fp)
 82281ec:	18800326 	beq	r3,r2,82281fc <bsd_ioctl+0x84>
 82281f0:	822d4140 	call	822d414 <dtrap>
 82281f4:	00bfffc4 	movi	r2,-1
 82281f8:	00001706 	br	8228258 <bsd_ioctl+0xe0>

   va_start(argptr, request);
 82281fc:	e0800204 	addi	r2,fp,8
 8228200:	e0bffc15 	stw	r2,-16(fp)

   switch (request)
 8228204:	e0bfff17 	ldw	r2,-4(fp)
 8228208:	108405a0 	cmpeqi	r2,r2,4118
 822820c:	10000e26 	beq	r2,zero,8228248 <bsd_ioctl+0xd0>
   {
   case FIONBIO:
      iarg = va_arg(argptr, int);
 8228210:	e0bffc17 	ldw	r2,-16(fp)
 8228214:	10c00104 	addi	r3,r2,4
 8228218:	e0fffc15 	stw	r3,-16(fp)
 822821c:	10800017 	ldw	r2,0(r2)
 8228220:	e0bffd15 	stw	r2,-12(fp)
      va_end(argptr);
      return t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &iarg, sizeof(iarg));
 8228224:	e0fffd04 	addi	r3,fp,-12
 8228228:	00800104 	movi	r2,4
 822822c:	d8800015 	stw	r2,0(sp)
 8228230:	180f883a 	mov	r7,r3
 8228234:	01840584 	movi	r6,4118
 8228238:	017fffc4 	movi	r5,-1
 822823c:	e13ffe17 	ldw	r4,-8(fp)
 8228240:	8230c900 	call	8230c90 <t_setsockopt>
 8228244:	00000406 	br	8228258 <bsd_ioctl+0xe0>
   default:
      so->so_error = EINVAL;
 8228248:	e0bffb17 	ldw	r2,-20(fp)
 822824c:	00c00584 	movi	r3,22
 8228250:	10c00615 	stw	r3,24(r2)
      return -1;
 8228254:	00bfffc4 	movi	r2,-1
   }
}
 8228258:	e037883a 	mov	sp,fp
 822825c:	dfc00117 	ldw	ra,4(sp)
 8228260:	df000017 	ldw	fp,0(sp)
 8228264:	dec00404 	addi	sp,sp,16
 8228268:	f800283a 	ret

0822826c <bsd_inet_ntoa>:
 * RETURNS: pointer to null-terminated string containing dotted-decimal
 *          printable representation of in
 */
char *
bsd_inet_ntoa(struct in_addr in)
{
 822826c:	defffd04 	addi	sp,sp,-12
 8228270:	dfc00215 	stw	ra,8(sp)
 8228274:	df000115 	stw	fp,4(sp)
 8228278:	df000104 	addi	fp,sp,4
 822827c:	e13fff15 	stw	r4,-4(fp)
   return print_ipad(in.s_addr);
 8228280:	e0bfff17 	ldw	r2,-4(fp)
 8228284:	1009883a 	mov	r4,r2
 8228288:	82289300 	call	8228930 <print_ipad>
}
 822828c:	e037883a 	mov	sp,fp
 8228290:	dfc00117 	ldw	ra,4(sp)
 8228294:	df000017 	ldw	fp,0(sp)
 8228298:	dec00204 	addi	sp,sp,8
 822829c:	f800283a 	ret

082282a0 <bsd_recvfrom>:
bsd_recvfrom(BSD_SOCKET s,
             void * buf,
             BSD_SIZE_T len,
             int flags,
             struct sockaddr * from, int * fromlen)
{
 82282a0:	defff004 	addi	sp,sp,-64
 82282a4:	dfc00f15 	stw	ra,60(sp)
 82282a8:	df000e15 	stw	fp,56(sp)
 82282ac:	df000e04 	addi	fp,sp,56
 82282b0:	e13ffc15 	stw	r4,-16(fp)
 82282b4:	e17ffd15 	stw	r5,-12(fp)
 82282b8:	e1bffe15 	stw	r6,-8(fp)
 82282bc:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;
   struct sockaddr lfrom;
   int lfromlen = 0;
 82282c0:	e03ffb15 	stw	zero,-20(fp)
   int lret;

   so = LONG2SO(s);
 82282c4:	e0bffc17 	ldw	r2,-16(fp)
 82282c8:	10bff804 	addi	r2,r2,-32
 82282cc:	1085883a 	add	r2,r2,r2
 82282d0:	1085883a 	add	r2,r2,r2
 82282d4:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 82282d8:	008209b4 	movhi	r2,2086
 82282dc:	10b96104 	addi	r2,r2,-6780
 82282e0:	e0bff415 	stw	r2,-48(fp)
 82282e4:	00000606 	br	8228300 <bsd_recvfrom+0x60>
 82282e8:	e0fff417 	ldw	r3,-48(fp)
 82282ec:	e0bff517 	ldw	r2,-44(fp)
 82282f0:	18800626 	beq	r3,r2,822830c <bsd_recvfrom+0x6c>
 82282f4:	e0bff417 	ldw	r2,-48(fp)
 82282f8:	10800017 	ldw	r2,0(r2)
 82282fc:	e0bff415 	stw	r2,-48(fp)
 8228300:	e0bff417 	ldw	r2,-48(fp)
 8228304:	103ff81e 	bne	r2,zero,82282e8 <bsd_recvfrom+0x48>
 8228308:	00000106 	br	8228310 <bsd_recvfrom+0x70>
 822830c:	0001883a 	nop
 8228310:	e0fff417 	ldw	r3,-48(fp)
 8228314:	e0bff517 	ldw	r2,-44(fp)
 8228318:	18800326 	beq	r3,r2,8228328 <bsd_recvfrom+0x88>
 822831c:	822d4140 	call	822d414 <dtrap>
 8228320:	00bfffc4 	movi	r2,-1
 8228324:	00002b06 	br	82283d4 <bsd_recvfrom+0x134>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (from != NULL)
 8228328:	e0800217 	ldw	r2,8(fp)
 822832c:	10000a26 	beq	r2,zero,8228358 <bsd_recvfrom+0xb8>
   {
      if (fromlen == NULL)
 8228330:	e0800317 	ldw	r2,12(fp)
 8228334:	1000051e 	bne	r2,zero,822834c <bsd_recvfrom+0xac>
      {
         so->so_error = EFAULT;
 8228338:	e0bff517 	ldw	r2,-44(fp)
 822833c:	00c00384 	movi	r3,14
 8228340:	10c00615 	stw	r3,24(r2)
         return -1;
 8228344:	00bfffc4 	movi	r2,-1
 8228348:	00002206 	br	82283d4 <bsd_recvfrom+0x134>
      }
      lfromlen = *fromlen;
 822834c:	e0800317 	ldw	r2,12(fp)
 8228350:	10800017 	ldw	r2,0(r2)
 8228354:	e0bffb15 	stw	r2,-20(fp)
   }

   lret = t_recvfrom(s, (char *)buf, len, flags, &lfrom, &lfromlen );
 8228358:	e0bffb04 	addi	r2,fp,-20
 822835c:	d8800115 	stw	r2,4(sp)
 8228360:	e0bff704 	addi	r2,fp,-36
 8228364:	d8800015 	stw	r2,0(sp)
 8228368:	e1ffff17 	ldw	r7,-4(fp)
 822836c:	e1bffe17 	ldw	r6,-8(fp)
 8228370:	e17ffd17 	ldw	r5,-12(fp)
 8228374:	e13ffc17 	ldw	r4,-16(fp)
 8228378:	82310bc0 	call	82310bc <t_recvfrom>
 822837c:	e0bff615 	stw	r2,-40(fp)
    * sockaddr_in), which is all that t_recvfrom() can return as a peer
    * name.
    * For IPV6 addresses or dual IPV4/IPV6 stack, the max size copied
    * is sizeof(struct sockaddr_in6)
    */
   if ((lret != -1) && (from != NULL))
 8228380:	e0bff617 	ldw	r2,-40(fp)
 8228384:	10bfffe0 	cmpeqi	r2,r2,-1
 8228388:	1000111e 	bne	r2,zero,82283d0 <bsd_recvfrom+0x130>
 822838c:	e0800217 	ldw	r2,8(fp)
 8228390:	10000f26 	beq	r2,zero,82283d0 <bsd_recvfrom+0x130>
   {
#ifndef IP_V6
      if (lfromlen > sizeof(struct sockaddr_in))
 8228394:	e0bffb17 	ldw	r2,-20(fp)
 8228398:	10800470 	cmpltui	r2,r2,17
 822839c:	1000021e 	bne	r2,zero,82283a8 <bsd_recvfrom+0x108>
         lfromlen = sizeof(struct sockaddr_in);
 82283a0:	00800404 	movi	r2,16
 82283a4:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lfromlen > sizeof(struct sockaddr_in6))
         lfromlen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(from, &lfrom, lfromlen);
 82283a8:	e0bffb17 	ldw	r2,-20(fp)
 82283ac:	1007883a 	mov	r3,r2
 82283b0:	e0bff704 	addi	r2,fp,-36
 82283b4:	180d883a 	mov	r6,r3
 82283b8:	100b883a 	mov	r5,r2
 82283bc:	e1000217 	ldw	r4,8(fp)
 82283c0:	8202e8c0 	call	8202e8c <memcpy>
      *fromlen = lfromlen;
 82283c4:	e0fffb17 	ldw	r3,-20(fp)
 82283c8:	e0800317 	ldw	r2,12(fp)
 82283cc:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 82283d0:	e0bff617 	ldw	r2,-40(fp)
}
 82283d4:	e037883a 	mov	sp,fp
 82283d8:	dfc00117 	ldw	ra,4(sp)
 82283dc:	df000017 	ldw	fp,0(sp)
 82283e0:	dec00204 	addi	sp,sp,8
 82283e4:	f800283a 	ret

082283e8 <bsd_select>:
bsd_select(int nfds,
           fd_set * readfds,
           fd_set * writefds,
           fd_set * exceptfds,
           BSD_TIMEVAL_T * timeout)
{
 82283e8:	defff804 	addi	sp,sp,-32
 82283ec:	dfc00715 	stw	ra,28(sp)
 82283f0:	df000615 	stw	fp,24(sp)
 82283f4:	df000604 	addi	fp,sp,24
 82283f8:	e13ffc15 	stw	r4,-16(fp)
 82283fc:	e17ffd15 	stw	r5,-12(fp)
 8228400:	e1bffe15 	stw	r6,-8(fp)
 8228404:	e1ffff15 	stw	r7,-4(fp)
   long ltv;    /* timeout expressed in ticks */
   long tps;    /* local copy of TPS */

   USE_ARG(nfds);

   if (timeout != NULL)
 8228408:	e0800217 	ldw	r2,8(fp)
 822840c:	10004b26 	beq	r2,zero,822853c <bsd_select+0x154>
       * million (i.e. any number of microseconds up to one second).
       * So we scale tv_usec from microseconds to something reasonable
       * based on TPS, multiply it by TPS, then scale it the rest of
       * the way to ticks-per-second.
       */
      tps = TPS;
 8228410:	00801904 	movi	r2,100
 8228414:	e0bffb15 	stw	r2,-20(fp)
      if (tps >= 1000)
 8228418:	e0bffb17 	ldw	r2,-20(fp)
 822841c:	1080fa10 	cmplti	r2,r2,1000
 8228420:	10000e1e 	bne	r2,zero,822845c <bsd_select+0x74>
      {
         ltv = (((timeout->tv_usec + 50) / 100) * tps) / 10000;
 8228424:	e0800217 	ldw	r2,8(fp)
 8228428:	10800117 	ldw	r2,4(r2)
 822842c:	10800c84 	addi	r2,r2,50
 8228430:	01401904 	movi	r5,100
 8228434:	1009883a 	mov	r4,r2
 8228438:	8202a940 	call	8202a94 <__divsi3>
 822843c:	1007883a 	mov	r3,r2
 8228440:	e0bffb17 	ldw	r2,-20(fp)
 8228444:	1885383a 	mul	r2,r3,r2
 8228448:	0149c404 	movi	r5,10000
 822844c:	1009883a 	mov	r4,r2
 8228450:	8202a940 	call	8202a94 <__divsi3>
 8228454:	e0bffa15 	stw	r2,-24(fp)
 8228458:	00003106 	br	8228520 <bsd_select+0x138>
      }
      else if (tps >= 100)
 822845c:	e0bffb17 	ldw	r2,-20(fp)
 8228460:	10801910 	cmplti	r2,r2,100
 8228464:	10000e1e 	bne	r2,zero,82284a0 <bsd_select+0xb8>
      {
         ltv = (((timeout->tv_usec + 500) / 1000) * tps) / 1000;
 8228468:	e0800217 	ldw	r2,8(fp)
 822846c:	10800117 	ldw	r2,4(r2)
 8228470:	10807d04 	addi	r2,r2,500
 8228474:	0140fa04 	movi	r5,1000
 8228478:	1009883a 	mov	r4,r2
 822847c:	8202a940 	call	8202a94 <__divsi3>
 8228480:	1007883a 	mov	r3,r2
 8228484:	e0bffb17 	ldw	r2,-20(fp)
 8228488:	1885383a 	mul	r2,r3,r2
 822848c:	0140fa04 	movi	r5,1000
 8228490:	1009883a 	mov	r4,r2
 8228494:	8202a940 	call	8202a94 <__divsi3>
 8228498:	e0bffa15 	stw	r2,-24(fp)
 822849c:	00002006 	br	8228520 <bsd_select+0x138>
      }
      else if (tps >= 10)
 82284a0:	e0bffb17 	ldw	r2,-20(fp)
 82284a4:	10800290 	cmplti	r2,r2,10
 82284a8:	10000e1e 	bne	r2,zero,82284e4 <bsd_select+0xfc>
      {
         ltv = (((timeout->tv_usec + 5000) / 10000) * tps) / 100;
 82284ac:	e0800217 	ldw	r2,8(fp)
 82284b0:	10800117 	ldw	r2,4(r2)
 82284b4:	1084e204 	addi	r2,r2,5000
 82284b8:	0149c404 	movi	r5,10000
 82284bc:	1009883a 	mov	r4,r2
 82284c0:	8202a940 	call	8202a94 <__divsi3>
 82284c4:	1007883a 	mov	r3,r2
 82284c8:	e0bffb17 	ldw	r2,-20(fp)
 82284cc:	1885383a 	mul	r2,r3,r2
 82284d0:	01401904 	movi	r5,100
 82284d4:	1009883a 	mov	r4,r2
 82284d8:	8202a940 	call	8202a94 <__divsi3>
 82284dc:	e0bffa15 	stw	r2,-24(fp)
 82284e0:	00000f06 	br	8228520 <bsd_select+0x138>
      }
      else
      {
         ltv = (((timeout->tv_usec + 50000) / 100000) * tps) / 10;
 82284e4:	e0800217 	ldw	r2,8(fp)
 82284e8:	10c00117 	ldw	r3,4(r2)
 82284ec:	00b0d414 	movui	r2,50000
 82284f0:	1885883a 	add	r2,r3,r2
 82284f4:	014000b4 	movhi	r5,2
 82284f8:	2961a804 	addi	r5,r5,-31072
 82284fc:	1009883a 	mov	r4,r2
 8228500:	8202a940 	call	8202a94 <__divsi3>
 8228504:	1007883a 	mov	r3,r2
 8228508:	e0bffb17 	ldw	r2,-20(fp)
 822850c:	1885383a 	mul	r2,r3,r2
 8228510:	01400284 	movi	r5,10
 8228514:	1009883a 	mov	r4,r2
 8228518:	8202a940 	call	8202a94 <__divsi3>
 822851c:	e0bffa15 	stw	r2,-24(fp)
      }
      ltv += (timeout->tv_sec * TPS);
 8228520:	e0800217 	ldw	r2,8(fp)
 8228524:	10800017 	ldw	r2,0(r2)
 8228528:	10801924 	muli	r2,r2,100
 822852c:	e0fffa17 	ldw	r3,-24(fp)
 8228530:	1885883a 	add	r2,r3,r2
 8228534:	e0bffa15 	stw	r2,-24(fp)
 8228538:	00000206 	br	8228544 <bsd_select+0x15c>
   }
   else {
      /*
       * NULL timeout: wait indefinitely in t_select()
       */
      ltv = -1;
 822853c:	00bfffc4 	movi	r2,-1
 8228540:	e0bffa15 	stw	r2,-24(fp)
   }

   return (t_select(readfds, writefds, exceptfds, ltv));
 8228544:	e1fffa17 	ldw	r7,-24(fp)
 8228548:	e1bfff17 	ldw	r6,-4(fp)
 822854c:	e17ffe17 	ldw	r5,-8(fp)
 8228550:	e13ffd17 	ldw	r4,-12(fp)
 8228554:	8234b740 	call	8234b74 <t_select>
}
 8228558:	e037883a 	mov	sp,fp
 822855c:	dfc00117 	ldw	ra,4(sp)
 8228560:	df000017 	ldw	fp,0(sp)
 8228564:	dec00204 	addi	sp,sp,8
 8228568:	f800283a 	ret

0822856c <bsd_setsockopt>:
int 
bsd_setsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int optlen)
{
 822856c:	defff704 	addi	sp,sp,-36
 8228570:	dfc00815 	stw	ra,32(sp)
 8228574:	df000715 	stw	fp,28(sp)
 8228578:	df000704 	addi	fp,sp,28
 822857c:	e13ffc15 	stw	r4,-16(fp)
 8228580:	e17ffd15 	stw	r5,-12(fp)
 8228584:	e1bffe15 	stw	r6,-8(fp)
 8228588:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;

   so = LONG2SO(s);
 822858c:	e0bffc17 	ldw	r2,-16(fp)
 8228590:	10bff804 	addi	r2,r2,-32
 8228594:	1085883a 	add	r2,r2,r2
 8228598:	1085883a 	add	r2,r2,r2
 822859c:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 82285a0:	008209b4 	movhi	r2,2086
 82285a4:	10b96104 	addi	r2,r2,-6780
 82285a8:	e0bffa15 	stw	r2,-24(fp)
 82285ac:	00000606 	br	82285c8 <bsd_setsockopt+0x5c>
 82285b0:	e0fffa17 	ldw	r3,-24(fp)
 82285b4:	e0bffb17 	ldw	r2,-20(fp)
 82285b8:	18800626 	beq	r3,r2,82285d4 <bsd_setsockopt+0x68>
 82285bc:	e0bffa17 	ldw	r2,-24(fp)
 82285c0:	10800017 	ldw	r2,0(r2)
 82285c4:	e0bffa15 	stw	r2,-24(fp)
 82285c8:	e0bffa17 	ldw	r2,-24(fp)
 82285cc:	103ff81e 	bne	r2,zero,82285b0 <bsd_setsockopt+0x44>
 82285d0:	00000106 	br	82285d8 <bsd_setsockopt+0x6c>
 82285d4:	0001883a 	nop
 82285d8:	e0fffa17 	ldw	r3,-24(fp)
 82285dc:	e0bffb17 	ldw	r2,-20(fp)
 82285e0:	18800326 	beq	r3,r2,82285f0 <bsd_setsockopt+0x84>
 82285e4:	822d4140 	call	822d414 <dtrap>
 82285e8:	00bfffc4 	movi	r2,-1
 82285ec:	00001206 	br	8228638 <bsd_setsockopt+0xcc>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   if (optlen < bsd_i_sockoptlen(level, name))
 82285f0:	e17ffe17 	ldw	r5,-8(fp)
 82285f4:	e13ffd17 	ldw	r4,-12(fp)
 82285f8:	8227f300 	call	8227f30 <bsd_i_sockoptlen>
 82285fc:	1007883a 	mov	r3,r2
 8228600:	e0800217 	ldw	r2,8(fp)
 8228604:	10c0050e 	bge	r2,r3,822861c <bsd_setsockopt+0xb0>
   {
      so->so_error = EFAULT;
 8228608:	e0bffb17 	ldw	r2,-20(fp)
 822860c:	00c00384 	movi	r3,14
 8228610:	10c00615 	stw	r3,24(r2)
      return -1;
 8228614:	00bfffc4 	movi	r2,-1
 8228618:	00000706 	br	8228638 <bsd_setsockopt+0xcc>
   }

   return t_setsockopt(s, level, name, opt, optlen);
 822861c:	e0800217 	ldw	r2,8(fp)
 8228620:	d8800015 	stw	r2,0(sp)
 8228624:	e1ffff17 	ldw	r7,-4(fp)
 8228628:	e1bffe17 	ldw	r6,-8(fp)
 822862c:	e17ffd17 	ldw	r5,-12(fp)
 8228630:	e13ffc17 	ldw	r4,-16(fp)
 8228634:	8230c900 	call	8230c90 <t_setsockopt>
}
 8228638:	e037883a 	mov	sp,fp
 822863c:	dfc00117 	ldw	ra,4(sp)
 8228640:	df000017 	ldw	fp,0(sp)
 8228644:	dec00204 	addi	sp,sp,8
 8228648:	f800283a 	ret

0822864c <ccksum>:
 * be done in 16-bit chunks.
 */

unsigned short
ccksum (void *ptr, unsigned words)
{
 822864c:	defffa04 	addi	sp,sp,-24
 8228650:	df000515 	stw	fp,20(sp)
 8228654:	df000504 	addi	fp,sp,20
 8228658:	e13ffe15 	stw	r4,-8(fp)
 822865c:	e17fff15 	stw	r5,-4(fp)
   unsigned short *addr = (unsigned short *)ptr;
 8228660:	e0bffe17 	ldw	r2,-8(fp)
 8228664:	e0bffb15 	stw	r2,-20(fp)
   unsigned long sum = 0;
 8228668:	e03ffc15 	stw	zero,-16(fp)
   int count = (int)words;
 822866c:	e0bfff17 	ldw	r2,-4(fp)
 8228670:	e0bffd15 	stw	r2,-12(fp)

   while (--count >= 0)
 8228674:	00000806 	br	8228698 <ccksum+0x4c>
   {
      /*  This is the inner loop */
      sum += *addr++;
 8228678:	e0bffb17 	ldw	r2,-20(fp)
 822867c:	10c00084 	addi	r3,r2,2
 8228680:	e0fffb15 	stw	r3,-20(fp)
 8228684:	1080000b 	ldhu	r2,0(r2)
 8228688:	10bfffcc 	andi	r2,r2,65535
 822868c:	e0fffc17 	ldw	r3,-16(fp)
 8228690:	1885883a 	add	r2,r3,r2
 8228694:	e0bffc15 	stw	r2,-16(fp)
{
   unsigned short *addr = (unsigned short *)ptr;
   unsigned long sum = 0;
   int count = (int)words;

   while (--count >= 0)
 8228698:	e0bffd17 	ldw	r2,-12(fp)
 822869c:	10bfffc4 	addi	r2,r2,-1
 82286a0:	e0bffd15 	stw	r2,-12(fp)
 82286a4:	e0bffd17 	ldw	r2,-12(fp)
 82286a8:	103ff30e 	bge	r2,zero,8228678 <ccksum+0x2c>
      /*  This is the inner loop */
      sum += *addr++;
   }

   /*  Fold 32-bit sum to 16 bits */
   sum = (sum & 0xffff) + (sum >> 16);
 82286ac:	e0bffc17 	ldw	r2,-16(fp)
 82286b0:	10ffffcc 	andi	r3,r2,65535
 82286b4:	e0bffc17 	ldw	r2,-16(fp)
 82286b8:	1004d43a 	srli	r2,r2,16
 82286bc:	1885883a 	add	r2,r3,r2
 82286c0:	e0bffc15 	stw	r2,-16(fp)
   sum = (sum & 0xffff) + (sum >> 16);
 82286c4:	e0bffc17 	ldw	r2,-16(fp)
 82286c8:	10ffffcc 	andi	r3,r2,65535
 82286cc:	e0bffc17 	ldw	r2,-16(fp)
 82286d0:	1004d43a 	srli	r2,r2,16
 82286d4:	1885883a 	add	r2,r3,r2
 82286d8:	e0bffc15 	stw	r2,-16(fp)

   /* checksum = ~sum; *//* removed for MIT IP stack */
   return ((unsigned short)sum);
 82286dc:	e0bffc17 	ldw	r2,-16(fp)
}
 82286e0:	e037883a 	mov	sp,fp
 82286e4:	df000017 	ldw	fp,0(sp)
 82286e8:	dec00104 	addi	sp,sp,4
 82286ec:	f800283a 	ret

082286f0 <cksum>:
 *    3 = user-supplied alternate implementation
 */

unsigned short
cksum (void *ptr, unsigned count)
{
 82286f0:	defffc04 	addi	sp,sp,-16
 82286f4:	dfc00315 	stw	ra,12(sp)
 82286f8:	df000215 	stw	fp,8(sp)
 82286fc:	df000204 	addi	fp,sp,8
 8228700:	e13ffe15 	stw	r4,-8(fp)
 8228704:	e17fff15 	stw	r5,-4(fp)
   switch (cksum_select)
 8228708:	d0a03117 	ldw	r2,-32572(gp)
 822870c:	108000a0 	cmpeqi	r2,r2,2
 8228710:	1000041e 	bne	r2,zero,8228724 <cksum+0x34>
   {
      case 1:
      default:
         return (ccksum(ptr, count));
 8228714:	e17fff17 	ldw	r5,-4(fp)
 8228718:	e13ffe17 	ldw	r4,-8(fp)
 822871c:	822864c0 	call	822864c <ccksum>
 8228720:	00000306 	br	8228730 <cksum+0x40>
 #ifndef C_CHECKSUM
      case 2:
         return (asm_cksum(ptr, count));
 8228724:	e17fff17 	ldw	r5,-4(fp)
 8228728:	e13ffe17 	ldw	r4,-8(fp)
 822872c:	822d2800 	call	822d280 <asm_cksum>
#else
#endif
         return (alt_cksum(ptr, count));
#endif
   }
}
 8228730:	e037883a 	mov	sp,fp
 8228734:	dfc00117 	ldw	ra,4(sp)
 8228738:	df000017 	ldw	fp,0(sp)
 822873c:	dec00204 	addi	sp,sp,8
 8228740:	f800283a 	ret

08228744 <do_trap>:
 * RETURNS: 0
 */

int
do_trap(void)
{
 8228744:	defffe04 	addi	sp,sp,-8
 8228748:	dfc00115 	stw	ra,4(sp)
 822874c:	df000015 	stw	fp,0(sp)
 8228750:	d839883a 	mov	fp,sp
   dtrap();
 8228754:	822d4140 	call	822d414 <dtrap>
   return 0;
 8228758:	0005883a 	mov	r2,zero
}
 822875c:	e037883a 	mov	sp,fp
 8228760:	dfc00117 	ldw	ra,4(sp)
 8228764:	df000017 	ldw	fp,0(sp)
 8228768:	dec00204 	addi	sp,sp,8
 822876c:	f800283a 	ret

08228770 <nextarg>:
 * RETURNS:  pointer to next arg in string 
 */

char *   
nextarg(char * argp)
{
 8228770:	defffe04 	addi	sp,sp,-8
 8228774:	df000115 	stw	fp,4(sp)
 8228778:	df000104 	addi	fp,sp,4
 822877c:	e13fff15 	stw	r4,-4(fp)
   while (*argp > ' ')argp++; /* scan past current arg */
 8228780:	00000306 	br	8228790 <nextarg+0x20>
 8228784:	e0bfff17 	ldw	r2,-4(fp)
 8228788:	10800044 	addi	r2,r2,1
 822878c:	e0bfff15 	stw	r2,-4(fp)
 8228790:	e0bfff17 	ldw	r2,-4(fp)
 8228794:	10800003 	ldbu	r2,0(r2)
 8228798:	10803fcc 	andi	r2,r2,255
 822879c:	1080201c 	xori	r2,r2,128
 82287a0:	10bfe004 	addi	r2,r2,-128
 82287a4:	10800848 	cmpgei	r2,r2,33
 82287a8:	103ff61e 	bne	r2,zero,8228784 <nextarg+0x14>
      while (*argp == ' ')argp++;   /* scan past spaces */
 82287ac:	00000306 	br	82287bc <nextarg+0x4c>
 82287b0:	e0bfff17 	ldw	r2,-4(fp)
 82287b4:	10800044 	addi	r2,r2,1
 82287b8:	e0bfff15 	stw	r2,-4(fp)
 82287bc:	e0bfff17 	ldw	r2,-4(fp)
 82287c0:	10800003 	ldbu	r2,0(r2)
 82287c4:	10803fcc 	andi	r2,r2,255
 82287c8:	1080201c 	xori	r2,r2,128
 82287cc:	10bfe004 	addi	r2,r2,-128
 82287d0:	10800820 	cmpeqi	r2,r2,32
 82287d4:	103ff61e 	bne	r2,zero,82287b0 <nextarg+0x40>
      return (argp);
 82287d8:	e0bfff17 	ldw	r2,-4(fp)
}
 82287dc:	e037883a 	mov	sp,fp
 82287e0:	df000017 	ldw	fp,0(sp)
 82287e4:	dec00104 	addi	sp,sp,4
 82287e8:	f800283a 	ret

082287ec <hexdump>:

#define  HEX_BYTES_PER_LINE   16

void
hexdump(void * pio, void * buffer, unsigned len)
{
 82287ec:	defff804 	addi	sp,sp,-32
 82287f0:	dfc00715 	stw	ra,28(sp)
 82287f4:	df000615 	stw	fp,24(sp)
 82287f8:	df000604 	addi	fp,sp,24
 82287fc:	e13ffd15 	stw	r4,-12(fp)
 8228800:	e17ffe15 	stw	r5,-8(fp)
 8228804:	e1bfff15 	stw	r6,-4(fp)
   u_char * data  =  (u_char *)buffer;
 8228808:	e0bffe17 	ldw	r2,-8(fp)
 822880c:	e0bffa15 	stw	r2,-24(fp)
   unsigned int count;
   char  c;

   while (len)
 8228810:	00003f06 	br	8228910 <hexdump+0x124>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 8228814:	e03ffb15 	stw	zero,-20(fp)
 8228818:	00000d06 	br	8228850 <hexdump+0x64>
         ns_printf(pio, "%02x ", *(data + count));
 822881c:	e0fffa17 	ldw	r3,-24(fp)
 8228820:	e0bffb17 	ldw	r2,-20(fp)
 8228824:	1885883a 	add	r2,r3,r2
 8228828:	10800003 	ldbu	r2,0(r2)
 822882c:	10803fcc 	andi	r2,r2,255
 8228830:	100d883a 	mov	r6,r2
 8228834:	01420974 	movhi	r5,2085
 8228838:	29417d04 	addi	r5,r5,1524
 822883c:	e13ffd17 	ldw	r4,-12(fp)
 8228840:	8228d040 	call	8228d04 <ns_printf>
   char  c;

   while (len)
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 8228844:	e0bffb17 	ldw	r2,-20(fp)
 8228848:	10800044 	addi	r2,r2,1
 822884c:	e0bffb15 	stw	r2,-20(fp)
 8228850:	e0bffb17 	ldw	r2,-20(fp)
 8228854:	10800428 	cmpgeui	r2,r2,16
 8228858:	1000031e 	bne	r2,zero,8228868 <hexdump+0x7c>
 822885c:	e0fffb17 	ldw	r3,-20(fp)
 8228860:	e0bfff17 	ldw	r2,-4(fp)
 8228864:	18bfed36 	bltu	r3,r2,822881c <hexdump+0x30>
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 8228868:	e03ffb15 	stw	zero,-20(fp)
 822886c:	00001606 	br	82288c8 <hexdump+0xdc>
      {
         c = *(data + count);
 8228870:	e0fffa17 	ldw	r3,-24(fp)
 8228874:	e0bffb17 	ldw	r2,-20(fp)
 8228878:	1885883a 	add	r2,r3,r2
 822887c:	10800003 	ldbu	r2,0(r2)
 8228880:	e0bffc05 	stb	r2,-16(fp)
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
 8228884:	e0bffc07 	ldb	r2,-16(fp)
 8228888:	10800810 	cmplti	r2,r2,32
 822888c:	1000051e 	bne	r2,zero,82288a4 <hexdump+0xb8>
 8228890:	e0bffc07 	ldb	r2,-16(fp)
 8228894:	10801fe0 	cmpeqi	r2,r2,127
 8228898:	1000021e 	bne	r2,zero,82288a4 <hexdump+0xb8>
 822889c:	e0bffc07 	ldb	r2,-16(fp)
 82288a0:	00000106 	br	82288a8 <hexdump+0xbc>
 82288a4:	00800b84 	movi	r2,46
 82288a8:	100d883a 	mov	r6,r2
 82288ac:	01420974 	movhi	r5,2085
 82288b0:	29417f04 	addi	r5,r5,1532
 82288b4:	e13ffd17 	ldw	r4,-12(fp)
 82288b8:	8228d040 	call	8228d04 <ns_printf>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 82288bc:	e0bffb17 	ldw	r2,-20(fp)
 82288c0:	10800044 	addi	r2,r2,1
 82288c4:	e0bffb15 	stw	r2,-20(fp)
 82288c8:	e0bffb17 	ldw	r2,-20(fp)
 82288cc:	10800428 	cmpgeui	r2,r2,16
 82288d0:	1000031e 	bne	r2,zero,82288e0 <hexdump+0xf4>
 82288d4:	e0fffb17 	ldw	r3,-20(fp)
 82288d8:	e0bfff17 	ldw	r2,-4(fp)
 82288dc:	18bfe436 	bltu	r3,r2,8228870 <hexdump+0x84>
      {
         c = *(data + count);
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
      }
      ns_printf(pio,"\n");
 82288e0:	01420974 	movhi	r5,2085
 82288e4:	29418004 	addi	r5,r5,1536
 82288e8:	e13ffd17 	ldw	r4,-12(fp)
 82288ec:	8228d040 	call	8228d04 <ns_printf>
      len -= count;
 82288f0:	e0ffff17 	ldw	r3,-4(fp)
 82288f4:	e0bffb17 	ldw	r2,-20(fp)
 82288f8:	1885c83a 	sub	r2,r3,r2
 82288fc:	e0bfff15 	stw	r2,-4(fp)
      data += count;
 8228900:	e0fffa17 	ldw	r3,-24(fp)
 8228904:	e0bffb17 	ldw	r2,-20(fp)
 8228908:	1885883a 	add	r2,r3,r2
 822890c:	e0bffa15 	stw	r2,-24(fp)
{
   u_char * data  =  (u_char *)buffer;
   unsigned int count;
   char  c;

   while (len)
 8228910:	e0bfff17 	ldw	r2,-4(fp)
 8228914:	103fbf1e 	bne	r2,zero,8228814 <hexdump+0x28>
      }
      ns_printf(pio,"\n");
      len -= count;
      data += count;
   }
}
 8228918:	0001883a 	nop
 822891c:	e037883a 	mov	sp,fp
 8228920:	dfc00117 	ldw	ra,4(sp)
 8228924:	df000017 	ldw	fp,0(sp)
 8228928:	dec00204 	addi	sp,sp,8
 822892c:	f800283a 	ret

08228930 <print_ipad>:

char     ipreturn[18];     /* buffer for return */

char *   
print_ipad(unsigned long ipaddr)
{
 8228930:	defffa04 	addi	sp,sp,-24
 8228934:	dfc00515 	stw	ra,20(sp)
 8228938:	df000415 	stw	fp,16(sp)
 822893c:	df000404 	addi	fp,sp,16
 8228940:	e13fff15 	stw	r4,-4(fp)
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
 8228944:	e0bfff17 	ldw	r2,-4(fp)
 8228948:	e0bffe15 	stw	r2,-8(fp)
   sprintf(ipreturn, "%u.%u.%u.%u", 
    ip.ip.ipchar[0],
 822894c:	e0bffe03 	ldbu	r2,-8(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228950:	11003fcc 	andi	r4,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
 8228954:	e0bffe43 	ldbu	r2,-7(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228958:	11403fcc 	andi	r5,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
 822895c:	e0bffe83 	ldbu	r2,-6(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228960:	10803fcc 	andi	r2,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);
 8228964:	e0fffec3 	ldbu	r3,-5(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 8228968:	18c03fcc 	andi	r3,r3,255
 822896c:	d8c00115 	stw	r3,4(sp)
 8228970:	d8800015 	stw	r2,0(sp)
 8228974:	280f883a 	mov	r7,r5
 8228978:	200d883a 	mov	r6,r4
 822897c:	01420974 	movhi	r5,2085
 8228980:	29418104 	addi	r5,r5,1540
 8228984:	010209b4 	movhi	r4,2086
 8228988:	21384584 	addi	r4,r4,-7914
 822898c:	82036940 	call	8203694 <sprintf>
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);

   return ipreturn;
 8228990:	008209b4 	movhi	r2,2086
 8228994:	10b84584 	addi	r2,r2,-7914
}
 8228998:	e037883a 	mov	sp,fp
 822899c:	dfc00117 	ldw	ra,4(sp)
 82289a0:	df000017 	ldw	fp,0(sp)
 82289a4:	dec00204 	addi	sp,sp,8
 82289a8:	f800283a 	ret

082289ac <print_uptime>:

static char tistring[24];     /* buffer for return */

char *   
print_uptime(unsigned long timetick)
{
 82289ac:	defff804 	addi	sp,sp,-32
 82289b0:	dfc00715 	stw	ra,28(sp)
 82289b4:	df000615 	stw	fp,24(sp)
 82289b8:	df000604 	addi	fp,sp,24
 82289bc:	e13fff15 	stw	r4,-4(fp)
   unsigned seconds, minutes, hours;

   timetick = timetick/100;   /* turn timetick into seconds */
 82289c0:	e0bfff17 	ldw	r2,-4(fp)
 82289c4:	01401904 	movi	r5,100
 82289c8:	1009883a 	mov	r4,r2
 82289cc:	8202b8c0 	call	8202b8c <__udivsi3>
 82289d0:	e0bfff15 	stw	r2,-4(fp)
   seconds = (unsigned)(timetick%60);
 82289d4:	e0bfff17 	ldw	r2,-4(fp)
 82289d8:	01400f04 	movi	r5,60
 82289dc:	1009883a 	mov	r4,r2
 82289e0:	8202bf00 	call	8202bf0 <__umodsi3>
 82289e4:	e0bffc15 	stw	r2,-16(fp)
   timetick = timetick/60;    /* turn timetick into minutes */
 82289e8:	e0bfff17 	ldw	r2,-4(fp)
 82289ec:	01400f04 	movi	r5,60
 82289f0:	1009883a 	mov	r4,r2
 82289f4:	8202b8c0 	call	8202b8c <__udivsi3>
 82289f8:	e0bfff15 	stw	r2,-4(fp)
   minutes = (unsigned)(timetick%60);
 82289fc:	e0bfff17 	ldw	r2,-4(fp)
 8228a00:	01400f04 	movi	r5,60
 8228a04:	1009883a 	mov	r4,r2
 8228a08:	8202bf00 	call	8202bf0 <__umodsi3>
 8228a0c:	e0bffd15 	stw	r2,-12(fp)
   timetick = timetick/60;    /* turn timetick into hours */
 8228a10:	e0bfff17 	ldw	r2,-4(fp)
 8228a14:	01400f04 	movi	r5,60
 8228a18:	1009883a 	mov	r4,r2
 8228a1c:	8202b8c0 	call	8202b8c <__udivsi3>
 8228a20:	e0bfff15 	stw	r2,-4(fp)
   hours = (unsigned)(timetick%24);
 8228a24:	e0bfff17 	ldw	r2,-4(fp)
 8228a28:	01400604 	movi	r5,24
 8228a2c:	1009883a 	mov	r4,r2
 8228a30:	8202bf00 	call	8202bf0 <__umodsi3>
 8228a34:	e0bffe15 	stw	r2,-8(fp)
   timetick = timetick/24;    /* turn timetick into days */
 8228a38:	e0bfff17 	ldw	r2,-4(fp)
 8228a3c:	01400604 	movi	r5,24
 8228a40:	1009883a 	mov	r4,r2
 8228a44:	8202b8c0 	call	8202b8c <__udivsi3>
 8228a48:	e0bfff15 	stw	r2,-4(fp)

   if (timetick)  /* Is there a whole number of days? */
 8228a4c:	e0bfff17 	ldw	r2,-4(fp)
 8228a50:	10000c26 	beq	r2,zero,8228a84 <print_uptime+0xd8>
      sprintf(tistring, "%ld days, %dh:%dm:%ds", 
 8228a54:	e0bffc17 	ldw	r2,-16(fp)
 8228a58:	d8800115 	stw	r2,4(sp)
 8228a5c:	e0bffd17 	ldw	r2,-12(fp)
 8228a60:	d8800015 	stw	r2,0(sp)
 8228a64:	e1fffe17 	ldw	r7,-8(fp)
 8228a68:	e1bfff17 	ldw	r6,-4(fp)
 8228a6c:	01420974 	movhi	r5,2085
 8228a70:	29418404 	addi	r5,r5,1552
 8228a74:	01020974 	movhi	r4,2085
 8228a78:	21121204 	addi	r4,r4,18504
 8228a7c:	82036940 	call	8203694 <sprintf>
 8228a80:	00001306 	br	8228ad0 <print_uptime+0x124>
    timetick, hours, minutes, seconds);
   else if (hours)
 8228a84:	e0bffe17 	ldw	r2,-8(fp)
 8228a88:	10000a26 	beq	r2,zero,8228ab4 <print_uptime+0x108>
      sprintf(tistring, "%d hours, %dm:%ds", hours, minutes, seconds);
 8228a8c:	e0bffc17 	ldw	r2,-16(fp)
 8228a90:	d8800015 	stw	r2,0(sp)
 8228a94:	e1fffd17 	ldw	r7,-12(fp)
 8228a98:	e1bffe17 	ldw	r6,-8(fp)
 8228a9c:	01420974 	movhi	r5,2085
 8228aa0:	29418a04 	addi	r5,r5,1576
 8228aa4:	01020974 	movhi	r4,2085
 8228aa8:	21121204 	addi	r4,r4,18504
 8228aac:	82036940 	call	8203694 <sprintf>
 8228ab0:	00000706 	br	8228ad0 <print_uptime+0x124>
   else
      sprintf(tistring, "%d minutes, %d sec.", minutes, seconds);
 8228ab4:	e1fffc17 	ldw	r7,-16(fp)
 8228ab8:	e1bffd17 	ldw	r6,-12(fp)
 8228abc:	01420974 	movhi	r5,2085
 8228ac0:	29418f04 	addi	r5,r5,1596
 8228ac4:	01020974 	movhi	r4,2085
 8228ac8:	21121204 	addi	r4,r4,18504
 8228acc:	82036940 	call	8203694 <sprintf>
   return tistring;
 8228ad0:	00820974 	movhi	r2,2085
 8228ad4:	10921204 	addi	r2,r2,18504
}
 8228ad8:	e037883a 	mov	sp,fp
 8228adc:	dfc00117 	ldw	ra,4(sp)
 8228ae0:	df000017 	ldw	fp,0(sp)
 8228ae4:	dec00204 	addi	sp,sp,8
 8228ae8:	f800283a 	ret

08228aec <panic>:
/* allow to be ifdeffed out on systems which already have a panic */
#ifndef PANIC_ALREADY

void
panic(char * msg)
{
 8228aec:	defffd04 	addi	sp,sp,-12
 8228af0:	dfc00215 	stw	ra,8(sp)
 8228af4:	df000115 	stw	fp,4(sp)
 8228af8:	df000104 	addi	fp,sp,4
 8228afc:	e13fff15 	stw	r4,-4(fp)
   dprintf("panic: %s\n", msg);
 8228b00:	e17fff17 	ldw	r5,-4(fp)
 8228b04:	01020974 	movhi	r4,2085
 8228b08:	21019404 	addi	r4,r4,1616
 8228b0c:	820331c0 	call	820331c <printf>
   dtrap();                   /* try to hook debugger */
 8228b10:	822d4140 	call	822d414 <dtrap>
   netexit(1);                /* try to clean up */
 8228b14:	01000044 	movi	r4,1
 8228b18:	8243adc0 	call	8243adc <netexit>
}
 8228b1c:	0001883a 	nop
 8228b20:	e037883a 	mov	sp,fp
 8228b24:	dfc00117 	ldw	ra,4(sp)
 8228b28:	df000017 	ldw	fp,0(sp)
 8228b2c:	dec00204 	addi	sp,sp,8
 8228b30:	f800283a 	ret

08228b34 <print_eth>:

char     eth_prt_buf[18];  /* buffer for return */

char *   
print_eth(char * addr, char spacer)
{
 8228b34:	defffb04 	addi	sp,sp,-20
 8228b38:	df000415 	stw	fp,16(sp)
 8228b3c:	df000404 	addi	fp,sp,16
 8228b40:	e13ffe15 	stw	r4,-8(fp)
 8228b44:	2805883a 	mov	r2,r5
 8228b48:	e0bfff05 	stb	r2,-4(fp)
   int   i;
   char *   out   =  eth_prt_buf;
 8228b4c:	008209b4 	movhi	r2,2086
 8228b50:	10b84104 	addi	r2,r2,-7932
 8228b54:	e0bffd15 	stw	r2,-12(fp)

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 8228b58:	e03ffc15 	stw	zero,-16(fp)
 8228b5c:	00003f06 	br	8228c5c <print_eth+0x128>
   {
      /* high nibble */
      *out = (char)(((*addr >> 4) & 0x0f) + 0x30);
 8228b60:	e0bffe17 	ldw	r2,-8(fp)
 8228b64:	10800003 	ldbu	r2,0(r2)
 8228b68:	10803fcc 	andi	r2,r2,255
 8228b6c:	1004d13a 	srli	r2,r2,4
 8228b70:	10800c04 	addi	r2,r2,48
 8228b74:	1007883a 	mov	r3,r2
 8228b78:	e0bffd17 	ldw	r2,-12(fp)
 8228b7c:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 8228b80:	e0bffd17 	ldw	r2,-12(fp)
 8228b84:	10800003 	ldbu	r2,0(r2)
 8228b88:	10803fcc 	andi	r2,r2,255
 8228b8c:	1080201c 	xori	r2,r2,128
 8228b90:	10bfe004 	addi	r2,r2,-128
 8228b94:	10800e90 	cmplti	r2,r2,58
 8228b98:	1000061e 	bne	r2,zero,8228bb4 <print_eth+0x80>
         (*out) += 7;
 8228b9c:	e0bffd17 	ldw	r2,-12(fp)
 8228ba0:	10800003 	ldbu	r2,0(r2)
 8228ba4:	108001c4 	addi	r2,r2,7
 8228ba8:	1007883a 	mov	r3,r2
 8228bac:	e0bffd17 	ldw	r2,-12(fp)
 8228bb0:	10c00005 	stb	r3,0(r2)
      out++;
 8228bb4:	e0bffd17 	ldw	r2,-12(fp)
 8228bb8:	10800044 	addi	r2,r2,1
 8228bbc:	e0bffd15 	stw	r2,-12(fp)

      /* low nibble */
      *out = (char)((*addr & 0x0f) + 0x30);  /* low nibble to digit */
 8228bc0:	e0bffe17 	ldw	r2,-8(fp)
 8228bc4:	10800003 	ldbu	r2,0(r2)
 8228bc8:	108003cc 	andi	r2,r2,15
 8228bcc:	10800c04 	addi	r2,r2,48
 8228bd0:	1007883a 	mov	r3,r2
 8228bd4:	e0bffd17 	ldw	r2,-12(fp)
 8228bd8:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 8228bdc:	e0bffd17 	ldw	r2,-12(fp)
 8228be0:	10800003 	ldbu	r2,0(r2)
 8228be4:	10803fcc 	andi	r2,r2,255
 8228be8:	1080201c 	xori	r2,r2,128
 8228bec:	10bfe004 	addi	r2,r2,-128
 8228bf0:	10800e90 	cmplti	r2,r2,58
 8228bf4:	1000061e 	bne	r2,zero,8228c10 <print_eth+0xdc>
         (*out) += 7;   /* eg 0x3a -> 0x41 ('A') */
 8228bf8:	e0bffd17 	ldw	r2,-12(fp)
 8228bfc:	10800003 	ldbu	r2,0(r2)
 8228c00:	108001c4 	addi	r2,r2,7
 8228c04:	1007883a 	mov	r3,r2
 8228c08:	e0bffd17 	ldw	r2,-12(fp)
 8228c0c:	10c00005 	stb	r3,0(r2)
      out++;
 8228c10:	e0bffd17 	ldw	r2,-12(fp)
 8228c14:	10800044 	addi	r2,r2,1
 8228c18:	e0bffd15 	stw	r2,-12(fp)

      /* optional spacer character */
      if (spacer && i < 5)
 8228c1c:	e0bfff07 	ldb	r2,-4(fp)
 8228c20:	10000826 	beq	r2,zero,8228c44 <print_eth+0x110>
 8228c24:	e0bffc17 	ldw	r2,-16(fp)
 8228c28:	10800148 	cmpgei	r2,r2,5
 8228c2c:	1000051e 	bne	r2,zero,8228c44 <print_eth+0x110>
         *out++ = spacer;
 8228c30:	e0bffd17 	ldw	r2,-12(fp)
 8228c34:	10c00044 	addi	r3,r2,1
 8228c38:	e0fffd15 	stw	r3,-12(fp)
 8228c3c:	e0ffff03 	ldbu	r3,-4(fp)
 8228c40:	10c00005 	stb	r3,0(r2)
      addr++;
 8228c44:	e0bffe17 	ldw	r2,-8(fp)
 8228c48:	10800044 	addi	r2,r2,1
 8228c4c:	e0bffe15 	stw	r2,-8(fp)
{
   int   i;
   char *   out   =  eth_prt_buf;

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 8228c50:	e0bffc17 	ldw	r2,-16(fp)
 8228c54:	10800044 	addi	r2,r2,1
 8228c58:	e0bffc15 	stw	r2,-16(fp)
 8228c5c:	e0bffc17 	ldw	r2,-16(fp)
 8228c60:	10800190 	cmplti	r2,r2,6
 8228c64:	103fbe1e 	bne	r2,zero,8228b60 <print_eth+0x2c>
      /* optional spacer character */
      if (spacer && i < 5)
         *out++ = spacer;
      addr++;
   }
   *out = 0;
 8228c68:	e0bffd17 	ldw	r2,-12(fp)
 8228c6c:	10000005 	stb	zero,0(r2)
   return eth_prt_buf;
 8228c70:	008209b4 	movhi	r2,2086
 8228c74:	10b84104 	addi	r2,r2,-7932
}
 8228c78:	e037883a 	mov	sp,fp
 8228c7c:	df000017 	ldw	fp,0(sp)
 8228c80:	dec00104 	addi	sp,sp,4
 8228c84:	f800283a 	ret

08228c88 <uslash>:
 * RETURNS:  pointer to formatted text
 */

char *   
uslash(char * path)
{
 8228c88:	defffd04 	addi	sp,sp,-12
 8228c8c:	df000215 	stw	fp,8(sp)
 8228c90:	df000204 	addi	fp,sp,8
 8228c94:	e13fff15 	stw	r4,-4(fp)
   char *   cp;

   for (cp = path; *cp; cp++)
 8228c98:	e0bfff17 	ldw	r2,-4(fp)
 8228c9c:	e0bffe15 	stw	r2,-8(fp)
 8228ca0:	00000d06 	br	8228cd8 <uslash+0x50>
      if (*cp == '\\')
 8228ca4:	e0bffe17 	ldw	r2,-8(fp)
 8228ca8:	10800003 	ldbu	r2,0(r2)
 8228cac:	10803fcc 	andi	r2,r2,255
 8228cb0:	1080201c 	xori	r2,r2,128
 8228cb4:	10bfe004 	addi	r2,r2,-128
 8228cb8:	10801718 	cmpnei	r2,r2,92
 8228cbc:	1000031e 	bne	r2,zero,8228ccc <uslash+0x44>
      *cp = '/';
 8228cc0:	e0bffe17 	ldw	r2,-8(fp)
 8228cc4:	00c00bc4 	movi	r3,47
 8228cc8:	10c00005 	stb	r3,0(r2)
char *   
uslash(char * path)
{
   char *   cp;

   for (cp = path; *cp; cp++)
 8228ccc:	e0bffe17 	ldw	r2,-8(fp)
 8228cd0:	10800044 	addi	r2,r2,1
 8228cd4:	e0bffe15 	stw	r2,-8(fp)
 8228cd8:	e0bffe17 	ldw	r2,-8(fp)
 8228cdc:	10800003 	ldbu	r2,0(r2)
 8228ce0:	10803fcc 	andi	r2,r2,255
 8228ce4:	1080201c 	xori	r2,r2,128
 8228ce8:	10bfe004 	addi	r2,r2,-128
 8228cec:	103fed1e 	bne	r2,zero,8228ca4 <uslash+0x1c>
      if (*cp == '\\')
      *cp = '/';
   return path;
 8228cf0:	e0bfff17 	ldw	r2,-4(fp)
}
 8228cf4:	e037883a 	mov	sp,fp
 8228cf8:	df000017 	ldw	fp,0(sp)
 8228cfc:	dec00104 	addi	sp,sp,4
 8228d00:	f800283a 	ret

08228d04 <ns_printf>:
 */
#ifndef ns_printf

int 
ns_printf(void * vio, char * format, ...)
{
 8228d04:	defff304 	addi	sp,sp,-52
 8228d08:	dfc00a15 	stw	ra,40(sp)
 8228d0c:	df000915 	stw	fp,36(sp)
 8228d10:	dc400815 	stw	r17,32(sp)
 8228d14:	dc000715 	stw	r16,28(sp)
 8228d18:	df000904 	addi	fp,sp,36
 8228d1c:	e13ffc15 	stw	r4,-16(fp)
 8228d20:	e17ffd15 	stw	r5,-12(fp)
 8228d24:	e1800215 	stw	r6,8(fp)
 8228d28:	e1c00315 	stw	r7,12(fp)
   char *   outbuf=NULL;
 8228d2c:	e03ff815 	stw	zero,-32(fp)
   int   ret_value   ;
   int   buf_size =  MAXIOSIZE   ;
 8228d30:	00802704 	movi	r2,156
 8228d34:	e0bff715 	stw	r2,-36(fp)
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 8228d38:	e0bffc17 	ldw	r2,-16(fp)
 8228d3c:	e0bff915 	stw	r2,-28(fp)
   int * next_arg=(int *)  &format;
   next_arg +=  sizeof(char *)/sizeof(int) ;
#endif   /* NATIVE_PRINTF || PRINTF_STRING */

   /* a NULL pio means just dump the output to stdout */
   if (pio == NULL)
 8228d40:	e0bff917 	ldw	r2,-28(fp)
 8228d44:	1000091e 	bne	r2,zero,8228d6c <ns_printf+0x68>
   {
#ifdef NATIVE_PRINTF
      /* use the target system's ANSI routines */
      va_start(argList,format);
 8228d48:	e0800204 	addi	r2,fp,8
 8228d4c:	e0bffb15 	stw	r2,-20(fp)
      ret_value = vprintf(format,argList);
 8228d50:	e0bffb17 	ldw	r2,-20(fp)
 8228d54:	100b883a 	mov	r5,r2
 8228d58:	e13ffd17 	ldw	r4,-12(fp)
 8228d5c:	824bb580 	call	824bb58 <vprintf>
 8228d60:	e0bffa15 	stw	r2,-24(fp)
      va_end(argList);
      return ret_value;
 8228d64:	e0bffa17 	ldw	r2,-24(fp)
 8228d68:	00003b06 	br	8228e58 <ns_printf+0x154>
      return strlen(format);
#endif   /* NATIVE_PRINTF */
   }

   /* Check if the output function is set */
   if (pio->out == NULL)
 8228d6c:	e0bff917 	ldw	r2,-28(fp)
 8228d70:	10800117 	ldw	r2,4(r2)
 8228d74:	1000021e 	bne	r2,zero,8228d80 <ns_printf+0x7c>
   {
      /* Programming mistake. Output function not set. */
      return -1;
 8228d78:	00bfffc4 	movi	r2,-1
 8228d7c:	00003606 	br	8228e58 <ns_printf+0x154>

   /* Allocate memory for the output string 
    * If the format string is greater than MAXIOSIZE, then
    * we surely need to allocate a bigger block
    */
   ret_value = strlen(format); 
 8228d80:	e13ffd17 	ldw	r4,-12(fp)
 8228d84:	8203edc0 	call	8203edc <strlen>
 8228d88:	e0bffa15 	stw	r2,-24(fp)
   if (ret_value >= MAXIOSIZE)
 8228d8c:	e0bffa17 	ldw	r2,-24(fp)
 8228d90:	10802710 	cmplti	r2,r2,156
 8228d94:	1000041e 	bne	r2,zero,8228da8 <ns_printf+0xa4>
   {
      buf_size += ret_value ;
 8228d98:	e0fff717 	ldw	r3,-36(fp)
 8228d9c:	e0bffa17 	ldw	r2,-24(fp)
 8228da0:	1885883a 	add	r2,r3,r2
 8228da4:	e0bff715 	stw	r2,-36(fp)
   }

   outbuf=(char *)npalloc(buf_size); 
 8228da8:	e0bff717 	ldw	r2,-36(fp)
 8228dac:	1009883a 	mov	r4,r2
 8228db0:	822dfec0 	call	822dfec <npalloc>
 8228db4:	e0bff815 	stw	r2,-32(fp)

   if (outbuf == NULL)
 8228db8:	e0bff817 	ldw	r2,-32(fp)
 8228dbc:	1000021e 	bne	r2,zero,8228dc8 <ns_printf+0xc4>
   {
      return -2;
 8228dc0:	00bfff84 	movi	r2,-2
 8228dc4:	00002406 	br	8228e58 <ns_printf+0x154>

   /* Now populate the output string */

#ifdef NATIVE_PRINTF
   /* use the target system's ANSI routines */
   va_start(argList,format);
 8228dc8:	e0800204 	addi	r2,fp,8
 8228dcc:	e0bffb15 	stw	r2,-20(fp)
   ret_value = vsprintf(outbuf,format,argList);
 8228dd0:	e0bffb17 	ldw	r2,-20(fp)
 8228dd4:	100d883a 	mov	r6,r2
 8228dd8:	e17ffd17 	ldw	r5,-12(fp)
 8228ddc:	e13ff817 	ldw	r4,-32(fp)
 8228de0:	824bbd40 	call	824bbd4 <vsprintf>
 8228de4:	e0bffa15 	stw	r2,-24(fp)
#endif   /* PRINTF_STDARG */
#endif   /* NATIVE_PRINTF */

#ifdef NATIVE_PRINTF
   /* Check if we have overwritten the output buffer */
   if ((int)strlen(outbuf) > buf_size)
 8228de8:	e13ff817 	ldw	r4,-32(fp)
 8228dec:	8203edc0 	call	8203edc <strlen>
 8228df0:	1007883a 	mov	r3,r2
 8228df4:	e0bff717 	ldw	r2,-36(fp)
 8228df8:	10c0080e 	bge	r2,r3,8228e1c <ns_printf+0x118>
       */
      /* Yes , we have overwritten. Truncate the output string.
       * Some memory in the heap has been corrupted, but it is too
       * late to rectify.
       */
      panic("ns_printf:Buffer overflow");
 8228dfc:	01020974 	movhi	r4,2085
 8228e00:	21019704 	addi	r4,r4,1628
 8228e04:	8228aec0 	call	8228aec <panic>
      outbuf[buf_size-1]=0;   /* Null terminate the string */
 8228e08:	e0bff717 	ldw	r2,-36(fp)
 8228e0c:	10bfffc4 	addi	r2,r2,-1
 8228e10:	e0fff817 	ldw	r3,-32(fp)
 8228e14:	1885883a 	add	r2,r3,r2
 8228e18:	10000005 	stb	zero,0(r2)
   }
#endif

   ret_value =(pio->out)(pio->id,outbuf,strlen(outbuf)) ;
 8228e1c:	e0bff917 	ldw	r2,-28(fp)
 8228e20:	14000117 	ldw	r16,4(r2)
 8228e24:	e0bff917 	ldw	r2,-28(fp)
 8228e28:	14400217 	ldw	r17,8(r2)
 8228e2c:	e13ff817 	ldw	r4,-32(fp)
 8228e30:	8203edc0 	call	8203edc <strlen>
 8228e34:	100d883a 	mov	r6,r2
 8228e38:	e17ff817 	ldw	r5,-32(fp)
 8228e3c:	8809883a 	mov	r4,r17
 8228e40:	803ee83a 	callr	r16
 8228e44:	e0bffa15 	stw	r2,-24(fp)

   /* Free memory for the output string */
   npfree(outbuf); 
 8228e48:	e13ff817 	ldw	r4,-32(fp)
 8228e4c:	822e0200 	call	822e020 <npfree>

   /* since ns_printf() can get called repeatedly down in the bowels 
    * of a single command interpretting function, spin tk_yield() so 
    * that some packets get a chance to get received 
    */
   tk_yield();
 8228e50:	82296b00 	call	82296b0 <tk_yield>

   return ret_value ;
 8228e54:	e0bffa17 	ldw	r2,-24(fp)
}
 8228e58:	e6fffe04 	addi	sp,fp,-8
 8228e5c:	dfc00317 	ldw	ra,12(sp)
 8228e60:	df000217 	ldw	fp,8(sp)
 8228e64:	dc400117 	ldw	r17,4(sp)
 8228e68:	dc000017 	ldw	r16,0(sp)
 8228e6c:	dec00604 	addi	sp,sp,24
 8228e70:	f800283a 	ret

08228e74 <std_out>:
 *
 * RETURNS: Number of bytes send to standard output. 
 */

int std_out(long s, char * buf, int len)
{
 8228e74:	defffb04 	addi	sp,sp,-20
 8228e78:	dfc00415 	stw	ra,16(sp)
 8228e7c:	df000315 	stw	fp,12(sp)
 8228e80:	df000304 	addi	fp,sp,12
 8228e84:	e13ffd15 	stw	r4,-12(fp)
 8228e88:	e17ffe15 	stw	r5,-8(fp)
 8228e8c:	e1bfff15 	stw	r6,-4(fp)
   /* puts(buf); - This does newline expansion return 
    * write(0,buf,len); - This doesn't printf(buf); - This has 
    * problems when printf format strings (eg %s) is part of data. 
    */
   printf("%s",buf);
 8228e90:	e17ffe17 	ldw	r5,-8(fp)
 8228e94:	01020974 	movhi	r4,2085
 8228e98:	21019e04 	addi	r4,r4,1656
 8228e9c:	820331c0 	call	820331c <printf>
   USE_ARG(s);
   return len;
 8228ea0:	e0bfff17 	ldw	r2,-4(fp)
}
 8228ea4:	e037883a 	mov	sp,fp
 8228ea8:	dfc00117 	ldw	ra,4(sp)
 8228eac:	df000017 	ldw	fp,0(sp)
 8228eb0:	dec00204 	addi	sp,sp,8
 8228eb4:	f800283a 	ret

08228eb8 <con_page>:
 * RETURNS: 1 if we got a break, 0 to keep printing
 */

int
con_page(void * vio, int lines)
{
 8228eb8:	defffa04 	addi	sp,sp,-24
 8228ebc:	dfc00515 	stw	ra,20(sp)
 8228ec0:	df000415 	stw	fp,16(sp)
 8228ec4:	df000404 	addi	fp,sp,16
 8228ec8:	e13ffe15 	stw	r4,-8(fp)
 8228ecc:	e17fff15 	stw	r5,-4(fp)
   int   ch;
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 8228ed0:	e0bffe17 	ldw	r2,-8(fp)
 8228ed4:	e0bffc15 	stw	r2,-16(fp)

   if (lines % 20 == 0)   /* Time to get user input */
 8228ed8:	e0bfff17 	ldw	r2,-4(fp)
 8228edc:	01400504 	movi	r5,20
 8228ee0:	1009883a 	mov	r4,r2
 8228ee4:	8202b180 	call	8202b18 <__modsi3>
 8228ee8:	1000231e 	bne	r2,zero,8228f78 <con_page+0xc0>
   {
      if (pio && pio->getch)   /*if i/p func is supplied*/
 8228eec:	e0bffc17 	ldw	r2,-16(fp)
 8228ef0:	10002126 	beq	r2,zero,8228f78 <con_page+0xc0>
 8228ef4:	e0bffc17 	ldw	r2,-16(fp)
 8228ef8:	10800317 	ldw	r2,12(r2)
 8228efc:	10001e26 	beq	r2,zero,8228f78 <con_page+0xc0>
      {
         ns_printf(pio,"....press any key for more (ESC to break)....");
 8228f00:	01420974 	movhi	r5,2085
 8228f04:	29419f04 	addi	r5,r5,1660
 8228f08:	e13ffc17 	ldw	r4,-16(fp)
 8228f0c:	8228d040 	call	8228d04 <ns_printf>

         do 
         {
            ch = (pio->getch)(pio->id);
 8228f10:	e0bffc17 	ldw	r2,-16(fp)
 8228f14:	10800317 	ldw	r2,12(r2)
 8228f18:	e0fffc17 	ldw	r3,-16(fp)
 8228f1c:	18c00217 	ldw	r3,8(r3)
 8228f20:	1809883a 	mov	r4,r3
 8228f24:	103ee83a 	callr	r2
 8228f28:	e0bffd15 	stw	r2,-12(fp)
            if (ch == 0)
 8228f2c:	e0bffd17 	ldw	r2,-12(fp)
 8228f30:	1000011e 	bne	r2,zero,8228f38 <con_page+0x80>
               tk_yield();    /* Give timeslice to other processes */
 8228f34:	82296b00 	call	82296b0 <tk_yield>
         } while (ch == 0) ;
 8228f38:	e0bffd17 	ldw	r2,-12(fp)
 8228f3c:	103ff426 	beq	r2,zero,8228f10 <con_page+0x58>

            /* if there is fatal error, we don't want to do any I/O */
         if (ch == -1)   /* fatal error */
 8228f40:	e0bffd17 	ldw	r2,-12(fp)
 8228f44:	10bfffd8 	cmpnei	r2,r2,-1
 8228f48:	1000021e 	bne	r2,zero,8228f54 <con_page+0x9c>
            return 1 ;
 8228f4c:	00800044 	movi	r2,1
 8228f50:	00000a06 	br	8228f7c <con_page+0xc4>

         ns_printf(pio,"\n");
 8228f54:	01420974 	movhi	r5,2085
 8228f58:	29418004 	addi	r5,r5,1536
 8228f5c:	e13ffc17 	ldw	r4,-16(fp)
 8228f60:	8228d040 	call	8228d04 <ns_printf>
         if (ch == 27)   /* ESC key pressed */
 8228f64:	e0bffd17 	ldw	r2,-12(fp)
 8228f68:	108006d8 	cmpnei	r2,r2,27
 8228f6c:	1000021e 	bne	r2,zero,8228f78 <con_page+0xc0>
            return 1 ;
 8228f70:	00800044 	movi	r2,1
 8228f74:	00000106 	br	8228f7c <con_page+0xc4>
      }
   }
   return  0;
 8228f78:	0005883a 	mov	r2,zero
}
 8228f7c:	e037883a 	mov	sp,fp
 8228f80:	dfc00117 	ldw	ra,4(sp)
 8228f84:	df000017 	ldw	fp,0(sp)
 8228f88:	dec00204 	addi	sp,sp,8
 8228f8c:	f800283a 	ret

08228f90 <parse_args>:

char **parse_args(char *buf, int argc, int *pargc_index)
{
 8228f90:	defff704 	addi	sp,sp,-36
 8228f94:	dfc00815 	stw	ra,32(sp)
 8228f98:	df000715 	stw	fp,28(sp)
 8228f9c:	df000704 	addi	fp,sp,28
 8228fa0:	e13ffd15 	stw	r4,-12(fp)
 8228fa4:	e17ffe15 	stw	r5,-8(fp)
 8228fa8:	e1bfff15 	stw	r6,-4(fp)
   /* This routine assumes buf is a null terminated string */
   int i;
   int len;
   char *bp = buf;
 8228fac:	e0bffd17 	ldw	r2,-12(fp)
 8228fb0:	e0bffa15 	stw	r2,-24(fp)
   char **pargv = NULL;
 8228fb4:	e03ffb15 	stw	zero,-20(fp)
   *pargc_index = 0;
 8228fb8:	e0bfff17 	ldw	r2,-4(fp)
 8228fbc:	10000015 	stw	zero,0(r2)
   if (buf == NULL)
 8228fc0:	e0bffd17 	ldw	r2,-12(fp)
 8228fc4:	1000021e 	bne	r2,zero,8228fd0 <parse_args+0x40>
   {
      return (NULL);
 8228fc8:	0005883a 	mov	r2,zero
 8228fcc:	00006c06 	br	8229180 <parse_args+0x1f0>
   }
   len = strlen(buf);
 8228fd0:	e13ffd17 	ldw	r4,-12(fp)
 8228fd4:	8203edc0 	call	8203edc <strlen>
 8228fd8:	e0bffc15 	stw	r2,-16(fp)
   if (len <= 0)
 8228fdc:	e0bffc17 	ldw	r2,-16(fp)
 8228fe0:	00800216 	blt	zero,r2,8228fec <parse_args+0x5c>
   {
      return (NULL);
 8228fe4:	0005883a 	mov	r2,zero
 8228fe8:	00006506 	br	8229180 <parse_args+0x1f0>
   }
   pargv = (char **) npalloc(argc * sizeof(char *));
 8228fec:	e0bffe17 	ldw	r2,-8(fp)
 8228ff0:	1085883a 	add	r2,r2,r2
 8228ff4:	1085883a 	add	r2,r2,r2
 8228ff8:	1009883a 	mov	r4,r2
 8228ffc:	822dfec0 	call	822dfec <npalloc>
 8229000:	e0bffb15 	stw	r2,-20(fp)
   if (pargv == NULL)
 8229004:	e0bffb17 	ldw	r2,-20(fp)
 8229008:	1000051e 	bne	r2,zero,8229020 <parse_args+0x90>
   {
      return (NULL);
 822900c:	0005883a 	mov	r2,zero
 8229010:	00005b06 	br	8229180 <parse_args+0x1f0>
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
 8229014:	e0bffa17 	ldw	r2,-24(fp)
 8229018:	10800044 	addi	r2,r2,1
 822901c:	e0bffa15 	stw	r2,-24(fp)
   if (pargv == NULL)
   {
      return (NULL);
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
 8229020:	e0bffa17 	ldw	r2,-24(fp)
 8229024:	10800003 	ldbu	r2,0(r2)
 8229028:	10803fcc 	andi	r2,r2,255
 822902c:	1080201c 	xori	r2,r2,128
 8229030:	10bfe004 	addi	r2,r2,-128
 8229034:	10800820 	cmpeqi	r2,r2,32
 8229038:	103ff61e 	bne	r2,zero,8229014 <parse_args+0x84>
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 822903c:	00003006 	br	8229100 <parse_args+0x170>
   {
      pargv[(*pargc_index)] = bp;
 8229040:	e0bfff17 	ldw	r2,-4(fp)
 8229044:	10800017 	ldw	r2,0(r2)
 8229048:	1085883a 	add	r2,r2,r2
 822904c:	1085883a 	add	r2,r2,r2
 8229050:	1007883a 	mov	r3,r2
 8229054:	e0bffb17 	ldw	r2,-20(fp)
 8229058:	10c5883a 	add	r2,r2,r3
 822905c:	e0fffa17 	ldw	r3,-24(fp)
 8229060:	10c00015 	stw	r3,0(r2)
      (*pargc_index)++;
 8229064:	e0bfff17 	ldw	r2,-4(fp)
 8229068:	10800017 	ldw	r2,0(r2)
 822906c:	10c00044 	addi	r3,r2,1
 8229070:	e0bfff17 	ldw	r2,-4(fp)
 8229074:	10c00015 	stw	r3,0(r2)
      while (*bp != ' ' && *bp != '\0')
 8229078:	00000306 	br	8229088 <parse_args+0xf8>
      {
         bp++; 
 822907c:	e0bffa17 	ldw	r2,-24(fp)
 8229080:	10800044 	addi	r2,r2,1
 8229084:	e0bffa15 	stw	r2,-24(fp)
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
   {
      pargv[(*pargc_index)] = bp;
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
 8229088:	e0bffa17 	ldw	r2,-24(fp)
 822908c:	10800003 	ldbu	r2,0(r2)
 8229090:	10803fcc 	andi	r2,r2,255
 8229094:	1080201c 	xori	r2,r2,128
 8229098:	10bfe004 	addi	r2,r2,-128
 822909c:	10800820 	cmpeqi	r2,r2,32
 82290a0:	10000a1e 	bne	r2,zero,82290cc <parse_args+0x13c>
 82290a4:	e0bffa17 	ldw	r2,-24(fp)
 82290a8:	10800003 	ldbu	r2,0(r2)
 82290ac:	10803fcc 	andi	r2,r2,255
 82290b0:	1080201c 	xori	r2,r2,128
 82290b4:	10bfe004 	addi	r2,r2,-128
 82290b8:	103ff01e 	bne	r2,zero,822907c <parse_args+0xec>
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 82290bc:	00000306 	br	82290cc <parse_args+0x13c>
      {
         bp++; 
 82290c0:	e0bffa17 	ldw	r2,-24(fp)
 82290c4:	10800044 	addi	r2,r2,1
 82290c8:	e0bffa15 	stw	r2,-24(fp)
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 82290cc:	e0bffa17 	ldw	r2,-24(fp)
 82290d0:	10800003 	ldbu	r2,0(r2)
 82290d4:	10803fcc 	andi	r2,r2,255
 82290d8:	1080201c 	xori	r2,r2,128
 82290dc:	10bfe004 	addi	r2,r2,-128
 82290e0:	10800818 	cmpnei	r2,r2,32
 82290e4:	1000061e 	bne	r2,zero,8229100 <parse_args+0x170>
 82290e8:	e0bffa17 	ldw	r2,-24(fp)
 82290ec:	10800003 	ldbu	r2,0(r2)
 82290f0:	10803fcc 	andi	r2,r2,255
 82290f4:	1080201c 	xori	r2,r2,128
 82290f8:	10bfe004 	addi	r2,r2,-128
 82290fc:	103ff01e 	bne	r2,zero,82290c0 <parse_args+0x130>
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 8229100:	e0bffa17 	ldw	r2,-24(fp)
 8229104:	10800003 	ldbu	r2,0(r2)
 8229108:	10803fcc 	andi	r2,r2,255
 822910c:	1080201c 	xori	r2,r2,128
 8229110:	10bfe004 	addi	r2,r2,-128
 8229114:	10000426 	beq	r2,zero,8229128 <parse_args+0x198>
 8229118:	e0bfff17 	ldw	r2,-4(fp)
 822911c:	10c00017 	ldw	r3,0(r2)
 8229120:	e0bffe17 	ldw	r2,-8(fp)
 8229124:	18bfc616 	blt	r3,r2,8229040 <parse_args+0xb0>
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 8229128:	e03ff915 	stw	zero,-28(fp)
 822912c:	00001006 	br	8229170 <parse_args+0x1e0>
   {
      if (buf[i] == ' ')
 8229130:	e0bff917 	ldw	r2,-28(fp)
 8229134:	e0fffd17 	ldw	r3,-12(fp)
 8229138:	1885883a 	add	r2,r3,r2
 822913c:	10800003 	ldbu	r2,0(r2)
 8229140:	10803fcc 	andi	r2,r2,255
 8229144:	1080201c 	xori	r2,r2,128
 8229148:	10bfe004 	addi	r2,r2,-128
 822914c:	10800818 	cmpnei	r2,r2,32
 8229150:	1000041e 	bne	r2,zero,8229164 <parse_args+0x1d4>
         buf[i] = '\0';
 8229154:	e0bff917 	ldw	r2,-28(fp)
 8229158:	e0fffd17 	ldw	r3,-12(fp)
 822915c:	1885883a 	add	r2,r3,r2
 8229160:	10000005 	stb	zero,0(r2)
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 8229164:	e0bff917 	ldw	r2,-28(fp)
 8229168:	10800044 	addi	r2,r2,1
 822916c:	e0bff915 	stw	r2,-28(fp)
 8229170:	e0fff917 	ldw	r3,-28(fp)
 8229174:	e0bffc17 	ldw	r2,-16(fp)
 8229178:	18bfed16 	blt	r3,r2,8229130 <parse_args+0x1a0>
   {
      printf("pargv[%d] = %s\n", i, pargv[i]);
   }
#endif

   return (pargv);
 822917c:	e0bffb17 	ldw	r2,-20(fp)
}
 8229180:	e037883a 	mov	sp,fp
 8229184:	dfc00117 	ldw	ra,4(sp)
 8229188:	df000017 	ldw	fp,0(sp)
 822918c:	dec00204 	addi	sp,sp,8
 8229190:	f800283a 	ret

08229194 <netmain>:
 * RETURNS: 
 */

int
netmain(void)
{
 8229194:	defffc04 	addi	sp,sp,-16
 8229198:	dfc00315 	stw	ra,12(sp)
 822919c:	df000215 	stw	fp,8(sp)
 82291a0:	df000204 	addi	fp,sp,8
   int   i;
   int   e;

   iniche_net_ready = FALSE;
 82291a4:	d0208c15 	stw	zero,-32208(gp)

   e = prep_modules();
 82291a8:	823d21c0 	call	823d21c <prep_modules>
 82291ac:	e0bfff15 	stw	r2,-4(fp)

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 82291b0:	e03ffe15 	stw	zero,-8(fp)
 82291b4:	00001a06 	br	8229220 <netmain+0x8c>
   {
      e = TK_NEWTASK(&nettasks[i]);
 82291b8:	e0bffe17 	ldw	r2,-8(fp)
 82291bc:	10c00624 	muli	r3,r2,24
 82291c0:	00820974 	movhi	r2,2085
 82291c4:	108eae04 	addi	r2,r2,15032
 82291c8:	1885883a 	add	r2,r3,r2
 82291cc:	1009883a 	mov	r4,r2
 82291d0:	822d7dc0 	call	822d7dc <TK_NEWTASK>
 82291d4:	e0bfff15 	stw	r2,-4(fp)
      if (e != 0)
 82291d8:	e0bfff17 	ldw	r2,-4(fp)
 82291dc:	10000d26 	beq	r2,zero,8229214 <netmain+0x80>
      {
         dprintf("task create error\n");
 82291e0:	01020974 	movhi	r4,2085
 82291e4:	2101b104 	addi	r4,r4,1732
 82291e8:	82035a00 	call	82035a0 <puts>
         panic((char *)&nettasks[i].name);
 82291ec:	e0bffe17 	ldw	r2,-8(fp)
 82291f0:	10800624 	muli	r2,r2,24
 82291f4:	10c00104 	addi	r3,r2,4
 82291f8:	00820974 	movhi	r2,2085
 82291fc:	108eae04 	addi	r2,r2,15032
 8229200:	1885883a 	add	r2,r3,r2
 8229204:	1009883a 	mov	r4,r2
 8229208:	8228aec0 	call	8228aec <panic>
         return -1;  /* compiler warnings */
 822920c:	00bfffc4 	movi	r2,-1
 8229210:	00001306 	br	8229260 <netmain+0xcc>
   iniche_net_ready = FALSE;

   e = prep_modules();

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 8229214:	e0bffe17 	ldw	r2,-8(fp)
 8229218:	10800044 	addi	r2,r2,1
 822921c:	e0bffe15 	stw	r2,-8(fp)
 8229220:	d0a03217 	ldw	r2,-32568(gp)
 8229224:	e0fffe17 	ldw	r3,-8(fp)
 8229228:	18bfe316 	blt	r3,r2,82291b8 <netmain+0x24>
         panic((char *)&nettasks[i].name);
         return -1;  /* compiler warnings */
      }
   }
   
   e = create_apptasks();
 822922c:	823d6840 	call	823d684 <create_apptasks>
 8229230:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0) 
 8229234:	e0bfff17 	ldw	r2,-4(fp)
 8229238:	10000826 	beq	r2,zero,822925c <netmain+0xc8>
   {
      dprintf("task create error\n");
 822923c:	01020974 	movhi	r4,2085
 8229240:	2101b104 	addi	r4,r4,1732
 8229244:	82035a00 	call	82035a0 <puts>
      panic("netmain");
 8229248:	01020974 	movhi	r4,2085
 822924c:	2101b604 	addi	r4,r4,1752
 8229250:	8228aec0 	call	8228aec <panic>
      return -1;  /* compiler warnings */
 8229254:	00bfffc4 	movi	r2,-1
 8229258:	00000106 	br	8229260 <netmain+0xcc>
#ifdef MAIN_TASK_IS_NET
   tk_netmain(TK_NETMAINPARM);
   panic("net task return");
   return -1;
#else
   return 0;
 822925c:	0005883a 	mov	r2,zero
#endif
#endif   /* NO_INET_STACK */
}
 8229260:	e037883a 	mov	sp,fp
 8229264:	dfc00117 	ldw	ra,4(sp)
 8229268:	df000017 	ldw	fp,0(sp)
 822926c:	dec00204 	addi	sp,sp,8
 8229270:	f800283a 	ret

08229274 <tk_netmain>:
 * RETURNS: n/a
 */

#ifndef NO_INET_STACK
TK_ENTRY(tk_netmain)
{
 8229274:	defffc04 	addi	sp,sp,-16
 8229278:	dfc00315 	stw	ra,12(sp)
 822927c:	df000215 	stw	fp,8(sp)
 8229280:	df000204 	addi	fp,sp,8
 8229284:	e13fff15 	stw	r4,-4(fp)
   netmain_init(); /* initialize all modules */
 8229288:	823ce840 	call	823ce84 <netmain_init>

   iniche_net_ready = TRUE;    /* let the other threads spin */
 822928c:	00800044 	movi	r2,1
 8229290:	d0a08c15 	stw	r2,-32208(gp)

   for (;;)
   {
      TK_NETRX_BLOCK();
 8229294:	d0a0ab17 	ldw	r2,-32084(gp)
 8229298:	e1bffe04 	addi	r6,fp,-8
 822929c:	01401904 	movi	r5,100
 82292a0:	1009883a 	mov	r4,r2
 82292a4:	821a0380 	call	821a038 <OSSemPend>
 82292a8:	e0bffe03 	ldbu	r2,-8(fp)
 82292ac:	10803fcc 	andi	r2,r2,255
 82292b0:	10000526 	beq	r2,zero,82292c8 <tk_netmain+0x54>
 82292b4:	e0bffe03 	ldbu	r2,-8(fp)
 82292b8:	10803fcc 	andi	r2,r2,255
 82292bc:	108002a0 	cmpeqi	r2,r2,10
 82292c0:	1000011e 	bne	r2,zero,82292c8 <tk_netmain+0x54>
 82292c4:	822d4140 	call	822d414 <dtrap>
      netmain_wakes++;  /* count wakeups */
 82292c8:	d0a08a17 	ldw	r2,-32216(gp)
 82292cc:	10800044 	addi	r2,r2,1
 82292d0:	d0a08a15 	stw	r2,-32216(gp)

      /* see if there's newly received network packets */
      if (rcvdq.q_len)
 82292d4:	008209b4 	movhi	r2,2086
 82292d8:	10b75f04 	addi	r2,r2,-8836
 82292dc:	10800217 	ldw	r2,8(r2)
 82292e0:	103fec26 	beq	r2,zero,8229294 <tk_netmain+0x20>
         pktdemux();
 82292e4:	82262000 	call	8226200 <pktdemux>
       * vital to a clean shutdown 
       */
#ifdef USE_LCD
      update_display();
#endif
   }
 82292e8:	003fea06 	br	8229294 <tk_netmain+0x20>

082292ec <tk_nettick>:
extern   int dhc_second(void);
#endif

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
 82292ec:	defffd04 	addi	sp,sp,-12
 82292f0:	dfc00215 	stw	ra,8(sp)
 82292f4:	df000115 	stw	fp,4(sp)
 82292f8:	df000104 	addi	fp,sp,4
 82292fc:	e13fff15 	stw	r4,-4(fp)
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 8229300:	00000306 	br	8229310 <tk_nettick+0x24>
       * request and then we receive a NAK. At this point the DHCP
       * client is reset to INIT state and dhc_second() needs to be
       * run to restart it.
       */
#ifdef DHCP_CLIENT
      dhc_second();
 8229304:	822bb900 	call	822bb90 <dhc_second>
#endif
      TK_SLEEP(1);
 8229308:	01000084 	movi	r4,2
 822930c:	821be3c0 	call	821be3c <OSTimeDly>

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 8229310:	d0a08c17 	ldw	r2,-32208(gp)
 8229314:	103ffb26 	beq	r2,zero,8229304 <tk_nettick+0x18>
      TK_SLEEP(1);
   }

   for (;;)
   {
      TK_SLEEP(SYS_SHORT_SLEEP);
 8229318:	01000084 	movi	r4,2
 822931c:	821be3c0 	call	821be3c <OSTimeDly>
      nettick_wakes++;  /* count wakeups */
 8229320:	d0a08b17 	ldw	r2,-32212(gp)
 8229324:	10800044 	addi	r2,r2,1
 8229328:	d0a08b15 	stw	r2,-32212(gp)
      inet_timer();  /* let various timeouts occur */
 822932c:	823d2700 	call	823d270 <inet_timer>
      /* do not kill timers on net_system_exit. They may be
       * vital to a clean shutdown 
       */
   }
 8229330:	003ff906 	br	8229318 <tk_nettick+0x2c>

08229334 <TK_OSTimeDly>:
u_char   TK_OSTaskQuery(void);



void TK_OSTimeDly(void)
{
 8229334:	defffe04 	addi	sp,sp,-8
 8229338:	dfc00115 	stw	ra,4(sp)
 822933c:	df000015 	stw	fp,0(sp)
 8229340:	d839883a 	mov	fp,sp
   OSTimeDly(2);
 8229344:	01000084 	movi	r4,2
 8229348:	821be3c0 	call	821be3c <OSTimeDly>
}
 822934c:	0001883a 	nop
 8229350:	e037883a 	mov	sp,fp
 8229354:	dfc00117 	ldw	ra,4(sp)
 8229358:	df000017 	ldw	fp,0(sp)
 822935c:	dec00204 	addi	sp,sp,8
 8229360:	f800283a 	ret

08229364 <TK_OSTaskResume>:



void TK_OSTaskResume(u_char * Id)
{
 8229364:	defffc04 	addi	sp,sp,-16
 8229368:	dfc00315 	stw	ra,12(sp)
 822936c:	df000215 	stw	fp,8(sp)
 8229370:	df000204 	addi	fp,sp,8
 8229374:	e13fff15 	stw	r4,-4(fp)
INT8U err;

   err = OSTaskResume(*Id);
 8229378:	e0bfff17 	ldw	r2,-4(fp)
 822937c:	10800003 	ldbu	r2,0(r2)
 8229380:	10803fcc 	andi	r2,r2,255
 8229384:	1009883a 	mov	r4,r2
 8229388:	821b7300 	call	821b730 <OSTaskResume>
 822938c:	e0bffe05 	stb	r2,-8(fp)
   
#ifdef NPDEBUG
   if ((err != OS_NO_ERR) && (err != OS_TASK_NOT_SUSPENDED))
 8229390:	e0bffe03 	ldbu	r2,-8(fp)
 8229394:	10000a26 	beq	r2,zero,82293c0 <TK_OSTaskResume+0x5c>
 8229398:	e0bffe03 	ldbu	r2,-8(fp)
 822939c:	10801120 	cmpeqi	r2,r2,68
 82293a0:	1000071e 	bne	r2,zero,82293c0 <TK_OSTaskResume+0x5c>
   {
      dprintf("ChronOS API call failure, to Resume Suspended Task!\n");
 82293a4:	01020974 	movhi	r4,2085
 82293a8:	2101b804 	addi	r4,r4,1760
 82293ac:	82035a00 	call	82035a0 <puts>
      dtrap();
 82293b0:	822d4140 	call	822d414 <dtrap>
      panic("TK_OSTaskResume");      
 82293b4:	01020974 	movhi	r4,2085
 82293b8:	2101c504 	addi	r4,r4,1812
 82293bc:	8228aec0 	call	8228aec <panic>
   }
#endif
}
 82293c0:	0001883a 	nop
 82293c4:	e037883a 	mov	sp,fp
 82293c8:	dfc00117 	ldw	ra,4(sp)
 82293cc:	df000017 	ldw	fp,0(sp)
 82293d0:	dec00204 	addi	sp,sp,8
 82293d4:	f800283a 	ret

082293d8 <tcp_sleep>:
 *
 * RETURN: none
 */
void
tcp_sleep(void * event)
{
 82293d8:	defffb04 	addi	sp,sp,-20
 82293dc:	dfc00415 	stw	ra,16(sp)
 82293e0:	df000315 	stw	fp,12(sp)
 82293e4:	df000304 	addi	fp,sp,12
 82293e8:	e13fff15 	stw	r4,-4(fp)
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 82293ec:	e03ffd15 	stw	zero,-12(fp)
 82293f0:	00004706 	br	8229510 <tcp_sleep+0x138>
   {
      if (global_TCPwakeup_set[i].soc_event == NULL)
 82293f4:	008209b4 	movhi	r2,2086
 82293f8:	10b90f04 	addi	r2,r2,-7108
 82293fc:	e0fffd17 	ldw	r3,-12(fp)
 8229400:	18c00324 	muli	r3,r3,12
 8229404:	10c5883a 	add	r2,r2,r3
 8229408:	10800104 	addi	r2,r2,4
 822940c:	10800017 	ldw	r2,0(r2)
 8229410:	10003c1e 	bne	r2,zero,8229504 <tcp_sleep+0x12c>
      {
         global_TCPwakeup_set[i].soc_event = event;
 8229414:	008209b4 	movhi	r2,2086
 8229418:	10b90f04 	addi	r2,r2,-7108
 822941c:	e0fffd17 	ldw	r3,-12(fp)
 8229420:	18c00324 	muli	r3,r3,12
 8229424:	10c5883a 	add	r2,r2,r3
 8229428:	10800104 	addi	r2,r2,4
 822942c:	e0ffff17 	ldw	r3,-4(fp)
 8229430:	10c00015 	stw	r3,0(r2)
         global_TCPwakeup_set[i].ctick = cticks;
 8229434:	d0e0a817 	ldw	r3,-32096(gp)
 8229438:	008209b4 	movhi	r2,2086
 822943c:	10b90f04 	addi	r2,r2,-7108
 8229440:	e13ffd17 	ldw	r4,-12(fp)
 8229444:	21000324 	muli	r4,r4,12
 8229448:	1105883a 	add	r2,r2,r4
 822944c:	10c00015 	stw	r3,0(r2)
         if (i > global_TCPwakeup_setIndx)
 8229450:	d0e0a717 	ldw	r3,-32100(gp)
 8229454:	e0bffd17 	ldw	r2,-12(fp)
 8229458:	1880020e 	bge	r3,r2,8229464 <tcp_sleep+0x8c>
            global_TCPwakeup_setIndx = i;
 822945c:	e0bffd17 	ldw	r2,-12(fp)
 8229460:	d0a0a715 	stw	r2,-32100(gp)

         tcp_sleep_count++;
 8229464:	d0a0a317 	ldw	r2,-32116(gp)
 8229468:	10800044 	addi	r2,r2,1
 822946c:	d0a0a315 	stw	r2,-32116(gp)

         /* Give up the lock before going to sleep. This can
          * potentially cause a context switch to the task
          * signaling the event.
          */
         UNLOCK_NET_RESOURCE(NET_RESID);
 8229470:	0009883a 	mov	r4,zero
 8229474:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

         /* don't wait forever in case we miss the event */
         OSSemPend(global_TCPwakeup_set[i].semaphore, TPS, &err);
 8229478:	008209b4 	movhi	r2,2086
 822947c:	10b90f04 	addi	r2,r2,-7108
 8229480:	e0fffd17 	ldw	r3,-12(fp)
 8229484:	18c00324 	muli	r3,r3,12
 8229488:	10c5883a 	add	r2,r2,r3
 822948c:	10800204 	addi	r2,r2,8
 8229490:	10800017 	ldw	r2,0(r2)
 8229494:	e0fffe04 	addi	r3,fp,-8
 8229498:	180d883a 	mov	r6,r3
 822949c:	01401904 	movi	r5,100
 82294a0:	1009883a 	mov	r4,r2
 82294a4:	821a0380 	call	821a038 <OSSemPend>
         if (err == 10)
 82294a8:	e0bffe03 	ldbu	r2,-8(fp)
 82294ac:	10803fcc 	andi	r2,r2,255
 82294b0:	10800298 	cmpnei	r2,r2,10
 82294b4:	1000101e 	bne	r2,zero,82294f8 <tcp_sleep+0x120>
         {
            ++tcp_sleep_timeout;
 82294b8:	d0a08e17 	ldw	r2,-32200(gp)
 82294bc:	10800044 	addi	r2,r2,1
 82294c0:	d0a08e15 	stw	r2,-32200(gp)

            /* clear the entry */
            global_TCPwakeup_set[i].ctick = 0;
 82294c4:	008209b4 	movhi	r2,2086
 82294c8:	10b90f04 	addi	r2,r2,-7108
 82294cc:	e0fffd17 	ldw	r3,-12(fp)
 82294d0:	18c00324 	muli	r3,r3,12
 82294d4:	10c5883a 	add	r2,r2,r3
 82294d8:	10000015 	stw	zero,0(r2)
            global_TCPwakeup_set[i].soc_event = NULL;
 82294dc:	008209b4 	movhi	r2,2086
 82294e0:	10b90f04 	addi	r2,r2,-7108
 82294e4:	e0fffd17 	ldw	r3,-12(fp)
 82294e8:	18c00324 	muli	r3,r3,12
 82294ec:	10c5883a 	add	r2,r2,r3
 82294f0:	10800104 	addi	r2,r2,4
 82294f4:	10000015 	stw	zero,0(r2)
         }

         /* Regain the lock */
         LOCK_NET_RESOURCE(NET_RESID);
 82294f8:	0009883a 	mov	r4,zero
 82294fc:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
 8229500:	00000d06 	br	8229538 <tcp_sleep+0x160>
tcp_sleep(void * event)
{
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 8229504:	e0bffd17 	ldw	r2,-12(fp)
 8229508:	10800044 	addi	r2,r2,1
 822950c:	e0bffd15 	stw	r2,-12(fp)
 8229510:	e0bffd17 	ldw	r2,-12(fp)
 8229514:	10800510 	cmplti	r2,r2,20
 8229518:	103fb61e 	bne	r2,zero,82293f4 <tcp_sleep+0x1c>

   /* The table is full. Try calling TK_YIELD() and hope for the best.
    * The user should increase the size of the table.
    * We'll record the max index for debugging purposes.
    */
   global_TCPwakeup_setIndx = i;
 822951c:	e0bffd17 	ldw	r2,-12(fp)
 8229520:	d0a0a715 	stw	r2,-32100(gp)

   UNLOCK_NET_RESOURCE(NET_RESID);
 8229524:	0009883a 	mov	r4,zero
 8229528:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   TK_YIELD();
 822952c:	82296b00 	call	82296b0 <tk_yield>
   LOCK_NET_RESOURCE(NET_RESID);
 8229530:	0009883a 	mov	r4,zero
 8229534:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
}
 8229538:	e037883a 	mov	sp,fp
 822953c:	dfc00117 	ldw	ra,4(sp)
 8229540:	df000017 	ldw	fp,0(sp)
 8229544:	dec00204 	addi	sp,sp,8
 8229548:	f800283a 	ret

0822954c <tcp_wakeup>:
 *
 * RETURN: none
 */
void
tcp_wakeup(void *event)
{
 822954c:	defffc04 	addi	sp,sp,-16
 8229550:	dfc00315 	stw	ra,12(sp)
 8229554:	df000215 	stw	fp,8(sp)
 8229558:	df000204 	addi	fp,sp,8
 822955c:	e13fff15 	stw	r4,-4(fp)
   int i;

   OSSchedLock();
 8229560:	821556c0 	call	821556c <OSSchedLock>

   for (i = 0; i < GLOBWAKE_SZ; i++)
 8229564:	e03ffe15 	stw	zero,-8(fp)
 8229568:	00002c06 	br	822961c <tcp_wakeup+0xd0>
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 822956c:	008209b4 	movhi	r2,2086
 8229570:	10b90f04 	addi	r2,r2,-7108
 8229574:	e0fffe17 	ldw	r3,-8(fp)
 8229578:	18c00324 	muli	r3,r3,12
 822957c:	10c5883a 	add	r2,r2,r3
 8229580:	10800017 	ldw	r2,0(r2)
 8229584:	10002226 	beq	r2,zero,8229610 <tcp_wakeup+0xc4>
          (global_TCPwakeup_set[i].soc_event == event))
 8229588:	008209b4 	movhi	r2,2086
 822958c:	10b90f04 	addi	r2,r2,-7108
 8229590:	e0fffe17 	ldw	r3,-8(fp)
 8229594:	18c00324 	muli	r3,r3,12
 8229598:	10c5883a 	add	r2,r2,r3
 822959c:	10800104 	addi	r2,r2,4
 82295a0:	10c00017 	ldw	r3,0(r2)

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 82295a4:	e0bfff17 	ldw	r2,-4(fp)
 82295a8:	1880191e 	bne	r3,r2,8229610 <tcp_wakeup+0xc4>
          (global_TCPwakeup_set[i].soc_event == event))
      {
         /* signal the event */
         OSSemPost(global_TCPwakeup_set[i].semaphore);
 82295ac:	008209b4 	movhi	r2,2086
 82295b0:	10b90f04 	addi	r2,r2,-7108
 82295b4:	e0fffe17 	ldw	r3,-8(fp)
 82295b8:	18c00324 	muli	r3,r3,12
 82295bc:	10c5883a 	add	r2,r2,r3
 82295c0:	10800204 	addi	r2,r2,8
 82295c4:	10800017 	ldw	r2,0(r2)
 82295c8:	1009883a 	mov	r4,r2
 82295cc:	821a3b00 	call	821a3b0 <OSSemPost>

         /* clear the entry */
         global_TCPwakeup_set[i].ctick = 0;
 82295d0:	008209b4 	movhi	r2,2086
 82295d4:	10b90f04 	addi	r2,r2,-7108
 82295d8:	e0fffe17 	ldw	r3,-8(fp)
 82295dc:	18c00324 	muli	r3,r3,12
 82295e0:	10c5883a 	add	r2,r2,r3
 82295e4:	10000015 	stw	zero,0(r2)
         global_TCPwakeup_set[i].soc_event = NULL;
 82295e8:	008209b4 	movhi	r2,2086
 82295ec:	10b90f04 	addi	r2,r2,-7108
 82295f0:	e0fffe17 	ldw	r3,-8(fp)
 82295f4:	18c00324 	muli	r3,r3,12
 82295f8:	10c5883a 	add	r2,r2,r3
 82295fc:	10800104 	addi	r2,r2,4
 8229600:	10000015 	stw	zero,0(r2)

         tcp_wakeup_count++;
 8229604:	d0a0a417 	ldw	r2,-32112(gp)
 8229608:	10800044 	addi	r2,r2,1
 822960c:	d0a0a415 	stw	r2,-32112(gp)
{
   int i;

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
 8229610:	e0bffe17 	ldw	r2,-8(fp)
 8229614:	10800044 	addi	r2,r2,1
 8229618:	e0bffe15 	stw	r2,-8(fp)
 822961c:	e0bffe17 	ldw	r2,-8(fp)
 8229620:	10800510 	cmplti	r2,r2,20
 8229624:	103fd11e 	bne	r2,zero,822956c <tcp_wakeup+0x20>

         tcp_wakeup_count++;
      }
   }

   OSSchedUnlock();
 8229628:	82155f80 	call	82155f8 <OSSchedUnlock>
}
 822962c:	0001883a 	nop
 8229630:	e037883a 	mov	sp,fp
 8229634:	dfc00117 	ldw	ra,4(sp)
 8229638:	df000017 	ldw	fp,0(sp)
 822963c:	dec00204 	addi	sp,sp,8
 8229640:	f800283a 	ret

08229644 <TK_OSTaskQuery>:



u_char TK_OSTaskQuery(void)
{
 8229644:	deffe204 	addi	sp,sp,-120
 8229648:	dfc01d15 	stw	ra,116(sp)
 822964c:	df001c15 	stw	fp,112(sp)
 8229650:	df001c04 	addi	fp,sp,112
   OS_TCB task_data;
   INT8U err, task_prio;

   err = OSTaskQuery(OS_PRIO_SELF, &task_data);
 8229654:	e0bfe504 	addi	r2,fp,-108
 8229658:	100b883a 	mov	r5,r2
 822965c:	01003fc4 	movi	r4,255
 8229660:	821bca80 	call	821bca8 <OSTaskQuery>
 8229664:	e0bfe405 	stb	r2,-112(fp)

   if (err == OS_NO_ERR)
 8229668:	e0bfe403 	ldbu	r2,-112(fp)
 822966c:	1000041e 	bne	r2,zero,8229680 <TK_OSTaskQuery+0x3c>
   {
      task_prio = task_data.OSTCBPrio;
 8229670:	e0bff183 	ldbu	r2,-58(fp)
 8229674:	e0bfe445 	stb	r2,-111(fp)
      dprintf("ChronOS API call failure, unable to identify task!");
      panic("TK_OSTaskQuery");
      return 0;
   }
   
   return task_prio;
 8229678:	e0bfe443 	ldbu	r2,-111(fp)
 822967c:	00000706 	br	822969c <TK_OSTaskQuery+0x58>
   {
      task_prio = task_data.OSTCBPrio;
   }
   else
   {
      dprintf("ChronOS API call failure, unable to identify task!");
 8229680:	01020974 	movhi	r4,2085
 8229684:	2101c904 	addi	r4,r4,1828
 8229688:	820331c0 	call	820331c <printf>
      panic("TK_OSTaskQuery");
 822968c:	01020974 	movhi	r4,2085
 8229690:	2101d604 	addi	r4,r4,1880
 8229694:	8228aec0 	call	8228aec <panic>
      return 0;
 8229698:	0005883a 	mov	r2,zero
   }
   
   return task_prio;
}
 822969c:	e037883a 	mov	sp,fp
 82296a0:	dfc00117 	ldw	ra,4(sp)
 82296a4:	df000017 	ldw	fp,0(sp)
 82296a8:	dec00204 	addi	sp,sp,8
 82296ac:	f800283a 	ret

082296b0 <tk_yield>:



void
tk_yield(void)
{
 82296b0:	defffe04 	addi	sp,sp,-8
 82296b4:	dfc00115 	stw	ra,4(sp)
 82296b8:	df000015 	stw	fp,0(sp)
 82296bc:	d839883a 	mov	fp,sp
   /* To ensure cycles to the lower priority tasks we should really
    * delay by two ticks, but that really hurts performance on some
    * long-tick targets. One tick works better overall....
    */
   OSTimeDly(1);
 82296c0:	01000044 	movi	r4,1
 82296c4:	821be3c0 	call	821be3c <OSTimeDly>
}
 82296c8:	0001883a 	nop
 82296cc:	e037883a 	mov	sp,fp
 82296d0:	dfc00117 	ldw	ra,4(sp)
 82296d4:	df000017 	ldw	fp,0(sp)
 82296d8:	dec00204 	addi	sp,sp,8
 82296dc:	f800283a 	ret

082296e0 <tk_stats>:
extern struct inet_taskinfo * nettask;
extern int num_net_tasks;

int
tk_stats(void * pio)
{
 82296e0:	deffef04 	addi	sp,sp,-68
 82296e4:	dfc01015 	stw	ra,64(sp)
 82296e8:	df000f15 	stw	fp,60(sp)
 82296ec:	df000f04 	addi	fp,sp,60
 82296f0:	e13fff15 	stw	r4,-4(fp)
   int      stackuse;
   char     name[OS_TASK_NAME_SIZE+1];
   INT8U    err;
   

   ns_printf(pio, "ChronOS RTOS stats:\n");
 82296f4:	01420974 	movhi	r5,2085
 82296f8:	2941da04 	addi	r5,r5,1896
 82296fc:	e13fff17 	ldw	r4,-4(fp)
 8229700:	8228d040 	call	8228d04 <ns_printf>

#ifdef NO_INICHE_EXTENSIONS
   ns_printf(pio, "Context switches; Delay:  %lu\n",
 8229704:	d0a07017 	ldw	r2,-32320(gp)
 8229708:	100d883a 	mov	r6,r2
 822970c:	01420974 	movhi	r5,2085
 8229710:	2941e004 	addi	r5,r5,1920
 8229714:	e13fff17 	ldw	r4,-4(fp)
 8229718:	8228d040 	call	8228d04 <ns_printf>
#else
   ns_printf(pio, "Context switches; Delay:  %lu, Interrupt: %lu\n",
      OSCtxSwCtr, OSCtxIntCtr);
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");
 822971c:	01420974 	movhi	r5,2085
 8229720:	2941e804 	addi	r5,r5,1952
 8229724:	e13fff17 	ldw	r4,-4(fp)
 8229728:	8228d040 	call	8228d04 <ns_printf>

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 822972c:	e03ff215 	stw	zero,-56(fp)
 8229730:	00005406 	br	8229884 <tk_stats+0x1a4>
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
 8229734:	008209b4 	movhi	r2,2086
 8229738:	10b6b204 	addi	r2,r2,-9528
 822973c:	e0fff217 	ldw	r3,-56(fp)
 8229740:	18c7883a 	add	r3,r3,r3
 8229744:	18c7883a 	add	r3,r3,r3
 8229748:	10c5883a 	add	r2,r2,r3
 822974c:	10800017 	ldw	r2,0(r2)
 8229750:	e0bff415 	stw	r2,-48(fp)
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
 8229754:	e0bff417 	ldw	r2,-48(fp)
 8229758:	10004626 	beq	r2,zero,8229874 <tk_stats+0x194>
 822975c:	e0bff417 	ldw	r2,-48(fp)
 8229760:	10800058 	cmpnei	r2,r2,1
 8229764:	10004326 	beq	r2,zero,8229874 <tk_stats+0x194>
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);
 8229768:	e0bff417 	ldw	r2,-48(fp)
 822976c:	10800c83 	ldbu	r2,50(r2)
 8229770:	10803fcc 	andi	r2,r2,255
 8229774:	e13ffe44 	addi	r4,fp,-7
 8229778:	e0fff604 	addi	r3,fp,-40
 822977c:	200d883a 	mov	r6,r4
 8229780:	180b883a 	mov	r5,r3
 8229784:	1009883a 	mov	r4,r2
 8229788:	821b3e40 	call	821b3e4 <OSTaskNameGet>

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
                     name, tcb->OSTCBPrio, tcb->OSTCBStat);
 822978c:	e0bff417 	ldw	r2,-48(fp)
 8229790:	10800c83 	ldbu	r2,50(r2)
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 8229794:	11003fcc 	andi	r4,r2,255
                     name, tcb->OSTCBPrio, tcb->OSTCBStat);
 8229798:	e0bff417 	ldw	r2,-48(fp)
 822979c:	10800c03 	ldbu	r2,48(r2)
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 82297a0:	10803fcc 	andi	r2,r2,255
 82297a4:	e0fff604 	addi	r3,fp,-40
 82297a8:	d8800015 	stw	r2,0(sp)
 82297ac:	200f883a 	mov	r7,r4
 82297b0:	180d883a 	mov	r6,r3
 82297b4:	01420974 	movhi	r5,2085
 82297b8:	2941f804 	addi	r5,r5,2016
 82297bc:	e13fff17 	ldw	r4,-4(fp)
 82297c0:	8228d040 	call	8228d04 <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 82297c4:	e0bff417 	ldw	r2,-48(fp)
 82297c8:	10800217 	ldw	r2,8(r2)
 82297cc:	10002426 	beq	r2,zero,8229860 <tk_stats+0x180>
 82297d0:	e0bff417 	ldw	r2,-48(fp)
 82297d4:	10800317 	ldw	r2,12(r2)
 82297d8:	10002126 	beq	r2,zero,8229860 <tk_stats+0x180>
      {
         sp = tcb->OSTCBStkBottom + 1;
 82297dc:	e0bff417 	ldw	r2,-48(fp)
 82297e0:	10800217 	ldw	r2,8(r2)
 82297e4:	10800104 	addi	r2,r2,4
 82297e8:	e0bff315 	stw	r2,-52(fp)
         while(*sp == 0)
 82297ec:	00000306 	br	82297fc <tk_stats+0x11c>
            sp++;
 82297f0:	e0bff317 	ldw	r2,-52(fp)
 82297f4:	10800104 	addi	r2,r2,4
 82297f8:	e0bff315 	stw	r2,-52(fp)
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
      {
         sp = tcb->OSTCBStkBottom + 1;
         while(*sp == 0)
 82297fc:	e0bff317 	ldw	r2,-52(fp)
 8229800:	10800017 	ldw	r2,0(r2)
 8229804:	103ffa26 	beq	r2,zero,82297f0 <tk_stats+0x110>
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
 8229808:	e0bff417 	ldw	r2,-48(fp)
 822980c:	10800317 	ldw	r2,12(r2)
 8229810:	e0fff317 	ldw	r3,-52(fp)
 8229814:	e13ff417 	ldw	r4,-48(fp)
 8229818:	21000217 	ldw	r4,8(r4)
 822981c:	1907c83a 	sub	r3,r3,r4
 8229820:	1807d0ba 	srai	r3,r3,2
 8229824:	10c5c83a 	sub	r2,r2,r3
 8229828:	1085883a 	add	r2,r2,r2
 822982c:	1085883a 	add	r2,r2,r2
 8229830:	e0bff515 	stw	r2,-44(fp)
         ns_printf(pio, "%6d,      %6d\n",
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
 8229834:	e0bff417 	ldw	r2,-48(fp)
 8229838:	10800317 	ldw	r2,12(r2)
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
         ns_printf(pio, "%6d,      %6d\n",
 822983c:	1085883a 	add	r2,r2,r2
 8229840:	1085883a 	add	r2,r2,r2
 8229844:	e1fff517 	ldw	r7,-44(fp)
 8229848:	100d883a 	mov	r6,r2
 822984c:	01420974 	movhi	r5,2085
 8229850:	29420004 	addi	r5,r5,2048
 8229854:	e13fff17 	ldw	r4,-4(fp)
 8229858:	8228d040 	call	8228d04 <ns_printf>
 822985c:	00000606 	br	8229878 <tk_stats+0x198>
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
      }
      else
#endif
      {
         ns_printf(pio, "No stack data\n");
 8229860:	01420974 	movhi	r5,2085
 8229864:	29420404 	addi	r5,r5,2064
 8229868:	e13fff17 	ldw	r4,-4(fp)
 822986c:	8228d040 	call	8228d04 <ns_printf>
 8229870:	00000106 	br	8229878 <tk_stats+0x198>
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
         continue;
 8229874:	0001883a 	nop
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 8229878:	e0bff217 	ldw	r2,-56(fp)
 822987c:	10800044 	addi	r2,r2,1
 8229880:	e0bff215 	stw	r2,-56(fp)
 8229884:	e0bff217 	ldw	r2,-56(fp)
 8229888:	10800550 	cmplti	r2,r2,21
 822988c:	103fa91e 	bne	r2,zero,8229734 <tk_stats+0x54>
      {
         ns_printf(pio, "No stack data\n");
      }
   }

   ns_printf(pio, "tcp_sleep_count = %lu, tcp_wakeup_count = %lu\n",
 8229890:	d0a0a317 	ldw	r2,-32116(gp)
 8229894:	d0e0a417 	ldw	r3,-32112(gp)
 8229898:	180f883a 	mov	r7,r3
 822989c:	100d883a 	mov	r6,r2
 82298a0:	01420974 	movhi	r5,2085
 82298a4:	29420804 	addi	r5,r5,2080
 82298a8:	e13fff17 	ldw	r4,-4(fp)
 82298ac:	8228d040 	call	8228d04 <ns_printf>
                  tcp_sleep_count, tcp_wakeup_count);
   ns_printf(pio, "global_TCPwakeup_setIndx = %d, tcp_sleep_timeout = %lu\n",
 82298b0:	d0a0a717 	ldw	r2,-32100(gp)
 82298b4:	d0e08e17 	ldw	r3,-32200(gp)
 82298b8:	180f883a 	mov	r7,r3
 82298bc:	100d883a 	mov	r6,r2
 82298c0:	01420974 	movhi	r5,2085
 82298c4:	29421404 	addi	r5,r5,2128
 82298c8:	e13fff17 	ldw	r4,-4(fp)
 82298cc:	8228d040 	call	8228d04 <ns_printf>
                  global_TCPwakeup_setIndx, tcp_sleep_timeout);

   return 0;
 82298d0:	0005883a 	mov	r2,zero
}
 82298d4:	e037883a 	mov	sp,fp
 82298d8:	dfc00117 	ldw	ra,4(sp)
 82298dc:	df000017 	ldw	fp,0(sp)
 82298e0:	dec00204 	addi	sp,sp,8
 82298e4:	f800283a 	ret

082298e8 <dhc_get_srv_ipaddr>:
 * RETURNS: 
 */

ip_addr 
dhc_get_srv_ipaddr(u_char *options /* after magic cookie */) 
{
 82298e8:	defffa04 	addi	sp,sp,-24
 82298ec:	dfc00515 	stw	ra,20(sp)
 82298f0:	df000415 	stw	fp,16(sp)
 82298f4:	df000404 	addi	fp,sp,16
 82298f8:	e13fff15 	stw	r4,-4(fp)
    u_char * opts;
    u_char   optlen;
   ip_addr srv_ipaddr = 0;
 82298fc:	e03ffc15 	stw	zero,-16(fp)

   if ((opts = find_opt(DHOP_SERVER, options)) != NULL) 
 8229900:	e17fff17 	ldw	r5,-4(fp)
 8229904:	01000d84 	movi	r4,54
 8229908:	822c5100 	call	822c510 <find_opt>
 822990c:	e0bffd15 	stw	r2,-12(fp)
 8229910:	e0bffd17 	ldw	r2,-12(fp)
 8229914:	10001026 	beq	r2,zero,8229958 <dhc_get_srv_ipaddr+0x70>
   {
      opts++;
 8229918:	e0bffd17 	ldw	r2,-12(fp)
 822991c:	10800044 	addi	r2,r2,1
 8229920:	e0bffd15 	stw	r2,-12(fp)
      optlen = *opts;
 8229924:	e0bffd17 	ldw	r2,-12(fp)
 8229928:	10800003 	ldbu	r2,0(r2)
 822992c:	e0bffe05 	stb	r2,-8(fp)
      opts++;
 8229930:	e0bffd17 	ldw	r2,-12(fp)
 8229934:	10800044 	addi	r2,r2,1
 8229938:	e0bffd15 	stw	r2,-12(fp)
      srv_ipaddr = dh_getlong(opts);
 822993c:	e13ffd17 	ldw	r4,-12(fp)
 8229940:	822b8740 	call	822b874 <dh_getlong>
 8229944:	e0bffc15 	stw	r2,-16(fp)
      opts += optlen;
 8229948:	e0bffe03 	ldbu	r2,-8(fp)
 822994c:	e0fffd17 	ldw	r3,-12(fp)
 8229950:	1885883a 	add	r2,r3,r2
 8229954:	e0bffd15 	stw	r2,-12(fp)
   }

   return (srv_ipaddr);
 8229958:	e0bffc17 	ldw	r2,-16(fp)
} 
 822995c:	e037883a 	mov	sp,fp
 8229960:	dfc00117 	ldw	ra,4(sp)
 8229964:	df000017 	ldw	fp,0(sp)
 8229968:	dec00204 	addi	sp,sp,8
 822996c:	f800283a 	ret

08229970 <dhc_init>:
 * RETURNS: Returns 0 if OK, else negative error code from net.h file 
 */

int
dhc_init(void)
{
 8229970:	defffc04 	addi	sp,sp,-16
 8229974:	dfc00315 	stw	ra,12(sp)
 8229978:	df000215 	stw	fp,8(sp)
 822997c:	df000204 	addi	fp,sp,8
   int   i;

   /* open UDP connection to receive incoming DHCP replys */
   dhc_conn = udp_open(0L,    /* wildcard foriegn host */
 8229980:	00bfff44 	movi	r2,-3
 8229984:	d8800015 	stw	r2,0(sp)
 8229988:	01c208f4 	movhi	r7,2083
 822998c:	39e69a04 	addi	r7,r7,-26008
 8229990:	01801104 	movi	r6,68
 8229994:	014010c4 	movi	r5,67
 8229998:	0009883a 	mov	r4,zero
 822999c:	822cfac0 	call	822cfac <udp_open>
 82299a0:	d0a08f15 	stw	r2,-32196(gp)
      BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT,
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
 82299a4:	d0a08f17 	ldw	r2,-32196(gp)
 82299a8:	1000021e 	bne	r2,zero,82299b4 <dhc_init+0x44>
      return ENP_RESOURCE;
 82299ac:	00bffa84 	movi	r2,-22
 82299b0:	00001606 	br	8229a0c <dhc_init+0x9c>

   for (i = 0; i < MAXNETS; i++)
 82299b4:	e03fff15 	stw	zero,-4(fp)
 82299b8:	00001006 	br	82299fc <dhc_init+0x8c>
   {
      dhc_states[i].state = DHCS_UNUSED;
 82299bc:	008209b4 	movhi	r2,2086
 82299c0:	10b84a04 	addi	r2,r2,-7896
 82299c4:	e0ffff17 	ldw	r3,-4(fp)
 82299c8:	18c00f24 	muli	r3,r3,60
 82299cc:	10c5883a 	add	r2,r2,r3
 82299d0:	10000015 	stw	zero,0(r2)
      dhc_states[i].tries = 0;
 82299d4:	008209b4 	movhi	r2,2086
 82299d8:	10b84a04 	addi	r2,r2,-7896
 82299dc:	e0ffff17 	ldw	r3,-4(fp)
 82299e0:	18c00f24 	muli	r3,r3,60
 82299e4:	10c5883a 	add	r2,r2,r3
 82299e8:	10800104 	addi	r2,r2,4
 82299ec:	10000015 	stw	zero,0(r2)
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
      return ENP_RESOURCE;

   for (i = 0; i < MAXNETS; i++)
 82299f0:	e0bfff17 	ldw	r2,-4(fp)
 82299f4:	10800044 	addi	r2,r2,1
 82299f8:	e0bfff15 	stw	r2,-4(fp)
 82299fc:	e0bfff17 	ldw	r2,-4(fp)
 8229a00:	10800110 	cmplti	r2,r2,4
 8229a04:	103fed1e 	bne	r2,zero,82299bc <dhc_init+0x4c>
   {
      dhc_states[i].state = DHCS_UNUSED;
      dhc_states[i].tries = 0;
   }

   return 0;
 8229a08:	0005883a 	mov	r2,zero
}
 8229a0c:	e037883a 	mov	sp,fp
 8229a10:	dfc00117 	ldw	ra,4(sp)
 8229a14:	df000017 	ldw	fp,0(sp)
 8229a18:	dec00204 	addi	sp,sp,8
 8229a1c:	f800283a 	ret

08229a20 <dhc_set_callback>:
 * RETURNS: 
 */

void
dhc_set_callback(int iface, int (*routine)(int,int) )
{
 8229a20:	defffd04 	addi	sp,sp,-12
 8229a24:	df000215 	stw	fp,8(sp)
 8229a28:	df000204 	addi	fp,sp,8
 8229a2c:	e13ffe15 	stw	r4,-8(fp)
 8229a30:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].callback = routine;
 8229a34:	008209b4 	movhi	r2,2086
 8229a38:	10b84a04 	addi	r2,r2,-7896
 8229a3c:	e0fffe17 	ldw	r3,-8(fp)
 8229a40:	18c00f24 	muli	r3,r3,60
 8229a44:	10c5883a 	add	r2,r2,r3
 8229a48:	10800e04 	addi	r2,r2,56
 8229a4c:	e0ffff17 	ldw	r3,-4(fp)
 8229a50:	10c00015 	stw	r3,0(r2)
}
 8229a54:	0001883a 	nop
 8229a58:	e037883a 	mov	sp,fp
 8229a5c:	df000017 	ldw	fp,0(sp)
 8229a60:	dec00104 	addi	sp,sp,4
 8229a64:	f800283a 	ret

08229a68 <dhc_upcall>:
 * returned
 */

int
dhc_upcall(PACKET pkt, void * data)
{
 8229a68:	defff504 	addi	sp,sp,-44
 8229a6c:	dfc00a15 	stw	ra,40(sp)
 8229a70:	df000915 	stw	fp,36(sp)
 8229a74:	dc000815 	stw	r16,32(sp)
 8229a78:	df000904 	addi	fp,sp,36
 8229a7c:	e13ffd15 	stw	r4,-12(fp)
 8229a80:	e17ffe15 	stw	r5,-8(fp)
   struct bootp * bp;
   int      len      =  pkt->nb_plen;  /* len of UDP data - the bootp/dhcp struct */
 8229a84:	e0bffd17 	ldw	r2,-12(fp)
 8229a88:	10800417 	ldw	r2,16(r2)
 8229a8c:	e0bff815 	stw	r2,-32(fp)
   int      dhcptype =  0;    /* DHCP type - not valid if bootp */
 8229a90:	e03ff715 	stw	zero,-36(fp)
   int      e;
   int      iface;
   u_char * opts;          /* scratch options pointer */

   if (data != DHCPDATA)
 8229a94:	e0bffe17 	ldw	r2,-8(fp)
 8229a98:	10bfff60 	cmpeqi	r2,r2,-3
 8229a9c:	1000031e 	bne	r2,zero,8229aac <dhc_upcall+0x44>
   {
      dtrap();
 8229aa0:	822d4140 	call	822d414 <dtrap>
      return ENP_LOGIC;    /* internal logic error */
 8229aa4:	00bffd44 	movi	r2,-11
 8229aa8:	0001d506 	br	822a200 <dhc_upcall+0x798>
   }

   /* punt if packet didn't come in a net we sent on */
   iface = net_num(pkt->net);
 8229aac:	e0bffd17 	ldw	r2,-12(fp)
 8229ab0:	10800617 	ldw	r2,24(r2)
 8229ab4:	1009883a 	mov	r4,r2
 8229ab8:	8226ba40 	call	8226ba4 <if_netnumber>
 8229abc:	e0bff915 	stw	r2,-28(fp)
   if (dhc_states[iface].state == DHCS_UNUSED)
 8229ac0:	008209b4 	movhi	r2,2086
 8229ac4:	10b84a04 	addi	r2,r2,-7896
 8229ac8:	e0fff917 	ldw	r3,-28(fp)
 8229acc:	18c00f24 	muli	r3,r3,60
 8229ad0:	10c5883a 	add	r2,r2,r3
 8229ad4:	10800017 	ldw	r2,0(r2)
 8229ad8:	1000021e 	bne	r2,zero,8229ae4 <dhc_upcall+0x7c>
      return ENP_NOT_MINE;
 8229adc:	00800084 	movi	r2,2
 8229ae0:	0001c706 	br	822a200 <dhc_upcall+0x798>

   bp = (struct bootp *)pkt->nb_prot;
 8229ae4:	e0bffd17 	ldw	r2,-12(fp)
 8229ae8:	10800317 	ldw	r2,12(r2)
 8229aec:	e0bffa15 	stw	r2,-24(fp)

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 8229af0:	e0bff817 	ldw	r2,-32(fp)
 8229af4:	10803b30 	cmpltui	r2,r2,236
 8229af8:	10000b1e 	bne	r2,zero,8229b28 <dhc_upcall+0xc0>
       (bp->op != BOOTREPLY) ||
 8229afc:	e0bffa17 	ldw	r2,-24(fp)
 8229b00:	10800003 	ldbu	r2,0(r2)
      return ENP_NOT_MINE;

   bp = (struct bootp *)pkt->nb_prot;

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 8229b04:	10803fcc 	andi	r2,r2,255
 8229b08:	10800098 	cmpnei	r2,r2,2
 8229b0c:	1000061e 	bne	r2,zero,8229b28 <dhc_upcall+0xc0>
       (bp->op != BOOTREPLY) ||
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
 8229b10:	e0bffa17 	ldw	r2,-24(fp)
 8229b14:	10803b04 	addi	r2,r2,236
 8229b18:	10c00017 	ldw	r3,0(r2)

   bp = (struct bootp *)pkt->nb_prot;

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
       (bp->op != BOOTREPLY) ||
 8229b1c:	0098d534 	movhi	r2,25428
 8229b20:	10a098c4 	addi	r2,r2,-32157
 8229b24:	18800626 	beq	r3,r2,8229b40 <dhc_upcall+0xd8>
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
   {
      dtrap();
 8229b28:	822d4140 	call	822d414 <dtrap>
      dsc_errors++;
 8229b2c:	d0a09017 	ldw	r2,-32192(gp)
 8229b30:	10800044 	addi	r2,r2,1
 8229b34:	d0a09015 	stw	r2,-32192(gp)
      return ENP_NOT_MINE;
 8229b38:	00800084 	movi	r2,2
 8229b3c:	0001b006 	br	822a200 <dhc_upcall+0x798>
   }

   /* punt offers or replys which are not for me */
   if(MEMCMP(bp->chaddr, pkt->net->mib.ifPhysAddress, pkt->net->n_hal))
 8229b40:	e0bffa17 	ldw	r2,-24(fp)
 8229b44:	10c00704 	addi	r3,r2,28
 8229b48:	e0bffd17 	ldw	r2,-12(fp)
 8229b4c:	10800617 	ldw	r2,24(r2)
 8229b50:	11001717 	ldw	r4,92(r2)
 8229b54:	e0bffd17 	ldw	r2,-12(fp)
 8229b58:	10800617 	ldw	r2,24(r2)
 8229b5c:	10801117 	ldw	r2,68(r2)
 8229b60:	100d883a 	mov	r6,r2
 8229b64:	200b883a 	mov	r5,r4
 8229b68:	1809883a 	mov	r4,r3
 8229b6c:	820c5580 	call	820c558 <memcmp>
 8229b70:	10000226 	beq	r2,zero,8229b7c <dhc_upcall+0x114>
      return ENP_NOT_MINE;    /* not an error, just ignore it */
 8229b74:	00800084 	movi	r2,2
 8229b78:	0001a106 	br	822a200 <dhc_upcall+0x798>

   /* see if it's full DHCP or plain bootp by looking for dhcp type option */
   opts = find_opt(DHOP_TYPE ,&bp->options[4]);
 8229b7c:	e0bffa17 	ldw	r2,-24(fp)
 8229b80:	10803c04 	addi	r2,r2,240
 8229b84:	100b883a 	mov	r5,r2
 8229b88:	01000d44 	movi	r4,53
 8229b8c:	822c5100 	call	822c510 <find_opt>
 8229b90:	e0bffb15 	stw	r2,-20(fp)
   if (opts && *opts == DHOP_TYPE)
 8229b94:	e0bffb17 	ldw	r2,-20(fp)
 8229b98:	10001026 	beq	r2,zero,8229bdc <dhc_upcall+0x174>
 8229b9c:	e0bffb17 	ldw	r2,-20(fp)
 8229ba0:	10800003 	ldbu	r2,0(r2)
 8229ba4:	10803fcc 	andi	r2,r2,255
 8229ba8:	10800d58 	cmpnei	r2,r2,53
 8229bac:	10000b1e 	bne	r2,zero,8229bdc <dhc_upcall+0x174>
   {
      dhcptype = *(opts+2);
 8229bb0:	e0bffb17 	ldw	r2,-20(fp)
 8229bb4:	10800084 	addi	r2,r2,2
 8229bb8:	10800003 	ldbu	r2,0(r2)
 8229bbc:	10803fcc 	andi	r2,r2,255
 8229bc0:	e0bff715 	stw	r2,-36(fp)
      bp->op |= ISDHCP;       /* tag packet for isdhcp() macro */
 8229bc4:	e0bffa17 	ldw	r2,-24(fp)
 8229bc8:	10800003 	ldbu	r2,0(r2)
 8229bcc:	10800114 	ori	r2,r2,4
 8229bd0:	1007883a 	mov	r3,r2
 8229bd4:	e0bffa17 	ldw	r2,-24(fp)
 8229bd8:	10c00005 	stb	r3,0(r2)
   }

   if (isdhcp(bp))
 8229bdc:	e0bffa17 	ldw	r2,-24(fp)
 8229be0:	10800003 	ldbu	r2,0(r2)
 8229be4:	10803fcc 	andi	r2,r2,255
 8229be8:	1080010c 	andi	r2,r2,4
 8229bec:	10016326 	beq	r2,zero,822a17c <dhc_upcall+0x714>
   {
      switch (dhcptype)
 8229bf0:	e0bff717 	ldw	r2,-36(fp)
 8229bf4:	10c00148 	cmpgei	r3,r2,5
 8229bf8:	1800051e 	bne	r3,zero,8229c10 <dhc_upcall+0x1a8>
 8229bfc:	10c000c8 	cmpgei	r3,r2,3
 8229c00:	1800051e 	bne	r3,zero,8229c18 <dhc_upcall+0x1b0>
 8229c04:	10800060 	cmpeqi	r2,r2,1
 8229c08:	1000031e 	bne	r2,zero,8229c18 <dhc_upcall+0x1b0>
 8229c0c:	00000706 	br	8229c2c <dhc_upcall+0x1c4>
 8229c10:	108001e0 	cmpeqi	r2,r2,7
 8229c14:	10000526 	beq	r2,zero,8229c2c <dhc_upcall+0x1c4>
      {
      case DHCP_DISCOVER:
      case DHCP_REQUEST:
      case DHCP_DECLINE:
      case DHCP_RELEASE:
         dsc_errors++;     /* these should only be upcalled to a server */
 8229c18:	d0a09017 	ldw	r2,-32192(gp)
 8229c1c:	10800044 	addi	r2,r2,1
 8229c20:	d0a09015 	stw	r2,-32192(gp)
         return ENP_NOT_MINE;
 8229c24:	00800084 	movi	r2,2
 8229c28:	00017506 	br	822a200 <dhc_upcall+0x798>
      }

      switch (dhc_states[iface].state)
 8229c2c:	008209b4 	movhi	r2,2086
 8229c30:	10b84a04 	addi	r2,r2,-7896
 8229c34:	e0fff917 	ldw	r3,-28(fp)
 8229c38:	18c00f24 	muli	r3,r3,60
 8229c3c:	10c5883a 	add	r2,r2,r3
 8229c40:	10800017 	ldw	r2,0(r2)
 8229c44:	10c00268 	cmpgeui	r3,r2,9
 8229c48:	1801431e 	bne	r3,zero,822a158 <dhc_upcall+0x6f0>
 8229c4c:	100690ba 	slli	r3,r2,2
 8229c50:	008208f4 	movhi	r2,2083
 8229c54:	10a71904 	addi	r2,r2,-25500
 8229c58:	1885883a 	add	r2,r3,r2
 8229c5c:	10800017 	ldw	r2,0(r2)
 8229c60:	1000683a 	jmp	r2
 8229c64:	0822a158 	cmpnei	zero,at,-30075
 8229c68:	08229c88 	cmpgei	zero,at,-30094
 8229c6c:	08229c88 	cmpgei	zero,at,-30094
 8229c70:	08229ebc 	xorhi	zero,at,35450
 8229c74:	08229c9c 	xori	zero,at,35442
 8229c78:	08229e10 	cmplti	zero,at,-30088
 8229c7c:	08229c88 	cmpgei	zero,at,-30094
 8229c80:	08229e10 	cmplti	zero,at,-30088
 8229c84:	08229e10 	cmplti	zero,at,-30088
      case DHCS_INITREBOOT:
         /* How can we receive any response when we never sent one */
      case DHCS_BOUND:
         /* If there are multiple DHCP Servers, and one of them is slow
            in responding, we might get OFFER pkts when are in BOUND state */
         dsc_errors++;     /* these should only be upcalled to a server */
 8229c88:	d0a09017 	ldw	r2,-32192(gp)
 8229c8c:	10800044 	addi	r2,r2,1
 8229c90:	d0a09015 	stw	r2,-32192(gp)
         return ENP_NOT_MINE;
 8229c94:	00800084 	movi	r2,2
 8229c98:	00015906 	br	822a200 <dhc_upcall+0x798>
      case DHCS_SELECTING:
         /* We will respond to the first offer packet that we receive ) */
         if ( dhcptype == DHCP_OFFER ) /* got offer back from server */
 8229c9c:	e0bff717 	ldw	r2,-36(fp)
 8229ca0:	10800098 	cmpnei	r2,r2,2
 8229ca4:	10004f1e 	bne	r2,zero,8229de4 <dhc_upcall+0x37c>
         {
            dsc_offers++;
 8229ca8:	d0a09217 	ldw	r2,-32184(gp)
 8229cac:	10800044 	addi	r2,r2,1
 8229cb0:	d0a09215 	stw	r2,-32184(gp)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]);
 8229cb4:	e0bffa17 	ldw	r2,-24(fp)
 8229cb8:	10803c04 	addi	r2,r2,240
 8229cbc:	1009883a 	mov	r4,r2
 8229cc0:	82298e80 	call	82298e8 <dhc_get_srv_ipaddr>
 8229cc4:	1009883a 	mov	r4,r2
 8229cc8:	008209b4 	movhi	r2,2086
 8229ccc:	10b84a04 	addi	r2,r2,-7896
 8229cd0:	e0fff917 	ldw	r3,-28(fp)
 8229cd4:	18c00f24 	muli	r3,r3,60
 8229cd8:	10c5883a 	add	r2,r2,r3
 8229cdc:	10800d04 	addi	r2,r2,52
 8229ce0:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 8229ce4:	008209b4 	movhi	r2,2086
 8229ce8:	10b84a04 	addi	r2,r2,-7896
 8229cec:	e0fff917 	ldw	r3,-28(fp)
 8229cf0:	18c00f24 	muli	r3,r3,60
 8229cf4:	10c5883a 	add	r2,r2,r3
 8229cf8:	10800d04 	addi	r2,r2,52
 8229cfc:	10800017 	ldw	r2,0(r2)
 8229d00:	10000d1e 	bne	r2,zero,8229d38 <dhc_upcall+0x2d0>
            {
               dtrap(); /* didn't receive server-identifier option */
 8229d04:	822d4140 	call	822d414 <dtrap>
               dsc_errors++;
 8229d08:	d0a09017 	ldw	r2,-32192(gp)
 8229d0c:	10800044 	addi	r2,r2,1
 8229d10:	d0a09015 	stw	r2,-32192(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 8229d14:	e0bffd17 	ldw	r2,-12(fp)
 8229d18:	10c00717 	ldw	r3,28(r2)
 8229d1c:	008209b4 	movhi	r2,2086
 8229d20:	10b84a04 	addi	r2,r2,-7896
 8229d24:	e13ff917 	ldw	r4,-28(fp)
 8229d28:	21000f24 	muli	r4,r4,60
 8229d2c:	1105883a 	add	r2,r2,r4
 8229d30:	10800d04 	addi	r2,r2,52
 8229d34:	10c00015 	stw	r3,0(r2)
            }

            if (bp->hops)
 8229d38:	e0bffa17 	ldw	r2,-24(fp)
 8229d3c:	108000c3 	ldbu	r2,3(r2)
 8229d40:	10803fcc 	andi	r2,r2,255
 8229d44:	10000a26 	beq	r2,zero,8229d70 <dhc_upcall+0x308>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 8229d48:	e0bffd17 	ldw	r2,-12(fp)
 8229d4c:	10c00717 	ldw	r3,28(r2)
 8229d50:	008209b4 	movhi	r2,2086
 8229d54:	10b84a04 	addi	r2,r2,-7896
 8229d58:	e13ff917 	ldw	r4,-28(fp)
 8229d5c:	21000f24 	muli	r4,r4,60
 8229d60:	1105883a 	add	r2,r2,r4
 8229d64:	10800c04 	addi	r2,r2,48
 8229d68:	10c00015 	stw	r3,0(r2)
 8229d6c:	00000706 	br	8229d8c <dhc_upcall+0x324>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 8229d70:	008209b4 	movhi	r2,2086
 8229d74:	10b84a04 	addi	r2,r2,-7896
 8229d78:	e0fff917 	ldw	r3,-28(fp)
 8229d7c:	18c00f24 	muli	r3,r3,60
 8229d80:	10c5883a 	add	r2,r2,r3
 8229d84:	10800c04 	addi	r2,r2,48
 8229d88:	10000015 	stw	zero,0(r2)

            e = dhc_rx_offer(iface,bp,pkt->nb_plen);     /* send request */
 8229d8c:	e0bffd17 	ldw	r2,-12(fp)
 8229d90:	10800417 	ldw	r2,16(r2)
 8229d94:	100d883a 	mov	r6,r2
 8229d98:	e17ffa17 	ldw	r5,-24(fp)
 8229d9c:	e13ff917 	ldw	r4,-28(fp)
 8229da0:	822a8a40 	call	822a8a4 <dhc_rx_offer>
 8229da4:	e0bffc15 	stw	r2,-16(fp)
            if (e)
 8229da8:	e0bffc17 	ldw	r2,-16(fp)
 8229dac:	10000926 	beq	r2,zero,8229dd4 <dhc_upcall+0x36c>
            {
               dsc_errors++;
 8229db0:	d0a09017 	ldw	r2,-32192(gp)
 8229db4:	10800044 	addi	r2,r2,1
 8229db8:	d0a09015 	stw	r2,-32192(gp)
               dhc_set_state(iface,DHCS_INIT);
 8229dbc:	01400044 	movi	r5,1
 8229dc0:	e13ff917 	ldw	r4,-28(fp)
 8229dc4:	822c4600 	call	822c460 <dhc_set_state>
               dtrap();
 8229dc8:	822d4140 	call	822d414 <dtrap>
               return ENP_NOT_MINE;
 8229dcc:	00800084 	movi	r2,2
 8229dd0:	00010b06 	br	822a200 <dhc_upcall+0x798>
            }
            else
               dhc_set_state(iface,DHCS_REQUESTING);
 8229dd4:	01400144 	movi	r5,5
 8229dd8:	e13ff917 	ldw	r4,-28(fp)
 8229ddc:	822c4600 	call	822c460 <dhc_set_state>
            dsc_errors++;
            if ( dhcptype == DHCP_NAK ) 
               dsc_naks++;
            return ENP_NOT_MINE;
         }
         break;
 8229de0:	00010406 	br	822a1f4 <dhc_upcall+0x78c>
             * Report an error and remain in SELECTING state, so that 
             * an OFFER packet from another DHCP server can be 
             * accepted. If we timeout waiting for a OFFER packet, 
             * then dhc_second() will transition to DHCS_INIT state. 
             */
            dsc_errors++;
 8229de4:	d0a09017 	ldw	r2,-32192(gp)
 8229de8:	10800044 	addi	r2,r2,1
 8229dec:	d0a09015 	stw	r2,-32192(gp)
            if ( dhcptype == DHCP_NAK ) 
 8229df0:	e0bff717 	ldw	r2,-36(fp)
 8229df4:	10800198 	cmpnei	r2,r2,6
 8229df8:	1000031e 	bne	r2,zero,8229e08 <dhc_upcall+0x3a0>
               dsc_naks++;
 8229dfc:	d0a09817 	ldw	r2,-32160(gp)
 8229e00:	10800044 	addi	r2,r2,1
 8229e04:	d0a09815 	stw	r2,-32160(gp)
            return ENP_NOT_MINE;
 8229e08:	00800084 	movi	r2,2
 8229e0c:	0000fc06 	br	822a200 <dhc_upcall+0x798>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 8229e10:	008209b4 	movhi	r2,2086
 8229e14:	10b84a04 	addi	r2,r2,-7896
 8229e18:	e0fff917 	ldw	r3,-28(fp)
 8229e1c:	18c00f24 	muli	r3,r3,60
 8229e20:	10c5883a 	add	r2,r2,r3
 8229e24:	10800d04 	addi	r2,r2,52
 8229e28:	14000017 	ldw	r16,0(r2)
             dhc_get_srv_ipaddr(&bp->options[4]) )
 8229e2c:	e0bffa17 	ldw	r2,-24(fp)
 8229e30:	10803c04 	addi	r2,r2,240
 8229e34:	1009883a 	mov	r4,r2
 8229e38:	82298e80 	call	82298e8 <dhc_get_srv_ipaddr>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 8229e3c:	80800526 	beq	r16,r2,8229e54 <dhc_upcall+0x3ec>
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
 8229e40:	d0a09017 	ldw	r2,-32192(gp)
 8229e44:	10800044 	addi	r2,r2,1
 8229e48:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 8229e4c:	00800084 	movi	r2,2
 8229e50:	0000eb06 	br	822a200 <dhc_upcall+0x798>
         }
         if (dhc_states[iface].rly_ipaddr &&
 8229e54:	008209b4 	movhi	r2,2086
 8229e58:	10b84a04 	addi	r2,r2,-7896
 8229e5c:	e0fff917 	ldw	r3,-28(fp)
 8229e60:	18c00f24 	muli	r3,r3,60
 8229e64:	10c5883a 	add	r2,r2,r3
 8229e68:	10800c04 	addi	r2,r2,48
 8229e6c:	10800017 	ldw	r2,0(r2)
 8229e70:	10001226 	beq	r2,zero,8229ebc <dhc_upcall+0x454>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
 8229e74:	008209b4 	movhi	r2,2086
 8229e78:	10b84a04 	addi	r2,r2,-7896
 8229e7c:	e0fff917 	ldw	r3,-28(fp)
 8229e80:	18c00f24 	muli	r3,r3,60
 8229e84:	10c5883a 	add	r2,r2,r3
 8229e88:	10800c04 	addi	r2,r2,48
 8229e8c:	10c00017 	ldw	r3,0(r2)
 8229e90:	e0bffd17 	ldw	r2,-12(fp)
 8229e94:	10800717 	ldw	r2,28(r2)
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
            return ENP_NOT_MINE;
         }
         if (dhc_states[iface].rly_ipaddr &&
 8229e98:	18800826 	beq	r3,r2,8229ebc <dhc_upcall+0x454>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
         {
            dsc_rlyerrs++;
 8229e9c:	d0a09b17 	ldw	r2,-32148(gp)
 8229ea0:	10800044 	addi	r2,r2,1
 8229ea4:	d0a09b15 	stw	r2,-32148(gp)
            dsc_errors++;
 8229ea8:	d0a09017 	ldw	r2,-32192(gp)
 8229eac:	10800044 	addi	r2,r2,1
 8229eb0:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 8229eb4:	00800084 	movi	r2,2
 8229eb8:	0000d106 	br	822a200 <dhc_upcall+0x798>
         }
      case DHCS_REBOOTING:
         if ( dhcptype == DHCP_ACK )   /* Server OKed our request */
 8229ebc:	e0bff717 	ldw	r2,-36(fp)
 8229ec0:	10800158 	cmpnei	r2,r2,5
 8229ec4:	1000851e 	bne	r2,zero,822a0dc <dhc_upcall+0x674>
         {
            dsc_acks++;
 8229ec8:	d0a09417 	ldw	r2,-32176(gp)
 8229ecc:	10800044 	addi	r2,r2,1
 8229ed0:	d0a09415 	stw	r2,-32176(gp)
            dhc_extract_opts(iface,&bp->options[4]);
 8229ed4:	e0bffa17 	ldw	r2,-24(fp)
 8229ed8:	10803c04 	addi	r2,r2,240
 8229edc:	100b883a 	mov	r5,r2
 8229ee0:	e13ff917 	ldw	r4,-28(fp)
 8229ee4:	822b9200 	call	822b920 <dhc_extract_opts>
            if ( dhc_states[iface].lease == DHC_INFINITY )
 8229ee8:	008209b4 	movhi	r2,2086
 8229eec:	10b84a04 	addi	r2,r2,-7896
 8229ef0:	e0fff917 	ldw	r3,-28(fp)
 8229ef4:	18c00f24 	muli	r3,r3,60
 8229ef8:	10c5883a 	add	r2,r2,r3
 8229efc:	10800504 	addi	r2,r2,20
 8229f00:	10800017 	ldw	r2,0(r2)
 8229f04:	10bfffd8 	cmpnei	r2,r2,-1
 8229f08:	1000111e 	bne	r2,zero,8229f50 <dhc_upcall+0x4e8>
            {
               dhc_states[iface].t1 = DHC_INFINITY ;
 8229f0c:	008209b4 	movhi	r2,2086
 8229f10:	10b84a04 	addi	r2,r2,-7896
 8229f14:	e0fff917 	ldw	r3,-28(fp)
 8229f18:	18c00f24 	muli	r3,r3,60
 8229f1c:	10c5883a 	add	r2,r2,r3
 8229f20:	10800604 	addi	r2,r2,24
 8229f24:	00ffffc4 	movi	r3,-1
 8229f28:	10c00015 	stw	r3,0(r2)
               dhc_states[iface].t2 = DHC_INFINITY ;
 8229f2c:	008209b4 	movhi	r2,2086
 8229f30:	10b84a04 	addi	r2,r2,-7896
 8229f34:	e0fff917 	ldw	r3,-28(fp)
 8229f38:	18c00f24 	muli	r3,r3,60
 8229f3c:	10c5883a 	add	r2,r2,r3
 8229f40:	10800704 	addi	r2,r2,28
 8229f44:	00ffffc4 	movi	r3,-1
 8229f48:	10c00015 	stw	r3,0(r2)
 8229f4c:	00001f06 	br	8229fcc <dhc_upcall+0x564>
            }
            else
            {
               dhc_states[iface].t1 = dhc_states[iface].lease/2     ;
 8229f50:	008209b4 	movhi	r2,2086
 8229f54:	10b84a04 	addi	r2,r2,-7896
 8229f58:	e0fff917 	ldw	r3,-28(fp)
 8229f5c:	18c00f24 	muli	r3,r3,60
 8229f60:	10c5883a 	add	r2,r2,r3
 8229f64:	10800504 	addi	r2,r2,20
 8229f68:	10800017 	ldw	r2,0(r2)
 8229f6c:	1006d07a 	srli	r3,r2,1
 8229f70:	008209b4 	movhi	r2,2086
 8229f74:	10b84a04 	addi	r2,r2,-7896
 8229f78:	e13ff917 	ldw	r4,-28(fp)
 8229f7c:	21000f24 	muli	r4,r4,60
 8229f80:	1105883a 	add	r2,r2,r4
 8229f84:	10800604 	addi	r2,r2,24
 8229f88:	10c00015 	stw	r3,0(r2)
               dhc_states[iface].t2 = (dhc_states[iface].lease/8)*7 ;
 8229f8c:	008209b4 	movhi	r2,2086
 8229f90:	10b84a04 	addi	r2,r2,-7896
 8229f94:	e0fff917 	ldw	r3,-28(fp)
 8229f98:	18c00f24 	muli	r3,r3,60
 8229f9c:	10c5883a 	add	r2,r2,r3
 8229fa0:	10800504 	addi	r2,r2,20
 8229fa4:	10800017 	ldw	r2,0(r2)
 8229fa8:	1004d0fa 	srli	r2,r2,3
 8229fac:	10c001e4 	muli	r3,r2,7
 8229fb0:	008209b4 	movhi	r2,2086
 8229fb4:	10b84a04 	addi	r2,r2,-7896
 8229fb8:	e13ff917 	ldw	r4,-28(fp)
 8229fbc:	21000f24 	muli	r4,r4,60
 8229fc0:	1105883a 	add	r2,r2,r4
 8229fc4:	10800704 	addi	r2,r2,28
 8229fc8:	10c00015 	stw	r3,0(r2)
            }
            dhc_states[iface].lease_start = cticks;   /* to calc lease expiry */
 8229fcc:	d0e0a817 	ldw	r3,-32096(gp)
 8229fd0:	008209b4 	movhi	r2,2086
 8229fd4:	10b84a04 	addi	r2,r2,-7896
 8229fd8:	e13ff917 	ldw	r4,-28(fp)
 8229fdc:	21000f24 	muli	r4,r4,60
 8229fe0:	1105883a 	add	r2,r2,r4
 8229fe4:	10800804 	addi	r2,r2,32
 8229fe8:	10c00015 	stw	r3,0(r2)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]); 
 8229fec:	e0bffa17 	ldw	r2,-24(fp)
 8229ff0:	10803c04 	addi	r2,r2,240
 8229ff4:	1009883a 	mov	r4,r2
 8229ff8:	82298e80 	call	82298e8 <dhc_get_srv_ipaddr>
 8229ffc:	1009883a 	mov	r4,r2
 822a000:	008209b4 	movhi	r2,2086
 822a004:	10b84a04 	addi	r2,r2,-7896
 822a008:	e0fff917 	ldw	r3,-28(fp)
 822a00c:	18c00f24 	muli	r3,r3,60
 822a010:	10c5883a 	add	r2,r2,r3
 822a014:	10800d04 	addi	r2,r2,52
 822a018:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 822a01c:	008209b4 	movhi	r2,2086
 822a020:	10b84a04 	addi	r2,r2,-7896
 822a024:	e0fff917 	ldw	r3,-28(fp)
 822a028:	18c00f24 	muli	r3,r3,60
 822a02c:	10c5883a 	add	r2,r2,r3
 822a030:	10800d04 	addi	r2,r2,52
 822a034:	10800017 	ldw	r2,0(r2)
 822a038:	10000d1e 	bne	r2,zero,822a070 <dhc_upcall+0x608>
            {
               dtrap(); /* didn't receive server-identifier option */
 822a03c:	822d4140 	call	822d414 <dtrap>
               dsc_errors++;
 822a040:	d0a09017 	ldw	r2,-32192(gp)
 822a044:	10800044 	addi	r2,r2,1
 822a048:	d0a09015 	stw	r2,-32192(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 822a04c:	e0bffd17 	ldw	r2,-12(fp)
 822a050:	10c00717 	ldw	r3,28(r2)
 822a054:	008209b4 	movhi	r2,2086
 822a058:	10b84a04 	addi	r2,r2,-7896
 822a05c:	e13ff917 	ldw	r4,-28(fp)
 822a060:	21000f24 	muli	r4,r4,60
 822a064:	1105883a 	add	r2,r2,r4
 822a068:	10800d04 	addi	r2,r2,52
 822a06c:	10c00015 	stw	r3,0(r2)
            }
            if (bp->hops)
 822a070:	e0bffa17 	ldw	r2,-24(fp)
 822a074:	108000c3 	ldbu	r2,3(r2)
 822a078:	10803fcc 	andi	r2,r2,255
 822a07c:	10000a26 	beq	r2,zero,822a0a8 <dhc_upcall+0x640>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 822a080:	e0bffd17 	ldw	r2,-12(fp)
 822a084:	10c00717 	ldw	r3,28(r2)
 822a088:	008209b4 	movhi	r2,2086
 822a08c:	10b84a04 	addi	r2,r2,-7896
 822a090:	e13ff917 	ldw	r4,-28(fp)
 822a094:	21000f24 	muli	r4,r4,60
 822a098:	1105883a 	add	r2,r2,r4
 822a09c:	10800c04 	addi	r2,r2,48
 822a0a0:	10c00015 	stw	r3,0(r2)
 822a0a4:	00000706 	br	822a0c4 <dhc_upcall+0x65c>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 822a0a8:	008209b4 	movhi	r2,2086
 822a0ac:	10b84a04 	addi	r2,r2,-7896
 822a0b0:	e0fff917 	ldw	r3,-28(fp)
 822a0b4:	18c00f24 	muli	r3,r3,60
 822a0b8:	10c5883a 	add	r2,r2,r3
 822a0bc:	10800c04 	addi	r2,r2,48
 822a0c0:	10000015 	stw	zero,0(r2)

            dhc_setip(iface);
 822a0c4:	e13ff917 	ldw	r4,-28(fp)
 822a0c8:	822b40c0 	call	822b40c <dhc_setip>
            dhc_set_state(iface,DHCS_BOUND);
 822a0cc:	01400184 	movi	r5,6
 822a0d0:	e13ff917 	ldw	r4,-28(fp)
 822a0d4:	822c4600 	call	822c460 <dhc_set_state>
             * error and discard it with no change to our state.
             */
            dsc_errors++;
            return ENP_NOT_MINE;
         }
         break;
 822a0d8:	00004606 	br	822a1f4 <dhc_upcall+0x78c>
               dhc_states[iface].rly_ipaddr = 0;

            dhc_setip(iface);
            dhc_set_state(iface,DHCS_BOUND);
         }
         else if ( dhcptype == DHCP_NAK ) /* Server denied our request */
 822a0dc:	e0bff717 	ldw	r2,-36(fp)
 822a0e0:	10800198 	cmpnei	r2,r2,6
 822a0e4:	1000071e 	bne	r2,zero,822a104 <dhc_upcall+0x69c>
         {
            dhc_set_state(iface,DHCS_INIT);
 822a0e8:	01400044 	movi	r5,1
 822a0ec:	e13ff917 	ldw	r4,-28(fp)
 822a0f0:	822c4600 	call	822c460 <dhc_set_state>
            dsc_naks++;
 822a0f4:	d0a09817 	ldw	r2,-32160(gp)
 822a0f8:	10800044 	addi	r2,r2,1
 822a0fc:	d0a09815 	stw	r2,-32160(gp)
             * error and discard it with no change to our state.
             */
            dsc_errors++;
            return ENP_NOT_MINE;
         }
         break;
 822a100:	00003c06 	br	822a1f4 <dhc_upcall+0x78c>
         {
            /* In REQUESTING state, we might receive a retransmitted
             * OFFER, which we should discard, but it's not an error,
             * so we log it.
             */
            if ((dhc_states[iface].state == DHCS_REQUESTING) &&
 822a104:	008209b4 	movhi	r2,2086
 822a108:	10b84a04 	addi	r2,r2,-7896
 822a10c:	e0fff917 	ldw	r3,-28(fp)
 822a110:	18c00f24 	muli	r3,r3,60
 822a114:	10c5883a 	add	r2,r2,r3
 822a118:	10800017 	ldw	r2,0(r2)
 822a11c:	10800158 	cmpnei	r2,r2,5
 822a120:	1000081e 	bne	r2,zero,822a144 <dhc_upcall+0x6dc>
 822a124:	e0bff717 	ldw	r2,-36(fp)
 822a128:	10800098 	cmpnei	r2,r2,2
 822a12c:	1000051e 	bne	r2,zero,822a144 <dhc_upcall+0x6dc>
                (dhcptype == DHCP_OFFER))
            {
               dsc_offers++;
 822a130:	d0a09217 	ldw	r2,-32184(gp)
 822a134:	10800044 	addi	r2,r2,1
 822a138:	d0a09215 	stw	r2,-32184(gp)
               return ENP_NOT_MINE;
 822a13c:	00800084 	movi	r2,2
 822a140:	00002f06 	br	822a200 <dhc_upcall+0x798>
             * only receive ACK or NAK, and in REQUESTING state we
             * should only receive ACK or NAK or OFFER; these are
             * accounted for above, so we log whatever this is as an
             * error and discard it with no change to our state.
             */
            dsc_errors++;
 822a144:	d0a09017 	ldw	r2,-32192(gp)
 822a148:	10800044 	addi	r2,r2,1
 822a14c:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 822a150:	00800084 	movi	r2,2
 822a154:	00002a06 	br	822a200 <dhc_upcall+0x798>
         }
         break;
      default:    /* bad state */
         dtrap();
 822a158:	822d4140 	call	822d414 <dtrap>
         dhc_set_state(iface,DHCS_INIT);
 822a15c:	01400044 	movi	r5,1
 822a160:	e13ff917 	ldw	r4,-28(fp)
 822a164:	822c4600 	call	822c460 <dhc_set_state>
         dsc_errors++;
 822a168:	d0a09017 	ldw	r2,-32192(gp)
 822a16c:	10800044 	addi	r2,r2,1
 822a170:	d0a09015 	stw	r2,-32192(gp)
         return -1;
 822a174:	00bfffc4 	movi	r2,-1
 822a178:	00002106 	br	822a200 <dhc_upcall+0x798>
      }
   }
   else     /* plain bootp reply */
   {
      dsc_bpreplys++;
 822a17c:	d0a09517 	ldw	r2,-32172(gp)
 822a180:	10800044 	addi	r2,r2,1
 822a184:	d0a09515 	stw	r2,-32172(gp)
      dhc_extract_opts(iface,&bp->options[4]);
 822a188:	e0bffa17 	ldw	r2,-24(fp)
 822a18c:	10803c04 	addi	r2,r2,240
 822a190:	100b883a 	mov	r5,r2
 822a194:	e13ff917 	ldw	r4,-28(fp)
 822a198:	822b9200 	call	822b920 <dhc_extract_opts>
      dhc_states[iface].ipaddr = bp->yiaddr;
 822a19c:	e0bffa17 	ldw	r2,-24(fp)
 822a1a0:	10c00417 	ldw	r3,16(r2)
 822a1a4:	008209b4 	movhi	r2,2086
 822a1a8:	10b84a04 	addi	r2,r2,-7896
 822a1ac:	e13ff917 	ldw	r4,-28(fp)
 822a1b0:	21000f24 	muli	r4,r4,60
 822a1b4:	1105883a 	add	r2,r2,r4
 822a1b8:	10800904 	addi	r2,r2,36
 822a1bc:	10c00015 	stw	r3,0(r2)
      dhc_setip(iface);
 822a1c0:	e13ff917 	ldw	r4,-28(fp)
 822a1c4:	822b40c0 	call	822b40c <dhc_setip>

      /* Set values so that DHCP State Machine remains happy */
      dhc_set_state(iface,DHCS_BOUND);
 822a1c8:	01400184 	movi	r5,6
 822a1cc:	e13ff917 	ldw	r4,-28(fp)
 822a1d0:	822c4600 	call	822c460 <dhc_set_state>
      dhc_states[iface].t1    = DHC_INFINITY ;
 822a1d4:	008209b4 	movhi	r2,2086
 822a1d8:	10b84a04 	addi	r2,r2,-7896
 822a1dc:	e0fff917 	ldw	r3,-28(fp)
 822a1e0:	18c00f24 	muli	r3,r3,60
 822a1e4:	10c5883a 	add	r2,r2,r3
 822a1e8:	10800604 	addi	r2,r2,24
 822a1ec:	00ffffc4 	movi	r3,-1
 822a1f0:	10c00015 	stw	r3,0(r2)
   }

   udp_free(pkt);
 822a1f4:	e13ffd17 	ldw	r4,-12(fp)
 822a1f8:	82453180 	call	8245318 <udp_free>
   return 0;
 822a1fc:	0005883a 	mov	r2,zero
}
 822a200:	e6ffff04 	addi	sp,fp,-4
 822a204:	dfc00217 	ldw	ra,8(sp)
 822a208:	df000117 	ldw	fp,4(sp)
 822a20c:	dc000017 	ldw	r16,0(sp)
 822a210:	dec00304 	addi	sp,sp,12
 822a214:	f800283a 	ret

0822a218 <dhc_buildheader>:
 * RETURNS: Returns 0 on success, else an ENP_ error code. 
 */

int
dhc_buildheader(int iface, struct bootp * outbp)
{
 822a218:	defffb04 	addi	sp,sp,-20
 822a21c:	dfc00415 	stw	ra,16(sp)
 822a220:	df000315 	stw	fp,12(sp)
 822a224:	df000304 	addi	fp,sp,12
 822a228:	e13ffe15 	stw	r4,-8(fp)
 822a22c:	e17fff15 	stw	r5,-4(fp)
   int   addrlen;    /* length of hardware address */

   MEMSET(outbp, 0, sizeof(struct bootp));   /* most of this is 0 anyway */
 822a230:	01804b04 	movi	r6,300
 822a234:	000b883a 	mov	r5,zero
 822a238:	e13fff17 	ldw	r4,-4(fp)
 822a23c:	82031300 	call	8203130 <memset>
   outbp->op = BOOTREQUEST;
 822a240:	e0bfff17 	ldw	r2,-4(fp)
 822a244:	00c00044 	movi	r3,1
 822a248:	10c00005 	stb	r3,0(r2)

   /* map SNMPish hardware types into bootp types */
   switch (nets[iface]->n_mib->ifType)
 822a24c:	008209b4 	movhi	r2,2086
 822a250:	10b82404 	addi	r2,r2,-8048
 822a254:	e0fffe17 	ldw	r3,-8(fp)
 822a258:	18c7883a 	add	r3,r3,r3
 822a25c:	18c7883a 	add	r3,r3,r3
 822a260:	10c5883a 	add	r2,r2,r3
 822a264:	10800017 	ldw	r2,0(r2)
 822a268:	10802717 	ldw	r2,156(r2)
 822a26c:	10800217 	ldw	r2,8(r2)
 822a270:	10c005e0 	cmpeqi	r3,r2,23
 822a274:	1800081e 	bne	r3,zero,822a298 <dhc_buildheader+0x80>
 822a278:	10c00720 	cmpeqi	r3,r2,28
 822a27c:	1800061e 	bne	r3,zero,822a298 <dhc_buildheader+0x80>
 822a280:	108001a0 	cmpeqi	r2,r2,6
 822a284:	10000826 	beq	r2,zero,822a2a8 <dhc_buildheader+0x90>
   {
   case ETHERNET:       /* ETHERNET defined in net.h */
      outbp->htype = ETHHWTYPE;  /* defined in dhcp.h */
 822a288:	e0bfff17 	ldw	r2,-4(fp)
 822a28c:	00c00044 	movi	r3,1
 822a290:	10c00045 	stb	r3,1(r2)
   break;
 822a294:	00000706 	br	822a2b4 <dhc_buildheader+0x9c>
   case PPP:
   case SLIP:
      outbp->htype = LINEHWTYPE;    /* line type for PPP or SLIP */
 822a298:	e0bfff17 	ldw	r2,-4(fp)
 822a29c:	00c00504 	movi	r3,20
 822a2a0:	10c00045 	stb	r3,1(r2)
   break;
 822a2a4:	00000306 	br	822a2b4 <dhc_buildheader+0x9c>
      default:
      dtrap();
 822a2a8:	822d4140 	call	822d414 <dtrap>
      return ENP_LOGIC;             /* this shouldn't happen */
 822a2ac:	00bffd44 	movi	r2,-11
 822a2b0:	00004d06 	br	822a3e8 <dhc_buildheader+0x1d0>
   }

   addrlen = min(16, nets[iface]->n_hal);
 822a2b4:	008209b4 	movhi	r2,2086
 822a2b8:	10b82404 	addi	r2,r2,-8048
 822a2bc:	e0fffe17 	ldw	r3,-8(fp)
 822a2c0:	18c7883a 	add	r3,r3,r3
 822a2c4:	18c7883a 	add	r3,r3,r3
 822a2c8:	10c5883a 	add	r2,r2,r3
 822a2cc:	10800017 	ldw	r2,0(r2)
 822a2d0:	10801117 	ldw	r2,68(r2)
 822a2d4:	10c00470 	cmpltui	r3,r2,17
 822a2d8:	1800011e 	bne	r3,zero,822a2e0 <dhc_buildheader+0xc8>
 822a2dc:	00800404 	movi	r2,16
 822a2e0:	e0bffd15 	stw	r2,-12(fp)
   outbp->hlen = (u_char)addrlen;
 822a2e4:	e0bffd17 	ldw	r2,-12(fp)
 822a2e8:	1007883a 	mov	r3,r2
 822a2ec:	e0bfff17 	ldw	r2,-4(fp)
 822a2f0:	10c00085 	stb	r3,2(r2)
   outbp->hops = 0;
 822a2f4:	e0bfff17 	ldw	r2,-4(fp)
 822a2f8:	100000c5 	stb	zero,3(r2)
   if(dhc_states[iface].state == DHCS_RENEWING) 
 822a2fc:	008209b4 	movhi	r2,2086
 822a300:	10b84a04 	addi	r2,r2,-7896
 822a304:	e0fffe17 	ldw	r3,-8(fp)
 822a308:	18c00f24 	muli	r3,r3,60
 822a30c:	10c5883a 	add	r2,r2,r3
 822a310:	10800017 	ldw	r2,0(r2)
 822a314:	108001d8 	cmpnei	r2,r2,7
 822a318:	1000031e 	bne	r2,zero,822a328 <dhc_buildheader+0x110>
      outbp->flags = 0; /* Renewing needs unicast */
 822a31c:	e0bfff17 	ldw	r2,-4(fp)
 822a320:	1000028d 	sth	zero,10(r2)
 822a324:	00000306 	br	822a334 <dhc_buildheader+0x11c>
   else
      outbp->flags = htons(DHC_BCASTFLAG); /* Othwise broadcast */
 822a328:	e0bfff17 	ldw	r2,-4(fp)
 822a32c:	00c02004 	movi	r3,128
 822a330:	10c0028d 	sth	r3,10(r2)
   outbp->xid = dhc_states[iface].xid;
 822a334:	008209b4 	movhi	r2,2086
 822a338:	10b84a04 	addi	r2,r2,-7896
 822a33c:	e0fffe17 	ldw	r3,-8(fp)
 822a340:	18c00f24 	muli	r3,r3,60
 822a344:	10c5883a 	add	r2,r2,r3
 822a348:	10800204 	addi	r2,r2,8
 822a34c:	10c00017 	ldw	r3,0(r2)
 822a350:	e0bfff17 	ldw	r2,-4(fp)
 822a354:	10c00115 	stw	r3,4(r2)
   outbp->secs = dhc_states[iface].secs;
 822a358:	008209b4 	movhi	r2,2086
 822a35c:	10b84a04 	addi	r2,r2,-7896
 822a360:	e0fffe17 	ldw	r3,-8(fp)
 822a364:	18c00f24 	muli	r3,r3,60
 822a368:	10c5883a 	add	r2,r2,r3
 822a36c:	10800304 	addi	r2,r2,12
 822a370:	10c0000b 	ldhu	r3,0(r2)
 822a374:	e0bfff17 	ldw	r2,-4(fp)
 822a378:	10c0020d 	sth	r3,8(r2)
#ifdef NPDEBUG
   /* make sure net[] has a MAC address, even if length is zero */
   if(nets[iface]->mib.ifPhysAddress == NULL)
 822a37c:	008209b4 	movhi	r2,2086
 822a380:	10b82404 	addi	r2,r2,-8048
 822a384:	e0fffe17 	ldw	r3,-8(fp)
 822a388:	18c7883a 	add	r3,r3,r3
 822a38c:	18c7883a 	add	r3,r3,r3
 822a390:	10c5883a 	add	r2,r2,r3
 822a394:	10800017 	ldw	r2,0(r2)
 822a398:	10801717 	ldw	r2,92(r2)
 822a39c:	1000031e 	bne	r2,zero,822a3ac <dhc_buildheader+0x194>
   {
      dtrap();
 822a3a0:	822d4140 	call	822d414 <dtrap>
      return ENP_LOGIC;
 822a3a4:	00bffd44 	movi	r2,-11
 822a3a8:	00000f06 	br	822a3e8 <dhc_buildheader+0x1d0>
   }
#endif
   MEMCPY(outbp->chaddr, nets[iface]->mib.ifPhysAddress, addrlen);
 822a3ac:	e0bfff17 	ldw	r2,-4(fp)
 822a3b0:	11000704 	addi	r4,r2,28
 822a3b4:	008209b4 	movhi	r2,2086
 822a3b8:	10b82404 	addi	r2,r2,-8048
 822a3bc:	e0fffe17 	ldw	r3,-8(fp)
 822a3c0:	18c7883a 	add	r3,r3,r3
 822a3c4:	18c7883a 	add	r3,r3,r3
 822a3c8:	10c5883a 	add	r2,r2,r3
 822a3cc:	10800017 	ldw	r2,0(r2)
 822a3d0:	10801717 	ldw	r2,92(r2)
 822a3d4:	e0fffd17 	ldw	r3,-12(fp)
 822a3d8:	180d883a 	mov	r6,r3
 822a3dc:	100b883a 	mov	r5,r2
 822a3e0:	8202e8c0 	call	8202e8c <memcpy>

   /* return success */
   return 0;
 822a3e4:	0005883a 	mov	r2,zero
}
 822a3e8:	e037883a 	mov	sp,fp
 822a3ec:	dfc00117 	ldw	ra,4(sp)
 822a3f0:	df000017 	ldw	fp,0(sp)
 822a3f4:	dec00204 	addi	sp,sp,8
 822a3f8:	f800283a 	ret

0822a3fc <dhc_discover>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_discover(int iface)
{
 822a3fc:	defff604 	addi	sp,sp,-40
 822a400:	dfc00915 	stw	ra,36(sp)
 822a404:	df000815 	stw	fp,32(sp)
 822a408:	df000804 	addi	fp,sp,32
 822a40c:	e13fff15 	stw	r4,-4(fp)
   u_char * opts;       /* scratch pointer to DHCP options field */
   long     leasetime;
   int      e;

   /* get a UDP packet buffer for DHCP sending */
   pkt = udp_alloc(sizeof(struct bootp), 0);
 822a410:	000b883a 	mov	r5,zero
 822a414:	01004b04 	movi	r4,300
 822a418:	82452380 	call	8245238 <udp_alloc>
 822a41c:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 822a420:	e0bffa17 	ldw	r2,-24(fp)
 822a424:	1000021e 	bne	r2,zero,822a430 <dhc_discover+0x34>
      return ENP_NOMEM;
 822a428:	00bffb04 	movi	r2,-20
 822a42c:	00011806 	br	822a890 <dhc_discover+0x494>
   pkt->nb_plen = sizeof(struct bootp);
 822a430:	e0bffa17 	ldw	r2,-24(fp)
 822a434:	00c04b04 	movi	r3,300
 822a438:	10c00415 	stw	r3,16(r2)

   /* start a new DHCP transaction */
   dhc_states[iface].xid = xids++;
 822a43c:	d0a03317 	ldw	r2,-32564(gp)
 822a440:	10c00044 	addi	r3,r2,1
 822a444:	d0e03315 	stw	r3,-32564(gp)
 822a448:	1009883a 	mov	r4,r2
 822a44c:	008209b4 	movhi	r2,2086
 822a450:	10b84a04 	addi	r2,r2,-7896
 822a454:	e0ffff17 	ldw	r3,-4(fp)
 822a458:	18c00f24 	muli	r3,r3,60
 822a45c:	10c5883a 	add	r2,r2,r3
 822a460:	10800204 	addi	r2,r2,8
 822a464:	11000015 	stw	r4,0(r2)
   dhc_states[iface].secs = (unsigned short)(sysuptime()/100L);
 822a468:	823d1700 	call	823d170 <sysuptime>
 822a46c:	01401904 	movi	r5,100
 822a470:	1009883a 	mov	r4,r2
 822a474:	8202b8c0 	call	8202b8c <__udivsi3>
 822a478:	1009883a 	mov	r4,r2
 822a47c:	008209b4 	movhi	r2,2086
 822a480:	10b84a04 	addi	r2,r2,-7896
 822a484:	e0ffff17 	ldw	r3,-4(fp)
 822a488:	18c00f24 	muli	r3,r3,60
 822a48c:	10c5883a 	add	r2,r2,r3
 822a490:	10800304 	addi	r2,r2,12
 822a494:	1100000d 	sth	r4,0(r2)

   /* set up DHCP/BOOTP header in buffer */
   outbp = (struct bootp *)pkt->nb_prot;     /* overlay bootp struct on buffer */
 822a498:	e0bffa17 	ldw	r2,-24(fp)
 822a49c:	10800317 	ldw	r2,12(r2)
 822a4a0:	e0bffb15 	stw	r2,-20(fp)
   e = dhc_buildheader(iface,outbp);
 822a4a4:	e17ffb17 	ldw	r5,-20(fp)
 822a4a8:	e13fff17 	ldw	r4,-4(fp)
 822a4ac:	822a2180 	call	822a218 <dhc_buildheader>
 822a4b0:	e0bffc15 	stw	r2,-16(fp)
   if (e)
 822a4b4:	e0bffc17 	ldw	r2,-16(fp)
 822a4b8:	10000226 	beq	r2,zero,822a4c4 <dhc_discover+0xc8>
      return e;
 822a4bc:	e0bffc17 	ldw	r2,-16(fp)
 822a4c0:	0000f306 	br	822a890 <dhc_discover+0x494>

   /* and turn it into a DHCP DISCOVER packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 822a4c4:	e0bffb17 	ldw	r2,-20(fp)
 822a4c8:	10c03b04 	addi	r3,r2,236
 822a4cc:	0098d534 	movhi	r2,25428
 822a4d0:	10a098c4 	addi	r2,r2,-32157
 822a4d4:	18800015 	stw	r2,0(r3)
   opts = &outbp->options[4];    /* encode options after cookie */
 822a4d8:	e0bffb17 	ldw	r2,-20(fp)
 822a4dc:	10803c04 	addi	r2,r2,240
 822a4e0:	e0bff815 	stw	r2,-32(fp)
   *opts++ = DHOP_TYPE;
 822a4e4:	e0bff817 	ldw	r2,-32(fp)
 822a4e8:	10c00044 	addi	r3,r2,1
 822a4ec:	e0fff815 	stw	r3,-32(fp)
 822a4f0:	00c00d44 	movi	r3,53
 822a4f4:	10c00005 	stb	r3,0(r2)
   *opts++ = 1;   /* length of option field */
 822a4f8:	e0bff817 	ldw	r2,-32(fp)
 822a4fc:	10c00044 	addi	r3,r2,1
 822a500:	e0fff815 	stw	r3,-32(fp)
 822a504:	00c00044 	movi	r3,1
 822a508:	10c00005 	stb	r3,0(r2)
   *opts++ = DHCP_DISCOVER;
 822a50c:	e0bff817 	ldw	r2,-32(fp)
 822a510:	10c00044 	addi	r3,r2,1
 822a514:	e0fff815 	stw	r3,-32(fp)
 822a518:	00c00044 	movi	r3,1
 822a51c:	10c00005 	stb	r3,0(r2)
   leasetime = -1L ;    /* ask for infinite lease */
 822a520:	00bfffc4 	movi	r2,-1
 822a524:	e0bffd15 	stw	r2,-12(fp)
   PUT_IP_OPT(opts, DHOP_LEASE, leasetime);
 822a528:	e0bff817 	ldw	r2,-32(fp)
 822a52c:	10c00044 	addi	r3,r2,1
 822a530:	e0fff815 	stw	r3,-32(fp)
 822a534:	00c00cc4 	movi	r3,51
 822a538:	10c00005 	stb	r3,0(r2)
 822a53c:	e0bff817 	ldw	r2,-32(fp)
 822a540:	10c00044 	addi	r3,r2,1
 822a544:	e0fff815 	stw	r3,-32(fp)
 822a548:	00c00104 	movi	r3,4
 822a54c:	10c00005 	stb	r3,0(r2)
 822a550:	e0bff817 	ldw	r2,-32(fp)
 822a554:	108000c4 	addi	r2,r2,3
 822a558:	e0fffd04 	addi	r3,fp,-12
 822a55c:	18c00003 	ldbu	r3,0(r3)
 822a560:	10c00005 	stb	r3,0(r2)
 822a564:	e0bff817 	ldw	r2,-32(fp)
 822a568:	10c00084 	addi	r3,r2,2
 822a56c:	e0bffd04 	addi	r2,fp,-12
 822a570:	10800044 	addi	r2,r2,1
 822a574:	10800003 	ldbu	r2,0(r2)
 822a578:	18800005 	stb	r2,0(r3)
 822a57c:	e0bff817 	ldw	r2,-32(fp)
 822a580:	10c00044 	addi	r3,r2,1
 822a584:	e0bffd04 	addi	r2,fp,-12
 822a588:	10800084 	addi	r2,r2,2
 822a58c:	10800003 	ldbu	r2,0(r2)
 822a590:	18800005 	stb	r2,0(r3)
 822a594:	e0bffd04 	addi	r2,fp,-12
 822a598:	108000c4 	addi	r2,r2,3
 822a59c:	10800003 	ldbu	r2,0(r2)
 822a5a0:	1007883a 	mov	r3,r2
 822a5a4:	e0bff817 	ldw	r2,-32(fp)
 822a5a8:	10c00005 	stb	r3,0(r2)
 822a5ac:	e0bff817 	ldw	r2,-32(fp)
 822a5b0:	10800104 	addi	r2,r2,4
 822a5b4:	e0bff815 	stw	r2,-32(fp)

   /* if we already have an IP address, try to get it from the server */
   if (nets[iface]->n_ipaddr != 0)
 822a5b8:	008209b4 	movhi	r2,2086
 822a5bc:	10b82404 	addi	r2,r2,-8048
 822a5c0:	e0ffff17 	ldw	r3,-4(fp)
 822a5c4:	18c7883a 	add	r3,r3,r3
 822a5c8:	18c7883a 	add	r3,r3,r3
 822a5cc:	10c5883a 	add	r2,r2,r3
 822a5d0:	10800017 	ldw	r2,0(r2)
 822a5d4:	10800a17 	ldw	r2,40(r2)
 822a5d8:	10004e26 	beq	r2,zero,822a714 <dhc_discover+0x318>
   {
      ip_addr my_ip = htonl(nets[iface]->n_ipaddr);
 822a5dc:	008209b4 	movhi	r2,2086
 822a5e0:	10b82404 	addi	r2,r2,-8048
 822a5e4:	e0ffff17 	ldw	r3,-4(fp)
 822a5e8:	18c7883a 	add	r3,r3,r3
 822a5ec:	18c7883a 	add	r3,r3,r3
 822a5f0:	10c5883a 	add	r2,r2,r3
 822a5f4:	10800017 	ldw	r2,0(r2)
 822a5f8:	10800a17 	ldw	r2,40(r2)
 822a5fc:	1008d63a 	srli	r4,r2,24
 822a600:	008209b4 	movhi	r2,2086
 822a604:	10b82404 	addi	r2,r2,-8048
 822a608:	e0ffff17 	ldw	r3,-4(fp)
 822a60c:	18c7883a 	add	r3,r3,r3
 822a610:	18c7883a 	add	r3,r3,r3
 822a614:	10c5883a 	add	r2,r2,r3
 822a618:	10800017 	ldw	r2,0(r2)
 822a61c:	10800a17 	ldw	r2,40(r2)
 822a620:	1004d23a 	srli	r2,r2,8
 822a624:	10bfc00c 	andi	r2,r2,65280
 822a628:	2088b03a 	or	r4,r4,r2
 822a62c:	008209b4 	movhi	r2,2086
 822a630:	10b82404 	addi	r2,r2,-8048
 822a634:	e0ffff17 	ldw	r3,-4(fp)
 822a638:	18c7883a 	add	r3,r3,r3
 822a63c:	18c7883a 	add	r3,r3,r3
 822a640:	10c5883a 	add	r2,r2,r3
 822a644:	10800017 	ldw	r2,0(r2)
 822a648:	10800a17 	ldw	r2,40(r2)
 822a64c:	10bfc00c 	andi	r2,r2,65280
 822a650:	1004923a 	slli	r2,r2,8
 822a654:	2088b03a 	or	r4,r4,r2
 822a658:	008209b4 	movhi	r2,2086
 822a65c:	10b82404 	addi	r2,r2,-8048
 822a660:	e0ffff17 	ldw	r3,-4(fp)
 822a664:	18c7883a 	add	r3,r3,r3
 822a668:	18c7883a 	add	r3,r3,r3
 822a66c:	10c5883a 	add	r2,r2,r3
 822a670:	10800017 	ldw	r2,0(r2)
 822a674:	10800a17 	ldw	r2,40(r2)
 822a678:	1004963a 	slli	r2,r2,24
 822a67c:	2084b03a 	or	r2,r4,r2
 822a680:	e0bffe15 	stw	r2,-8(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, my_ip);
 822a684:	e0bff817 	ldw	r2,-32(fp)
 822a688:	10c00044 	addi	r3,r2,1
 822a68c:	e0fff815 	stw	r3,-32(fp)
 822a690:	00c00c84 	movi	r3,50
 822a694:	10c00005 	stb	r3,0(r2)
 822a698:	e0bff817 	ldw	r2,-32(fp)
 822a69c:	10c00044 	addi	r3,r2,1
 822a6a0:	e0fff815 	stw	r3,-32(fp)
 822a6a4:	00c00104 	movi	r3,4
 822a6a8:	10c00005 	stb	r3,0(r2)
 822a6ac:	e0bff817 	ldw	r2,-32(fp)
 822a6b0:	108000c4 	addi	r2,r2,3
 822a6b4:	e0fffe04 	addi	r3,fp,-8
 822a6b8:	18c00003 	ldbu	r3,0(r3)
 822a6bc:	10c00005 	stb	r3,0(r2)
 822a6c0:	e0bff817 	ldw	r2,-32(fp)
 822a6c4:	10c00084 	addi	r3,r2,2
 822a6c8:	e0bffe04 	addi	r2,fp,-8
 822a6cc:	10800044 	addi	r2,r2,1
 822a6d0:	10800003 	ldbu	r2,0(r2)
 822a6d4:	18800005 	stb	r2,0(r3)
 822a6d8:	e0bff817 	ldw	r2,-32(fp)
 822a6dc:	10c00044 	addi	r3,r2,1
 822a6e0:	e0bffe04 	addi	r2,fp,-8
 822a6e4:	10800084 	addi	r2,r2,2
 822a6e8:	10800003 	ldbu	r2,0(r2)
 822a6ec:	18800005 	stb	r2,0(r3)
 822a6f0:	e0bffe04 	addi	r2,fp,-8
 822a6f4:	108000c4 	addi	r2,r2,3
 822a6f8:	10800003 	ldbu	r2,0(r2)
 822a6fc:	1007883a 	mov	r3,r2
 822a700:	e0bff817 	ldw	r2,-32(fp)
 822a704:	10c00005 	stb	r3,0(r2)
 822a708:	e0bff817 	ldw	r2,-32(fp)
 822a70c:	10800104 	addi	r2,r2,4
 822a710:	e0bff815 	stw	r2,-32(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 822a714:	d0a03517 	ldw	r2,-32556(gp)
 822a718:	00801a0e 	bge	zero,r2,822a784 <dhc_discover+0x388>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 822a71c:	e0bff817 	ldw	r2,-32(fp)
 822a720:	10c00044 	addi	r3,r2,1
 822a724:	e0fff815 	stw	r3,-32(fp)
 822a728:	00c00dc4 	movi	r3,55
 822a72c:	10c00005 	stb	r3,0(r2)
      *opts++ = (u_char)reqlist_len ;
 822a730:	e0bff817 	ldw	r2,-32(fp)
 822a734:	10c00044 	addi	r3,r2,1
 822a738:	e0fff815 	stw	r3,-32(fp)
 822a73c:	d0e03517 	ldw	r3,-32556(gp)
 822a740:	10c00005 	stb	r3,0(r2)

      for (i=0 ; i < reqlist_len ; i++ )
 822a744:	e03ff915 	stw	zero,-28(fp)
 822a748:	00000b06 	br	822a778 <dhc_discover+0x37c>
         *opts++ = reqlist[i];
 822a74c:	e0bff817 	ldw	r2,-32(fp)
 822a750:	10c00044 	addi	r3,r2,1
 822a754:	e0fff815 	stw	r3,-32(fp)
 822a758:	e13ff917 	ldw	r4,-28(fp)
 822a75c:	d0e03404 	addi	r3,gp,-32560
 822a760:	20c7883a 	add	r3,r4,r3
 822a764:	18c00003 	ldbu	r3,0(r3)
 822a768:	10c00005 	stb	r3,0(r2)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 822a76c:	e0bff917 	ldw	r2,-28(fp)
 822a770:	10800044 	addi	r2,r2,1
 822a774:	e0bff915 	stw	r2,-28(fp)
 822a778:	d0a03517 	ldw	r2,-32556(gp)
 822a77c:	e0fff917 	ldw	r3,-28(fp)
 822a780:	18bff216 	blt	r3,r2,822a74c <dhc_discover+0x350>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   *opts++ = DHOP_END;
 822a784:	e0bff817 	ldw	r2,-32(fp)
 822a788:	10c00044 	addi	r3,r2,1
 822a78c:	e0fff815 	stw	r3,-32(fp)
 822a790:	00ffffc4 	movi	r3,-1
 822a794:	10c00005 	stb	r3,0(r2)

   /* last_tick needs to be set in case we are doing a retry. It 
    * prevents dhc_second from calling us to do another retry while 
    * we are stuck 
    */
   dhc_states[iface].last_tick = cticks;
 822a798:	d0e0a817 	ldw	r3,-32096(gp)
 822a79c:	008209b4 	movhi	r2,2086
 822a7a0:	10b84a04 	addi	r2,r2,-7896
 822a7a4:	e13fff17 	ldw	r4,-4(fp)
 822a7a8:	21000f24 	muli	r4,r4,60
 822a7ac:	1105883a 	add	r2,r2,r4
 822a7b0:	10800404 	addi	r2,r2,16
 822a7b4:	10c00015 	stw	r3,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast discovery request */
 822a7b8:	e0bffa17 	ldw	r2,-24(fp)
 822a7bc:	00ffffc4 	movi	r3,-1
 822a7c0:	10c00715 	stw	r3,28(r2)
   pkt->net = nets[iface];    /* send out caller spec'ed net */
 822a7c4:	008209b4 	movhi	r2,2086
 822a7c8:	10b82404 	addi	r2,r2,-8048
 822a7cc:	e0ffff17 	ldw	r3,-4(fp)
 822a7d0:	18c7883a 	add	r3,r3,r3
 822a7d4:	18c7883a 	add	r3,r3,r3
 822a7d8:	10c5883a 	add	r2,r2,r3
 822a7dc:	10c00017 	ldw	r3,0(r2)
 822a7e0:	e0bffa17 	ldw	r2,-24(fp)
 822a7e4:	10c00615 	stw	r3,24(r2)

   /* we need to change the DHCP state before sending to avoid a 
    * race condition with the expected reply 
    */
   if (dhc_states[iface].state != DHCS_SELECTING)
 822a7e8:	008209b4 	movhi	r2,2086
 822a7ec:	10b84a04 	addi	r2,r2,-7896
 822a7f0:	e0ffff17 	ldw	r3,-4(fp)
 822a7f4:	18c00f24 	muli	r3,r3,60
 822a7f8:	10c5883a 	add	r2,r2,r3
 822a7fc:	10800017 	ldw	r2,0(r2)
 822a800:	10800120 	cmpeqi	r2,r2,4
 822a804:	1000031e 	bne	r2,zero,822a814 <dhc_discover+0x418>
      dhc_set_state(iface, DHCS_SELECTING);
 822a808:	01400104 	movi	r5,4
 822a80c:	e13fff17 	ldw	r4,-4(fp)
 822a810:	822c4600 	call	822c460 <dhc_set_state>

   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 822a814:	e1bffa17 	ldw	r6,-24(fp)
 822a818:	01401104 	movi	r5,68
 822a81c:	010010c4 	movi	r4,67
 822a820:	8244dfc0 	call	8244dfc <udp_send>
   dsc_discovers++;
 822a824:	d0a09117 	ldw	r2,-32188(gp)
 822a828:	10800044 	addi	r2,r2,1
 822a82c:	d0a09115 	stw	r2,-32188(gp)

   /* state info is the same even if udp_send() failed */
   dhc_states[iface].last_tick = cticks;     /* set this again, post udp_send */
 822a830:	d0e0a817 	ldw	r3,-32096(gp)
 822a834:	008209b4 	movhi	r2,2086
 822a838:	10b84a04 	addi	r2,r2,-7896
 822a83c:	e13fff17 	ldw	r4,-4(fp)
 822a840:	21000f24 	muli	r4,r4,60
 822a844:	1105883a 	add	r2,r2,r4
 822a848:	10800404 	addi	r2,r2,16
 822a84c:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].tries++;
 822a850:	008209b4 	movhi	r2,2086
 822a854:	10b84a04 	addi	r2,r2,-7896
 822a858:	e0ffff17 	ldw	r3,-4(fp)
 822a85c:	18c00f24 	muli	r3,r3,60
 822a860:	10c5883a 	add	r2,r2,r3
 822a864:	10800104 	addi	r2,r2,4
 822a868:	10800017 	ldw	r2,0(r2)
 822a86c:	10c00044 	addi	r3,r2,1
 822a870:	008209b4 	movhi	r2,2086
 822a874:	10b84a04 	addi	r2,r2,-7896
 822a878:	e13fff17 	ldw	r4,-4(fp)
 822a87c:	21000f24 	muli	r4,r4,60
 822a880:	1105883a 	add	r2,r2,r4
 822a884:	10800104 	addi	r2,r2,4
 822a888:	10c00015 	stw	r3,0(r2)

   return 0;
 822a88c:	0005883a 	mov	r2,zero
}
 822a890:	e037883a 	mov	sp,fp
 822a894:	dfc00117 	ldw	ra,4(sp)
 822a898:	df000017 	ldw	fp,0(sp)
 822a89c:	dec00204 	addi	sp,sp,8
 822a8a0:	f800283a 	ret

0822a8a4 <dhc_rx_offer>:
 * RETURNS: 0 if OK, else ENP_ error
 */

int
dhc_rx_offer(int iface, struct bootp * bp, unsigned bplen)
{
 822a8a4:	defff904 	addi	sp,sp,-28
 822a8a8:	dfc00615 	stw	ra,24(sp)
 822a8ac:	df000515 	stw	fp,20(sp)
 822a8b0:	df000504 	addi	fp,sp,20
 822a8b4:	e13ffd15 	stw	r4,-12(fp)
 822a8b8:	e17ffe15 	stw	r5,-8(fp)
 822a8bc:	e1bfff15 	stw	r6,-4(fp)
   u_char * opts;
   int   e;

   if (dhc_states[iface].xid != bp->xid)
 822a8c0:	008209b4 	movhi	r2,2086
 822a8c4:	10b84a04 	addi	r2,r2,-7896
 822a8c8:	e0fffd17 	ldw	r3,-12(fp)
 822a8cc:	18c00f24 	muli	r3,r3,60
 822a8d0:	10c5883a 	add	r2,r2,r3
 822a8d4:	10800204 	addi	r2,r2,8
 822a8d8:	10c00017 	ldw	r3,0(r2)
 822a8dc:	e0bffe17 	ldw	r2,-8(fp)
 822a8e0:	10800117 	ldw	r2,4(r2)
 822a8e4:	18800226 	beq	r3,r2,822a8f0 <dhc_rx_offer+0x4c>
      return ENP_NOT_MINE;
 822a8e8:	00800084 	movi	r2,2
 822a8ec:	00002106 	br	822a974 <dhc_rx_offer+0xd0>

   opts = &bp->options[4];    /* examine options after cookie */
 822a8f0:	e0bffe17 	ldw	r2,-8(fp)
 822a8f4:	10803c04 	addi	r2,r2,240
 822a8f8:	e0bffb15 	stw	r2,-20(fp)
   e = dhc_extract_opts(iface,opts);
 822a8fc:	e17ffb17 	ldw	r5,-20(fp)
 822a900:	e13ffd17 	ldw	r4,-12(fp)
 822a904:	822b9200 	call	822b920 <dhc_extract_opts>
 822a908:	e0bffc15 	stw	r2,-16(fp)
   if (e)   /* parse error? */
 822a90c:	e0bffc17 	ldw	r2,-16(fp)
 822a910:	10000326 	beq	r2,zero,822a920 <dhc_rx_offer+0x7c>
   {
      dtrap();
 822a914:	822d4140 	call	822d414 <dtrap>
      return e;
 822a918:	e0bffc17 	ldw	r2,-16(fp)
 822a91c:	00001506 	br	822a974 <dhc_rx_offer+0xd0>
   }
   if (!bp->yiaddr)  /* require an IP address */
 822a920:	e0bffe17 	ldw	r2,-8(fp)
 822a924:	10800417 	ldw	r2,16(r2)
 822a928:	1000061e 	bne	r2,zero,822a944 <dhc_rx_offer+0xa0>
   {
      dhc_decline(iface,bp, bplen);
 822a92c:	e1bfff17 	ldw	r6,-4(fp)
 822a930:	e17ffe17 	ldw	r5,-8(fp)
 822a934:	e13ffd17 	ldw	r4,-12(fp)
 822a938:	822b76c0 	call	822b76c <dhc_decline>
      return ENP_NOT_MINE;
 822a93c:	00800084 	movi	r2,2
 822a940:	00000c06 	br	822a974 <dhc_rx_offer+0xd0>
   }
   dhc_states[iface].ipaddr = bp->yiaddr;
 822a944:	e0bffe17 	ldw	r2,-8(fp)
 822a948:	10c00417 	ldw	r3,16(r2)
 822a94c:	008209b4 	movhi	r2,2086
 822a950:	10b84a04 	addi	r2,r2,-7896
 822a954:	e13ffd17 	ldw	r4,-12(fp)
 822a958:	21000f24 	muli	r4,r4,60
 822a95c:	1105883a 	add	r2,r2,r4
 822a960:	10800904 	addi	r2,r2,36
 822a964:	10c00015 	stw	r3,0(r2)

   /* if we got here, we must like the offer -- send a DHCP REQUEST */
   return (dhc_request(iface,FALSE));
 822a968:	000b883a 	mov	r5,zero
 822a96c:	e13ffd17 	ldw	r4,-12(fp)
 822a970:	822a9880 	call	822a988 <dhc_request>
}
 822a974:	e037883a 	mov	sp,fp
 822a978:	dfc00117 	ldw	ra,4(sp)
 822a97c:	df000017 	ldw	fp,0(sp)
 822a980:	dec00204 	addi	sp,sp,8
 822a984:	f800283a 	ret

0822a988 <dhc_request>:
 * RETURNS:  Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_request(int iface,int xid_flag)
{
 822a988:	defff404 	addi	sp,sp,-48
 822a98c:	dfc00b15 	stw	ra,44(sp)
 822a990:	df000a15 	stw	fp,40(sp)
 822a994:	df000a04 	addi	fp,sp,40
 822a998:	e13ffe15 	stw	r4,-8(fp)
 822a99c:	e17fff15 	stw	r5,-4(fp)
   u_char  *   opts; /* scratch pointer to DHCP options field */
   ip_addr opt_ip;      /* IP address temporary */
   int      e;       /* error holder */

   /* get a UDP packet buffer for sending DHCP request */
   pkt = udp_alloc(sizeof(struct bootp) + DHCP_OPTSIZE - BOOTP_OPTSIZE, 0);
 822a9a0:	000b883a 	mov	r5,zero
 822a9a4:	01008904 	movi	r4,548
 822a9a8:	82452380 	call	8245238 <udp_alloc>
 822a9ac:	e0bff815 	stw	r2,-32(fp)
   if (!pkt) 
 822a9b0:	e0bff817 	ldw	r2,-32(fp)
 822a9b4:	1000021e 	bne	r2,zero,822a9c0 <dhc_request+0x38>
      return ENP_NOMEM;
 822a9b8:	00bffb04 	movi	r2,-20
 822a9bc:	00028e06 	br	822b3f8 <dhc_request+0xa70>
   pkt->nb_plen = sizeof(struct bootp) - BOOTP_OPTSIZE;
 822a9c0:	e0bff817 	ldw	r2,-32(fp)
 822a9c4:	00c03b04 	movi	r3,236
 822a9c8:	10c00415 	stw	r3,16(r2)

   if ( xid_flag == TRUE )
 822a9cc:	e0bfff17 	ldw	r2,-4(fp)
 822a9d0:	10800058 	cmpnei	r2,r2,1
 822a9d4:	1000121e 	bne	r2,zero,822aa20 <dhc_request+0x98>
   {
      dhc_states[iface].xid  = xids++;
 822a9d8:	d0a03317 	ldw	r2,-32564(gp)
 822a9dc:	10c00044 	addi	r3,r2,1
 822a9e0:	d0e03315 	stw	r3,-32564(gp)
 822a9e4:	1009883a 	mov	r4,r2
 822a9e8:	008209b4 	movhi	r2,2086
 822a9ec:	10b84a04 	addi	r2,r2,-7896
 822a9f0:	e0fffe17 	ldw	r3,-8(fp)
 822a9f4:	18c00f24 	muli	r3,r3,60
 822a9f8:	10c5883a 	add	r2,r2,r3
 822a9fc:	10800204 	addi	r2,r2,8
 822aa00:	11000015 	stw	r4,0(r2)
      dhc_states[iface].secs = 0;
 822aa04:	008209b4 	movhi	r2,2086
 822aa08:	10b84a04 	addi	r2,r2,-7896
 822aa0c:	e0fffe17 	ldw	r3,-8(fp)
 822aa10:	18c00f24 	muli	r3,r3,60
 822aa14:	10c5883a 	add	r2,r2,r3
 822aa18:	10800304 	addi	r2,r2,12
 822aa1c:	1000000d 	sth	zero,0(r2)
   }

   /* build a BOOTP request header */
   outbp = (struct bootp *)pkt->nb_prot;
 822aa20:	e0bff817 	ldw	r2,-32(fp)
 822aa24:	10800317 	ldw	r2,12(r2)
 822aa28:	e0bff915 	stw	r2,-28(fp)
   e     = dhc_buildheader(iface,outbp);
 822aa2c:	e17ff917 	ldw	r5,-28(fp)
 822aa30:	e13ffe17 	ldw	r4,-8(fp)
 822aa34:	822a2180 	call	822a218 <dhc_buildheader>
 822aa38:	e0bffa15 	stw	r2,-24(fp)
   if (e)
 822aa3c:	e0bffa17 	ldw	r2,-24(fp)
 822aa40:	10000226 	beq	r2,zero,822aa4c <dhc_request+0xc4>
      return e;
 822aa44:	e0bffa17 	ldw	r2,-24(fp)
 822aa48:	00026b06 	br	822b3f8 <dhc_request+0xa70>

   /* turn it into a DHCP REQUEST packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 822aa4c:	e0bff917 	ldw	r2,-28(fp)
 822aa50:	10c03b04 	addi	r3,r2,236
 822aa54:	0098d534 	movhi	r2,25428
 822aa58:	10a098c4 	addi	r2,r2,-32157
 822aa5c:	18800015 	stw	r2,0(r3)
   opts    = &outbp->options[4];    /* encode options after cookie */
 822aa60:	e0bff917 	ldw	r2,-28(fp)
 822aa64:	10803c04 	addi	r2,r2,240
 822aa68:	e0bff615 	stw	r2,-40(fp)
   *opts++ = DHOP_TYPE;
 822aa6c:	e0bff617 	ldw	r2,-40(fp)
 822aa70:	10c00044 	addi	r3,r2,1
 822aa74:	e0fff615 	stw	r3,-40(fp)
 822aa78:	00c00d44 	movi	r3,53
 822aa7c:	10c00005 	stb	r3,0(r2)
   *opts++ = 1;   /* length of option field */
 822aa80:	e0bff617 	ldw	r2,-40(fp)
 822aa84:	10c00044 	addi	r3,r2,1
 822aa88:	e0fff615 	stw	r3,-40(fp)
 822aa8c:	00c00044 	movi	r3,1
 822aa90:	10c00005 	stb	r3,0(r2)
   *opts++ = DHCP_REQUEST;
 822aa94:	e0bff617 	ldw	r2,-40(fp)
 822aa98:	10c00044 	addi	r3,r2,1
 822aa9c:	e0fff615 	stw	r3,-40(fp)
 822aaa0:	00c000c4 	movi	r3,3
 822aaa4:	10c00005 	stb	r3,0(r2)

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822aaa8:	008209b4 	movhi	r2,2086
 822aaac:	10b84a04 	addi	r2,r2,-7896
 822aab0:	e0fffe17 	ldw	r3,-8(fp)
 822aab4:	18c00f24 	muli	r3,r3,60
 822aab8:	10c5883a 	add	r2,r2,r3
 822aabc:	10800017 	ldw	r2,0(r2)
 822aac0:	10800120 	cmpeqi	r2,r2,4
 822aac4:	1000181e 	bne	r2,zero,822ab28 <dhc_request+0x1a0>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
 822aac8:	008209b4 	movhi	r2,2086
 822aacc:	10b84a04 	addi	r2,r2,-7896
 822aad0:	e0fffe17 	ldw	r3,-8(fp)
 822aad4:	18c00f24 	muli	r3,r3,60
 822aad8:	10c5883a 	add	r2,r2,r3
 822aadc:	10800017 	ldw	r2,0(r2)
   *opts++ = DHOP_TYPE;
   *opts++ = 1;   /* length of option field */
   *opts++ = DHCP_REQUEST;

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822aae0:	10800160 	cmpeqi	r2,r2,5
 822aae4:	1000101e 	bne	r2,zero,822ab28 <dhc_request+0x1a0>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
 822aae8:	008209b4 	movhi	r2,2086
 822aaec:	10b84a04 	addi	r2,r2,-7896
 822aaf0:	e0fffe17 	ldw	r3,-8(fp)
 822aaf4:	18c00f24 	muli	r3,r3,60
 822aaf8:	10c5883a 	add	r2,r2,r3
 822aafc:	10800017 	ldw	r2,0(r2)
   *opts++ = 1;   /* length of option field */
   *opts++ = DHCP_REQUEST;

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
       (dhc_states[iface].state == DHCS_REQUESTING) ||
 822ab00:	108000e0 	cmpeqi	r2,r2,3
 822ab04:	1000081e 	bne	r2,zero,822ab28 <dhc_request+0x1a0>
       (dhc_states[iface].state == DHCS_REBOOTING) ||
       (dhc_states[iface].state == DHCS_INITREBOOT))
 822ab08:	008209b4 	movhi	r2,2086
 822ab0c:	10b84a04 	addi	r2,r2,-7896
 822ab10:	e0fffe17 	ldw	r3,-8(fp)
 822ab14:	18c00f24 	muli	r3,r3,60
 822ab18:	10c5883a 	add	r2,r2,r3
 822ab1c:	10800017 	ldw	r2,0(r2)
   *opts++ = DHCP_REQUEST;

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
 822ab20:	10800098 	cmpnei	r2,r2,2
 822ab24:	10004a1e 	bne	r2,zero,822ac50 <dhc_request+0x2c8>
       (dhc_states[iface].state == DHCS_INITREBOOT))
   {
      opt_ip = ntohl(dhc_states[iface].ipaddr);
 822ab28:	008209b4 	movhi	r2,2086
 822ab2c:	10b84a04 	addi	r2,r2,-7896
 822ab30:	e0fffe17 	ldw	r3,-8(fp)
 822ab34:	18c00f24 	muli	r3,r3,60
 822ab38:	10c5883a 	add	r2,r2,r3
 822ab3c:	10800904 	addi	r2,r2,36
 822ab40:	10800017 	ldw	r2,0(r2)
 822ab44:	1006d63a 	srli	r3,r2,24
 822ab48:	008209b4 	movhi	r2,2086
 822ab4c:	10b84a04 	addi	r2,r2,-7896
 822ab50:	e13ffe17 	ldw	r4,-8(fp)
 822ab54:	21000f24 	muli	r4,r4,60
 822ab58:	1105883a 	add	r2,r2,r4
 822ab5c:	10800904 	addi	r2,r2,36
 822ab60:	10800017 	ldw	r2,0(r2)
 822ab64:	1004d23a 	srli	r2,r2,8
 822ab68:	10bfc00c 	andi	r2,r2,65280
 822ab6c:	1886b03a 	or	r3,r3,r2
 822ab70:	008209b4 	movhi	r2,2086
 822ab74:	10b84a04 	addi	r2,r2,-7896
 822ab78:	e13ffe17 	ldw	r4,-8(fp)
 822ab7c:	21000f24 	muli	r4,r4,60
 822ab80:	1105883a 	add	r2,r2,r4
 822ab84:	10800904 	addi	r2,r2,36
 822ab88:	10800017 	ldw	r2,0(r2)
 822ab8c:	10bfc00c 	andi	r2,r2,65280
 822ab90:	1004923a 	slli	r2,r2,8
 822ab94:	1886b03a 	or	r3,r3,r2
 822ab98:	008209b4 	movhi	r2,2086
 822ab9c:	10b84a04 	addi	r2,r2,-7896
 822aba0:	e13ffe17 	ldw	r4,-8(fp)
 822aba4:	21000f24 	muli	r4,r4,60
 822aba8:	1105883a 	add	r2,r2,r4
 822abac:	10800904 	addi	r2,r2,36
 822abb0:	10800017 	ldw	r2,0(r2)
 822abb4:	1004963a 	slli	r2,r2,24
 822abb8:	1884b03a 	or	r2,r3,r2
 822abbc:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, opt_ip);
 822abc0:	e0bff617 	ldw	r2,-40(fp)
 822abc4:	10c00044 	addi	r3,r2,1
 822abc8:	e0fff615 	stw	r3,-40(fp)
 822abcc:	00c00c84 	movi	r3,50
 822abd0:	10c00005 	stb	r3,0(r2)
 822abd4:	e0bff617 	ldw	r2,-40(fp)
 822abd8:	10c00044 	addi	r3,r2,1
 822abdc:	e0fff615 	stw	r3,-40(fp)
 822abe0:	00c00104 	movi	r3,4
 822abe4:	10c00005 	stb	r3,0(r2)
 822abe8:	e0bff617 	ldw	r2,-40(fp)
 822abec:	108000c4 	addi	r2,r2,3
 822abf0:	e0fffd04 	addi	r3,fp,-12
 822abf4:	18c00003 	ldbu	r3,0(r3)
 822abf8:	10c00005 	stb	r3,0(r2)
 822abfc:	e0bff617 	ldw	r2,-40(fp)
 822ac00:	10c00084 	addi	r3,r2,2
 822ac04:	e0bffd04 	addi	r2,fp,-12
 822ac08:	10800044 	addi	r2,r2,1
 822ac0c:	10800003 	ldbu	r2,0(r2)
 822ac10:	18800005 	stb	r2,0(r3)
 822ac14:	e0bff617 	ldw	r2,-40(fp)
 822ac18:	10c00044 	addi	r3,r2,1
 822ac1c:	e0bffd04 	addi	r2,fp,-12
 822ac20:	10800084 	addi	r2,r2,2
 822ac24:	10800003 	ldbu	r2,0(r2)
 822ac28:	18800005 	stb	r2,0(r3)
 822ac2c:	e0bffd04 	addi	r2,fp,-12
 822ac30:	108000c4 	addi	r2,r2,3
 822ac34:	10800003 	ldbu	r2,0(r2)
 822ac38:	1007883a 	mov	r3,r2
 822ac3c:	e0bff617 	ldw	r2,-40(fp)
 822ac40:	10c00005 	stb	r3,0(r2)
 822ac44:	e0bff617 	ldw	r2,-40(fp)
 822ac48:	10800104 	addi	r2,r2,4
 822ac4c:	e0bff615 	stw	r2,-40(fp)
   }
   if (dhc_states[iface].snmask)
 822ac50:	008209b4 	movhi	r2,2086
 822ac54:	10b84a04 	addi	r2,r2,-7896
 822ac58:	e0fffe17 	ldw	r3,-8(fp)
 822ac5c:	18c00f24 	muli	r3,r3,60
 822ac60:	10c5883a 	add	r2,r2,r3
 822ac64:	10800a04 	addi	r2,r2,40
 822ac68:	10800017 	ldw	r2,0(r2)
 822ac6c:	10004a26 	beq	r2,zero,822ad98 <dhc_request+0x410>
   {
      opt_ip = ntohl(dhc_states[iface].snmask);
 822ac70:	008209b4 	movhi	r2,2086
 822ac74:	10b84a04 	addi	r2,r2,-7896
 822ac78:	e0fffe17 	ldw	r3,-8(fp)
 822ac7c:	18c00f24 	muli	r3,r3,60
 822ac80:	10c5883a 	add	r2,r2,r3
 822ac84:	10800a04 	addi	r2,r2,40
 822ac88:	10800017 	ldw	r2,0(r2)
 822ac8c:	1006d63a 	srli	r3,r2,24
 822ac90:	008209b4 	movhi	r2,2086
 822ac94:	10b84a04 	addi	r2,r2,-7896
 822ac98:	e13ffe17 	ldw	r4,-8(fp)
 822ac9c:	21000f24 	muli	r4,r4,60
 822aca0:	1105883a 	add	r2,r2,r4
 822aca4:	10800a04 	addi	r2,r2,40
 822aca8:	10800017 	ldw	r2,0(r2)
 822acac:	1004d23a 	srli	r2,r2,8
 822acb0:	10bfc00c 	andi	r2,r2,65280
 822acb4:	1886b03a 	or	r3,r3,r2
 822acb8:	008209b4 	movhi	r2,2086
 822acbc:	10b84a04 	addi	r2,r2,-7896
 822acc0:	e13ffe17 	ldw	r4,-8(fp)
 822acc4:	21000f24 	muli	r4,r4,60
 822acc8:	1105883a 	add	r2,r2,r4
 822accc:	10800a04 	addi	r2,r2,40
 822acd0:	10800017 	ldw	r2,0(r2)
 822acd4:	10bfc00c 	andi	r2,r2,65280
 822acd8:	1004923a 	slli	r2,r2,8
 822acdc:	1886b03a 	or	r3,r3,r2
 822ace0:	008209b4 	movhi	r2,2086
 822ace4:	10b84a04 	addi	r2,r2,-7896
 822ace8:	e13ffe17 	ldw	r4,-8(fp)
 822acec:	21000f24 	muli	r4,r4,60
 822acf0:	1105883a 	add	r2,r2,r4
 822acf4:	10800a04 	addi	r2,r2,40
 822acf8:	10800017 	ldw	r2,0(r2)
 822acfc:	1004963a 	slli	r2,r2,24
 822ad00:	1884b03a 	or	r2,r3,r2
 822ad04:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_SNMASK, opt_ip);
 822ad08:	e0bff617 	ldw	r2,-40(fp)
 822ad0c:	10c00044 	addi	r3,r2,1
 822ad10:	e0fff615 	stw	r3,-40(fp)
 822ad14:	00c00044 	movi	r3,1
 822ad18:	10c00005 	stb	r3,0(r2)
 822ad1c:	e0bff617 	ldw	r2,-40(fp)
 822ad20:	10c00044 	addi	r3,r2,1
 822ad24:	e0fff615 	stw	r3,-40(fp)
 822ad28:	00c00104 	movi	r3,4
 822ad2c:	10c00005 	stb	r3,0(r2)
 822ad30:	e0bff617 	ldw	r2,-40(fp)
 822ad34:	108000c4 	addi	r2,r2,3
 822ad38:	e0fffd04 	addi	r3,fp,-12
 822ad3c:	18c00003 	ldbu	r3,0(r3)
 822ad40:	10c00005 	stb	r3,0(r2)
 822ad44:	e0bff617 	ldw	r2,-40(fp)
 822ad48:	10c00084 	addi	r3,r2,2
 822ad4c:	e0bffd04 	addi	r2,fp,-12
 822ad50:	10800044 	addi	r2,r2,1
 822ad54:	10800003 	ldbu	r2,0(r2)
 822ad58:	18800005 	stb	r2,0(r3)
 822ad5c:	e0bff617 	ldw	r2,-40(fp)
 822ad60:	10c00044 	addi	r3,r2,1
 822ad64:	e0bffd04 	addi	r2,fp,-12
 822ad68:	10800084 	addi	r2,r2,2
 822ad6c:	10800003 	ldbu	r2,0(r2)
 822ad70:	18800005 	stb	r2,0(r3)
 822ad74:	e0bffd04 	addi	r2,fp,-12
 822ad78:	108000c4 	addi	r2,r2,3
 822ad7c:	10800003 	ldbu	r2,0(r2)
 822ad80:	1007883a 	mov	r3,r2
 822ad84:	e0bff617 	ldw	r2,-40(fp)
 822ad88:	10c00005 	stb	r3,0(r2)
 822ad8c:	e0bff617 	ldw	r2,-40(fp)
 822ad90:	10800104 	addi	r2,r2,4
 822ad94:	e0bff615 	stw	r2,-40(fp)
   }
   if (dhc_states[iface].defgw)
 822ad98:	008209b4 	movhi	r2,2086
 822ad9c:	10b84a04 	addi	r2,r2,-7896
 822ada0:	e0fffe17 	ldw	r3,-8(fp)
 822ada4:	18c00f24 	muli	r3,r3,60
 822ada8:	10c5883a 	add	r2,r2,r3
 822adac:	10800b04 	addi	r2,r2,44
 822adb0:	10800017 	ldw	r2,0(r2)
 822adb4:	10004a26 	beq	r2,zero,822aee0 <dhc_request+0x558>
   {
      opt_ip = ntohl(dhc_states[iface].defgw);
 822adb8:	008209b4 	movhi	r2,2086
 822adbc:	10b84a04 	addi	r2,r2,-7896
 822adc0:	e0fffe17 	ldw	r3,-8(fp)
 822adc4:	18c00f24 	muli	r3,r3,60
 822adc8:	10c5883a 	add	r2,r2,r3
 822adcc:	10800b04 	addi	r2,r2,44
 822add0:	10800017 	ldw	r2,0(r2)
 822add4:	1006d63a 	srli	r3,r2,24
 822add8:	008209b4 	movhi	r2,2086
 822addc:	10b84a04 	addi	r2,r2,-7896
 822ade0:	e13ffe17 	ldw	r4,-8(fp)
 822ade4:	21000f24 	muli	r4,r4,60
 822ade8:	1105883a 	add	r2,r2,r4
 822adec:	10800b04 	addi	r2,r2,44
 822adf0:	10800017 	ldw	r2,0(r2)
 822adf4:	1004d23a 	srli	r2,r2,8
 822adf8:	10bfc00c 	andi	r2,r2,65280
 822adfc:	1886b03a 	or	r3,r3,r2
 822ae00:	008209b4 	movhi	r2,2086
 822ae04:	10b84a04 	addi	r2,r2,-7896
 822ae08:	e13ffe17 	ldw	r4,-8(fp)
 822ae0c:	21000f24 	muli	r4,r4,60
 822ae10:	1105883a 	add	r2,r2,r4
 822ae14:	10800b04 	addi	r2,r2,44
 822ae18:	10800017 	ldw	r2,0(r2)
 822ae1c:	10bfc00c 	andi	r2,r2,65280
 822ae20:	1004923a 	slli	r2,r2,8
 822ae24:	1886b03a 	or	r3,r3,r2
 822ae28:	008209b4 	movhi	r2,2086
 822ae2c:	10b84a04 	addi	r2,r2,-7896
 822ae30:	e13ffe17 	ldw	r4,-8(fp)
 822ae34:	21000f24 	muli	r4,r4,60
 822ae38:	1105883a 	add	r2,r2,r4
 822ae3c:	10800b04 	addi	r2,r2,44
 822ae40:	10800017 	ldw	r2,0(r2)
 822ae44:	1004963a 	slli	r2,r2,24
 822ae48:	1884b03a 	or	r2,r3,r2
 822ae4c:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_ROUTER, opt_ip);
 822ae50:	e0bff617 	ldw	r2,-40(fp)
 822ae54:	10c00044 	addi	r3,r2,1
 822ae58:	e0fff615 	stw	r3,-40(fp)
 822ae5c:	00c000c4 	movi	r3,3
 822ae60:	10c00005 	stb	r3,0(r2)
 822ae64:	e0bff617 	ldw	r2,-40(fp)
 822ae68:	10c00044 	addi	r3,r2,1
 822ae6c:	e0fff615 	stw	r3,-40(fp)
 822ae70:	00c00104 	movi	r3,4
 822ae74:	10c00005 	stb	r3,0(r2)
 822ae78:	e0bff617 	ldw	r2,-40(fp)
 822ae7c:	108000c4 	addi	r2,r2,3
 822ae80:	e0fffd04 	addi	r3,fp,-12
 822ae84:	18c00003 	ldbu	r3,0(r3)
 822ae88:	10c00005 	stb	r3,0(r2)
 822ae8c:	e0bff617 	ldw	r2,-40(fp)
 822ae90:	10c00084 	addi	r3,r2,2
 822ae94:	e0bffd04 	addi	r2,fp,-12
 822ae98:	10800044 	addi	r2,r2,1
 822ae9c:	10800003 	ldbu	r2,0(r2)
 822aea0:	18800005 	stb	r2,0(r3)
 822aea4:	e0bff617 	ldw	r2,-40(fp)
 822aea8:	10c00044 	addi	r3,r2,1
 822aeac:	e0bffd04 	addi	r2,fp,-12
 822aeb0:	10800084 	addi	r2,r2,2
 822aeb4:	10800003 	ldbu	r2,0(r2)
 822aeb8:	18800005 	stb	r2,0(r3)
 822aebc:	e0bffd04 	addi	r2,fp,-12
 822aec0:	108000c4 	addi	r2,r2,3
 822aec4:	10800003 	ldbu	r2,0(r2)
 822aec8:	1007883a 	mov	r3,r2
 822aecc:	e0bff617 	ldw	r2,-40(fp)
 822aed0:	10c00005 	stb	r3,0(r2)
 822aed4:	e0bff617 	ldw	r2,-40(fp)
 822aed8:	10800104 	addi	r2,r2,4
 822aedc:	e0bff615 	stw	r2,-40(fp)
         }
      }
   }
#endif

   if (dhc_states[iface].lease)
 822aee0:	008209b4 	movhi	r2,2086
 822aee4:	10b84a04 	addi	r2,r2,-7896
 822aee8:	e0fffe17 	ldw	r3,-8(fp)
 822aeec:	18c00f24 	muli	r3,r3,60
 822aef0:	10c5883a 	add	r2,r2,r3
 822aef4:	10800504 	addi	r2,r2,20
 822aef8:	10800017 	ldw	r2,0(r2)
 822aefc:	10003826 	beq	r2,zero,822afe0 <dhc_request+0x658>
   {
      PUT_IP_OPT(opts, DHOP_LEASE, dhc_states[iface].lease);
 822af00:	e0bff617 	ldw	r2,-40(fp)
 822af04:	10c00044 	addi	r3,r2,1
 822af08:	e0fff615 	stw	r3,-40(fp)
 822af0c:	00c00cc4 	movi	r3,51
 822af10:	10c00005 	stb	r3,0(r2)
 822af14:	e0bff617 	ldw	r2,-40(fp)
 822af18:	10c00044 	addi	r3,r2,1
 822af1c:	e0fff615 	stw	r3,-40(fp)
 822af20:	00c00104 	movi	r3,4
 822af24:	10c00005 	stb	r3,0(r2)
 822af28:	e0bff617 	ldw	r2,-40(fp)
 822af2c:	10c000c4 	addi	r3,r2,3
 822af30:	e0bffe17 	ldw	r2,-8(fp)
 822af34:	10800f24 	muli	r2,r2,60
 822af38:	11000504 	addi	r4,r2,20
 822af3c:	008209b4 	movhi	r2,2086
 822af40:	10b84a04 	addi	r2,r2,-7896
 822af44:	2085883a 	add	r2,r4,r2
 822af48:	10800003 	ldbu	r2,0(r2)
 822af4c:	18800005 	stb	r2,0(r3)
 822af50:	e0bff617 	ldw	r2,-40(fp)
 822af54:	10c00084 	addi	r3,r2,2
 822af58:	e0bffe17 	ldw	r2,-8(fp)
 822af5c:	10800f24 	muli	r2,r2,60
 822af60:	11000504 	addi	r4,r2,20
 822af64:	008209b4 	movhi	r2,2086
 822af68:	10b84a04 	addi	r2,r2,-7896
 822af6c:	2085883a 	add	r2,r4,r2
 822af70:	10800044 	addi	r2,r2,1
 822af74:	10800003 	ldbu	r2,0(r2)
 822af78:	18800005 	stb	r2,0(r3)
 822af7c:	e0bff617 	ldw	r2,-40(fp)
 822af80:	10c00044 	addi	r3,r2,1
 822af84:	e0bffe17 	ldw	r2,-8(fp)
 822af88:	10800f24 	muli	r2,r2,60
 822af8c:	11000504 	addi	r4,r2,20
 822af90:	008209b4 	movhi	r2,2086
 822af94:	10b84a04 	addi	r2,r2,-7896
 822af98:	2085883a 	add	r2,r4,r2
 822af9c:	10800084 	addi	r2,r2,2
 822afa0:	10800003 	ldbu	r2,0(r2)
 822afa4:	18800005 	stb	r2,0(r3)
 822afa8:	e0bffe17 	ldw	r2,-8(fp)
 822afac:	10800f24 	muli	r2,r2,60
 822afb0:	10c00504 	addi	r3,r2,20
 822afb4:	008209b4 	movhi	r2,2086
 822afb8:	10b84a04 	addi	r2,r2,-7896
 822afbc:	1885883a 	add	r2,r3,r2
 822afc0:	108000c4 	addi	r2,r2,3
 822afc4:	10800003 	ldbu	r2,0(r2)
 822afc8:	1007883a 	mov	r3,r2
 822afcc:	e0bff617 	ldw	r2,-40(fp)
 822afd0:	10c00005 	stb	r3,0(r2)
 822afd4:	e0bff617 	ldw	r2,-40(fp)
 822afd8:	10800104 	addi	r2,r2,4
 822afdc:	e0bff615 	stw	r2,-40(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 822afe0:	d0a03517 	ldw	r2,-32556(gp)
 822afe4:	00801a0e 	bge	zero,r2,822b050 <dhc_request+0x6c8>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 822afe8:	e0bff617 	ldw	r2,-40(fp)
 822afec:	10c00044 	addi	r3,r2,1
 822aff0:	e0fff615 	stw	r3,-40(fp)
 822aff4:	00c00dc4 	movi	r3,55
 822aff8:	10c00005 	stb	r3,0(r2)
      *opts++ = (u_char)reqlist_len ;
 822affc:	e0bff617 	ldw	r2,-40(fp)
 822b000:	10c00044 	addi	r3,r2,1
 822b004:	e0fff615 	stw	r3,-40(fp)
 822b008:	d0e03517 	ldw	r3,-32556(gp)
 822b00c:	10c00005 	stb	r3,0(r2)

      for (i=0 ; i < reqlist_len ; i++ )
 822b010:	e03ff715 	stw	zero,-36(fp)
 822b014:	00000b06 	br	822b044 <dhc_request+0x6bc>
         *opts++ = reqlist[i];
 822b018:	e0bff617 	ldw	r2,-40(fp)
 822b01c:	10c00044 	addi	r3,r2,1
 822b020:	e0fff615 	stw	r3,-40(fp)
 822b024:	e13ff717 	ldw	r4,-36(fp)
 822b028:	d0e03404 	addi	r3,gp,-32560
 822b02c:	20c7883a 	add	r3,r4,r3
 822b030:	18c00003 	ldbu	r3,0(r3)
 822b034:	10c00005 	stb	r3,0(r2)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 822b038:	e0bff717 	ldw	r2,-36(fp)
 822b03c:	10800044 	addi	r2,r2,1
 822b040:	e0bff715 	stw	r2,-36(fp)
 822b044:	d0a03517 	ldw	r2,-32556(gp)
 822b048:	e0fff717 	ldw	r3,-36(fp)
 822b04c:	18bff216 	blt	r3,r2,822b018 <dhc_request+0x690>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   /* only set client IP address (ours) when renewing or rebinding */
   if ((dhc_states[iface].state == DHCS_RENEWING)
 822b050:	008209b4 	movhi	r2,2086
 822b054:	10b84a04 	addi	r2,r2,-7896
 822b058:	e0fffe17 	ldw	r3,-8(fp)
 822b05c:	18c00f24 	muli	r3,r3,60
 822b060:	10c5883a 	add	r2,r2,r3
 822b064:	10800017 	ldw	r2,0(r2)
 822b068:	108001e0 	cmpeqi	r2,r2,7
 822b06c:	1000081e 	bne	r2,zero,822b090 <dhc_request+0x708>
       || (dhc_states[iface].state == DHCS_REBINDING))
 822b070:	008209b4 	movhi	r2,2086
 822b074:	10b84a04 	addi	r2,r2,-7896
 822b078:	e0fffe17 	ldw	r3,-8(fp)
 822b07c:	18c00f24 	muli	r3,r3,60
 822b080:	10c5883a 	add	r2,r2,r3
 822b084:	10800017 	ldw	r2,0(r2)
 822b088:	10800218 	cmpnei	r2,r2,8
 822b08c:	10000a1e 	bne	r2,zero,822b0b8 <dhc_request+0x730>
   {
      outbp->ciaddr = nets[iface]->n_ipaddr;
 822b090:	008209b4 	movhi	r2,2086
 822b094:	10b82404 	addi	r2,r2,-8048
 822b098:	e0fffe17 	ldw	r3,-8(fp)
 822b09c:	18c7883a 	add	r3,r3,r3
 822b0a0:	18c7883a 	add	r3,r3,r3
 822b0a4:	10c5883a 	add	r2,r2,r3
 822b0a8:	10800017 	ldw	r2,0(r2)
 822b0ac:	10c00a17 	ldw	r3,40(r2)
 822b0b0:	e0bff917 	ldw	r2,-28(fp)
 822b0b4:	10c00315 	stw	r3,12(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822b0b8:	008209b4 	movhi	r2,2086
 822b0bc:	10b84a04 	addi	r2,r2,-7896
 822b0c0:	e0fffe17 	ldw	r3,-8(fp)
 822b0c4:	18c00f24 	muli	r3,r3,60
 822b0c8:	10c5883a 	add	r2,r2,r3
 822b0cc:	10800017 	ldw	r2,0(r2)
 822b0d0:	10800120 	cmpeqi	r2,r2,4
 822b0d4:	1000081e 	bne	r2,zero,822b0f8 <dhc_request+0x770>
       (dhc_states[iface].state == DHCS_REQUESTING))
 822b0d8:	008209b4 	movhi	r2,2086
 822b0dc:	10b84a04 	addi	r2,r2,-7896
 822b0e0:	e0fffe17 	ldw	r3,-8(fp)
 822b0e4:	18c00f24 	muli	r3,r3,60
 822b0e8:	10c5883a 	add	r2,r2,r3
 822b0ec:	10800017 	ldw	r2,0(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 822b0f0:	10800158 	cmpnei	r2,r2,5
 822b0f4:	10004a1e 	bne	r2,zero,822b220 <dhc_request+0x898>
       (dhc_states[iface].state == DHCS_REQUESTING))
   {
      opt_ip = ntohl(dhc_states[iface].srv_ipaddr);
 822b0f8:	008209b4 	movhi	r2,2086
 822b0fc:	10b84a04 	addi	r2,r2,-7896
 822b100:	e0fffe17 	ldw	r3,-8(fp)
 822b104:	18c00f24 	muli	r3,r3,60
 822b108:	10c5883a 	add	r2,r2,r3
 822b10c:	10800d04 	addi	r2,r2,52
 822b110:	10800017 	ldw	r2,0(r2)
 822b114:	1006d63a 	srli	r3,r2,24
 822b118:	008209b4 	movhi	r2,2086
 822b11c:	10b84a04 	addi	r2,r2,-7896
 822b120:	e13ffe17 	ldw	r4,-8(fp)
 822b124:	21000f24 	muli	r4,r4,60
 822b128:	1105883a 	add	r2,r2,r4
 822b12c:	10800d04 	addi	r2,r2,52
 822b130:	10800017 	ldw	r2,0(r2)
 822b134:	1004d23a 	srli	r2,r2,8
 822b138:	10bfc00c 	andi	r2,r2,65280
 822b13c:	1886b03a 	or	r3,r3,r2
 822b140:	008209b4 	movhi	r2,2086
 822b144:	10b84a04 	addi	r2,r2,-7896
 822b148:	e13ffe17 	ldw	r4,-8(fp)
 822b14c:	21000f24 	muli	r4,r4,60
 822b150:	1105883a 	add	r2,r2,r4
 822b154:	10800d04 	addi	r2,r2,52
 822b158:	10800017 	ldw	r2,0(r2)
 822b15c:	10bfc00c 	andi	r2,r2,65280
 822b160:	1004923a 	slli	r2,r2,8
 822b164:	1886b03a 	or	r3,r3,r2
 822b168:	008209b4 	movhi	r2,2086
 822b16c:	10b84a04 	addi	r2,r2,-7896
 822b170:	e13ffe17 	ldw	r4,-8(fp)
 822b174:	21000f24 	muli	r4,r4,60
 822b178:	1105883a 	add	r2,r2,r4
 822b17c:	10800d04 	addi	r2,r2,52
 822b180:	10800017 	ldw	r2,0(r2)
 822b184:	1004963a 	slli	r2,r2,24
 822b188:	1884b03a 	or	r2,r3,r2
 822b18c:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_SERVER, opt_ip);
 822b190:	e0bff617 	ldw	r2,-40(fp)
 822b194:	10c00044 	addi	r3,r2,1
 822b198:	e0fff615 	stw	r3,-40(fp)
 822b19c:	00c00d84 	movi	r3,54
 822b1a0:	10c00005 	stb	r3,0(r2)
 822b1a4:	e0bff617 	ldw	r2,-40(fp)
 822b1a8:	10c00044 	addi	r3,r2,1
 822b1ac:	e0fff615 	stw	r3,-40(fp)
 822b1b0:	00c00104 	movi	r3,4
 822b1b4:	10c00005 	stb	r3,0(r2)
 822b1b8:	e0bff617 	ldw	r2,-40(fp)
 822b1bc:	108000c4 	addi	r2,r2,3
 822b1c0:	e0fffd04 	addi	r3,fp,-12
 822b1c4:	18c00003 	ldbu	r3,0(r3)
 822b1c8:	10c00005 	stb	r3,0(r2)
 822b1cc:	e0bff617 	ldw	r2,-40(fp)
 822b1d0:	10c00084 	addi	r3,r2,2
 822b1d4:	e0bffd04 	addi	r2,fp,-12
 822b1d8:	10800044 	addi	r2,r2,1
 822b1dc:	10800003 	ldbu	r2,0(r2)
 822b1e0:	18800005 	stb	r2,0(r3)
 822b1e4:	e0bff617 	ldw	r2,-40(fp)
 822b1e8:	10c00044 	addi	r3,r2,1
 822b1ec:	e0bffd04 	addi	r2,fp,-12
 822b1f0:	10800084 	addi	r2,r2,2
 822b1f4:	10800003 	ldbu	r2,0(r2)
 822b1f8:	18800005 	stb	r2,0(r3)
 822b1fc:	e0bffd04 	addi	r2,fp,-12
 822b200:	108000c4 	addi	r2,r2,3
 822b204:	10800003 	ldbu	r2,0(r2)
 822b208:	1007883a 	mov	r3,r2
 822b20c:	e0bff617 	ldw	r2,-40(fp)
 822b210:	10c00005 	stb	r3,0(r2)
 822b214:	e0bff617 	ldw	r2,-40(fp)
 822b218:	10800104 	addi	r2,r2,4
 822b21c:	e0bff615 	stw	r2,-40(fp)
   /* add hostname (code 12) */
   PUT_STRING_OPT(opts, 12, dhc_hostname()); 
#endif /* USE_AUTOIP */

   /* Client Fully Qualified Domain Name */
   PUT_STRING_OPT(opts, 81, DC_DOMAINNAME); 
 822b220:	e0bff617 	ldw	r2,-40(fp)
 822b224:	10c00044 	addi	r3,r2,1
 822b228:	e0fff615 	stw	r3,-40(fp)
 822b22c:	00c01444 	movi	r3,81
 822b230:	10c00005 	stb	r3,0(r2)
 822b234:	00800184 	movi	r2,6
 822b238:	e0bffb15 	stw	r2,-20(fp)
 822b23c:	e0bff617 	ldw	r2,-40(fp)
 822b240:	10c00044 	addi	r3,r2,1
 822b244:	e0fff615 	stw	r3,-40(fp)
 822b248:	e0fffb17 	ldw	r3,-20(fp)
 822b24c:	10c00005 	stb	r3,0(r2)
 822b250:	e0bffb17 	ldw	r2,-20(fp)
 822b254:	100d883a 	mov	r6,r2
 822b258:	01420974 	movhi	r5,2085
 822b25c:	29422204 	addi	r5,r5,2184
 822b260:	e13ff617 	ldw	r4,-40(fp)
 822b264:	824b8180 	call	824b818 <strncpy>
 822b268:	e0bffb17 	ldw	r2,-20(fp)
 822b26c:	e0fff617 	ldw	r3,-40(fp)
 822b270:	1885883a 	add	r2,r3,r2
 822b274:	e0bff615 	stw	r2,-40(fp)
   /* Vendor Class Identifier */
   PUT_STRING_OPT(opts, 60, name); 
 822b278:	e0bff617 	ldw	r2,-40(fp)
 822b27c:	10c00044 	addi	r3,r2,1
 822b280:	e0fff615 	stw	r3,-40(fp)
 822b284:	00c00f04 	movi	r3,60
 822b288:	10c00005 	stb	r3,0(r2)
 822b28c:	d0a04b17 	ldw	r2,-32468(gp)
 822b290:	1009883a 	mov	r4,r2
 822b294:	8203edc0 	call	8203edc <strlen>
 822b298:	e0bffc15 	stw	r2,-16(fp)
 822b29c:	e0bff617 	ldw	r2,-40(fp)
 822b2a0:	10c00044 	addi	r3,r2,1
 822b2a4:	e0fff615 	stw	r3,-40(fp)
 822b2a8:	e0fffc17 	ldw	r3,-16(fp)
 822b2ac:	10c00005 	stb	r3,0(r2)
 822b2b0:	d0a04b17 	ldw	r2,-32468(gp)
 822b2b4:	e0fffc17 	ldw	r3,-16(fp)
 822b2b8:	180d883a 	mov	r6,r3
 822b2bc:	100b883a 	mov	r5,r2
 822b2c0:	e13ff617 	ldw	r4,-40(fp)
 822b2c4:	824b8180 	call	824b818 <strncpy>
 822b2c8:	e0bffc17 	ldw	r2,-16(fp)
 822b2cc:	e0fff617 	ldw	r3,-40(fp)
 822b2d0:	1885883a 	add	r2,r3,r2
 822b2d4:	e0bff615 	stw	r2,-40(fp)

   *opts++ = DHOP_END;  /* Mark the end of options */
 822b2d8:	e0bff617 	ldw	r2,-40(fp)
 822b2dc:	10c00044 	addi	r3,r2,1
 822b2e0:	e0fff615 	stw	r3,-40(fp)
 822b2e4:	00ffffc4 	movi	r3,-1
 822b2e8:	10c00005 	stb	r3,0(r2)

   /* figure out whether to send via unicast or broadcast */
   if (dhc_states[iface].state == DHCS_RENEWING)
 822b2ec:	008209b4 	movhi	r2,2086
 822b2f0:	10b84a04 	addi	r2,r2,-7896
 822b2f4:	e0fffe17 	ldw	r3,-8(fp)
 822b2f8:	18c00f24 	muli	r3,r3,60
 822b2fc:	10c5883a 	add	r2,r2,r3
 822b300:	10800017 	ldw	r2,0(r2)
 822b304:	108001d8 	cmpnei	r2,r2,7
 822b308:	10000a1e 	bne	r2,zero,822b334 <dhc_request+0x9ac>
   {
      pkt->fhost = dhc_states[iface].srv_ipaddr;
 822b30c:	008209b4 	movhi	r2,2086
 822b310:	10b84a04 	addi	r2,r2,-7896
 822b314:	e0fffe17 	ldw	r3,-8(fp)
 822b318:	18c00f24 	muli	r3,r3,60
 822b31c:	10c5883a 	add	r2,r2,r3
 822b320:	10800d04 	addi	r2,r2,52
 822b324:	10c00017 	ldw	r3,0(r2)
 822b328:	e0bff817 	ldw	r2,-32(fp)
 822b32c:	10c00715 	stw	r3,28(r2)
 822b330:	00000306 	br	822b340 <dhc_request+0x9b8>
   }
   else
   {
      pkt->fhost = 0xFFFFFFFF;   /* broadcast request */
 822b334:	e0bff817 	ldw	r2,-32(fp)
 822b338:	00ffffc4 	movi	r3,-1
 822b33c:	10c00715 	stw	r3,28(r2)
   }

   pkt->net = nets[iface];    /* send out caller spec'ed net */
 822b340:	008209b4 	movhi	r2,2086
 822b344:	10b82404 	addi	r2,r2,-8048
 822b348:	e0fffe17 	ldw	r3,-8(fp)
 822b34c:	18c7883a 	add	r3,r3,r3
 822b350:	18c7883a 	add	r3,r3,r3
 822b354:	10c5883a 	add	r2,r2,r3
 822b358:	10c00017 	ldw	r3,0(r2)
 822b35c:	e0bff817 	ldw	r2,-32(fp)
 822b360:	10c00615 	stw	r3,24(r2)
   pkt->nb_plen = (char *)opts - (char *)outbp;
 822b364:	e0fff617 	ldw	r3,-40(fp)
 822b368:	e0bff917 	ldw	r2,-28(fp)
 822b36c:	1885c83a 	sub	r2,r3,r2
 822b370:	1007883a 	mov	r3,r2
 822b374:	e0bff817 	ldw	r2,-32(fp)
 822b378:	10c00415 	stw	r3,16(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 822b37c:	e1bff817 	ldw	r6,-32(fp)
 822b380:	01401104 	movi	r5,68
 822b384:	010010c4 	movi	r4,67
 822b388:	8244dfc0 	call	8244dfc <udp_send>
   dsc_requests++;
 822b38c:	d0a09317 	ldw	r2,-32180(gp)
 822b390:	10800044 	addi	r2,r2,1
 822b394:	d0a09315 	stw	r2,-32180(gp)

   dhc_states[iface].last_tick = cticks;
 822b398:	d0e0a817 	ldw	r3,-32096(gp)
 822b39c:	008209b4 	movhi	r2,2086
 822b3a0:	10b84a04 	addi	r2,r2,-7896
 822b3a4:	e13ffe17 	ldw	r4,-8(fp)
 822b3a8:	21000f24 	muli	r4,r4,60
 822b3ac:	1105883a 	add	r2,r2,r4
 822b3b0:	10800404 	addi	r2,r2,16
 822b3b4:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].tries++;
 822b3b8:	008209b4 	movhi	r2,2086
 822b3bc:	10b84a04 	addi	r2,r2,-7896
 822b3c0:	e0fffe17 	ldw	r3,-8(fp)
 822b3c4:	18c00f24 	muli	r3,r3,60
 822b3c8:	10c5883a 	add	r2,r2,r3
 822b3cc:	10800104 	addi	r2,r2,4
 822b3d0:	10800017 	ldw	r2,0(r2)
 822b3d4:	10c00044 	addi	r3,r2,1
 822b3d8:	008209b4 	movhi	r2,2086
 822b3dc:	10b84a04 	addi	r2,r2,-7896
 822b3e0:	e13ffe17 	ldw	r4,-8(fp)
 822b3e4:	21000f24 	muli	r4,r4,60
 822b3e8:	1105883a 	add	r2,r2,r4
 822b3ec:	10800104 	addi	r2,r2,4
 822b3f0:	10c00015 	stw	r3,0(r2)

   return 0;   /* return OK code */
 822b3f4:	0005883a 	mov	r2,zero
}
 822b3f8:	e037883a 	mov	sp,fp
 822b3fc:	dfc00117 	ldw	ra,4(sp)
 822b400:	df000017 	ldw	fp,0(sp)
 822b404:	dec00204 	addi	sp,sp,8
 822b408:	f800283a 	ret

0822b40c <dhc_setip>:
 * RETURNS: Returns 0 if ok, else non-zero ENP error.
 */

int
dhc_setip(int iface)
{
 822b40c:	defffd04 	addi	sp,sp,-12
 822b410:	dfc00215 	stw	ra,8(sp)
 822b414:	df000115 	stw	fp,4(sp)
 822b418:	df000104 	addi	fp,sp,4
 822b41c:	e13fff15 	stw	r4,-4(fp)
   nets[iface]->n_ipaddr = dhc_states[iface].ipaddr;
 822b420:	008209b4 	movhi	r2,2086
 822b424:	10b82404 	addi	r2,r2,-8048
 822b428:	e0ffff17 	ldw	r3,-4(fp)
 822b42c:	18c7883a 	add	r3,r3,r3
 822b430:	18c7883a 	add	r3,r3,r3
 822b434:	10c5883a 	add	r2,r2,r3
 822b438:	10c00017 	ldw	r3,0(r2)
 822b43c:	008209b4 	movhi	r2,2086
 822b440:	10b84a04 	addi	r2,r2,-7896
 822b444:	e13fff17 	ldw	r4,-4(fp)
 822b448:	21000f24 	muli	r4,r4,60
 822b44c:	1105883a 	add	r2,r2,r4
 822b450:	10800904 	addi	r2,r2,36
 822b454:	10800017 	ldw	r2,0(r2)
 822b458:	18800a15 	stw	r2,40(r3)
   nets[iface]->snmask   = dhc_states[iface].snmask;
 822b45c:	008209b4 	movhi	r2,2086
 822b460:	10b82404 	addi	r2,r2,-8048
 822b464:	e0ffff17 	ldw	r3,-4(fp)
 822b468:	18c7883a 	add	r3,r3,r3
 822b46c:	18c7883a 	add	r3,r3,r3
 822b470:	10c5883a 	add	r2,r2,r3
 822b474:	10c00017 	ldw	r3,0(r2)
 822b478:	008209b4 	movhi	r2,2086
 822b47c:	10b84a04 	addi	r2,r2,-7896
 822b480:	e13fff17 	ldw	r4,-4(fp)
 822b484:	21000f24 	muli	r4,r4,60
 822b488:	1105883a 	add	r2,r2,r4
 822b48c:	10800a04 	addi	r2,r2,40
 822b490:	10800017 	ldw	r2,0(r2)
 822b494:	18800c15 	stw	r2,48(r3)
   nets[iface]->n_defgw  = dhc_states[iface].defgw;
 822b498:	008209b4 	movhi	r2,2086
 822b49c:	10b82404 	addi	r2,r2,-8048
 822b4a0:	e0ffff17 	ldw	r3,-4(fp)
 822b4a4:	18c7883a 	add	r3,r3,r3
 822b4a8:	18c7883a 	add	r3,r3,r3
 822b4ac:	10c5883a 	add	r2,r2,r3
 822b4b0:	10c00017 	ldw	r3,0(r2)
 822b4b4:	008209b4 	movhi	r2,2086
 822b4b8:	10b84a04 	addi	r2,r2,-7896
 822b4bc:	e13fff17 	ldw	r4,-4(fp)
 822b4c0:	21000f24 	muli	r4,r4,60
 822b4c4:	1105883a 	add	r2,r2,r4
 822b4c8:	10800b04 	addi	r2,r2,44
 822b4cc:	10800017 	ldw	r2,0(r2)
 822b4d0:	18800d15 	stw	r2,52(r3)

   if ( nets[iface]->snmask == 0 )
 822b4d4:	008209b4 	movhi	r2,2086
 822b4d8:	10b82404 	addi	r2,r2,-8048
 822b4dc:	e0ffff17 	ldw	r3,-4(fp)
 822b4e0:	18c7883a 	add	r3,r3,r3
 822b4e4:	18c7883a 	add	r3,r3,r3
 822b4e8:	10c5883a 	add	r2,r2,r3
 822b4ec:	10800017 	ldw	r2,0(r2)
 822b4f0:	10800c17 	ldw	r2,48(r2)
 822b4f4:	1000111e 	bne	r2,zero,822b53c <dhc_setip+0x130>
   {
      fixup_subnet_mask(iface);
 822b4f8:	e13fff17 	ldw	r4,-4(fp)
 822b4fc:	8225fc40 	call	8225fc4 <fixup_subnet_mask>
      dhc_states[iface].snmask = nets[iface]->snmask; 
 822b500:	008209b4 	movhi	r2,2086
 822b504:	10b82404 	addi	r2,r2,-8048
 822b508:	e0ffff17 	ldw	r3,-4(fp)
 822b50c:	18c7883a 	add	r3,r3,r3
 822b510:	18c7883a 	add	r3,r3,r3
 822b514:	10c5883a 	add	r2,r2,r3
 822b518:	10800017 	ldw	r2,0(r2)
 822b51c:	10c00c17 	ldw	r3,48(r2)
 822b520:	008209b4 	movhi	r2,2086
 822b524:	10b84a04 	addi	r2,r2,-7896
 822b528:	e13fff17 	ldw	r4,-4(fp)
 822b52c:	21000f24 	muli	r4,r4,60
 822b530:	1105883a 	add	r2,r2,r4
 822b534:	10800a04 	addi	r2,r2,40
 822b538:	10c00015 	stw	r3,0(r2)
   }

   /* fixup broadcast addresses */
   nets[iface]->n_netbr    = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 822b53c:	008209b4 	movhi	r2,2086
 822b540:	10b82404 	addi	r2,r2,-8048
 822b544:	e0ffff17 	ldw	r3,-4(fp)
 822b548:	18c7883a 	add	r3,r3,r3
 822b54c:	18c7883a 	add	r3,r3,r3
 822b550:	10c5883a 	add	r2,r2,r3
 822b554:	11000017 	ldw	r4,0(r2)
 822b558:	008209b4 	movhi	r2,2086
 822b55c:	10b82404 	addi	r2,r2,-8048
 822b560:	e0ffff17 	ldw	r3,-4(fp)
 822b564:	18c7883a 	add	r3,r3,r3
 822b568:	18c7883a 	add	r3,r3,r3
 822b56c:	10c5883a 	add	r2,r2,r3
 822b570:	10800017 	ldw	r2,0(r2)
 822b574:	11400a17 	ldw	r5,40(r2)
 822b578:	008209b4 	movhi	r2,2086
 822b57c:	10b82404 	addi	r2,r2,-8048
 822b580:	e0ffff17 	ldw	r3,-4(fp)
 822b584:	18c7883a 	add	r3,r3,r3
 822b588:	18c7883a 	add	r3,r3,r3
 822b58c:	10c5883a 	add	r2,r2,r3
 822b590:	10800017 	ldw	r2,0(r2)
 822b594:	10800c17 	ldw	r2,48(r2)
 822b598:	0084303a 	nor	r2,zero,r2
 822b59c:	2884b03a 	or	r2,r5,r2
 822b5a0:	20800e15 	stw	r2,56(r4)
   nets[iface]->n_netbr42  = nets[iface]->n_ipaddr &  nets[iface]->snmask;
 822b5a4:	008209b4 	movhi	r2,2086
 822b5a8:	10b82404 	addi	r2,r2,-8048
 822b5ac:	e0ffff17 	ldw	r3,-4(fp)
 822b5b0:	18c7883a 	add	r3,r3,r3
 822b5b4:	18c7883a 	add	r3,r3,r3
 822b5b8:	10c5883a 	add	r2,r2,r3
 822b5bc:	11000017 	ldw	r4,0(r2)
 822b5c0:	008209b4 	movhi	r2,2086
 822b5c4:	10b82404 	addi	r2,r2,-8048
 822b5c8:	e0ffff17 	ldw	r3,-4(fp)
 822b5cc:	18c7883a 	add	r3,r3,r3
 822b5d0:	18c7883a 	add	r3,r3,r3
 822b5d4:	10c5883a 	add	r2,r2,r3
 822b5d8:	10800017 	ldw	r2,0(r2)
 822b5dc:	11400a17 	ldw	r5,40(r2)
 822b5e0:	008209b4 	movhi	r2,2086
 822b5e4:	10b82404 	addi	r2,r2,-8048
 822b5e8:	e0ffff17 	ldw	r3,-4(fp)
 822b5ec:	18c7883a 	add	r3,r3,r3
 822b5f0:	18c7883a 	add	r3,r3,r3
 822b5f4:	10c5883a 	add	r2,r2,r3
 822b5f8:	10800017 	ldw	r2,0(r2)
 822b5fc:	10800c17 	ldw	r2,48(r2)
 822b600:	2884703a 	and	r2,r5,r2
 822b604:	20800f15 	stw	r2,60(r4)
   nets[iface]->n_subnetbr = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 822b608:	008209b4 	movhi	r2,2086
 822b60c:	10b82404 	addi	r2,r2,-8048
 822b610:	e0ffff17 	ldw	r3,-4(fp)
 822b614:	18c7883a 	add	r3,r3,r3
 822b618:	18c7883a 	add	r3,r3,r3
 822b61c:	10c5883a 	add	r2,r2,r3
 822b620:	11000017 	ldw	r4,0(r2)
 822b624:	008209b4 	movhi	r2,2086
 822b628:	10b82404 	addi	r2,r2,-8048
 822b62c:	e0ffff17 	ldw	r3,-4(fp)
 822b630:	18c7883a 	add	r3,r3,r3
 822b634:	18c7883a 	add	r3,r3,r3
 822b638:	10c5883a 	add	r2,r2,r3
 822b63c:	10800017 	ldw	r2,0(r2)
 822b640:	11400a17 	ldw	r5,40(r2)
 822b644:	008209b4 	movhi	r2,2086
 822b648:	10b82404 	addi	r2,r2,-8048
 822b64c:	e0ffff17 	ldw	r3,-4(fp)
 822b650:	18c7883a 	add	r3,r3,r3
 822b654:	18c7883a 	add	r3,r3,r3
 822b658:	10c5883a 	add	r2,r2,r3
 822b65c:	10800017 	ldw	r2,0(r2)
 822b660:	10800c17 	ldw	r2,48(r2)
 822b664:	0084303a 	nor	r2,zero,r2
 822b668:	2884b03a 	or	r2,r5,r2
 822b66c:	20801015 	stw	r2,64(r4)

   return 0;   /* return OK code */
 822b670:	0005883a 	mov	r2,zero
}
 822b674:	e037883a 	mov	sp,fp
 822b678:	dfc00117 	ldw	ra,4(sp)
 822b67c:	df000017 	ldw	fp,0(sp)
 822b680:	dec00204 	addi	sp,sp,8
 822b684:	f800283a 	ret

0822b688 <dhc_resetip>:
 * RETURNS: Returns 0 if ok, else non-zero error. 
 */

int
dhc_resetip(int iface)
{
 822b688:	defffe04 	addi	sp,sp,-8
 822b68c:	df000115 	stw	fp,4(sp)
 822b690:	df000104 	addi	fp,sp,4
 822b694:	e13fff15 	stw	r4,-4(fp)
   /* reset the ipaddress */
   nets[iface]->n_ipaddr = 0;
 822b698:	008209b4 	movhi	r2,2086
 822b69c:	10b82404 	addi	r2,r2,-8048
 822b6a0:	e0ffff17 	ldw	r3,-4(fp)
 822b6a4:	18c7883a 	add	r3,r3,r3
 822b6a8:	18c7883a 	add	r3,r3,r3
 822b6ac:	10c5883a 	add	r2,r2,r3
 822b6b0:	10800017 	ldw	r2,0(r2)
 822b6b4:	10000a15 	stw	zero,40(r2)
   nets[iface]->snmask   = 0;
 822b6b8:	008209b4 	movhi	r2,2086
 822b6bc:	10b82404 	addi	r2,r2,-8048
 822b6c0:	e0ffff17 	ldw	r3,-4(fp)
 822b6c4:	18c7883a 	add	r3,r3,r3
 822b6c8:	18c7883a 	add	r3,r3,r3
 822b6cc:	10c5883a 	add	r2,r2,r3
 822b6d0:	10800017 	ldw	r2,0(r2)
 822b6d4:	10000c15 	stw	zero,48(r2)
   nets[iface]->n_defgw  = 0;
 822b6d8:	008209b4 	movhi	r2,2086
 822b6dc:	10b82404 	addi	r2,r2,-8048
 822b6e0:	e0ffff17 	ldw	r3,-4(fp)
 822b6e4:	18c7883a 	add	r3,r3,r3
 822b6e8:	18c7883a 	add	r3,r3,r3
 822b6ec:	10c5883a 	add	r2,r2,r3
 822b6f0:	10800017 	ldw	r2,0(r2)
 822b6f4:	10000d15 	stw	zero,52(r2)

   /* reset the broadcast addresses */
   nets[iface]->n_netbr    = 0;
 822b6f8:	008209b4 	movhi	r2,2086
 822b6fc:	10b82404 	addi	r2,r2,-8048
 822b700:	e0ffff17 	ldw	r3,-4(fp)
 822b704:	18c7883a 	add	r3,r3,r3
 822b708:	18c7883a 	add	r3,r3,r3
 822b70c:	10c5883a 	add	r2,r2,r3
 822b710:	10800017 	ldw	r2,0(r2)
 822b714:	10000e15 	stw	zero,56(r2)
   nets[iface]->n_netbr42  = 0;
 822b718:	008209b4 	movhi	r2,2086
 822b71c:	10b82404 	addi	r2,r2,-8048
 822b720:	e0ffff17 	ldw	r3,-4(fp)
 822b724:	18c7883a 	add	r3,r3,r3
 822b728:	18c7883a 	add	r3,r3,r3
 822b72c:	10c5883a 	add	r2,r2,r3
 822b730:	10800017 	ldw	r2,0(r2)
 822b734:	10000f15 	stw	zero,60(r2)
   nets[iface]->n_subnetbr = 0;
 822b738:	008209b4 	movhi	r2,2086
 822b73c:	10b82404 	addi	r2,r2,-8048
 822b740:	e0ffff17 	ldw	r3,-4(fp)
 822b744:	18c7883a 	add	r3,r3,r3
 822b748:	18c7883a 	add	r3,r3,r3
 822b74c:	10c5883a 	add	r2,r2,r3
 822b750:	10800017 	ldw	r2,0(r2)
 822b754:	10001015 	stw	zero,64(r2)

   return 0;   /* return OK code */
 822b758:	0005883a 	mov	r2,zero
}
 822b75c:	e037883a 	mov	sp,fp
 822b760:	df000017 	ldw	fp,0(sp)
 822b764:	dec00104 	addi	sp,sp,4
 822b768:	f800283a 	ret

0822b76c <dhc_decline>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_decline(int iface,struct bootp * bp, unsigned bplen)
{
 822b76c:	defff804 	addi	sp,sp,-32
 822b770:	dfc00715 	stw	ra,28(sp)
 822b774:	df000615 	stw	fp,24(sp)
 822b778:	df000604 	addi	fp,sp,24
 822b77c:	e13ffd15 	stw	r4,-12(fp)
 822b780:	e17ffe15 	stw	r5,-8(fp)
 822b784:	e1bfff15 	stw	r6,-4(fp)
   struct bootp * outbp;
   PACKET pkt;
   u_char * opts;    /* scratch pointer to DHCP options field */

   /* get a UDP packet buffer for sending DHCP */
   pkt = udp_alloc(bplen, 0);
 822b788:	e0bfff17 	ldw	r2,-4(fp)
 822b78c:	000b883a 	mov	r5,zero
 822b790:	1009883a 	mov	r4,r2
 822b794:	82452380 	call	8245238 <udp_alloc>
 822b798:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 822b79c:	e0bffa17 	ldw	r2,-24(fp)
 822b7a0:	1000021e 	bne	r2,zero,822b7ac <dhc_decline+0x40>
      return ENP_NOMEM;
 822b7a4:	00bffb04 	movi	r2,-20
 822b7a8:	00002d06 	br	822b860 <dhc_decline+0xf4>
   pkt->nb_plen = bplen;
 822b7ac:	e0bffa17 	ldw	r2,-24(fp)
 822b7b0:	e0ffff17 	ldw	r3,-4(fp)
 822b7b4:	10c00415 	stw	r3,16(r2)

   outbp = (struct bootp *)pkt->nb_prot;
 822b7b8:	e0bffa17 	ldw	r2,-24(fp)
 822b7bc:	10800317 	ldw	r2,12(r2)
 822b7c0:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(outbp, bp, bplen);
 822b7c4:	e1bfff17 	ldw	r6,-4(fp)
 822b7c8:	e17ffe17 	ldw	r5,-8(fp)
 822b7cc:	e13ffb17 	ldw	r4,-20(fp)
 822b7d0:	8202e8c0 	call	8202e8c <memcpy>
   outbp->op = BOOTREQUEST;
 822b7d4:	e0bffb17 	ldw	r2,-20(fp)
 822b7d8:	00c00044 	movi	r3,1
 822b7dc:	10c00005 	stb	r3,0(r2)

   /* find DHCP TYPE option so we can overwrite it */   
   opts = find_opt(DHOP_TYPE, &outbp->options[4]);
 822b7e0:	e0bffb17 	ldw	r2,-20(fp)
 822b7e4:	10803c04 	addi	r2,r2,240
 822b7e8:	100b883a 	mov	r5,r2
 822b7ec:	01000d44 	movi	r4,53
 822b7f0:	822c5100 	call	822c510 <find_opt>
 822b7f4:	e0bffc15 	stw	r2,-16(fp)
   opts += 2;     /* point to actual op code */
 822b7f8:	e0bffc17 	ldw	r2,-16(fp)
 822b7fc:	10800084 	addi	r2,r2,2
 822b800:	e0bffc15 	stw	r2,-16(fp)
   *opts = DHCP_DECLINE;   /* overwrite op code */
 822b804:	e0bffc17 	ldw	r2,-16(fp)
 822b808:	00c00104 	movi	r3,4
 822b80c:	10c00005 	stb	r3,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast decline pkt */
 822b810:	e0bffa17 	ldw	r2,-24(fp)
 822b814:	00ffffc4 	movi	r3,-1
 822b818:	10c00715 	stw	r3,28(r2)
   pkt->net = nets[iface];    /* send out caller speced net */
 822b81c:	008209b4 	movhi	r2,2086
 822b820:	10b82404 	addi	r2,r2,-8048
 822b824:	e0fffd17 	ldw	r3,-12(fp)
 822b828:	18c7883a 	add	r3,r3,r3
 822b82c:	18c7883a 	add	r3,r3,r3
 822b830:	10c5883a 	add	r2,r2,r3
 822b834:	10c00017 	ldw	r3,0(r2)
 822b838:	e0bffa17 	ldw	r2,-24(fp)
 822b83c:	10c00615 	stw	r3,24(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 822b840:	e1bffa17 	ldw	r6,-24(fp)
 822b844:	01401104 	movi	r5,68
 822b848:	010010c4 	movi	r4,67
 822b84c:	8244dfc0 	call	8244dfc <udp_send>
   dsc_declines++;   /* count declines sent */
 822b850:	d0a09617 	ldw	r2,-32168(gp)
 822b854:	10800044 	addi	r2,r2,1
 822b858:	d0a09615 	stw	r2,-32168(gp)
   return 0;
 822b85c:	0005883a 	mov	r2,zero
}
 822b860:	e037883a 	mov	sp,fp
 822b864:	dfc00117 	ldw	ra,4(sp)
 822b868:	df000017 	ldw	fp,0(sp)
 822b86c:	dec00204 	addi	sp,sp,8
 822b870:	f800283a 	ret

0822b874 <dh_getlong>:
 *
 * RETURNS: the extracted 32 bit value
 */

static   long dh_getlong( u_char *ptr )
{
 822b874:	defffc04 	addi	sp,sp,-16
 822b878:	df000315 	stw	fp,12(sp)
 822b87c:	df000304 	addi	fp,sp,12
 822b880:	e13fff15 	stw	r4,-4(fp)
     long  v;
     u_char * p2 =  (u_char *)&v;
 822b884:	e0bffe04 	addi	r2,fp,-8
 822b888:	e0bffd15 	stw	r2,-12(fp)

   *p2++ = *ptr++;
 822b88c:	e0bffd17 	ldw	r2,-12(fp)
 822b890:	10c00044 	addi	r3,r2,1
 822b894:	e0fffd15 	stw	r3,-12(fp)
 822b898:	e0ffff17 	ldw	r3,-4(fp)
 822b89c:	19000044 	addi	r4,r3,1
 822b8a0:	e13fff15 	stw	r4,-4(fp)
 822b8a4:	18c00003 	ldbu	r3,0(r3)
 822b8a8:	10c00005 	stb	r3,0(r2)
   *p2++ = *ptr++;
 822b8ac:	e0bffd17 	ldw	r2,-12(fp)
 822b8b0:	10c00044 	addi	r3,r2,1
 822b8b4:	e0fffd15 	stw	r3,-12(fp)
 822b8b8:	e0ffff17 	ldw	r3,-4(fp)
 822b8bc:	19000044 	addi	r4,r3,1
 822b8c0:	e13fff15 	stw	r4,-4(fp)
 822b8c4:	18c00003 	ldbu	r3,0(r3)
 822b8c8:	10c00005 	stb	r3,0(r2)
   *p2++ = *ptr++;
 822b8cc:	e0bffd17 	ldw	r2,-12(fp)
 822b8d0:	10c00044 	addi	r3,r2,1
 822b8d4:	e0fffd15 	stw	r3,-12(fp)
 822b8d8:	e0ffff17 	ldw	r3,-4(fp)
 822b8dc:	19000044 	addi	r4,r3,1
 822b8e0:	e13fff15 	stw	r4,-4(fp)
 822b8e4:	18c00003 	ldbu	r3,0(r3)
 822b8e8:	10c00005 	stb	r3,0(r2)
   *p2++ = *ptr++;
 822b8ec:	e0bffd17 	ldw	r2,-12(fp)
 822b8f0:	10c00044 	addi	r3,r2,1
 822b8f4:	e0fffd15 	stw	r3,-12(fp)
 822b8f8:	e0ffff17 	ldw	r3,-4(fp)
 822b8fc:	19000044 	addi	r4,r3,1
 822b900:	e13fff15 	stw	r4,-4(fp)
 822b904:	18c00003 	ldbu	r3,0(r3)
 822b908:	10c00005 	stb	r3,0(r2)

   return v;
 822b90c:	e0bffe17 	ldw	r2,-8(fp)
}
 822b910:	e037883a 	mov	sp,fp
 822b914:	df000017 	ldw	fp,0(sp)
 822b918:	dec00104 	addi	sp,sp,4
 822b91c:	f800283a 	ret

0822b920 <dhc_extract_opts>:
 * of the options passed were filled in with good values. 
 */

int
dhc_extract_opts(int iface, u_char *opts)
{
 822b920:	defff904 	addi	sp,sp,-28
 822b924:	dfc00615 	stw	ra,24(sp)
 822b928:	df000515 	stw	fp,20(sp)
 822b92c:	dc000415 	stw	r16,16(sp)
 822b930:	df000504 	addi	fp,sp,20
 822b934:	e13ffd15 	stw	r4,-12(fp)
 822b938:	e17ffe15 	stw	r5,-8(fp)
   u_char *end = opts + DHCP_OPTSIZE;  /* limit scope of search */
 822b93c:	e0bffe17 	ldw	r2,-8(fp)
 822b940:	10804e04 	addi	r2,r2,312
 822b944:	e0bffb15 	stw	r2,-20(fp)
   u_char optlen;

   /* first, clear the options */
   dhc_states[iface].snmask = 0; 
 822b948:	008209b4 	movhi	r2,2086
 822b94c:	10b84a04 	addi	r2,r2,-7896
 822b950:	e0fffd17 	ldw	r3,-12(fp)
 822b954:	18c00f24 	muli	r3,r3,60
 822b958:	10c5883a 	add	r2,r2,r3
 822b95c:	10800a04 	addi	r2,r2,40
 822b960:	10000015 	stw	zero,0(r2)
   dhc_states[iface].defgw = 0; 
 822b964:	008209b4 	movhi	r2,2086
 822b968:	10b84a04 	addi	r2,r2,-7896
 822b96c:	e0fffd17 	ldw	r3,-12(fp)
 822b970:	18c00f24 	muli	r3,r3,60
 822b974:	10c5883a 	add	r2,r2,r3
 822b978:	10800b04 	addi	r2,r2,44
 822b97c:	10000015 	stw	zero,0(r2)
   dhc_states[iface].lease = 0; 
 822b980:	008209b4 	movhi	r2,2086
 822b984:	10b84a04 	addi	r2,r2,-7896
 822b988:	e0fffd17 	ldw	r3,-12(fp)
 822b98c:	18c00f24 	muli	r3,r3,60
 822b990:	10c5883a 	add	r2,r2,r3
 822b994:	10800504 	addi	r2,r2,20
 822b998:	10000015 	stw	zero,0(r2)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 822b99c:	00007106 	br	822bb64 <dhc_extract_opts+0x244>
   {
      switch (*opts++)
 822b9a0:	e0bffe17 	ldw	r2,-8(fp)
 822b9a4:	10c00044 	addi	r3,r2,1
 822b9a8:	e0fffe15 	stw	r3,-8(fp)
 822b9ac:	10800003 	ldbu	r2,0(r2)
 822b9b0:	10803fcc 	andi	r2,r2,255
 822b9b4:	10c000e0 	cmpeqi	r3,r2,3
 822b9b8:	1800201e 	bne	r3,zero,822ba3c <dhc_extract_opts+0x11c>
 822b9bc:	10c00108 	cmpgei	r3,r2,4
 822b9c0:	1800041e 	bne	r3,zero,822b9d4 <dhc_extract_opts+0xb4>
 822b9c4:	10006726 	beq	r2,zero,822bb64 <dhc_extract_opts+0x244>
 822b9c8:	10800060 	cmpeqi	r2,r2,1
 822b9cc:	10000a1e 	bne	r2,zero,822b9f8 <dhc_extract_opts+0xd8>
 822b9d0:	00005c06 	br	822bb44 <dhc_extract_opts+0x224>
 822b9d4:	10c00ce0 	cmpeqi	r3,r2,51
 822b9d8:	18002f1e 	bne	r3,zero,822ba98 <dhc_extract_opts+0x178>
 822b9dc:	10c03fe0 	cmpeqi	r3,r2,255
 822b9e0:	1800031e 	bne	r3,zero,822b9f0 <dhc_extract_opts+0xd0>
 822b9e4:	108001a0 	cmpeqi	r2,r2,6
 822b9e8:	10004c1e 	bne	r2,zero,822bb1c <dhc_extract_opts+0x1fc>
 822b9ec:	00005506 	br	822bb44 <dhc_extract_opts+0x224>
      {
      case DHOP_PAD:
         break;
      case DHOP_END:
         return 0;   /* only good exit point */
 822b9f0:	0005883a 	mov	r2,zero
 822b9f4:	00006006 	br	822bb78 <dhc_extract_opts+0x258>
      case DHOP_SNMASK:
         opts++;
 822b9f8:	e0bffe17 	ldw	r2,-8(fp)
 822b9fc:	10800044 	addi	r2,r2,1
 822ba00:	e0bffe15 	stw	r2,-8(fp)
         dhc_states[iface].snmask = dh_getlong(opts);
 822ba04:	e13ffe17 	ldw	r4,-8(fp)
 822ba08:	822b8740 	call	822b874 <dh_getlong>
 822ba0c:	1009883a 	mov	r4,r2
 822ba10:	008209b4 	movhi	r2,2086
 822ba14:	10b84a04 	addi	r2,r2,-7896
 822ba18:	e0fffd17 	ldw	r3,-12(fp)
 822ba1c:	18c00f24 	muli	r3,r3,60
 822ba20:	10c5883a 	add	r2,r2,r3
 822ba24:	10800a04 	addi	r2,r2,40
 822ba28:	11000015 	stw	r4,0(r2)
         opts += 4;
 822ba2c:	e0bffe17 	ldw	r2,-8(fp)
 822ba30:	10800104 	addi	r2,r2,4
 822ba34:	e0bffe15 	stw	r2,-8(fp)
         break;
 822ba38:	00004a06 	br	822bb64 <dhc_extract_opts+0x244>
      case DHOP_ROUTER:
         optlen = *opts++;
 822ba3c:	e0bffe17 	ldw	r2,-8(fp)
 822ba40:	10c00044 	addi	r3,r2,1
 822ba44:	e0fffe15 	stw	r3,-8(fp)
 822ba48:	10800003 	ldbu	r2,0(r2)
 822ba4c:	e0bffc05 	stb	r2,-16(fp)
         if (optlen >= 4)
 822ba50:	e0bffc03 	ldbu	r2,-16(fp)
 822ba54:	10800130 	cmpltui	r2,r2,4
 822ba58:	10000a1e 	bne	r2,zero,822ba84 <dhc_extract_opts+0x164>
            dhc_states[iface].defgw = dh_getlong(opts);
 822ba5c:	e13ffe17 	ldw	r4,-8(fp)
 822ba60:	822b8740 	call	822b874 <dh_getlong>
 822ba64:	1009883a 	mov	r4,r2
 822ba68:	008209b4 	movhi	r2,2086
 822ba6c:	10b84a04 	addi	r2,r2,-7896
 822ba70:	e0fffd17 	ldw	r3,-12(fp)
 822ba74:	18c00f24 	muli	r3,r3,60
 822ba78:	10c5883a 	add	r2,r2,r3
 822ba7c:	10800b04 	addi	r2,r2,44
 822ba80:	11000015 	stw	r4,0(r2)
         opts += optlen;
 822ba84:	e0bffc03 	ldbu	r2,-16(fp)
 822ba88:	e0fffe17 	ldw	r3,-8(fp)
 822ba8c:	1885883a 	add	r2,r3,r2
 822ba90:	e0bffe15 	stw	r2,-8(fp)
         break;
 822ba94:	00003306 	br	822bb64 <dhc_extract_opts+0x244>
      case DHOP_LEASE:
         opts++;
 822ba98:	e0bffe17 	ldw	r2,-8(fp)
 822ba9c:	10800044 	addi	r2,r2,1
 822baa0:	e0bffe15 	stw	r2,-8(fp)
         dhc_states[iface].lease = htonl(dh_getlong(opts));
 822baa4:	e13ffe17 	ldw	r4,-8(fp)
 822baa8:	822b8740 	call	822b874 <dh_getlong>
 822baac:	1004d63a 	srli	r2,r2,24
 822bab0:	1021883a 	mov	r16,r2
 822bab4:	e13ffe17 	ldw	r4,-8(fp)
 822bab8:	822b8740 	call	822b874 <dh_getlong>
 822babc:	1005d23a 	srai	r2,r2,8
 822bac0:	10bfc00c 	andi	r2,r2,65280
 822bac4:	80a0b03a 	or	r16,r16,r2
 822bac8:	e13ffe17 	ldw	r4,-8(fp)
 822bacc:	822b8740 	call	822b874 <dh_getlong>
 822bad0:	10bfc00c 	andi	r2,r2,65280
 822bad4:	1004923a 	slli	r2,r2,8
 822bad8:	80a0b03a 	or	r16,r16,r2
 822badc:	e13ffe17 	ldw	r4,-8(fp)
 822bae0:	822b8740 	call	822b874 <dh_getlong>
 822bae4:	1004963a 	slli	r2,r2,24
 822bae8:	8084b03a 	or	r2,r16,r2
 822baec:	1009883a 	mov	r4,r2
 822baf0:	008209b4 	movhi	r2,2086
 822baf4:	10b84a04 	addi	r2,r2,-7896
 822baf8:	e0fffd17 	ldw	r3,-12(fp)
 822bafc:	18c00f24 	muli	r3,r3,60
 822bb00:	10c5883a 	add	r2,r2,r3
 822bb04:	10800504 	addi	r2,r2,20
 822bb08:	11000015 	stw	r4,0(r2)
         opts += 4;
 822bb0c:	e0bffe17 	ldw	r2,-8(fp)
 822bb10:	10800104 	addi	r2,r2,4
 822bb14:	e0bffe15 	stw	r2,-8(fp)
         break;
 822bb18:	00001206 	br	822bb64 <dhc_extract_opts+0x244>
      case DHOP_DNSRV:
         optlen = *opts++;
 822bb1c:	e0bffe17 	ldw	r2,-8(fp)
 822bb20:	10c00044 	addi	r3,r2,1
 822bb24:	e0fffe15 	stw	r3,-8(fp)
 822bb28:	10800003 	ldbu	r2,0(r2)
 822bb2c:	e0bffc05 	stb	r2,-16(fp)
               opts += 4;
               i++;
            }
         }
#endif   /* DHC_MAXDNSRVS */
         opts += optlen;
 822bb30:	e0bffc03 	ldbu	r2,-16(fp)
 822bb34:	e0fffe17 	ldw	r3,-8(fp)
 822bb38:	1885883a 	add	r2,r3,r2
 822bb3c:	e0bffe15 	stw	r2,-8(fp)
         break;
 822bb40:	00000806 	br	822bb64 <dhc_extract_opts+0x244>
      default:
         opts += ((*opts) + 1);
 822bb44:	e0bffe17 	ldw	r2,-8(fp)
 822bb48:	10800003 	ldbu	r2,0(r2)
 822bb4c:	10803fcc 	andi	r2,r2,255
 822bb50:	10800044 	addi	r2,r2,1
 822bb54:	e0fffe17 	ldw	r3,-8(fp)
 822bb58:	1885883a 	add	r2,r3,r2
 822bb5c:	e0bffe15 	stw	r2,-8(fp)
         break;
 822bb60:	0001883a 	nop
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 822bb64:	e0bffe17 	ldw	r2,-8(fp)
 822bb68:	e0fffb17 	ldw	r3,-20(fp)
 822bb6c:	18bf8c2e 	bgeu	r3,r2,822b9a0 <dhc_extract_opts+0x80>
      default:
         opts += ((*opts) + 1);
         break;
      }
   }
   dtrap();
 822bb70:	822d4140 	call	822d414 <dtrap>
   return -1;
 822bb74:	00bfffc4 	movi	r2,-1
}
 822bb78:	e6ffff04 	addi	sp,fp,-4
 822bb7c:	dfc00217 	ldw	ra,8(sp)
 822bb80:	df000117 	ldw	fp,4(sp)
 822bb84:	dc000017 	ldw	r16,0(sp)
 822bb88:	dec00304 	addi	sp,sp,12
 822bb8c:	f800283a 	ret

0822bb90 <dhc_second>:
 * RETURNS: Returns 0 or ENP_ error code 
 */

int
dhc_second(void)
{
 822bb90:	defffa04 	addi	sp,sp,-24
 822bb94:	dfc00515 	stw	ra,20(sp)
 822bb98:	df000415 	stw	fp,16(sp)
 822bb9c:	df000404 	addi	fp,sp,16
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 822bba0:	e03ffc15 	stw	zero,-16(fp)
 822bba4:	00014506 	br	822c0bc <dhc_second+0x52c>
   {
      switch (dhc_states[iface].state)
 822bba8:	008209b4 	movhi	r2,2086
 822bbac:	10b84a04 	addi	r2,r2,-7896
 822bbb0:	e0fffc17 	ldw	r3,-16(fp)
 822bbb4:	18c00f24 	muli	r3,r3,60
 822bbb8:	10c5883a 	add	r2,r2,r3
 822bbbc:	10800017 	ldw	r2,0(r2)
 822bbc0:	10c00268 	cmpgeui	r3,r2,9
 822bbc4:	1801311e 	bne	r3,zero,822c08c <dhc_second+0x4fc>
 822bbc8:	100690ba 	slli	r3,r2,2
 822bbcc:	008208f4 	movhi	r2,2083
 822bbd0:	10aef804 	addi	r2,r2,-17440
 822bbd4:	1885883a 	add	r2,r3,r2
 822bbd8:	10800017 	ldw	r2,0(r2)
 822bbdc:	1000683a 	jmp	r2
 822bbe0:	0822c08c 	andi	zero,at,35586
 822bbe4:	0822bc04 	addi	zero,at,-29968
 822bbe8:	0822bc34 	orhi	zero,at,35568
 822bbec:	0822bc64 	muli	zero,at,-29967
 822bbf0:	0822bc64 	muli	zero,at,-29967
 822bbf4:	0822bc64 	muli	zero,at,-29967
 822bbf8:	0822bea4 	muli	zero,at,-29958
 822bbfc:	0822bf4c 	andi	zero,at,35581
 822bc00:	0822bd80 	call	822bd8 <OSCtxSw_SWITCH_PC+0x822b98>
      {
      case DHCS_INIT:         /* Send a discover packet */
         e = dhc_discover(iface);
 822bc04:	e13ffc17 	ldw	r4,-16(fp)
 822bc08:	822a3fc0 	call	822a3fc <dhc_discover>
 822bc0c:	e0bfff15 	stw	r2,-4(fp)
         /* Error while sending a discover packet */
         if (e)
 822bc10:	e0bfff17 	ldw	r2,-4(fp)
 822bc14:	10000326 	beq	r2,zero,822bc24 <dhc_second+0x94>
         {
            dtrap();
 822bc18:	822d4140 	call	822d414 <dtrap>
            return e;
 822bc1c:	e0bfff17 	ldw	r2,-4(fp)
 822bc20:	00012a06 	br	822c0cc <dhc_second+0x53c>
         }
         dhc_set_state(iface,DHCS_SELECTING);
 822bc24:	01400104 	movi	r5,4
 822bc28:	e13ffc17 	ldw	r4,-16(fp)
 822bc2c:	822c4600 	call	822c460 <dhc_set_state>
         break;
 822bc30:	00011f06 	br	822c0b0 <dhc_second+0x520>
      case DHCS_INITREBOOT:   /* Send a request packet */
         e = dhc_reclaim(iface);
 822bc34:	e13ffc17 	ldw	r4,-16(fp)
 822bc38:	822c1600 	call	822c160 <dhc_reclaim>
 822bc3c:	e0bfff15 	stw	r2,-4(fp)
         if (e)
 822bc40:	e0bfff17 	ldw	r2,-4(fp)
 822bc44:	10000326 	beq	r2,zero,822bc54 <dhc_second+0xc4>
         {
            dtrap();
 822bc48:	822d4140 	call	822d414 <dtrap>
            return e;
 822bc4c:	e0bfff17 	ldw	r2,-4(fp)
 822bc50:	00011e06 	br	822c0cc <dhc_second+0x53c>
         }
         dhc_set_state(iface,DHCS_REBOOTING);
 822bc54:	014000c4 	movi	r5,3
 822bc58:	e13ffc17 	ldw	r4,-16(fp)
 822bc5c:	822c4600 	call	822c460 <dhc_set_state>
         break;
 822bc60:	00011306 	br	822c0b0 <dhc_second+0x520>
         /* Send discover packet on timeout */
      case DHCS_REBOOTING:
      case DHCS_REQUESTING:
         /* Discovery timeout = DHC_RETRY_TMO secs * (2 ** retries), max 64 */

         tries = dhc_states[iface].tries ;
 822bc64:	008209b4 	movhi	r2,2086
 822bc68:	10b84a04 	addi	r2,r2,-7896
 822bc6c:	e0fffc17 	ldw	r3,-16(fp)
 822bc70:	18c00f24 	muli	r3,r3,60
 822bc74:	10c5883a 	add	r2,r2,r3
 822bc78:	10800104 	addi	r2,r2,4
 822bc7c:	10800017 	ldw	r2,0(r2)
 822bc80:	e0bffd15 	stw	r2,-12(fp)

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
 822bc84:	e0bffd17 	ldw	r2,-12(fp)
 822bc88:	10800110 	cmplti	r2,r2,4
 822bc8c:	1000021e 	bne	r2,zero,822bc98 <dhc_second+0x108>
            tries= DHC_MAX_TRIES;
 822bc90:	00800104 	movi	r2,4
 822bc94:	e0bffd15 	stw	r2,-12(fp)
         if ( cticks > (dhc_states[iface].last_tick + 
 822bc98:	008209b4 	movhi	r2,2086
 822bc9c:	10b84a04 	addi	r2,r2,-7896
 822bca0:	e0fffc17 	ldw	r3,-16(fp)
 822bca4:	18c00f24 	muli	r3,r3,60
 822bca8:	10c5883a 	add	r2,r2,r3
 822bcac:	10800404 	addi	r2,r2,16
 822bcb0:	10c00017 	ldw	r3,0(r2)
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
 822bcb4:	01006404 	movi	r4,400
 822bcb8:	e0bffd17 	ldw	r2,-12(fp)
 822bcbc:	2084983a 	sll	r2,r4,r2
         tries = dhc_states[iface].tries ;

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
            tries= DHC_MAX_TRIES;
         if ( cticks > (dhc_states[iface].last_tick + 
 822bcc0:	1887883a 	add	r3,r3,r2
 822bcc4:	d0a0a817 	ldw	r2,-32096(gp)
 822bcc8:	1880192e 	bgeu	r3,r2,822bd30 <dhc_second+0x1a0>
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
         {
            /* Timeout while waiting for a OFFER/ACK/NAK. Retransmit */
            switch(dhc_states[iface].state)
 822bccc:	008209b4 	movhi	r2,2086
 822bcd0:	10b84a04 	addi	r2,r2,-7896
 822bcd4:	e0fffc17 	ldw	r3,-16(fp)
 822bcd8:	18c00f24 	muli	r3,r3,60
 822bcdc:	10c5883a 	add	r2,r2,r3
 822bce0:	10800017 	ldw	r2,0(r2)
 822bce4:	10c00120 	cmpeqi	r3,r2,4
 822bce8:	1800051e 	bne	r3,zero,822bd00 <dhc_second+0x170>
 822bcec:	10c00160 	cmpeqi	r3,r2,5
 822bcf0:	1800061e 	bne	r3,zero,822bd0c <dhc_second+0x17c>
 822bcf4:	108000e0 	cmpeqi	r2,r2,3
 822bcf8:	1000081e 	bne	r2,zero,822bd1c <dhc_second+0x18c>
 822bcfc:	00000a06 	br	822bd28 <dhc_second+0x198>
            {
            case DHCS_SELECTING:
               dhc_discover(iface);
 822bd00:	e13ffc17 	ldw	r4,-16(fp)
 822bd04:	822a3fc0 	call	822a3fc <dhc_discover>
               break;
 822bd08:	00000906 	br	822bd30 <dhc_second+0x1a0>
            case DHCS_REQUESTING:
               dhc_request(iface,FALSE);
 822bd0c:	000b883a 	mov	r5,zero
 822bd10:	e13ffc17 	ldw	r4,-16(fp)
 822bd14:	822a9880 	call	822a988 <dhc_request>
               break;
 822bd18:	00000506 	br	822bd30 <dhc_second+0x1a0>
            case DHCS_REBOOTING:
               dhc_reclaim(iface);
 822bd1c:	e13ffc17 	ldw	r4,-16(fp)
 822bd20:	822c1600 	call	822c160 <dhc_reclaim>
               break;
 822bd24:	00000206 	br	822bd30 <dhc_second+0x1a0>
            default:
               dtrap(); /* bogus state */
 822bd28:	822d4140 	call	822d414 <dtrap>
               break;
 822bd2c:	0001883a 	nop
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 822bd30:	e0bffd17 	ldw	r2,-12(fp)
 822bd34:	10800118 	cmpnei	r2,r2,4
 822bd38:	1000d61e 	bne	r2,zero,822c094 <dhc_second+0x504>
             (dhc_states[iface].state !=DHCS_SELECTING) )
 822bd3c:	008209b4 	movhi	r2,2086
 822bd40:	10b84a04 	addi	r2,r2,-7896
 822bd44:	e0fffc17 	ldw	r3,-16(fp)
 822bd48:	18c00f24 	muli	r3,r3,60
 822bd4c:	10c5883a 	add	r2,r2,r3
 822bd50:	10800017 	ldw	r2,0(r2)
            default:
               dtrap(); /* bogus state */
               break;
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 822bd54:	10800120 	cmpeqi	r2,r2,4
 822bd58:	1000ce1e 	bne	r2,zero,822c094 <dhc_second+0x504>
             (dhc_states[iface].state !=DHCS_SELECTING) )
         {
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
 822bd5c:	01400244 	movi	r5,9
 822bd60:	e13ffc17 	ldw	r4,-16(fp)
 822bd64:	822c4600 	call	822c460 <dhc_set_state>
            dhc_resetip(iface);
 822bd68:	e13ffc17 	ldw	r4,-16(fp)
 822bd6c:	822b6880 	call	822b688 <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 822bd70:	01400044 	movi	r5,1
 822bd74:	e13ffc17 	ldw	r4,-16(fp)
 822bd78:	822c4600 	call	822c460 <dhc_set_state>
         }
         break;
 822bd7c:	0000c506 	br	822c094 <dhc_second+0x504>
      case DHCS_REBINDING:
         /* Check for timeout. Retry if we didn't get a ACK/NAK response. */

         if ( (dhc_states[iface].lease*TPS+dhc_states[iface].lease_start) > cticks )
 822bd80:	008209b4 	movhi	r2,2086
 822bd84:	10b84a04 	addi	r2,r2,-7896
 822bd88:	e0fffc17 	ldw	r3,-16(fp)
 822bd8c:	18c00f24 	muli	r3,r3,60
 822bd90:	10c5883a 	add	r2,r2,r3
 822bd94:	10800504 	addi	r2,r2,20
 822bd98:	10800017 	ldw	r2,0(r2)
 822bd9c:	10c01924 	muli	r3,r2,100
 822bda0:	008209b4 	movhi	r2,2086
 822bda4:	10b84a04 	addi	r2,r2,-7896
 822bda8:	e13ffc17 	ldw	r4,-16(fp)
 822bdac:	21000f24 	muli	r4,r4,60
 822bdb0:	1105883a 	add	r2,r2,r4
 822bdb4:	10800804 	addi	r2,r2,32
 822bdb8:	10800017 	ldw	r2,0(r2)
 822bdbc:	1885883a 	add	r2,r3,r2
 822bdc0:	d0e0a817 	ldw	r3,-32096(gp)
 822bdc4:	18802e2e 	bgeu	r3,r2,822be80 <dhc_second+0x2f0>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 822bdc8:	008209b4 	movhi	r2,2086
 822bdcc:	10b84a04 	addi	r2,r2,-7896
 822bdd0:	e0fffc17 	ldw	r3,-16(fp)
 822bdd4:	18c00f24 	muli	r3,r3,60
 822bdd8:	10c5883a 	add	r2,r2,r3
 822bddc:	10800804 	addi	r2,r2,32
 822bde0:	10c00017 	ldw	r3,0(r2)
             dhc_states[iface].lease*TPS - 
 822bde4:	008209b4 	movhi	r2,2086
 822bde8:	10b84a04 	addi	r2,r2,-7896
 822bdec:	e13ffc17 	ldw	r4,-16(fp)
 822bdf0:	21000f24 	muli	r4,r4,60
 822bdf4:	1105883a 	add	r2,r2,r4
 822bdf8:	10800504 	addi	r2,r2,20
 822bdfc:	10800017 	ldw	r2,0(r2)
 822be00:	10801924 	muli	r2,r2,100
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 822be04:	1887883a 	add	r3,r3,r2
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;
 822be08:	008209b4 	movhi	r2,2086
 822be0c:	10b84a04 	addi	r2,r2,-7896
 822be10:	e13ffc17 	ldw	r4,-16(fp)
 822be14:	21000f24 	muli	r4,r4,60
 822be18:	1105883a 	add	r2,r2,r4
 822be1c:	10800404 	addi	r2,r2,16
 822be20:	10800017 	ldw	r2,0(r2)
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
             dhc_states[iface].lease*TPS - 
 822be24:	1885c83a 	sub	r2,r3,r2
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 822be28:	1004d07a 	srli	r2,r2,1
 822be2c:	e0bffe15 	stw	r2,-8(fp)
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 822be30:	e0bffe17 	ldw	r2,-8(fp)
 822be34:	1085dc28 	cmpgeui	r2,r2,6000
 822be38:	1000021e 	bne	r2,zero,822be44 <dhc_second+0x2b4>
               half_time = 60*TPS;
 822be3c:	0085dc04 	movi	r2,6000
 822be40:	e0bffe15 	stw	r2,-8(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 822be44:	008209b4 	movhi	r2,2086
 822be48:	10b84a04 	addi	r2,r2,-7896
 822be4c:	e0fffc17 	ldw	r3,-16(fp)
 822be50:	18c00f24 	muli	r3,r3,60
 822be54:	10c5883a 	add	r2,r2,r3
 822be58:	10800404 	addi	r2,r2,16
 822be5c:	10c00017 	ldw	r3,0(r2)
 822be60:	e0bffe17 	ldw	r2,-8(fp)
 822be64:	1887883a 	add	r3,r3,r2
 822be68:	d0a0a817 	ldw	r2,-32096(gp)
 822be6c:	18808b2e 	bgeu	r3,r2,822c09c <dhc_second+0x50c>
            {
               dhc_request(iface,FALSE);
 822be70:	000b883a 	mov	r5,zero
 822be74:	e13ffc17 	ldw	r4,-16(fp)
 822be78:	822a9880 	call	822a988 <dhc_request>
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
            dhc_resetip(iface);
            dhc_set_state(iface,DHCS_INIT);
         }
         break;
 822be7c:	00008706 	br	822c09c <dhc_second+0x50c>
            }
         }
         else
         {
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
 822be80:	01400244 	movi	r5,9
 822be84:	e13ffc17 	ldw	r4,-16(fp)
 822be88:	822c4600 	call	822c460 <dhc_set_state>
            dhc_resetip(iface);
 822be8c:	e13ffc17 	ldw	r4,-16(fp)
 822be90:	822b6880 	call	822b688 <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 822be94:	01400044 	movi	r5,1
 822be98:	e13ffc17 	ldw	r4,-16(fp)
 822be9c:	822c4600 	call	822c460 <dhc_set_state>
         }
         break;
 822bea0:	00007e06 	br	822c09c <dhc_second+0x50c>

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 822bea4:	008209b4 	movhi	r2,2086
 822bea8:	10b84a04 	addi	r2,r2,-7896
 822beac:	e0fffc17 	ldw	r3,-16(fp)
 822beb0:	18c00f24 	muli	r3,r3,60
 822beb4:	10c5883a 	add	r2,r2,r3
 822beb8:	10800604 	addi	r2,r2,24
 822bebc:	10800017 	ldw	r2,0(r2)
 822bec0:	10bfffe0 	cmpeqi	r2,r2,-1
 822bec4:	1000771e 	bne	r2,zero,822c0a4 <dhc_second+0x514>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
 822bec8:	008209b4 	movhi	r2,2086
 822becc:	10b84a04 	addi	r2,r2,-7896
 822bed0:	e0fffc17 	ldw	r3,-16(fp)
 822bed4:	18c00f24 	muli	r3,r3,60
 822bed8:	10c5883a 	add	r2,r2,r3
 822bedc:	10800604 	addi	r2,r2,24
 822bee0:	10800017 	ldw	r2,0(r2)
 822bee4:	10c01924 	muli	r3,r2,100
 822bee8:	008209b4 	movhi	r2,2086
 822beec:	10b84a04 	addi	r2,r2,-7896
 822bef0:	e13ffc17 	ldw	r4,-16(fp)
 822bef4:	21000f24 	muli	r4,r4,60
 822bef8:	1105883a 	add	r2,r2,r4
 822befc:	10800804 	addi	r2,r2,32
 822bf00:	10800017 	ldw	r2,0(r2)
 822bf04:	1887883a 	add	r3,r3,r2
 822bf08:	d0a0a817 	ldw	r2,-32096(gp)
         }
         break;

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 822bf0c:	1880652e 	bgeu	r3,r2,822c0a4 <dhc_second+0x514>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
         {
            /* Time to renew. Send a UNICAST to the DHCP server */
            dhc_set_state(iface,DHCS_RENEWING);
 822bf10:	014001c4 	movi	r5,7
 822bf14:	e13ffc17 	ldw	r4,-16(fp)
 822bf18:	822c4600 	call	822c460 <dhc_set_state>
            e = dhc_reclaim(iface); /* unicast */ 
 822bf1c:	e13ffc17 	ldw	r4,-16(fp)
 822bf20:	822c1600 	call	822c160 <dhc_reclaim>
 822bf24:	e0bfff15 	stw	r2,-4(fp)
            if (e)
 822bf28:	e0bfff17 	ldw	r2,-4(fp)
 822bf2c:	10000326 	beq	r2,zero,822bf3c <dhc_second+0x3ac>
            {
               dtrap();
 822bf30:	822d4140 	call	822d414 <dtrap>
               return e;
 822bf34:	e0bfff17 	ldw	r2,-4(fp)
 822bf38:	00006406 	br	822c0cc <dhc_second+0x53c>
            }
            dsc_renew++;
 822bf3c:	d0a09917 	ldw	r2,-32156(gp)
 822bf40:	10800044 	addi	r2,r2,1
 822bf44:	d0a09915 	stw	r2,-32156(gp)
         }
         break;
 822bf48:	00005606 	br	822c0a4 <dhc_second+0x514>
      case DHCS_RENEWING:
         /* Test for lease expiry. The REBIND timer. */
         if ( (dhc_states[iface].t2*TPS+dhc_states[iface].lease_start) > cticks )
 822bf4c:	008209b4 	movhi	r2,2086
 822bf50:	10b84a04 	addi	r2,r2,-7896
 822bf54:	e0fffc17 	ldw	r3,-16(fp)
 822bf58:	18c00f24 	muli	r3,r3,60
 822bf5c:	10c5883a 	add	r2,r2,r3
 822bf60:	10800704 	addi	r2,r2,28
 822bf64:	10800017 	ldw	r2,0(r2)
 822bf68:	10c01924 	muli	r3,r2,100
 822bf6c:	008209b4 	movhi	r2,2086
 822bf70:	10b84a04 	addi	r2,r2,-7896
 822bf74:	e13ffc17 	ldw	r4,-16(fp)
 822bf78:	21000f24 	muli	r4,r4,60
 822bf7c:	1105883a 	add	r2,r2,r4
 822bf80:	10800804 	addi	r2,r2,32
 822bf84:	10800017 	ldw	r2,0(r2)
 822bf88:	1885883a 	add	r2,r3,r2
 822bf8c:	d0e0a817 	ldw	r3,-32096(gp)
 822bf90:	18802e2e 	bgeu	r3,r2,822c04c <dhc_second+0x4bc>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 822bf94:	008209b4 	movhi	r2,2086
 822bf98:	10b84a04 	addi	r2,r2,-7896
 822bf9c:	e0fffc17 	ldw	r3,-16(fp)
 822bfa0:	18c00f24 	muli	r3,r3,60
 822bfa4:	10c5883a 	add	r2,r2,r3
 822bfa8:	10800804 	addi	r2,r2,32
 822bfac:	10c00017 	ldw	r3,0(r2)
             dhc_states[iface].t2*TPS - 
 822bfb0:	008209b4 	movhi	r2,2086
 822bfb4:	10b84a04 	addi	r2,r2,-7896
 822bfb8:	e13ffc17 	ldw	r4,-16(fp)
 822bfbc:	21000f24 	muli	r4,r4,60
 822bfc0:	1105883a 	add	r2,r2,r4
 822bfc4:	10800704 	addi	r2,r2,28
 822bfc8:	10800017 	ldw	r2,0(r2)
 822bfcc:	10801924 	muli	r2,r2,100
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 822bfd0:	1887883a 	add	r3,r3,r2
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;
 822bfd4:	008209b4 	movhi	r2,2086
 822bfd8:	10b84a04 	addi	r2,r2,-7896
 822bfdc:	e13ffc17 	ldw	r4,-16(fp)
 822bfe0:	21000f24 	muli	r4,r4,60
 822bfe4:	1105883a 	add	r2,r2,r4
 822bfe8:	10800404 	addi	r2,r2,16
 822bfec:	10800017 	ldw	r2,0(r2)
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
             dhc_states[iface].t2*TPS - 
 822bff0:	1885c83a 	sub	r2,r3,r2
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 822bff4:	1004d07a 	srli	r2,r2,1
 822bff8:	e0bffe15 	stw	r2,-8(fp)
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 822bffc:	e0bffe17 	ldw	r2,-8(fp)
 822c000:	1085dc28 	cmpgeui	r2,r2,6000
 822c004:	1000021e 	bne	r2,zero,822c010 <dhc_second+0x480>
               half_time = 60*TPS;
 822c008:	0085dc04 	movi	r2,6000
 822c00c:	e0bffe15 	stw	r2,-8(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 822c010:	008209b4 	movhi	r2,2086
 822c014:	10b84a04 	addi	r2,r2,-7896
 822c018:	e0fffc17 	ldw	r3,-16(fp)
 822c01c:	18c00f24 	muli	r3,r3,60
 822c020:	10c5883a 	add	r2,r2,r3
 822c024:	10800404 	addi	r2,r2,16
 822c028:	10c00017 	ldw	r3,0(r2)
 822c02c:	e0bffe17 	ldw	r2,-8(fp)
 822c030:	1887883a 	add	r3,r3,r2
 822c034:	d0a0a817 	ldw	r2,-32096(gp)
 822c038:	18801c2e 	bgeu	r3,r2,822c0ac <dhc_second+0x51c>
            {
               dhc_request(iface,FALSE);
 822c03c:	000b883a 	mov	r5,zero
 822c040:	e13ffc17 	ldw	r4,-16(fp)
 822c044:	822a9880 	call	822a988 <dhc_request>
               dtrap();
               return e;
            }
            dsc_rebind++;
         }
         break;
 822c048:	00001806 	br	822c0ac <dhc_second+0x51c>
         {
            /* No Response has come from the Server that assigned our 
             * IP. Hence send a broadcast packet to see if we can 
             * lease this IP from some other server 
             */
            dhc_set_state(iface,DHCS_REBINDING);
 822c04c:	01400204 	movi	r5,8
 822c050:	e13ffc17 	ldw	r4,-16(fp)
 822c054:	822c4600 	call	822c460 <dhc_set_state>
            e = dhc_request(iface,TRUE);  /* broadcast */
 822c058:	01400044 	movi	r5,1
 822c05c:	e13ffc17 	ldw	r4,-16(fp)
 822c060:	822a9880 	call	822a988 <dhc_request>
 822c064:	e0bfff15 	stw	r2,-4(fp)
            if (e)
 822c068:	e0bfff17 	ldw	r2,-4(fp)
 822c06c:	10000326 	beq	r2,zero,822c07c <dhc_second+0x4ec>
            {
               dtrap();
 822c070:	822d4140 	call	822d414 <dtrap>
               return e;
 822c074:	e0bfff17 	ldw	r2,-4(fp)
 822c078:	00001406 	br	822c0cc <dhc_second+0x53c>
            }
            dsc_rebind++;
 822c07c:	d0a09a17 	ldw	r2,-32152(gp)
 822c080:	10800044 	addi	r2,r2,1
 822c084:	d0a09a15 	stw	r2,-32152(gp)
         }
         break;
 822c088:	00000806 	br	822c0ac <dhc_second+0x51c>
      case DHCS_UNUSED:
      default:
         continue;
 822c08c:	0001883a 	nop
 822c090:	00000706 	br	822c0b0 <dhc_second+0x520>
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
            dhc_resetip(iface);
            dhc_set_state(iface,DHCS_INIT);
         }
         break;
 822c094:	0001883a 	nop
 822c098:	00000506 	br	822c0b0 <dhc_second+0x520>
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
            dhc_resetip(iface);
            dhc_set_state(iface,DHCS_INIT);
         }
         break;
 822c09c:	0001883a 	nop
 822c0a0:	00000306 	br	822c0b0 <dhc_second+0x520>
               dtrap();
               return e;
            }
            dsc_renew++;
         }
         break;
 822c0a4:	0001883a 	nop
 822c0a8:	00000106 	br	822c0b0 <dhc_second+0x520>
               dtrap();
               return e;
            }
            dsc_rebind++;
         }
         break;
 822c0ac:	0001883a 	nop
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 822c0b0:	e0bffc17 	ldw	r2,-16(fp)
 822c0b4:	10800044 	addi	r2,r2,1
 822c0b8:	e0bffc15 	stw	r2,-16(fp)
 822c0bc:	e0bffc17 	ldw	r2,-16(fp)
 822c0c0:	10800110 	cmplti	r2,r2,4
 822c0c4:	103eb81e 	bne	r2,zero,822bba8 <dhc_second+0x18>
      case DHCS_UNUSED:
      default:
         continue;
      }
   }
   return 0;
 822c0c8:	0005883a 	mov	r2,zero
}
 822c0cc:	e037883a 	mov	sp,fp
 822c0d0:	dfc00117 	ldw	ra,4(sp)
 822c0d4:	df000017 	ldw	fp,0(sp)
 822c0d8:	dec00204 	addi	sp,sp,8
 822c0dc:	f800283a 	ret

0822c0e0 <dhc_halt>:
 * RETURNS: void
 */

void
dhc_halt(int iface)
{
 822c0e0:	defffd04 	addi	sp,sp,-12
 822c0e4:	dfc00215 	stw	ra,8(sp)
 822c0e8:	df000115 	stw	fp,4(sp)
 822c0ec:	df000104 	addi	fp,sp,4
 822c0f0:	e13fff15 	stw	r4,-4(fp)
   if (iface < 0 || iface > MAXNETS)
 822c0f4:	e0bfff17 	ldw	r2,-4(fp)
 822c0f8:	10000316 	blt	r2,zero,822c108 <dhc_halt+0x28>
 822c0fc:	e0bfff17 	ldw	r2,-4(fp)
 822c100:	10800150 	cmplti	r2,r2,5
 822c104:	1000021e 	bne	r2,zero,822c110 <dhc_halt+0x30>
   {
      dtrap();
 822c108:	822d4140 	call	822d414 <dtrap>
      return;
 822c10c:	00000f06 	br	822c14c <dhc_halt+0x6c>
   }
   /* clear dhc_states entry - (kills retrys) */
   MEMSET(&dhc_states[iface], 0, sizeof(struct dhc_state));
 822c110:	e0bfff17 	ldw	r2,-4(fp)
 822c114:	10c00f24 	muli	r3,r2,60
 822c118:	008209b4 	movhi	r2,2086
 822c11c:	10b84a04 	addi	r2,r2,-7896
 822c120:	1885883a 	add	r2,r3,r2
 822c124:	01800f04 	movi	r6,60
 822c128:	000b883a 	mov	r5,zero
 822c12c:	1009883a 	mov	r4,r2
 822c130:	82031300 	call	8203130 <memset>
   dhc_states[iface].state = DHCS_UNUSED;
 822c134:	008209b4 	movhi	r2,2086
 822c138:	10b84a04 	addi	r2,r2,-7896
 822c13c:	e0ffff17 	ldw	r3,-4(fp)
 822c140:	18c00f24 	muli	r3,r3,60
 822c144:	10c5883a 	add	r2,r2,r3
 822c148:	10000015 	stw	zero,0(r2)
}
 822c14c:	e037883a 	mov	sp,fp
 822c150:	dfc00117 	ldw	ra,4(sp)
 822c154:	df000017 	ldw	fp,0(sp)
 822c158:	dec00204 	addi	sp,sp,8
 822c15c:	f800283a 	ret

0822c160 <dhc_reclaim>:
 * RETURNS: Returns 0 if DHCP request was sent OK, else non-zero error. 
 */

int   
dhc_reclaim(int iface)
{
 822c160:	defffc04 	addi	sp,sp,-16
 822c164:	dfc00315 	stw	ra,12(sp)
 822c168:	df000215 	stw	fp,8(sp)
 822c16c:	df000204 	addi	fp,sp,8
 822c170:	e13fff15 	stw	r4,-4(fp)
   /* punt if IP address is not set */
   if (nets[iface]->n_ipaddr == 0L)
 822c174:	008209b4 	movhi	r2,2086
 822c178:	10b82404 	addi	r2,r2,-8048
 822c17c:	e0ffff17 	ldw	r3,-4(fp)
 822c180:	18c7883a 	add	r3,r3,r3
 822c184:	18c7883a 	add	r3,r3,r3
 822c188:	10c5883a 	add	r2,r2,r3
 822c18c:	10800017 	ldw	r2,0(r2)
 822c190:	10800a17 	ldw	r2,40(r2)
 822c194:	1000031e 	bne	r2,zero,822c1a4 <dhc_reclaim+0x44>
   {
      dtrap();    /* programming bug? */
 822c198:	822d4140 	call	822d414 <dtrap>
      return ENP_LOGIC;
 822c19c:	00bffd44 	movi	r2,-11
 822c1a0:	00005806 	br	822c304 <dhc_reclaim+0x1a4>
   }

   dhc_states[iface].ipaddr = nets[iface]->n_ipaddr;
 822c1a4:	008209b4 	movhi	r2,2086
 822c1a8:	10b82404 	addi	r2,r2,-8048
 822c1ac:	e0ffff17 	ldw	r3,-4(fp)
 822c1b0:	18c7883a 	add	r3,r3,r3
 822c1b4:	18c7883a 	add	r3,r3,r3
 822c1b8:	10c5883a 	add	r2,r2,r3
 822c1bc:	10800017 	ldw	r2,0(r2)
 822c1c0:	10c00a17 	ldw	r3,40(r2)
 822c1c4:	008209b4 	movhi	r2,2086
 822c1c8:	10b84a04 	addi	r2,r2,-7896
 822c1cc:	e13fff17 	ldw	r4,-4(fp)
 822c1d0:	21000f24 	muli	r4,r4,60
 822c1d4:	1105883a 	add	r2,r2,r4
 822c1d8:	10800904 	addi	r2,r2,36
 822c1dc:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].snmask = nets[iface]->snmask;
 822c1e0:	008209b4 	movhi	r2,2086
 822c1e4:	10b82404 	addi	r2,r2,-8048
 822c1e8:	e0ffff17 	ldw	r3,-4(fp)
 822c1ec:	18c7883a 	add	r3,r3,r3
 822c1f0:	18c7883a 	add	r3,r3,r3
 822c1f4:	10c5883a 	add	r2,r2,r3
 822c1f8:	10800017 	ldw	r2,0(r2)
 822c1fc:	10c00c17 	ldw	r3,48(r2)
 822c200:	008209b4 	movhi	r2,2086
 822c204:	10b84a04 	addi	r2,r2,-7896
 822c208:	e13fff17 	ldw	r4,-4(fp)
 822c20c:	21000f24 	muli	r4,r4,60
 822c210:	1105883a 	add	r2,r2,r4
 822c214:	10800a04 	addi	r2,r2,40
 822c218:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].defgw  = nets[iface]->n_defgw;
 822c21c:	008209b4 	movhi	r2,2086
 822c220:	10b82404 	addi	r2,r2,-8048
 822c224:	e0ffff17 	ldw	r3,-4(fp)
 822c228:	18c7883a 	add	r3,r3,r3
 822c22c:	18c7883a 	add	r3,r3,r3
 822c230:	10c5883a 	add	r2,r2,r3
 822c234:	10800017 	ldw	r2,0(r2)
 822c238:	10c00d17 	ldw	r3,52(r2)
 822c23c:	008209b4 	movhi	r2,2086
 822c240:	10b84a04 	addi	r2,r2,-7896
 822c244:	e13fff17 	ldw	r4,-4(fp)
 822c248:	21000f24 	muli	r4,r4,60
 822c24c:	1105883a 	add	r2,r2,r4
 822c250:	10800b04 	addi	r2,r2,44
 822c254:	10c00015 	stw	r3,0(r2)

#ifdef IP_ROUTING
   /* If the DHCP Server is on other network, route the request
    * from the same DHCP relay agent. To do that, add a route.
    */
   if (dhc_states[iface].rly_ipaddr)
 822c258:	008209b4 	movhi	r2,2086
 822c25c:	10b84a04 	addi	r2,r2,-7896
 822c260:	e0ffff17 	ldw	r3,-4(fp)
 822c264:	18c00f24 	muli	r3,r3,60
 822c268:	10c5883a 	add	r2,r2,r3
 822c26c:	10800c04 	addi	r2,r2,48
 822c270:	10800017 	ldw	r2,0(r2)
 822c274:	10002026 	beq	r2,zero,822c2f8 <dhc_reclaim+0x198>
   {
      if (dhc_states[iface].srv_ipaddr)
 822c278:	008209b4 	movhi	r2,2086
 822c27c:	10b84a04 	addi	r2,r2,-7896
 822c280:	e0ffff17 	ldw	r3,-4(fp)
 822c284:	18c00f24 	muli	r3,r3,60
 822c288:	10c5883a 	add	r2,r2,r3
 822c28c:	10800d04 	addi	r2,r2,52
 822c290:	10800017 	ldw	r2,0(r2)
 822c294:	10001726 	beq	r2,zero,822c2f4 <dhc_reclaim+0x194>
      {
         /* yes, earlier negotiation was done via a relay agent */
         if ( !add_route(dhc_states[iface].srv_ipaddr, 0xFFFFFFFF,
 822c298:	008209b4 	movhi	r2,2086
 822c29c:	10b84a04 	addi	r2,r2,-7896
 822c2a0:	e0ffff17 	ldw	r3,-4(fp)
 822c2a4:	18c00f24 	muli	r3,r3,60
 822c2a8:	10c5883a 	add	r2,r2,r3
 822c2ac:	10800d04 	addi	r2,r2,52
 822c2b0:	11000017 	ldw	r4,0(r2)
 822c2b4:	008209b4 	movhi	r2,2086
 822c2b8:	10b84a04 	addi	r2,r2,-7896
 822c2bc:	e0ffff17 	ldw	r3,-4(fp)
 822c2c0:	18c00f24 	muli	r3,r3,60
 822c2c4:	10c5883a 	add	r2,r2,r3
 822c2c8:	10800c04 	addi	r2,r2,48
 822c2cc:	10c00017 	ldw	r3,0(r2)
 822c2d0:	00800084 	movi	r2,2
 822c2d4:	d8800015 	stw	r2,0(sp)
 822c2d8:	e1ffff17 	ldw	r7,-4(fp)
 822c2dc:	180d883a 	mov	r6,r3
 822c2e0:	017fffc4 	movi	r5,-1
 822c2e4:	82441800 	call	8244180 <add_route>
 822c2e8:	1000031e 	bne	r2,zero,822c2f8 <dhc_reclaim+0x198>
             dhc_states[iface].rly_ipaddr, iface, IPRP_LOCAL))
         {
            /* route was not added. check this case */
            dtrap(); 
 822c2ec:	822d4140 	call	822d414 <dtrap>
 822c2f0:	00000106 	br	822c2f8 <dhc_reclaim+0x198>
      else
      {
         /* DHCP relay IP address is set, but DHCP Server IP address is
          * not set ! How can this happen ?
          */
         dtrap();
 822c2f4:	822d4140 	call	822d414 <dtrap>
      }
   }
#endif  /* IP_ROUTING */

   /* send the request */
   return(dhc_request(iface,TRUE));  
 822c2f8:	01400044 	movi	r5,1
 822c2fc:	e13fff17 	ldw	r4,-4(fp)
 822c300:	822a9880 	call	822a988 <dhc_request>
}
 822c304:	e037883a 	mov	sp,fp
 822c308:	dfc00117 	ldw	ra,4(sp)
 822c30c:	df000017 	ldw	fp,0(sp)
 822c310:	dec00204 	addi	sp,sp,8
 822c314:	f800283a 	ret

0822c318 <dhc_state_init>:
 * RETURNS: void
 */

void 
dhc_state_init(int iface, int init_flag)
{
 822c318:	defffb04 	addi	sp,sp,-20
 822c31c:	dfc00415 	stw	ra,16(sp)
 822c320:	df000315 	stw	fp,12(sp)
 822c324:	df000304 	addi	fp,sp,12
 822c328:	e13ffe15 	stw	r4,-8(fp)
 822c32c:	e17fff15 	stw	r5,-4(fp)
   int state = (init_flag == TRUE) ? DHCS_INIT : DHCS_INITREBOOT;
 822c330:	e0bfff17 	ldw	r2,-4(fp)
 822c334:	10800058 	cmpnei	r2,r2,1
 822c338:	1000021e 	bne	r2,zero,822c344 <dhc_state_init+0x2c>
 822c33c:	00800044 	movi	r2,1
 822c340:	00000106 	br	822c348 <dhc_state_init+0x30>
 822c344:	00800084 	movi	r2,2
 822c348:	e0bffd15 	stw	r2,-12(fp)
   
   dhc_set_state(iface, state);
 822c34c:	e17ffd17 	ldw	r5,-12(fp)
 822c350:	e13ffe17 	ldw	r4,-8(fp)
 822c354:	822c4600 	call	822c460 <dhc_set_state>
}
 822c358:	0001883a 	nop
 822c35c:	e037883a 	mov	sp,fp
 822c360:	dfc00117 	ldw	ra,4(sp)
 822c364:	df000017 	ldw	fp,0(sp)
 822c368:	dec00204 	addi	sp,sp,8
 822c36c:	f800283a 	ret

0822c370 <dhc_alldone>:
 * otherwise. 
 */

int 
dhc_alldone(void)
{
 822c370:	defffe04 	addi	sp,sp,-8
 822c374:	df000115 	stw	fp,4(sp)
 822c378:	df000104 	addi	fp,sp,4
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 822c37c:	e03fff15 	stw	zero,-4(fp)
 822c380:	00001506 	br	822c3d8 <dhc_alldone+0x68>
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 822c384:	008209b4 	movhi	r2,2086
 822c388:	10b84a04 	addi	r2,r2,-7896
 822c38c:	e0ffff17 	ldw	r3,-4(fp)
 822c390:	18c00f24 	muli	r3,r3,60
 822c394:	10c5883a 	add	r2,r2,r3
 822c398:	10800017 	ldw	r2,0(r2)
 822c39c:	10000826 	beq	r2,zero,822c3c0 <dhc_alldone+0x50>
          ( dhc_states[i].state == DHCS_BOUND  )  )
 822c3a0:	008209b4 	movhi	r2,2086
 822c3a4:	10b84a04 	addi	r2,r2,-7896
 822c3a8:	e0ffff17 	ldw	r3,-4(fp)
 822c3ac:	18c00f24 	muli	r3,r3,60
 822c3b0:	10c5883a 	add	r2,r2,r3
 822c3b4:	10800017 	ldw	r2,0(r2)
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 822c3b8:	10800198 	cmpnei	r2,r2,6
 822c3bc:	1000041e 	bne	r2,zero,822c3d0 <dhc_alldone+0x60>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 822c3c0:	e0bfff17 	ldw	r2,-4(fp)
 822c3c4:	10800044 	addi	r2,r2,1
 822c3c8:	e0bfff15 	stw	r2,-4(fp)
 822c3cc:	00000206 	br	822c3d8 <dhc_alldone+0x68>
      {
         continue ;
      }
      else
      {
         return FALSE ;
 822c3d0:	0005883a 	mov	r2,zero
 822c3d4:	00000406 	br	822c3e8 <dhc_alldone+0x78>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 822c3d8:	e0bfff17 	ldw	r2,-4(fp)
 822c3dc:	10800110 	cmplti	r2,r2,4
 822c3e0:	103fe81e 	bne	r2,zero,822c384 <dhc_alldone+0x14>
      else
      {
         return FALSE ;
      }
   }
   return TRUE ;
 822c3e4:	00800044 	movi	r2,1
}
 822c3e8:	e037883a 	mov	sp,fp
 822c3ec:	df000017 	ldw	fp,0(sp)
 822c3f0:	dec00104 	addi	sp,sp,4
 822c3f4:	f800283a 	ret

0822c3f8 <dhc_ifacedone>:
 * RETURNS: 
 */

int 
dhc_ifacedone(int iface)
{
 822c3f8:	defffe04 	addi	sp,sp,-8
 822c3fc:	df000115 	stw	fp,4(sp)
 822c400:	df000104 	addi	fp,sp,4
 822c404:	e13fff15 	stw	r4,-4(fp)
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 822c408:	008209b4 	movhi	r2,2086
 822c40c:	10b84a04 	addi	r2,r2,-7896
 822c410:	e0ffff17 	ldw	r3,-4(fp)
 822c414:	18c00f24 	muli	r3,r3,60
 822c418:	10c5883a 	add	r2,r2,r3
 822c41c:	10800017 	ldw	r2,0(r2)
 822c420:	10000826 	beq	r2,zero,822c444 <dhc_ifacedone+0x4c>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
 822c424:	008209b4 	movhi	r2,2086
 822c428:	10b84a04 	addi	r2,r2,-7896
 822c42c:	e0ffff17 	ldw	r3,-4(fp)
 822c430:	18c00f24 	muli	r3,r3,60
 822c434:	10c5883a 	add	r2,r2,r3
 822c438:	10800017 	ldw	r2,0(r2)
 */

int 
dhc_ifacedone(int iface)
{
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 822c43c:	10800198 	cmpnei	r2,r2,6
 822c440:	1000021e 	bne	r2,zero,822c44c <dhc_ifacedone+0x54>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
   {
      return TRUE ;
 822c444:	00800044 	movi	r2,1
 822c448:	00000106 	br	822c450 <dhc_ifacedone+0x58>
   }
   else
   {
      return FALSE ;
 822c44c:	0005883a 	mov	r2,zero
   }
}
 822c450:	e037883a 	mov	sp,fp
 822c454:	df000017 	ldw	fp,0(sp)
 822c458:	dec00104 	addi	sp,sp,4
 822c45c:	f800283a 	ret

0822c460 <dhc_set_state>:
 *
 * RETURNS: 
 */

void dhc_set_state(int iface, int state)
{
 822c460:	defffc04 	addi	sp,sp,-16
 822c464:	dfc00315 	stw	ra,12(sp)
 822c468:	df000215 	stw	fp,8(sp)
 822c46c:	df000204 	addi	fp,sp,8
 822c470:	e13ffe15 	stw	r4,-8(fp)
 822c474:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].state = state; /* Set the new state */
 822c478:	e0ffff17 	ldw	r3,-4(fp)
 822c47c:	008209b4 	movhi	r2,2086
 822c480:	10b84a04 	addi	r2,r2,-7896
 822c484:	e13ffe17 	ldw	r4,-8(fp)
 822c488:	21000f24 	muli	r4,r4,60
 822c48c:	1105883a 	add	r2,r2,r4
 822c490:	10c00015 	stw	r3,0(r2)
   dhc_states[iface].tries = 0;     /* Reset the number of tries */
 822c494:	008209b4 	movhi	r2,2086
 822c498:	10b84a04 	addi	r2,r2,-7896
 822c49c:	e0fffe17 	ldw	r3,-8(fp)
 822c4a0:	18c00f24 	muli	r3,r3,60
 822c4a4:	10c5883a 	add	r2,r2,r3
 822c4a8:	10800104 	addi	r2,r2,4
 822c4ac:	10000015 	stw	zero,0(r2)

   /* If callback is set, call it */
   if (dhc_states[iface].callback)
 822c4b0:	008209b4 	movhi	r2,2086
 822c4b4:	10b84a04 	addi	r2,r2,-7896
 822c4b8:	e0fffe17 	ldw	r3,-8(fp)
 822c4bc:	18c00f24 	muli	r3,r3,60
 822c4c0:	10c5883a 	add	r2,r2,r3
 822c4c4:	10800e04 	addi	r2,r2,56
 822c4c8:	10800017 	ldw	r2,0(r2)
 822c4cc:	10000a26 	beq	r2,zero,822c4f8 <dhc_set_state+0x98>
      dhc_states[iface].callback(iface,state);
 822c4d0:	008209b4 	movhi	r2,2086
 822c4d4:	10b84a04 	addi	r2,r2,-7896
 822c4d8:	e0fffe17 	ldw	r3,-8(fp)
 822c4dc:	18c00f24 	muli	r3,r3,60
 822c4e0:	10c5883a 	add	r2,r2,r3
 822c4e4:	10800e04 	addi	r2,r2,56
 822c4e8:	10800017 	ldw	r2,0(r2)
 822c4ec:	e17fff17 	ldw	r5,-4(fp)
 822c4f0:	e13ffe17 	ldw	r4,-8(fp)
 822c4f4:	103ee83a 	callr	r2
}
 822c4f8:	0001883a 	nop
 822c4fc:	e037883a 	mov	sp,fp
 822c500:	dfc00117 	ldw	ra,4(sp)
 822c504:	df000017 	ldw	fp,0(sp)
 822c508:	dec00204 	addi	sp,sp,8
 822c50c:	f800283a 	ret

0822c510 <find_opt>:
 * RETURNS:  Return pointer to that code if found, NULL if not found.
 */

u_char * 
find_opt(u_char opcode, u_char * opts)
{
 822c510:	defffc04 	addi	sp,sp,-16
 822c514:	df000315 	stw	fp,12(sp)
 822c518:	df000304 	addi	fp,sp,12
 822c51c:	2005883a 	mov	r2,r4
 822c520:	e17fff15 	stw	r5,-4(fp)
 822c524:	e0bffe05 	stb	r2,-8(fp)
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */
 822c528:	e0bfff17 	ldw	r2,-4(fp)
 822c52c:	10804e04 	addi	r2,r2,312
 822c530:	e0bffd15 	stw	r2,-12(fp)

   while (opts < end)
 822c534:	00001e06 	br	822c5b0 <find_opt+0xa0>
   {
      if (*opts == opcode) /* found it */
 822c538:	e0bfff17 	ldw	r2,-4(fp)
 822c53c:	10800003 	ldbu	r2,0(r2)
 822c540:	10c03fcc 	andi	r3,r2,255
 822c544:	e0bffe03 	ldbu	r2,-8(fp)
 822c548:	1880021e 	bne	r3,r2,822c554 <find_opt+0x44>
         return opts;
 822c54c:	e0bfff17 	ldw	r2,-4(fp)
 822c550:	00001b06 	br	822c5c0 <find_opt+0xb0>
      if (*opts == DHOP_END)  /* end of options; opcode not found */
 822c554:	e0bfff17 	ldw	r2,-4(fp)
 822c558:	10800003 	ldbu	r2,0(r2)
 822c55c:	10803fcc 	andi	r2,r2,255
 822c560:	10803fd8 	cmpnei	r2,r2,255
 822c564:	1000021e 	bne	r2,zero,822c570 <find_opt+0x60>
         return NULL;
 822c568:	0005883a 	mov	r2,zero
 822c56c:	00001406 	br	822c5c0 <find_opt+0xb0>
      if (*opts == DHOP_PAD)  /* PAD has only 1 byte */
 822c570:	e0bfff17 	ldw	r2,-4(fp)
 822c574:	10800003 	ldbu	r2,0(r2)
 822c578:	10803fcc 	andi	r2,r2,255
 822c57c:	1000041e 	bne	r2,zero,822c590 <find_opt+0x80>
         opts++;
 822c580:	e0bfff17 	ldw	r2,-4(fp)
 822c584:	10800044 	addi	r2,r2,1
 822c588:	e0bfff15 	stw	r2,-4(fp)
 822c58c:	00000806 	br	822c5b0 <find_opt+0xa0>
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
 822c590:	e0bfff17 	ldw	r2,-4(fp)
 822c594:	10800044 	addi	r2,r2,1
 822c598:	10800003 	ldbu	r2,0(r2)
 822c59c:	10803fcc 	andi	r2,r2,255
 822c5a0:	10800084 	addi	r2,r2,2
 822c5a4:	e0ffff17 	ldw	r3,-4(fp)
 822c5a8:	1885883a 	add	r2,r3,r2
 822c5ac:	e0bfff15 	stw	r2,-4(fp)
u_char * 
find_opt(u_char opcode, u_char * opts)
{
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */

   while (opts < end)
 822c5b0:	e0ffff17 	ldw	r3,-4(fp)
 822c5b4:	e0bffd17 	ldw	r2,-12(fp)
 822c5b8:	18bfdf36 	bltu	r3,r2,822c538 <find_opt+0x28>
         opts++;
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
   }
   /* no DHOP_END option?? */
   return NULL;
 822c5bc:	0005883a 	mov	r2,zero
}
 822c5c0:	e037883a 	mov	sp,fp
 822c5c4:	df000017 	ldw	fp,0(sp)
 822c5c8:	dec00104 	addi	sp,sp,4
 822c5cc:	f800283a 	ret

0822c5d0 <pk_init>:
 * for a PACKET buffer or a data buffer fails, or if there is an inconsistency
 * between (bigbufs + lilbufs) and MAXPACKETS) it returns -1. 
 */

int pk_init (void)
{
 822c5d0:	defff804 	addi	sp,sp,-32
 822c5d4:	dfc00715 	stw	ra,28(sp)
 822c5d8:	df000615 	stw	fp,24(sp)
 822c5dc:	df000604 	addi	fp,sp,24
   PACKET packet;
   unsigned i;
   unsigned numpkts = bigbufs + lilbufs;
 822c5e0:	d0e03817 	ldw	r3,-32544(gp)
 822c5e4:	d0a03617 	ldw	r2,-32552(gp)
 822c5e8:	1885883a 	add	r2,r3,r2
 822c5ec:	e0bffd15 	stw	r2,-12(fp)
   u_char align_req;
   
#ifdef ALIGN_BUFS
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
 822c5f0:	e03ffe05 	stb	zero,-8(fp)
#endif

   for (i = 0; i < numpkts; i++)
 822c5f4:	e03ffa15 	stw	zero,-24(fp)
 822c5f8:	00007a06 	br	822c7e4 <pk_init+0x214>
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
 822c5fc:	01000d04 	movi	r4,52
 822c600:	822dfec0 	call	822dfec <npalloc>
 822c604:	e0bfff15 	stw	r2,-4(fp)
      if (packet == NULL)
 822c608:	e0bfff17 	ldw	r2,-4(fp)
 822c60c:	10008426 	beq	r2,zero,822c820 <pk_init+0x250>
         goto no_pkt_buf;

#ifdef NPDEBUG
      if (i >= MAXPACKETS)
 822c610:	e0bffa17 	ldw	r2,-24(fp)
 822c614:	10800f30 	cmpltui	r2,r2,60
 822c618:	1000051e 	bne	r2,zero,822c630 <pk_init+0x60>
      {
         dprintf("pk_init: bad define\n");
 822c61c:	01020974 	movhi	r4,2085
 822c620:	21022404 	addi	r4,r4,2192
 822c624:	82035a00 	call	82035a0 <puts>
         return -1;
 822c628:	00bfffc4 	movi	r2,-1
 822c62c:	00008a06 	br	822c858 <pk_init+0x288>
      }
      pktlog[i] = packet;     /* save for debugging */
 822c630:	008209b4 	movhi	r2,2086
 822c634:	10b88f04 	addi	r2,r2,-7620
 822c638:	e0fffa17 	ldw	r3,-24(fp)
 822c63c:	18c7883a 	add	r3,r3,r3
 822c640:	18c7883a 	add	r3,r3,r3
 822c644:	10c5883a 	add	r2,r2,r3
 822c648:	e0ffff17 	ldw	r3,-4(fp)
 822c64c:	10c00015 	stw	r3,0(r2)
#endif

      packet->nb_tstamp = 0L;
 822c650:	e0bfff17 	ldw	r2,-4(fp)
 822c654:	10000515 	stw	zero,20(r2)

      if (i < bigbufs)
 822c658:	d0a03817 	ldw	r2,-32544(gp)
 822c65c:	e0fffa17 	ldw	r3,-24(fp)
 822c660:	18802f2e 	bgeu	r3,r2,822c720 <pk_init+0x150>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
 822c664:	d0a03917 	ldw	r2,-32540(gp)
 822c668:	10800144 	addi	r2,r2,5
 822c66c:	1009883a 	mov	r4,r2
 822c670:	822e0600 	call	822e060 <ncpalloc>
 822c674:	1007883a 	mov	r3,r2
 822c678:	e0bfff17 	ldw	r2,-4(fp)
 822c67c:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 822c680:	e0bfff17 	ldw	r2,-4(fp)
 822c684:	10800117 	ldw	r2,4(r2)
 822c688:	10006726 	beq	r2,zero,822c828 <pk_init+0x258>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c68c:	e03ffb15 	stw	zero,-20(fp)
 822c690:	00000906 	br	822c6b8 <pk_init+0xe8>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 822c694:	e0bfff17 	ldw	r2,-4(fp)
 822c698:	10c00117 	ldw	r3,4(r2)
 822c69c:	e0bffb17 	ldw	r2,-20(fp)
 822c6a0:	1885883a 	add	r2,r3,r2
 822c6a4:	00c01344 	movi	r3,77
 822c6a8:	10c00005 	stb	r3,0(r2)
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c6ac:	e0bffb17 	ldw	r2,-20(fp)
 822c6b0:	10800044 	addi	r2,r2,1
 822c6b4:	e0bffb15 	stw	r2,-20(fp)
 822c6b8:	e0bffb17 	ldw	r2,-20(fp)
 822c6bc:	10800110 	cmplti	r2,r2,4
 822c6c0:	103ff41e 	bne	r2,zero,822c694 <pk_init+0xc4>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + bigbufsiz + ALIGN_TYPE) = 'M';
 822c6c4:	e0bfff17 	ldw	r2,-4(fp)
 822c6c8:	10c00117 	ldw	r3,4(r2)
 822c6cc:	d0a03917 	ldw	r2,-32540(gp)
 822c6d0:	10800104 	addi	r2,r2,4
 822c6d4:	1885883a 	add	r2,r3,r2
 822c6d8:	00c01344 	movi	r3,77
 822c6dc:	10c00005 	stb	r3,0(r2)
            packet->nb_buff += ALIGN_TYPE;   /* bump buf past MMs */
 822c6e0:	e0bfff17 	ldw	r2,-4(fp)
 822c6e4:	10800117 	ldw	r2,4(r2)
 822c6e8:	10c00104 	addi	r3,r2,4
 822c6ec:	e0bfff17 	ldw	r2,-4(fp)
 822c6f0:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 822c6f4:	e0bfff17 	ldw	r2,-4(fp)
 822c6f8:	10800117 	ldw	r2,4(r2)
 822c6fc:	10004c26 	beq	r2,zero,822c830 <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = bigbufsiz;
 822c700:	d0e03917 	ldw	r3,-32540(gp)
 822c704:	e0bfff17 	ldw	r2,-4(fp)
 822c708:	10c00215 	stw	r3,8(r2)
         q_add(&bigfreeq, packet);        /* save it in big pkt free queue */
 822c70c:	e17fff17 	ldw	r5,-4(fp)
 822c710:	010209b4 	movhi	r4,2086
 822c714:	2138cb04 	addi	r4,r4,-7380
 822c718:	822cdfc0 	call	822cdfc <putq>
 822c71c:	00002e06 	br	822c7d8 <pk_init+0x208>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
 822c720:	d0a03717 	ldw	r2,-32548(gp)
 822c724:	10800144 	addi	r2,r2,5
 822c728:	1009883a 	mov	r4,r2
 822c72c:	822e0600 	call	822e060 <ncpalloc>
 822c730:	1007883a 	mov	r3,r2
 822c734:	e0bfff17 	ldw	r2,-4(fp)
 822c738:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 822c73c:	e0bfff17 	ldw	r2,-4(fp)
 822c740:	10800117 	ldw	r2,4(r2)
 822c744:	10003c26 	beq	r2,zero,822c838 <pk_init+0x268>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c748:	e03ffc15 	stw	zero,-16(fp)
 822c74c:	00000906 	br	822c774 <pk_init+0x1a4>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 822c750:	e0bfff17 	ldw	r2,-4(fp)
 822c754:	10c00117 	ldw	r3,4(r2)
 822c758:	e0bffc17 	ldw	r2,-16(fp)
 822c75c:	1885883a 	add	r2,r3,r2
 822c760:	00c01344 	movi	r3,77
 822c764:	10c00005 	stb	r3,0(r2)
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 822c768:	e0bffc17 	ldw	r2,-16(fp)
 822c76c:	10800044 	addi	r2,r2,1
 822c770:	e0bffc15 	stw	r2,-16(fp)
 822c774:	e0bffc17 	ldw	r2,-16(fp)
 822c778:	10800110 	cmplti	r2,r2,4
 822c77c:	103ff41e 	bne	r2,zero,822c750 <pk_init+0x180>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + lilbufsiz + ALIGN_TYPE) = 'M';
 822c780:	e0bfff17 	ldw	r2,-4(fp)
 822c784:	10c00117 	ldw	r3,4(r2)
 822c788:	d0a03717 	ldw	r2,-32548(gp)
 822c78c:	10800104 	addi	r2,r2,4
 822c790:	1885883a 	add	r2,r3,r2
 822c794:	00c01344 	movi	r3,77
 822c798:	10c00005 	stb	r3,0(r2)
            packet->nb_buff += ALIGN_TYPE;
 822c79c:	e0bfff17 	ldw	r2,-4(fp)
 822c7a0:	10800117 	ldw	r2,4(r2)
 822c7a4:	10c00104 	addi	r3,r2,4
 822c7a8:	e0bfff17 	ldw	r2,-4(fp)
 822c7ac:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 822c7b0:	e0bfff17 	ldw	r2,-4(fp)
 822c7b4:	10800117 	ldw	r2,4(r2)
 822c7b8:	10002126 	beq	r2,zero,822c840 <pk_init+0x270>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
 822c7bc:	d0e03717 	ldw	r3,-32548(gp)
 822c7c0:	e0bfff17 	ldw	r2,-4(fp)
 822c7c4:	10c00215 	stw	r3,8(r2)
         q_add(&lilfreeq, packet);        /* save it in little free queue */
 822c7c8:	e17fff17 	ldw	r5,-4(fp)
 822c7cc:	010209b4 	movhi	r4,2086
 822c7d0:	21388604 	addi	r4,r4,-7656
 822c7d4:	822cdfc0 	call	822cdfc <putq>
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
#endif

   for (i = 0; i < numpkts; i++)
 822c7d8:	e0bffa17 	ldw	r2,-24(fp)
 822c7dc:	10800044 	addi	r2,r2,1
 822c7e0:	e0bffa15 	stw	r2,-24(fp)
 822c7e4:	e0fffa17 	ldw	r3,-24(fp)
 822c7e8:	e0bffd17 	ldw	r2,-12(fp)
 822c7ec:	18bf8336 	bltu	r3,r2,822c5fc <pk_init+0x2c>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
         q_add(&lilfreeq, packet);        /* save it in little free queue */
      }
   }
   bigfreeq.q_min = bigbufs;
 822c7f0:	d0a03817 	ldw	r2,-32544(gp)
 822c7f4:	1007883a 	mov	r3,r2
 822c7f8:	008209b4 	movhi	r2,2086
 822c7fc:	10b8cb04 	addi	r2,r2,-7380
 822c800:	10c00415 	stw	r3,16(r2)
   lilfreeq.q_min = lilbufs;
 822c804:	d0a03617 	ldw	r2,-32552(gp)
 822c808:	1007883a 	mov	r3,r2
 822c80c:	008209b4 	movhi	r2,2086
 822c810:	10b88604 	addi	r2,r2,-7656
 822c814:	10c00415 	stw	r3,16(r2)
   heap_curr_mem_hi_watermark = 0;
   /* set the heap's access type to blocking */
   heap_type = HEAP_ACCESS_BLOCKING;
#endif

   return 0;
 822c818:	0005883a 	mov	r2,zero
 822c81c:	00000e06 	br	822c858 <pk_init+0x288>

   for (i = 0; i < numpkts; i++)
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
      if (packet == NULL)
         goto no_pkt_buf;
 822c820:	0001883a 	nop
 822c824:	00000706 	br	822c844 <pk_init+0x274>
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;
 822c828:	0001883a 	nop
 822c82c:	00000506 	br	822c844 <pk_init+0x274>
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
            goto no_pkt_buf;
 822c830:	0001883a 	nop
 822c834:	00000306 	br	822c844 <pk_init+0x274>
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;
 822c838:	0001883a 	nop
 822c83c:	00000106 	br	822c844 <pk_init+0x274>
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
            goto no_pkt_buf;
 822c840:	0001883a 	nop

   return 0;

no_pkt_buf:
#ifdef NPDEBUG
   dprintf("Netinit: calloc failed getting buffer %d\n", i);
 822c844:	e17ffa17 	ldw	r5,-24(fp)
 822c848:	01020974 	movhi	r4,2085
 822c84c:	21022904 	addi	r4,r4,2212
 822c850:	820331c0 	call	820331c <printf>
#endif
   return(-1);
 822c854:	00bfffc4 	movi	r2,-1
}
 822c858:	e037883a 	mov	sp,fp
 822c85c:	dfc00117 	ldw	ra,4(sp)
 822c860:	df000017 	ldw	fp,0(sp)
 822c864:	dec00204 	addi	sp,sp,8
 822c868:	f800283a 	ret

0822c86c <pk_alloc>:
 * OUTPUT: 0 if the request cannot be satisfied, or a pointer to the struct
 * netbuf structure that corresponds to the just allocated data buffer.
 */

PACKET pk_alloc(unsigned len)
{
 822c86c:	defffc04 	addi	sp,sp,-16
 822c870:	dfc00315 	stw	ra,12(sp)
 822c874:	df000215 	stw	fp,8(sp)
 822c878:	df000204 	addi	fp,sp,8
 822c87c:	e13fff15 	stw	r4,-4(fp)
   PACKET p;

   if (len > bigbufsiz) /* caller wants oversize buffer? */
 822c880:	d0e03917 	ldw	r3,-32540(gp)
 822c884:	e0bfff17 	ldw	r2,-4(fp)
 822c888:	1880022e 	bgeu	r3,r2,822c894 <pk_alloc+0x28>
   {
#ifdef HEAPBUFS
      if ((p = pk_alloc_heapbuf (len)) == NULL)
         return NULL;
#else
      return(NULL);
 822c88c:	0005883a 	mov	r2,zero
 822c890:	00002206 	br	822c91c <pk_alloc+0xb0>
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 822c894:	d0e03717 	ldw	r3,-32548(gp)
 822c898:	e0bfff17 	ldw	r2,-4(fp)
 822c89c:	18800436 	bltu	r3,r2,822c8b0 <pk_alloc+0x44>
 822c8a0:	008209b4 	movhi	r2,2086
 822c8a4:	10b88604 	addi	r2,r2,-7656
 822c8a8:	10800217 	ldw	r2,8(r2)
 822c8ac:	1000051e 	bne	r2,zero,822c8c4 <pk_alloc+0x58>
         p = (PACKET)getq(&bigfreeq);
 822c8b0:	010209b4 	movhi	r4,2086
 822c8b4:	2138cb04 	addi	r4,r4,-7380
 822c8b8:	822cd440 	call	822cd44 <getq>
 822c8bc:	e0bffe15 	stw	r2,-8(fp)
 822c8c0:	00000406 	br	822c8d4 <pk_alloc+0x68>
      else
         p = (PACKET)getq(&lilfreeq);
 822c8c4:	010209b4 	movhi	r4,2086
 822c8c8:	21388604 	addi	r4,r4,-7656
 822c8cc:	822cd440 	call	822cd44 <getq>
 822c8d0:	e0bffe15 	stw	r2,-8(fp)

      if (!p)
 822c8d4:	e0bffe17 	ldw	r2,-8(fp)
 822c8d8:	1000021e 	bne	r2,zero,822c8e4 <pk_alloc+0x78>
         return NULL;
 822c8dc:	0005883a 	mov	r2,zero
 822c8e0:	00000e06 	br	822c91c <pk_alloc+0xb0>
   }

   p->nb_prot = p->nb_buff + MaxLnh;   /* point past biggest mac header */
 822c8e4:	e0bffe17 	ldw	r2,-8(fp)
 822c8e8:	10800117 	ldw	r2,4(r2)
 822c8ec:	d0e08117 	ldw	r3,-32252(gp)
 822c8f0:	10c7883a 	add	r3,r2,r3
 822c8f4:	e0bffe17 	ldw	r2,-8(fp)
 822c8f8:	10c00315 	stw	r3,12(r2)
   p->nb_plen = 0;   /* no protocol data there yet */
 822c8fc:	e0bffe17 	ldw	r2,-8(fp)
 822c900:	10000415 	stw	zero,16(r2)
   p->net = NULL;
 822c904:	e0bffe17 	ldw	r2,-8(fp)
 822c908:	10000615 	stw	zero,24(r2)
   p->nexthop = NULL;      /* no next hop  */
   p->nb_pmtu = 1240;      /* Set minimum IPv6 Path MTU */
#endif   /* IP_V6 */
#endif /* LINKED_PKTS */

   p->inuse = 1;  /* initially buffer in use by 1 user */
 822c90c:	e0bffe17 	ldw	r2,-8(fp)
 822c910:	00c00044 	movi	r3,1
 822c914:	10c00915 	stw	r3,36(r2)

   /* note that 'type' and 'fhost' fields are not set in pk_alloc () */
   return(p);
 822c918:	e0bffe17 	ldw	r2,-8(fp)
}
 822c91c:	e037883a 	mov	sp,fp
 822c920:	dfc00117 	ldw	ra,4(sp)
 822c924:	df000017 	ldw	fp,0(sp)
 822c928:	dec00204 	addi	sp,sp,8
 822c92c:	f800283a 	ret

0822c930 <pk_validate>:
 * OUTPUT: 0 if the buffer being freed was successfully validated, or
 * -1 if the validation failed.
 */

int pk_validate(PACKET pkt)   /* check if pk_free() can free the pkt */
{
 822c930:	defffb04 	addi	sp,sp,-20
 822c934:	dfc00415 	stw	ra,16(sp)
 822c938:	df000315 	stw	fp,12(sp)
 822c93c:	df000304 	addi	fp,sp,12
 822c940:	e13fff15 	stw	r4,-4(fp)
   /* If packet link is non-zero, then this packet is
    * part of a chain and deleted this packet would break
    * the chain and cause memory leak for subsequent pkts.
    * Note that heapbufs do not use the 'next' field at all.
    */
   if ((pkt->next) && (pkt->inuse >= 1))
 822c944:	e0bfff17 	ldw	r2,-4(fp)
 822c948:	10800017 	ldw	r2,0(r2)
 822c94c:	10000e26 	beq	r2,zero,822c988 <pk_validate+0x58>
 822c950:	e0bfff17 	ldw	r2,-4(fp)
 822c954:	10800917 	ldw	r2,36(r2)
 822c958:	10000b26 	beq	r2,zero,822c988 <pk_validate+0x58>
   {
      INCR_SHARED_VAR (memestats, INCONSISTENT_LOCATION_ERR, 1);   
 822c95c:	822d5ec0 	call	822d5ec <irq_Mask>
 822c960:	008209b4 	movhi	r2,2086
 822c964:	10b88b04 	addi	r2,r2,-7636
 822c968:	10800317 	ldw	r2,12(r2)
 822c96c:	10c00044 	addi	r3,r2,1
 822c970:	008209b4 	movhi	r2,2086
 822c974:	10b88b04 	addi	r2,r2,-7636
 822c978:	10c00315 	stw	r3,12(r2)
 822c97c:	822d64c0 	call	822d64c <irq_Unmask>
      return -1;
 822c980:	00bfffc4 	movi	r2,-1
 822c984:	00008806 	br	822cba8 <pk_validate+0x278>
   }
   else  
#endif /* HEAPBUFS */
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
 822c988:	e0bfff17 	ldw	r2,-4(fp)
 822c98c:	10c00217 	ldw	r3,8(r2)
 822c990:	d0a03917 	ldw	r2,-32540(gp)
 822c994:	1880201e 	bne	r3,r2,822ca18 <pk_validate+0xe8>
      {
         ENTER_CRIT_SECTION(&bigfreeq);
 822c998:	822d5ec0 	call	822d5ec <irq_Mask>
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 822c99c:	008209b4 	movhi	r2,2086
 822c9a0:	10b8cb04 	addi	r2,r2,-7380
 822c9a4:	10800017 	ldw	r2,0(r2)
 822c9a8:	e0bffd15 	stw	r2,-12(fp)
 822c9ac:	00001606 	br	822ca08 <pk_validate+0xd8>
            if (p == pkt)
 822c9b0:	e0fffd17 	ldw	r3,-12(fp)
 822c9b4:	e0bfff17 	ldw	r2,-4(fp)
 822c9b8:	1880101e 	bne	r3,r2,822c9fc <pk_validate+0xcc>
            {
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
 822c9bc:	e17fff17 	ldw	r5,-4(fp)
 822c9c0:	01020974 	movhi	r4,2085
 822c9c4:	21023404 	addi	r4,r4,2256
 822c9c8:	820331c0 	call	820331c <printf>
               EXIT_CRIT_SECTION(&bigfreeq);
 822c9cc:	822d64c0 	call	822d64c <irq_Unmask>
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 822c9d0:	822d5ec0 	call	822d5ec <irq_Mask>
 822c9d4:	008209b4 	movhi	r2,2086
 822c9d8:	10b88b04 	addi	r2,r2,-7636
 822c9dc:	10800217 	ldw	r2,8(r2)
 822c9e0:	10c00044 	addi	r3,r2,1
 822c9e4:	008209b4 	movhi	r2,2086
 822c9e8:	10b88b04 	addi	r2,r2,-7636
 822c9ec:	10c00215 	stw	r3,8(r2)
 822c9f0:	822d64c0 	call	822d64c <irq_Unmask>
               return -1;
 822c9f4:	00bfffc4 	movi	r2,-1
 822c9f8:	00006b06 	br	822cba8 <pk_validate+0x278>
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
      {
         ENTER_CRIT_SECTION(&bigfreeq);
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 822c9fc:	e0bffd17 	ldw	r2,-12(fp)
 822ca00:	10800017 	ldw	r2,0(r2)
 822ca04:	e0bffd15 	stw	r2,-12(fp)
 822ca08:	e0bffd17 	ldw	r2,-12(fp)
 822ca0c:	103fe81e 	bne	r2,zero,822c9b0 <pk_validate+0x80>
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
               EXIT_CRIT_SECTION(&bigfreeq);
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
               return -1;
            }
         EXIT_CRIT_SECTION(&bigfreeq);
 822ca10:	822d64c0 	call	822d64c <irq_Unmask>
 822ca14:	00002f06 	br	822cad4 <pk_validate+0x1a4>
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
 822ca18:	e0bfff17 	ldw	r2,-4(fp)
 822ca1c:	10c00217 	ldw	r3,8(r2)
 822ca20:	d0a03717 	ldw	r2,-32548(gp)
 822ca24:	1880201e 	bne	r3,r2,822caa8 <pk_validate+0x178>
      {
         ENTER_CRIT_SECTION(&lilfreeq);
 822ca28:	822d5ec0 	call	822d5ec <irq_Mask>
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 822ca2c:	008209b4 	movhi	r2,2086
 822ca30:	10b88604 	addi	r2,r2,-7656
 822ca34:	10800017 	ldw	r2,0(r2)
 822ca38:	e0bffd15 	stw	r2,-12(fp)
 822ca3c:	00001606 	br	822ca98 <pk_validate+0x168>
            if (p == pkt)
 822ca40:	e0fffd17 	ldw	r3,-12(fp)
 822ca44:	e0bfff17 	ldw	r2,-4(fp)
 822ca48:	1880101e 	bne	r3,r2,822ca8c <pk_validate+0x15c>
         {
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
 822ca4c:	e17fff17 	ldw	r5,-4(fp)
 822ca50:	01020974 	movhi	r4,2085
 822ca54:	21023e04 	addi	r4,r4,2296
 822ca58:	820331c0 	call	820331c <printf>
            EXIT_CRIT_SECTION(&lilfreeq);
 822ca5c:	822d64c0 	call	822d64c <irq_Unmask>
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 822ca60:	822d5ec0 	call	822d5ec <irq_Mask>
 822ca64:	008209b4 	movhi	r2,2086
 822ca68:	10b88b04 	addi	r2,r2,-7636
 822ca6c:	10800217 	ldw	r2,8(r2)
 822ca70:	10c00044 	addi	r3,r2,1
 822ca74:	008209b4 	movhi	r2,2086
 822ca78:	10b88b04 	addi	r2,r2,-7636
 822ca7c:	10c00215 	stw	r3,8(r2)
 822ca80:	822d64c0 	call	822d64c <irq_Unmask>
            return -1;
 822ca84:	00bfffc4 	movi	r2,-1
 822ca88:	00004706 	br	822cba8 <pk_validate+0x278>
         EXIT_CRIT_SECTION(&bigfreeq);
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
      {
         ENTER_CRIT_SECTION(&lilfreeq);
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 822ca8c:	e0bffd17 	ldw	r2,-12(fp)
 822ca90:	10800017 	ldw	r2,0(r2)
 822ca94:	e0bffd15 	stw	r2,-12(fp)
 822ca98:	e0bffd17 	ldw	r2,-12(fp)
 822ca9c:	103fe81e 	bne	r2,zero,822ca40 <pk_validate+0x110>
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
            EXIT_CRIT_SECTION(&lilfreeq);
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
            return -1;
         }
         EXIT_CRIT_SECTION(&lilfreeq);
 822caa0:	822d64c0 	call	822d64c <irq_Unmask>
 822caa4:	00000b06 	br	822cad4 <pk_validate+0x1a4>
      }
      else
      {
         /* log an error */
         INCR_SHARED_VAR (memestats, BAD_REGULAR_BUF_LEN_ERR, 1);
 822caa8:	822d5ec0 	call	822d5ec <irq_Mask>
 822caac:	008209b4 	movhi	r2,2086
 822cab0:	10b88b04 	addi	r2,r2,-7636
 822cab4:	10800017 	ldw	r2,0(r2)
 822cab8:	10c00044 	addi	r3,r2,1
 822cabc:	008209b4 	movhi	r2,2086
 822cac0:	10b88b04 	addi	r2,r2,-7636
 822cac4:	10c00015 	stw	r3,0(r2)
 822cac8:	822d64c0 	call	822d64c <irq_Unmask>
         return -1;
 822cacc:	00bfffc4 	movi	r2,-1
 822cad0:	00003506 	br	822cba8 <pk_validate+0x278>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 822cad4:	00800104 	movi	r2,4
 822cad8:	e0bffe15 	stw	r2,-8(fp)
 822cadc:	00001906 	br	822cb44 <pk_validate+0x214>
   {
      if (*(pkt->nb_buff - j) != 'M')
 822cae0:	e0bfff17 	ldw	r2,-4(fp)
 822cae4:	10c00117 	ldw	r3,4(r2)
 822cae8:	e0bffe17 	ldw	r2,-8(fp)
 822caec:	0085c83a 	sub	r2,zero,r2
 822caf0:	1885883a 	add	r2,r3,r2
 822caf4:	10800003 	ldbu	r2,0(r2)
 822caf8:	10803fcc 	andi	r2,r2,255
 822cafc:	1080201c 	xori	r2,r2,128
 822cb00:	10bfe004 	addi	r2,r2,-128
 822cb04:	10801360 	cmpeqi	r2,r2,77
 822cb08:	10000b1e 	bne	r2,zero,822cb38 <pk_validate+0x208>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 822cb0c:	822d5ec0 	call	822d5ec <irq_Mask>
 822cb10:	008209b4 	movhi	r2,2086
 822cb14:	10b88b04 	addi	r2,r2,-7636
 822cb18:	10800117 	ldw	r2,4(r2)
 822cb1c:	10c00044 	addi	r3,r2,1
 822cb20:	008209b4 	movhi	r2,2086
 822cb24:	10b88b04 	addi	r2,r2,-7636
 822cb28:	10c00115 	stw	r3,4(r2)
 822cb2c:	822d64c0 	call	822d64c <irq_Unmask>
         return -1;
 822cb30:	00bfffc4 	movi	r2,-1
 822cb34:	00001c06 	br	822cba8 <pk_validate+0x278>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 822cb38:	e0bffe17 	ldw	r2,-8(fp)
 822cb3c:	10bfffc4 	addi	r2,r2,-1
 822cb40:	e0bffe15 	stw	r2,-8(fp)
 822cb44:	e0bffe17 	ldw	r2,-8(fp)
 822cb48:	00bfe516 	blt	zero,r2,822cae0 <pk_validate+0x1b0>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
         return -1;
      }
   }
   if (*(pkt->nb_buff + pkt->nb_blen) != 'M')
 822cb4c:	e0bfff17 	ldw	r2,-4(fp)
 822cb50:	10c00117 	ldw	r3,4(r2)
 822cb54:	e0bfff17 	ldw	r2,-4(fp)
 822cb58:	10800217 	ldw	r2,8(r2)
 822cb5c:	1885883a 	add	r2,r3,r2
 822cb60:	10800003 	ldbu	r2,0(r2)
 822cb64:	10803fcc 	andi	r2,r2,255
 822cb68:	1080201c 	xori	r2,r2,128
 822cb6c:	10bfe004 	addi	r2,r2,-128
 822cb70:	10801360 	cmpeqi	r2,r2,77
 822cb74:	10000b1e 	bne	r2,zero,822cba4 <pk_validate+0x274>
   {
      INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 822cb78:	822d5ec0 	call	822d5ec <irq_Mask>
 822cb7c:	008209b4 	movhi	r2,2086
 822cb80:	10b88b04 	addi	r2,r2,-7636
 822cb84:	10800117 	ldw	r2,4(r2)
 822cb88:	10c00044 	addi	r3,r2,1
 822cb8c:	008209b4 	movhi	r2,2086
 822cb90:	10b88b04 	addi	r2,r2,-7636
 822cb94:	10c00115 	stw	r3,4(r2)
 822cb98:	822d64c0 	call	822d64c <irq_Unmask>
      return -1;
 822cb9c:	00bfffc4 	movi	r2,-1
 822cba0:	00000106 	br	822cba8 <pk_validate+0x278>
   }
#endif /* NPDEBUG */

   return 0;
 822cba4:	0005883a 	mov	r2,zero
}
 822cba8:	e037883a 	mov	sp,fp
 822cbac:	dfc00117 	ldw	ra,4(sp)
 822cbb0:	df000017 	ldw	fp,0(sp)
 822cbb4:	dec00204 	addi	sp,sp,8
 822cbb8:	f800283a 	ret

0822cbbc <pk_free>:
 *
 * OUTPUT: None.
 */

void pk_free(PACKET pkt)   /* PACKET to place in free queue */
{
 822cbbc:	defffc04 	addi	sp,sp,-16
 822cbc0:	dfc00315 	stw	ra,12(sp)
 822cbc4:	df000215 	stw	fp,8(sp)
 822cbc8:	df000204 	addi	fp,sp,8
 822cbcc:	e13fff15 	stw	r4,-4(fp)
      PACKET pknext;
      pknext = pkt->pk_next;
#endif /* LINKED_PKTS */

      /* validate the pkt before freeing */
      e = pk_validate(pkt);
 822cbd0:	e13fff17 	ldw	r4,-4(fp)
 822cbd4:	822c9300 	call	822c930 <pk_validate>
 822cbd8:	e0bffe15 	stw	r2,-8(fp)
      if (e)
 822cbdc:	e0bffe17 	ldw	r2,-8(fp)
 822cbe0:	1000191e 	bne	r2,zero,822cc48 <pk_free+0x8c>
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
 822cbe4:	e0bfff17 	ldw	r2,-4(fp)
 822cbe8:	10800917 	ldw	r2,36(r2)
 822cbec:	113fffc4 	addi	r4,r2,-1
 822cbf0:	e0ffff17 	ldw	r3,-4(fp)
 822cbf4:	19000915 	stw	r4,36(r3)
 822cbf8:	108000b0 	cmpltui	r2,r2,2
 822cbfc:	10001426 	beq	r2,zero,822cc50 <pk_free+0x94>
         pk_free_heapbuf (pkt);
      }
      else 
#endif /* HEAPBUFS */
      {
         if (pkt->nb_blen == bigbufsiz)
 822cc00:	e0bfff17 	ldw	r2,-4(fp)
 822cc04:	10c00217 	ldw	r3,8(r2)
 822cc08:	d0a03917 	ldw	r2,-32540(gp)
 822cc0c:	1880051e 	bne	r3,r2,822cc24 <pk_free+0x68>
            q_add(&bigfreeq, (qp)pkt);
 822cc10:	e17fff17 	ldw	r5,-4(fp)
 822cc14:	010209b4 	movhi	r4,2086
 822cc18:	2138cb04 	addi	r4,r4,-7380
 822cc1c:	822cdfc0 	call	822cdfc <putq>
 822cc20:	00000c06 	br	822cc54 <pk_free+0x98>
         else if (pkt->nb_blen == lilbufsiz)
 822cc24:	e0bfff17 	ldw	r2,-4(fp)
 822cc28:	10c00217 	ldw	r3,8(r2)
 822cc2c:	d0a03717 	ldw	r2,-32548(gp)
 822cc30:	1880081e 	bne	r3,r2,822cc54 <pk_free+0x98>
            q_add(&lilfreeq, (qp)pkt);
 822cc34:	e17fff17 	ldw	r5,-4(fp)
 822cc38:	010209b4 	movhi	r4,2086
 822cc3c:	21388604 	addi	r4,r4,-7656
 822cc40:	822cdfc0 	call	822cdfc <putq>
 822cc44:	00000306 	br	822cc54 <pk_free+0x98>
         {
            pkt = pknext;
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
 822cc48:	0001883a 	nop
 822cc4c:	00000106 	br	822cc54 <pk_free+0x98>
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
         return;  /* packet was cloned, don't delete yet */
 822cc50:	0001883a 	nop
#ifdef LINKED_PKTS
      pkt = pknext;
   }
#endif 

}
 822cc54:	e037883a 	mov	sp,fp
 822cc58:	dfc00117 	ldw	ra,4(sp)
 822cc5c:	df000017 	ldw	fp,0(sp)
 822cc60:	dec00204 	addi	sp,sp,8
 822cc64:	f800283a 	ret

0822cc68 <pk_get_max_intrsafe_buf_len>:
 *
 * OUTPUT: This function always returns the length of a big buffer (bigbufsiz).
 */

unsigned pk_get_max_intrsafe_buf_len(void)
{
 822cc68:	deffff04 	addi	sp,sp,-4
 822cc6c:	df000015 	stw	fp,0(sp)
 822cc70:	d839883a 	mov	fp,sp
   return bigbufsiz;
 822cc74:	d0a03917 	ldw	r2,-32540(gp)
}
 822cc78:	e037883a 	mov	sp,fp
 822cc7c:	df000017 	ldw	fp,0(sp)
 822cc80:	dec00104 	addi	sp,sp,4
 822cc84:	f800283a 	ret

0822cc88 <dump_buf_estats>:
 *
 * OUTPUT: This function always returns 0.
 */

int dump_buf_estats (void * pio)
{
 822cc88:	defff904 	addi	sp,sp,-28
 822cc8c:	dfc00615 	stw	ra,24(sp)
 822cc90:	df000515 	stw	fp,20(sp)
 822cc94:	df000504 	addi	fp,sp,20
 822cc98:	e13fff15 	stw	r4,-4(fp)
   u_long mlocal [MEMERR_NUM_STATS];

   LOCK_NET_RESOURCE(FREEQ_RESID);
 822cc9c:	01000084 	movi	r4,2
 822cca0:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   ENTER_CRIT_SECTION(&memestats);
 822cca4:	822d5ec0 	call	822d5ec <irq_Mask>
   MEMCPY (&mlocal, &memestats, sizeof(memestats));
 822cca8:	008209b4 	movhi	r2,2086
 822ccac:	10b88b04 	addi	r2,r2,-7636
 822ccb0:	10c00017 	ldw	r3,0(r2)
 822ccb4:	e0fffb15 	stw	r3,-20(fp)
 822ccb8:	10c00117 	ldw	r3,4(r2)
 822ccbc:	e0fffc15 	stw	r3,-16(fp)
 822ccc0:	10c00217 	ldw	r3,8(r2)
 822ccc4:	e0fffd15 	stw	r3,-12(fp)
 822ccc8:	10800317 	ldw	r2,12(r2)
 822cccc:	e0bffe15 	stw	r2,-8(fp)
   EXIT_CRIT_SECTION(&memestats);
 822ccd0:	822d64c0 	call	822d64c <irq_Unmask>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822ccd4:	01000084 	movi	r4,2
 822ccd8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   ns_printf(pio, "Regular buffer error statistics:\n");
 822ccdc:	01420974 	movhi	r5,2085
 822cce0:	29424804 	addi	r5,r5,2336
 822cce4:	e13fff17 	ldw	r4,-4(fp)
 822cce8:	8228d040 	call	8228d04 <ns_printf>
   ns_printf(pio, "Bad buffer length %lu, Guard band violations %lu\n",mlocal[BAD_REGULAR_BUF_LEN_ERR],mlocal[GUARD_BAND_VIOLATED_ERR]);
 822ccec:	e0bffb17 	ldw	r2,-20(fp)
 822ccf0:	e0fffc17 	ldw	r3,-16(fp)
 822ccf4:	180f883a 	mov	r7,r3
 822ccf8:	100d883a 	mov	r6,r2
 822ccfc:	01420974 	movhi	r5,2085
 822cd00:	29425104 	addi	r5,r5,2372
 822cd04:	e13fff17 	ldw	r4,-4(fp)
 822cd08:	8228d040 	call	8228d04 <ns_printf>
   ns_printf(pio, "Multiple frees %lu, Inconsistent location %lu\n",mlocal[MULTIPLE_FREE_ERR],mlocal[INCONSISTENT_LOCATION_ERR]);
 822cd0c:	e0bffd17 	ldw	r2,-12(fp)
 822cd10:	e0fffe17 	ldw	r3,-8(fp)
 822cd14:	180f883a 	mov	r7,r3
 822cd18:	100d883a 	mov	r6,r2
 822cd1c:	01420974 	movhi	r5,2085
 822cd20:	29425e04 	addi	r5,r5,2424
 822cd24:	e13fff17 	ldw	r4,-4(fp)
 822cd28:	8228d040 	call	8228d04 <ns_printf>

   return 0;
 822cd2c:	0005883a 	mov	r2,zero
}
 822cd30:	e037883a 	mov	sp,fp
 822cd34:	dfc00117 	ldw	ra,4(sp)
 822cd38:	df000017 	ldw	fp,0(sp)
 822cd3c:	dec00204 	addi	sp,sp,8
 822cd40:	f800283a 	ret

0822cd44 <getq>:
 * RETURNS: pointer to the first element if any, or 0 if the queue is empty.
 */

void*
getq(queue * q)
{
 822cd44:	defffc04 	addi	sp,sp,-16
 822cd48:	dfc00315 	stw	ra,12(sp)
 822cd4c:	df000215 	stw	fp,8(sp)
 822cd50:	df000204 	addi	fp,sp,8
 822cd54:	e13fff15 	stw	r4,-4(fp)
   q_elt   temp;        /* temp for result */


   ENTER_CRIT_SECTION(q);     /* shut off ints, save old state */   
 822cd58:	822d5ec0 	call	822d5ec <irq_Mask>

   LOCKNET_CHECK(q);          /* make sure queue is protected */

   if ((temp = q->q_head) == 0)  /* queue empty? */
 822cd5c:	e0bfff17 	ldw	r2,-4(fp)
 822cd60:	10800017 	ldw	r2,0(r2)
 822cd64:	e0bffe15 	stw	r2,-8(fp)
 822cd68:	e0bffe17 	ldw	r2,-8(fp)
 822cd6c:	1000031e 	bne	r2,zero,822cd7c <getq+0x38>
   {
      EXIT_CRIT_SECTION(q);
 822cd70:	822d64c0 	call	822d64c <irq_Unmask>
      return (0);             /* yes, show none */
 822cd74:	0005883a 	mov	r2,zero
 822cd78:	00001b06 	br	822cde8 <getq+0xa4>
   }

   q->q_head = temp->qe_next; /* else unlink */
 822cd7c:	e0bffe17 	ldw	r2,-8(fp)
 822cd80:	10c00017 	ldw	r3,0(r2)
 822cd84:	e0bfff17 	ldw	r2,-4(fp)
 822cd88:	10c00015 	stw	r3,0(r2)
   temp->qe_next = 0;         /* avoid dangling pointers */
 822cd8c:	e0bffe17 	ldw	r2,-8(fp)
 822cd90:	10000015 	stw	zero,0(r2)
   if (q->q_head == 0)        /* queue empty? */
 822cd94:	e0bfff17 	ldw	r2,-4(fp)
 822cd98:	10800017 	ldw	r2,0(r2)
 822cd9c:	1000021e 	bne	r2,zero,822cda8 <getq+0x64>
      q->q_tail = 0;          /* yes, update tail pointer too */
 822cda0:	e0bfff17 	ldw	r2,-4(fp)
 822cda4:	10000115 	stw	zero,4(r2)
   q->q_len--;                /* update queue length */
 822cda8:	e0bfff17 	ldw	r2,-4(fp)
 822cdac:	10800217 	ldw	r2,8(r2)
 822cdb0:	10ffffc4 	addi	r3,r2,-1
 822cdb4:	e0bfff17 	ldw	r2,-4(fp)
 822cdb8:	10c00215 	stw	r3,8(r2)
   if (q->q_len < q->q_min)
 822cdbc:	e0bfff17 	ldw	r2,-4(fp)
 822cdc0:	10c00217 	ldw	r3,8(r2)
 822cdc4:	e0bfff17 	ldw	r2,-4(fp)
 822cdc8:	10800417 	ldw	r2,16(r2)
 822cdcc:	1880040e 	bge	r3,r2,822cde0 <getq+0x9c>
      q->q_min = q->q_len;
 822cdd0:	e0bfff17 	ldw	r2,-4(fp)
 822cdd4:	10c00217 	ldw	r3,8(r2)
 822cdd8:	e0bfff17 	ldw	r2,-4(fp)
 822cddc:	10c00415 	stw	r3,16(r2)

   QUEUE_CHECK(q);         /* make sure queue is not corrupted */

   EXIT_CRIT_SECTION(q);   /* restore caller's int state */
 822cde0:	822d64c0 	call	822d64c <irq_Unmask>

   return ((void*)temp);
 822cde4:	e0bffe17 	ldw	r2,-8(fp)
}
 822cde8:	e037883a 	mov	sp,fp
 822cdec:	dfc00117 	ldw	ra,4(sp)
 822cdf0:	df000017 	ldw	fp,0(sp)
 822cdf4:	dec00204 	addi	sp,sp,8
 822cdf8:	f800283a 	ret

0822cdfc <putq>:

void
putq(
   queue   *   q,       /* the queue */
   void *   elt)        /* element to delete */
{
 822cdfc:	defffc04 	addi	sp,sp,-16
 822ce00:	dfc00315 	stw	ra,12(sp)
 822ce04:	df000215 	stw	fp,8(sp)
 822ce08:	df000204 	addi	fp,sp,8
 822ce0c:	e13ffe15 	stw	r4,-8(fp)
 822ce10:	e17fff15 	stw	r5,-4(fp)
   ENTER_CRIT_SECTION(q);
 822ce14:	822d5ec0 	call	822d5ec <irq_Mask>
   LOCKNET_CHECK(q);       /* make sure queue is protected */
   q_addt(q, (qp)elt);     /* use macro to do work */
 822ce18:	e0bfff17 	ldw	r2,-4(fp)
 822ce1c:	10000015 	stw	zero,0(r2)
 822ce20:	e0bffe17 	ldw	r2,-8(fp)
 822ce24:	10800017 	ldw	r2,0(r2)
 822ce28:	1000041e 	bne	r2,zero,822ce3c <putq+0x40>
 822ce2c:	e0bffe17 	ldw	r2,-8(fp)
 822ce30:	e0ffff17 	ldw	r3,-4(fp)
 822ce34:	10c00015 	stw	r3,0(r2)
 822ce38:	00000406 	br	822ce4c <putq+0x50>
 822ce3c:	e0bffe17 	ldw	r2,-8(fp)
 822ce40:	10800117 	ldw	r2,4(r2)
 822ce44:	e0ffff17 	ldw	r3,-4(fp)
 822ce48:	10c00015 	stw	r3,0(r2)
 822ce4c:	e0bffe17 	ldw	r2,-8(fp)
 822ce50:	e0ffff17 	ldw	r3,-4(fp)
 822ce54:	10c00115 	stw	r3,4(r2)
 822ce58:	e0bffe17 	ldw	r2,-8(fp)
 822ce5c:	10800217 	ldw	r2,8(r2)
 822ce60:	10c00044 	addi	r3,r2,1
 822ce64:	e0bffe17 	ldw	r2,-8(fp)
 822ce68:	10c00215 	stw	r3,8(r2)
 822ce6c:	e0bffe17 	ldw	r2,-8(fp)
 822ce70:	10800217 	ldw	r2,8(r2)
 822ce74:	e0fffe17 	ldw	r3,-8(fp)
 822ce78:	18c00317 	ldw	r3,12(r3)
 822ce7c:	1880040e 	bge	r3,r2,822ce90 <putq+0x94>
 822ce80:	e0bffe17 	ldw	r2,-8(fp)
 822ce84:	10c00217 	ldw	r3,8(r2)
 822ce88:	e0bffe17 	ldw	r2,-8(fp)
 822ce8c:	10c00315 	stw	r3,12(r2)
   QUEUE_CHECK(q);         /* make sure queue is not corrupted */
   EXIT_CRIT_SECTION(q);   /* restore int state */
 822ce90:	822d64c0 	call	822d64c <irq_Unmask>
}
 822ce94:	0001883a 	nop
 822ce98:	e037883a 	mov	sp,fp
 822ce9c:	dfc00117 	ldw	ra,4(sp)
 822cea0:	df000017 	ldw	fp,0(sp)
 822cea4:	dec00204 	addi	sp,sp,8
 822cea8:	f800283a 	ret

0822ceac <qdel>:
 * RETURNS: Return pointer to queue member if found, else NULL. 
 */

qp
qdel(queue * q, void * elt)
{
 822ceac:	defffa04 	addi	sp,sp,-24
 822ceb0:	dfc00515 	stw	ra,20(sp)
 822ceb4:	df000415 	stw	fp,16(sp)
 822ceb8:	df000404 	addi	fp,sp,16
 822cebc:	e13ffe15 	stw	r4,-8(fp)
 822cec0:	e17fff15 	stw	r5,-4(fp)
   qp qptr;
   qp qlast;

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
 822cec4:	822d5ec0 	call	822d5ec <irq_Mask>
   qptr = q->q_head;
 822cec8:	e0bffe17 	ldw	r2,-8(fp)
 822cecc:	10800017 	ldw	r2,0(r2)
 822ced0:	e0bffc15 	stw	r2,-16(fp)
   qlast = NULL;
 822ced4:	e03ffd15 	stw	zero,-12(fp)
   while (qptr)
 822ced8:	00002b06 	br	822cf88 <qdel+0xdc>
   {
      if (qptr == (qp)elt)
 822cedc:	e0fffc17 	ldw	r3,-16(fp)
 822cee0:	e0bfff17 	ldw	r2,-4(fp)
 822cee4:	1880231e 	bne	r3,r2,822cf74 <qdel+0xc8>
      {
         /* found our item; dequeue it */
         if (qlast)
 822cee8:	e0bffd17 	ldw	r2,-12(fp)
 822ceec:	10000526 	beq	r2,zero,822cf04 <qdel+0x58>
            qlast->qe_next = qptr->qe_next;
 822cef0:	e0bffc17 	ldw	r2,-16(fp)
 822cef4:	10c00017 	ldw	r3,0(r2)
 822cef8:	e0bffd17 	ldw	r2,-12(fp)
 822cefc:	10c00015 	stw	r3,0(r2)
 822cf00:	00000406 	br	822cf14 <qdel+0x68>
         else     /* item was at head of queqe */
            q->q_head = qptr->qe_next;
 822cf04:	e0bffc17 	ldw	r2,-16(fp)
 822cf08:	10c00017 	ldw	r3,0(r2)
 822cf0c:	e0bffe17 	ldw	r2,-8(fp)
 822cf10:	10c00015 	stw	r3,0(r2)

         /* fix queue tail pointer if needed */
         if (q->q_tail == (qp)elt)
 822cf14:	e0bffe17 	ldw	r2,-8(fp)
 822cf18:	10c00117 	ldw	r3,4(r2)
 822cf1c:	e0bfff17 	ldw	r2,-4(fp)
 822cf20:	1880031e 	bne	r3,r2,822cf30 <qdel+0x84>
            q->q_tail = qlast;
 822cf24:	e0bffe17 	ldw	r2,-8(fp)
 822cf28:	e0fffd17 	ldw	r3,-12(fp)
 822cf2c:	10c00115 	stw	r3,4(r2)

         /* fix queue counters */
         q->q_len--;
 822cf30:	e0bffe17 	ldw	r2,-8(fp)
 822cf34:	10800217 	ldw	r2,8(r2)
 822cf38:	10ffffc4 	addi	r3,r2,-1
 822cf3c:	e0bffe17 	ldw	r2,-8(fp)
 822cf40:	10c00215 	stw	r3,8(r2)
         if (q->q_len < q->q_min)
 822cf44:	e0bffe17 	ldw	r2,-8(fp)
 822cf48:	10c00217 	ldw	r3,8(r2)
 822cf4c:	e0bffe17 	ldw	r2,-8(fp)
 822cf50:	10800417 	ldw	r2,16(r2)
 822cf54:	1880040e 	bge	r3,r2,822cf68 <qdel+0xbc>
            q->q_min = q->q_len;
 822cf58:	e0bffe17 	ldw	r2,-8(fp)
 822cf5c:	10c00217 	ldw	r3,8(r2)
 822cf60:	e0bffe17 	ldw	r2,-8(fp)
 822cf64:	10c00415 	stw	r3,16(r2)
         EXIT_CRIT_SECTION(q);   /* restore int state */
 822cf68:	822d64c0 	call	822d64c <irq_Unmask>
         return (qp)elt;   /* success exit point */
 822cf6c:	e0bfff17 	ldw	r2,-4(fp)
 822cf70:	00000906 	br	822cf98 <qdel+0xec>
      }
      qlast = qptr;
 822cf74:	e0bffc17 	ldw	r2,-16(fp)
 822cf78:	e0bffd15 	stw	r2,-12(fp)
      qptr = qptr->qe_next;
 822cf7c:	e0bffc17 	ldw	r2,-16(fp)
 822cf80:	10800017 	ldw	r2,0(r2)
 822cf84:	e0bffc15 	stw	r2,-16(fp)

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
   qptr = q->q_head;
   qlast = NULL;
   while (qptr)
 822cf88:	e0bffc17 	ldw	r2,-16(fp)
 822cf8c:	103fd31e 	bne	r2,zero,822cedc <qdel+0x30>
         return (qp)elt;   /* success exit point */
      }
      qlast = qptr;
      qptr = qptr->qe_next;
   }
   EXIT_CRIT_SECTION(q);   /* restore int state */
 822cf90:	822d64c0 	call	822d64c <irq_Unmask>
   return NULL;   /* item not found in queue */
 822cf94:	0005883a 	mov	r2,zero
}
 822cf98:	e037883a 	mov	sp,fp
 822cf9c:	dfc00117 	ldw	ra,4(sp)
 822cfa0:	df000017 	ldw	fp,0(sp)
 822cfa4:	dec00204 	addi	sp,sp,8
 822cfa8:	f800283a 	ret

0822cfac <udp_open>:
   ip_addr  fhost,      /* foreign host, 0L for any */
   unshort  fsock,      /* foreign socket, 0 for any */
   unshort  lsock,      /* local socket */
   int (*handler)(PACKET, void*),   /* rcv upcall */
   void *   data)       /* random data, returned on upcalls to aid demuxing */
{
 822cfac:	defff404 	addi	sp,sp,-48
 822cfb0:	dfc00b15 	stw	ra,44(sp)
 822cfb4:	df000a15 	stw	fp,40(sp)
 822cfb8:	df000a04 	addi	fp,sp,40
 822cfbc:	e13ffc15 	stw	r4,-16(fp)
 822cfc0:	2807883a 	mov	r3,r5
 822cfc4:	3005883a 	mov	r2,r6
 822cfc8:	e1ffff15 	stw	r7,-4(fp)
 822cfcc:	e0fffd0d 	sth	r3,-12(fp)
 822cfd0:	e0bffe0d 	sth	r2,-8(fp)
/*
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
 822cfd4:	d0a08317 	ldw	r2,-32244(gp)
 822cfd8:	1080010c 	andi	r2,r2,4
 822cfdc:	10001526 	beq	r2,zero,822d034 <udp_open+0x88>
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822cfe0:	e0bffc17 	ldw	r2,-16(fp)
 822cfe4:	12003fcc 	andi	r8,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 822cfe8:	e0bffc17 	ldw	r2,-16(fp)
 822cfec:	1004d23a 	srli	r2,r2,8
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822cff0:	11803fcc 	andi	r6,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 822cff4:	e0bffc17 	ldw	r2,-16(fp)
 822cff8:	1004d43a 	srli	r2,r2,16
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822cffc:	11c03fcc 	andi	r7,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 822d000:	e0bffc17 	ldw	r2,-16(fp)
 822d004:	1004d63a 	srli	r2,r2,24
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 822d008:	e0fffe0b 	ldhu	r3,-8(fp)
 822d00c:	e13ffd0b 	ldhu	r4,-12(fp)
 822d010:	e1400217 	ldw	r5,8(fp)
 822d014:	d9400315 	stw	r5,12(sp)
 822d018:	d9000215 	stw	r4,8(sp)
 822d01c:	d8c00115 	stw	r3,4(sp)
 822d020:	d8800015 	stw	r2,0(sp)
 822d024:	400b883a 	mov	r5,r8
 822d028:	01020974 	movhi	r4,2085
 822d02c:	21026a04 	addi	r4,r4,2472
 822d030:	820331c0 	call	820331c <printf>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 822d034:	0009883a 	mov	r4,zero
 822d038:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   ocon = NULL;
 822d03c:	e03ffb15 	stw	zero,-20(fp)
   for (con = firstudp; con; con = con->u_next)
 822d040:	d0a09c17 	ldw	r2,-32144(gp)
 822d044:	e0bffa15 	stw	r2,-24(fp)
 822d048:	00002006 	br	822d0cc <udp_open+0x120>
   {
      ocon = con;       /* remember last con in list */
 822d04c:	e0bffa17 	ldw	r2,-24(fp)
 822d050:	e0bffb15 	stw	r2,-20(fp)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 822d054:	e0bffa17 	ldw	r2,-24(fp)
 822d058:	1080018b 	ldhu	r2,6(r2)
 822d05c:	10ffffcc 	andi	r3,r2,65535
 822d060:	e0bffe0b 	ldhu	r2,-8(fp)
 822d064:	1880161e 	bne	r3,r2,822d0c0 <udp_open+0x114>
 822d068:	e0bffa17 	ldw	r2,-24(fp)
 822d06c:	1080020b 	ldhu	r2,8(r2)
 822d070:	10ffffcc 	andi	r3,r2,65535
 822d074:	e0bffd0b 	ldhu	r2,-12(fp)
 822d078:	1880111e 	bne	r3,r2,822d0c0 <udp_open+0x114>
          con->u_lhost == 0 && con->u_fhost == fhost)
 822d07c:	e0bffa17 	ldw	r2,-24(fp)
 822d080:	10800317 	ldw	r2,12(r2)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 822d084:	10000e1e 	bne	r2,zero,822d0c0 <udp_open+0x114>
          con->u_lhost == 0 && con->u_fhost == fhost)
 822d088:	e0bffa17 	ldw	r2,-24(fp)
 822d08c:	10c00417 	ldw	r3,16(r2)
 822d090:	e0bffc17 	ldw	r2,-16(fp)
 822d094:	18800a1e 	bne	r3,r2,822d0c0 <udp_open+0x114>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (INFOMSG|PROTERR))
 822d098:	d0a08317 	ldw	r2,-32244(gp)
 822d09c:	1080050c 	andi	r2,r2,20
 822d0a0:	10000326 	beq	r2,zero,822d0b0 <udp_open+0x104>
            dprintf("UDP: Connection already exists.\n");
 822d0a4:	01020974 	movhi	r4,2085
 822d0a8:	21027904 	addi	r4,r4,2532
 822d0ac:	82035a00 	call	82035a0 <puts>
#endif
         UNLOCK_NET_RESOURCE(NET_RESID);
 822d0b0:	0009883a 	mov	r4,zero
 822d0b4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         return(NULL);
 822d0b8:	0005883a 	mov	r2,zero
 822d0bc:	00003506 	br	822d194 <udp_open+0x1e8>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
   ocon = NULL;
   for (con = firstudp; con; con = con->u_next)
 822d0c0:	e0bffa17 	ldw	r2,-24(fp)
 822d0c4:	10800017 	ldw	r2,0(r2)
 822d0c8:	e0bffa15 	stw	r2,-24(fp)
 822d0cc:	e0bffa17 	ldw	r2,-24(fp)
 822d0d0:	103fde1e 	bne	r2,zero,822d04c <udp_open+0xa0>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return(NULL);
      }
   }

   con = (UDPCONN)UC_ALLOC(sizeof(struct udp_conn));
 822d0d4:	01000804 	movi	r4,32
 822d0d8:	822dfec0 	call	822dfec <npalloc>
 822d0dc:	e0bffa15 	stw	r2,-24(fp)
   if (con == 0)
 822d0e0:	e0bffa17 	ldw	r2,-24(fp)
 822d0e4:	10000a1e 	bne	r2,zero,822d110 <udp_open+0x164>
   {
#ifdef   NPDEBUG
      if (NDEBUG & INFOMSG)
 822d0e8:	d0a08317 	ldw	r2,-32244(gp)
 822d0ec:	1080010c 	andi	r2,r2,4
 822d0f0:	10000326 	beq	r2,zero,822d100 <udp_open+0x154>
         dprintf("UDP: Couldn't allocate conn storage.\n");
 822d0f4:	01020974 	movhi	r4,2085
 822d0f8:	21028104 	addi	r4,r4,2564
 822d0fc:	82035a00 	call	82035a0 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 822d100:	0009883a 	mov	r4,zero
 822d104:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return(NULL);
 822d108:	0005883a 	mov	r2,zero
 822d10c:	00002106 	br	822d194 <udp_open+0x1e8>
   }

   if (ocon)   /* ocon is end of list */
 822d110:	e0bffb17 	ldw	r2,-20(fp)
 822d114:	10000426 	beq	r2,zero,822d128 <udp_open+0x17c>
      ocon->u_next = con;  /* add new connection to end */
 822d118:	e0bffb17 	ldw	r2,-20(fp)
 822d11c:	e0fffa17 	ldw	r3,-24(fp)
 822d120:	10c00015 	stw	r3,0(r2)
 822d124:	00000206 	br	822d130 <udp_open+0x184>
   else  /* no list, start one */
      firstudp = con;
 822d128:	e0bffa17 	ldw	r2,-24(fp)
 822d12c:	d0a09c15 	stw	r2,-32144(gp)

   con->u_next = 0;
 822d130:	e0bffa17 	ldw	r2,-24(fp)
 822d134:	10000015 	stw	zero,0(r2)

   con->u_lport = lsock;      /* fill in connection info */
 822d138:	e0bffa17 	ldw	r2,-24(fp)
 822d13c:	e0fffe0b 	ldhu	r3,-8(fp)
 822d140:	10c0018d 	sth	r3,6(r2)
   con->u_fport = fsock;
 822d144:	e0bffa17 	ldw	r2,-24(fp)
 822d148:	e0fffd0b 	ldhu	r3,-12(fp)
 822d14c:	10c0020d 	sth	r3,8(r2)
   con->u_lhost = 0;
 822d150:	e0bffa17 	ldw	r2,-24(fp)
 822d154:	10000315 	stw	zero,12(r2)
   con->u_fhost = fhost;
 822d158:	e0bffa17 	ldw	r2,-24(fp)
 822d15c:	e0fffc17 	ldw	r3,-16(fp)
 822d160:	10c00415 	stw	r3,16(r2)
   con->u_rcv   = handler;
 822d164:	e0bffa17 	ldw	r2,-24(fp)
 822d168:	e0ffff17 	ldw	r3,-4(fp)
 822d16c:	10c00515 	stw	r3,20(r2)
   con->u_data  = data;
 822d170:	e0bffa17 	ldw	r2,-24(fp)
 822d174:	e0c00217 	ldw	r3,8(fp)
 822d178:	10c00615 	stw	r3,24(r2)
   con->u_flags = UDPCF_V4;
 822d17c:	e0bffa17 	ldw	r2,-24(fp)
 822d180:	00c00044 	movi	r3,1
 822d184:	10c0010d 	sth	r3,4(r2)

   UNLOCK_NET_RESOURCE(NET_RESID);
 822d188:	0009883a 	mov	r4,zero
 822d18c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   return(con);
 822d190:	e0bffa17 	ldw	r2,-24(fp)
}
 822d194:	e037883a 	mov	sp,fp
 822d198:	dfc00117 	ldw	ra,4(sp)
 822d19c:	df000017 	ldw	fp,0(sp)
 822d1a0:	dec00204 	addi	sp,sp,8
 822d1a4:	f800283a 	ret

0822d1a8 <udp_close>:
 * RETURNS: void
 */

void
udp_close(UDPCONN con)
{
 822d1a8:	defffb04 	addi	sp,sp,-20
 822d1ac:	dfc00415 	stw	ra,16(sp)
 822d1b0:	df000315 	stw	fp,12(sp)
 822d1b4:	df000304 	addi	fp,sp,12
 822d1b8:	e13fff15 	stw	r4,-4(fp)
   UDPCONN pcon;
   UDPCONN lcon;

#ifdef NPDEBUG
   if ((con == NULL) || (firstudp == NULL))
 822d1bc:	e0bfff17 	ldw	r2,-4(fp)
 822d1c0:	10000226 	beq	r2,zero,822d1cc <udp_close+0x24>
 822d1c4:	d0a09c17 	ldw	r2,-32144(gp)
 822d1c8:	1000021e 	bne	r2,zero,822d1d4 <udp_close+0x2c>
   {
      dtrap(); /* bad programming! */
 822d1cc:	822d4140 	call	822d414 <dtrap>
      return;
 822d1d0:	00002606 	br	822d26c <udp_close+0xc4>
   }
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 822d1d4:	0009883a 	mov	r4,zero
 822d1d8:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
 822d1dc:	e03ffe15 	stw	zero,-8(fp)
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 822d1e0:	d0a09c17 	ldw	r2,-32144(gp)
 822d1e4:	e0bffd15 	stw	r2,-12(fp)
 822d1e8:	00000806 	br	822d20c <udp_close+0x64>
   {
      if (pcon == con)  /* found connection to delete */
 822d1ec:	e0fffd17 	ldw	r3,-12(fp)
 822d1f0:	e0bfff17 	ldw	r2,-4(fp)
 822d1f4:	18800826 	beq	r3,r2,822d218 <udp_close+0x70>
      break;
      lcon = pcon;   /* remember last connection */
 822d1f8:	e0bffd17 	ldw	r2,-12(fp)
 822d1fc:	e0bffe15 	stw	r2,-8(fp)
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 822d200:	e0bffd17 	ldw	r2,-12(fp)
 822d204:	10800017 	ldw	r2,0(r2)
 822d208:	e0bffd15 	stw	r2,-12(fp)
 822d20c:	e0bffd17 	ldw	r2,-12(fp)
 822d210:	103ff61e 	bne	r2,zero,822d1ec <udp_close+0x44>
 822d214:	00000106 	br	822d21c <udp_close+0x74>
   {
      if (pcon == con)  /* found connection to delete */
      break;
 822d218:	0001883a 	nop
      lcon = pcon;   /* remember last connection */
   }

   if (!pcon)
 822d21c:	e0bffd17 	ldw	r2,-12(fp)
 822d220:	1000041e 	bne	r2,zero,822d234 <udp_close+0x8c>
   {
      dtrap(); /* prog error - connenction not in list */
 822d224:	822d4140 	call	822d414 <dtrap>
      UNLOCK_NET_RESOURCE(NET_RESID);
 822d228:	0009883a 	mov	r4,zero
 822d22c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return;
 822d230:	00000e06 	br	822d26c <udp_close+0xc4>
   }

   if (lcon)   /* in con is not head of list */
 822d234:	e0bffe17 	ldw	r2,-8(fp)
 822d238:	10000526 	beq	r2,zero,822d250 <udp_close+0xa8>
      lcon->u_next = con->u_next;   /* unlink */
 822d23c:	e0bfff17 	ldw	r2,-4(fp)
 822d240:	10c00017 	ldw	r3,0(r2)
 822d244:	e0bffe17 	ldw	r2,-8(fp)
 822d248:	10c00015 	stw	r3,0(r2)
 822d24c:	00000306 	br	822d25c <udp_close+0xb4>
   else
      firstudp = con->u_next; /* remove from head */
 822d250:	e0bfff17 	ldw	r2,-4(fp)
 822d254:	10800017 	ldw	r2,0(r2)
 822d258:	d0a09c15 	stw	r2,-32144(gp)

   UC_FREE(con);  /* free memory for structure */
 822d25c:	e13fff17 	ldw	r4,-4(fp)
 822d260:	822e0200 	call	822e020 <npfree>
   UNLOCK_NET_RESOURCE(NET_RESID);
 822d264:	0009883a 	mov	r4,zero
 822d268:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
}
 822d26c:	e037883a 	mov	sp,fp
 822d270:	dfc00117 	ldw	ra,4(sp)
 822d274:	df000017 	ldw	fp,0(sp)
 822d278:	dec00204 	addi	sp,sp,8
 822d27c:	f800283a 	ret

0822d280 <asm_cksum>:
      .text

      .global	  asm_cksum

asm_cksum:
      mov   r2, zero		       /* accumulator = 0 */
 822d280:	0005883a 	mov	r2,zero
      ble   r5, zero, done	       /* count <= 0 ? */
 822d284:	0140620e 	bge	zero,r5,822d410 <done>

      mov   r6, zero		       /* carry accumulator */
 822d288:	000d883a 	mov	r6,zero

      andi  r3, r4, 2		       /* ptr 32-bit aligned? */
 822d28c:	20c0008c 	andi	r3,r4,2
      beq   r3, zero, asm1
 822d290:	18000326 	beq	r3,zero,822d2a0 <asm1>
      ldhu  r2, (r4)		       /* no - process first 16-bits */
 822d294:	2080000b 	ldhu	r2,0(r4)
      addi  r4, r4, 2
 822d298:	21000084 	addi	r4,r4,2
      subi  r5, r5, 1
 822d29c:	297fffc4 	addi	r5,r5,-1

0822d2a0 <asm1>:
 822d2a0:	02c208f4 	movhi	r11,2083
/*
 * adjust ptr by ((count/2) mod 16) * 4 bytes
 * jump to location: loop0 - (count/2 mod 16) * 4 instructions
 */
asm1:
      movia r11, loop0
 822d2a4:	5af4f304 	addi	r11,r11,-11316
      andi  r9, r5, 1		       /* r9 = last halfword flag */
 822d2a8:	2a40004c 	andi	r9,r5,1
      srai  r5, r5, 1		       /* count = number of words */
 822d2ac:	280bd07a 	srai	r5,r5,1
      andi  r10, r5, 0xf	       /* modulo 16 */
 822d2b0:	2a8003cc 	andi	r10,r5,15
      slli  r10, r10, 2		       /*      * 4 bytes per word */
 822d2b4:	501490ba 	slli	r10,r10,2
      add   r4, r10, r4		       /* adjust ptr */
 822d2b8:	5109883a 	add	r4,r10,r4
      slli  r10, r10, 2		       /*      * 4 instructions per 4 bytes */
 822d2bc:	501490ba 	slli	r10,r10,2
      sub   r11, r11, r10
 822d2c0:	5a97c83a 	sub	r11,r11,r10
      jmp   r11
 822d2c4:	5800683a 	jmp	r11

0822d2c8 <loop>:
      
loop:
      addi  r4, r4, 64		       /* increment data pointer */
 822d2c8:	21001004 	addi	r4,r4,64

      ldw   r7, -64(r4)
 822d2cc:	21fff017 	ldw	r7,-64(r4)
      add   r2, r7, r2
 822d2d0:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d2d4:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d2d8:	418d883a 	add	r6,r8,r6

      ldw   r7, -60(r4)
 822d2dc:	21fff117 	ldw	r7,-60(r4)
      add   r2, r7, r2
 822d2e0:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d2e4:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d2e8:	418d883a 	add	r6,r8,r6

      ldw   r7, -56(r4)
 822d2ec:	21fff217 	ldw	r7,-56(r4)
      add   r2, r7, r2
 822d2f0:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d2f4:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d2f8:	418d883a 	add	r6,r8,r6

      ldw   r7, -52(r4)
 822d2fc:	21fff317 	ldw	r7,-52(r4)
      add   r2, r7, r2
 822d300:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d304:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d308:	418d883a 	add	r6,r8,r6

      ldw   r7, -48(r4)
 822d30c:	21fff417 	ldw	r7,-48(r4)
      add   r2, r7, r2
 822d310:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d314:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d318:	418d883a 	add	r6,r8,r6

      ldw   r7, -44(r4)
 822d31c:	21fff517 	ldw	r7,-44(r4)
      add   r2, r7, r2
 822d320:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d324:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d328:	418d883a 	add	r6,r8,r6

      ldw   r7, -40(r4)
 822d32c:	21fff617 	ldw	r7,-40(r4)
      add   r2, r7, r2
 822d330:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d334:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d338:	418d883a 	add	r6,r8,r6

      ldw   r7, -36(r4)
 822d33c:	21fff717 	ldw	r7,-36(r4)
      add   r2, r7, r2
 822d340:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d344:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d348:	418d883a 	add	r6,r8,r6

      ldw   r7, -32(r4)
 822d34c:	21fff817 	ldw	r7,-32(r4)
      add   r2, r7, r2
 822d350:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d354:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d358:	418d883a 	add	r6,r8,r6

      ldw   r7, -28(r4)
 822d35c:	21fff917 	ldw	r7,-28(r4)
      add   r2, r7, r2
 822d360:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d364:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d368:	418d883a 	add	r6,r8,r6

      ldw   r7, -24(r4)
 822d36c:	21fffa17 	ldw	r7,-24(r4)
      add   r2, r7, r2
 822d370:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d374:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d378:	418d883a 	add	r6,r8,r6

      ldw   r7, -20(r4)
 822d37c:	21fffb17 	ldw	r7,-20(r4)
      add   r2, r7, r2
 822d380:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d384:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d388:	418d883a 	add	r6,r8,r6

      ldw   r7, -16(r4)
 822d38c:	21fffc17 	ldw	r7,-16(r4)
      add   r2, r7, r2
 822d390:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d394:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d398:	418d883a 	add	r6,r8,r6

      ldw   r7, -12(r4)
 822d39c:	21fffd17 	ldw	r7,-12(r4)
      add   r2, r7, r2
 822d3a0:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d3a4:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d3a8:	418d883a 	add	r6,r8,r6

      ldw   r7, -8(r4)
 822d3ac:	21fffe17 	ldw	r7,-8(r4)
      add   r2, r7, r2
 822d3b0:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d3b4:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d3b8:	418d883a 	add	r6,r8,r6

      ldw   r7, -4(r4)
 822d3bc:	21ffff17 	ldw	r7,-4(r4)
      add   r2, r7, r2
 822d3c0:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d3c4:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d3c8:	418d883a 	add	r6,r8,r6

0822d3cc <loop0>:
loop0:
      subi  r5, r5, 16
 822d3cc:	297ffc04 	addi	r5,r5,-16
      bge   r5, zero, loop
 822d3d0:	283fbd0e 	bge	r5,zero,822d2c8 <loop>
/*
 * process last halfword (if any)
 */
      beq   r9, zero, fold
 822d3d4:	48000426 	beq	r9,zero,822d3e8 <fold>
      ldhu  r7, 0(r4)
 822d3d8:	21c0000b 	ldhu	r7,0(r4)
      add   r2, r7, r2
 822d3dc:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 822d3e0:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 822d3e4:	418d883a 	add	r6,r8,r6

0822d3e8 <fold>:
      
fold:
      srli  r7, r2, 16
 822d3e8:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 822d3ec:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add the upper and lower halfwords */
 822d3f0:	3885883a 	add	r2,r7,r2
      add   r2, r6, r2		    /* add the carries */
 822d3f4:	3085883a 	add	r2,r6,r2
/* the accumulator is 18 bits */
      srli  r7, r2, 16
 822d3f8:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 822d3fc:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add 2 carry bits to lower halfword */
 822d400:	3885883a 	add	r2,r7,r2
/* the accumulator is 17 bits */
      srli  r7, r2, 16
 822d404:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 822d408:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add carry to lower halfword */
 822d40c:	3885883a 	add	r2,r7,r2

0822d410 <done>:

done:
      ret			    		/* r2 = 16-bit checksum */
 822d410:	f800283a 	ret

0822d414 <dtrap>:
void irq_Unmask(void);

/* dtrap() - function to trap to debugger */
void
dtrap(void)
{
 822d414:	defffe04 	addi	sp,sp,-8
 822d418:	dfc00115 	stw	ra,4(sp)
 822d41c:	df000015 	stw	fp,0(sp)
 822d420:	d839883a 	mov	fp,sp
   printf("dtrap - needs breakpoint\n");
 822d424:	01020974 	movhi	r4,2085
 822d428:	21028b04 	addi	r4,r4,2604
 822d42c:	82035a00 	call	82035a0 <puts>
}
 822d430:	0001883a 	nop
 822d434:	e037883a 	mov	sp,fp
 822d438:	dfc00117 	ldw	ra,4(sp)
 822d43c:	df000017 	ldw	fp,0(sp)
 822d440:	dec00204 	addi	sp,sp,8
 822d444:	f800283a 	ret

0822d448 <kbhit>:

int
kbhit()
{
 822d448:	defffd04 	addi	sp,sp,-12
 822d44c:	dfc00215 	stw	ra,8(sp)
 822d450:	df000115 	stw	fp,4(sp)
 822d454:	df000104 	addi	fp,sp,4
   static int kbd_init = 0;
   int   kb;
   
   if (!kbd_init)
 822d458:	d0a0a017 	ldw	r2,-32128(gp)
 822d45c:	10000b1e 	bne	r2,zero,822d48c <kbhit+0x44>
      /* we really should read the flags, OR in O_NONBLOCK, and write
       * the flags back to STDIN, but the NIOS-II/HAL implementation
       * will only let us modify O_NONBLOCK and O_APPEND, so we'll
       * just write the new flag value.
       */
      if (fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK) != 0)
 822d460:	01900004 	movi	r6,16384
 822d464:	01400104 	movi	r5,4
 822d468:	0009883a 	mov	r4,zero
 822d46c:	823d7240 	call	823d724 <fcntl>
 822d470:	10000426 	beq	r2,zero,822d484 <kbhit+0x3c>
      {
         printf("F_SETFL failed.\n");
 822d474:	01020974 	movhi	r4,2085
 822d478:	21029204 	addi	r4,r4,2632
 822d47c:	82035a00 	call	82035a0 <puts>
         dtrap();
 822d480:	822d4140 	call	822d414 <dtrap>
      }
      kbd_init = 1; 
 822d484:	00800044 	movi	r2,1
 822d488:	d0a0a015 	stw	r2,-32128(gp)
   }

   /* we have to do a read to see if there is a character available.
    * we save the character, if there was one, to be read later. */
   if (kb_last == EOF)
 822d48c:	d0a03a17 	ldw	r2,-32536(gp)
 822d490:	10bfffd8 	cmpnei	r2,r2,-1
 822d494:	10000b1e 	bne	r2,zero,822d4c4 <kbhit+0x7c>
   {
      kb = getchar();
 822d498:	d0a00217 	ldw	r2,-32760(gp)
 822d49c:	10800117 	ldw	r2,4(r2)
 822d4a0:	1009883a 	mov	r4,r2
 822d4a4:	8202e040 	call	8202e04 <getc>
 822d4a8:	e0bfff15 	stw	r2,-4(fp)
      if (kb < 0)       /* any error means no character present */
 822d4ac:	e0bfff17 	ldw	r2,-4(fp)
 822d4b0:	1000020e 	bge	r2,zero,822d4bc <kbhit+0x74>
         return (FALSE);
 822d4b4:	0005883a 	mov	r2,zero
 822d4b8:	00000306 	br	822d4c8 <kbhit+0x80>
         
      /* there was a character, and we read it. */
      kb_last = kb;
 822d4bc:	e0bfff17 	ldw	r2,-4(fp)
 822d4c0:	d0a03a15 	stw	r2,-32536(gp)
   }

   return (TRUE);
 822d4c4:	00800044 	movi	r2,1
}
 822d4c8:	e037883a 	mov	sp,fp
 822d4cc:	dfc00117 	ldw	ra,4(sp)
 822d4d0:	df000017 	ldw	fp,0(sp)
 822d4d4:	dec00204 	addi	sp,sp,8
 822d4d8:	f800283a 	ret

0822d4dc <getch>:

int 
getch()
{
 822d4dc:	defffd04 	addi	sp,sp,-12
 822d4e0:	dfc00215 	stw	ra,8(sp)
 822d4e4:	df000115 	stw	fp,4(sp)
 822d4e8:	df000104 	addi	fp,sp,4
int chr;

   if(kb_last != EOF)
 822d4ec:	d0a03a17 	ldw	r2,-32536(gp)
 822d4f0:	10bfffe0 	cmpeqi	r2,r2,-1
 822d4f4:	1000051e 	bne	r2,zero,822d50c <getch+0x30>
   {
      chr = kb_last;
 822d4f8:	d0a03a17 	ldw	r2,-32536(gp)
 822d4fc:	e0bfff15 	stw	r2,-4(fp)
      kb_last = EOF;
 822d500:	00bfffc4 	movi	r2,-1
 822d504:	d0a03a15 	stw	r2,-32536(gp)
 822d508:	00000506 	br	822d520 <getch+0x44>
   }
   else
      chr = getchar();
 822d50c:	d0a00217 	ldw	r2,-32760(gp)
 822d510:	10800117 	ldw	r2,4(r2)
 822d514:	1009883a 	mov	r4,r2
 822d518:	8202e040 	call	8202e04 <getc>
 822d51c:	e0bfff15 	stw	r2,-4(fp)

   return chr;
 822d520:	e0bfff17 	ldw	r2,-4(fp)
}
 822d524:	e037883a 	mov	sp,fp
 822d528:	dfc00117 	ldw	ra,4(sp)
 822d52c:	df000017 	ldw	fp,0(sp)
 822d530:	dec00204 	addi	sp,sp,8
 822d534:	f800283a 	ret

0822d538 <clock_init>:
int OS_TPS;
int cticks_factor;
int cticks_initialized = 0;

void clock_init(void)
{
 822d538:	deffff04 	addi	sp,sp,-4
 822d53c:	df000015 	stw	fp,0(sp)
 822d540:	d839883a 	mov	fp,sp
   OS_TPS = OS_TICKS_PER_SEC;
 822d544:	00801904 	movi	r2,100
 822d548:	d0a0a215 	stw	r2,-32120(gp)
   cticks_factor = 0;
 822d54c:	d020a115 	stw	zero,-32124(gp)
   cticks = 0;
 822d550:	d020a815 	stw	zero,-32096(gp)
   cticks_initialized = 1;
 822d554:	00800044 	movi	r2,1
 822d558:	d0a09d15 	stw	r2,-32140(gp)
}
 822d55c:	0001883a 	nop
 822d560:	e037883a 	mov	sp,fp
 822d564:	df000017 	ldw	fp,0(sp)
 822d568:	dec00104 	addi	sp,sp,4
 822d56c:	f800283a 	ret

0822d570 <clock_c>:

/* undo effects of clock_init (i.e. restore ISR vector) 
 * NO OP since using RTOS's timer.
 */
void clock_c(void)
{
 822d570:	deffff04 	addi	sp,sp,-4
 822d574:	df000015 	stw	fp,0(sp)
 822d578:	d839883a 	mov	fp,sp
   /* null */ ;
}
 822d57c:	0001883a 	nop
 822d580:	e037883a 	mov	sp,fp
 822d584:	df000017 	ldw	fp,0(sp)
 822d588:	dec00104 	addi	sp,sp,4
 822d58c:	f800283a 	ret

0822d590 <cticks_hook>:
 * Use the uCOS-II/Altera HAL BSP's timer and scale cticks as per TPS.
 */

void
cticks_hook(void)
{
 822d590:	deffff04 	addi	sp,sp,-4
 822d594:	df000015 	stw	fp,0(sp)
 822d598:	d839883a 	mov	fp,sp
   if (cticks_initialized) 
 822d59c:	d0a09d17 	ldw	r2,-32140(gp)
 822d5a0:	10000d26 	beq	r2,zero,822d5d8 <cticks_hook+0x48>
   {
      cticks_factor += TPS;
 822d5a4:	d0a0a117 	ldw	r2,-32124(gp)
 822d5a8:	10801904 	addi	r2,r2,100
 822d5ac:	d0a0a115 	stw	r2,-32124(gp)
      if (cticks_factor >= OS_TPS)
 822d5b0:	d0e0a117 	ldw	r3,-32124(gp)
 822d5b4:	d0a0a217 	ldw	r2,-32120(gp)
 822d5b8:	18800716 	blt	r3,r2,822d5d8 <cticks_hook+0x48>
      {
         cticks++;
 822d5bc:	d0a0a817 	ldw	r2,-32096(gp)
 822d5c0:	10800044 	addi	r2,r2,1
 822d5c4:	d0a0a815 	stw	r2,-32096(gp)
         cticks_factor -= OS_TPS;
 822d5c8:	d0e0a117 	ldw	r3,-32124(gp)
 822d5cc:	d0a0a217 	ldw	r2,-32120(gp)
 822d5d0:	1885c83a 	sub	r2,r3,r2
 822d5d4:	d0a0a115 	stw	r2,-32124(gp)
#ifdef USE_LCD
         update_display();
#endif
      }
   }
}
 822d5d8:	0001883a 	nop
 822d5dc:	e037883a 	mov	sp,fp
 822d5e0:	df000017 	ldw	fp,0(sp)
 822d5e4:	dec00104 	addi	sp,sp,4
 822d5e8:	f800283a 	ret

0822d5ec <irq_Mask>:
 * ENTER_CRIT_SECTION() and enable them in EXIT_CRIT_SECTION()
 * because calls to ENTER_CRIT_SECTION() can be nested."
 */
void
irq_Mask(void)
{
 822d5ec:	defffd04 	addi	sp,sp,-12
 822d5f0:	df000215 	stw	fp,8(sp)
 822d5f4:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 822d5f8:	0005303a 	rdctl	r2,status
 822d5fc:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 822d600:	e0ffff17 	ldw	r3,-4(fp)
 822d604:	00bfff84 	movi	r2,-2
 822d608:	1884703a 	and	r2,r3,r2
 822d60c:	1001703a 	wrctl	status,r2
  
  return context;
 822d610:	e0bfff17 	ldw	r2,-4(fp)
   alt_irq_context  local_cpu_statusreg;

   local_cpu_statusreg = alt_irq_disable_all();
 822d614:	e0bffe15 	stw	r2,-8(fp)
	
   if (++irq_level == 1)
 822d618:	d0a09e17 	ldw	r2,-32136(gp)
 822d61c:	10800044 	addi	r2,r2,1
 822d620:	d0a09e15 	stw	r2,-32136(gp)
 822d624:	d0a09e17 	ldw	r2,-32136(gp)
 822d628:	10800058 	cmpnei	r2,r2,1
 822d62c:	1000021e 	bne	r2,zero,822d638 <irq_Mask+0x4c>
   {
      cpu_statusreg = local_cpu_statusreg;
 822d630:	e0bffe17 	ldw	r2,-8(fp)
 822d634:	d0a09f15 	stw	r2,-32132(gp)
   }
}
 822d638:	0001883a 	nop
 822d63c:	e037883a 	mov	sp,fp
 822d640:	df000017 	ldw	fp,0(sp)
 822d644:	dec00104 	addi	sp,sp,4
 822d648:	f800283a 	ret

0822d64c <irq_Unmask>:


/* Re-Enable Interrupts */
void
irq_Unmask(void)
{
 822d64c:	defffe04 	addi	sp,sp,-8
 822d650:	df000115 	stw	fp,4(sp)
 822d654:	df000104 	addi	fp,sp,4
   if (--irq_level == 0)
 822d658:	d0a09e17 	ldw	r2,-32136(gp)
 822d65c:	10bfffc4 	addi	r2,r2,-1
 822d660:	d0a09e15 	stw	r2,-32136(gp)
 822d664:	d0a09e17 	ldw	r2,-32136(gp)
 822d668:	1000041e 	bne	r2,zero,822d67c <irq_Unmask+0x30>
   {
      alt_irq_enable_all(cpu_statusreg);
 822d66c:	d0a09f17 	ldw	r2,-32132(gp)
 822d670:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 822d674:	e0bfff17 	ldw	r2,-4(fp)
 822d678:	1001703a 	wrctl	status,r2
   }
}
 822d67c:	0001883a 	nop
 822d680:	e037883a 	mov	sp,fp
 822d684:	df000017 	ldw	fp,0(sp)
 822d688:	dec00104 	addi	sp,sp,4
 822d68c:	f800283a 	ret

0822d690 <LOCK_NET_RESOURCE>:
extern void irq_Mask(void);
extern void irq_Unmask(void);

void
LOCK_NET_RESOURCE(int resid)
{
 822d690:	defffb04 	addi	sp,sp,-20
 822d694:	dfc00415 	stw	ra,16(sp)
 822d698:	df000315 	stw	fp,12(sp)
 822d69c:	df000304 	addi	fp,sp,12
 822d6a0:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 822d6a4:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 822d6a8:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 822d6ac:	e0bfff17 	ldw	r2,-4(fp)
 822d6b0:	10002216 	blt	r2,zero,822d73c <LOCK_NET_RESOURCE+0xac>
 822d6b4:	e0bfff17 	ldw	r2,-4(fp)
 822d6b8:	10800408 	cmpgei	r2,r2,16
 822d6bc:	10001f1e 	bne	r2,zero,822d73c <LOCK_NET_RESOURCE+0xac>
   {
      do
      {
         OSSemPend(resid_semaphore[resid], 0, &error);
 822d6c0:	008209b4 	movhi	r2,2086
 822d6c4:	10b94b04 	addi	r2,r2,-6868
 822d6c8:	e0ffff17 	ldw	r3,-4(fp)
 822d6cc:	18c7883a 	add	r3,r3,r3
 822d6d0:	18c7883a 	add	r3,r3,r3
 822d6d4:	10c5883a 	add	r2,r2,r3
 822d6d8:	10800017 	ldw	r2,0(r2)
 822d6dc:	e0fffe04 	addi	r3,fp,-8
 822d6e0:	180d883a 	mov	r6,r3
 822d6e4:	000b883a 	mov	r5,zero
 822d6e8:	1009883a 	mov	r4,r2
 822d6ec:	821a0380 	call	821a038 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 822d6f0:	e0bffe03 	ldbu	r2,-8(fp)
 822d6f4:	10803fcc 	andi	r2,r2,255
 822d6f8:	10800298 	cmpnei	r2,r2,10
 822d6fc:	10000a1e 	bne	r2,zero,822d728 <LOCK_NET_RESOURCE+0x98>
 822d700:	e0bffd17 	ldw	r2,-12(fp)
 822d704:	10800044 	addi	r2,r2,1
 822d708:	e0bffd15 	stw	r2,-12(fp)
 822d70c:	e0bffd17 	ldw	r2,-12(fp)
 822d710:	1080fa50 	cmplti	r2,r2,1001
 822d714:	1000041e 	bne	r2,zero,822d728 <LOCK_NET_RESOURCE+0x98>
         {
            panic("lock NET");   /* fatal */
 822d718:	01020974 	movhi	r4,2085
 822d71c:	21029604 	addi	r4,r4,2648
 822d720:	8228aec0 	call	8228aec <panic>
 822d724:	00000606 	br	822d740 <LOCK_NET_RESOURCE+0xb0>
            return;
         }
      } while (error == 10);
 822d728:	e0bffe03 	ldbu	r2,-8(fp)
 822d72c:	10803fcc 	andi	r2,r2,255
 822d730:	108002a0 	cmpeqi	r2,r2,10
 822d734:	103fe21e 	bne	r2,zero,822d6c0 <LOCK_NET_RESOURCE+0x30>
LOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;
   int   errct = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 822d738:	00000106 	br	822d740 <LOCK_NET_RESOURCE+0xb0>
            return;
         }
      } while (error == 10);
   }
   else
      dtrap();
 822d73c:	822d4140 	call	822d414 <dtrap>
}
 822d740:	e037883a 	mov	sp,fp
 822d744:	dfc00117 	ldw	ra,4(sp)
 822d748:	df000017 	ldw	fp,0(sp)
 822d74c:	dec00204 	addi	sp,sp,8
 822d750:	f800283a 	ret

0822d754 <UNLOCK_NET_RESOURCE>:

void
UNLOCK_NET_RESOURCE(int resid)
{
 822d754:	defffc04 	addi	sp,sp,-16
 822d758:	dfc00315 	stw	ra,12(sp)
 822d75c:	df000215 	stw	fp,8(sp)
 822d760:	df000204 	addi	fp,sp,8
 822d764:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 822d768:	e03ffe05 	stb	zero,-8(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 822d76c:	e0bfff17 	ldw	r2,-4(fp)
 822d770:	10001316 	blt	r2,zero,822d7c0 <UNLOCK_NET_RESOURCE+0x6c>
 822d774:	e0bfff17 	ldw	r2,-4(fp)
 822d778:	10800408 	cmpgei	r2,r2,16
 822d77c:	1000101e 	bne	r2,zero,822d7c0 <UNLOCK_NET_RESOURCE+0x6c>
   {
      error = OSSemPost(resid_semaphore[resid]);
 822d780:	008209b4 	movhi	r2,2086
 822d784:	10b94b04 	addi	r2,r2,-6868
 822d788:	e0ffff17 	ldw	r3,-4(fp)
 822d78c:	18c7883a 	add	r3,r3,r3
 822d790:	18c7883a 	add	r3,r3,r3
 822d794:	10c5883a 	add	r2,r2,r3
 822d798:	10800017 	ldw	r2,0(r2)
 822d79c:	1009883a 	mov	r4,r2
 822d7a0:	821a3b00 	call	821a3b0 <OSSemPost>
 822d7a4:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 822d7a8:	e0bffe03 	ldbu	r2,-8(fp)
 822d7ac:	10000526 	beq	r2,zero,822d7c4 <UNLOCK_NET_RESOURCE+0x70>
      {
         panic("unlock NET");
 822d7b0:	01020974 	movhi	r4,2085
 822d7b4:	21029904 	addi	r4,r4,2660
 822d7b8:	8228aec0 	call	8228aec <panic>
   INT8U error = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
   {
      error = OSSemPost(resid_semaphore[resid]);
      if (error != OS_NO_ERR)
 822d7bc:	00000106 	br	822d7c4 <UNLOCK_NET_RESOURCE+0x70>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 822d7c0:	822d4140 	call	822d414 <dtrap>
}
 822d7c4:	0001883a 	nop
 822d7c8:	e037883a 	mov	sp,fp
 822d7cc:	dfc00117 	ldw	ra,4(sp)
 822d7d0:	df000017 	ldw	fp,0(sp)
 822d7d4:	dec00204 	addi	sp,sp,8
 822d7d8:	f800283a 	ret

0822d7dc <TK_NEWTASK>:
extern long     nettick_wakes;


int
TK_NEWTASK(struct inet_taskinfo * nettask)
{
 822d7dc:	deffee04 	addi	sp,sp,-72
 822d7e0:	dfc01115 	stw	ra,68(sp)
 822d7e4:	df001015 	stw	fp,64(sp)
 822d7e8:	df001004 	addi	fp,sp,64
 822d7ec:	e13fff15 	stw	r4,-4(fp)
   INT8U    error;
   OS_STK * stack;

   stack = (OS_STK*)npalloc(nettask->stacksize);
 822d7f0:	e0bfff17 	ldw	r2,-4(fp)
 822d7f4:	10800417 	ldw	r2,16(r2)
 822d7f8:	1009883a 	mov	r4,r2
 822d7fc:	822dfec0 	call	822dfec <npalloc>
 822d800:	e0bff515 	stw	r2,-44(fp)
   if(!stack)
 822d804:	e0bff517 	ldw	r2,-44(fp)
 822d808:	1000031e 	bne	r2,zero,822d818 <TK_NEWTASK+0x3c>
      panic("stack alloc");
 822d80c:	01020974 	movhi	r4,2085
 822d810:	21029c04 	addi	r4,r4,2672
 822d814:	8228aec0 	call	8228aec <panic>

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d818:	e0bfff17 	ldw	r2,-4(fp)
 822d81c:	12000217 	ldw	r8,8(r2)
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
 822d820:	e0bfff17 	ldw	r2,-4(fp)
 822d824:	10800417 	ldw	r2,16(r2)
 822d828:	1006d0ba 	srli	r3,r2,2
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d82c:	00900034 	movhi	r2,16384
 822d830:	10bfffc4 	addi	r2,r2,-1
 822d834:	1885883a 	add	r2,r3,r2
 822d838:	1085883a 	add	r2,r2,r2
 822d83c:	1085883a 	add	r2,r2,r2
 822d840:	1007883a 	mov	r3,r2
 822d844:	e0bff517 	ldw	r2,-44(fp)
 822d848:	10cb883a 	add	r5,r2,r3
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
 822d84c:	e0bfff17 	ldw	r2,-4(fp)
 822d850:	10800317 	ldw	r2,12(r2)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d854:	11803fcc 	andi	r6,r2,255
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
      nettask->priority,
 822d858:	e0bfff17 	ldw	r2,-4(fp)
 822d85c:	10800317 	ldw	r2,12(r2)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d860:	10bfffcc 	andi	r2,r2,65535
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
      nettask->priority,
      stack, 
      (INT32U)nettask->stacksize / sizeof(OS_STK),
 822d864:	e0ffff17 	ldw	r3,-4(fp)
 822d868:	18c00417 	ldw	r3,16(r3)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 822d86c:	1806d0ba 	srli	r3,r3,2
 822d870:	010000c4 	movi	r4,3
 822d874:	d9000415 	stw	r4,16(sp)
 822d878:	d8000315 	stw	zero,12(sp)
 822d87c:	d8c00215 	stw	r3,8(sp)
 822d880:	e0fff517 	ldw	r3,-44(fp)
 822d884:	d8c00115 	stw	r3,4(sp)
 822d888:	d8800015 	stw	r2,0(sp)
 822d88c:	300f883a 	mov	r7,r6
 822d890:	280d883a 	mov	r6,r5
 822d894:	000b883a 	mov	r5,zero
 822d898:	4009883a 	mov	r4,r8
 822d89c:	821ad6c0 	call	821ad6c <OSTaskCreateExt>
 822d8a0:	e0bff605 	stb	r2,-40(fp)
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority);
#endif
   /* If we go here, then there's another task using our priority */
   /* Tell the user and exit with an error */
   if (error == OS_PRIO_EXIST)
 822d8a4:	e0bff603 	ldbu	r2,-40(fp)
 822d8a8:	10803fcc 	andi	r2,r2,255
 822d8ac:	10800a18 	cmpnei	r2,r2,40
 822d8b0:	10001c1e 	bne	r2,zero,822d924 <TK_NEWTASK+0x148>
   { 
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, (INT8U*)curr_task, &err);
 822d8b4:	e0bfff17 	ldw	r2,-4(fp)
 822d8b8:	10800317 	ldw	r2,12(r2)
 822d8bc:	10803fcc 	andi	r2,r2,255
 822d8c0:	e13ff644 	addi	r4,fp,-39
 822d8c4:	e0fff684 	addi	r3,fp,-38
 822d8c8:	200d883a 	mov	r6,r4
 822d8cc:	180b883a 	mov	r5,r3
 822d8d0:	1009883a 	mov	r4,r2
 822d8d4:	821b3e40 	call	821b3e4 <OSTaskNameGet>
     curr_task[OS_TASK_NAME_SIZE-1]=0;
 822d8d8:	e03ffe45 	stb	zero,-7(fp)
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
 822d8dc:	e0bfff17 	ldw	r2,-4(fp)
 822d8e0:	10c00117 	ldw	r3,4(r2)
 822d8e4:	e0bfff17 	ldw	r2,-4(fp)
 822d8e8:	11000317 	ldw	r4,12(r2)
 822d8ec:	e0bfff17 	ldw	r2,-4(fp)
 822d8f0:	10800317 	ldw	r2,12(r2)
 822d8f4:	e17ff684 	addi	r5,fp,-38
 822d8f8:	d8800015 	stw	r2,0(sp)
 822d8fc:	280f883a 	mov	r7,r5
 822d900:	200d883a 	mov	r6,r4
 822d904:	180b883a 	mov	r5,r3
 822d908:	01020974 	movhi	r4,2085
 822d90c:	21029f04 	addi	r4,r4,2684
 822d910:	820331c0 	call	820331c <printf>
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
             
     printf("You may wish to check your task priority settings in "\
 822d914:	01020974 	movhi	r4,2085
 822d918:	2102b704 	addi	r4,r4,2780
 822d91c:	82035a00 	call	82035a0 <puts>
 822d920:	00002006 	br	822d9a4 <TK_NEWTASK+0x1c8>
            "\"<bsp path>\\iniche\\src\\h\\nios2\\ipport.h\" against "\
            "the priority settings in your application and recompile.\n\n");
   }
   else if (error == OS_PRIO_INVALID)
 822d924:	e0bff603 	ldbu	r2,-40(fp)
 822d928:	10803fcc 	andi	r2,r2,255
 822d92c:	10800a98 	cmpnei	r2,r2,42
 822d930:	10000e1e 	bne	r2,zero,822d96c <TK_NEWTASK+0x190>
   {
     printf("Priority requested for task \"%s\" (Prio:%d) exceeds "\
 822d934:	e0bfff17 	ldw	r2,-4(fp)
 822d938:	10c00117 	ldw	r3,4(r2)
 822d93c:	e0bfff17 	ldw	r2,-4(fp)
 822d940:	10800317 	ldw	r2,12(r2)
 822d944:	01c00504 	movi	r7,20
 822d948:	100d883a 	mov	r6,r2
 822d94c:	180b883a 	mov	r5,r3
 822d950:	01020974 	movhi	r4,2085
 822d954:	2102df04 	addi	r4,r4,2940
 822d958:	820331c0 	call	820331c <printf>
            "available priority levels in the system (OS_LOWEST_PRIO = %d)\n\n",
             nettask->name, nettask->priority, OS_LOWEST_PRIO);
             
     printf("Please modify the tasks priority level, or modify the "\
 822d95c:	01020974 	movhi	r4,2085
 822d960:	2102fc04 	addi	r4,r4,3056
 822d964:	82035a00 	call	82035a0 <puts>
 822d968:	00000e06 	br	822d9a4 <TK_NEWTASK+0x1c8>
            "\"Lowest assignable priority\" setting in the MicroC/OS-II "\
            "component\n");
   }
   else if (error != OS_NO_ERR)
 822d96c:	e0bff603 	ldbu	r2,-40(fp)
 822d970:	10803fcc 	andi	r2,r2,255
 822d974:	10000b26 	beq	r2,zero,822d9a4 <TK_NEWTASK+0x1c8>
   {                          /* All other errors are fatal */
      printf("Task create error /(MicroC/OS-II error code:%d/) on %s\n",
 822d978:	e0bff603 	ldbu	r2,-40(fp)
 822d97c:	10c03fcc 	andi	r3,r2,255
 822d980:	e0bfff17 	ldw	r2,-4(fp)
 822d984:	10800117 	ldw	r2,4(r2)
 822d988:	100d883a 	mov	r6,r2
 822d98c:	180b883a 	mov	r5,r3
 822d990:	01020974 	movhi	r4,2085
 822d994:	21031b04 	addi	r4,r4,3180
 822d998:	820331c0 	call	820331c <printf>
             error, nettask->name);
      return (-1);
 822d99c:	00bfffc4 	movi	r2,-1
 822d9a0:	00001c06 	br	822da14 <TK_NEWTASK+0x238>
   }

   /* Include the task name, so that uc/osII (os aware) debuggers can
    * display it.
    */
   OSTaskNameSet(nettask->priority, (INT8U*)&nettask->name[0], &error);
 822d9a4:	e0bfff17 	ldw	r2,-4(fp)
 822d9a8:	10800317 	ldw	r2,12(r2)
 822d9ac:	10c03fcc 	andi	r3,r2,255
 822d9b0:	e0bfff17 	ldw	r2,-4(fp)
 822d9b4:	10800117 	ldw	r2,4(r2)
 822d9b8:	e13ff604 	addi	r4,fp,-40
 822d9bc:	200d883a 	mov	r6,r4
 822d9c0:	100b883a 	mov	r5,r2
 822d9c4:	1809883a 	mov	r4,r3
 822d9c8:	821b57c0 	call	821b57c <OSTaskNameSet>

   nettask->stackbase = (char*)stack;
 822d9cc:	e0bfff17 	ldw	r2,-4(fp)
 822d9d0:	e0fff517 	ldw	r3,-44(fp)
 822d9d4:	10c00515 	stw	r3,20(r2)
   *nettask->tk_ptr = (INT8U)nettask->priority;  
 822d9d8:	e0bfff17 	ldw	r2,-4(fp)
 822d9dc:	10800017 	ldw	r2,0(r2)
 822d9e0:	e0ffff17 	ldw	r3,-4(fp)
 822d9e4:	18c00317 	ldw	r3,12(r3)
 822d9e8:	10c00005 	stb	r3,0(r2)

   printf("Created \"%s\" task (Prio: %d)\n",
 822d9ec:	e0bfff17 	ldw	r2,-4(fp)
 822d9f0:	10c00117 	ldw	r3,4(r2)
 822d9f4:	e0bfff17 	ldw	r2,-4(fp)
 822d9f8:	10800317 	ldw	r2,12(r2)
 822d9fc:	100d883a 	mov	r6,r2
 822da00:	180b883a 	mov	r5,r3
 822da04:	01020974 	movhi	r4,2085
 822da08:	21032904 	addi	r4,r4,3236
 822da0c:	820331c0 	call	820331c <printf>
         (char *)nettask->name, nettask->priority);

   return (0);
 822da10:	0005883a 	mov	r2,zero
}
 822da14:	e037883a 	mov	sp,fp
 822da18:	dfc00117 	ldw	ra,4(sp)
 822da1c:	df000017 	ldw	fp,0(sp)
 822da20:	dec00204 	addi	sp,sp,8
 822da24:	f800283a 	ret

0822da28 <wait_app_sem>:
 * event (e.g., configuration inputs from user, initiation of a new session,
 * or a periodic timeout notification.
 */
void
wait_app_sem(unsigned long semid)
{
 822da28:	defffb04 	addi	sp,sp,-20
 822da2c:	dfc00415 	stw	ra,16(sp)
 822da30:	df000315 	stw	fp,12(sp)
 822da34:	df000304 	addi	fp,sp,12
 822da38:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 822da3c:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 822da40:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= semid) && (semid <= MAX_SEMID))
 822da44:	e0bfff17 	ldw	r2,-4(fp)
 822da48:	108001a8 	cmpgeui	r2,r2,6
 822da4c:	10001f1e 	bne	r2,zero,822dacc <wait_app_sem+0xa4>
   {
      do
      {
         OSSemPend(app_semaphore[semid], 0, &error);
 822da50:	008209b4 	movhi	r2,2086
 822da54:	10b95b04 	addi	r2,r2,-6804
 822da58:	e0ffff17 	ldw	r3,-4(fp)
 822da5c:	18c7883a 	add	r3,r3,r3
 822da60:	18c7883a 	add	r3,r3,r3
 822da64:	10c5883a 	add	r2,r2,r3
 822da68:	10800017 	ldw	r2,0(r2)
 822da6c:	e0fffe04 	addi	r3,fp,-8
 822da70:	180d883a 	mov	r6,r3
 822da74:	000b883a 	mov	r5,zero
 822da78:	1009883a 	mov	r4,r2
 822da7c:	821a0380 	call	821a038 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 822da80:	e0bffe03 	ldbu	r2,-8(fp)
 822da84:	10803fcc 	andi	r2,r2,255
 822da88:	10800298 	cmpnei	r2,r2,10
 822da8c:	10000a1e 	bne	r2,zero,822dab8 <wait_app_sem+0x90>
 822da90:	e0bffd17 	ldw	r2,-12(fp)
 822da94:	10800044 	addi	r2,r2,1
 822da98:	e0bffd15 	stw	r2,-12(fp)
 822da9c:	e0bffd17 	ldw	r2,-12(fp)
 822daa0:	1080fa50 	cmplti	r2,r2,1001
 822daa4:	1000041e 	bne	r2,zero,822dab8 <wait_app_sem+0x90>
         {
            panic("lock NET");   /* fatal */
 822daa8:	01020974 	movhi	r4,2085
 822daac:	21029604 	addi	r4,r4,2648
 822dab0:	8228aec0 	call	8228aec <panic>
 822dab4:	00000606 	br	822dad0 <wait_app_sem+0xa8>
            return;
         }
      } while (error == 10);
 822dab8:	e0bffe03 	ldbu	r2,-8(fp)
 822dabc:	10803fcc 	andi	r2,r2,255
 822dac0:	108002a0 	cmpeqi	r2,r2,10
 822dac4:	103fe21e 	bne	r2,zero,822da50 <wait_app_sem+0x28>
 822dac8:	00000106 	br	822dad0 <wait_app_sem+0xa8>
   }
   else
      dtrap();
 822dacc:	822d4140 	call	822d414 <dtrap>
}
 822dad0:	e037883a 	mov	sp,fp
 822dad4:	dfc00117 	ldw	ra,4(sp)
 822dad8:	df000017 	ldw	fp,0(sp)
 822dadc:	dec00204 	addi	sp,sp,8
 822dae0:	f800283a 	ret

0822dae4 <post_app_sem>:
 * notification. It signals the corresponding application event.
 */

void
post_app_sem(unsigned long semid)
{
 822dae4:	defffc04 	addi	sp,sp,-16
 822dae8:	dfc00315 	stw	ra,12(sp)
 822daec:	df000215 	stw	fp,8(sp)
 822daf0:	df000204 	addi	fp,sp,8
 822daf4:	e13fff15 	stw	r4,-4(fp)
   INT8U error;

   if ((0 <= semid) && (semid <= MAX_SEMID))
 822daf8:	e0bfff17 	ldw	r2,-4(fp)
 822dafc:	108001a8 	cmpgeui	r2,r2,6
 822db00:	1000101e 	bne	r2,zero,822db44 <post_app_sem+0x60>
   {
      error = OSSemPost(app_semaphore[semid]);
 822db04:	008209b4 	movhi	r2,2086
 822db08:	10b95b04 	addi	r2,r2,-6804
 822db0c:	e0ffff17 	ldw	r3,-4(fp)
 822db10:	18c7883a 	add	r3,r3,r3
 822db14:	18c7883a 	add	r3,r3,r3
 822db18:	10c5883a 	add	r2,r2,r3
 822db1c:	10800017 	ldw	r2,0(r2)
 822db20:	1009883a 	mov	r4,r2
 822db24:	821a3b00 	call	821a3b0 <OSSemPost>
 822db28:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 822db2c:	e0bffe03 	ldbu	r2,-8(fp)
 822db30:	10000526 	beq	r2,zero,822db48 <post_app_sem+0x64>
      {
         panic("unlock NET");
 822db34:	01020974 	movhi	r4,2085
 822db38:	21029904 	addi	r4,r4,2660
 822db3c:	8228aec0 	call	8228aec <panic>
      }
   }
   else
      dtrap();
}
 822db40:	00000106 	br	822db48 <post_app_sem+0x64>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 822db44:	822d4140 	call	822d414 <dtrap>
}
 822db48:	0001883a 	nop
 822db4c:	e037883a 	mov	sp,fp
 822db50:	dfc00117 	ldw	ra,4(sp)
 822db54:	df000017 	ldw	fp,0(sp)
 822db58:	dec00204 	addi	sp,sp,8
 822db5c:	f800283a 	ret

0822db60 <alt_iniche_init>:
#ifndef SUPERLOOP

extern OS_EVENT *resid_semaphore[MAX_RESID+1];

void alt_iniche_init(void)
{
 822db60:	defffd04 	addi	sp,sp,-12
 822db64:	dfc00215 	stw	ra,8(sp)
 822db68:	df000115 	stw	fp,4(sp)
 822db6c:	df000104 	addi	fp,sp,4
   int i;

   /* initialize the npalloc() heap semaphore */
   mheap_sem_ptr = OSSemCreate(1);
 822db70:	01000044 	movi	r4,1
 822db74:	8219d200 	call	8219d20 <OSSemCreate>
 822db78:	d0a0aa15 	stw	r2,-32088(gp)
   if (!mheap_sem_ptr)
 822db7c:	d0a0aa17 	ldw	r2,-32088(gp)
 822db80:	1000031e 	bne	r2,zero,822db90 <alt_iniche_init+0x30>
      panic("mheap_sem_ptr create err"); 
 822db84:	01020974 	movhi	r4,2085
 822db88:	21033104 	addi	r4,r4,3268
 822db8c:	8228aec0 	call	8228aec <panic>

   rcvdq_sem_ptr = OSSemCreate(0);
 822db90:	0009883a 	mov	r4,zero
 822db94:	8219d200 	call	8219d20 <OSSemCreate>
 822db98:	d0a0ab15 	stw	r2,-32084(gp)
   if (!rcvdq_sem_ptr)
 822db9c:	d0a0ab17 	ldw	r2,-32084(gp)
 822dba0:	1000031e 	bne	r2,zero,822dbb0 <alt_iniche_init+0x50>
      panic("rcvdq_sem_ptr create err"); 
 822dba4:	01020974 	movhi	r4,2085
 822dba8:	21033804 	addi	r4,r4,3296
 822dbac:	8228aec0 	call	8228aec <panic>

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 822dbb0:	e03fff15 	stw	zero,-4(fp)
 822dbb4:	00001806 	br	822dc18 <alt_iniche_init+0xb8>
   {
      resid_semaphore[i] = OSSemCreate(1);
 822dbb8:	01000044 	movi	r4,1
 822dbbc:	8219d200 	call	8219d20 <OSSemCreate>
 822dbc0:	1009883a 	mov	r4,r2
 822dbc4:	008209b4 	movhi	r2,2086
 822dbc8:	10b94b04 	addi	r2,r2,-6868
 822dbcc:	e0ffff17 	ldw	r3,-4(fp)
 822dbd0:	18c7883a 	add	r3,r3,r3
 822dbd4:	18c7883a 	add	r3,r3,r3
 822dbd8:	10c5883a 	add	r2,r2,r3
 822dbdc:	11000015 	stw	r4,0(r2)
      if (!resid_semaphore[i])
 822dbe0:	008209b4 	movhi	r2,2086
 822dbe4:	10b94b04 	addi	r2,r2,-6868
 822dbe8:	e0ffff17 	ldw	r3,-4(fp)
 822dbec:	18c7883a 	add	r3,r3,r3
 822dbf0:	18c7883a 	add	r3,r3,r3
 822dbf4:	10c5883a 	add	r2,r2,r3
 822dbf8:	10800017 	ldw	r2,0(r2)
 822dbfc:	1000031e 	bne	r2,zero,822dc0c <alt_iniche_init+0xac>
         panic("resid_semaphore create err");  
 822dc00:	01020974 	movhi	r4,2085
 822dc04:	21033f04 	addi	r4,r4,3324
 822dc08:	8228aec0 	call	8228aec <panic>
   rcvdq_sem_ptr = OSSemCreate(0);
   if (!rcvdq_sem_ptr)
      panic("rcvdq_sem_ptr create err"); 

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 822dc0c:	e0bfff17 	ldw	r2,-4(fp)
 822dc10:	10800044 	addi	r2,r2,1
 822dc14:	e0bfff15 	stw	r2,-4(fp)
 822dc18:	e0bfff17 	ldw	r2,-4(fp)
 822dc1c:	10800410 	cmplti	r2,r2,16
 822dc20:	103fe51e 	bne	r2,zero,822dbb8 <alt_iniche_init+0x58>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 822dc24:	e03fff15 	stw	zero,-4(fp)
 822dc28:	00001806 	br	822dc8c <alt_iniche_init+0x12c>
   {
      app_semaphore[i] = OSSemCreate(1);
 822dc2c:	01000044 	movi	r4,1
 822dc30:	8219d200 	call	8219d20 <OSSemCreate>
 822dc34:	1009883a 	mov	r4,r2
 822dc38:	008209b4 	movhi	r2,2086
 822dc3c:	10b95b04 	addi	r2,r2,-6804
 822dc40:	e0ffff17 	ldw	r3,-4(fp)
 822dc44:	18c7883a 	add	r3,r3,r3
 822dc48:	18c7883a 	add	r3,r3,r3
 822dc4c:	10c5883a 	add	r2,r2,r3
 822dc50:	11000015 	stw	r4,0(r2)
      if (!app_semaphore[i])
 822dc54:	008209b4 	movhi	r2,2086
 822dc58:	10b95b04 	addi	r2,r2,-6804
 822dc5c:	e0ffff17 	ldw	r3,-4(fp)
 822dc60:	18c7883a 	add	r3,r3,r3
 822dc64:	18c7883a 	add	r3,r3,r3
 822dc68:	10c5883a 	add	r2,r2,r3
 822dc6c:	10800017 	ldw	r2,0(r2)
 822dc70:	1000031e 	bne	r2,zero,822dc80 <alt_iniche_init+0x120>
         panic("app_semaphore create err");  
 822dc74:	01020974 	movhi	r4,2085
 822dc78:	21034604 	addi	r4,r4,3352
 822dc7c:	8228aec0 	call	8228aec <panic>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 822dc80:	e0bfff17 	ldw	r2,-4(fp)
 822dc84:	10800044 	addi	r2,r2,1
 822dc88:	e0bfff15 	stw	r2,-4(fp)
 822dc8c:	e0bfff17 	ldw	r2,-4(fp)
 822dc90:	10800190 	cmplti	r2,r2,6
 822dc94:	103fe51e 	bne	r2,zero,822dc2c <alt_iniche_init+0xcc>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 822dc98:	e03fff15 	stw	zero,-4(fp)
 822dc9c:	00002506 	br	822dd34 <alt_iniche_init+0x1d4>
   {
      global_TCPwakeup_set[i].ctick = 0;
 822dca0:	008209b4 	movhi	r2,2086
 822dca4:	10b90f04 	addi	r2,r2,-7108
 822dca8:	e0ffff17 	ldw	r3,-4(fp)
 822dcac:	18c00324 	muli	r3,r3,12
 822dcb0:	10c5883a 	add	r2,r2,r3
 822dcb4:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].soc_event = NULL;
 822dcb8:	008209b4 	movhi	r2,2086
 822dcbc:	10b90f04 	addi	r2,r2,-7108
 822dcc0:	e0ffff17 	ldw	r3,-4(fp)
 822dcc4:	18c00324 	muli	r3,r3,12
 822dcc8:	10c5883a 	add	r2,r2,r3
 822dccc:	10800104 	addi	r2,r2,4
 822dcd0:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
 822dcd4:	0009883a 	mov	r4,zero
 822dcd8:	8219d200 	call	8219d20 <OSSemCreate>
 822dcdc:	1009883a 	mov	r4,r2
 822dce0:	008209b4 	movhi	r2,2086
 822dce4:	10b90f04 	addi	r2,r2,-7108
 822dce8:	e0ffff17 	ldw	r3,-4(fp)
 822dcec:	18c00324 	muli	r3,r3,12
 822dcf0:	10c5883a 	add	r2,r2,r3
 822dcf4:	10800204 	addi	r2,r2,8
 822dcf8:	11000015 	stw	r4,0(r2)
      if (!global_TCPwakeup_set[i].semaphore)
 822dcfc:	008209b4 	movhi	r2,2086
 822dd00:	10b90f04 	addi	r2,r2,-7108
 822dd04:	e0ffff17 	ldw	r3,-4(fp)
 822dd08:	18c00324 	muli	r3,r3,12
 822dd0c:	10c5883a 	add	r2,r2,r3
 822dd10:	10800204 	addi	r2,r2,8
 822dd14:	10800017 	ldw	r2,0(r2)
 822dd18:	1000031e 	bne	r2,zero,822dd28 <alt_iniche_init+0x1c8>
         panic("globwake_semaphore create err");  
 822dd1c:	01020974 	movhi	r4,2085
 822dd20:	21034d04 	addi	r4,r4,3380
 822dd24:	8228aec0 	call	8228aec <panic>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 822dd28:	e0bfff17 	ldw	r2,-4(fp)
 822dd2c:	10800044 	addi	r2,r2,1
 822dd30:	e0bfff15 	stw	r2,-4(fp)
 822dd34:	e0bfff17 	ldw	r2,-4(fp)
 822dd38:	10800510 	cmplti	r2,r2,20
 822dd3c:	103fd81e 	bne	r2,zero,822dca0 <alt_iniche_init+0x140>
      global_TCPwakeup_set[i].soc_event = NULL;
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
      if (!global_TCPwakeup_set[i].semaphore)
         panic("globwake_semaphore create err");  
   }
   global_TCPwakeup_setIndx = 0;
 822dd40:	d020a715 	stw	zero,-32100(gp)
#endif  /* TCPWAKE_RTOS */
}
 822dd44:	0001883a 	nop
 822dd48:	e037883a 	mov	sp,fp
 822dd4c:	dfc00117 	ldw	ra,4(sp)
 822dd50:	df000017 	ldw	fp,0(sp)
 822dd54:	dec00204 	addi	sp,sp,8
 822dd58:	f800283a 	ret

0822dd5c <pre_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
pre_task_setup()
{
 822dd5c:	deffff04 	addi	sp,sp,-4
 822dd60:	df000015 	stw	fp,0(sp)
 822dd64:	d839883a 	mov	fp,sp
   write_leds(0);
   write_7seg_raw(0x0000);
#endif

   /* preset buffer counts; may be overridden from command line */
   bigbufs = MAXBIGPKTS;
 822dd68:	00800784 	movi	r2,30
 822dd6c:	d0a03815 	stw	r2,-32544(gp)
   lilbufs = MAXLILPKTS;
 822dd70:	00800784 	movi	r2,30
 822dd74:	d0a03615 	stw	r2,-32552(gp)
   bigbufsiz = BIGBUFSIZE;
 822dd78:	00818004 	movi	r2,1536
 822dd7c:	d0a03915 	stw	r2,-32540(gp)
   lilbufsiz = LILBUFSIZE;
 822dd80:	00802004 	movi	r2,128
 822dd84:	d0a03715 	stw	r2,-32548(gp)

   /* Install callback to prep_armintcp from prep_ifaces() */
   port_prep = prep_armintcp;
 822dd88:	008208f4 	movhi	r2,2083
 822dd8c:	10b77204 	addi	r2,r2,-8760
 822dd90:	d0a0ca15 	stw	r2,-31960(gp)
#endif   /* NOTDEF */

#endif   /* USE_PPP */


   return NULL;
 822dd94:	0005883a 	mov	r2,zero
}
 822dd98:	e037883a 	mov	sp,fp
 822dd9c:	df000017 	ldw	fp,0(sp)
 822dda0:	dec00104 	addi	sp,sp,4
 822dda4:	f800283a 	ret

0822dda8 <post_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
post_task_setup()
{
 822dda8:	deffff04 	addi	sp,sp,-4
 822ddac:	df000015 	stw	fp,0(sp)
 822ddb0:	d839883a 	mov	fp,sp
   return NULL;
 822ddb4:	0005883a 	mov	r2,zero
}
 822ddb8:	e037883a 	mov	sp,fp
 822ddbc:	df000017 	ldw	fp,0(sp)
 822ddc0:	dec00104 	addi	sp,sp,4
 822ddc4:	f800283a 	ret

0822ddc8 <prep_armintcp>:

#endif  /* INCLUDE_NVPARMS */

int 
prep_armintcp(int ifaces_found)
{
 822ddc8:	defffd04 	addi	sp,sp,-12
 822ddcc:	dfc00215 	stw	ra,8(sp)
 822ddd0:	df000115 	stw	fp,4(sp)
 822ddd4:	df000104 	addi	fp,sp,4
 822ddd8:	e13fff15 	stw	r4,-4(fp)
 * Call iniche_devices_init, in alt_iniche_dev.c, 
 * to step through all devices and all their respective
 * low-level initialization routines.
 */
#ifdef ALT_INICHE
   ifaces_found = iniche_devices_init(ifaces_found);
 822dddc:	e13fff17 	ldw	r4,-4(fp)
 822dde0:	82257bc0 	call	82257bc <iniche_devices_init>
 822dde4:	e0bfff15 	stw	r2,-4(fp)

#ifdef USE_SLIP
   ifaces_found = prep_slip(ifaces_found);
#endif

   return ifaces_found;
 822dde8:	e0bfff17 	ldw	r2,-4(fp)
}
 822ddec:	e037883a 	mov	sp,fp
 822ddf0:	dfc00117 	ldw	ra,4(sp)
 822ddf4:	df000017 	ldw	fp,0(sp)
 822ddf8:	dec00204 	addi	sp,sp,8
 822ddfc:	f800283a 	ret

0822de00 <npalloc_base>:
#endif


char *
npalloc_base(unsigned size, int cacheable)
{
 822de00:	defff804 	addi	sp,sp,-32
 822de04:	dfc00715 	stw	ra,28(sp)
 822de08:	df000615 	stw	fp,24(sp)
 822de0c:	df000604 	addi	fp,sp,24
 822de10:	e13ffe15 	stw	r4,-8(fp)
 822de14:	e17fff15 	stw	r5,-4(fp)
char * ptr;
void *(*alloc_rtn)(size_t size) = cacheable ? malloc : alt_uncached_malloc;
 822de18:	e0bfff17 	ldw	r2,-4(fp)
 822de1c:	10000326 	beq	r2,zero,822de2c <npalloc_base+0x2c>
 822de20:	00820974 	movhi	r2,2085
 822de24:	10ada404 	addi	r2,r2,-18800
 822de28:	00000206 	br	822de34 <npalloc_base+0x34>
 822de2c:	00820934 	movhi	r2,2084
 822de30:	10b20f04 	addi	r2,r2,-14276
 822de34:	e0bffb15 	stw	r2,-20(fp)
#ifdef UCOS_II
   INT8U err;
#endif

#ifdef UCOS_II
   OSSemPend(mheap_sem_ptr, 0, &err);
 822de38:	d0a0aa17 	ldw	r2,-32088(gp)
 822de3c:	e0fffd04 	addi	r3,fp,-12
 822de40:	180d883a 	mov	r6,r3
 822de44:	000b883a 	mov	r5,zero
 822de48:	1009883a 	mov	r4,r2
 822de4c:	821a0380 	call	821a038 <OSSemPend>
   if(err)
 822de50:	e0bffd03 	ldbu	r2,-12(fp)
 822de54:	10803fcc 	andi	r2,r2,255
 822de58:	10001626 	beq	r2,zero,822deb4 <npalloc_base+0xb4>
   {
      int errct = 0;
 822de5c:	e03ffa15 	stw	zero,-24(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 822de60:	00001006 	br	822dea4 <npalloc_base+0xa4>
      {
         if(errct++ > 1000)
 822de64:	e0bffa17 	ldw	r2,-24(fp)
 822de68:	10c00044 	addi	r3,r2,1
 822de6c:	e0fffa15 	stw	r3,-24(fp)
 822de70:	1080fa50 	cmplti	r2,r2,1001
 822de74:	1000051e 	bne	r2,zero,822de8c <npalloc_base+0x8c>
         {
            panic("npalloc");    /* fatal? */
 822de78:	01020974 	movhi	r4,2085
 822de7c:	21035504 	addi	r4,r4,3412
 822de80:	8228aec0 	call	8228aec <panic>
            return NULL;
 822de84:	0005883a 	mov	r2,zero
 822de88:	00001b06 	br	822def8 <npalloc_base+0xf8>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 822de8c:	d0a0aa17 	ldw	r2,-32088(gp)
 822de90:	e0fffd04 	addi	r3,fp,-12
 822de94:	180d883a 	mov	r6,r3
 822de98:	000b883a 	mov	r5,zero
 822de9c:	1009883a 	mov	r4,r2
 822dea0:	821a0380 	call	821a038 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 822dea4:	e0bffd03 	ldbu	r2,-12(fp)
 822dea8:	10803fcc 	andi	r2,r2,255
 822deac:	108002a0 	cmpeqi	r2,r2,10
 822deb0:	103fec1e 	bne	r2,zero,822de64 <npalloc_base+0x64>
#endif

#ifdef   MEM_WRAPPERS
   ptr = wrap_alloc(size, alloc_rtn);
#else
   ptr = (*alloc_rtn)(size);
 822deb4:	e0bffb17 	ldw	r2,-20(fp)
 822deb8:	e13ffe17 	ldw	r4,-8(fp)
 822debc:	103ee83a 	callr	r2
 822dec0:	e0bffc15 	stw	r2,-16(fp)
#endif

#ifdef UCOS_II 
   err = OSSemPost(mheap_sem_ptr);
 822dec4:	d0a0aa17 	ldw	r2,-32088(gp)
 822dec8:	1009883a 	mov	r4,r2
 822decc:	821a3b00 	call	821a3b0 <OSSemPost>
 822ded0:	e0bffd05 	stb	r2,-12(fp)
#endif
   
   if(!ptr)
 822ded4:	e0bffc17 	ldw	r2,-16(fp)
 822ded8:	1000021e 	bne	r2,zero,822dee4 <npalloc_base+0xe4>
      return NULL;
 822dedc:	0005883a 	mov	r2,zero
 822dee0:	00000506 	br	822def8 <npalloc_base+0xf8>

   MEMSET(ptr, 0, size);
 822dee4:	e1bffe17 	ldw	r6,-8(fp)
 822dee8:	000b883a 	mov	r5,zero
 822deec:	e13ffc17 	ldw	r4,-16(fp)
 822def0:	82031300 	call	8203130 <memset>
   return ptr;      
 822def4:	e0bffc17 	ldw	r2,-16(fp)
}
 822def8:	e037883a 	mov	sp,fp
 822defc:	dfc00117 	ldw	ra,4(sp)
 822df00:	df000017 	ldw	fp,0(sp)
 822df04:	dec00204 	addi	sp,sp,8
 822df08:	f800283a 	ret

0822df0c <npfree_base>:

void
npfree_base(void *ptr, int cacheable)
{
 822df0c:	defff904 	addi	sp,sp,-28
 822df10:	dfc00615 	stw	ra,24(sp)
 822df14:	df000515 	stw	fp,20(sp)
 822df18:	df000504 	addi	fp,sp,20
 822df1c:	e13ffe15 	stw	r4,-8(fp)
 822df20:	e17fff15 	stw	r5,-4(fp)
   void (*free_rtn)(void *ptr) = cacheable ? free : alt_uncached_free;
 822df24:	e0bfff17 	ldw	r2,-4(fp)
 822df28:	10000326 	beq	r2,zero,822df38 <npfree_base+0x2c>
 822df2c:	00820974 	movhi	r2,2085
 822df30:	10ada904 	addi	r2,r2,-18780
 822df34:	00000206 	br	822df40 <npfree_base+0x34>
 822df38:	00820934 	movhi	r2,2084
 822df3c:	10b1fe04 	addi	r2,r2,-14344
 822df40:	e0bffc15 	stw	r2,-16(fp)
#ifdef UCOS_II
   INT8U err;

   OSSemPend(mheap_sem_ptr, 0, &err);
 822df44:	d0a0aa17 	ldw	r2,-32088(gp)
 822df48:	e0fffd04 	addi	r3,fp,-12
 822df4c:	180d883a 	mov	r6,r3
 822df50:	000b883a 	mov	r5,zero
 822df54:	1009883a 	mov	r4,r2
 822df58:	821a0380 	call	821a038 <OSSemPend>
   if (err)
 822df5c:	e0bffd03 	ldbu	r2,-12(fp)
 822df60:	10803fcc 	andi	r2,r2,255
 822df64:	10001526 	beq	r2,zero,822dfbc <npfree_base+0xb0>
   {
      int errct = 0;
 822df68:	e03ffb15 	stw	zero,-20(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 822df6c:	00000f06 	br	822dfac <npfree_base+0xa0>
      {
         if (errct++ > 1000)
 822df70:	e0bffb17 	ldw	r2,-20(fp)
 822df74:	10c00044 	addi	r3,r2,1
 822df78:	e0fffb15 	stw	r3,-20(fp)
 822df7c:	1080fa50 	cmplti	r2,r2,1001
 822df80:	1000041e 	bne	r2,zero,822df94 <npfree_base+0x88>
         {
            panic("npfree");    /* fatal? */
 822df84:	01020974 	movhi	r4,2085
 822df88:	21035704 	addi	r4,r4,3420
 822df8c:	8228aec0 	call	8228aec <panic>
            return;
 822df90:	00001106 	br	822dfd8 <npfree_base+0xcc>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 822df94:	d0a0aa17 	ldw	r2,-32088(gp)
 822df98:	e0fffd04 	addi	r3,fp,-12
 822df9c:	180d883a 	mov	r6,r3
 822dfa0:	000b883a 	mov	r5,zero
 822dfa4:	1009883a 	mov	r4,r2
 822dfa8:	821a0380 	call	821a038 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 822dfac:	e0bffd03 	ldbu	r2,-12(fp)
 822dfb0:	10803fcc 	andi	r2,r2,255
 822dfb4:	108002a0 	cmpeqi	r2,r2,10
 822dfb8:	103fed1e 	bne	r2,zero,822df70 <npfree_base+0x64>
   }
   
#ifdef   MEM_WRAPPERS
   wrap_free((char*)ptr, free_rtn);
#else
   (*free_rtn)(ptr);
 822dfbc:	e0bffc17 	ldw	r2,-16(fp)
 822dfc0:	e13ffe17 	ldw	r4,-8(fp)
 822dfc4:	103ee83a 	callr	r2
#endif

   err = OSSemPost(mheap_sem_ptr);
 822dfc8:	d0a0aa17 	ldw	r2,-32088(gp)
 822dfcc:	1009883a 	mov	r4,r2
 822dfd0:	821a3b00 	call	821a3b0 <OSSemPost>
 822dfd4:	e0bffd05 	stb	r2,-12(fp)
#else
   (*free_rtn)(ptr);
#endif
#endif

}
 822dfd8:	e037883a 	mov	sp,fp
 822dfdc:	dfc00117 	ldw	ra,4(sp)
 822dfe0:	df000017 	ldw	fp,0(sp)
 822dfe4:	dec00204 	addi	sp,sp,8
 822dfe8:	f800283a 	ret

0822dfec <npalloc>:

char *
npalloc(unsigned size)
{
 822dfec:	defffd04 	addi	sp,sp,-12
 822dff0:	dfc00215 	stw	ra,8(sp)
 822dff4:	df000115 	stw	fp,4(sp)
 822dff8:	df000104 	addi	fp,sp,4
 822dffc:	e13fff15 	stw	r4,-4(fp)
   return npalloc_base(size, 1);
 822e000:	01400044 	movi	r5,1
 822e004:	e13fff17 	ldw	r4,-4(fp)
 822e008:	822de000 	call	822de00 <npalloc_base>
}
 822e00c:	e037883a 	mov	sp,fp
 822e010:	dfc00117 	ldw	ra,4(sp)
 822e014:	df000017 	ldw	fp,0(sp)
 822e018:	dec00204 	addi	sp,sp,8
 822e01c:	f800283a 	ret

0822e020 <npfree>:

void
npfree(void *ptr)
{
 822e020:	defffd04 	addi	sp,sp,-12
 822e024:	dfc00215 	stw	ra,8(sp)
 822e028:	df000115 	stw	fp,4(sp)
 822e02c:	df000104 	addi	fp,sp,4
 822e030:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 822e034:	e0bfff17 	ldw	r2,-4(fp)
 822e038:	10000326 	beq	r2,zero,822e048 <npfree+0x28>
      npfree_base(ptr, 1);
 822e03c:	01400044 	movi	r5,1
 822e040:	e13fff17 	ldw	r4,-4(fp)
 822e044:	822df0c0 	call	822df0c <npfree_base>
   }
}
 822e048:	0001883a 	nop
 822e04c:	e037883a 	mov	sp,fp
 822e050:	dfc00117 	ldw	ra,4(sp)
 822e054:	df000017 	ldw	fp,0(sp)
 822e058:	dec00204 	addi	sp,sp,8
 822e05c:	f800283a 	ret

0822e060 <ncpalloc>:
 * contains macro definitions that assign specific memory
 * allocation calls to these routines.
 */
#ifdef ALT_INICHE
char * ncpalloc(unsigned size)
{
 822e060:	defffd04 	addi	sp,sp,-12
 822e064:	dfc00215 	stw	ra,8(sp)
 822e068:	df000115 	stw	fp,4(sp)
 822e06c:	df000104 	addi	fp,sp,4
 822e070:	e13fff15 	stw	r4,-4(fp)
   return npalloc_base(size, 0);
 822e074:	000b883a 	mov	r5,zero
 822e078:	e13fff17 	ldw	r4,-4(fp)
 822e07c:	822de000 	call	822de00 <npalloc_base>
}
 822e080:	e037883a 	mov	sp,fp
 822e084:	dfc00117 	ldw	ra,4(sp)
 822e088:	df000017 	ldw	fp,0(sp)
 822e08c:	dec00204 	addi	sp,sp,8
 822e090:	f800283a 	ret

0822e094 <ncpfree>:

void ncpfree(void *ptr)
{
 822e094:	defffd04 	addi	sp,sp,-12
 822e098:	dfc00215 	stw	ra,8(sp)
 822e09c:	df000115 	stw	fp,4(sp)
 822e0a0:	df000104 	addi	fp,sp,4
 822e0a4:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 822e0a8:	e0bfff17 	ldw	r2,-4(fp)
 822e0ac:	10000326 	beq	r2,zero,822e0bc <ncpfree+0x28>
      npfree_base(ptr, 0);
 822e0b0:	000b883a 	mov	r5,zero
 822e0b4:	e13fff17 	ldw	r4,-4(fp)
 822e0b8:	822df0c0 	call	822df0c <npfree_base>
   }
}
 822e0bc:	0001883a 	nop
 822e0c0:	e037883a 	mov	sp,fp
 822e0c4:	dfc00117 	ldw	ra,4(sp)
 822e0c8:	df000017 	ldw	fp,0(sp)
 822e0cc:	dec00204 	addi	sp,sp,8
 822e0d0:	f800283a 	ret

0822e0d4 <pffindtype>:
 * RETURNS: 
 */

struct protosw *  
pffindtype(int domain, int type)
{
 822e0d4:	defffc04 	addi	sp,sp,-16
 822e0d8:	dfc00315 	stw	ra,12(sp)
 822e0dc:	df000215 	stw	fp,8(sp)
 822e0e0:	df000204 	addi	fp,sp,8
 822e0e4:	e13ffe15 	stw	r4,-8(fp)
 822e0e8:	e17fff15 	stw	r5,-4(fp)

   /* check that the passed domain is vaid for the build */
   if (domain != AF_INET)
 822e0ec:	e0bffe17 	ldw	r2,-8(fp)
 822e0f0:	108000a0 	cmpeqi	r2,r2,2
 822e0f4:	1000031e 	bne	r2,zero,822e104 <pffindtype+0x30>
   {
#ifdef IP_V6
      if(domain != AF_INET6)
#endif
      {
         dtrap();    /* programming error */
 822e0f8:	822d4140 	call	822d414 <dtrap>
         return NULL;
 822e0fc:	0005883a 	mov	r2,zero
 822e100:	00001306 	br	822e150 <pffindtype+0x7c>
      }
   }

   if (type == SOCK_STREAM)
 822e104:	e0bfff17 	ldw	r2,-4(fp)
 822e108:	10800058 	cmpnei	r2,r2,1
 822e10c:	1000031e 	bne	r2,zero,822e11c <pffindtype+0x48>
      return &tcp_protosw;
 822e110:	00820974 	movhi	r2,2085
 822e114:	108eba04 	addi	r2,r2,15080
 822e118:	00000d06 	br	822e150 <pffindtype+0x7c>
#ifdef UDP_SOCKETS
   else if(type == SOCK_DGRAM)
 822e11c:	e0bfff17 	ldw	r2,-4(fp)
 822e120:	10800098 	cmpnei	r2,r2,2
 822e124:	1000031e 	bne	r2,zero,822e134 <pffindtype+0x60>
      return &udp_protosw;
 822e128:	00820974 	movhi	r2,2085
 822e12c:	108ec004 	addi	r2,r2,15104
 822e130:	00000706 	br	822e150 <pffindtype+0x7c>
#endif   /* UDP_SOCKETS */
#ifdef IP_RAW
   else if(type == SOCK_RAW)
 822e134:	e0bfff17 	ldw	r2,-4(fp)
 822e138:	108000d8 	cmpnei	r2,r2,3
 822e13c:	1000031e 	bne	r2,zero,822e14c <pffindtype+0x78>
      return &rawip_protosw;
 822e140:	00820974 	movhi	r2,2085
 822e144:	108ec604 	addi	r2,r2,15128
 822e148:	00000106 	br	822e150 <pffindtype+0x7c>
#endif  /* IP_RAW */
   else
      return NULL;
 822e14c:	0005883a 	mov	r2,zero
}
 822e150:	e037883a 	mov	sp,fp
 822e154:	dfc00117 	ldw	ra,4(sp)
 822e158:	df000017 	ldw	fp,0(sp)
 822e15c:	dec00204 	addi	sp,sp,8
 822e160:	f800283a 	ret

0822e164 <pffindproto>:
 * RETURNS: 
 */

struct protosw *  
pffindproto(int domain, int protocol, int type)
{
 822e164:	defffb04 	addi	sp,sp,-20
 822e168:	dfc00415 	stw	ra,16(sp)
 822e16c:	df000315 	stw	fp,12(sp)
 822e170:	df000304 	addi	fp,sp,12
 822e174:	e13ffd15 	stw	r4,-12(fp)
 822e178:	e17ffe15 	stw	r5,-8(fp)
 822e17c:	e1bfff15 	stw	r6,-4(fp)
#ifdef IP_RAW
   if (type == SOCK_RAW)
 822e180:	e0bfff17 	ldw	r2,-4(fp)
 822e184:	108000d8 	cmpnei	r2,r2,3
 822e188:	1000041e 	bne	r2,zero,822e19c <pffindproto+0x38>
      return(pffindtype(domain, type));
 822e18c:	e17fff17 	ldw	r5,-4(fp)
 822e190:	e13ffd17 	ldw	r4,-12(fp)
 822e194:	822e0d40 	call	822e0d4 <pffindtype>
 822e198:	00001e06 	br	822e214 <pffindproto+0xb0>
#endif

   switch (protocol)
 822e19c:	e0bffe17 	ldw	r2,-8(fp)
 822e1a0:	10c001a0 	cmpeqi	r3,r2,6
 822e1a4:	1800041e 	bne	r3,zero,822e1b8 <pffindproto+0x54>
 822e1a8:	10c00460 	cmpeqi	r3,r2,17
 822e1ac:	1800081e 	bne	r3,zero,822e1d0 <pffindproto+0x6c>
 822e1b0:	10001026 	beq	r2,zero,822e1f4 <pffindproto+0x90>
 822e1b4:	00000c06 	br	822e1e8 <pffindproto+0x84>
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
 822e1b8:	e0bfff17 	ldw	r2,-4(fp)
 822e1bc:	10800058 	cmpnei	r2,r2,1
 822e1c0:	10000e26 	beq	r2,zero,822e1fc <pffindproto+0x98>
         break;
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
 822e1c4:	822d4140 	call	822d414 <dtrap>
      return NULL;
 822e1c8:	0005883a 	mov	r2,zero
 822e1cc:	00001106 	br	822e214 <pffindproto+0xb0>
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
 822e1d0:	e0bfff17 	ldw	r2,-4(fp)
 822e1d4:	10800098 	cmpnei	r2,r2,2
 822e1d8:	10000a26 	beq	r2,zero,822e204 <pffindproto+0xa0>
         break;
      /* IPPROTO_UDP protocol on non-SOCK_DGRAM type socket */
      dtrap();
 822e1dc:	822d4140 	call	822d414 <dtrap>
      return NULL;
 822e1e0:	0005883a 	mov	r2,zero
 822e1e4:	00000b06 	br	822e214 <pffindproto+0xb0>
   case 0:
      /* let protocol default based on socket type */
      break;
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
 822e1e8:	822d4140 	call	822d414 <dtrap>
      return NULL;
 822e1ec:	0005883a 	mov	r2,zero
 822e1f0:	00000806 	br	822e214 <pffindproto+0xb0>
      dtrap();
      return NULL;
#endif /* BSD_SOCKETS */
   case 0:
      /* let protocol default based on socket type */
      break;
 822e1f4:	0001883a 	nop
 822e1f8:	00000306 	br	822e208 <pffindproto+0xa4>
   switch (protocol)
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
         break;
 822e1fc:	0001883a 	nop
 822e200:	00000106 	br	822e208 <pffindproto+0xa4>
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
      return NULL;
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
         break;
 822e204:	0001883a 	nop
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
      return NULL;
   }
   return(pffindtype(domain, type));   /* map to findtype */
 822e208:	e17fff17 	ldw	r5,-4(fp)
 822e20c:	e13ffd17 	ldw	r4,-12(fp)
 822e210:	822e0d40 	call	822e0d4 <pffindtype>
}
 822e214:	e037883a 	mov	sp,fp
 822e218:	dfc00117 	ldw	ra,4(sp)
 822e21c:	df000017 	ldw	fp,0(sp)
 822e220:	dec00204 	addi	sp,sp,8
 822e224:	f800283a 	ret

0822e228 <m_getnbuf>:
 * RETURNS: 
 */

struct mbuf *  
m_getnbuf(int type, int len)
{
 822e228:	defffa04 	addi	sp,sp,-24
 822e22c:	dfc00515 	stw	ra,20(sp)
 822e230:	df000415 	stw	fp,16(sp)
 822e234:	df000404 	addi	fp,sp,16
 822e238:	e13ffe15 	stw	r4,-8(fp)
 822e23c:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   PACKET pkt = NULL;
 822e240:	e03ffc15 	stw	zero,-16(fp)

#ifdef NPDEBUG
   if (type < MT_RXDATA || type > MT_IFADDR)
 822e244:	e0bffe17 	ldw	r2,-8(fp)
 822e248:	0080030e 	bge	zero,r2,822e258 <m_getnbuf+0x30>
 822e24c:	e0bffe17 	ldw	r2,-8(fp)
 822e250:	10800390 	cmplti	r2,r2,14
 822e254:	1000011e 	bne	r2,zero,822e25c <m_getnbuf+0x34>
   {
      dtrap(); /* is this OK? */
 822e258:	822d4140 	call	822d414 <dtrap>
   }
#endif

   /* if caller has data (len >= 0), we need to allocate 
    * a packet buffer; else all we need is the mbuf */
   if (len != 0)
 822e25c:	e0bfff17 	ldw	r2,-4(fp)
 822e260:	10000d26 	beq	r2,zero,822e298 <m_getnbuf+0x70>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822e264:	01000084 	movi	r4,2
 822e268:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pkt = pk_alloc(len + HDRSLEN);
 822e26c:	e0bfff17 	ldw	r2,-4(fp)
 822e270:	10800e04 	addi	r2,r2,56
 822e274:	1009883a 	mov	r4,r2
 822e278:	822c86c0 	call	822c86c <pk_alloc>
 822e27c:	e0bffc15 	stw	r2,-16(fp)

      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822e280:	01000084 	movi	r4,2
 822e284:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      if (!pkt)
 822e288:	e0bffc17 	ldw	r2,-16(fp)
 822e28c:	1000021e 	bne	r2,zero,822e298 <m_getnbuf+0x70>
         return NULL;
 822e290:	0005883a 	mov	r2,zero
 822e294:	00004106 	br	822e39c <m_getnbuf+0x174>
   }

   m = (struct mbuf *)getq(&mfreeq);
 822e298:	010209b4 	movhi	r4,2086
 822e29c:	21397a04 	addi	r4,r4,-6680
 822e2a0:	822cd440 	call	822cd44 <getq>
 822e2a4:	e0bffd15 	stw	r2,-12(fp)
   if (!m)
 822e2a8:	e0bffd17 	ldw	r2,-12(fp)
 822e2ac:	10000a1e 	bne	r2,zero,822e2d8 <m_getnbuf+0xb0>
   {
      if (pkt) 
 822e2b0:	e0bffc17 	ldw	r2,-16(fp)
 822e2b4:	10000626 	beq	r2,zero,822e2d0 <m_getnbuf+0xa8>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822e2b8:	01000084 	movi	r4,2
 822e2bc:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 822e2c0:	e13ffc17 	ldw	r4,-16(fp)
 822e2c4:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822e2c8:	01000084 	movi	r4,2
 822e2cc:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      }
      return NULL;
 822e2d0:	0005883a 	mov	r2,zero
 822e2d4:	00003106 	br	822e39c <m_getnbuf+0x174>
   }
   m->m_type = type;
 822e2d8:	e0bffd17 	ldw	r2,-12(fp)
 822e2dc:	e0fffe17 	ldw	r3,-8(fp)
 822e2e0:	10c00815 	stw	r3,32(r2)
   if (len == 0)
 822e2e4:	e0bfff17 	ldw	r2,-4(fp)
 822e2e8:	1000071e 	bne	r2,zero,822e308 <m_getnbuf+0xe0>
   {
      m->pkt = NULL;
 822e2ec:	e0bffd17 	ldw	r2,-12(fp)
 822e2f0:	10000115 	stw	zero,4(r2)
      m->m_base = NULL;    /* caller better fill these in! */
 822e2f4:	e0bffd17 	ldw	r2,-12(fp)
 822e2f8:	10000415 	stw	zero,16(r2)
      m->m_memsz = 0;
 822e2fc:	e0bffd17 	ldw	r2,-12(fp)
 822e300:	10000515 	stw	zero,20(r2)
 822e304:	00001506 	br	822e35c <m_getnbuf+0x134>
   }
   else
   {
      m->pkt = pkt;
 822e308:	e0bffd17 	ldw	r2,-12(fp)
 822e30c:	e0fffc17 	ldw	r3,-16(fp)
 822e310:	10c00115 	stw	r3,4(r2)
      /* set m_data to the part where tcp data should go */
      m->m_base = m->m_data = pkt->nb_prot = pkt->nb_buff + HDRSLEN;
 822e314:	e0bffc17 	ldw	r2,-16(fp)
 822e318:	10800117 	ldw	r2,4(r2)
 822e31c:	10c00e04 	addi	r3,r2,56
 822e320:	e0bffc17 	ldw	r2,-16(fp)
 822e324:	10c00315 	stw	r3,12(r2)
 822e328:	e0bffc17 	ldw	r2,-16(fp)
 822e32c:	10c00317 	ldw	r3,12(r2)
 822e330:	e0bffd17 	ldw	r2,-12(fp)
 822e334:	10c00315 	stw	r3,12(r2)
 822e338:	e0bffd17 	ldw	r2,-12(fp)
 822e33c:	10c00317 	ldw	r3,12(r2)
 822e340:	e0bffd17 	ldw	r2,-12(fp)
 822e344:	10c00415 	stw	r3,16(r2)
      m->m_memsz = pkt->nb_blen - HDRSLEN;
 822e348:	e0bffc17 	ldw	r2,-16(fp)
 822e34c:	10800217 	ldw	r2,8(r2)
 822e350:	10fff204 	addi	r3,r2,-56
 822e354:	e0bffd17 	ldw	r2,-12(fp)
 822e358:	10c00515 	stw	r3,20(r2)
   }
   m->m_len = 0;
 822e35c:	e0bffd17 	ldw	r2,-12(fp)
 822e360:	10000215 	stw	zero,8(r2)
   m->m_next = m->m_act = NULL;
 822e364:	e0bffd17 	ldw	r2,-12(fp)
 822e368:	10000715 	stw	zero,28(r2)
 822e36c:	e0bffd17 	ldw	r2,-12(fp)
 822e370:	10c00717 	ldw	r3,28(r2)
 822e374:	e0bffd17 	ldw	r2,-12(fp)
 822e378:	10c00615 	stw	r3,24(r2)
   mbstat.allocs++;        /* maintain local statistics */
 822e37c:	d0a0ae17 	ldw	r2,-32072(gp)
 822e380:	10800044 	addi	r2,r2,1
 822e384:	d0a0ae15 	stw	r2,-32072(gp)
   putq(&mbufq, (qp)m);
 822e388:	e17ffd17 	ldw	r5,-12(fp)
 822e38c:	010209b4 	movhi	r4,2086
 822e390:	21397504 	addi	r4,r4,-6700
 822e394:	822cdfc0 	call	822cdfc <putq>
   return m;
 822e398:	e0bffd17 	ldw	r2,-12(fp)
}
 822e39c:	e037883a 	mov	sp,fp
 822e3a0:	dfc00117 	ldw	ra,4(sp)
 822e3a4:	df000017 	ldw	fp,0(sp)
 822e3a8:	dec00204 	addi	sp,sp,8
 822e3ac:	f800283a 	ret

0822e3b0 <m_free>:
 */


struct mbuf *  
m_free(struct mbuf * m)
{
 822e3b0:	defffc04 	addi	sp,sp,-16
 822e3b4:	dfc00315 	stw	ra,12(sp)
 822e3b8:	df000215 	stw	fp,8(sp)
 822e3bc:	df000204 	addi	fp,sp,8
 822e3c0:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  nextptr;

#ifdef NPDEBUG
   if (mbufq.q_len < 1)
 822e3c4:	008209b4 	movhi	r2,2086
 822e3c8:	10b97504 	addi	r2,r2,-6700
 822e3cc:	10800217 	ldw	r2,8(r2)
 822e3d0:	00800316 	blt	zero,r2,822e3e0 <m_free+0x30>
      panic("mfree: q_len");
 822e3d4:	01020974 	movhi	r4,2085
 822e3d8:	21035904 	addi	r4,r4,3428
 822e3dc:	8228aec0 	call	8228aec <panic>

   if (m->m_type < MT_RXDATA || m->m_type > MT_IFADDR)
 822e3e0:	e0bfff17 	ldw	r2,-4(fp)
 822e3e4:	10800817 	ldw	r2,32(r2)
 822e3e8:	0080040e 	bge	zero,r2,822e3fc <m_free+0x4c>
 822e3ec:	e0bfff17 	ldw	r2,-4(fp)
 822e3f0:	10800817 	ldw	r2,32(r2)
 822e3f4:	10800390 	cmplti	r2,r2,14
 822e3f8:	10000a1e 	bne	r2,zero,822e424 <m_free+0x74>
   {
      if (m->m_type == MT_FREE)
 822e3fc:	e0bfff17 	ldw	r2,-4(fp)
 822e400:	10800817 	ldw	r2,32(r2)
 822e404:	1000041e 	bne	r2,zero,822e418 <m_free+0x68>
      {
         dtrap(); /* debug double free of mbuf by tcp_in() */
 822e408:	822d4140 	call	822d414 <dtrap>
         return m->m_next; /* seems harmless, though.... */
 822e40c:	e0bfff17 	ldw	r2,-4(fp)
 822e410:	10800617 	ldw	r2,24(r2)
 822e414:	00002306 	br	822e4a4 <m_free+0xf4>
      }
      else
         panic("m_free: type");
 822e418:	01020974 	movhi	r4,2085
 822e41c:	21035d04 	addi	r4,r4,3444
 822e420:	8228aec0 	call	8228aec <panic>
   }
#endif   /* NPDEBUG */

   nextptr = m->m_next;    /* remember value to return */
 822e424:	e0bfff17 	ldw	r2,-4(fp)
 822e428:	10800617 	ldw	r2,24(r2)
 822e42c:	e0bffe15 	stw	r2,-8(fp)

   if (qdel(&mbufq, m) == NULL)
 822e430:	e17fff17 	ldw	r5,-4(fp)
 822e434:	010209b4 	movhi	r4,2086
 822e438:	21397504 	addi	r4,r4,-6700
 822e43c:	822ceac0 	call	822ceac <qdel>
 822e440:	1000031e 	bne	r2,zero,822e450 <m_free+0xa0>
      panic("m_free: missing");
 822e444:	01020974 	movhi	r4,2085
 822e448:	21036104 	addi	r4,r4,3460
 822e44c:	8228aec0 	call	8228aec <panic>

   m->m_type = MT_FREE;    /* this may seem silly, but helps error checking */
 822e450:	e0bfff17 	ldw	r2,-4(fp)
 822e454:	10000815 	stw	zero,32(r2)

   if (m->pkt)
 822e458:	e0bfff17 	ldw	r2,-4(fp)
 822e45c:	10800117 	ldw	r2,4(r2)
 822e460:	10000826 	beq	r2,zero,822e484 <m_free+0xd4>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822e464:	01000084 	movi	r4,2
 822e468:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(m->pkt);     /* free up the netport buffer */
 822e46c:	e0bfff17 	ldw	r2,-4(fp)
 822e470:	10800117 	ldw	r2,4(r2)
 822e474:	1009883a 	mov	r4,r2
 822e478:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822e47c:	01000084 	movi	r4,2
 822e480:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   }
   mbstat.frees++;
 822e484:	d0a0af17 	ldw	r2,-32068(gp)
 822e488:	10800044 	addi	r2,r2,1
 822e48c:	d0a0af15 	stw	r2,-32068(gp)
   putq(&mfreeq, (qp)m);
 822e490:	e17fff17 	ldw	r5,-4(fp)
 822e494:	010209b4 	movhi	r4,2086
 822e498:	21397a04 	addi	r4,r4,-6680
 822e49c:	822cdfc0 	call	822cdfc <putq>
   return nextptr;
 822e4a0:	e0bffe17 	ldw	r2,-8(fp)
}
 822e4a4:	e037883a 	mov	sp,fp
 822e4a8:	dfc00117 	ldw	ra,4(sp)
 822e4ac:	df000017 	ldw	fp,0(sp)
 822e4b0:	dec00204 	addi	sp,sp,8
 822e4b4:	f800283a 	ret

0822e4b8 <m_freem>:
 * RETURNS: 
 */

void
m_freem(struct mbuf * m)
{
 822e4b8:	defffd04 	addi	sp,sp,-12
 822e4bc:	dfc00215 	stw	ra,8(sp)
 822e4c0:	df000115 	stw	fp,4(sp)
 822e4c4:	df000104 	addi	fp,sp,4
 822e4c8:	e13fff15 	stw	r4,-4(fp)
   while (m != NULL)
 822e4cc:	00000306 	br	822e4dc <m_freem+0x24>
      m = m_free(m);
 822e4d0:	e13fff17 	ldw	r4,-4(fp)
 822e4d4:	822e3b00 	call	822e3b0 <m_free>
 822e4d8:	e0bfff15 	stw	r2,-4(fp)
 */

void
m_freem(struct mbuf * m)
{
   while (m != NULL)
 822e4dc:	e0bfff17 	ldw	r2,-4(fp)
 822e4e0:	103ffb1e 	bne	r2,zero,822e4d0 <m_freem+0x18>
      m = m_free(m);
}
 822e4e4:	0001883a 	nop
 822e4e8:	e037883a 	mov	sp,fp
 822e4ec:	dfc00117 	ldw	ra,4(sp)
 822e4f0:	df000017 	ldw	fp,0(sp)
 822e4f4:	dec00204 	addi	sp,sp,8
 822e4f8:	f800283a 	ret

0822e4fc <m_copy>:
 * RETURNS: 
 */

struct mbuf *  
m_copy(struct mbuf * m, int off, int len)
{
 822e4fc:	defff704 	addi	sp,sp,-36
 822e500:	dfc00815 	stw	ra,32(sp)
 822e504:	df000715 	stw	fp,28(sp)
 822e508:	df000704 	addi	fp,sp,28
 822e50c:	e13ffd15 	stw	r4,-12(fp)
 822e510:	e17ffe15 	stw	r5,-8(fp)
 822e514:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  nb, * head, *  tail;
   int   tocopy;

   if (len == 0)  /* nothing to do */
 822e518:	e0bfff17 	ldw	r2,-4(fp)
 822e51c:	1000021e 	bne	r2,zero,822e528 <m_copy+0x2c>
      return NULL;
 822e520:	0005883a 	mov	r2,zero
 822e524:	0000ad06 	br	822e7dc <m_copy+0x2e0>

#ifdef NPDEBUG
   /* sanity test parms */
   if (off < 0 || (len < 0 && len != M_COPYALL))
 822e528:	e0bffe17 	ldw	r2,-8(fp)
 822e52c:	10000516 	blt	r2,zero,822e544 <m_copy+0x48>
 822e530:	e0bfff17 	ldw	r2,-4(fp)
 822e534:	1000180e 	bge	r2,zero,822e598 <m_copy+0x9c>
 822e538:	e0bfff17 	ldw	r2,-4(fp)
 822e53c:	10bfffe0 	cmpeqi	r2,r2,-1
 822e540:	1000151e 	bne	r2,zero,822e598 <m_copy+0x9c>
   {
      dtrap();
 822e544:	822d4140 	call	822d414 <dtrap>
      return NULL;
 822e548:	0005883a 	mov	r2,zero
 822e54c:	0000a306 	br	822e7dc <m_copy+0x2e0>
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
   {
      if (!m)
 822e550:	e0bffd17 	ldw	r2,-12(fp)
 822e554:	1000031e 	bne	r2,zero,822e564 <m_copy+0x68>
      {
         dtrap();
 822e558:	822d4140 	call	822d414 <dtrap>
         return NULL;
 822e55c:	0005883a 	mov	r2,zero
 822e560:	00009e06 	br	822e7dc <m_copy+0x2e0>
      }
      if (off < (int)m->m_len)
 822e564:	e0bffd17 	ldw	r2,-12(fp)
 822e568:	10800217 	ldw	r2,8(r2)
 822e56c:	1007883a 	mov	r3,r2
 822e570:	e0bffe17 	ldw	r2,-8(fp)
 822e574:	10c00b16 	blt	r2,r3,822e5a4 <m_copy+0xa8>
         break;
      off -= m->m_len;
 822e578:	e0fffe17 	ldw	r3,-8(fp)
 822e57c:	e0bffd17 	ldw	r2,-12(fp)
 822e580:	10800217 	ldw	r2,8(r2)
 822e584:	1885c83a 	sub	r2,r3,r2
 822e588:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 822e58c:	e0bffd17 	ldw	r2,-12(fp)
 822e590:	10800617 	ldw	r2,24(r2)
 822e594:	e0bffd15 	stw	r2,-12(fp)
      return NULL;
   }
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
 822e598:	e0bffe17 	ldw	r2,-8(fp)
 822e59c:	00bfec16 	blt	zero,r2,822e550 <m_copy+0x54>
 822e5a0:	00000106 	br	822e5a8 <m_copy+0xac>
      {
         dtrap();
         return NULL;
      }
      if (off < (int)m->m_len)
         break;
 822e5a4:	0001883a 	nop
      off -= m->m_len;
      m = m->m_next;
   }

   head = tail = NULL;
 822e5a8:	e03ffb15 	stw	zero,-20(fp)
 822e5ac:	e0bffb17 	ldw	r2,-20(fp)
 822e5b0:	e0bffa15 	stw	r2,-24(fp)

   while (len > 0)
 822e5b4:	00007f06 	br	822e7b4 <m_copy+0x2b8>
   {
      if (m == NULL) /* at end of queue? */
 822e5b8:	e0bffd17 	ldw	r2,-12(fp)
 822e5bc:	1000051e 	bne	r2,zero,822e5d4 <m_copy+0xd8>
      {
         panic("m_copy: bad len");
 822e5c0:	01020974 	movhi	r4,2085
 822e5c4:	21036504 	addi	r4,r4,3476
 822e5c8:	8228aec0 	call	8228aec <panic>
         return NULL;
 822e5cc:	0005883a 	mov	r2,zero
 822e5d0:	00008206 	br	822e7dc <m_copy+0x2e0>
      }
      tocopy = (int)MIN(len, (int)(m->m_len - off));
 822e5d4:	e0bffd17 	ldw	r2,-12(fp)
 822e5d8:	10c00217 	ldw	r3,8(r2)
 822e5dc:	e0bffe17 	ldw	r2,-8(fp)
 822e5e0:	1885c83a 	sub	r2,r3,r2
 822e5e4:	e0ffff17 	ldw	r3,-4(fp)
 822e5e8:	1880010e 	bge	r3,r2,822e5f0 <m_copy+0xf4>
 822e5ec:	1805883a 	mov	r2,r3
 822e5f0:	e0bffc15 	stw	r2,-16(fp)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 822e5f4:	e0bffe17 	ldw	r2,-8(fp)
 822e5f8:	108000cc 	andi	r2,r2,3
 822e5fc:	1000051e 	bne	r2,zero,822e614 <m_copy+0x118>
          (m->pkt->inuse != 1))
 822e600:	e0bffd17 	ldw	r2,-12(fp)
 822e604:	10800117 	ldw	r2,4(r2)
 822e608:	10800917 	ldw	r2,36(r2)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 822e60c:	10800060 	cmpeqi	r2,r2,1
 822e610:	1000251e 	bne	r2,zero,822e6a8 <m_copy+0x1ac>
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
 822e614:	e0bffd17 	ldw	r2,-12(fp)
 822e618:	10800817 	ldw	r2,32(r2)
 822e61c:	e17ffc17 	ldw	r5,-16(fp)
 822e620:	1009883a 	mov	r4,r2
 822e624:	822e2280 	call	822e228 <m_getnbuf>
 822e628:	e0bff915 	stw	r2,-28(fp)
 822e62c:	e0bff917 	ldw	r2,-28(fp)
 822e630:	10006426 	beq	r2,zero,822e7c4 <m_copy+0x2c8>
            goto nospace;
         MEMCPY(nb->m_data, m->m_data+off, tocopy);
 822e634:	e0bff917 	ldw	r2,-28(fp)
 822e638:	11000317 	ldw	r4,12(r2)
 822e63c:	e0bffd17 	ldw	r2,-12(fp)
 822e640:	10c00317 	ldw	r3,12(r2)
 822e644:	e0bffe17 	ldw	r2,-8(fp)
 822e648:	1885883a 	add	r2,r3,r2
 822e64c:	e0fffc17 	ldw	r3,-16(fp)
 822e650:	180d883a 	mov	r6,r3
 822e654:	100b883a 	mov	r5,r2
 822e658:	8202e8c0 	call	8202e8c <memcpy>
         nb->m_len = tocopy;  /* set length of data we just moved into new mbuf */
 822e65c:	e0fffc17 	ldw	r3,-16(fp)
 822e660:	e0bff917 	ldw	r2,-28(fp)
 822e664:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mcopies++;
 822e668:	008209b4 	movhi	r2,2086
 822e66c:	10b99404 	addi	r2,r2,-6576
 822e670:	10802e17 	ldw	r2,184(r2)
 822e674:	10c00044 	addi	r3,r2,1
 822e678:	008209b4 	movhi	r2,2086
 822e67c:	10b99404 	addi	r2,r2,-6576
 822e680:	10c02e15 	stw	r3,184(r2)
         tcpstat.tcps_mcopiedbytes += tocopy;
 822e684:	008209b4 	movhi	r2,2086
 822e688:	10b99404 	addi	r2,r2,-6576
 822e68c:	10c03017 	ldw	r3,192(r2)
 822e690:	e0bffc17 	ldw	r2,-16(fp)
 822e694:	1887883a 	add	r3,r3,r2
 822e698:	008209b4 	movhi	r2,2086
 822e69c:	10b99404 	addi	r2,r2,-6576
 822e6a0:	10c03015 	stw	r3,192(r2)
 822e6a4:	00003106 	br	822e76c <m_copy+0x270>
      {
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
 822e6a8:	e0bffd17 	ldw	r2,-12(fp)
 822e6ac:	10800817 	ldw	r2,32(r2)
 822e6b0:	000b883a 	mov	r5,zero
 822e6b4:	1009883a 	mov	r4,r2
 822e6b8:	822e2280 	call	822e228 <m_getnbuf>
 822e6bc:	e0bff915 	stw	r2,-28(fp)
 822e6c0:	e0bff917 	ldw	r2,-28(fp)
 822e6c4:	10004126 	beq	r2,zero,822e7cc <m_copy+0x2d0>
            goto nospace;

         m->pkt->inuse++;     /* bump pkt use count to clone it */
 822e6c8:	e0bffd17 	ldw	r2,-12(fp)
 822e6cc:	10800117 	ldw	r2,4(r2)
 822e6d0:	10c00917 	ldw	r3,36(r2)
 822e6d4:	18c00044 	addi	r3,r3,1
 822e6d8:	10c00915 	stw	r3,36(r2)

         /* set up new mbuf with pointers to cloned packet */
         nb->pkt = m->pkt;
 822e6dc:	e0bffd17 	ldw	r2,-12(fp)
 822e6e0:	10c00117 	ldw	r3,4(r2)
 822e6e4:	e0bff917 	ldw	r2,-28(fp)
 822e6e8:	10c00115 	stw	r3,4(r2)
         nb->m_base = m->m_base;
 822e6ec:	e0bffd17 	ldw	r2,-12(fp)
 822e6f0:	10c00417 	ldw	r3,16(r2)
 822e6f4:	e0bff917 	ldw	r2,-28(fp)
 822e6f8:	10c00415 	stw	r3,16(r2)
         nb->m_memsz = m->m_memsz;
 822e6fc:	e0bffd17 	ldw	r2,-12(fp)
 822e700:	10c00517 	ldw	r3,20(r2)
 822e704:	e0bff917 	ldw	r2,-28(fp)
 822e708:	10c00515 	stw	r3,20(r2)
         nb->m_data = m->m_data + off;
 822e70c:	e0bffd17 	ldw	r2,-12(fp)
 822e710:	10c00317 	ldw	r3,12(r2)
 822e714:	e0bffe17 	ldw	r2,-8(fp)
 822e718:	1887883a 	add	r3,r3,r2
 822e71c:	e0bff917 	ldw	r2,-28(fp)
 822e720:	10c00315 	stw	r3,12(r2)
         nb->m_len = tocopy;
 822e724:	e0fffc17 	ldw	r3,-16(fp)
 822e728:	e0bff917 	ldw	r2,-28(fp)
 822e72c:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mclones++;
 822e730:	008209b4 	movhi	r2,2086
 822e734:	10b99404 	addi	r2,r2,-6576
 822e738:	10802f17 	ldw	r2,188(r2)
 822e73c:	10c00044 	addi	r3,r2,1
 822e740:	008209b4 	movhi	r2,2086
 822e744:	10b99404 	addi	r2,r2,-6576
 822e748:	10c02f15 	stw	r3,188(r2)
         tcpstat.tcps_mclonedbytes += tocopy;
 822e74c:	008209b4 	movhi	r2,2086
 822e750:	10b99404 	addi	r2,r2,-6576
 822e754:	10c03117 	ldw	r3,196(r2)
 822e758:	e0bffc17 	ldw	r2,-16(fp)
 822e75c:	1887883a 	add	r3,r3,r2
 822e760:	008209b4 	movhi	r2,2086
 822e764:	10b99404 	addi	r2,r2,-6576
 822e768:	10c03115 	stw	r3,196(r2)
      }

      len -= tocopy;
 822e76c:	e0ffff17 	ldw	r3,-4(fp)
 822e770:	e0bffc17 	ldw	r2,-16(fp)
 822e774:	1885c83a 	sub	r2,r3,r2
 822e778:	e0bfff15 	stw	r2,-4(fp)
      off = 0;
 822e77c:	e03ffe15 	stw	zero,-8(fp)
      if (tail)      /* head & tail are set by first pass thru loop */
 822e780:	e0bffb17 	ldw	r2,-20(fp)
 822e784:	10000426 	beq	r2,zero,822e798 <m_copy+0x29c>
         tail->m_next = nb;
 822e788:	e0bffb17 	ldw	r2,-20(fp)
 822e78c:	e0fff917 	ldw	r3,-28(fp)
 822e790:	10c00615 	stw	r3,24(r2)
 822e794:	00000206 	br	822e7a0 <m_copy+0x2a4>
      else
         head = nb;
 822e798:	e0bff917 	ldw	r2,-28(fp)
 822e79c:	e0bffa15 	stw	r2,-24(fp)
      tail = nb;     /* always make new mbuf the tail */
 822e7a0:	e0bff917 	ldw	r2,-28(fp)
 822e7a4:	e0bffb15 	stw	r2,-20(fp)
      m = m->m_next;
 822e7a8:	e0bffd17 	ldw	r2,-12(fp)
 822e7ac:	10800617 	ldw	r2,24(r2)
 822e7b0:	e0bffd15 	stw	r2,-12(fp)
      m = m->m_next;
   }

   head = tail = NULL;

   while (len > 0)
 822e7b4:	e0bfff17 	ldw	r2,-4(fp)
 822e7b8:	00bf7f16 	blt	zero,r2,822e5b8 <m_copy+0xbc>
      tail = nb;     /* always make new mbuf the tail */
      m = m->m_next;

   }

   return head;
 822e7bc:	e0bffa17 	ldw	r2,-24(fp)
 822e7c0:	00000606 	br	822e7dc <m_copy+0x2e0>
       */
      if ((off & (ALIGN_TYPE - 1)) ||
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
            goto nospace;
 822e7c4:	0001883a 	nop
 822e7c8:	00000106 	br	822e7d0 <m_copy+0x2d4>
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
            goto nospace;
 822e7cc:	0001883a 	nop
   }

   return head;

nospace:
   m_freem (head);
 822e7d0:	e13ffa17 	ldw	r4,-24(fp)
 822e7d4:	822e4b80 	call	822e4b8 <m_freem>
   return NULL;
 822e7d8:	0005883a 	mov	r2,zero
}
 822e7dc:	e037883a 	mov	sp,fp
 822e7e0:	dfc00117 	ldw	ra,4(sp)
 822e7e4:	df000017 	ldw	fp,0(sp)
 822e7e8:	dec00204 	addi	sp,sp,8
 822e7ec:	f800283a 	ret

0822e7f0 <m_adj>:
 * RETURNS: 
 */

void
m_adj(struct mbuf * mp, int len)
{
 822e7f0:	defffb04 	addi	sp,sp,-20
 822e7f4:	df000415 	stw	fp,16(sp)
 822e7f8:	df000404 	addi	fp,sp,16
 822e7fc:	e13ffe15 	stw	r4,-8(fp)
 822e800:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
 822e804:	e0bffe17 	ldw	r2,-8(fp)
 822e808:	e0bffc15 	stw	r2,-16(fp)
 822e80c:	e0bffc17 	ldw	r2,-16(fp)
 822e810:	10006226 	beq	r2,zero,822e99c <m_adj+0x1ac>
      return;

   if (len >= 0) 
 822e814:	e0bfff17 	ldw	r2,-4(fp)
 822e818:	10002216 	blt	r2,zero,822e8a4 <m_adj+0xb4>
   {
      while (m != NULL && len > 0) 
 822e81c:	00001c06 	br	822e890 <m_adj+0xa0>
      {
         if (m->m_len <= (unsigned)len)
 822e820:	e0bffc17 	ldw	r2,-16(fp)
 822e824:	10800217 	ldw	r2,8(r2)
 822e828:	e0ffff17 	ldw	r3,-4(fp)
 822e82c:	18800b36 	bltu	r3,r2,822e85c <m_adj+0x6c>
         {
            len -= m->m_len;
 822e830:	e0ffff17 	ldw	r3,-4(fp)
 822e834:	e0bffc17 	ldw	r2,-16(fp)
 822e838:	10800217 	ldw	r2,8(r2)
 822e83c:	1885c83a 	sub	r2,r3,r2
 822e840:	e0bfff15 	stw	r2,-4(fp)
            m->m_len = 0;
 822e844:	e0bffc17 	ldw	r2,-16(fp)
 822e848:	10000215 	stw	zero,8(r2)
            m = m->m_next;
 822e84c:	e0bffc17 	ldw	r2,-16(fp)
 822e850:	10800617 	ldw	r2,24(r2)
 822e854:	e0bffc15 	stw	r2,-16(fp)
 822e858:	00000d06 	br	822e890 <m_adj+0xa0>
         }
         else
         {
            m->m_len -= len;
 822e85c:	e0bffc17 	ldw	r2,-16(fp)
 822e860:	10c00217 	ldw	r3,8(r2)
 822e864:	e0bfff17 	ldw	r2,-4(fp)
 822e868:	1887c83a 	sub	r3,r3,r2
 822e86c:	e0bffc17 	ldw	r2,-16(fp)
 822e870:	10c00215 	stw	r3,8(r2)
            m->m_data += len;
 822e874:	e0bffc17 	ldw	r2,-16(fp)
 822e878:	10c00317 	ldw	r3,12(r2)
 822e87c:	e0bfff17 	ldw	r2,-4(fp)
 822e880:	1887883a 	add	r3,r3,r2
 822e884:	e0bffc17 	ldw	r2,-16(fp)
 822e888:	10c00315 	stw	r3,12(r2)
            break;
 822e88c:	00004406 	br	822e9a0 <m_adj+0x1b0>
   if ((m = mp) == NULL)
      return;

   if (len >= 0) 
   {
      while (m != NULL && len > 0) 
 822e890:	e0bffc17 	ldw	r2,-16(fp)
 822e894:	10004226 	beq	r2,zero,822e9a0 <m_adj+0x1b0>
 822e898:	e0bfff17 	ldw	r2,-4(fp)
 822e89c:	00bfe016 	blt	zero,r2,822e820 <m_adj+0x30>
 822e8a0:	00003f06 	br	822e9a0 <m_adj+0x1b0>
       * calculating its length and finding the last mbuf.
       * If the adjustment only affects this mbuf, then just
       * adjust and return.  Otherwise, rescan and truncate
       * after the remaining size.
       */
      len = -len;
 822e8a4:	e0bfff17 	ldw	r2,-4(fp)
 822e8a8:	0085c83a 	sub	r2,zero,r2
 822e8ac:	e0bfff15 	stw	r2,-4(fp)
      count = 0;
 822e8b0:	e03ffd15 	stw	zero,-12(fp)
      for (;;) 
      {
         count += m->m_len;
 822e8b4:	e0bffc17 	ldw	r2,-16(fp)
 822e8b8:	10c00217 	ldw	r3,8(r2)
 822e8bc:	e0bffd17 	ldw	r2,-12(fp)
 822e8c0:	1885883a 	add	r2,r3,r2
 822e8c4:	e0bffd15 	stw	r2,-12(fp)
         if (m->m_next == (struct mbuf *)0)
 822e8c8:	e0bffc17 	ldw	r2,-16(fp)
 822e8cc:	10800617 	ldw	r2,24(r2)
 822e8d0:	10000426 	beq	r2,zero,822e8e4 <m_adj+0xf4>
            break;
         m = m->m_next;
 822e8d4:	e0bffc17 	ldw	r2,-16(fp)
 822e8d8:	10800617 	ldw	r2,24(r2)
 822e8dc:	e0bffc15 	stw	r2,-16(fp)
      }
 822e8e0:	003ff406 	br	822e8b4 <m_adj+0xc4>
      count = 0;
      for (;;) 
      {
         count += m->m_len;
         if (m->m_next == (struct mbuf *)0)
            break;
 822e8e4:	0001883a 	nop
         m = m->m_next;
      }
      if (m->m_len >= (unsigned)len)
 822e8e8:	e0bffc17 	ldw	r2,-16(fp)
 822e8ec:	10c00217 	ldw	r3,8(r2)
 822e8f0:	e0bfff17 	ldw	r2,-4(fp)
 822e8f4:	18800736 	bltu	r3,r2,822e914 <m_adj+0x124>
      {
         m->m_len -= len;
 822e8f8:	e0bffc17 	ldw	r2,-16(fp)
 822e8fc:	10c00217 	ldw	r3,8(r2)
 822e900:	e0bfff17 	ldw	r2,-4(fp)
 822e904:	1887c83a 	sub	r3,r3,r2
 822e908:	e0bffc17 	ldw	r2,-16(fp)
 822e90c:	10c00215 	stw	r3,8(r2)
         return;
 822e910:	00002306 	br	822e9a0 <m_adj+0x1b0>
      }
      count -= len;
 822e914:	e0fffd17 	ldw	r3,-12(fp)
 822e918:	e0bfff17 	ldw	r2,-4(fp)
 822e91c:	1885c83a 	sub	r2,r3,r2
 822e920:	e0bffd15 	stw	r2,-12(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 822e924:	e0bffe17 	ldw	r2,-8(fp)
 822e928:	e0bffc15 	stw	r2,-16(fp)
 822e92c:	00001006 	br	822e970 <m_adj+0x180>
      {
         if (m->m_len >= (unsigned)count)
 822e930:	e0bffc17 	ldw	r2,-16(fp)
 822e934:	10c00217 	ldw	r3,8(r2)
 822e938:	e0bffd17 	ldw	r2,-12(fp)
 822e93c:	18800436 	bltu	r3,r2,822e950 <m_adj+0x160>
         {
            m->m_len = count;
 822e940:	e0fffd17 	ldw	r3,-12(fp)
 822e944:	e0bffc17 	ldw	r2,-16(fp)
 822e948:	10c00215 	stw	r3,8(r2)
            break;
 822e94c:	00000a06 	br	822e978 <m_adj+0x188>
         }
         count -= m->m_len;
 822e950:	e0fffd17 	ldw	r3,-12(fp)
 822e954:	e0bffc17 	ldw	r2,-16(fp)
 822e958:	10800217 	ldw	r2,8(r2)
 822e95c:	1885c83a 	sub	r2,r3,r2
 822e960:	e0bffd15 	stw	r2,-12(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 822e964:	e0bffc17 	ldw	r2,-16(fp)
 822e968:	10800617 	ldw	r2,24(r2)
 822e96c:	e0bffc15 	stw	r2,-16(fp)
 822e970:	e0bffc17 	ldw	r2,-16(fp)
 822e974:	103fee1e 	bne	r2,zero,822e930 <m_adj+0x140>
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 822e978:	00000206 	br	822e984 <m_adj+0x194>
         m->m_len = 0;
 822e97c:	e0bffc17 	ldw	r2,-16(fp)
 822e980:	10000215 	stw	zero,8(r2)
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 822e984:	e0bffc17 	ldw	r2,-16(fp)
 822e988:	10800617 	ldw	r2,24(r2)
 822e98c:	e0bffc15 	stw	r2,-16(fp)
 822e990:	e0bffc17 	ldw	r2,-16(fp)
 822e994:	103ff91e 	bne	r2,zero,822e97c <m_adj+0x18c>
 822e998:	00000106 	br	822e9a0 <m_adj+0x1b0>
{
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
      return;
 822e99c:	0001883a 	nop
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
         m->m_len = 0;
   }
}
 822e9a0:	e037883a 	mov	sp,fp
 822e9a4:	df000017 	ldw	fp,0(sp)
 822e9a8:	dec00104 	addi	sp,sp,4
 822e9ac:	f800283a 	ret

0822e9b0 <mbuf_len>:
 * RETURNS: 
 */

int
mbuf_len (struct mbuf * m)
{
 822e9b0:	defffd04 	addi	sp,sp,-12
 822e9b4:	df000215 	stw	fp,8(sp)
 822e9b8:	df000204 	addi	fp,sp,8
 822e9bc:	e13fff15 	stw	r4,-4(fp)
   int   len   =  0;
 822e9c0:	e03ffe15 	stw	zero,-8(fp)

   while (m)
 822e9c4:	00000806 	br	822e9e8 <mbuf_len+0x38>
   {
      len += m->m_len;
 822e9c8:	e0bfff17 	ldw	r2,-4(fp)
 822e9cc:	10c00217 	ldw	r3,8(r2)
 822e9d0:	e0bffe17 	ldw	r2,-8(fp)
 822e9d4:	1885883a 	add	r2,r3,r2
 822e9d8:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 822e9dc:	e0bfff17 	ldw	r2,-4(fp)
 822e9e0:	10800617 	ldw	r2,24(r2)
 822e9e4:	e0bfff15 	stw	r2,-4(fp)
int
mbuf_len (struct mbuf * m)
{
   int   len   =  0;

   while (m)
 822e9e8:	e0bfff17 	ldw	r2,-4(fp)
 822e9ec:	103ff61e 	bne	r2,zero,822e9c8 <mbuf_len+0x18>
   {
      len += m->m_len;
      m = m->m_next;
   }
   return len;
 822e9f0:	e0bffe17 	ldw	r2,-8(fp)
}
 822e9f4:	e037883a 	mov	sp,fp
 822e9f8:	df000017 	ldw	fp,0(sp)
 822e9fc:	dec00104 	addi	sp,sp,4
 822ea00:	f800283a 	ret

0822ea04 <dtom>:
 * RETURNS: 
 */

struct mbuf *  
dtom(void * data)
{
 822ea04:	defffb04 	addi	sp,sp,-20
 822ea08:	dfc00415 	stw	ra,16(sp)
 822ea0c:	df000315 	stw	fp,12(sp)
 822ea10:	df000304 	addi	fp,sp,12
 822ea14:	e13fff15 	stw	r4,-4(fp)
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 822ea18:	008209b4 	movhi	r2,2086
 822ea1c:	10b97504 	addi	r2,r2,-6700
 822ea20:	10800017 	ldw	r2,0(r2)
 822ea24:	e0bffd15 	stw	r2,-12(fp)
 822ea28:	00001206 	br	822ea74 <dtom+0x70>
   {
      m = (struct mbuf *)qptr;
 822ea2c:	e0bffd17 	ldw	r2,-12(fp)
 822ea30:	e0bffe15 	stw	r2,-8(fp)

      if (IN_RANGE(m->m_base, m->m_memsz, (char*)data))
 822ea34:	e0bffe17 	ldw	r2,-8(fp)
 822ea38:	10800417 	ldw	r2,16(r2)
 822ea3c:	e0ffff17 	ldw	r3,-4(fp)
 822ea40:	18800936 	bltu	r3,r2,822ea68 <dtom+0x64>
 822ea44:	e0bffe17 	ldw	r2,-8(fp)
 822ea48:	10c00417 	ldw	r3,16(r2)
 822ea4c:	e0bffe17 	ldw	r2,-8(fp)
 822ea50:	10800517 	ldw	r2,20(r2)
 822ea54:	1885883a 	add	r2,r3,r2
 822ea58:	e0ffff17 	ldw	r3,-4(fp)
 822ea5c:	1880022e 	bgeu	r3,r2,822ea68 <dtom+0x64>
         return (struct mbuf *)qptr;
 822ea60:	e0bffd17 	ldw	r2,-12(fp)
 822ea64:	00000906 	br	822ea8c <dtom+0x88>
dtom(void * data)
{
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 822ea68:	e0bffd17 	ldw	r2,-12(fp)
 822ea6c:	10800017 	ldw	r2,0(r2)
 822ea70:	e0bffd15 	stw	r2,-12(fp)
 822ea74:	e0bffd17 	ldw	r2,-12(fp)
 822ea78:	103fec1e 	bne	r2,zero,822ea2c <dtom+0x28>
      else
         continue;

   }

   panic("dtom");    /* data not found in any "in use" mbuf */
 822ea7c:	01020974 	movhi	r4,2085
 822ea80:	21036904 	addi	r4,r4,3492
 822ea84:	8228aec0 	call	8228aec <panic>
   return NULL;
 822ea88:	0005883a 	mov	r2,zero
}
 822ea8c:	e037883a 	mov	sp,fp
 822ea90:	dfc00117 	ldw	ra,4(sp)
 822ea94:	df000017 	ldw	fp,0(sp)
 822ea98:	dec00204 	addi	sp,sp,8
 822ea9c:	f800283a 	ret

0822eaa0 <remque>:
};


void
remque (void * arg)
{
 822eaa0:	defffd04 	addi	sp,sp,-12
 822eaa4:	df000215 	stw	fp,8(sp)
 822eaa8:	df000204 	addi	fp,sp,8
 822eaac:	e13fff15 	stw	r4,-4(fp)
   struct bsdq *  old;

   old = (struct bsdq *)arg;
 822eab0:	e0bfff17 	ldw	r2,-4(fp)
 822eab4:	e0bffe15 	stw	r2,-8(fp)
   if (!old->prev) return;
 822eab8:	e0bffe17 	ldw	r2,-8(fp)
 822eabc:	10800117 	ldw	r2,4(r2)
 822eac0:	10000e26 	beq	r2,zero,822eafc <remque+0x5c>
      old->prev->next = old->next;
 822eac4:	e0bffe17 	ldw	r2,-8(fp)
 822eac8:	10800117 	ldw	r2,4(r2)
 822eacc:	e0fffe17 	ldw	r3,-8(fp)
 822ead0:	18c00017 	ldw	r3,0(r3)
 822ead4:	10c00015 	stw	r3,0(r2)
   if (old->next)
 822ead8:	e0bffe17 	ldw	r2,-8(fp)
 822eadc:	10800017 	ldw	r2,0(r2)
 822eae0:	10000726 	beq	r2,zero,822eb00 <remque+0x60>
      old->next->prev = old->prev;
 822eae4:	e0bffe17 	ldw	r2,-8(fp)
 822eae8:	10800017 	ldw	r2,0(r2)
 822eaec:	e0fffe17 	ldw	r3,-8(fp)
 822eaf0:	18c00117 	ldw	r3,4(r3)
 822eaf4:	10c00115 	stw	r3,4(r2)
 822eaf8:	00000106 	br	822eb00 <remque+0x60>
remque (void * arg)
{
   struct bsdq *  old;

   old = (struct bsdq *)arg;
   if (!old->prev) return;
 822eafc:	0001883a 	nop
      old->prev->next = old->next;
   if (old->next)
      old->next->prev = old->prev;
}
 822eb00:	e037883a 	mov	sp,fp
 822eb04:	df000017 	ldw	fp,0(sp)
 822eb08:	dec00104 	addi	sp,sp,4
 822eb0c:	f800283a 	ret

0822eb10 <insque>:
 * RETURNS: 
 */

void
insque(void * n, void * p)
{
 822eb10:	defffb04 	addi	sp,sp,-20
 822eb14:	df000415 	stw	fp,16(sp)
 822eb18:	df000404 	addi	fp,sp,16
 822eb1c:	e13ffe15 	stw	r4,-8(fp)
 822eb20:	e17fff15 	stw	r5,-4(fp)
   struct bsdq *  newe, *  prev;

   newe = (struct bsdq *)n;
 822eb24:	e0bffe17 	ldw	r2,-8(fp)
 822eb28:	e0bffc15 	stw	r2,-16(fp)
   prev = (struct bsdq *)p;
 822eb2c:	e0bfff17 	ldw	r2,-4(fp)
 822eb30:	e0bffd15 	stw	r2,-12(fp)
   newe->next = prev->next;
 822eb34:	e0bffd17 	ldw	r2,-12(fp)
 822eb38:	10c00017 	ldw	r3,0(r2)
 822eb3c:	e0bffc17 	ldw	r2,-16(fp)
 822eb40:	10c00015 	stw	r3,0(r2)
   newe->prev = prev;
 822eb44:	e0bffc17 	ldw	r2,-16(fp)
 822eb48:	e0fffd17 	ldw	r3,-12(fp)
 822eb4c:	10c00115 	stw	r3,4(r2)
   prev->next = newe;
 822eb50:	e0bffd17 	ldw	r2,-12(fp)
 822eb54:	e0fffc17 	ldw	r3,-16(fp)
 822eb58:	10c00015 	stw	r3,0(r2)
   if (newe->next)
 822eb5c:	e0bffc17 	ldw	r2,-16(fp)
 822eb60:	10800017 	ldw	r2,0(r2)
 822eb64:	10000426 	beq	r2,zero,822eb78 <insque+0x68>
      newe->next->prev = newe;
 822eb68:	e0bffc17 	ldw	r2,-16(fp)
 822eb6c:	10800017 	ldw	r2,0(r2)
 822eb70:	e0fffc17 	ldw	r3,-16(fp)
 822eb74:	10c00115 	stw	r3,4(r2)
}
 822eb78:	0001883a 	nop
 822eb7c:	e037883a 	mov	sp,fp
 822eb80:	df000017 	ldw	fp,0(sp)
 822eb84:	dec00104 	addi	sp,sp,4
 822eb88:	f800283a 	ret

0822eb8c <nptcp_init>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
nptcp_init()
{
 822eb8c:	defffb04 	addi	sp,sp,-20
 822eb90:	dfc00415 	stw	ra,16(sp)
 822eb94:	df000315 	stw	fp,12(sp)
 822eb98:	df000304 	addi	fp,sp,12
    * buffers, soreceive() can't complete and the packet buffers stay 
    * on the queue, so we allocate 3 extra mbufs in the hope that 
    * this will allow soreceive() to complete and free up the packet 
    * buffers. yes, its kind of an ugly hack and 3 is a wild guess.
    */
   unsigned bufcount = (lilbufs + bigbufs) * 2 + 3;
 822eb9c:	d0e03617 	ldw	r3,-32552(gp)
 822eba0:	d0a03817 	ldw	r2,-32544(gp)
 822eba4:	1885883a 	add	r2,r3,r2
 822eba8:	1085883a 	add	r2,r2,r2
 822ebac:	108000c4 	addi	r2,r2,3
 822ebb0:	e0bffe15 	stw	r2,-8(fp)
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
 822ebb4:	01800504 	movi	r6,20
 822ebb8:	000b883a 	mov	r5,zero
 822ebbc:	010209b4 	movhi	r4,2086
 822ebc0:	21396104 	addi	r4,r4,-6780
 822ebc4:	82031300 	call	8203130 <memset>
   MEMSET(&mbufq, 0, sizeof(mbufq));
 822ebc8:	01800504 	movi	r6,20
 822ebcc:	000b883a 	mov	r5,zero
 822ebd0:	010209b4 	movhi	r4,2086
 822ebd4:	21397504 	addi	r4,r4,-6700
 822ebd8:	82031300 	call	8203130 <memset>
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
 822ebdc:	01800504 	movi	r6,20
 822ebe0:	000b883a 	mov	r5,zero
 822ebe4:	010209b4 	movhi	r4,2086
 822ebe8:	21397a04 	addi	r4,r4,-6680
 822ebec:	82031300 	call	8203130 <memset>
   for (i = 0; i < (int)bufcount; i++)
 822ebf0:	e03ffd15 	stw	zero,-12(fp)
 822ebf4:	00001506 	br	822ec4c <nptcp_init+0xc0>
   {
      m = MBU_ALLOC(sizeof(struct mbuf));
 822ebf8:	01000904 	movi	r4,36
 822ebfc:	822dfec0 	call	822dfec <npalloc>
 822ec00:	e0bfff15 	stw	r2,-4(fp)
      if (!m)  /* malloc error, bail out */
 822ec04:	e0bfff17 	ldw	r2,-4(fp)
 822ec08:	1000031e 	bne	r2,zero,822ec18 <nptcp_init+0x8c>
         panic("tcpinit");
 822ec0c:	01020974 	movhi	r4,2085
 822ec10:	21036b04 	addi	r4,r4,3500
 822ec14:	8228aec0 	call	8228aec <panic>
      m->m_type = MT_FREE;
 822ec18:	e0bfff17 	ldw	r2,-4(fp)
 822ec1c:	10000815 	stw	zero,32(r2)
      m->m_len = 0;
 822ec20:	e0bfff17 	ldw	r2,-4(fp)
 822ec24:	10000215 	stw	zero,8(r2)
      m->m_data = NULL;
 822ec28:	e0bfff17 	ldw	r2,-4(fp)
 822ec2c:	10000315 	stw	zero,12(r2)
      putq(&mfreeq, (qp)m);
 822ec30:	e17fff17 	ldw	r5,-4(fp)
 822ec34:	010209b4 	movhi	r4,2086
 822ec38:	21397a04 	addi	r4,r4,-6680
 822ec3c:	822cdfc0 	call	822cdfc <putq>
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
   MEMSET(&mbufq, 0, sizeof(mbufq));
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
   for (i = 0; i < (int)bufcount; i++)
 822ec40:	e0bffd17 	ldw	r2,-12(fp)
 822ec44:	10800044 	addi	r2,r2,1
 822ec48:	e0bffd15 	stw	r2,-12(fp)
 822ec4c:	e0bffe17 	ldw	r2,-8(fp)
 822ec50:	e0fffd17 	ldw	r3,-12(fp)
 822ec54:	18bfe816 	blt	r3,r2,822ebf8 <nptcp_init+0x6c>
      m->m_type = MT_FREE;
      m->m_len = 0;
      m->m_data = NULL;
      putq(&mfreeq, (qp)m);
   }
   mfreeq.q_min = (int)bufcount;   /* this should match q_max and q_len */
 822ec58:	e0fffe17 	ldw	r3,-8(fp)
 822ec5c:	008209b4 	movhi	r2,2086
 822ec60:	10b97a04 	addi	r2,r2,-6680
 822ec64:	10c00415 	stw	r3,16(r2)
   tcpmib.tcpRtoAlgorithm = 4;     /* Van Jacobson's algorithm */
   tcpmib.tcpRtoMin = TCPTV_MIN * 1000;      /* PR_SLOWHZ */
   tcpmib.tcpRtoMax = TCPTV_REXMTMAX * 1000; /* PR_SLOWHZ */
#endif

   tcp_init();    /* call the BSD init in tcp_usr.c */
 822ec68:	823933c0 	call	823933c <tcp_init>

#ifdef TCP_MENUS
   install_menu(&tcpmenu[0]);
#endif   /* IN_MENUS */

   return 0;   /* good return */
 822ec6c:	0005883a 	mov	r2,zero
}
 822ec70:	e037883a 	mov	sp,fp
 822ec74:	dfc00117 	ldw	ra,4(sp)
 822ec78:	df000017 	ldw	fp,0(sp)
 822ec7c:	dec00204 	addi	sp,sp,8
 822ec80:	f800283a 	ret

0822ec84 <tcp_rcv>:

#ifdef IP_V4
 
int
tcp_rcv(PACKET pkt)     /* NOTE: pkt has nb_prot pointing to IP header */
{
 822ec84:	defff904 	addi	sp,sp,-28
 822ec88:	dfc00615 	stw	ra,24(sp)
 822ec8c:	df000515 	stw	fp,20(sp)
 822ec90:	df000504 	addi	fp,sp,20
 822ec94:	e13fff15 	stw	r4,-4(fp)

   /* For TCP, the netport IP layer is modified to set nb_prot to the 
    * start of the IP header (not TCP). We need to do some further
    * mods which the BSD code expects:
    */
   bip = (struct ip *)pkt->nb_prot;    /* get ip header */
 822ec98:	e0bfff17 	ldw	r2,-4(fp)
 822ec9c:	10800317 	ldw	r2,12(r2)
 822eca0:	e0bffb15 	stw	r2,-20(fp)
   len = ntohs(bip->ip_len);  /* get length in local endian */
 822eca4:	e0bffb17 	ldw	r2,-20(fp)
 822eca8:	1080008b 	ldhu	r2,2(r2)
 822ecac:	10bfffcc 	andi	r2,r2,65535
 822ecb0:	1004d23a 	srli	r2,r2,8
 822ecb4:	1007883a 	mov	r3,r2
 822ecb8:	e0bffb17 	ldw	r2,-20(fp)
 822ecbc:	1080008b 	ldhu	r2,2(r2)
 822ecc0:	10bfffcc 	andi	r2,r2,65535
 822ecc4:	1004923a 	slli	r2,r2,8
 822ecc8:	1884b03a 	or	r2,r3,r2
 822eccc:	e0bffc0d 	sth	r2,-16(fp)

   /* verify checksum of received packet */

   tcpp = (struct tcphdr *)ip_data(bip);
 822ecd0:	e0bffb17 	ldw	r2,-20(fp)
 822ecd4:	10800003 	ldbu	r2,0(r2)
 822ecd8:	10803fcc 	andi	r2,r2,255
 822ecdc:	108003cc 	andi	r2,r2,15
 822ece0:	1085883a 	add	r2,r2,r2
 822ece4:	1085883a 	add	r2,r2,r2
 822ece8:	1007883a 	mov	r3,r2
 822ecec:	e0bffb17 	ldw	r2,-20(fp)
 822ecf0:	10c5883a 	add	r2,r2,r3
 822ecf4:	e0bffd15 	stw	r2,-12(fp)
   if (tcp_cksum(bip) != tcpp->th_sum)
 822ecf8:	e13ffb17 	ldw	r4,-20(fp)
 822ecfc:	8247ae80 	call	8247ae8 <tcp_cksum>
 822ed00:	1007883a 	mov	r3,r2
 822ed04:	e0bffd17 	ldw	r2,-12(fp)
 822ed08:	1080040b 	ldhu	r2,16(r2)
 822ed0c:	18ffffcc 	andi	r3,r3,65535
 822ed10:	10bfffcc 	andi	r2,r2,65535
 822ed14:	18801626 	beq	r3,r2,822ed70 <tcp_rcv+0xec>
   {
      TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 822ed18:	008209b4 	movhi	r2,2086
 822ed1c:	10b96604 	addi	r2,r2,-6760
 822ed20:	10800d17 	ldw	r2,52(r2)
 822ed24:	10c00044 	addi	r3,r2,1
 822ed28:	008209b4 	movhi	r2,2086
 822ed2c:	10b96604 	addi	r2,r2,-6760
 822ed30:	10c00d15 	stw	r3,52(r2)
      tcpstat.tcps_rcvbadsum++;  /* keep BSD stats */
 822ed34:	008209b4 	movhi	r2,2086
 822ed38:	10b99404 	addi	r2,r2,-6576
 822ed3c:	10801c17 	ldw	r2,112(r2)
 822ed40:	10c00044 	addi	r3,r2,1
 822ed44:	008209b4 	movhi	r2,2086
 822ed48:	10b99404 	addi	r2,r2,-6576
 822ed4c:	10c01c15 	stw	r3,112(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822ed50:	01000084 	movi	r4,2
 822ed54:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(pkt);  /* punt packet */
 822ed58:	e13fff17 	ldw	r4,-4(fp)
 822ed5c:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822ed60:	01000084 	movi	r4,2
 822ed64:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 822ed68:	00bff804 	movi	r2,-32
 822ed6c:	00003406 	br	822ee40 <tcp_rcv+0x1bc>
   }

   m_in = m_getnbuf(MT_RXDATA, 0);
 822ed70:	000b883a 	mov	r5,zero
 822ed74:	01000044 	movi	r4,1
 822ed78:	822e2280 	call	822e228 <m_getnbuf>
 822ed7c:	e0bffe15 	stw	r2,-8(fp)
   if (!m_in){
 822ed80:	e0bffe17 	ldw	r2,-8(fp)
 822ed84:	1000081e 	bne	r2,zero,822eda8 <tcp_rcv+0x124>
      LOCK_NET_RESOURCE(FREEQ_RESID);
 822ed88:	01000084 	movi	r4,2
 822ed8c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 822ed90:	e13fff17 	ldw	r4,-4(fp)
 822ed94:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822ed98:	01000084 	movi	r4,2
 822ed9c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;  
 822eda0:	00bffa84 	movi	r2,-22
 822eda4:	00002606 	br	822ee40 <tcp_rcv+0x1bc>
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);      /* measure time in TCP */

   /* subtract IP header length from total IP packet length */
   len -= ((unshort)(bip->ip_ver_ihl & 0x0f) << 2);
 822eda8:	e0bffb17 	ldw	r2,-20(fp)
 822edac:	10800003 	ldbu	r2,0(r2)
 822edb0:	10803fcc 	andi	r2,r2,255
 822edb4:	108003cc 	andi	r2,r2,15
 822edb8:	1085883a 	add	r2,r2,r2
 822edbc:	1085883a 	add	r2,r2,r2
 822edc0:	1007883a 	mov	r3,r2
 822edc4:	e0bffc0b 	ldhu	r2,-16(fp)
 822edc8:	10c5c83a 	sub	r2,r2,r3
 822edcc:	e0bffc0d 	sth	r2,-16(fp)
   bip->ip_len = len;   /* put TCP length in struct for TCP code to use */
 822edd0:	e0bffb17 	ldw	r2,-20(fp)
 822edd4:	e0fffc0b 	ldhu	r3,-16(fp)
 822edd8:	10c0008d 	sth	r3,2(r2)

   /* set mbuf to point to start of IP header (not TCP) */
   m_in->pkt = pkt;
 822eddc:	e0bffe17 	ldw	r2,-8(fp)
 822ede0:	e0ffff17 	ldw	r3,-4(fp)
 822ede4:	10c00115 	stw	r3,4(r2)
   m_in->m_data = pkt->nb_prot;
 822ede8:	e0bfff17 	ldw	r2,-4(fp)
 822edec:	10c00317 	ldw	r3,12(r2)
 822edf0:	e0bffe17 	ldw	r2,-8(fp)
 822edf4:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 822edf8:	e0bfff17 	ldw	r2,-4(fp)
 822edfc:	10c00417 	ldw	r3,16(r2)
 822ee00:	e0bffe17 	ldw	r2,-8(fp)
 822ee04:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;     /* ??? */
 822ee08:	e0bfff17 	ldw	r2,-4(fp)
 822ee0c:	10c00117 	ldw	r3,4(r2)
 822ee10:	e0bffe17 	ldw	r2,-8(fp)
 822ee14:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;    /* ??? */
 822ee18:	e0bfff17 	ldw	r2,-4(fp)
 822ee1c:	10c00217 	ldw	r3,8(r2)
 822ee20:	e0bffe17 	ldw	r2,-8(fp)
 822ee24:	10c00515 	stw	r3,20(r2)

   tcp_input(m_in, pkt->net);
 822ee28:	e0bfff17 	ldw	r2,-4(fp)
 822ee2c:	10800617 	ldw	r2,24(r2)
 822ee30:	100b883a 	mov	r5,r2
 822ee34:	e13ffe17 	ldw	r4,-8(fp)
 822ee38:	82358000 	call	8235800 <tcp_input>

   IN_PROFILER(PF_TCP, PF_EXIT);      /* measure time in TCP */

   return 0;
 822ee3c:	0005883a 	mov	r2,zero
}
 822ee40:	e037883a 	mov	sp,fp
 822ee44:	dfc00117 	ldw	ra,4(sp)
 822ee48:	df000017 	ldw	fp,0(sp)
 822ee4c:	dec00204 	addi	sp,sp,8
 822ee50:	f800283a 	ret

0822ee54 <ip_output>:
 * RETURNS: 
 */

int
ip_output(struct mbuf * data, struct   ip_socopts * so_optsPack) /* mbuf chain with data to send */
{
 822ee54:	defff404 	addi	sp,sp,-48
 822ee58:	dfc00b15 	stw	ra,44(sp)
 822ee5c:	df000a15 	stw	fp,40(sp)
 822ee60:	df000a04 	addi	fp,sp,40
 822ee64:	e13ffe15 	stw	r4,-8(fp)
 822ee68:	e17fff15 	stw	r5,-4(fp)
    * little copying as possible. Typically the mbufs will be either 
    * 1) a single mbuf with iptcp header info only (e.g.tcp ACK 
    * packet), or 2) iptcp header with data mbuf chained to it, or 3) 
    * #2) with a tiny option data mbuf between header and data. 
    */
   if ((data->m_next))
 822ee6c:	e0bffe17 	ldw	r2,-8(fp)
 822ee70:	10800617 	ldw	r2,24(r2)
 822ee74:	10010a26 	beq	r2,zero,822f2a0 <ip_output+0x44c>
   {
      m1 = data;
 822ee78:	e0bffe17 	ldw	r2,-8(fp)
 822ee7c:	e0bff615 	stw	r2,-40(fp)
      m2 = data->m_next;
 822ee80:	e0bffe17 	ldw	r2,-8(fp)
 822ee84:	10800617 	ldw	r2,24(r2)
 822ee88:	e0bff715 	stw	r2,-36(fp)

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 822ee8c:	00003506 	br	822ef64 <ip_output+0x110>
      {
         pkt = m1->pkt;
 822ee90:	e0bff617 	ldw	r2,-40(fp)
 822ee94:	10800117 	ldw	r2,4(r2)
 822ee98:	e0bffa15 	stw	r2,-24(fp)
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 822ee9c:	e0bffa17 	ldw	r2,-24(fp)
 822eea0:	10c00117 	ldw	r3,4(r2)
 822eea4:	e0bffa17 	ldw	r2,-24(fp)
 822eea8:	10800217 	ldw	r2,8(r2)
 822eeac:	1885883a 	add	r2,r3,r2
             (m1->m_data + m1->m_len + m2->m_len))
 822eeb0:	e0fff617 	ldw	r3,-40(fp)
 822eeb4:	19000317 	ldw	r4,12(r3)
 822eeb8:	e0fff617 	ldw	r3,-40(fp)
 822eebc:	19400217 	ldw	r5,8(r3)
 822eec0:	e0fff717 	ldw	r3,-36(fp)
 822eec4:	18c00217 	ldw	r3,8(r3)
 822eec8:	28c7883a 	add	r3,r5,r3
 822eecc:	20c7883a 	add	r3,r4,r3

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
      {
         pkt = m1->pkt;
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 822eed0:	18802b2e 	bgeu	r3,r2,822ef80 <ip_output+0x12c>
             (m1->m_data + m1->m_len + m2->m_len))
         {
            MEMCPY((m1->m_data + m1->m_len), m2->m_data, m2->m_len);
 822eed4:	e0bff617 	ldw	r2,-40(fp)
 822eed8:	10c00317 	ldw	r3,12(r2)
 822eedc:	e0bff617 	ldw	r2,-40(fp)
 822eee0:	10800217 	ldw	r2,8(r2)
 822eee4:	1887883a 	add	r3,r3,r2
 822eee8:	e0bff717 	ldw	r2,-36(fp)
 822eeec:	11000317 	ldw	r4,12(r2)
 822eef0:	e0bff717 	ldw	r2,-36(fp)
 822eef4:	10800217 	ldw	r2,8(r2)
 822eef8:	100d883a 	mov	r6,r2
 822eefc:	200b883a 	mov	r5,r4
 822ef00:	1809883a 	mov	r4,r3
 822ef04:	8202e8c0 	call	8202e8c <memcpy>
            m1->m_len += m2->m_len;
 822ef08:	e0bff617 	ldw	r2,-40(fp)
 822ef0c:	10c00217 	ldw	r3,8(r2)
 822ef10:	e0bff717 	ldw	r2,-36(fp)
 822ef14:	10800217 	ldw	r2,8(r2)
 822ef18:	1887883a 	add	r3,r3,r2
 822ef1c:	e0bff617 	ldw	r2,-40(fp)
 822ef20:	10c00215 	stw	r3,8(r2)
            m1->m_next = m2->m_next;
 822ef24:	e0bff717 	ldw	r2,-36(fp)
 822ef28:	10c00617 	ldw	r3,24(r2)
 822ef2c:	e0bff617 	ldw	r2,-40(fp)
 822ef30:	10c00615 	stw	r3,24(r2)
            m_free(m2);    /* free this m2.... */
 822ef34:	e13ff717 	ldw	r4,-36(fp)
 822ef38:	822e3b00 	call	822e3b0 <m_free>
            m2 = m1->m_next;  /* ...and thread the next one */
 822ef3c:	e0bff617 	ldw	r2,-40(fp)
 822ef40:	10800617 	ldw	r2,24(r2)
 822ef44:	e0bff715 	stw	r2,-36(fp)
            tcpstat.tcps_oappends++;
 822ef48:	008209b4 	movhi	r2,2086
 822ef4c:	10b99404 	addi	r2,r2,-6576
 822ef50:	10803317 	ldw	r2,204(r2)
 822ef54:	10c00044 	addi	r3,r2,1
 822ef58:	008209b4 	movhi	r2,2086
 822ef5c:	10b99404 	addi	r2,r2,-6576
 822ef60:	10c03315 	stw	r3,204(r2)
   {
      m1 = data;
      m2 = data->m_next;

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 822ef64:	e0bff717 	ldw	r2,-36(fp)
 822ef68:	10005b26 	beq	r2,zero,822f0d8 <ip_output+0x284>
 822ef6c:	e0bff717 	ldw	r2,-36(fp)
 822ef70:	10800217 	ldw	r2,8(r2)
 822ef74:	108002b0 	cmpltui	r2,r2,10
 822ef78:	103fc51e 	bne	r2,zero,822ee90 <ip_output+0x3c>
 822ef7c:	00005606 	br	822f0d8 <ip_output+0x284>
            m_free(m2);    /* free this m2.... */
            m2 = m1->m_next;  /* ...and thread the next one */
            tcpstat.tcps_oappends++;
         }
         else     /* if won't fit, fall to next copy */
            break;
 822ef80:	0001883a 	nop
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 822ef84:	00005406 	br	822f0d8 <ip_output+0x284>
      {
         /* try prepending m1 to m2, first see if it fits: */
         e = m2->m_data - m2->pkt->nb_buff;  /* e is prepend space */
 822ef88:	e0bff717 	ldw	r2,-36(fp)
 822ef8c:	10800317 	ldw	r2,12(r2)
 822ef90:	1007883a 	mov	r3,r2
 822ef94:	e0bff717 	ldw	r2,-36(fp)
 822ef98:	10800117 	ldw	r2,4(r2)
 822ef9c:	10800117 	ldw	r2,4(r2)
 822efa0:	1885c83a 	sub	r2,r3,r2
 822efa4:	e0bffb15 	stw	r2,-20(fp)
         if (e < MaxLnh)
 822efa8:	d0a08117 	ldw	r2,-32252(gp)
 822efac:	e0fffb17 	ldw	r3,-20(fp)
 822efb0:	1880090e 	bge	r3,r2,822efd8 <ip_output+0x184>
         { 
#ifdef NPDEBUG
            dprintf("nptcp: MaxLnh:%d, e:%d\n", MaxLnh, e);
 822efb4:	d0a08117 	ldw	r2,-32252(gp)
 822efb8:	e1bffb17 	ldw	r6,-20(fp)
 822efbc:	100b883a 	mov	r5,r2
 822efc0:	01020974 	movhi	r4,2085
 822efc4:	21036d04 	addi	r4,r4,3508
 822efc8:	820331c0 	call	820331c <printf>
#endif
            panic("tcp_out:mbuf-nbuf");   /* sanity check */
 822efcc:	01020974 	movhi	r4,2085
 822efd0:	21037304 	addi	r4,r4,3532
 822efd4:	8228aec0 	call	8228aec <panic>
         }

         if ((m1->m_len < (unsigned)(e - MaxLnh))  /* leave room for MAC */
 822efd8:	e0bff617 	ldw	r2,-40(fp)
 822efdc:	10800217 	ldw	r2,8(r2)
 822efe0:	d0e08117 	ldw	r3,-32252(gp)
 822efe4:	e13ffb17 	ldw	r4,-20(fp)
 822efe8:	20c7c83a 	sub	r3,r4,r3
 822efec:	10c03c2e 	bgeu	r2,r3,822f0e0 <ip_output+0x28c>
             && ((m1->m_len & (ALIGN_TYPE - 1)) == 0)  /* and stay aligned */
 822eff0:	e0bff617 	ldw	r2,-40(fp)
 822eff4:	10800217 	ldw	r2,8(r2)
 822eff8:	108000cc 	andi	r2,r2,3
 822effc:	1000381e 	bne	r2,zero,822f0e0 <ip_output+0x28c>
             && ((m2->m_data - m2->pkt->nb_buff) == HDRSLEN))   /* be at start */
 822f000:	e0bff717 	ldw	r2,-36(fp)
 822f004:	10800317 	ldw	r2,12(r2)
 822f008:	1007883a 	mov	r3,r2
 822f00c:	e0bff717 	ldw	r2,-36(fp)
 822f010:	10800117 	ldw	r2,4(r2)
 822f014:	10800117 	ldw	r2,4(r2)
 822f018:	1885c83a 	sub	r2,r3,r2
 822f01c:	10800e18 	cmpnei	r2,r2,56
 822f020:	10002f1e 	bne	r2,zero,822f0e0 <ip_output+0x28c>
         {
            MEMCPY((m2->m_data - m1->m_len), m1->m_data, m1->m_len);
 822f024:	e0bff717 	ldw	r2,-36(fp)
 822f028:	10c00317 	ldw	r3,12(r2)
 822f02c:	e0bff617 	ldw	r2,-40(fp)
 822f030:	10800217 	ldw	r2,8(r2)
 822f034:	0085c83a 	sub	r2,zero,r2
 822f038:	1887883a 	add	r3,r3,r2
 822f03c:	e0bff617 	ldw	r2,-40(fp)
 822f040:	11000317 	ldw	r4,12(r2)
 822f044:	e0bff617 	ldw	r2,-40(fp)
 822f048:	10800217 	ldw	r2,8(r2)
 822f04c:	100d883a 	mov	r6,r2
 822f050:	200b883a 	mov	r5,r4
 822f054:	1809883a 	mov	r4,r3
 822f058:	8202e8c0 	call	8202e8c <memcpy>
            m2->m_data -= m1->m_len;   /* fix target to reflect prepend */
 822f05c:	e0bff717 	ldw	r2,-36(fp)
 822f060:	10c00317 	ldw	r3,12(r2)
 822f064:	e0bff617 	ldw	r2,-40(fp)
 822f068:	10800217 	ldw	r2,8(r2)
 822f06c:	0085c83a 	sub	r2,zero,r2
 822f070:	1887883a 	add	r3,r3,r2
 822f074:	e0bff717 	ldw	r2,-36(fp)
 822f078:	10c00315 	stw	r3,12(r2)
            m2->m_len += m1->m_len;
 822f07c:	e0bff717 	ldw	r2,-36(fp)
 822f080:	10c00217 	ldw	r3,8(r2)
 822f084:	e0bff617 	ldw	r2,-40(fp)
 822f088:	10800217 	ldw	r2,8(r2)
 822f08c:	1887883a 	add	r3,r3,r2
 822f090:	e0bff717 	ldw	r2,-36(fp)
 822f094:	10c00215 	stw	r3,8(r2)
            m_free(m1);    /* free head (copied) mbuf */
 822f098:	e13ff617 	ldw	r4,-40(fp)
 822f09c:	822e3b00 	call	822e3b0 <m_free>
            data = m1 = m2;   /* move other mbufs up the chain */
 822f0a0:	e0bff717 	ldw	r2,-36(fp)
 822f0a4:	e0bff615 	stw	r2,-40(fp)
 822f0a8:	e0bff617 	ldw	r2,-40(fp)
 822f0ac:	e0bffe15 	stw	r2,-8(fp)
            m2 = m2->m_next;  /* loop to while(m2) test */
 822f0b0:	e0bff717 	ldw	r2,-36(fp)
 822f0b4:	10800617 	ldw	r2,24(r2)
 822f0b8:	e0bff715 	stw	r2,-36(fp)
            tcpstat.tcps_oprepends++;
 822f0bc:	008209b4 	movhi	r2,2086
 822f0c0:	10b99404 	addi	r2,r2,-6576
 822f0c4:	10803217 	ldw	r2,200(r2)
 822f0c8:	10c00044 	addi	r3,r2,1
 822f0cc:	008209b4 	movhi	r2,2086
 822f0d0:	10b99404 	addi	r2,r2,-6576
 822f0d4:	10c03215 	stw	r3,200(r2)
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 822f0d8:	e0bff717 	ldw	r2,-36(fp)
 822f0dc:	103faa1e 	bne	r2,zero,822ef88 <ip_output+0x134>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      if (m2)  /* If all else fails, brute force copy: */
 822f0e0:	e0bff717 	ldw	r2,-36(fp)
 822f0e4:	10006e26 	beq	r2,zero,822f2a0 <ip_output+0x44c>
      {
         total = 0;
 822f0e8:	e03ff915 	stw	zero,-28(fp)
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 822f0ec:	e0bff617 	ldw	r2,-40(fp)
 822f0f0:	e0bff815 	stw	r2,-32(fp)
 822f0f4:	00000806 	br	822f118 <ip_output+0x2c4>
            total += mtmp->m_len;
 822f0f8:	e0bff817 	ldw	r2,-32(fp)
 822f0fc:	10c00217 	ldw	r3,8(r2)
 822f100:	e0bff917 	ldw	r2,-28(fp)
 822f104:	1885883a 	add	r2,r3,r2
 822f108:	e0bff915 	stw	r2,-28(fp)
      }

      if (m2)  /* If all else fails, brute force copy: */
      {
         total = 0;
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 822f10c:	e0bff817 	ldw	r2,-32(fp)
 822f110:	10800617 	ldw	r2,24(r2)
 822f114:	e0bff815 	stw	r2,-32(fp)
 822f118:	e0bff817 	ldw	r2,-32(fp)
 822f11c:	103ff61e 	bne	r2,zero,822f0f8 <ip_output+0x2a4>
            total += mtmp->m_len;
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822f120:	01000084 	movi	r4,2
 822f124:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pkt = pk_alloc(total + HDRSLEN);
 822f128:	e0bff917 	ldw	r2,-28(fp)
 822f12c:	10800e04 	addi	r2,r2,56
 822f130:	1009883a 	mov	r4,r2
 822f134:	822c86c0 	call	822c86c <pk_alloc>
 822f138:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822f13c:	01000084 	movi	r4,2
 822f140:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         if (!pkt)
 822f144:	e0bffa17 	ldw	r2,-24(fp)
 822f148:	1000021e 	bne	r2,zero,822f154 <ip_output+0x300>
            return ENOBUFS;
 822f14c:	00801a44 	movi	r2,105
 822f150:	0000a706 	br	822f3f0 <ip_output+0x59c>
         pkt->nb_prot = pkt->nb_buff + MaxLnh;
 822f154:	e0bffa17 	ldw	r2,-24(fp)
 822f158:	10800117 	ldw	r2,4(r2)
 822f15c:	d0e08117 	ldw	r3,-32252(gp)
 822f160:	10c7883a 	add	r3,r2,r3
 822f164:	e0bffa17 	ldw	r2,-24(fp)
 822f168:	10c00315 	stw	r3,12(r2)

         mtmp = m1;
 822f16c:	e0bff617 	ldw	r2,-40(fp)
 822f170:	e0bff815 	stw	r2,-32(fp)
         while (mtmp)
 822f174:	00002906 	br	822f21c <ip_output+0x3c8>
         {
            MEMCPY(pkt->nb_prot, mtmp->m_data, mtmp->m_len);
 822f178:	e0bffa17 	ldw	r2,-24(fp)
 822f17c:	10c00317 	ldw	r3,12(r2)
 822f180:	e0bff817 	ldw	r2,-32(fp)
 822f184:	11000317 	ldw	r4,12(r2)
 822f188:	e0bff817 	ldw	r2,-32(fp)
 822f18c:	10800217 	ldw	r2,8(r2)
 822f190:	100d883a 	mov	r6,r2
 822f194:	200b883a 	mov	r5,r4
 822f198:	1809883a 	mov	r4,r3
 822f19c:	8202e8c0 	call	8202e8c <memcpy>
            pkt->nb_prot += mtmp->m_len;
 822f1a0:	e0bffa17 	ldw	r2,-24(fp)
 822f1a4:	10c00317 	ldw	r3,12(r2)
 822f1a8:	e0bff817 	ldw	r2,-32(fp)
 822f1ac:	10800217 	ldw	r2,8(r2)
 822f1b0:	1887883a 	add	r3,r3,r2
 822f1b4:	e0bffa17 	ldw	r2,-24(fp)
 822f1b8:	10c00315 	stw	r3,12(r2)
            pkt->nb_plen += mtmp->m_len;
 822f1bc:	e0bffa17 	ldw	r2,-24(fp)
 822f1c0:	10c00417 	ldw	r3,16(r2)
 822f1c4:	e0bff817 	ldw	r2,-32(fp)
 822f1c8:	10800217 	ldw	r2,8(r2)
 822f1cc:	1887883a 	add	r3,r3,r2
 822f1d0:	e0bffa17 	ldw	r2,-24(fp)
 822f1d4:	10c00415 	stw	r3,16(r2)
            m2 = mtmp;
 822f1d8:	e0bff817 	ldw	r2,-32(fp)
 822f1dc:	e0bff715 	stw	r2,-36(fp)
            mtmp = mtmp->m_next;
 822f1e0:	e0bff817 	ldw	r2,-32(fp)
 822f1e4:	10800617 	ldw	r2,24(r2)
 822f1e8:	e0bff815 	stw	r2,-32(fp)
            if (m2 != data)   /* save original head */
 822f1ec:	e0fff717 	ldw	r3,-36(fp)
 822f1f0:	e0bffe17 	ldw	r2,-8(fp)
 822f1f4:	18800226 	beq	r3,r2,822f200 <ip_output+0x3ac>
               m_free(m2);
 822f1f8:	e13ff717 	ldw	r4,-36(fp)
 822f1fc:	822e3b00 	call	822e3b0 <m_free>
            tcpstat.tcps_ocopies++;
 822f200:	008209b4 	movhi	r2,2086
 822f204:	10b99404 	addi	r2,r2,-6576
 822f208:	10803417 	ldw	r2,208(r2)
 822f20c:	10c00044 	addi	r3,r2,1
 822f210:	008209b4 	movhi	r2,2086
 822f214:	10b99404 	addi	r2,r2,-6576
 822f218:	10c03415 	stw	r3,208(r2)
         if (!pkt)
            return ENOBUFS;
         pkt->nb_prot = pkt->nb_buff + MaxLnh;

         mtmp = m1;
         while (mtmp)
 822f21c:	e0bff817 	ldw	r2,-32(fp)
 822f220:	103fd51e 	bne	r2,zero,822f178 <ip_output+0x324>
            mtmp = mtmp->m_next;
            if (m2 != data)   /* save original head */
               m_free(m2);
            tcpstat.tcps_ocopies++;
         }
         pkt->nb_prot -= total;     /* fix data pointer */
 822f224:	e0bffa17 	ldw	r2,-24(fp)
 822f228:	10c00317 	ldw	r3,12(r2)
 822f22c:	e0bff917 	ldw	r2,-28(fp)
 822f230:	0085c83a 	sub	r2,zero,r2
 822f234:	1887883a 	add	r3,r3,r2
 822f238:	e0bffa17 	ldw	r2,-24(fp)
 822f23c:	10c00315 	stw	r3,12(r2)

         /* release the original mbufs packet install the new one */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 822f240:	01000084 	movi	r4,2
 822f244:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free(data->pkt);
 822f248:	e0bffe17 	ldw	r2,-8(fp)
 822f24c:	10800117 	ldw	r2,4(r2)
 822f250:	1009883a 	mov	r4,r2
 822f254:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822f258:	01000084 	movi	r4,2
 822f25c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         data->pkt = pkt;
 822f260:	e0bffe17 	ldw	r2,-8(fp)
 822f264:	e0fffa17 	ldw	r3,-24(fp)
 822f268:	10c00115 	stw	r3,4(r2)
         data->m_len = pkt->nb_plen;
 822f26c:	e0bffa17 	ldw	r2,-24(fp)
 822f270:	10c00417 	ldw	r3,16(r2)
 822f274:	e0bffe17 	ldw	r2,-8(fp)
 822f278:	10c00215 	stw	r3,8(r2)
         data->m_next = NULL;
 822f27c:	e0bffe17 	ldw	r2,-8(fp)
 822f280:	10000615 	stw	zero,24(r2)
         data->m_data = pkt->nb_prot;
 822f284:	e0bffa17 	ldw	r2,-24(fp)
 822f288:	10c00317 	ldw	r3,12(r2)
 822f28c:	e0bffe17 	ldw	r2,-8(fp)
 822f290:	10c00315 	stw	r3,12(r2)
         data->m_len = total;
 822f294:	e0fff917 	ldw	r3,-28(fp)
 822f298:	e0bffe17 	ldw	r2,-8(fp)
 822f29c:	10c00215 	stw	r3,8(r2)
      }
   }

   if ((data->m_data < (data->pkt->nb_buff + MaxLnh)))
 822f2a0:	e0bffe17 	ldw	r2,-8(fp)
 822f2a4:	10c00317 	ldw	r3,12(r2)
 822f2a8:	e0bffe17 	ldw	r2,-8(fp)
 822f2ac:	10800117 	ldw	r2,4(r2)
 822f2b0:	10800117 	ldw	r2,4(r2)
 822f2b4:	d1208117 	ldw	r4,-32252(gp)
 822f2b8:	1105883a 	add	r2,r2,r4
 822f2bc:	1880032e 	bgeu	r3,r2,822f2cc <ip_output+0x478>
      panic("ip_output: overflow");
 822f2c0:	01020974 	movhi	r4,2085
 822f2c4:	21037804 	addi	r4,r4,3552
 822f2c8:	8228aec0 	call	8228aec <panic>

   pkt = data->pkt;
 822f2cc:	e0bffe17 	ldw	r2,-8(fp)
 822f2d0:	10800117 	ldw	r2,4(r2)
 822f2d4:	e0bffa15 	stw	r2,-24(fp)

   /* do we have options? */
   if (so_optsPack)
 822f2d8:	e0bfff17 	ldw	r2,-4(fp)
 822f2dc:	10000326 	beq	r2,zero,822f2ec <ip_output+0x498>
	   pkt->soxopts = so_optsPack;   /* yup */
 822f2e0:	e0bffa17 	ldw	r2,-24(fp)
 822f2e4:	e0ffff17 	ldw	r3,-4(fp)
 822f2e8:	10c00c15 	stw	r3,48(r2)
      panic("ip_output: no so_optsPack for the IPv6 scope");     
   }
#endif

   /* fill in dest host for IP layer */
   bip = (struct ip *)data->m_data;
 822f2ec:	e0bffe17 	ldw	r2,-8(fp)
 822f2f0:	10800317 	ldw	r2,12(r2)
 822f2f4:	e0bffc15 	stw	r2,-16(fp)
   pkt->fhost = bip->ip_dest;
 822f2f8:	e0bffc17 	ldw	r2,-16(fp)
 822f2fc:	10c00417 	ldw	r3,16(r2)
 822f300:	e0bffa17 	ldw	r2,-24(fp)
 822f304:	10c00715 	stw	r3,28(r2)

   /* make enough IP header for cksum calculation */
   bip->ip_ver_ihl = 0x45;
 822f308:	e0bffc17 	ldw	r2,-16(fp)
 822f30c:	00c01144 	movi	r3,69
 822f310:	10c00005 	stb	r3,0(r2)
   bip->ip_len = htons(bip->ip_len);   /* make net endian for calculation */
 822f314:	e0bffc17 	ldw	r2,-16(fp)
 822f318:	1080008b 	ldhu	r2,2(r2)
 822f31c:	10bfffcc 	andi	r2,r2,65535
 822f320:	1004d23a 	srli	r2,r2,8
 822f324:	1007883a 	mov	r3,r2
 822f328:	e0bffc17 	ldw	r2,-16(fp)
 822f32c:	1080008b 	ldhu	r2,2(r2)
 822f330:	10bfffcc 	andi	r2,r2,65535
 822f334:	1004923a 	slli	r2,r2,8
 822f338:	1884b03a 	or	r2,r3,r2
 822f33c:	1007883a 	mov	r3,r2
 822f340:	e0bffc17 	ldw	r2,-16(fp)
 822f344:	10c0008d 	sth	r3,2(r2)
   tcpp = (struct tcphdr *)ip_data(bip);
 822f348:	e0bffc17 	ldw	r2,-16(fp)
 822f34c:	10800003 	ldbu	r2,0(r2)
 822f350:	10803fcc 	andi	r2,r2,255
 822f354:	108003cc 	andi	r2,r2,15
 822f358:	1085883a 	add	r2,r2,r2
 822f35c:	1085883a 	add	r2,r2,r2
 822f360:	1007883a 	mov	r3,r2
 822f364:	e0bffc17 	ldw	r2,-16(fp)
 822f368:	10c5883a 	add	r2,r2,r3
 822f36c:	e0bffd15 	stw	r2,-12(fp)
#ifdef CSUM_DEMO
   if (!(tcpp->th_flags & TH_SYN))
   tcpp->th_flags |= TH_PUSH;     /* force the PSH flag in TCP hdr */
#endif
   tcpp->th_sum = tcp_cksum(bip);
 822f370:	e13ffc17 	ldw	r4,-16(fp)
 822f374:	8247ae80 	call	8247ae8 <tcp_cksum>
 822f378:	1007883a 	mov	r3,r2
 822f37c:	e0bffd17 	ldw	r2,-12(fp)
 822f380:	10c0040d 	sth	r3,16(r2)

   pkt->nb_prot = (char*)(bip + 1);    /* point past IP header */
 822f384:	e0bffc17 	ldw	r2,-16(fp)
 822f388:	10c00504 	addi	r3,r2,20
 822f38c:	e0bffa17 	ldw	r2,-24(fp)
 822f390:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen = data->m_len - sizeof(struct ip);
 822f394:	e0bffe17 	ldw	r2,-8(fp)
 822f398:	10800217 	ldw	r2,8(r2)
 822f39c:	10fffb04 	addi	r3,r2,-20
 822f3a0:	e0bffa17 	ldw	r2,-24(fp)
 822f3a4:	10c00415 	stw	r3,16(r2)

   e = ip_write(IPPROTO_TCP, pkt);
 822f3a8:	e17ffa17 	ldw	r5,-24(fp)
 822f3ac:	01000184 	movi	r4,6
 822f3b0:	823f7b00 	call	823f7b0 <ip_write>
 822f3b4:	e0bffb15 	stw	r2,-20(fp)

   /* ip_write() is now responsable for data->pkt, so... */
   data->pkt = NULL;
 822f3b8:	e0bffe17 	ldw	r2,-8(fp)
 822f3bc:	10000115 	stw	zero,4(r2)
   m_freem(data);
 822f3c0:	e13ffe17 	ldw	r4,-8(fp)
 822f3c4:	822e4b80 	call	822e4b8 <m_freem>

   if (e < 0)
 822f3c8:	e0bffb17 	ldw	r2,-20(fp)
 822f3cc:	1000070e 	bge	r2,zero,822f3ec <ip_output+0x598>
   {
      /* don't report dropped sends, it causes socket applications to 
      bail when a TCP retry will fix the problem */
      if (e == SEND_DROPPED)
 822f3d0:	e0bffb17 	ldw	r2,-20(fp)
 822f3d4:	10bffa98 	cmpnei	r2,r2,-22
 822f3d8:	1000021e 	bne	r2,zero,822f3e4 <ip_output+0x590>
         return 0;
 822f3dc:	0005883a 	mov	r2,zero
 822f3e0:	00000306 	br	822f3f0 <ip_output+0x59c>
      return e;
 822f3e4:	e0bffb17 	ldw	r2,-20(fp)
 822f3e8:	00000106 	br	822f3f0 <ip_output+0x59c>
   }
   else
      return 0;
 822f3ec:	0005883a 	mov	r2,zero
}
 822f3f0:	e037883a 	mov	sp,fp
 822f3f4:	dfc00117 	ldw	ra,4(sp)
 822f3f8:	df000017 	ldw	fp,0(sp)
 822f3fc:	dec00204 	addi	sp,sp,8
 822f400:	f800283a 	ret

0822f404 <in_broadcast>:
 * RETURNS: TRUE if broadcast, else FALSE
 */

int
in_broadcast(u_long ipaddr)   /* passed in net endian */
{
 822f404:	defffe04 	addi	sp,sp,-8
 822f408:	df000115 	stw	fp,4(sp)
 822f40c:	df000104 	addi	fp,sp,4
 822f410:	e13fff15 	stw	r4,-4(fp)
   if (ipaddr == 0xffffffff)
 822f414:	e0bfff17 	ldw	r2,-4(fp)
 822f418:	10bfffd8 	cmpnei	r2,r2,-1
 822f41c:	1000021e 	bne	r2,zero,822f428 <in_broadcast+0x24>
      return TRUE;
 822f420:	00800044 	movi	r2,1
 822f424:	00000106 	br	822f42c <in_broadcast+0x28>

   return FALSE;
 822f428:	0005883a 	mov	r2,zero
}
 822f42c:	e037883a 	mov	sp,fp
 822f430:	df000017 	ldw	fp,0(sp)
 822f434:	dec00104 	addi	sp,sp,4
 822f438:	f800283a 	ret

0822f43c <np_stripoptions>:
 * RETURNS: void
 */

void
np_stripoptions(struct ip * ti, struct mbuf * m)
{
 822f43c:	defffb04 	addi	sp,sp,-20
 822f440:	dfc00415 	stw	ra,16(sp)
 822f444:	df000315 	stw	fp,12(sp)
 822f448:	df000304 	addi	fp,sp,12
 822f44c:	e13ffe15 	stw	r4,-8(fp)
 822f450:	e17fff15 	stw	r5,-4(fp)
   int   ihlen;

   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;
 822f454:	e0bffe17 	ldw	r2,-8(fp)
 822f458:	10800003 	ldbu	r2,0(r2)
 822f45c:	10803fcc 	andi	r2,r2,255
 822f460:	108003cc 	andi	r2,r2,15
 822f464:	1085883a 	add	r2,r2,r2
 822f468:	1085883a 	add	r2,r2,r2
 822f46c:	e0bffd15 	stw	r2,-12(fp)

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
 822f470:	e0bffd17 	ldw	r2,-12(fp)
 822f474:	10800548 	cmpgei	r2,r2,21
 822f478:	10002726 	beq	r2,zero,822f518 <np_stripoptions+0xdc>
      return;

   /* figure out how much to strip: we want to keep the 20-octet IP header */
   ihlen -= 20;
 822f47c:	e0bffd17 	ldw	r2,-12(fp)
 822f480:	10bffb04 	addi	r2,r2,-20
 822f484:	e0bffd15 	stw	r2,-12(fp)

   /* remove the stripped options from the IP datagram length */
   ti->ip_len -= ihlen;
 822f488:	e0bffe17 	ldw	r2,-8(fp)
 822f48c:	1080008b 	ldhu	r2,2(r2)
 822f490:	e0fffd17 	ldw	r3,-12(fp)
 822f494:	10c5c83a 	sub	r2,r2,r3
 822f498:	1007883a 	mov	r3,r2
 822f49c:	e0bffe17 	ldw	r2,-8(fp)
 822f4a0:	10c0008d 	sth	r3,2(r2)

   /* and from the IP header length (which will be 5*4 octets long) */
   ti->ip_ver_ihl = (ti->ip_ver_ihl & 0xf0) | 5;
 822f4a4:	e0bffe17 	ldw	r2,-8(fp)
 822f4a8:	10800003 	ldbu	r2,0(r2)
 822f4ac:	1007883a 	mov	r3,r2
 822f4b0:	00bffc04 	movi	r2,-16
 822f4b4:	1884703a 	and	r2,r3,r2
 822f4b8:	10800154 	ori	r2,r2,5
 822f4bc:	1007883a 	mov	r3,r2
 822f4c0:	e0bffe17 	ldw	r2,-8(fp)
 822f4c4:	10c00005 	stb	r3,0(r2)

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
 822f4c8:	e0bffd17 	ldw	r2,-12(fp)
 822f4cc:	e0fffe17 	ldw	r3,-8(fp)
 822f4d0:	1885883a 	add	r2,r3,r2
 822f4d4:	01800504 	movi	r6,20
 822f4d8:	e17ffe17 	ldw	r5,-8(fp)
 822f4dc:	1009883a 	mov	r4,r2
 822f4e0:	8202fd40 	call	8202fd4 <memmove>
   m->m_len -= ihlen;
 822f4e4:	e0bfff17 	ldw	r2,-4(fp)
 822f4e8:	10c00217 	ldw	r3,8(r2)
 822f4ec:	e0bffd17 	ldw	r2,-12(fp)
 822f4f0:	1887c83a 	sub	r3,r3,r2
 822f4f4:	e0bfff17 	ldw	r2,-4(fp)
 822f4f8:	10c00215 	stw	r3,8(r2)
   m->m_data += ihlen;
 822f4fc:	e0bfff17 	ldw	r2,-4(fp)
 822f500:	10c00317 	ldw	r3,12(r2)
 822f504:	e0bffd17 	ldw	r2,-12(fp)
 822f508:	1887883a 	add	r3,r3,r2
 822f50c:	e0bfff17 	ldw	r2,-4(fp)
 822f510:	10c00315 	stw	r3,12(r2)
 822f514:	00000106 	br	822f51c <np_stripoptions+0xe0>
   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
      return;
 822f518:	0001883a 	nop

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
   m->m_len -= ihlen;
   m->m_data += ihlen;
}
 822f51c:	e037883a 	mov	sp,fp
 822f520:	dfc00117 	ldw	ra,4(sp)
 822f524:	df000017 	ldw	fp,0(sp)
 822f528:	dec00204 	addi	sp,sp,8
 822f52c:	f800283a 	ret

0822f530 <so_icmpdu>:
 * RETURNS: 
 */

void
so_icmpdu(PACKET p, struct destun * pdp)
{
 822f530:	defff304 	addi	sp,sp,-52
 822f534:	dfc00c15 	stw	ra,48(sp)
 822f538:	df000b15 	stw	fp,44(sp)
 822f53c:	df000b04 	addi	fp,sp,44
 822f540:	e13ffe15 	stw	r4,-8(fp)
 822f544:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;
   struct socket *   so;
   struct tcpcb * tp;

   /* extract information about packet which generated DU */
   fhost = htonl(pdp->dip.ip_dest);
 822f548:	e0bfff17 	ldw	r2,-4(fp)
 822f54c:	10800617 	ldw	r2,24(r2)
 822f550:	1006d63a 	srli	r3,r2,24
 822f554:	e0bfff17 	ldw	r2,-4(fp)
 822f558:	10800617 	ldw	r2,24(r2)
 822f55c:	1004d23a 	srli	r2,r2,8
 822f560:	10bfc00c 	andi	r2,r2,65280
 822f564:	1886b03a 	or	r3,r3,r2
 822f568:	e0bfff17 	ldw	r2,-4(fp)
 822f56c:	10800617 	ldw	r2,24(r2)
 822f570:	10bfc00c 	andi	r2,r2,65280
 822f574:	1004923a 	slli	r2,r2,8
 822f578:	1886b03a 	or	r3,r3,r2
 822f57c:	e0bfff17 	ldw	r2,-4(fp)
 822f580:	10800617 	ldw	r2,24(r2)
 822f584:	1004963a 	slli	r2,r2,24
 822f588:	1884b03a 	or	r2,r3,r2
 822f58c:	e0bff815 	stw	r2,-32(fp)
   lhost = htonl(pdp->dip.ip_src);
 822f590:	e0bfff17 	ldw	r2,-4(fp)
 822f594:	10800517 	ldw	r2,20(r2)
 822f598:	1006d63a 	srli	r3,r2,24
 822f59c:	e0bfff17 	ldw	r2,-4(fp)
 822f5a0:	10800517 	ldw	r2,20(r2)
 822f5a4:	1004d23a 	srli	r2,r2,8
 822f5a8:	10bfc00c 	andi	r2,r2,65280
 822f5ac:	1886b03a 	or	r3,r3,r2
 822f5b0:	e0bfff17 	ldw	r2,-4(fp)
 822f5b4:	10800517 	ldw	r2,20(r2)
 822f5b8:	10bfc00c 	andi	r2,r2,65280
 822f5bc:	1004923a 	slli	r2,r2,8
 822f5c0:	1886b03a 	or	r3,r3,r2
 822f5c4:	e0bfff17 	ldw	r2,-4(fp)
 822f5c8:	10800517 	ldw	r2,20(r2)
 822f5cc:	1004963a 	slli	r2,r2,24
 822f5d0:	1884b03a 	or	r2,r3,r2
 822f5d4:	e0bff915 	stw	r2,-28(fp)
   lport = htons(*(unshort*)(&pdp->ddata[0]));
 822f5d8:	e0bfff17 	ldw	r2,-4(fp)
 822f5dc:	10800704 	addi	r2,r2,28
 822f5e0:	1080000b 	ldhu	r2,0(r2)
 822f5e4:	10bfffcc 	andi	r2,r2,65535
 822f5e8:	1004d23a 	srli	r2,r2,8
 822f5ec:	1007883a 	mov	r3,r2
 822f5f0:	e0bfff17 	ldw	r2,-4(fp)
 822f5f4:	10800704 	addi	r2,r2,28
 822f5f8:	1080000b 	ldhu	r2,0(r2)
 822f5fc:	10bfffcc 	andi	r2,r2,65535
 822f600:	1004923a 	slli	r2,r2,8
 822f604:	1884b03a 	or	r2,r3,r2
 822f608:	e0bffa0d 	sth	r2,-24(fp)
   fport = htons(*(unshort*)(&pdp->ddata[2]));
 822f60c:	e0bfff17 	ldw	r2,-4(fp)
 822f610:	10800784 	addi	r2,r2,30
 822f614:	1080000b 	ldhu	r2,0(r2)
 822f618:	10bfffcc 	andi	r2,r2,65535
 822f61c:	1004d23a 	srli	r2,r2,8
 822f620:	1007883a 	mov	r3,r2
 822f624:	e0bfff17 	ldw	r2,-4(fp)
 822f628:	10800784 	addi	r2,r2,30
 822f62c:	1080000b 	ldhu	r2,0(r2)
 822f630:	10bfffcc 	andi	r2,r2,65535
 822f634:	1004923a 	slli	r2,r2,8
 822f638:	1884b03a 	or	r2,r3,r2
 822f63c:	e0bffa8d 	sth	r2,-22(fp)
#ifndef IP_PMTU
   /* if it's a datagram-too-big message, ignore it -- As the
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
 822f640:	e0bfff17 	ldw	r2,-4(fp)
 822f644:	10800043 	ldbu	r2,1(r2)
 822f648:	10803fcc 	andi	r2,r2,255
 822f64c:	1080201c 	xori	r2,r2,128
 822f650:	10bfe004 	addi	r2,r2,-128
 822f654:	10800118 	cmpnei	r2,r2,4
 822f658:	10006e26 	beq	r2,zero,822f814 <so_icmpdu+0x2e4>
       goto done;
    }
#endif   /* IP_PMTU */

   /* if it's a TCP connection, clean it up */
   if (pdp->dip.ip_prot == TCPTP)
 822f65c:	e0bfff17 	ldw	r2,-4(fp)
 822f660:	10800443 	ldbu	r2,17(r2)
 822f664:	10803fcc 	andi	r2,r2,255
 822f668:	10800198 	cmpnei	r2,r2,6
 822f66c:	1000221e 	bne	r2,zero,822f6f8 <so_icmpdu+0x1c8>
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
 822f670:	e13ffa8b 	ldhu	r4,-22(fp)
 822f674:	e0bffa0b 	ldhu	r2,-24(fp)
 822f678:	00c00044 	movi	r3,1
 822f67c:	d8c00115 	stw	r3,4(sp)
 822f680:	d8800015 	stw	r2,0(sp)
 822f684:	e1fff917 	ldw	r7,-28(fp)
 822f688:	200d883a 	mov	r6,r4
 822f68c:	e17ff817 	ldw	r5,-32(fp)
 822f690:	010209b4 	movhi	r4,2086
 822f694:	21398904 	addi	r4,r4,-6620
 822f698:	82482bc0 	call	82482bc <in_pcblookup>
 822f69c:	e0bffb15 	stw	r2,-20(fp)
      if (inp == 0)
 822f6a0:	e0bffb17 	ldw	r2,-20(fp)
 822f6a4:	10005d26 	beq	r2,zero,822f81c <so_icmpdu+0x2ec>
         goto done;
      so = inp->inp_socket;
 822f6a8:	e0bffb17 	ldw	r2,-20(fp)
 822f6ac:	10800817 	ldw	r2,32(r2)
 822f6b0:	e0bffc15 	stw	r2,-16(fp)
      if (so == 0)
 822f6b4:	e0bffc17 	ldw	r2,-16(fp)
 822f6b8:	10005a26 	beq	r2,zero,822f824 <so_icmpdu+0x2f4>
         goto done;
      tp = intotcpcb(inp);
 822f6bc:	e0bffb17 	ldw	r2,-20(fp)
 822f6c0:	10800917 	ldw	r2,36(r2)
 822f6c4:	e0bffd15 	stw	r2,-12(fp)
      if (tp)
 822f6c8:	e0bffd17 	ldw	r2,-12(fp)
 822f6cc:	10000626 	beq	r2,zero,822f6e8 <so_icmpdu+0x1b8>
      {
         if (tp->t_state <= TCPS_LISTEN)
 822f6d0:	e0bffd17 	ldw	r2,-12(fp)
 822f6d4:	10800217 	ldw	r2,8(r2)
 822f6d8:	10800088 	cmpgei	r2,r2,2
 822f6dc:	10005326 	beq	r2,zero,822f82c <so_icmpdu+0x2fc>
               goto done;
        }
   }
#endif

         tcp_close(tp);
 822f6e0:	e13ffd17 	ldw	r4,-12(fp)
 822f6e4:	8239a500 	call	8239a50 <tcp_close>
      }
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 822f6e8:	e0bffc17 	ldw	r2,-16(fp)
 822f6ec:	00c01bc4 	movi	r3,111
 822f6f0:	10c00615 	stw	r3,24(r2)
 822f6f4:	00005406 	br	822f848 <so_icmpdu+0x318>
   }   
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
 822f6f8:	e0bfff17 	ldw	r2,-4(fp)
 822f6fc:	10800443 	ldbu	r2,17(r2)
 822f700:	10803fcc 	andi	r2,r2,255
 822f704:	10800458 	cmpnei	r2,r2,17
 822f708:	10004a1e 	bne	r2,zero,822f834 <so_icmpdu+0x304>
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 822f70c:	d0a09c17 	ldw	r2,-32144(gp)
 822f710:	e0bff715 	stw	r2,-36(fp)
 822f714:	00002106 	br	822f79c <so_icmpdu+0x26c>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 822f718:	e0bff717 	ldw	r2,-36(fp)
 822f71c:	1080020b 	ldhu	r2,8(r2)
 822f720:	10ffffcc 	andi	r3,r2,65535
 822f724:	e0bffa8b 	ldhu	r2,-22(fp)
 822f728:	18800426 	beq	r3,r2,822f73c <so_icmpdu+0x20c>
 822f72c:	e0bff717 	ldw	r2,-36(fp)
 822f730:	1080020b 	ldhu	r2,8(r2)
 822f734:	10bfffcc 	andi	r2,r2,65535
 822f738:	1000151e 	bne	r2,zero,822f790 <so_icmpdu+0x260>
             (tmp->u_fhost == htonl(fhost)) &&
 822f73c:	e0bff717 	ldw	r2,-36(fp)
 822f740:	10c00417 	ldw	r3,16(r2)
 822f744:	e0bff817 	ldw	r2,-32(fp)
 822f748:	1008d63a 	srli	r4,r2,24
 822f74c:	e0bff817 	ldw	r2,-32(fp)
 822f750:	1004d23a 	srli	r2,r2,8
 822f754:	10bfc00c 	andi	r2,r2,65280
 822f758:	2088b03a 	or	r4,r4,r2
 822f75c:	e0bff817 	ldw	r2,-32(fp)
 822f760:	10bfc00c 	andi	r2,r2,65280
 822f764:	1004923a 	slli	r2,r2,8
 822f768:	2088b03a 	or	r4,r4,r2
 822f76c:	e0bff817 	ldw	r2,-32(fp)
 822f770:	1004963a 	slli	r2,r2,24
 822f774:	2084b03a 	or	r2,r4,r2
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 822f778:	1880051e 	bne	r3,r2,822f790 <so_icmpdu+0x260>
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
 822f77c:	e0bff717 	ldw	r2,-36(fp)
 822f780:	1080018b 	ldhu	r2,6(r2)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
             (tmp->u_fhost == htonl(fhost)) &&
 822f784:	10ffffcc 	andi	r3,r2,65535
 822f788:	e0bffa0b 	ldhu	r2,-24(fp)
 822f78c:	18800626 	beq	r3,r2,822f7a8 <so_icmpdu+0x278>
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 822f790:	e0bff717 	ldw	r2,-36(fp)
 822f794:	10800017 	ldw	r2,0(r2)
 822f798:	e0bff715 	stw	r2,-36(fp)
 822f79c:	e0bff717 	ldw	r2,-36(fp)
 822f7a0:	103fdd1e 	bne	r2,zero,822f718 <so_icmpdu+0x1e8>
 822f7a4:	00000106 	br	822f7ac <so_icmpdu+0x27c>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
 822f7a8:	0001883a 	nop
         }
      if (!tmp) 
 822f7ac:	e0bff717 	ldw	r2,-36(fp)
 822f7b0:	10002226 	beq	r2,zero,822f83c <so_icmpdu+0x30c>
         goto done;
      so = (struct socket *)tmp->u_data;
 822f7b4:	e0bff717 	ldw	r2,-36(fp)
 822f7b8:	10800617 	ldw	r2,24(r2)
 822f7bc:	e0bffc15 	stw	r2,-16(fp)
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
 822f7c0:	e0bffc17 	ldw	r2,-16(fp)
 822f7c4:	10800983 	ldbu	r2,38(r2)
 822f7c8:	10803fcc 	andi	r2,r2,255
 822f7cc:	1080201c 	xori	r2,r2,128
 822f7d0:	10bfe004 	addi	r2,r2,-128
 822f7d4:	108000a0 	cmpeqi	r2,r2,2
 822f7d8:	10001a26 	beq	r2,zero,822f844 <so_icmpdu+0x314>
         goto done;
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 822f7dc:	e0bffc17 	ldw	r2,-16(fp)
 822f7e0:	00c01bc4 	movi	r3,111
 822f7e4:	10c00615 	stw	r3,24(r2)
      /* do a select() notify on socket here */
      sorwakeup(so);
 822f7e8:	e0bffc17 	ldw	r2,-16(fp)
 822f7ec:	10800a04 	addi	r2,r2,40
 822f7f0:	100b883a 	mov	r5,r2
 822f7f4:	e13ffc17 	ldw	r4,-16(fp)
 822f7f8:	82340c40 	call	82340c4 <sbwakeup>
      sowwakeup(so);
 822f7fc:	e0bffc17 	ldw	r2,-16(fp)
 822f800:	10801204 	addi	r2,r2,72
 822f804:	100b883a 	mov	r5,r2
 822f808:	e13ffc17 	ldw	r4,-16(fp)
 822f80c:	82340c40 	call	82340c4 <sbwakeup>
 822f810:	00000d06 	br	822f848 <so_icmpdu+0x318>
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
    {
       goto done;
 822f814:	0001883a 	nop
 822f818:	00000b06 	br	822f848 <so_icmpdu+0x318>
   if (pdp->dip.ip_prot == TCPTP)
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
      if (inp == 0)
         goto done;
 822f81c:	0001883a 	nop
 822f820:	00000906 	br	822f848 <so_icmpdu+0x318>
      so = inp->inp_socket;
      if (so == 0)
         goto done;
 822f824:	0001883a 	nop
 822f828:	00000706 	br	822f848 <so_icmpdu+0x318>
      tp = intotcpcb(inp);
      if (tp)
      {
         if (tp->t_state <= TCPS_LISTEN)
         {
            goto done;
 822f82c:	0001883a 	nop
 822f830:	00000506 	br	822f848 <so_icmpdu+0x318>
      sorwakeup(so);
      sowwakeup(so);
   }
#endif   /* UDP_SOCKETS */
   else
      goto done;
 822f834:	0001883a 	nop
 822f838:	00000306 	br	822f848 <so_icmpdu+0x318>
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
         }
      if (!tmp) 
         goto done;
 822f83c:	0001883a 	nop
 822f840:	00000106 	br	822f848 <so_icmpdu+0x318>
      so = (struct socket *)tmp->u_data;
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
         goto done;
 822f844:	0001883a 	nop
   if (pdp->dcode == DSTFRAG)
      pmtucache_set(pdp->dip.ip_dest, htons(pdp->dno2));
#endif   /* IP_PMTU */

done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
 822f848:	01000084 	movi	r4,2
 822f84c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   pk_free(p); /* done with original packet */
 822f850:	e13ffe17 	ldw	r4,-8(fp)
 822f854:	822cbbc0 	call	822cbbc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 822f858:	01000084 	movi	r4,2
 822f85c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   return;
 822f860:	0001883a 	nop
}
 822f864:	e037883a 	mov	sp,fp
 822f868:	dfc00117 	ldw	ra,4(sp)
 822f86c:	df000017 	ldw	fp,0(sp)
 822f870:	dec00204 	addi	sp,sp,8
 822f874:	f800283a 	ret

0822f878 <tcp_tick>:
unsigned long nextslow = 0L;     /* next slow tcp timer time */
static int in_tcptick = 0;       /* reentry gaurd */

void
tcp_tick()
{
 822f878:	defffe04 	addi	sp,sp,-8
 822f87c:	dfc00115 	stw	ra,4(sp)
 822f880:	df000015 	stw	fp,0(sp)
 822f884:	d839883a 	mov	fp,sp
   /* guard against re-entry */
   if (in_tcptick)
 822f888:	d0a0ad17 	ldw	r2,-32076(gp)
 822f88c:	1000121e 	bne	r2,zero,822f8d8 <tcp_tick+0x60>
      return;
   in_tcptick++;
 822f890:	d0a0ad17 	ldw	r2,-32076(gp)
 822f894:	10800044 	addi	r2,r2,1
 822f898:	d0a0ad15 	stw	r2,-32076(gp)

   LOCK_NET_RESOURCE(NET_RESID);
 822f89c:	0009883a 	mov	r4,zero
 822f8a0:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>

   if (cticks >= nextslow) /* time to do it again */
 822f8a4:	d0e0a817 	ldw	r3,-32096(gp)
 822f8a8:	d0a0ac17 	ldw	r2,-32080(gp)
 822f8ac:	18800436 	bltu	r3,r2,822f8c0 <tcp_tick+0x48>
   {
      tcp_slowtimo();      /* call routine in BSD tcp_timr.c */
 822f8b0:	8239c780 	call	8239c78 <tcp_slowtimo>
#ifdef CSUM_DEMO
      nextslow = cticks + (TPS/5);  /* another 200 ms */
#else
      nextslow = cticks + (TPS/2);  /* another 500 ms */
 822f8b4:	d0a0a817 	ldw	r2,-32096(gp)
 822f8b8:	10800c84 	addi	r2,r2,50
 822f8bc:	d0a0ac15 	stw	r2,-32080(gp)

#ifdef DO_DELAY_ACKS
   tcp_fasttimo();
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);
 822f8c0:	0009883a 	mov	r4,zero
 822f8c4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   in_tcptick--;
 822f8c8:	d0a0ad17 	ldw	r2,-32076(gp)
 822f8cc:	10bfffc4 	addi	r2,r2,-1
 822f8d0:	d0a0ad15 	stw	r2,-32076(gp)
 822f8d4:	00000106 	br	822f8dc <tcp_tick+0x64>
void
tcp_tick()
{
   /* guard against re-entry */
   if (in_tcptick)
      return;
 822f8d8:	0001883a 	nop
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);

   in_tcptick--;
}
 822f8dc:	e037883a 	mov	sp,fp
 822f8e0:	dfc00117 	ldw	ra,4(sp)
 822f8e4:	df000017 	ldw	fp,0(sp)
 822f8e8:	dec00204 	addi	sp,sp,8
 822f8ec:	f800283a 	ret

0822f8f0 <rawip_lookup>:
 *          or NULL if no matching raw IP endpoint is found.
 */

struct ipraw_ep *
rawip_lookup(struct socket * so)
{
 822f8f0:	defffd04 	addi	sp,sp,-12
 822f8f4:	df000215 	stw	fp,8(sp)
 822f8f8:	df000204 	addi	fp,sp,8
 822f8fc:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 822f900:	d0a0cf17 	ldw	r2,-31940(gp)
 822f904:	e0bffe15 	stw	r2,-8(fp)
 822f908:	00000906 	br	822f930 <rawip_lookup+0x40>
      if (tmp->ipr_data == (void*)so)
 822f90c:	e0bffe17 	ldw	r2,-8(fp)
 822f910:	10c00417 	ldw	r3,16(r2)
 822f914:	e0bfff17 	ldw	r2,-4(fp)
 822f918:	1880021e 	bne	r3,r2,822f924 <rawip_lookup+0x34>
      return (tmp);
 822f91c:	e0bffe17 	ldw	r2,-8(fp)
 822f920:	00000606 	br	822f93c <rawip_lookup+0x4c>
struct ipraw_ep *
rawip_lookup(struct socket * so)
{
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 822f924:	e0bffe17 	ldw	r2,-8(fp)
 822f928:	10800017 	ldw	r2,0(r2)
 822f92c:	e0bffe15 	stw	r2,-8(fp)
 822f930:	e0bffe17 	ldw	r2,-8(fp)
 822f934:	103ff51e 	bne	r2,zero,822f90c <rawip_lookup+0x1c>
      if (tmp->ipr_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 822f938:	0005883a 	mov	r2,zero
}
 822f93c:	e037883a 	mov	sp,fp
 822f940:	df000017 	ldw	fp,0(sp)
 822f944:	dec00104 	addi	sp,sp,4
 822f948:	f800283a 	ret

0822f94c <rawip_soinput>:
 *          indicates that the packet has not been accepted.
 */

int
rawip_soinput(PACKET pkt, void * so_ptr)
{
 822f94c:	defff504 	addi	sp,sp,-44
 822f950:	dfc00a15 	stw	ra,40(sp)
 822f954:	df000915 	stw	fp,36(sp)
 822f958:	df000904 	addi	fp,sp,36
 822f95c:	e13ffe15 	stw	r4,-8(fp)
 822f960:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 822f964:	e0bfff17 	ldw	r2,-4(fp)
 822f968:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;

   LOCK_NET_RESOURCE(NET_RESID); 
 822f96c:	0009883a 	mov	r4,zero
 822f970:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 822f974:	e0bff717 	ldw	r2,-36(fp)
 822f978:	10c00a17 	ldw	r3,40(r2)
 822f97c:	e0bffe17 	ldw	r2,-8(fp)
 822f980:	10800417 	ldw	r2,16(r2)
 822f984:	1887883a 	add	r3,r3,r2
 822f988:	e0bff717 	ldw	r2,-36(fp)
 822f98c:	10800b17 	ldw	r2,44(r2)
 822f990:	18800436 	bltu	r3,r2,822f9a4 <rawip_soinput+0x58>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 822f994:	0009883a 	mov	r4,zero
 822f998:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 822f99c:	00801a44 	movi	r2,105
 822f9a0:	00005706 	br	822fb00 <rawip_soinput+0x1b4>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 822f9a4:	000b883a 	mov	r5,zero
 822f9a8:	01000044 	movi	r4,1
 822f9ac:	822e2280 	call	822e228 <m_getnbuf>
 822f9b0:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 822f9b4:	e0bff817 	ldw	r2,-32(fp)
 822f9b8:	1000041e 	bne	r2,zero,822f9cc <rawip_soinput+0x80>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 822f9bc:	0009883a 	mov	r4,zero
 822f9c0:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 822f9c4:	00801a44 	movi	r2,105
 822f9c8:	00004d06 	br	822fb00 <rawip_soinput+0x1b4>
   }

   /* set data mbuf to point to start of IP header */
   m_in->pkt = pkt;
 822f9cc:	e0bff817 	ldw	r2,-32(fp)
 822f9d0:	e0fffe17 	ldw	r3,-8(fp)
 822f9d4:	10c00115 	stw	r3,4(r2)
   m_in->m_base = pkt->nb_buff;
 822f9d8:	e0bffe17 	ldw	r2,-8(fp)
 822f9dc:	10c00117 	ldw	r3,4(r2)
 822f9e0:	e0bff817 	ldw	r2,-32(fp)
 822f9e4:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 822f9e8:	e0bffe17 	ldw	r2,-8(fp)
 822f9ec:	10c00217 	ldw	r3,8(r2)
 822f9f0:	e0bff817 	ldw	r2,-32(fp)
 822f9f4:	10c00515 	stw	r3,20(r2)
   m_in->m_data = pkt->nb_prot;
 822f9f8:	e0bffe17 	ldw	r2,-8(fp)
 822f9fc:	10c00317 	ldw	r3,12(r2)
 822fa00:	e0bff817 	ldw	r2,-32(fp)
 822fa04:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 822fa08:	e0bffe17 	ldw	r2,-8(fp)
 822fa0c:	10c00417 	ldw	r3,16(r2)
 822fa10:	e0bff817 	ldw	r2,-32(fp)
 822fa14:	10c00215 	stw	r3,8(r2)

   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
 822fa18:	e0bff717 	ldw	r2,-36(fp)
 822fa1c:	10800417 	ldw	r2,16(r2)
 822fa20:	1088000c 	andi	r2,r2,8192
 822fa24:	1000141e 	bne	r2,zero,822fa78 <rawip_soinput+0x12c>
   {
      unsigned int ihl = 
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
 822fa28:	e0bffe17 	ldw	r2,-8(fp)
 822fa2c:	10800317 	ldw	r2,12(r2)
 822fa30:	10800003 	ldbu	r2,0(r2)
 822fa34:	10803fcc 	andi	r2,r2,255
 822fa38:	108003cc 	andi	r2,r2,15
 822fa3c:	1085883a 	add	r2,r2,r2
 822fa40:	1085883a 	add	r2,r2,r2
   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
   {
      unsigned int ihl = 
 822fa44:	e0bff915 	stw	r2,-28(fp)
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
      m_in->m_data += ihl;
 822fa48:	e0bff817 	ldw	r2,-32(fp)
 822fa4c:	10c00317 	ldw	r3,12(r2)
 822fa50:	e0bff917 	ldw	r2,-28(fp)
 822fa54:	1887883a 	add	r3,r3,r2
 822fa58:	e0bff817 	ldw	r2,-32(fp)
 822fa5c:	10c00315 	stw	r3,12(r2)
      m_in->m_len -= ihl;
 822fa60:	e0bff817 	ldw	r2,-32(fp)
 822fa64:	10c00217 	ldw	r3,8(r2)
 822fa68:	e0bff917 	ldw	r2,-28(fp)
 822fa6c:	1887c83a 	sub	r3,r3,r2
 822fa70:	e0bff817 	ldw	r2,-32(fp)
 822fa74:	10c00215 	stw	r3,8(r2)
   }

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 822fa78:	e0bffe17 	ldw	r2,-8(fp)
 822fa7c:	10800717 	ldw	r2,28(r2)
 822fa80:	e0bffb15 	stw	r2,-20(fp)
   sin.sin_port = 0;
 822fa84:	e03ffa8d 	sth	zero,-22(fp)
   sin.sin_family = AF_INET;
 822fa88:	00800084 	movi	r2,2
 822fa8c:	e0bffa0d 	sth	r2,-24(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 822fa90:	e0bff717 	ldw	r2,-36(fp)
 822fa94:	10800a04 	addi	r2,r2,40
 822fa98:	e0fffa04 	addi	r3,fp,-24
 822fa9c:	e1bff817 	ldw	r6,-32(fp)
 822faa0:	180b883a 	mov	r5,r3
 822faa4:	1009883a 	mov	r4,r2
 822faa8:	82343ec0 	call	82343ec <sbappendaddr>
 822faac:	1000081e 	bne	r2,zero,822fad0 <rawip_soinput+0x184>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       * underlying stack
       */
      m_in->pkt = NULL;
 822fab0:	e0bff817 	ldw	r2,-32(fp)
 822fab4:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 822fab8:	e13ff817 	ldw	r4,-32(fp)
 822fabc:	822e3b00 	call	822e3b0 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fac0:	0009883a 	mov	r4,zero
 822fac4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 822fac8:	00801a44 	movi	r2,105
 822facc:	00000c06 	br	822fb00 <rawip_soinput+0x1b4>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 822fad0:	e0bff717 	ldw	r2,-36(fp)
 822fad4:	10800a04 	addi	r2,r2,40
 822fad8:	1009883a 	mov	r4,r2
 822fadc:	822954c0 	call	822954c <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 822fae0:	e0bff717 	ldw	r2,-36(fp)
 822fae4:	10800a04 	addi	r2,r2,40
 822fae8:	100b883a 	mov	r5,r2
 822faec:	e13ff717 	ldw	r4,-36(fp)
 822faf0:	82340c40 	call	82340c4 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 822faf4:	0009883a 	mov	r4,zero
 822faf8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   return 0;
 822fafc:	0005883a 	mov	r2,zero
}
 822fb00:	e037883a 	mov	sp,fp
 822fb04:	dfc00117 	ldw	ra,4(sp)
 822fb08:	df000017 	ldw	fp,0(sp)
 822fb0c:	dec00204 	addi	sp,sp,8
 822fb10:	f800283a 	ret

0822fb14 <rawip_usrreq>:

int
rawip_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 822fb14:	deffef04 	addi	sp,sp,-68
 822fb18:	dfc01015 	stw	ra,64(sp)
 822fb1c:	df000f15 	stw	fp,60(sp)
 822fb20:	dc000e15 	stw	r16,56(sp)
 822fb24:	df000f04 	addi	fp,sp,60
 822fb28:	e13ffc15 	stw	r4,-16(fp)
 822fb2c:	e17ffd15 	stw	r5,-12(fp)
 822fb30:	e1bffe15 	stw	r6,-8(fp)
   u_char prot;
   struct ip * pip;
   int   req;
   NET   ifp;     /* ptr to network interface structure */

   req = so->so_req;    /* get request from socket struct */
 822fb34:	e0bffc17 	ldw	r2,-16(fp)
 822fb38:	10800717 	ldw	r2,28(r2)
 822fb3c:	e0bff615 	stw	r2,-40(fp)

   switch (req) 
 822fb40:	e0bff617 	ldw	r2,-40(fp)
 822fb44:	10800468 	cmpgeui	r2,r2,17
 822fb48:	1001be1e 	bne	r2,zero,8230244 <rawip_usrreq+0x730>
 822fb4c:	e0bff617 	ldw	r2,-40(fp)
 822fb50:	100690ba 	slli	r3,r2,2
 822fb54:	008208f4 	movhi	r2,2083
 822fb58:	10beda04 	addi	r2,r2,-1176
 822fb5c:	1885883a 	add	r2,r3,r2
 822fb60:	10800017 	ldw	r2,0(r2)
 822fb64:	1000683a 	jmp	r2
 822fb68:	0822fbac 	andhi	zero,at,35822
 822fb6c:	0822fc34 	orhi	zero,at,35824
 822fb70:	0822fc70 	cmpltui	zero,at,35825
 822fb74:	08230244 	addi	zero,at,-29687
 822fb78:	0822fc70 	cmpltui	zero,at,35825
 822fb7c:	08230244 	addi	zero,at,-29687
 822fb80:	08230238 	rdprs	zero,at,-29688
 822fb84:	08230244 	addi	zero,at,-29687
 822fb88:	08230238 	rdprs	zero,at,-29688
 822fb8c:	0822fdfc 	xorhi	zero,at,35831
 822fb90:	08230244 	addi	zero,at,-29687
 822fb94:	08230244 	addi	zero,at,-29687
 822fb98:	08230244 	addi	zero,at,-29687
 822fb9c:	08230244 	addi	zero,at,-29687
 822fba0:	08230244 	addi	zero,at,-29687
 822fba4:	082301a4 	muli	zero,at,-29690
 822fba8:	082301a4 	muli	zero,at,-29690
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 822fbac:	e0bffc17 	ldw	r2,-16(fp)
 822fbb0:	10800417 	ldw	r2,16(r2)
 822fbb4:	1088000c 	andi	r2,r2,8192
 822fbb8:	1009883a 	mov	r4,r2
 822fbbc:	8243fe40 	call	8243fe4 <ip_raw_maxalloc>

   switch (req) 
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
 822fbc0:	1007883a 	mov	r3,r2
 822fbc4:	e0bffc17 	ldw	r2,-16(fp)
 822fbc8:	10c01315 	stw	r3,76(r2)
 822fbcc:	e0bffc17 	ldw	r2,-16(fp)
 822fbd0:	10c01317 	ldw	r3,76(r2)
 822fbd4:	e0bffc17 	ldw	r2,-16(fp)
 822fbd8:	10c00b15 	stw	r3,44(r2)
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
      /* make a raw IP endpoint */
      prot = (u_char)(MBUF2LONG(nam));
 822fbdc:	e0bffe17 	ldw	r2,-8(fp)
 822fbe0:	e0bff705 	stb	r2,-36(fp)
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fbe4:	0009883a 	mov	r4,zero
 822fbe8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      ep = ip_raw_open(prot, 0L, 0L, rawip_soinput, so);
 822fbec:	e0fff703 	ldbu	r3,-36(fp)
 822fbf0:	e0bffc17 	ldw	r2,-16(fp)
 822fbf4:	d8800015 	stw	r2,0(sp)
 822fbf8:	01c208f4 	movhi	r7,2083
 822fbfc:	39fe5304 	addi	r7,r7,-1716
 822fc00:	000d883a 	mov	r6,zero
 822fc04:	000b883a 	mov	r5,zero
 822fc08:	1809883a 	mov	r4,r3
 822fc0c:	8243b300 	call	8243b30 <ip_raw_open>
 822fc10:	e0bff815 	stw	r2,-32(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 822fc14:	0009883a 	mov	r4,zero
 822fc18:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      if (!ep)
 822fc1c:	e0bff817 	ldw	r2,-32(fp)
 822fc20:	1000021e 	bne	r2,zero,822fc2c <rawip_usrreq+0x118>
         return(EINVAL);
 822fc24:	00800584 	movi	r2,22
 822fc28:	00018706 	br	8230248 <rawip_usrreq+0x734>
      return 0;
 822fc2c:	0005883a 	mov	r2,zero
 822fc30:	00018506 	br	8230248 <rawip_usrreq+0x734>
   case PRU_DETACH:
      /* delete the raw IP endpoint */
      ep = rawip_lookup(so);
 822fc34:	e13ffc17 	ldw	r4,-16(fp)
 822fc38:	822f8f00 	call	822f8f0 <rawip_lookup>
 822fc3c:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822fc40:	e0bff817 	ldw	r2,-32(fp)
 822fc44:	1000021e 	bne	r2,zero,822fc50 <rawip_usrreq+0x13c>
         return(EINVAL);
 822fc48:	00800584 	movi	r2,22
 822fc4c:	00017e06 	br	8230248 <rawip_usrreq+0x734>
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 822fc50:	0009883a 	mov	r4,zero
 822fc54:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      ip_raw_close(ep);
 822fc58:	e13ff817 	ldw	r4,-32(fp)
 822fc5c:	8243c080 	call	8243c08 <ip_raw_close>
      LOCK_NET_RESOURCE(NET_RESID);
 822fc60:	0009883a 	mov	r4,zero
 822fc64:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      return 0;
 822fc68:	0005883a 	mov	r2,zero
 822fc6c:	00017606 	br	8230248 <rawip_usrreq+0x734>
       * a default address for sending
       */
      /* fall through to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 822fc70:	e0bffe17 	ldw	r2,-8(fp)
 822fc74:	1000021e 	bne	r2,zero,822fc80 <rawip_usrreq+0x16c>
         return(EINVAL);
 822fc78:	00800584 	movi	r2,22
 822fc7c:	00017206 	br	8230248 <rawip_usrreq+0x734>
      sin = mtod(nam, struct sockaddr_in *);
 822fc80:	e0bffe17 	ldw	r2,-8(fp)
 822fc84:	10800317 	ldw	r2,12(r2)
 822fc88:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 822fc8c:	e0bff917 	ldw	r2,-28(fp)
 822fc90:	1000021e 	bne	r2,zero,822fc9c <rawip_usrreq+0x188>
         return(EINVAL);
 822fc94:	00800584 	movi	r2,22
 822fc98:	00016b06 	br	8230248 <rawip_usrreq+0x734>
      if (nam->m_len != sizeof (*sin))
 822fc9c:	e0bffe17 	ldw	r2,-8(fp)
 822fca0:	10800217 	ldw	r2,8(r2)
 822fca4:	10800420 	cmpeqi	r2,r2,16
 822fca8:	1000021e 	bne	r2,zero,822fcb4 <rawip_usrreq+0x1a0>
         return(EINVAL);
 822fcac:	00800584 	movi	r2,22
 822fcb0:	00016506 	br	8230248 <rawip_usrreq+0x734>
      ep = rawip_lookup(so);
 822fcb4:	e13ffc17 	ldw	r4,-16(fp)
 822fcb8:	822f8f00 	call	822f8f0 <rawip_lookup>
 822fcbc:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822fcc0:	e0bff817 	ldw	r2,-32(fp)
 822fcc4:	1000021e 	bne	r2,zero,822fcd0 <rawip_usrreq+0x1bc>
         return(EINVAL);
 822fcc8:	00800584 	movi	r2,22
 822fccc:	00015e06 	br	8230248 <rawip_usrreq+0x734>
      if (req == PRU_BIND)
 822fcd0:	e0bff617 	ldw	r2,-40(fp)
 822fcd4:	10800098 	cmpnei	r2,r2,2
 822fcd8:	1000201e 	bne	r2,zero,822fd5c <rawip_usrreq+0x248>
          * if the caller-supplied address is INADDR_ANY,
          * don't bind to a specific address; else, 
          * make sure the caller-supplied address is
          * an interface IP address and if so, bind to that
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 822fcdc:	e0bff917 	ldw	r2,-28(fp)
 822fce0:	10800117 	ldw	r2,4(r2)
 822fce4:	1000021e 	bne	r2,zero,822fcf0 <rawip_usrreq+0x1dc>
         {
            lhost = 0L;
 822fce8:	e03ff415 	stw	zero,-48(fp)
 822fcec:	00001706 	br	822fd4c <rawip_usrreq+0x238>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
 822fcf0:	e0bff917 	ldw	r2,-28(fp)
 822fcf4:	10800117 	ldw	r2,4(r2)
 822fcf8:	e0bff415 	stw	r2,-48(fp)
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fcfc:	008209b4 	movhi	r2,2086
 822fd00:	10ba6504 	addi	r2,r2,-5740
 822fd04:	10800017 	ldw	r2,0(r2)
 822fd08:	e0bff515 	stw	r2,-44(fp)
 822fd0c:	00000706 	br	822fd2c <rawip_usrreq+0x218>
               if (ifp->n_ipaddr == lhost)
 822fd10:	e0bff517 	ldw	r2,-44(fp)
 822fd14:	10c00a17 	ldw	r3,40(r2)
 822fd18:	e0bff417 	ldw	r2,-48(fp)
 822fd1c:	18800626 	beq	r3,r2,822fd38 <rawip_usrreq+0x224>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822fd20:	e0bff517 	ldw	r2,-44(fp)
 822fd24:	10800017 	ldw	r2,0(r2)
 822fd28:	e0bff515 	stw	r2,-44(fp)
 822fd2c:	e0bff517 	ldw	r2,-44(fp)
 822fd30:	103ff71e 	bne	r2,zero,822fd10 <rawip_usrreq+0x1fc>
 822fd34:	00000106 	br	822fd3c <rawip_usrreq+0x228>
               if (ifp->n_ipaddr == lhost)
                  break;
 822fd38:	0001883a 	nop
            if (ifp == NULL)
 822fd3c:	e0bff517 	ldw	r2,-44(fp)
 822fd40:	1000021e 	bne	r2,zero,822fd4c <rawip_usrreq+0x238>
               return(EADDRNOTAVAIL);
 822fd44:	00801f44 	movi	r2,125
 822fd48:	00013f06 	br	8230248 <rawip_usrreq+0x734>
         }

         /* bind the endpoint */
         ep->ipr_laddr = lhost;
 822fd4c:	e0bff817 	ldw	r2,-32(fp)
 822fd50:	e0fff417 	ldw	r3,-48(fp)
 822fd54:	10c00115 	stw	r3,4(r2)
 822fd58:	00002606 	br	822fdf4 <rawip_usrreq+0x2e0>
          *
          * if the caller-supplied address is INADDR_ANY,
          * use the wildcard address; else, use the caller-
          * supplied address
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 822fd5c:	e0bff917 	ldw	r2,-28(fp)
 822fd60:	10800117 	ldw	r2,4(r2)
 822fd64:	1000021e 	bne	r2,zero,822fd70 <rawip_usrreq+0x25c>
            fhost = 0L;
 822fd68:	e03ff315 	stw	zero,-52(fp)
 822fd6c:	00000306 	br	822fd7c <rawip_usrreq+0x268>
         else
            fhost = sin->sin_addr.s_addr;
 822fd70:	e0bff917 	ldw	r2,-28(fp)
 822fd74:	10800117 	ldw	r2,4(r2)
 822fd78:	e0bff315 	stw	r2,-52(fp)
         /* connect the IP endpoint */
         ep->ipr_faddr = fhost;
 822fd7c:	e0bff817 	ldw	r2,-32(fp)
 822fd80:	e0fff317 	ldw	r3,-52(fp)
 822fd84:	10c00215 	stw	r3,8(r2)
         /* mark the socket as connected or disconnected, as appropriate */
         if (fhost != 0L) {
 822fd88:	e0bff317 	ldw	r2,-52(fp)
 822fd8c:	10000e26 	beq	r2,zero,822fdc8 <rawip_usrreq+0x2b4>
            so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 822fd90:	e0bffc17 	ldw	r2,-16(fp)
 822fd94:	10c0088b 	ldhu	r3,34(r2)
 822fd98:	00bffcc4 	movi	r2,-13
 822fd9c:	1884703a 	and	r2,r3,r2
 822fda0:	1007883a 	mov	r3,r2
 822fda4:	e0bffc17 	ldw	r2,-16(fp)
 822fda8:	10c0088d 	sth	r3,34(r2)
            so->so_state |= SS_ISCONNECTED;
 822fdac:	e0bffc17 	ldw	r2,-16(fp)
 822fdb0:	1080088b 	ldhu	r2,34(r2)
 822fdb4:	10800094 	ori	r2,r2,2
 822fdb8:	1007883a 	mov	r3,r2
 822fdbc:	e0bffc17 	ldw	r2,-16(fp)
 822fdc0:	10c0088d 	sth	r3,34(r2)
 822fdc4:	00000706 	br	822fde4 <rawip_usrreq+0x2d0>
         }
         else
         {
            so->so_state &= ~SS_ISCONNECTED;
 822fdc8:	e0bffc17 	ldw	r2,-16(fp)
 822fdcc:	10c0088b 	ldhu	r3,34(r2)
 822fdd0:	00bfff44 	movi	r2,-3
 822fdd4:	1884703a 	and	r2,r3,r2
 822fdd8:	1007883a 	mov	r3,r2
 822fddc:	e0bffc17 	ldw	r2,-16(fp)
 822fde0:	10c0088d 	sth	r3,34(r2)
         }
         /* since socket was in listen state, packets may be queued */
         sbflush(&so->so_rcv);   /* dump these now */
 822fde4:	e0bffc17 	ldw	r2,-16(fp)
 822fde8:	10800a04 	addi	r2,r2,40
 822fdec:	1009883a 	mov	r4,r2
 822fdf0:	82347a80 	call	82347a8 <sbflush>
      }
      return 0;
 822fdf4:	0005883a 	mov	r2,zero
 822fdf8:	00011306 	br	8230248 <rawip_usrreq+0x734>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 822fdfc:	e0bffd17 	ldw	r2,-12(fp)
 822fe00:	1000021e 	bne	r2,zero,822fe0c <rawip_usrreq+0x2f8>
         return(EINVAL);
 822fe04:	00800584 	movi	r2,22
 822fe08:	00010f06 	br	8230248 <rawip_usrreq+0x734>

      ep = rawip_lookup(so);
 822fe0c:	e13ffc17 	ldw	r4,-16(fp)
 822fe10:	822f8f00 	call	822f8f0 <rawip_lookup>
 822fe14:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 822fe18:	e0bff817 	ldw	r2,-32(fp)
 822fe1c:	1000041e 	bne	r2,zero,822fe30 <rawip_usrreq+0x31c>
      {
         m_free(m);
 822fe20:	e13ffd17 	ldw	r4,-12(fp)
 822fe24:	822e3b00 	call	822e3b0 <m_free>
         /* may be bogus socket, but more likely the connection may 
         have closed due to ICMP dest unreachable from other side. */
         return(ECONNREFUSED);
 822fe28:	00801bc4 	movi	r2,111
 822fe2c:	00010606 	br	8230248 <rawip_usrreq+0x734>
      }

      if (nam == NULL)  /* no sendto() info passed, must be send() */
 822fe30:	e0bffe17 	ldw	r2,-8(fp)
 822fe34:	10000b1e 	bne	r2,zero,822fe64 <rawip_usrreq+0x350>
      {
         if (!(so->so_state & SS_ISCONNECTED))
 822fe38:	e0bffc17 	ldw	r2,-16(fp)
 822fe3c:	1080088b 	ldhu	r2,34(r2)
 822fe40:	10bfffcc 	andi	r2,r2,65535
 822fe44:	1080008c 	andi	r2,r2,2
 822fe48:	1000021e 	bne	r2,zero,822fe54 <rawip_usrreq+0x340>
            return (ENOTCONN);
 822fe4c:	00802004 	movi	r2,128
 822fe50:	0000fd06 	br	8230248 <rawip_usrreq+0x734>
         fhost = ep->ipr_faddr;
 822fe54:	e0bff817 	ldw	r2,-32(fp)
 822fe58:	10800217 	ldw	r2,8(r2)
 822fe5c:	e0bff315 	stw	r2,-52(fp)
 822fe60:	00001406 	br	822feb4 <rawip_usrreq+0x3a0>
      }
      else 
      {
         if (so->so_state & SS_ISCONNECTED)
 822fe64:	e0bffc17 	ldw	r2,-16(fp)
 822fe68:	1080088b 	ldhu	r2,34(r2)
 822fe6c:	10bfffcc 	andi	r2,r2,65535
 822fe70:	1080008c 	andi	r2,r2,2
 822fe74:	10000226 	beq	r2,zero,822fe80 <rawip_usrreq+0x36c>
            return (EISCONN);
 822fe78:	00801fc4 	movi	r2,127
 822fe7c:	0000f206 	br	8230248 <rawip_usrreq+0x734>
         if (nam->m_len != sizeof (*sin))
 822fe80:	e0bffe17 	ldw	r2,-8(fp)
 822fe84:	10800217 	ldw	r2,8(r2)
 822fe88:	10800420 	cmpeqi	r2,r2,16
 822fe8c:	1000031e 	bne	r2,zero,822fe9c <rawip_usrreq+0x388>
         {
            dtrap();
 822fe90:	822d4140 	call	822d414 <dtrap>
            return (EINVAL);
 822fe94:	00800584 	movi	r2,22
 822fe98:	0000eb06 	br	8230248 <rawip_usrreq+0x734>
         }
         sin = mtod(nam, struct sockaddr_in *);
 822fe9c:	e0bffe17 	ldw	r2,-8(fp)
 822fea0:	10800317 	ldw	r2,12(r2)
 822fea4:	e0bff915 	stw	r2,-28(fp)
         fhost = sin->sin_addr.s_addr;
 822fea8:	e0bff917 	ldw	r2,-28(fp)
 822feac:	10800117 	ldw	r2,4(r2)
 822feb0:	e0bff315 	stw	r2,-52(fp)

      /* since our pkt->nb_buff size is tied to max packet size, we 
       * assume our raw IP datagrams are always in one mbuf and that the 
       * mbuf -- but check anyway
       */
      if (m->m_len > (unsigned)ip_raw_maxalloc(so->so_options & SO_HDRINCL))
 822feb4:	e0bffd17 	ldw	r2,-12(fp)
 822feb8:	14000217 	ldw	r16,8(r2)
 822febc:	e0bffc17 	ldw	r2,-16(fp)
 822fec0:	10800417 	ldw	r2,16(r2)
 822fec4:	1088000c 	andi	r2,r2,8192
 822fec8:	1009883a 	mov	r4,r2
 822fecc:	8243fe40 	call	8243fe4 <ip_raw_maxalloc>
 822fed0:	1400032e 	bgeu	r2,r16,822fee0 <rawip_usrreq+0x3cc>
      {
         dtrap(); /* should never happen */
 822fed4:	822d4140 	call	822d414 <dtrap>
         return EMSGSIZE;  /* try to recover */
 822fed8:	00801e84 	movi	r2,122
 822fedc:	0000da06 	br	8230248 <rawip_usrreq+0x734>
      }
      /* get a packet buffer for send */
      pkt = ip_raw_alloc(m->m_len, so->so_options & SO_HDRINCL);
 822fee0:	e0bffd17 	ldw	r2,-12(fp)
 822fee4:	10800217 	ldw	r2,8(r2)
 822fee8:	1007883a 	mov	r3,r2
 822feec:	e0bffc17 	ldw	r2,-16(fp)
 822fef0:	10800417 	ldw	r2,16(r2)
 822fef4:	1088000c 	andi	r2,r2,8192
 822fef8:	100b883a 	mov	r5,r2
 822fefc:	1809883a 	mov	r4,r3
 822ff00:	8243ee80 	call	8243ee8 <ip_raw_alloc>
 822ff04:	e0bffa15 	stw	r2,-24(fp)
      if (!pkt)
 822ff08:	e0bffa17 	ldw	r2,-24(fp)
 822ff0c:	1000041e 	bne	r2,zero,822ff20 <rawip_usrreq+0x40c>
      {
         m_free(m);
 822ff10:	e13ffd17 	ldw	r4,-12(fp)
 822ff14:	822e3b00 	call	822e3b0 <m_free>
         return ENOBUFS;   /* report buffer shortages */
 822ff18:	00801a44 	movi	r2,105
 822ff1c:	0000ca06 	br	8230248 <rawip_usrreq+0x734>
      }
      MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 822ff20:	e0bffa17 	ldw	r2,-24(fp)
 822ff24:	10c00317 	ldw	r3,12(r2)
 822ff28:	e0bffd17 	ldw	r2,-12(fp)
 822ff2c:	11000317 	ldw	r4,12(r2)
 822ff30:	e0bffd17 	ldw	r2,-12(fp)
 822ff34:	10800217 	ldw	r2,8(r2)
 822ff38:	100d883a 	mov	r6,r2
 822ff3c:	200b883a 	mov	r5,r4
 822ff40:	1809883a 	mov	r4,r3
 822ff44:	8202e8c0 	call	8202e8c <memcpy>
      pkt->nb_plen = m->m_len;
 822ff48:	e0bffd17 	ldw	r2,-12(fp)
 822ff4c:	10c00217 	ldw	r3,8(r2)
 822ff50:	e0bffa17 	ldw	r2,-24(fp)
 822ff54:	10c00415 	stw	r3,16(r2)
      /* finished with mbuf, free it now */
      m_free(m);
 822ff58:	e13ffd17 	ldw	r4,-12(fp)
 822ff5c:	822e3b00 	call	822e3b0 <m_free>
      pkt->fhost = fhost;
 822ff60:	e0bffa17 	ldw	r2,-24(fp)
 822ff64:	e0fff317 	ldw	r3,-52(fp)
 822ff68:	10c00715 	stw	r3,28(r2)
       * is up; if (after all that) we don't have an interface then we
       * fail with error EADDRNOTAVAIL; and finally, if we're built
       * for a single-homed configuration where there's only one
       * interface, we might as well use it, so we do.  
       */
      if (fhost == 0xffffffff)
 822ff6c:	e0bff317 	ldw	r2,-52(fp)
 822ff70:	10bfffd8 	cmpnei	r2,r2,-1
 822ff74:	10004a1e 	bne	r2,zero,82300a0 <rawip_usrreq+0x58c>
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
 822ff78:	e0bff817 	ldw	r2,-32(fp)
 822ff7c:	10800117 	ldw	r2,4(r2)
 822ff80:	10001026 	beq	r2,zero,822ffc4 <rawip_usrreq+0x4b0>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822ff84:	008209b4 	movhi	r2,2086
 822ff88:	10ba6504 	addi	r2,r2,-5740
 822ff8c:	10800017 	ldw	r2,0(r2)
 822ff90:	e0bff515 	stw	r2,-44(fp)
 822ff94:	00000806 	br	822ffb8 <rawip_usrreq+0x4a4>
               if (ifp->n_ipaddr == ep->ipr_laddr)
 822ff98:	e0bff517 	ldw	r2,-44(fp)
 822ff9c:	10c00a17 	ldw	r3,40(r2)
 822ffa0:	e0bff817 	ldw	r2,-32(fp)
 822ffa4:	10800117 	ldw	r2,4(r2)
 822ffa8:	18801d26 	beq	r3,r2,8230020 <rawip_usrreq+0x50c>
      if (fhost == 0xffffffff)
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822ffac:	e0bff517 	ldw	r2,-44(fp)
 822ffb0:	10800017 	ldw	r2,0(r2)
 822ffb4:	e0bff515 	stw	r2,-44(fp)
 822ffb8:	e0bff517 	ldw	r2,-44(fp)
 822ffbc:	103ff61e 	bne	r2,zero,822ff98 <rawip_usrreq+0x484>
 822ffc0:	00001a06 	br	823002c <rawip_usrreq+0x518>
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 822ffc4:	008209b4 	movhi	r2,2086
 822ffc8:	10ba6504 	addi	r2,r2,-5740
 822ffcc:	10800017 	ldw	r2,0(r2)
 822ffd0:	e0bff515 	stw	r2,-44(fp)
 822ffd4:	00000f06 	br	8230014 <rawip_usrreq+0x500>
               if ((ifp->n_flags & NF_BCAST) &&
 822ffd8:	e0bff517 	ldw	r2,-44(fp)
 822ffdc:	10802a17 	ldw	r2,168(r2)
 822ffe0:	1080004c 	andi	r2,r2,1
 822ffe4:	10000826 	beq	r2,zero,8230008 <rawip_usrreq+0x4f4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 822ffe8:	e0bff517 	ldw	r2,-44(fp)
 822ffec:	10802717 	ldw	r2,156(r2)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if ((ifp->n_flags & NF_BCAST) &&
 822fff0:	10000526 	beq	r2,zero,8230008 <rawip_usrreq+0x4f4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 822fff4:	e0bff517 	ldw	r2,-44(fp)
 822fff8:	10802717 	ldw	r2,156(r2)
 822fffc:	10800617 	ldw	r2,24(r2)
 8230000:	10800058 	cmpnei	r2,r2,1
 8230004:	10000826 	beq	r2,zero,8230028 <rawip_usrreq+0x514>
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8230008:	e0bff517 	ldw	r2,-44(fp)
 823000c:	10800017 	ldw	r2,0(r2)
 8230010:	e0bff515 	stw	r2,-44(fp)
 8230014:	e0bff517 	ldw	r2,-44(fp)
 8230018:	103fef1e 	bne	r2,zero,822ffd8 <rawip_usrreq+0x4c4>
 823001c:	00000306 	br	823002c <rawip_usrreq+0x518>
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
 8230020:	0001883a 	nop
 8230024:	00000106 	br	823002c <rawip_usrreq+0x518>
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if ((ifp->n_flags & NF_BCAST) &&
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
 8230028:	0001883a 	nop
         }
         if (ifp == NULL)
 823002c:	e0bff517 	ldw	r2,-44(fp)
 8230030:	1000181e 	bne	r2,zero,8230094 <rawip_usrreq+0x580>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8230034:	008209b4 	movhi	r2,2086
 8230038:	10ba6504 	addi	r2,r2,-5740
 823003c:	10800017 	ldw	r2,0(r2)
 8230040:	e0bff515 	stw	r2,-44(fp)
 8230044:	00000b06 	br	8230074 <rawip_usrreq+0x560>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 8230048:	e0bff517 	ldw	r2,-44(fp)
 823004c:	10802717 	ldw	r2,156(r2)
 8230050:	10000526 	beq	r2,zero,8230068 <rawip_usrreq+0x554>
 8230054:	e0bff517 	ldw	r2,-44(fp)
 8230058:	10802717 	ldw	r2,156(r2)
 823005c:	10800617 	ldw	r2,24(r2)
 8230060:	10800058 	cmpnei	r2,r2,1
 8230064:	10000626 	beq	r2,zero,8230080 <rawip_usrreq+0x56c>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 8230068:	e0bff517 	ldw	r2,-44(fp)
 823006c:	10800017 	ldw	r2,0(r2)
 8230070:	e0bff515 	stw	r2,-44(fp)
 8230074:	e0bff517 	ldw	r2,-44(fp)
 8230078:	103ff31e 	bne	r2,zero,8230048 <rawip_usrreq+0x534>
 823007c:	00000106 	br	8230084 <rawip_usrreq+0x570>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
 8230080:	0001883a 	nop
            if (ifp == NULL)
 8230084:	e0bff517 	ldw	r2,-44(fp)
 8230088:	1000021e 	bne	r2,zero,8230094 <rawip_usrreq+0x580>
               return(EADDRNOTAVAIL);
 823008c:	00801f44 	movi	r2,125
 8230090:	00006d06 	br	8230248 <rawip_usrreq+0x734>
         }
         pkt->net = ifp;
 8230094:	e0bffa17 	ldw	r2,-24(fp)
 8230098:	e0fff517 	ldw	r3,-44(fp)
 823009c:	10c00615 	stw	r3,24(r2)
#ifdef IP_MULTICAST

      /* If the socket has an IP moptions structure for multicast options,
       * place a pointer to this structure in the PACKET structure.
       */
      if (so->inp_moptions)
 82300a0:	e0bffc17 	ldw	r2,-16(fp)
 82300a4:	10800317 	ldw	r2,12(r2)
 82300a8:	10000426 	beq	r2,zero,82300bc <rawip_usrreq+0x5a8>
         pkt->imo = so->inp_moptions;
 82300ac:	e0bffc17 	ldw	r2,-16(fp)
 82300b0:	10c00317 	ldw	r3,12(r2)
 82300b4:	e0bffa17 	ldw	r2,-24(fp)
 82300b8:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

      if (so->so_options & SO_HDRINCL)
 82300bc:	e0bffc17 	ldw	r2,-16(fp)
 82300c0:	10800417 	ldw	r2,16(r2)
 82300c4:	1088000c 	andi	r2,r2,8192
 82300c8:	10000826 	beq	r2,zero,82300ec <rawip_usrreq+0x5d8>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 82300cc:	0009883a 	mov	r4,zero
 82300d0:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         e = ip_raw_write(pkt);
 82300d4:	e13ffa17 	ldw	r4,-24(fp)
 82300d8:	823fd540 	call	823fd54 <ip_raw_write>
 82300dc:	e0bff215 	stw	r2,-56(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 82300e0:	0009883a 	mov	r4,zero
 82300e4:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
 82300e8:	00002806 	br	823018c <rawip_usrreq+0x678>
      }
      else
      {
         pip = (struct ip *)(pkt->nb_prot - IPHSIZ);
 82300ec:	e0bffa17 	ldw	r2,-24(fp)
 82300f0:	10800317 	ldw	r2,12(r2)
 82300f4:	10bffb04 	addi	r2,r2,-20
 82300f8:	e0bffb15 	stw	r2,-20(fp)
         if (ep->ipr_laddr)
 82300fc:	e0bff817 	ldw	r2,-32(fp)
 8230100:	10800117 	ldw	r2,4(r2)
 8230104:	10000526 	beq	r2,zero,823011c <rawip_usrreq+0x608>
            pip->ip_src = ep->ipr_laddr;
 8230108:	e0bff817 	ldw	r2,-32(fp)
 823010c:	10c00117 	ldw	r3,4(r2)
 8230110:	e0bffb17 	ldw	r2,-20(fp)
 8230114:	10c00315 	stw	r3,12(r2)
 8230118:	00000e06 	br	8230154 <rawip_usrreq+0x640>
         else
         {
            if (fhost == 0xffffffff)
 823011c:	e0bff317 	ldw	r2,-52(fp)
 8230120:	10bfffd8 	cmpnei	r2,r2,-1
 8230124:	1000061e 	bne	r2,zero,8230140 <rawip_usrreq+0x62c>
               pip->ip_src = pkt->net->n_ipaddr;
 8230128:	e0bffa17 	ldw	r2,-24(fp)
 823012c:	10800617 	ldw	r2,24(r2)
 8230130:	10c00a17 	ldw	r3,40(r2)
 8230134:	e0bffb17 	ldw	r2,-20(fp)
 8230138:	10c00315 	stw	r3,12(r2)
 823013c:	00000506 	br	8230154 <rawip_usrreq+0x640>
            else
               pip->ip_src = ip_mymach(fhost);
 8230140:	e13ff317 	ldw	r4,-52(fp)
 8230144:	82408000 	call	8240800 <ip_mymach>
 8230148:	1007883a 	mov	r3,r2
 823014c:	e0bffb17 	ldw	r2,-20(fp)
 8230150:	10c00315 	stw	r3,12(r2)
         }
         pip->ip_dest = fhost;
 8230154:	e0bffb17 	ldw	r2,-20(fp)
 8230158:	e0fff317 	ldw	r3,-52(fp)
 823015c:	10c00415 	stw	r3,16(r2)
         UNLOCK_NET_RESOURCE(NET_RESID);
 8230160:	0009883a 	mov	r4,zero
 8230164:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         e = ip_write(ep->ipr_prot, pkt);
 8230168:	e0bff817 	ldw	r2,-32(fp)
 823016c:	10800503 	ldbu	r2,20(r2)
 8230170:	10803fcc 	andi	r2,r2,255
 8230174:	e17ffa17 	ldw	r5,-24(fp)
 8230178:	1009883a 	mov	r4,r2
 823017c:	823f7b00 	call	823f7b0 <ip_write>
 8230180:	e0bff215 	stw	r2,-56(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 8230184:	0009883a 	mov	r4,zero
 8230188:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      }         
      if (e < 0) 
 823018c:	e0bff217 	ldw	r2,-56(fp)
 8230190:	1000020e 	bge	r2,zero,823019c <rawip_usrreq+0x688>
         return(e);
 8230194:	e0bff217 	ldw	r2,-56(fp)
 8230198:	00002b06 	br	8230248 <rawip_usrreq+0x734>
      return 0;
 823019c:	0005883a 	mov	r2,zero
 82301a0:	00002906 	br	8230248 <rawip_usrreq+0x734>
   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 82301a4:	e0bffe17 	ldw	r2,-8(fp)
 82301a8:	1000021e 	bne	r2,zero,82301b4 <rawip_usrreq+0x6a0>
         return(EINVAL);
 82301ac:	00800584 	movi	r2,22
 82301b0:	00002506 	br	8230248 <rawip_usrreq+0x734>
      sin = mtod(nam, struct sockaddr_in *);
 82301b4:	e0bffe17 	ldw	r2,-8(fp)
 82301b8:	10800317 	ldw	r2,12(r2)
 82301bc:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 82301c0:	e0bff917 	ldw	r2,-28(fp)
 82301c4:	1000021e 	bne	r2,zero,82301d0 <rawip_usrreq+0x6bc>
         return(EINVAL);
 82301c8:	00800584 	movi	r2,22
 82301cc:	00001e06 	br	8230248 <rawip_usrreq+0x734>
      ep = rawip_lookup(so);
 82301d0:	e13ffc17 	ldw	r4,-16(fp)
 82301d4:	822f8f00 	call	822f8f0 <rawip_lookup>
 82301d8:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 82301dc:	e0bff817 	ldw	r2,-32(fp)
 82301e0:	1000021e 	bne	r2,zero,82301ec <rawip_usrreq+0x6d8>
         return(EINVAL);
 82301e4:	00800584 	movi	r2,22
 82301e8:	00001706 	br	8230248 <rawip_usrreq+0x734>
      sin->sin_port = 0;
 82301ec:	e0bff917 	ldw	r2,-28(fp)
 82301f0:	1000008d 	sth	zero,2(r2)
      nam->m_len = sizeof(*sin);
 82301f4:	e0bffe17 	ldw	r2,-8(fp)
 82301f8:	00c00404 	movi	r3,16
 82301fc:	10c00215 	stw	r3,8(r2)
      if (req == PRU_SOCKADDR)
 8230200:	e0bff617 	ldw	r2,-40(fp)
 8230204:	108003d8 	cmpnei	r2,r2,15
 8230208:	1000051e 	bne	r2,zero,8230220 <rawip_usrreq+0x70c>
      {
         sin->sin_addr.s_addr = ep->ipr_laddr;
 823020c:	e0bff817 	ldw	r2,-32(fp)
 8230210:	10c00117 	ldw	r3,4(r2)
 8230214:	e0bff917 	ldw	r2,-28(fp)
 8230218:	10c00115 	stw	r3,4(r2)
 823021c:	00000406 	br	8230230 <rawip_usrreq+0x71c>
      }
      else /* PRU_PEERADDR */
      {
         sin->sin_addr.s_addr = ep->ipr_faddr;
 8230220:	e0bff817 	ldw	r2,-32(fp)
 8230224:	10c00217 	ldw	r3,8(r2)
 8230228:	e0bff917 	ldw	r2,-28(fp)
 823022c:	10c00115 	stw	r3,4(r2)
      }
      return 0;
 8230230:	0005883a 	mov	r2,zero
 8230234:	00000406 	br	8230248 <rawip_usrreq+0x734>
   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 8230238:	822d4140 	call	822d414 <dtrap>
      return 0;
 823023c:	0005883a 	mov	r2,zero
 8230240:	00000106 	br	8230248 <rawip_usrreq+0x734>
   case PRU_LISTEN:     /* don't support these for raw IP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 8230244:	008017c4 	movi	r2,95
   }
}
 8230248:	e6ffff04 	addi	sp,fp,-4
 823024c:	dfc00217 	ldw	ra,8(sp)
 8230250:	df000117 	ldw	fp,4(sp)
 8230254:	dc000017 	ldw	r16,0(sp)
 8230258:	dec00304 	addi	sp,sp,12
 823025c:	f800283a 	ret

08230260 <DOMAIN_CHECK>:
 */

#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
 8230260:	defffc04 	addi	sp,sp,-16
 8230264:	dfc00315 	stw	ra,12(sp)
 8230268:	df000215 	stw	fp,8(sp)
 823026c:	df000204 	addi	fp,sp,8
 8230270:	e13ffe15 	stw	r4,-8(fp)
 8230274:	e17fff15 	stw	r5,-4(fp)
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 8230278:	e0bffe17 	ldw	r2,-8(fp)
 823027c:	10800517 	ldw	r2,20(r2)
 8230280:	10800098 	cmpnei	r2,r2,2
 8230284:	1000041e 	bne	r2,zero,8230298 <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
 8230288:	e0bfff17 	ldw	r2,-4(fp)
#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 823028c:	10800428 	cmpgeui	r2,r2,16
 8230290:	1000011e 	bne	r2,zero,8230298 <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
   {
      dtrap(); /* programmer passed wrong structure */
 8230294:	822d4140 	call	822d414 <dtrap>
      (size != sizeof(struct sockaddr_in6)))
   {
      dtrap(); /* programmer passed wrong structure */
   }
#endif   /* IP_V6 */
}
 8230298:	0001883a 	nop
 823029c:	e037883a 	mov	sp,fp
 82302a0:	dfc00117 	ldw	ra,4(sp)
 82302a4:	df000017 	ldw	fp,0(sp)
 82302a8:	dec00204 	addi	sp,sp,8
 82302ac:	f800283a 	ret

082302b0 <t_socket>:

long
t_socket(int family, 
   int   type, 
   int   proto)
{
 82302b0:	defffa04 	addi	sp,sp,-24
 82302b4:	dfc00515 	stw	ra,20(sp)
 82302b8:	df000415 	stw	fp,16(sp)
 82302bc:	df000404 	addi	fp,sp,16
 82302c0:	e13ffd15 	stw	r4,-12(fp)
 82302c4:	e17ffe15 	stw	r5,-8(fp)
 82302c8:	e1bfff15 	stw	r6,-4(fp)
   struct socket *   so;

   INET_TRACE (INETM_SOCKET, ("SOCK:sock:family %d, typ %d, proto %d\n",
    family, type, proto));
   LOCK_NET_RESOURCE(NET_RESID);
 82302cc:	0009883a 	mov	r4,zero
 82302d0:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   if ((so = socreate (family, type, proto)) == NULL) 
 82302d4:	e1bfff17 	ldw	r6,-4(fp)
 82302d8:	e17ffe17 	ldw	r5,-8(fp)
 82302dc:	e13ffd17 	ldw	r4,-12(fp)
 82302e0:	82318b40 	call	82318b4 <socreate>
 82302e4:	e0bffc15 	stw	r2,-16(fp)
 82302e8:	e0bffc17 	ldw	r2,-16(fp)
 82302ec:	1000041e 	bne	r2,zero,8230300 <t_socket+0x50>
   {  /* can't really return error info since no socket.... */
      UNLOCK_NET_RESOURCE(NET_RESID);
 82302f0:	0009883a 	mov	r4,zero
 82302f4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 82302f8:	00bfffc4 	movi	r2,-1
 82302fc:	00000706 	br	823031c <t_socket+0x6c>
   }
   SOC_RANGE(so);
   so->so_error = 0;
 8230300:	e0bffc17 	ldw	r2,-16(fp)
 8230304:	10000615 	stw	zero,24(r2)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230308:	0009883a 	mov	r4,zero
 823030c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   return SO2LONG(so);
 8230310:	e0bffc17 	ldw	r2,-16(fp)
 8230314:	1004d0ba 	srli	r2,r2,2
 8230318:	10800804 	addi	r2,r2,32
}
 823031c:	e037883a 	mov	sp,fp
 8230320:	dfc00117 	ldw	ra,4(sp)
 8230324:	df000017 	ldw	fp,0(sp)
 8230328:	dec00204 	addi	sp,sp,8
 823032c:	f800283a 	ret

08230330 <t_bind>:

int
t_bind (long s, 
   struct sockaddr * addr,
   int addrlen)
{
 8230330:	defff204 	addi	sp,sp,-56
 8230334:	dfc00d15 	stw	ra,52(sp)
 8230338:	df000c15 	stw	fp,48(sp)
 823033c:	df000c04 	addi	fp,sp,48
 8230340:	e13ffd15 	stw	r4,-12(fp)
 8230344:	e17ffe15 	stw	r5,-8(fp)
 8230348:	e1bfff15 	stw	r6,-4(fp)
   struct sockaddr   sa;
   struct sockaddr * sap;
   struct socket *   so;
   int               err;

   so = LONG2SO(s);  /* convert long to socket */
 823034c:	e0bffd17 	ldw	r2,-12(fp)
 8230350:	10bff804 	addi	r2,r2,-32
 8230354:	1085883a 	add	r2,r2,r2
 8230358:	1085883a 	add	r2,r2,r2
 823035c:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 8230360:	008209b4 	movhi	r2,2086
 8230364:	10b96104 	addi	r2,r2,-6780
 8230368:	e0bff515 	stw	r2,-44(fp)
 823036c:	00000606 	br	8230388 <t_bind+0x58>
 8230370:	e0fff517 	ldw	r3,-44(fp)
 8230374:	e0bff617 	ldw	r2,-40(fp)
 8230378:	18800626 	beq	r3,r2,8230394 <t_bind+0x64>
 823037c:	e0bff517 	ldw	r2,-44(fp)
 8230380:	10800017 	ldw	r2,0(r2)
 8230384:	e0bff515 	stw	r2,-44(fp)
 8230388:	e0bff517 	ldw	r2,-44(fp)
 823038c:	103ff81e 	bne	r2,zero,8230370 <t_bind+0x40>
 8230390:	00000106 	br	8230398 <t_bind+0x68>
 8230394:	0001883a 	nop
 8230398:	e0fff517 	ldw	r3,-44(fp)
 823039c:	e0bff617 	ldw	r2,-40(fp)
 82303a0:	18800326 	beq	r3,r2,82303b0 <t_bind+0x80>
 82303a4:	822d4140 	call	822d414 <dtrap>
 82303a8:	00bfffc4 	movi	r2,-1
 82303ac:	00003406 	br	8230480 <t_bind+0x150>
   DOMAIN_CHECK(so, addrlen);
 82303b0:	e17fff17 	ldw	r5,-4(fp)
 82303b4:	e13ff617 	ldw	r4,-40(fp)
 82303b8:	82302600 	call	8230260 <DOMAIN_CHECK>

   so->so_error = 0;
 82303bc:	e0bff617 	ldw	r2,-40(fp)
 82303c0:	10000615 	stw	zero,24(r2)
   if (addr == (struct sockaddr *)NULL) 
 82303c4:	e0bffe17 	ldw	r2,-8(fp)
 82303c8:	10000d1e 	bne	r2,zero,8230400 <t_bind+0xd0>
   {
      MEMSET ((void *)&sa, 0, sizeof(sa));
 82303cc:	e0bff904 	addi	r2,fp,-28
 82303d0:	01800404 	movi	r6,16
 82303d4:	000b883a 	mov	r5,zero
 82303d8:	1009883a 	mov	r4,r2
 82303dc:	82031300 	call	8203130 <memset>
      addrlen = sizeof(sa);
 82303e0:	00800404 	movi	r2,16
 82303e4:	e0bfff15 	stw	r2,-4(fp)
      sa.sa_family = so->so_domain;
 82303e8:	e0bff617 	ldw	r2,-40(fp)
 82303ec:	10800517 	ldw	r2,20(r2)
 82303f0:	e0bff90d 	sth	r2,-28(fp)
      sap = &sa;
 82303f4:	e0bff904 	addi	r2,fp,-28
 82303f8:	e0bff415 	stw	r2,-48(fp)
 82303fc:	00000206 	br	8230408 <t_bind+0xd8>
   } else
      sap = addr;
 8230400:	e0bffe17 	ldw	r2,-8(fp)
 8230404:	e0bff415 	stw	r2,-48(fp)

   if ((nam = sockargs (sap, addrlen, MT_SONAME)) == NULL) 
 8230408:	01800244 	movi	r6,9
 823040c:	e17fff17 	ldw	r5,-4(fp)
 8230410:	e13ff417 	ldw	r4,-48(fp)
 8230414:	82317900 	call	8231790 <sockargs>
 8230418:	e0bff715 	stw	r2,-36(fp)
 823041c:	e0bff717 	ldw	r2,-36(fp)
 8230420:	1000051e 	bne	r2,zero,8230438 <t_bind+0x108>
   {
      so->so_error = ENOMEM;
 8230424:	e0bff617 	ldw	r2,-40(fp)
 8230428:	00c00304 	movi	r3,12
 823042c:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230430:	00bfffc4 	movi	r2,-1
 8230434:	00001206 	br	8230480 <t_bind+0x150>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 8230438:	0009883a 	mov	r4,zero
 823043c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   err = sobind (so, nam);
 8230440:	e17ff717 	ldw	r5,-36(fp)
 8230444:	e13ff617 	ldw	r4,-40(fp)
 8230448:	8231a5c0 	call	8231a5c <sobind>
 823044c:	e0bff815 	stw	r2,-32(fp)
   m_freem(nam);
 8230450:	e13ff717 	ldw	r4,-36(fp)
 8230454:	822e4b80 	call	822e4b8 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230458:	0009883a 	mov	r4,zero
 823045c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   if (err) 
 8230460:	e0bff817 	ldw	r2,-32(fp)
 8230464:	10000526 	beq	r2,zero,823047c <t_bind+0x14c>
   {
      so->so_error = err;
 8230468:	e0bff617 	ldw	r2,-40(fp)
 823046c:	e0fff817 	ldw	r3,-32(fp)
 8230470:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230474:	00bfffc4 	movi	r2,-1
 8230478:	00000106 	br	8230480 <t_bind+0x150>
   }
   return 0;
 823047c:	0005883a 	mov	r2,zero
}
 8230480:	e037883a 	mov	sp,fp
 8230484:	dfc00117 	ldw	ra,4(sp)
 8230488:	df000017 	ldw	fp,0(sp)
 823048c:	dec00204 	addi	sp,sp,8
 8230490:	f800283a 	ret

08230494 <t_listen>:
 */

int
t_listen(long s, 
   int   backlog)
{
 8230494:	defff904 	addi	sp,sp,-28
 8230498:	dfc00615 	stw	ra,24(sp)
 823049c:	df000515 	stw	fp,20(sp)
 82304a0:	df000504 	addi	fp,sp,20
 82304a4:	e13ffe15 	stw	r4,-8(fp)
 82304a8:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);  /* convert long to socket */
 82304ac:	e0bffe17 	ldw	r2,-8(fp)
 82304b0:	10bff804 	addi	r2,r2,-32
 82304b4:	1085883a 	add	r2,r2,r2
 82304b8:	1085883a 	add	r2,r2,r2
 82304bc:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 82304c0:	008209b4 	movhi	r2,2086
 82304c4:	10b96104 	addi	r2,r2,-6780
 82304c8:	e0bffb15 	stw	r2,-20(fp)
 82304cc:	00000606 	br	82304e8 <t_listen+0x54>
 82304d0:	e0fffb17 	ldw	r3,-20(fp)
 82304d4:	e0bffc17 	ldw	r2,-16(fp)
 82304d8:	18800626 	beq	r3,r2,82304f4 <t_listen+0x60>
 82304dc:	e0bffb17 	ldw	r2,-20(fp)
 82304e0:	10800017 	ldw	r2,0(r2)
 82304e4:	e0bffb15 	stw	r2,-20(fp)
 82304e8:	e0bffb17 	ldw	r2,-20(fp)
 82304ec:	103ff81e 	bne	r2,zero,82304d0 <t_listen+0x3c>
 82304f0:	00000106 	br	82304f8 <t_listen+0x64>
 82304f4:	0001883a 	nop
 82304f8:	e0fffb17 	ldw	r3,-20(fp)
 82304fc:	e0bffc17 	ldw	r2,-16(fp)
 8230500:	18800326 	beq	r3,r2,8230510 <t_listen+0x7c>
 8230504:	822d4140 	call	822d414 <dtrap>
 8230508:	00bfffc4 	movi	r2,-1
 823050c:	00001206 	br	8230558 <t_listen+0xc4>
   so->so_error = 0;
 8230510:	e0bffc17 	ldw	r2,-16(fp)
 8230514:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("SOCK:listen:qlen %d\n", backlog));

   LOCK_NET_RESOURCE(NET_RESID);
 8230518:	0009883a 	mov	r4,zero
 823051c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   err = solisten (so, backlog);
 8230520:	e17fff17 	ldw	r5,-4(fp)
 8230524:	e13ffc17 	ldw	r4,-16(fp)
 8230528:	8231ab80 	call	8231ab8 <solisten>
 823052c:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230530:	0009883a 	mov	r4,zero
 8230534:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 8230538:	e0bffd17 	ldw	r2,-12(fp)
 823053c:	10000526 	beq	r2,zero,8230554 <t_listen+0xc0>
   {
      so->so_error = err;
 8230540:	e0bffc17 	ldw	r2,-16(fp)
 8230544:	e0fffd17 	ldw	r3,-12(fp)
 8230548:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 823054c:	00bfffc4 	movi	r2,-1
 8230550:	00000106 	br	8230558 <t_listen+0xc4>
   }
   return 0;
 8230554:	0005883a 	mov	r2,zero
}
 8230558:	e037883a 	mov	sp,fp
 823055c:	dfc00117 	ldw	ra,4(sp)
 8230560:	df000017 	ldw	fp,0(sp)
 8230564:	dec00204 	addi	sp,sp,8
 8230568:	f800283a 	ret

0823056c <t_accept>:

long
t_accept(long s, 
   struct sockaddr * addr,
   int * addrlen)
{
 823056c:	defff704 	addi	sp,sp,-36
 8230570:	dfc00815 	stw	ra,32(sp)
 8230574:	df000715 	stw	fp,28(sp)
 8230578:	df000704 	addi	fp,sp,28
 823057c:	e13ffd15 	stw	r4,-12(fp)
 8230580:	e17ffe15 	stw	r5,-8(fp)
 8230584:	e1bfff15 	stw	r6,-4(fp)
   char logbuf[10];
#endif
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 8230588:	e0bffd17 	ldw	r2,-12(fp)
 823058c:	10bff804 	addi	r2,r2,-32
 8230590:	1085883a 	add	r2,r2,r2
 8230594:	1085883a 	add	r2,r2,r2
 8230598:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 823059c:	008209b4 	movhi	r2,2086
 82305a0:	10b96104 	addi	r2,r2,-6780
 82305a4:	e0bff915 	stw	r2,-28(fp)
 82305a8:	00000606 	br	82305c4 <t_accept+0x58>
 82305ac:	e0fff917 	ldw	r3,-28(fp)
 82305b0:	e0bffa17 	ldw	r2,-24(fp)
 82305b4:	18800626 	beq	r3,r2,82305d0 <t_accept+0x64>
 82305b8:	e0bff917 	ldw	r2,-28(fp)
 82305bc:	10800017 	ldw	r2,0(r2)
 82305c0:	e0bff915 	stw	r2,-28(fp)
 82305c4:	e0bff917 	ldw	r2,-28(fp)
 82305c8:	103ff81e 	bne	r2,zero,82305ac <t_accept+0x40>
 82305cc:	00000106 	br	82305d4 <t_accept+0x68>
 82305d0:	0001883a 	nop
 82305d4:	e0fff917 	ldw	r3,-28(fp)
 82305d8:	e0bffa17 	ldw	r2,-24(fp)
 82305dc:	18800326 	beq	r3,r2,82305ec <t_accept+0x80>
 82305e0:	822d4140 	call	822d414 <dtrap>
 82305e4:	00bfffc4 	movi	r2,-1
 82305e8:	00007006 	br	82307ac <t_accept+0x240>
   DOMAIN_CHECK(so, *addrlen);
 82305ec:	e0bfff17 	ldw	r2,-4(fp)
 82305f0:	10800017 	ldw	r2,0(r2)
 82305f4:	100b883a 	mov	r5,r2
 82305f8:	e13ffa17 	ldw	r4,-24(fp)
 82305fc:	82302600 	call	8230260 <DOMAIN_CHECK>

   so->so_error = 0;
 8230600:	e0bffa17 	ldw	r2,-24(fp)
 8230604:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
      ("INET:accept:so %x so_qlen %d so_state %x\n", so, so->so_qlen, so->so_state));
   if ((so->so_options & SO_ACCEPTCONN) == 0)
 8230608:	e0bffa17 	ldw	r2,-24(fp)
 823060c:	10800417 	ldw	r2,16(r2)
 8230610:	1080008c 	andi	r2,r2,2
 8230614:	1000051e 	bne	r2,zero,823062c <t_accept+0xc0>
   {
      so->so_error = EINVAL;
 8230618:	e0bffa17 	ldw	r2,-24(fp)
 823061c:	00c00584 	movi	r3,22
 8230620:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8230624:	00bfffc4 	movi	r2,-1
 8230628:	00006006 	br	82307ac <t_accept+0x240>
   }
   if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
 823062c:	e0bffa17 	ldw	r2,-24(fp)
 8230630:	1080088b 	ldhu	r2,34(r2)
 8230634:	10bfffcc 	andi	r2,r2,65535
 8230638:	1080400c 	andi	r2,r2,256
 823063c:	10000b26 	beq	r2,zero,823066c <t_accept+0x100>
 8230640:	e0bffa17 	ldw	r2,-24(fp)
 8230644:	10801e43 	ldbu	r2,121(r2)
 8230648:	10803fcc 	andi	r2,r2,255
 823064c:	1080201c 	xori	r2,r2,128
 8230650:	10bfe004 	addi	r2,r2,-128
 8230654:	1000051e 	bne	r2,zero,823066c <t_accept+0x100>
   {
      so->so_error = EWOULDBLOCK;
 8230658:	e0bffa17 	ldw	r2,-24(fp)
 823065c:	00c002c4 	movi	r3,11
 8230660:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8230664:	00bfffc4 	movi	r2,-1
 8230668:	00005006 	br	82307ac <t_accept+0x240>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 823066c:	0009883a 	mov	r4,zero
 8230670:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   while (so->so_qlen == 0 && so->so_error == 0)
 8230674:	00001006 	br	82306b8 <t_accept+0x14c>
   {
      if (so->so_state & SS_CANTRCVMORE)
 8230678:	e0bffa17 	ldw	r2,-24(fp)
 823067c:	1080088b 	ldhu	r2,34(r2)
 8230680:	10bfffcc 	andi	r2,r2,65535
 8230684:	1080080c 	andi	r2,r2,32
 8230688:	10000726 	beq	r2,zero,82306a8 <t_accept+0x13c>
      {
         so->so_error = ECONNABORTED;
 823068c:	e0bffa17 	ldw	r2,-24(fp)
 8230690:	00c01c44 	movi	r3,113
 8230694:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE(NET_RESID);
 8230698:	0009883a 	mov	r4,zero
 823069c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 82306a0:	00bfffc4 	movi	r2,-1
 82306a4:	00004106 	br	82307ac <t_accept+0x240>
      }
      tcp_sleep ((char *)&so->so_timeo);
 82306a8:	e0bffa17 	ldw	r2,-24(fp)
 82306ac:	10800904 	addi	r2,r2,36
 82306b0:	1009883a 	mov	r4,r2
 82306b4:	82293d80 	call	82293d8 <tcp_sleep>
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
   }
   LOCK_NET_RESOURCE(NET_RESID);
   while (so->so_qlen == 0 && so->so_error == 0)
 82306b8:	e0bffa17 	ldw	r2,-24(fp)
 82306bc:	10801e43 	ldbu	r2,121(r2)
 82306c0:	10803fcc 	andi	r2,r2,255
 82306c4:	1080201c 	xori	r2,r2,128
 82306c8:	10bfe004 	addi	r2,r2,-128
 82306cc:	1000031e 	bne	r2,zero,82306dc <t_accept+0x170>
 82306d0:	e0bffa17 	ldw	r2,-24(fp)
 82306d4:	10800617 	ldw	r2,24(r2)
 82306d8:	103fe726 	beq	r2,zero,8230678 <t_accept+0x10c>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return SOCKET_ERROR;
      }
      tcp_sleep ((char *)&so->so_timeo);
   }
   if (so->so_error)
 82306dc:	e0bffa17 	ldw	r2,-24(fp)
 82306e0:	10800617 	ldw	r2,24(r2)
 82306e4:	10000426 	beq	r2,zero,82306f8 <t_accept+0x18c>
   {
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 82306e8:	0009883a 	mov	r4,zero
 82306ec:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 82306f0:	00bfffc4 	movi	r2,-1
 82306f4:	00002d06 	br	82307ac <t_accept+0x240>
   }
   nam = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 82306f8:	01400404 	movi	r5,16
 82306fc:	01000244 	movi	r4,9
 8230700:	822e2280 	call	822e228 <m_getnbuf>
 8230704:	e0bffb15 	stw	r2,-20(fp)
   if (nam == NULL) 
 8230708:	e0bffb17 	ldw	r2,-20(fp)
 823070c:	1000071e 	bne	r2,zero,823072c <t_accept+0x1c0>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 8230710:	0009883a 	mov	r4,zero
 8230714:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      so->so_error = ENOMEM;
 8230718:	e0bffa17 	ldw	r2,-24(fp)
 823071c:	00c00304 	movi	r3,12
 8230720:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8230724:	00bfffc4 	movi	r2,-1
 8230728:	00002006 	br	82307ac <t_accept+0x240>
   }
   { 
      struct socket *aso = so->so_q;
 823072c:	e0bffa17 	ldw	r2,-24(fp)
 8230730:	10801d17 	ldw	r2,116(r2)
 8230734:	e0bffc15 	stw	r2,-16(fp)
      if (soqremque (aso, 1) == 0)
 8230738:	01400044 	movi	r5,1
 823073c:	e13ffc17 	ldw	r4,-16(fp)
 8230740:	8233e640 	call	8233e64 <soqremque>
 8230744:	1000031e 	bne	r2,zero,8230754 <t_accept+0x1e8>
         panic("accept");
 8230748:	01020974 	movhi	r4,2085
 823074c:	21037d04 	addi	r4,r4,3572
 8230750:	8228aec0 	call	8228aec <panic>
      so = aso;
 8230754:	e0bffc17 	ldw	r2,-16(fp)
 8230758:	e0bffa15 	stw	r2,-24(fp)
   }
   (void)soaccept (so, nam);
 823075c:	e17ffb17 	ldw	r5,-20(fp)
 8230760:	e13ffa17 	ldw	r4,-24(fp)
 8230764:	8231fa40 	call	8231fa4 <soaccept>
      INET_TRACE (INETM_SOCKET, ("INET:accept:done so %lx port %d addr %lx\n",
       so, sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_INET */
   /* return the addressing info in the passed structure */
   if (addr != NULL)
 8230768:	e0bffe17 	ldw	r2,-8(fp)
 823076c:	10000826 	beq	r2,zero,8230790 <t_accept+0x224>
      MEMCPY(addr, nam->m_data, *addrlen);
 8230770:	e0bffb17 	ldw	r2,-20(fp)
 8230774:	10c00317 	ldw	r3,12(r2)
 8230778:	e0bfff17 	ldw	r2,-4(fp)
 823077c:	10800017 	ldw	r2,0(r2)
 8230780:	100d883a 	mov	r6,r2
 8230784:	180b883a 	mov	r5,r3
 8230788:	e13ffe17 	ldw	r4,-8(fp)
 823078c:	8202e8c0 	call	8202e8c <memcpy>
   m_freem (nam);
 8230790:	e13ffb17 	ldw	r4,-20(fp)
 8230794:	822e4b80 	call	822e4b8 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230798:	0009883a 	mov	r4,zero
 823079c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   SOC_RANGE(so);
   return SO2LONG(so);
 82307a0:	e0bffa17 	ldw	r2,-24(fp)
 82307a4:	1004d0ba 	srli	r2,r2,2
 82307a8:	10800804 	addi	r2,r2,32
}
 82307ac:	e037883a 	mov	sp,fp
 82307b0:	dfc00117 	ldw	ra,4(sp)
 82307b4:	df000017 	ldw	fp,0(sp)
 82307b8:	dec00204 	addi	sp,sp,8
 82307bc:	f800283a 	ret

082307c0 <t_connect>:

int
t_connect(long s, 
   struct sockaddr * addr,
   int   addrlen)
{
 82307c0:	defff804 	addi	sp,sp,-32
 82307c4:	dfc00715 	stw	ra,28(sp)
 82307c8:	df000615 	stw	fp,24(sp)
 82307cc:	df000604 	addi	fp,sp,24
 82307d0:	e13ffd15 	stw	r4,-12(fp)
 82307d4:	e17ffe15 	stw	r5,-8(fp)
 82307d8:	e1bfff15 	stw	r6,-4(fp)
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 82307dc:	e0bffd17 	ldw	r2,-12(fp)
 82307e0:	10bff804 	addi	r2,r2,-32
 82307e4:	1085883a 	add	r2,r2,r2
 82307e8:	1085883a 	add	r2,r2,r2
 82307ec:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 82307f0:	008209b4 	movhi	r2,2086
 82307f4:	10b96104 	addi	r2,r2,-6780
 82307f8:	e0bffa15 	stw	r2,-24(fp)
 82307fc:	00000606 	br	8230818 <t_connect+0x58>
 8230800:	e0fffa17 	ldw	r3,-24(fp)
 8230804:	e0bffb17 	ldw	r2,-20(fp)
 8230808:	18800626 	beq	r3,r2,8230824 <t_connect+0x64>
 823080c:	e0bffa17 	ldw	r2,-24(fp)
 8230810:	10800017 	ldw	r2,0(r2)
 8230814:	e0bffa15 	stw	r2,-24(fp)
 8230818:	e0bffa17 	ldw	r2,-24(fp)
 823081c:	103ff81e 	bne	r2,zero,8230800 <t_connect+0x40>
 8230820:	00000106 	br	8230828 <t_connect+0x68>
 8230824:	0001883a 	nop
 8230828:	e0fffa17 	ldw	r3,-24(fp)
 823082c:	e0bffb17 	ldw	r2,-20(fp)
 8230830:	18800326 	beq	r3,r2,8230840 <t_connect+0x80>
 8230834:	822d4140 	call	822d414 <dtrap>
 8230838:	00bfffc4 	movi	r2,-1
 823083c:	00007606 	br	8230a18 <t_connect+0x258>
   DOMAIN_CHECK(so, addrlen);
 8230840:	e17fff17 	ldw	r5,-4(fp)
 8230844:	e13ffb17 	ldw	r4,-20(fp)
 8230848:	82302600 	call	8230260 <DOMAIN_CHECK>

#ifdef NB_CONNECT
   /* need to test non blocking connect bits in case this is a 
      poll of a previous request */
   if (so->so_state & SS_NBIO)
 823084c:	e0bffb17 	ldw	r2,-20(fp)
 8230850:	1080088b 	ldhu	r2,34(r2)
 8230854:	10bfffcc 	andi	r2,r2,65535
 8230858:	1080400c 	andi	r2,r2,256
 823085c:	10002426 	beq	r2,zero,82308f0 <t_connect+0x130>
   {
      if (so->so_state & SS_ISCONNECTING) /* still trying */
 8230860:	e0bffb17 	ldw	r2,-20(fp)
 8230864:	1080088b 	ldhu	r2,34(r2)
 8230868:	10bfffcc 	andi	r2,r2,65535
 823086c:	1080010c 	andi	r2,r2,4
 8230870:	10000526 	beq	r2,zero,8230888 <t_connect+0xc8>
      {
         so->so_error = EINPROGRESS;
 8230874:	e0bffb17 	ldw	r2,-20(fp)
 8230878:	00c01dc4 	movi	r3,119
 823087c:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 8230880:	00bfffc4 	movi	r2,-1
 8230884:	00006406 	br	8230a18 <t_connect+0x258>
      }
      if (so->so_state & SS_ISCONNECTED)  /* connected OK */
 8230888:	e0bffb17 	ldw	r2,-20(fp)
 823088c:	1080088b 	ldhu	r2,34(r2)
 8230890:	10bfffcc 	andi	r2,r2,65535
 8230894:	1080008c 	andi	r2,r2,2
 8230898:	10000426 	beq	r2,zero,82308ac <t_connect+0xec>
      {
         so->so_error = 0;
 823089c:	e0bffb17 	ldw	r2,-20(fp)
 82308a0:	10000615 	stw	zero,24(r2)
         return 0;
 82308a4:	0005883a 	mov	r2,zero
 82308a8:	00005b06 	br	8230a18 <t_connect+0x258>
      }
      if (so->so_state & SS_WASCONNECTING)
 82308ac:	e0bffb17 	ldw	r2,-20(fp)
 82308b0:	1080088b 	ldhu	r2,34(r2)
 82308b4:	10bfffcc 	andi	r2,r2,65535
 82308b8:	1088000c 	andi	r2,r2,8192
 82308bc:	10000c26 	beq	r2,zero,82308f0 <t_connect+0x130>
      {
         so->so_state &= ~SS_WASCONNECTING;
 82308c0:	e0bffb17 	ldw	r2,-20(fp)
 82308c4:	10c0088b 	ldhu	r3,34(r2)
 82308c8:	00b7ffc4 	movi	r2,-8193
 82308cc:	1884703a 	and	r2,r3,r2
 82308d0:	1007883a 	mov	r3,r2
 82308d4:	e0bffb17 	ldw	r2,-20(fp)
 82308d8:	10c0088d 	sth	r3,34(r2)
         if (so->so_error) /* connect error - maybe timeout */
 82308dc:	e0bffb17 	ldw	r2,-20(fp)
 82308e0:	10800617 	ldw	r2,24(r2)
 82308e4:	10000226 	beq	r2,zero,82308f0 <t_connect+0x130>
            return SOCKET_ERROR;
 82308e8:	00bfffc4 	movi	r2,-1
 82308ec:	00004a06 	br	8230a18 <t_connect+0x258>
      }
   }
#endif   /*  NB_CONNECT */

   so->so_error = 0;
 82308f0:	e0bffb17 	ldw	r2,-20(fp)
 82308f4:	10000615 	stw	zero,24(r2)

   if ((nam = sockargs (addr, addrlen, MT_SONAME))
 82308f8:	01800244 	movi	r6,9
 82308fc:	e17fff17 	ldw	r5,-4(fp)
 8230900:	e13ffe17 	ldw	r4,-8(fp)
 8230904:	82317900 	call	8231790 <sockargs>
 8230908:	e0bffc15 	stw	r2,-16(fp)
 823090c:	e0bffc17 	ldw	r2,-16(fp)
 8230910:	1000051e 	bne	r2,zero,8230928 <t_connect+0x168>
       == NULL)
   {
      so->so_error = ENOMEM;
 8230914:	e0bffb17 	ldw	r2,-20(fp)
 8230918:	00c00304 	movi	r3,12
 823091c:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230920:	00bfffc4 	movi	r2,-1
 8230924:	00003c06 	br	8230a18 <t_connect+0x258>
      INET_TRACE (INETM_SOCKET, ("INET: connect, port %d addr %lx\n",
       sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 8230928:	0009883a 	mov	r4,zero
 823092c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   if ((so->so_error = soconnect (so, nam)) != 0)
 8230930:	e17ffc17 	ldw	r5,-16(fp)
 8230934:	e13ffb17 	ldw	r4,-20(fp)
 8230938:	823203c0 	call	823203c <soconnect>
 823093c:	1007883a 	mov	r3,r2
 8230940:	e0bffb17 	ldw	r2,-20(fp)
 8230944:	10c00615 	stw	r3,24(r2)
 8230948:	e0bffb17 	ldw	r2,-20(fp)
 823094c:	10800617 	ldw	r2,24(r2)
 8230950:	10001b1e 	bne	r2,zero,82309c0 <t_connect+0x200>
      goto bad;

#ifdef NB_CONNECT
   /* need to test non blocking connect bits after soconnect() call */
   if ((so->so_state & SS_NBIO)&& (so->so_state & SS_ISCONNECTING))
 8230954:	e0bffb17 	ldw	r2,-20(fp)
 8230958:	1080088b 	ldhu	r2,34(r2)
 823095c:	10bfffcc 	andi	r2,r2,65535
 8230960:	1080400c 	andi	r2,r2,256
 8230964:	10000d26 	beq	r2,zero,823099c <t_connect+0x1dc>
 8230968:	e0bffb17 	ldw	r2,-20(fp)
 823096c:	1080088b 	ldhu	r2,34(r2)
 8230970:	10bfffcc 	andi	r2,r2,65535
 8230974:	1080010c 	andi	r2,r2,4
 8230978:	10000826 	beq	r2,zero,823099c <t_connect+0x1dc>
   {
      so->so_error = EINPROGRESS;
 823097c:	e0bffb17 	ldw	r2,-20(fp)
 8230980:	00c01dc4 	movi	r3,119
 8230984:	10c00615 	stw	r3,24(r2)
      goto bad;
 8230988:	00000e06 	br	82309c4 <t_connect+0x204>
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
 823098c:	e0bffb17 	ldw	r2,-20(fp)
 8230990:	10800904 	addi	r2,r2,36
 8230994:	1009883a 	mov	r4,r2
 8230998:	82293d80 	call	82293d8 <tcp_sleep>
   }
#endif   /*  NB_CONNECT */
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
 823099c:	e0bffb17 	ldw	r2,-20(fp)
 82309a0:	1080088b 	ldhu	r2,34(r2)
 82309a4:	10bfffcc 	andi	r2,r2,65535
 82309a8:	1080010c 	andi	r2,r2,4
 82309ac:	10000526 	beq	r2,zero,82309c4 <t_connect+0x204>
 82309b0:	e0bffb17 	ldw	r2,-20(fp)
 82309b4:	10800617 	ldw	r2,24(r2)
 82309b8:	103ff426 	beq	r2,zero,823098c <t_connect+0x1cc>
 82309bc:	00000106 	br	82309c4 <t_connect+0x204>
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   if ((so->so_error = soconnect (so, nam)) != 0)
      goto bad;
 82309c0:	0001883a 	nop
   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
   }
bad:
   if (so->so_error != EINPROGRESS)
 82309c4:	e0bffb17 	ldw	r2,-20(fp)
 82309c8:	10800617 	ldw	r2,24(r2)
 82309cc:	10801de0 	cmpeqi	r2,r2,119
 82309d0:	1000071e 	bne	r2,zero,82309f0 <t_connect+0x230>
      so->so_state &= ~(SS_ISCONNECTING|SS_WASCONNECTING);
 82309d4:	e0bffb17 	ldw	r2,-20(fp)
 82309d8:	10c0088b 	ldhu	r3,34(r2)
 82309dc:	00b7fec4 	movi	r2,-8197
 82309e0:	1884703a 	and	r2,r3,r2
 82309e4:	1007883a 	mov	r3,r2
 82309e8:	e0bffb17 	ldw	r2,-20(fp)
 82309ec:	10c0088d 	sth	r3,34(r2)
   m_freem (nam);
 82309f0:	e13ffc17 	ldw	r4,-16(fp)
 82309f4:	822e4b80 	call	822e4b8 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 82309f8:	0009883a 	mov	r4,zero
 82309fc:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   if (so->so_error)
 8230a00:	e0bffb17 	ldw	r2,-20(fp)
 8230a04:	10800617 	ldw	r2,24(r2)
 8230a08:	10000226 	beq	r2,zero,8230a14 <t_connect+0x254>
   {
/*      printf("t_connect(): so_error = %d\n", so->so_error);*/
      return SOCKET_ERROR;
 8230a0c:	00bfffc4 	movi	r2,-1
 8230a10:	00000106 	br	8230a18 <t_connect+0x258>

   }
      return 0;
 8230a14:	0005883a 	mov	r2,zero
}
 8230a18:	e037883a 	mov	sp,fp
 8230a1c:	dfc00117 	ldw	ra,4(sp)
 8230a20:	df000017 	ldw	fp,0(sp)
 8230a24:	dec00204 	addi	sp,sp,8
 8230a28:	f800283a 	ret

08230a2c <t_getpeername>:
 * RETURNS: 
 */

int
t_getpeername(long s, struct sockaddr * addr, int * addrlen)
{
 8230a2c:	defffb04 	addi	sp,sp,-20
 8230a30:	dfc00415 	stw	ra,16(sp)
 8230a34:	df000315 	stw	fp,12(sp)
 8230a38:	df000304 	addi	fp,sp,12
 8230a3c:	e13ffd15 	stw	r4,-12(fp)
 8230a40:	e17ffe15 	stw	r5,-8(fp)
 8230a44:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_PEERADDR));
 8230a48:	01c00404 	movi	r7,16
 8230a4c:	e1bfff17 	ldw	r6,-4(fp)
 8230a50:	e17ffe17 	ldw	r5,-8(fp)
 8230a54:	e13ffd17 	ldw	r4,-12(fp)
 8230a58:	8230ab40 	call	8230ab4 <t_getname>
}
 8230a5c:	e037883a 	mov	sp,fp
 8230a60:	dfc00117 	ldw	ra,4(sp)
 8230a64:	df000017 	ldw	fp,0(sp)
 8230a68:	dec00204 	addi	sp,sp,8
 8230a6c:	f800283a 	ret

08230a70 <t_getsockname>:
 * RETURNS: 
 */

int 
t_getsockname(long s, struct sockaddr * addr, int * addrlen)
{
 8230a70:	defffb04 	addi	sp,sp,-20
 8230a74:	dfc00415 	stw	ra,16(sp)
 8230a78:	df000315 	stw	fp,12(sp)
 8230a7c:	df000304 	addi	fp,sp,12
 8230a80:	e13ffd15 	stw	r4,-12(fp)
 8230a84:	e17ffe15 	stw	r5,-8(fp)
 8230a88:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_SOCKADDR));
 8230a8c:	01c003c4 	movi	r7,15
 8230a90:	e1bfff17 	ldw	r6,-4(fp)
 8230a94:	e17ffe17 	ldw	r5,-8(fp)
 8230a98:	e13ffd17 	ldw	r4,-12(fp)
 8230a9c:	8230ab40 	call	8230ab4 <t_getname>
}
 8230aa0:	e037883a 	mov	sp,fp
 8230aa4:	dfc00117 	ldw	ra,4(sp)
 8230aa8:	df000017 	ldw	fp,0(sp)
 8230aac:	dec00204 	addi	sp,sp,8
 8230ab0:	f800283a 	ret

08230ab4 <t_getname>:
 * RETURNS: 
 */

static int
t_getname(long s, struct sockaddr * addr, int * addrlen, int opcode)
{
 8230ab4:	defff604 	addi	sp,sp,-40
 8230ab8:	dfc00915 	stw	ra,36(sp)
 8230abc:	df000815 	stw	fp,32(sp)
 8230ac0:	df000804 	addi	fp,sp,32
 8230ac4:	e13ffc15 	stw	r4,-16(fp)
 8230ac8:	e17ffd15 	stw	r5,-12(fp)
 8230acc:	e1bffe15 	stw	r6,-8(fp)
 8230ad0:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   struct mbuf *  m;
   int   err;

   so = LONG2SO(s);
 8230ad4:	e0bffc17 	ldw	r2,-16(fp)
 8230ad8:	10bff804 	addi	r2,r2,-32
 8230adc:	1085883a 	add	r2,r2,r2
 8230ae0:	1085883a 	add	r2,r2,r2
 8230ae4:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 8230ae8:	008209b4 	movhi	r2,2086
 8230aec:	10b96104 	addi	r2,r2,-6780
 8230af0:	e0bff815 	stw	r2,-32(fp)
 8230af4:	00000606 	br	8230b10 <t_getname+0x5c>
 8230af8:	e0fff817 	ldw	r3,-32(fp)
 8230afc:	e0bff917 	ldw	r2,-28(fp)
 8230b00:	18800626 	beq	r3,r2,8230b1c <t_getname+0x68>
 8230b04:	e0bff817 	ldw	r2,-32(fp)
 8230b08:	10800017 	ldw	r2,0(r2)
 8230b0c:	e0bff815 	stw	r2,-32(fp)
 8230b10:	e0bff817 	ldw	r2,-32(fp)
 8230b14:	103ff81e 	bne	r2,zero,8230af8 <t_getname+0x44>
 8230b18:	00000106 	br	8230b20 <t_getname+0x6c>
 8230b1c:	0001883a 	nop
 8230b20:	e0fff817 	ldw	r3,-32(fp)
 8230b24:	e0bff917 	ldw	r2,-28(fp)
 8230b28:	18800326 	beq	r3,r2,8230b38 <t_getname+0x84>
 8230b2c:	822d4140 	call	822d414 <dtrap>
 8230b30:	00bfffc4 	movi	r2,-1
 8230b34:	00005106 	br	8230c7c <t_getname+0x1c8>

   so->so_error = 0;
 8230b38:	e0bff917 	ldw	r2,-28(fp)
 8230b3c:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:get[sock|peer]name so %x\n", so));
   if((opcode == PRU_PEERADDR) && (so->so_state & SS_ISCONNECTED) == 0)
 8230b40:	e0bfff17 	ldw	r2,-4(fp)
 8230b44:	10800418 	cmpnei	r2,r2,16
 8230b48:	10000a1e 	bne	r2,zero,8230b74 <t_getname+0xc0>
 8230b4c:	e0bff917 	ldw	r2,-28(fp)
 8230b50:	1080088b 	ldhu	r2,34(r2)
 8230b54:	10bfffcc 	andi	r2,r2,65535
 8230b58:	1080008c 	andi	r2,r2,2
 8230b5c:	1000051e 	bne	r2,zero,8230b74 <t_getname+0xc0>
   {
      so->so_error = ENOTCONN;
 8230b60:	e0bff917 	ldw	r2,-28(fp)
 8230b64:	00c02004 	movi	r3,128
 8230b68:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230b6c:	00bfffc4 	movi	r2,-1
 8230b70:	00004206 	br	8230c7c <t_getname+0x1c8>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 8230b74:	0009883a 	mov	r4,zero
 8230b78:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 8230b7c:	01400404 	movi	r5,16
 8230b80:	01000244 	movi	r4,9
 8230b84:	822e2280 	call	822e228 <m_getnbuf>
 8230b88:	e0bffa15 	stw	r2,-24(fp)
   if (m == NULL) 
 8230b8c:	e0bffa17 	ldw	r2,-24(fp)
 8230b90:	1000071e 	bne	r2,zero,8230bb0 <t_getname+0xfc>
   {
      so->so_error = ENOMEM;
 8230b94:	e0bff917 	ldw	r2,-28(fp)
 8230b98:	00c00304 	movi	r3,12
 8230b9c:	10c00615 	stw	r3,24(r2)
      UNLOCK_NET_RESOURCE(NET_RESID);
 8230ba0:	0009883a 	mov	r4,zero
 8230ba4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 8230ba8:	00bfffc4 	movi	r2,-1
 8230bac:	00003306 	br	8230c7c <t_getname+0x1c8>
   }
   so->so_req = opcode;
 8230bb0:	e0bff917 	ldw	r2,-28(fp)
 8230bb4:	e0ffff17 	ldw	r3,-4(fp)
 8230bb8:	10c00715 	stw	r3,28(r2)
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
 8230bbc:	e0bff917 	ldw	r2,-28(fp)
 8230bc0:	10800217 	ldw	r2,8(r2)
 8230bc4:	10800317 	ldw	r2,12(r2)
 8230bc8:	e1bffa17 	ldw	r6,-24(fp)
 8230bcc:	000b883a 	mov	r5,zero
 8230bd0:	e13ff917 	ldw	r4,-28(fp)
 8230bd4:	103ee83a 	callr	r2
 8230bd8:	e0bffb15 	stw	r2,-20(fp)
 8230bdc:	e0bffb17 	ldw	r2,-20(fp)
 8230be0:	1000191e 	bne	r2,zero,8230c48 <t_getname+0x194>
      goto bad;

#ifdef IP_V4
   if(so->so_domain == AF_INET)
 8230be4:	e0bff917 	ldw	r2,-28(fp)
 8230be8:	10800517 	ldw	r2,20(r2)
 8230bec:	10800098 	cmpnei	r2,r2,2
 8230bf0:	1000161e 	bne	r2,zero,8230c4c <t_getname+0x198>
   {
      if(*addrlen < sizeof(struct sockaddr_in))
 8230bf4:	e0bffe17 	ldw	r2,-8(fp)
 8230bf8:	10800017 	ldw	r2,0(r2)
 8230bfc:	10800428 	cmpgeui	r2,r2,16
 8230c00:	1000071e 	bne	r2,zero,8230c20 <t_getname+0x16c>
      {
         dtrap();    /* programming error */
 8230c04:	822d4140 	call	822d414 <dtrap>
         m_freem(m);
 8230c08:	e13ffa17 	ldw	r4,-24(fp)
 8230c0c:	822e4b80 	call	822e4b8 <m_freem>
         UNLOCK_NET_RESOURCE(NET_RESID);
 8230c10:	0009883a 	mov	r4,zero
 8230c14:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         return EINVAL;
 8230c18:	00800584 	movi	r2,22
 8230c1c:	00001706 	br	8230c7c <t_getname+0x1c8>
      }
      MEMCPY(addr, m->m_data, sizeof(struct sockaddr_in));
 8230c20:	e0bffa17 	ldw	r2,-24(fp)
 8230c24:	10800317 	ldw	r2,12(r2)
 8230c28:	01800404 	movi	r6,16
 8230c2c:	100b883a 	mov	r5,r2
 8230c30:	e13ffd17 	ldw	r4,-12(fp)
 8230c34:	8202e8c0 	call	8202e8c <memcpy>
      *addrlen = sizeof(struct sockaddr_in);
 8230c38:	e0bffe17 	ldw	r2,-8(fp)
 8230c3c:	00c00404 	movi	r3,16
 8230c40:	10c00015 	stw	r3,0(r2)
 8230c44:	00000106 	br	8230c4c <t_getname+0x198>
      UNLOCK_NET_RESOURCE(NET_RESID);
      return SOCKET_ERROR;
   }
   so->so_req = opcode;
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
      goto bad;
 8230c48:	0001883a 	nop
   }
#endif   /* IP_V6 */


bad:
   m_freem(m);
 8230c4c:	e13ffa17 	ldw	r4,-24(fp)
 8230c50:	822e4b80 	call	822e4b8 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 8230c54:	0009883a 	mov	r4,zero
 8230c58:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   if (err) 
 8230c5c:	e0bffb17 	ldw	r2,-20(fp)
 8230c60:	10000526 	beq	r2,zero,8230c78 <t_getname+0x1c4>
   {
      so->so_error = err;
 8230c64:	e0bff917 	ldw	r2,-28(fp)
 8230c68:	e0fffb17 	ldw	r3,-20(fp)
 8230c6c:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8230c70:	00bfffc4 	movi	r2,-1
 8230c74:	00000106 	br	8230c7c <t_getname+0x1c8>
   }
   return 0;
 8230c78:	0005883a 	mov	r2,zero
}
 8230c7c:	e037883a 	mov	sp,fp
 8230c80:	dfc00117 	ldw	ra,4(sp)
 8230c84:	df000017 	ldw	fp,0(sp)
 8230c88:	dec00204 	addi	sp,sp,8
 8230c8c:	f800283a 	ret

08230c90 <t_setsockopt>:
t_setsockopt(long s,
   int   level,
   int   name,
   void * arg,
   int arglen)
{
 8230c90:	defff704 	addi	sp,sp,-36
 8230c94:	dfc00815 	stw	ra,32(sp)
 8230c98:	df000715 	stw	fp,28(sp)
 8230c9c:	df000704 	addi	fp,sp,28
 8230ca0:	e13ffc15 	stw	r4,-16(fp)
 8230ca4:	e17ffd15 	stw	r5,-12(fp)
 8230ca8:	e1bffe15 	stw	r6,-8(fp)
 8230cac:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 8230cb0:	e0bffc17 	ldw	r2,-16(fp)
 8230cb4:	10bff804 	addi	r2,r2,-32
 8230cb8:	1085883a 	add	r2,r2,r2
 8230cbc:	1085883a 	add	r2,r2,r2
 8230cc0:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 8230cc4:	008209b4 	movhi	r2,2086
 8230cc8:	10b96104 	addi	r2,r2,-6780
 8230ccc:	e0bff915 	stw	r2,-28(fp)
 8230cd0:	00000606 	br	8230cec <t_setsockopt+0x5c>
 8230cd4:	e0fff917 	ldw	r3,-28(fp)
 8230cd8:	e0bffa17 	ldw	r2,-24(fp)
 8230cdc:	18800626 	beq	r3,r2,8230cf8 <t_setsockopt+0x68>
 8230ce0:	e0bff917 	ldw	r2,-28(fp)
 8230ce4:	10800017 	ldw	r2,0(r2)
 8230ce8:	e0bff915 	stw	r2,-28(fp)
 8230cec:	e0bff917 	ldw	r2,-28(fp)
 8230cf0:	103ff81e 	bne	r2,zero,8230cd4 <t_setsockopt+0x44>
 8230cf4:	00000106 	br	8230cfc <t_setsockopt+0x6c>
 8230cf8:	0001883a 	nop
 8230cfc:	e0fff917 	ldw	r3,-28(fp)
 8230d00:	e0bffa17 	ldw	r2,-24(fp)
 8230d04:	18800326 	beq	r3,r2,8230d14 <t_setsockopt+0x84>
 8230d08:	822d4140 	call	822d414 <dtrap>
 8230d0c:	00bfffc4 	movi	r2,-1
 8230d10:	00004a06 	br	8230e3c <t_setsockopt+0x1ac>
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 8230d14:	0009883a 	mov	r4,zero
 8230d18:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>

   so->so_error = 0;
 8230d1c:	e0bffa17 	ldw	r2,-24(fp)
 8230d20:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
    ("INET: setsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 8230d24:	e0bffd17 	ldw	r2,-12(fp)
 8230d28:	10800060 	cmpeqi	r2,r2,1
 8230d2c:	10000e1e 	bne	r2,zero,8230d68 <t_setsockopt+0xd8>
   {
      if ((err = sosetopt (so, name, arg)) != 0) 
 8230d30:	e1bfff17 	ldw	r6,-4(fp)
 8230d34:	e17ffe17 	ldw	r5,-8(fp)
 8230d38:	e13ffa17 	ldw	r4,-24(fp)
 8230d3c:	8232fc40 	call	8232fc4 <sosetopt>
 8230d40:	e0bffb15 	stw	r2,-20(fp)
 8230d44:	e0bffb17 	ldw	r2,-20(fp)
 8230d48:	10003926 	beq	r2,zero,8230e30 <t_setsockopt+0x1a0>
      {
         so->so_error = err;
 8230d4c:	e0bffa17 	ldw	r2,-24(fp)
 8230d50:	e0fffb17 	ldw	r3,-20(fp)
 8230d54:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230d58:	0009883a 	mov	r4,zero
 8230d5c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230d60:	00bfffc4 	movi	r2,-1
 8230d64:	00003506 	br	8230e3c <t_setsockopt+0x1ac>
   {
   /* level 1 options are for the IP packet level.
    * the info is carried in the socket CB, then put 
    * into the PACKET.
    */
      if (!so->so_optsPack)
 8230d68:	e0bffa17 	ldw	r2,-24(fp)
 8230d6c:	10801f17 	ldw	r2,124(r2)
 8230d70:	10000f1e 	bne	r2,zero,8230db0 <t_setsockopt+0x120>
      {
         so->so_optsPack = (struct ip_socopts *) SOCOPT_ALLOC (sizeof(struct ip_socopts *));
 8230d74:	01000104 	movi	r4,4
 8230d78:	822dfec0 	call	822dfec <npalloc>
 8230d7c:	1007883a 	mov	r3,r2
 8230d80:	e0bffa17 	ldw	r2,-24(fp)
 8230d84:	10c01f15 	stw	r3,124(r2)
         if (!so->so_optsPack) 
 8230d88:	e0bffa17 	ldw	r2,-24(fp)
 8230d8c:	10801f17 	ldw	r2,124(r2)
 8230d90:	1000071e 	bne	r2,zero,8230db0 <t_setsockopt+0x120>
         {
            so->so_error = ENOMEM;
 8230d94:	e0bffa17 	ldw	r2,-24(fp)
 8230d98:	00c00304 	movi	r3,12
 8230d9c:	10c00615 	stw	r3,24(r2)
            UNLOCK_NET_RESOURCE (NET_RESID);
 8230da0:	0009883a 	mov	r4,zero
 8230da4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
            return SOCKET_ERROR;
 8230da8:	00bfffc4 	movi	r2,-1
 8230dac:	00002306 	br	8230e3c <t_setsockopt+0x1ac>
         }
      }
      
      if (name == IP_TTL_OPT)
 8230db0:	e0bffe17 	ldw	r2,-8(fp)
 8230db4:	10800118 	cmpnei	r2,r2,4
 8230db8:	1000061e 	bne	r2,zero,8230dd4 <t_setsockopt+0x144>
         so->so_optsPack->ip_ttl = (u_char)(*(int *)arg);
 8230dbc:	e0bffa17 	ldw	r2,-24(fp)
 8230dc0:	10801f17 	ldw	r2,124(r2)
 8230dc4:	e0ffff17 	ldw	r3,-4(fp)
 8230dc8:	18c00017 	ldw	r3,0(r3)
 8230dcc:	10c00045 	stb	r3,1(r2)
 8230dd0:	00001706 	br	8230e30 <t_setsockopt+0x1a0>
      else
      if (name == IP_TOS)
 8230dd4:	e0bffe17 	ldw	r2,-8(fp)
 8230dd8:	108000d8 	cmpnei	r2,r2,3
 8230ddc:	1000061e 	bne	r2,zero,8230df8 <t_setsockopt+0x168>
         so->so_optsPack->ip_tos = (u_char)(*(int *)arg);
 8230de0:	e0bffa17 	ldw	r2,-24(fp)
 8230de4:	10801f17 	ldw	r2,124(r2)
 8230de8:	e0ffff17 	ldw	r3,-4(fp)
 8230dec:	18c00017 	ldw	r3,0(r3)
 8230df0:	10c00005 	stb	r3,0(r2)
 8230df4:	00000e06 	br	8230e30 <t_setsockopt+0x1a0>
	   else
	   if (name == IP_SCOPEID)
 8230df8:	e0bffe17 	ldw	r2,-8(fp)
 8230dfc:	10800398 	cmpnei	r2,r2,14
 8230e00:	1000071e 	bne	r2,zero,8230e20 <t_setsockopt+0x190>
            so->so_optsPack->ip_scopeid = (u_char)(*(u_int *)arg);
 8230e04:	e0bffa17 	ldw	r2,-24(fp)
 8230e08:	10801f17 	ldw	r2,124(r2)
 8230e0c:	e0ffff17 	ldw	r3,-4(fp)
 8230e10:	18c00017 	ldw	r3,0(r3)
 8230e14:	18c03fcc 	andi	r3,r3,255
 8230e18:	10c00115 	stw	r3,4(r2)
 8230e1c:	00000406 	br	8230e30 <t_setsockopt+0x1a0>
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230e20:	0009883a 	mov	r4,zero
 8230e24:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230e28:	00bfffc4 	movi	r2,-1
 8230e2c:	00000306 	br	8230e3c <t_setsockopt+0x1ac>
      }   
   }

   UNLOCK_NET_RESOURCE (NET_RESID);
 8230e30:	0009883a 	mov	r4,zero
 8230e34:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   return 0;
 8230e38:	0005883a 	mov	r2,zero
}
 8230e3c:	e037883a 	mov	sp,fp
 8230e40:	dfc00117 	ldw	ra,4(sp)
 8230e44:	df000017 	ldw	fp,0(sp)
 8230e48:	dec00204 	addi	sp,sp,8
 8230e4c:	f800283a 	ret

08230e50 <t_getsockopt>:
   int   level,
   int   name,
   void *   arg,
   int   arglen)

{
 8230e50:	defff704 	addi	sp,sp,-36
 8230e54:	dfc00815 	stw	ra,32(sp)
 8230e58:	df000715 	stw	fp,28(sp)
 8230e5c:	df000704 	addi	fp,sp,28
 8230e60:	e13ffc15 	stw	r4,-16(fp)
 8230e64:	e17ffd15 	stw	r5,-12(fp)
 8230e68:	e1bffe15 	stw	r6,-8(fp)
 8230e6c:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 8230e70:	e0bffc17 	ldw	r2,-16(fp)
 8230e74:	10bff804 	addi	r2,r2,-32
 8230e78:	1085883a 	add	r2,r2,r2
 8230e7c:	1085883a 	add	r2,r2,r2
 8230e80:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 8230e84:	008209b4 	movhi	r2,2086
 8230e88:	10b96104 	addi	r2,r2,-6780
 8230e8c:	e0bff915 	stw	r2,-28(fp)
 8230e90:	00000606 	br	8230eac <t_getsockopt+0x5c>
 8230e94:	e0fff917 	ldw	r3,-28(fp)
 8230e98:	e0bffa17 	ldw	r2,-24(fp)
 8230e9c:	18800626 	beq	r3,r2,8230eb8 <t_getsockopt+0x68>
 8230ea0:	e0bff917 	ldw	r2,-28(fp)
 8230ea4:	10800017 	ldw	r2,0(r2)
 8230ea8:	e0bff915 	stw	r2,-28(fp)
 8230eac:	e0bff917 	ldw	r2,-28(fp)
 8230eb0:	103ff81e 	bne	r2,zero,8230e94 <t_getsockopt+0x44>
 8230eb4:	00000106 	br	8230ebc <t_getsockopt+0x6c>
 8230eb8:	0001883a 	nop
 8230ebc:	e0fff917 	ldw	r3,-28(fp)
 8230ec0:	e0bffa17 	ldw	r2,-24(fp)
 8230ec4:	18800326 	beq	r3,r2,8230ed4 <t_getsockopt+0x84>
 8230ec8:	822d4140 	call	822d414 <dtrap>
 8230ecc:	00bfffc4 	movi	r2,-1
 8230ed0:	00003d06 	br	8230fc8 <t_getsockopt+0x178>
   USE_ARG(level);
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 8230ed4:	0009883a 	mov	r4,zero
 8230ed8:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   INET_TRACE (INETM_SOCKET,
    ("INET: getsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 8230edc:	e0bffd17 	ldw	r2,-12(fp)
 8230ee0:	10800060 	cmpeqi	r2,r2,1
 8230ee4:	10000e1e 	bne	r2,zero,8230f20 <t_getsockopt+0xd0>
   {
      if ((err = sogetopt (so, name, arg)) != 0) 
 8230ee8:	e1bfff17 	ldw	r6,-4(fp)
 8230eec:	e17ffe17 	ldw	r5,-8(fp)
 8230ef0:	e13ffa17 	ldw	r4,-24(fp)
 8230ef4:	82333f40 	call	82333f4 <sogetopt>
 8230ef8:	e0bffb15 	stw	r2,-20(fp)
 8230efc:	e0bffb17 	ldw	r2,-20(fp)
 8230f00:	10002c26 	beq	r2,zero,8230fb4 <t_getsockopt+0x164>
      {
         so->so_error = err;
 8230f04:	e0bffa17 	ldw	r2,-24(fp)
 8230f08:	e0fffb17 	ldw	r3,-20(fp)
 8230f0c:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230f10:	0009883a 	mov	r4,zero
 8230f14:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230f18:	00bfffc4 	movi	r2,-1
 8230f1c:	00002a06 	br	8230fc8 <t_getsockopt+0x178>
   {
      /* level 1 options are for the IP packet level.
       * the info is carried in the socket CB, then put 
       * into the PACKET.
       */
      if (name == IP_TTL_OPT)
 8230f20:	e0bffe17 	ldw	r2,-8(fp)
 8230f24:	10800118 	cmpnei	r2,r2,4
 8230f28:	10000e1e 	bne	r2,zero,8230f64 <t_getsockopt+0x114>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TTL;
 8230f2c:	e0bffa17 	ldw	r2,-24(fp)
 8230f30:	10801f17 	ldw	r2,124(r2)
 8230f34:	1000041e 	bne	r2,zero,8230f48 <t_getsockopt+0xf8>
 8230f38:	e0bfff17 	ldw	r2,-4(fp)
 8230f3c:	00c01004 	movi	r3,64
 8230f40:	10c00015 	stw	r3,0(r2)
 8230f44:	00001b06 	br	8230fb4 <t_getsockopt+0x164>
         else *(int *)arg = (int)so->so_optsPack->ip_ttl;
 8230f48:	e0bffa17 	ldw	r2,-24(fp)
 8230f4c:	10801f17 	ldw	r2,124(r2)
 8230f50:	10800043 	ldbu	r2,1(r2)
 8230f54:	10c03fcc 	andi	r3,r2,255
 8230f58:	e0bfff17 	ldw	r2,-4(fp)
 8230f5c:	10c00015 	stw	r3,0(r2)
 8230f60:	00001406 	br	8230fb4 <t_getsockopt+0x164>
      }
      else if (name == IP_TOS)
 8230f64:	e0bffe17 	ldw	r2,-8(fp)
 8230f68:	108000d8 	cmpnei	r2,r2,3
 8230f6c:	10000d1e 	bne	r2,zero,8230fa4 <t_getsockopt+0x154>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TOS_DEFVAL;
 8230f70:	e0bffa17 	ldw	r2,-24(fp)
 8230f74:	10801f17 	ldw	r2,124(r2)
 8230f78:	1000031e 	bne	r2,zero,8230f88 <t_getsockopt+0x138>
 8230f7c:	e0bfff17 	ldw	r2,-4(fp)
 8230f80:	10000015 	stw	zero,0(r2)
 8230f84:	00000b06 	br	8230fb4 <t_getsockopt+0x164>
         else *(int *)arg = (int)so->so_optsPack->ip_tos;
 8230f88:	e0bffa17 	ldw	r2,-24(fp)
 8230f8c:	10801f17 	ldw	r2,124(r2)
 8230f90:	10800003 	ldbu	r2,0(r2)
 8230f94:	10c03fcc 	andi	r3,r2,255
 8230f98:	e0bfff17 	ldw	r2,-4(fp)
 8230f9c:	10c00015 	stw	r3,0(r2)
 8230fa0:	00000406 	br	8230fb4 <t_getsockopt+0x164>
      }
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 8230fa4:	0009883a 	mov	r4,zero
 8230fa8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 8230fac:	00bfffc4 	movi	r2,-1
 8230fb0:	00000506 	br	8230fc8 <t_getsockopt+0x178>
      }
   }   
   so->so_error = 0;
 8230fb4:	e0bffa17 	ldw	r2,-24(fp)
 8230fb8:	10000615 	stw	zero,24(r2)

   UNLOCK_NET_RESOURCE (NET_RESID);
 8230fbc:	0009883a 	mov	r4,zero
 8230fc0:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   return 0;
 8230fc4:	0005883a 	mov	r2,zero
}
 8230fc8:	e037883a 	mov	sp,fp
 8230fcc:	dfc00117 	ldw	ra,4(sp)
 8230fd0:	df000017 	ldw	fp,0(sp)
 8230fd4:	dec00204 	addi	sp,sp,8
 8230fd8:	f800283a 	ret

08230fdc <t_recv>:
int
t_recv (long s, 
   char *   buf,
   int   len, 
   int   flag)
{
 8230fdc:	defff604 	addi	sp,sp,-40
 8230fe0:	dfc00915 	stw	ra,36(sp)
 8230fe4:	df000815 	stw	fp,32(sp)
 8230fe8:	df000804 	addi	fp,sp,32
 8230fec:	e13ffc15 	stw	r4,-16(fp)
 8230ff0:	e17ffd15 	stw	r5,-12(fp)
 8230ff4:	e1bffe15 	stw	r6,-8(fp)
 8230ff8:	e1ffff15 	stw	r7,-4(fp)
#ifdef SOCKDEBUG
   char logbuf[10];
#endif
   struct socket *   so;
   int   err;
   int   sendlen = len;
 8230ffc:	e0bffe17 	ldw	r2,-8(fp)
 8231000:	e0bff915 	stw	r2,-28(fp)

   so = LONG2SO(s);
 8231004:	e0bffc17 	ldw	r2,-16(fp)
 8231008:	10bff804 	addi	r2,r2,-32
 823100c:	1085883a 	add	r2,r2,r2
 8231010:	1085883a 	add	r2,r2,r2
 8231014:	e0bffa15 	stw	r2,-24(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 8231018:	e0bffa17 	ldw	r2,-24(fp)
 823101c:	1080088b 	ldhu	r2,34(r2)
 8231020:	10bfffcc 	andi	r2,r2,65535
 8231024:	1080038c 	andi	r2,r2,14
 8231028:	108000a0 	cmpeqi	r2,r2,2
 823102c:	1000051e 	bne	r2,zero,8231044 <t_recv+0x68>
   {
      so->so_error = EPIPE;
 8231030:	e0bffa17 	ldw	r2,-24(fp)
 8231034:	00c00804 	movi	r3,32
 8231038:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 823103c:	00bfffc4 	movi	r2,-1
 8231040:	00001906 	br	82310a8 <t_recv+0xcc>
   }
   so->so_error = 0;
 8231044:	e0bffa17 	ldw	r2,-24(fp)
 8231048:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 823104c:	0009883a 	mov	r4,zero
 8231050:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   IN_PROFILER(PF_TCP, PF_ENTRY);        /* measure time in TCP */
   INET_TRACE (INETM_IO, ("INET:recv: so %x, len %d\n", so, len));
   err = soreceive(so, NULL, buf, &len, flag);
 8231054:	e0fffe04 	addi	r3,fp,-8
 8231058:	e0bfff17 	ldw	r2,-4(fp)
 823105c:	d8800015 	stw	r2,0(sp)
 8231060:	180f883a 	mov	r7,r3
 8231064:	e1bffd17 	ldw	r6,-12(fp)
 8231068:	000b883a 	mov	r5,zero
 823106c:	e13ffa17 	ldw	r4,-24(fp)
 8231070:	82326e40 	call	82326e4 <soreceive>
 8231074:	e0bffb15 	stw	r2,-20(fp)
   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   UNLOCK_NET_RESOURCE(NET_RESID);
 8231078:	0009883a 	mov	r4,zero
 823107c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   if(err)
 8231080:	e0bffb17 	ldw	r2,-20(fp)
 8231084:	10000526 	beq	r2,zero,823109c <t_recv+0xc0>
   {
      so->so_error = err;
 8231088:	e0bffa17 	ldw	r2,-24(fp)
 823108c:	e0fffb17 	ldw	r3,-20(fp)
 8231090:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 8231094:	00bfffc4 	movi	r2,-1
 8231098:	00000306 	br	82310a8 <t_recv+0xcc>
   }

   /* return bytes we sent - the amount we wanted to send minus
    * the amount left in the buffer.
    */
   return (sendlen - len);
 823109c:	e0bffe17 	ldw	r2,-8(fp)
 82310a0:	e0fff917 	ldw	r3,-28(fp)
 82310a4:	1885c83a 	sub	r2,r3,r2
}
 82310a8:	e037883a 	mov	sp,fp
 82310ac:	dfc00117 	ldw	ra,4(sp)
 82310b0:	df000017 	ldw	fp,0(sp)
 82310b4:	dec00204 	addi	sp,sp,8
 82310b8:	f800283a 	ret

082310bc <t_recvfrom>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * from,
   int * fromlen)
{
 82310bc:	defff404 	addi	sp,sp,-48
 82310c0:	dfc00b15 	stw	ra,44(sp)
 82310c4:	df000a15 	stw	fp,40(sp)
 82310c8:	df000a04 	addi	fp,sp,40
 82310cc:	e13ffc15 	stw	r4,-16(fp)
 82310d0:	e17ffd15 	stw	r5,-12(fp)
 82310d4:	e1bffe15 	stw	r6,-8(fp)
 82310d8:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   struct mbuf *     sender = NULL;
 82310dc:	e03ffb15 	stw	zero,-20(fp)
   int   err;
   int   sendlen = len;
 82310e0:	e0bffe17 	ldw	r2,-8(fp)
 82310e4:	e0bff815 	stw	r2,-32(fp)

   so = LONG2SO(s);
 82310e8:	e0bffc17 	ldw	r2,-16(fp)
 82310ec:	10bff804 	addi	r2,r2,-32
 82310f0:	1085883a 	add	r2,r2,r2
 82310f4:	1085883a 	add	r2,r2,r2
 82310f8:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 82310fc:	008209b4 	movhi	r2,2086
 8231100:	10b96104 	addi	r2,r2,-6780
 8231104:	e0bff715 	stw	r2,-36(fp)
 8231108:	00000606 	br	8231124 <t_recvfrom+0x68>
 823110c:	e0fff717 	ldw	r3,-36(fp)
 8231110:	e0bff917 	ldw	r2,-28(fp)
 8231114:	18800626 	beq	r3,r2,8231130 <t_recvfrom+0x74>
 8231118:	e0bff717 	ldw	r2,-36(fp)
 823111c:	10800017 	ldw	r2,0(r2)
 8231120:	e0bff715 	stw	r2,-36(fp)
 8231124:	e0bff717 	ldw	r2,-36(fp)
 8231128:	103ff81e 	bne	r2,zero,823110c <t_recvfrom+0x50>
 823112c:	00000106 	br	8231134 <t_recvfrom+0x78>
 8231130:	0001883a 	nop
 8231134:	e0fff717 	ldw	r3,-36(fp)
 8231138:	e0bff917 	ldw	r2,-28(fp)
 823113c:	18800326 	beq	r3,r2,823114c <t_recvfrom+0x90>
 8231140:	822d4140 	call	822d414 <dtrap>
 8231144:	00bfffc4 	movi	r2,-1
 8231148:	00002706 	br	82311e8 <t_recvfrom+0x12c>
   so->so_error = 0;
 823114c:	e0bff917 	ldw	r2,-28(fp)
 8231150:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 8231154:	0009883a 	mov	r4,zero
 8231158:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>

   err = soreceive(so, &sender, buf, &len, flags);
 823115c:	e13ffe04 	addi	r4,fp,-8
 8231160:	e0fffb04 	addi	r3,fp,-20
 8231164:	e0bfff17 	ldw	r2,-4(fp)
 8231168:	d8800015 	stw	r2,0(sp)
 823116c:	200f883a 	mov	r7,r4
 8231170:	e1bffd17 	ldw	r6,-12(fp)
 8231174:	180b883a 	mov	r5,r3
 8231178:	e13ff917 	ldw	r4,-28(fp)
 823117c:	82326e40 	call	82326e4 <soreceive>
 8231180:	e0bffa15 	stw	r2,-24(fp)

   /* copy sender info from mbuf to sockaddr */
   if (sender)
 8231184:	e0bffb17 	ldw	r2,-20(fp)
 8231188:	10000b26 	beq	r2,zero,82311b8 <t_recvfrom+0xfc>
   {
      MEMCPY(from, (mtod(sender, struct sockaddr *)), *fromlen );
 823118c:	e0bffb17 	ldw	r2,-20(fp)
 8231190:	10c00317 	ldw	r3,12(r2)
 8231194:	e0800317 	ldw	r2,12(fp)
 8231198:	10800017 	ldw	r2,0(r2)
 823119c:	100d883a 	mov	r6,r2
 82311a0:	180b883a 	mov	r5,r3
 82311a4:	e1000217 	ldw	r4,8(fp)
 82311a8:	8202e8c0 	call	8202e8c <memcpy>
      m_freem (sender);
 82311ac:	e0bffb17 	ldw	r2,-20(fp)
 82311b0:	1009883a 	mov	r4,r2
 82311b4:	822e4b80 	call	822e4b8 <m_freem>
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 82311b8:	0009883a 	mov	r4,zero
 82311bc:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   if(err)
 82311c0:	e0bffa17 	ldw	r2,-24(fp)
 82311c4:	10000526 	beq	r2,zero,82311dc <t_recvfrom+0x120>
   {
      so->so_error = err;
 82311c8:	e0bff917 	ldw	r2,-28(fp)
 82311cc:	e0fffa17 	ldw	r3,-24(fp)
 82311d0:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82311d4:	00bfffc4 	movi	r2,-1
 82311d8:	00000306 	br	82311e8 <t_recvfrom+0x12c>
   }

   /* OK return: amount of data actually sent */
   return (sendlen - len);
 82311dc:	e0bffe17 	ldw	r2,-8(fp)
 82311e0:	e0fff817 	ldw	r3,-32(fp)
 82311e4:	1885c83a 	sub	r2,r3,r2
}
 82311e8:	e037883a 	mov	sp,fp
 82311ec:	dfc00117 	ldw	ra,4(sp)
 82311f0:	df000017 	ldw	fp,0(sp)
 82311f4:	dec00204 	addi	sp,sp,8
 82311f8:	f800283a 	ret

082311fc <t_sendto>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * to,
   int   tolen)
{
 82311fc:	defff404 	addi	sp,sp,-48
 8231200:	dfc00b15 	stw	ra,44(sp)
 8231204:	df000a15 	stw	fp,40(sp)
 8231208:	df000a04 	addi	fp,sp,40
 823120c:	e13ffc15 	stw	r4,-16(fp)
 8231210:	e17ffd15 	stw	r5,-12(fp)
 8231214:	e1bffe15 	stw	r6,-8(fp)
 8231218:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   sendlen;
   int   err;
   struct mbuf *     name;

   so = LONG2SO(s);
 823121c:	e0bffc17 	ldw	r2,-16(fp)
 8231220:	10bff804 	addi	r2,r2,-32
 8231224:	1085883a 	add	r2,r2,r2
 8231228:	1085883a 	add	r2,r2,r2
 823122c:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 8231230:	008209b4 	movhi	r2,2086
 8231234:	10b96104 	addi	r2,r2,-6780
 8231238:	e0bff815 	stw	r2,-32(fp)
 823123c:	00000606 	br	8231258 <t_sendto+0x5c>
 8231240:	e0fff817 	ldw	r3,-32(fp)
 8231244:	e0bff917 	ldw	r2,-28(fp)
 8231248:	18800626 	beq	r3,r2,8231264 <t_sendto+0x68>
 823124c:	e0bff817 	ldw	r2,-32(fp)
 8231250:	10800017 	ldw	r2,0(r2)
 8231254:	e0bff815 	stw	r2,-32(fp)
 8231258:	e0bff817 	ldw	r2,-32(fp)
 823125c:	103ff81e 	bne	r2,zero,8231240 <t_sendto+0x44>
 8231260:	00000106 	br	8231268 <t_sendto+0x6c>
 8231264:	0001883a 	nop
 8231268:	e0fff817 	ldw	r3,-32(fp)
 823126c:	e0bff917 	ldw	r2,-28(fp)
 8231270:	18800326 	beq	r3,r2,8231280 <t_sendto+0x84>
 8231274:	822d4140 	call	822d414 <dtrap>
 8231278:	00bfffc4 	movi	r2,-1
 823127c:	00005706 	br	82313dc <t_sendto+0x1e0>
   so->so_error = 0;
 8231280:	e0bff917 	ldw	r2,-28(fp)
 8231284:	10000615 	stw	zero,24(r2)

   switch (so->so_type)
 8231288:	e0bff917 	ldw	r2,-28(fp)
 823128c:	10800983 	ldbu	r2,38(r2)
 8231290:	10803fcc 	andi	r2,r2,255
 8231294:	1080201c 	xori	r2,r2,128
 8231298:	10bfe004 	addi	r2,r2,-128
 823129c:	10c000a0 	cmpeqi	r3,r2,2
 82312a0:	18000a1e 	bne	r3,zero,82312cc <t_sendto+0xd0>
 82312a4:	10c000e0 	cmpeqi	r3,r2,3
 82312a8:	18000b1e 	bne	r3,zero,82312d8 <t_sendto+0xdc>
 82312ac:	10800060 	cmpeqi	r2,r2,1
 82312b0:	10001026 	beq	r2,zero,82312f4 <t_sendto+0xf8>
   {
   case SOCK_STREAM:
      /* this is a stream socket, so pass this request through
       * t_send() for its large-send support.
       */
      return t_send(s, buf, len, flags);
 82312b4:	e1ffff17 	ldw	r7,-4(fp)
 82312b8:	e1bffe17 	ldw	r6,-8(fp)
 82312bc:	e17ffd17 	ldw	r5,-12(fp)
 82312c0:	e13ffc17 	ldw	r4,-16(fp)
 82312c4:	82313f00 	call	82313f0 <t_send>
 82312c8:	00004406 	br	82313dc <t_sendto+0x1e0>
      /*NOTREACHED*/
   case SOCK_DGRAM:
      /* datagram (UDP) socket -- prepare to check length */
      sendlen = udp_maxalloc();
 82312cc:	82452f40 	call	82452f4 <udp_maxalloc>
 82312d0:	e0bffb15 	stw	r2,-20(fp)
      break;
 82312d4:	00000d06 	br	823130c <t_sendto+0x110>
#ifdef IP_RAW
   case SOCK_RAW:
      /* raw socket -- prepare to check length */
      sendlen = ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 82312d8:	e0bff917 	ldw	r2,-28(fp)
 82312dc:	10800417 	ldw	r2,16(r2)
 82312e0:	1088000c 	andi	r2,r2,8192
 82312e4:	1009883a 	mov	r4,r2
 82312e8:	8243fe40 	call	8243fe4 <ip_raw_maxalloc>
 82312ec:	e0bffb15 	stw	r2,-20(fp)
      break;
 82312f0:	00000606 	br	823130c <t_sendto+0x110>
#endif /* IP_RAW */
   default:
      /* socket has unknown type */
      dtrap();
 82312f4:	822d4140 	call	822d414 <dtrap>
      so->so_error = EFAULT;
 82312f8:	e0bff917 	ldw	r2,-28(fp)
 82312fc:	00c00384 	movi	r3,14
 8231300:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8231304:	00bfffc4 	movi	r2,-1
 8231308:	00003406 	br	82313dc <t_sendto+0x1e0>
   /* fall through for non-stream sockets: SOCK_DGRAM (UDP) and
    * SOCK_RAW (raw IP)
    */

   /* check length against underlying stack's maximum */
   if (len > sendlen)
 823130c:	e0fffb17 	ldw	r3,-20(fp)
 8231310:	e0bffe17 	ldw	r2,-8(fp)
 8231314:	1880050e 	bge	r3,r2,823132c <t_sendto+0x130>
   {
      so->so_error = EMSGSIZE;
 8231318:	e0bff917 	ldw	r2,-28(fp)
 823131c:	00c01e84 	movi	r3,122
 8231320:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 8231324:	00bfffc4 	movi	r2,-1
 8231328:	00002c06 	br	82313dc <t_sendto+0x1e0>
   /* if a sockaddr was passed, wrap it in an mbuf and pas it into the
    * bowels of the BSD code; else assume this is a bound UDP socket
    * and this call came from t_send() below.
    */

   if (to)  /* sockaddr was passed */
 823132c:	e0800217 	ldw	r2,8(fp)
 8231330:	10000c26 	beq	r2,zero,8231364 <t_sendto+0x168>
   {
      name = sockargs(to, tolen, MT_SONAME);
 8231334:	01800244 	movi	r6,9
 8231338:	e1400317 	ldw	r5,12(fp)
 823133c:	e1000217 	ldw	r4,8(fp)
 8231340:	82317900 	call	8231790 <sockargs>
 8231344:	e0bff715 	stw	r2,-36(fp)
      if(name == NULL)
 8231348:	e0bff717 	ldw	r2,-36(fp)
 823134c:	1000061e 	bne	r2,zero,8231368 <t_sendto+0x16c>
      {
         so->so_error = ENOMEM;
 8231350:	e0bff917 	ldw	r2,-28(fp)
 8231354:	00c00304 	movi	r3,12
 8231358:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 823135c:	00bfffc4 	movi	r2,-1
 8231360:	00001e06 	br	82313dc <t_sendto+0x1e0>
      }
   }
   else     /* hope user called bind() first... */
      name = NULL;
 8231364:	e03ff715 	stw	zero,-36(fp)
   
   sendlen = len;
 8231368:	e0bffe17 	ldw	r2,-8(fp)
 823136c:	e0bffb15 	stw	r2,-20(fp)

   LOCK_NET_RESOURCE(NET_RESID);
 8231370:	0009883a 	mov	r4,zero
 8231374:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>

   err = sosend (so, name, buf, &sendlen, flags);
 8231378:	e0fffb04 	addi	r3,fp,-20
 823137c:	e0bfff17 	ldw	r2,-4(fp)
 8231380:	d8800015 	stw	r2,0(sp)
 8231384:	180f883a 	mov	r7,r3
 8231388:	e1bffd17 	ldw	r6,-12(fp)
 823138c:	e17ff717 	ldw	r5,-36(fp)
 8231390:	e13ff917 	ldw	r4,-28(fp)
 8231394:	823218c0 	call	823218c <sosend>
 8231398:	e0bffa15 	stw	r2,-24(fp)

   if (name)
 823139c:	e0bff717 	ldw	r2,-36(fp)
 82313a0:	10000226 	beq	r2,zero,82313ac <t_sendto+0x1b0>
      m_freem(name);
 82313a4:	e13ff717 	ldw	r4,-36(fp)
 82313a8:	822e4b80 	call	822e4b8 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 82313ac:	0009883a 	mov	r4,zero
 82313b0:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 82313b4:	e0bffa17 	ldw	r2,-24(fp)
 82313b8:	10000526 	beq	r2,zero,82313d0 <t_sendto+0x1d4>
   {
      so->so_error = err;
 82313bc:	e0bff917 	ldw	r2,-28(fp)
 82313c0:	e0fffa17 	ldw	r3,-24(fp)
 82313c4:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82313c8:	00bfffc4 	movi	r2,-1
 82313cc:	00000306 	br	82313dc <t_sendto+0x1e0>
   }

   return (len - sendlen);
 82313d0:	e0bffb17 	ldw	r2,-20(fp)
 82313d4:	e0fffe17 	ldw	r3,-8(fp)
 82313d8:	1885c83a 	sub	r2,r3,r2
}
 82313dc:	e037883a 	mov	sp,fp
 82313e0:	dfc00117 	ldw	ra,4(sp)
 82313e4:	df000017 	ldw	fp,0(sp)
 82313e8:	dec00204 	addi	sp,sp,8
 82313ec:	f800283a 	ret

082313f0 <t_send>:
int
t_send(long s, 
   char *   buf,
   int      len, 
   int      flags)
{
 82313f0:	defff104 	addi	sp,sp,-60
 82313f4:	dfc00e15 	stw	ra,56(sp)
 82313f8:	df000d15 	stw	fp,52(sp)
 82313fc:	df000d04 	addi	fp,sp,52
 8231400:	e13ffc15 	stw	r4,-16(fp)
 8231404:	e17ffd15 	stw	r5,-12(fp)
 8231408:	e1bffe15 	stw	r6,-8(fp)
 823140c:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   e;       /* error holder */
   int   total_sent  =  0;
 8231410:	e03ff515 	stw	zero,-44(fp)
   int   maxpkt;
   int   sendlen;
   int   sent;

   so = LONG2SO(s);
 8231414:	e0bffc17 	ldw	r2,-16(fp)
 8231418:	10bff804 	addi	r2,r2,-32
 823141c:	1085883a 	add	r2,r2,r2
 8231420:	1085883a 	add	r2,r2,r2
 8231424:	e0bff715 	stw	r2,-36(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 8231428:	e0bff717 	ldw	r2,-36(fp)
 823142c:	1080088b 	ldhu	r2,34(r2)
 8231430:	10bfffcc 	andi	r2,r2,65535
 8231434:	1080038c 	andi	r2,r2,14
 8231438:	108000a0 	cmpeqi	r2,r2,2
 823143c:	1000051e 	bne	r2,zero,8231454 <t_send+0x64>
   {
      so->so_error = EPIPE;
 8231440:	e0bff717 	ldw	r2,-36(fp)
 8231444:	00c00804 	movi	r3,32
 8231448:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 823144c:	00bfffc4 	movi	r2,-1
 8231450:	00006306 	br	82315e0 <t_send+0x1f0>
   }
   so->so_error = 0;
 8231454:	e0bff717 	ldw	r2,-36(fp)
 8231458:	10000615 	stw	zero,24(r2)

   /* If this is not a stream socket, assume it is bound and pass to
    * t_sendto() with a null sockaddr
    */
   if (so->so_type != SOCK_STREAM)
 823145c:	e0bff717 	ldw	r2,-36(fp)
 8231460:	10800983 	ldbu	r2,38(r2)
 8231464:	10803fcc 	andi	r2,r2,255
 8231468:	1080201c 	xori	r2,r2,128
 823146c:	10bfe004 	addi	r2,r2,-128
 8231470:	10800060 	cmpeqi	r2,r2,1
 8231474:	1000081e 	bne	r2,zero,8231498 <t_send+0xa8>
      return(t_sendto(s, buf, len, flags, NULL, 0));
 8231478:	d8000115 	stw	zero,4(sp)
 823147c:	d8000015 	stw	zero,0(sp)
 8231480:	e1ffff17 	ldw	r7,-4(fp)
 8231484:	e1bffe17 	ldw	r6,-8(fp)
 8231488:	e17ffd17 	ldw	r5,-12(fp)
 823148c:	e13ffc17 	ldw	r4,-16(fp)
 8231490:	82311fc0 	call	82311fc <t_sendto>
 8231494:	00005206 	br	82315e0 <t_send+0x1f0>

   maxpkt = TCP_MSS;
 8231498:	00816d04 	movi	r2,1460
 823149c:	e0bff615 	stw	r2,-40(fp)
   if(so->so_pcb)
 82314a0:	e0bff717 	ldw	r2,-36(fp)
 82314a4:	10800117 	ldw	r2,4(r2)
 82314a8:	10004826 	beq	r2,zero,82315cc <t_send+0x1dc>
   { 
      struct tcpcb * tp;
      tp = intotcpcb(so->so_pcb);   /* get tcp structure with mss */
 82314ac:	e0bff717 	ldw	r2,-36(fp)
 82314b0:	10800117 	ldw	r2,4(r2)
 82314b4:	10800917 	ldw	r2,36(r2)
 82314b8:	e0bff815 	stw	r2,-32(fp)
      if(tp->t_maxseg)              /* Make sure it's set */
 82314bc:	e0bff817 	ldw	r2,-32(fp)
 82314c0:	10800a0b 	ldhu	r2,40(r2)
 82314c4:	10bfffcc 	andi	r2,r2,65535
 82314c8:	10004026 	beq	r2,zero,82315cc <t_send+0x1dc>
         maxpkt = tp->t_maxseg;
 82314cc:	e0bff817 	ldw	r2,-32(fp)
 82314d0:	10800a0b 	ldhu	r2,40(r2)
 82314d4:	10bfffcc 	andi	r2,r2,65535
 82314d8:	e0bff615 	stw	r2,-40(fp)
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 82314dc:	00003b06 	br	82315cc <t_send+0x1dc>
   {
      if (len > maxpkt)
 82314e0:	e0bffe17 	ldw	r2,-8(fp)
 82314e4:	e0fff617 	ldw	r3,-40(fp)
 82314e8:	1880030e 	bge	r3,r2,82314f8 <t_send+0x108>
         sendlen = maxpkt;  /* take biggest block we can */
 82314ec:	e0bff617 	ldw	r2,-40(fp)
 82314f0:	e0bffb15 	stw	r2,-20(fp)
 82314f4:	00000206 	br	8231500 <t_send+0x110>
      else
         sendlen = len;
 82314f8:	e0bffe17 	ldw	r2,-8(fp)
 82314fc:	e0bffb15 	stw	r2,-20(fp)
      sent = sendlen;
 8231500:	e0bffb17 	ldw	r2,-20(fp)
 8231504:	e0bff915 	stw	r2,-28(fp)

      LOCK_NET_RESOURCE(NET_RESID);
 8231508:	0009883a 	mov	r4,zero
 823150c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      e = sosend (so, NULL, buf, &sendlen, flags);
 8231510:	e0fffb04 	addi	r3,fp,-20
 8231514:	e0bfff17 	ldw	r2,-4(fp)
 8231518:	d8800015 	stw	r2,0(sp)
 823151c:	180f883a 	mov	r7,r3
 8231520:	e1bffd17 	ldw	r6,-12(fp)
 8231524:	000b883a 	mov	r5,zero
 8231528:	e13ff717 	ldw	r4,-36(fp)
 823152c:	823218c0 	call	823218c <sosend>
 8231530:	e0bffa15 	stw	r2,-24(fp)
      UNLOCK_NET_RESOURCE(NET_RESID);
 8231534:	0009883a 	mov	r4,zero
 8231538:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
 
      if (e != 0)  /* sock_sendit failed? */
 823153c:	e0bffa17 	ldw	r2,-24(fp)
 8231540:	10001026 	beq	r2,zero,8231584 <t_send+0x194>
      {
         /* if we simply ran out of bufs, report back to caller. */
         if ((e == ENOBUFS) || (e == EWOULDBLOCK))
 8231544:	e0bffa17 	ldw	r2,-24(fp)
 8231548:	10801a60 	cmpeqi	r2,r2,105
 823154c:	1000031e 	bne	r2,zero,823155c <t_send+0x16c>
 8231550:	e0bffa17 	ldw	r2,-24(fp)
 8231554:	108002d8 	cmpnei	r2,r2,11
 8231558:	1000051e 	bne	r2,zero,8231570 <t_send+0x180>
            /* if we actually sent something before running out
             * of buffers, report what we sent; 
             * else, report the error and let the application 
             * retry the call later
             */
            if (total_sent != 0)
 823155c:	e0bff517 	ldw	r2,-44(fp)
 8231560:	10000326 	beq	r2,zero,8231570 <t_send+0x180>
            {
               so->so_error = 0;
 8231564:	e0bff717 	ldw	r2,-36(fp)
 8231568:	10000615 	stw	zero,24(r2)
               break;      /* break out of while(len) loop */
 823156c:	00001b06 	br	82315dc <t_send+0x1ec>
            }
         }
         so->so_error = e;
 8231570:	e0bff717 	ldw	r2,-36(fp)
 8231574:	e0fffa17 	ldw	r3,-24(fp)
 8231578:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 823157c:	00bfffc4 	movi	r2,-1
 8231580:	00001706 	br	82315e0 <t_send+0x1f0>
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
 8231584:	e0bffb17 	ldw	r2,-20(fp)
 8231588:	1000131e 	bne	r2,zero,82315d8 <t_send+0x1e8>
         break;         /* break out of while(len) loop */

      /* adjust numbers & pointers, and go do next send loop */
      sent -= sendlen;        /* subtract anything that didn't get sent */
 823158c:	e0bffb17 	ldw	r2,-20(fp)
 8231590:	e0fff917 	ldw	r3,-28(fp)
 8231594:	1885c83a 	sub	r2,r3,r2
 8231598:	e0bff915 	stw	r2,-28(fp)
      buf += sent;
 823159c:	e0bff917 	ldw	r2,-28(fp)
 82315a0:	e0fffd17 	ldw	r3,-12(fp)
 82315a4:	1885883a 	add	r2,r3,r2
 82315a8:	e0bffd15 	stw	r2,-12(fp)
      len -= sent;
 82315ac:	e0fffe17 	ldw	r3,-8(fp)
 82315b0:	e0bff917 	ldw	r2,-28(fp)
 82315b4:	1885c83a 	sub	r2,r3,r2
 82315b8:	e0bffe15 	stw	r2,-8(fp)
      total_sent += sent;
 82315bc:	e0fff517 	ldw	r3,-44(fp)
 82315c0:	e0bff917 	ldw	r2,-28(fp)
 82315c4:	1885883a 	add	r2,r3,r2
 82315c8:	e0bff515 	stw	r2,-44(fp)
         maxpkt = tp->t_maxseg;
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 82315cc:	e0bffe17 	ldw	r2,-8(fp)
 82315d0:	103fc31e 	bne	r2,zero,82314e0 <t_send+0xf0>
 82315d4:	00000106 	br	82315dc <t_send+0x1ec>
         so->so_error = e;
         return SOCKET_ERROR;
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
         break;         /* break out of while(len) loop */
 82315d8:	0001883a 	nop
      len -= sent;
      total_sent += sent;
   }

   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   return total_sent;
 82315dc:	e0bff517 	ldw	r2,-44(fp)
}
 82315e0:	e037883a 	mov	sp,fp
 82315e4:	dfc00117 	ldw	ra,4(sp)
 82315e8:	df000017 	ldw	fp,0(sp)
 82315ec:	dec00204 	addi	sp,sp,8
 82315f0:	f800283a 	ret

082315f4 <t_shutdown>:
 * RETURNS: 
 */

int
t_shutdown(long s, int   how)
{
 82315f4:	defff904 	addi	sp,sp,-28
 82315f8:	dfc00615 	stw	ra,24(sp)
 82315fc:	df000515 	stw	fp,20(sp)
 8231600:	df000504 	addi	fp,sp,20
 8231604:	e13ffe15 	stw	r4,-8(fp)
 8231608:	e17fff15 	stw	r5,-4(fp)
   struct socket *so;
   int   err;

   so = LONG2SO(s);
 823160c:	e0bffe17 	ldw	r2,-8(fp)
 8231610:	10bff804 	addi	r2,r2,-32
 8231614:	1085883a 	add	r2,r2,r2
 8231618:	1085883a 	add	r2,r2,r2
 823161c:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 8231620:	008209b4 	movhi	r2,2086
 8231624:	10b96104 	addi	r2,r2,-6780
 8231628:	e0bffb15 	stw	r2,-20(fp)
 823162c:	00000606 	br	8231648 <t_shutdown+0x54>
 8231630:	e0fffb17 	ldw	r3,-20(fp)
 8231634:	e0bffc17 	ldw	r2,-16(fp)
 8231638:	18800626 	beq	r3,r2,8231654 <t_shutdown+0x60>
 823163c:	e0bffb17 	ldw	r2,-20(fp)
 8231640:	10800017 	ldw	r2,0(r2)
 8231644:	e0bffb15 	stw	r2,-20(fp)
 8231648:	e0bffb17 	ldw	r2,-20(fp)
 823164c:	103ff81e 	bne	r2,zero,8231630 <t_shutdown+0x3c>
 8231650:	00000106 	br	8231658 <t_shutdown+0x64>
 8231654:	0001883a 	nop
 8231658:	e0fffb17 	ldw	r3,-20(fp)
 823165c:	e0bffc17 	ldw	r2,-16(fp)
 8231660:	18800326 	beq	r3,r2,8231670 <t_shutdown+0x7c>
 8231664:	822d4140 	call	822d414 <dtrap>
 8231668:	00bfffc4 	movi	r2,-1
 823166c:	00001206 	br	82316b8 <t_shutdown+0xc4>
   so->so_error = 0;
 8231670:	e0bffc17 	ldw	r2,-16(fp)
 8231674:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:shutdown so %x how %d\n", so, how));

   LOCK_NET_RESOURCE(NET_RESID);
 8231678:	0009883a 	mov	r4,zero
 823167c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   err = soshutdown(so, how);
 8231680:	e17fff17 	ldw	r5,-4(fp)
 8231684:	e13ffc17 	ldw	r4,-16(fp)
 8231688:	8232e300 	call	8232e30 <soshutdown>
 823168c:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8231690:	0009883a 	mov	r4,zero
 8231694:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 8231698:	e0bffd17 	ldw	r2,-12(fp)
 823169c:	10000526 	beq	r2,zero,82316b4 <t_shutdown+0xc0>
   {
      so->so_error = err;
 82316a0:	e0bffc17 	ldw	r2,-16(fp)
 82316a4:	e0fffd17 	ldw	r3,-12(fp)
 82316a8:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 82316ac:	00bfffc4 	movi	r2,-1
 82316b0:	00000106 	br	82316b8 <t_shutdown+0xc4>
   }
   return 0;
 82316b4:	0005883a 	mov	r2,zero
}
 82316b8:	e037883a 	mov	sp,fp
 82316bc:	dfc00117 	ldw	ra,4(sp)
 82316c0:	df000017 	ldw	fp,0(sp)
 82316c4:	dec00204 	addi	sp,sp,8
 82316c8:	f800283a 	ret

082316cc <t_socketclose>:
 * RETURNS: 
 */

int
t_socketclose(long s)
{
 82316cc:	defffa04 	addi	sp,sp,-24
 82316d0:	dfc00515 	stw	ra,20(sp)
 82316d4:	df000415 	stw	fp,16(sp)
 82316d8:	df000404 	addi	fp,sp,16
 82316dc:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 82316e0:	e0bfff17 	ldw	r2,-4(fp)
 82316e4:	10bff804 	addi	r2,r2,-32
 82316e8:	1085883a 	add	r2,r2,r2
 82316ec:	1085883a 	add	r2,r2,r2
 82316f0:	e0bffd15 	stw	r2,-12(fp)
   SOC_CHECK(so);
 82316f4:	008209b4 	movhi	r2,2086
 82316f8:	10b96104 	addi	r2,r2,-6780
 82316fc:	e0bffc15 	stw	r2,-16(fp)
 8231700:	00000606 	br	823171c <t_socketclose+0x50>
 8231704:	e0fffc17 	ldw	r3,-16(fp)
 8231708:	e0bffd17 	ldw	r2,-12(fp)
 823170c:	18800626 	beq	r3,r2,8231728 <t_socketclose+0x5c>
 8231710:	e0bffc17 	ldw	r2,-16(fp)
 8231714:	10800017 	ldw	r2,0(r2)
 8231718:	e0bffc15 	stw	r2,-16(fp)
 823171c:	e0bffc17 	ldw	r2,-16(fp)
 8231720:	103ff81e 	bne	r2,zero,8231704 <t_socketclose+0x38>
 8231724:	00000106 	br	823172c <t_socketclose+0x60>
 8231728:	0001883a 	nop
 823172c:	e0fffc17 	ldw	r3,-16(fp)
 8231730:	e0bffd17 	ldw	r2,-12(fp)
 8231734:	18800326 	beq	r3,r2,8231744 <t_socketclose+0x78>
 8231738:	822d4140 	call	822d414 <dtrap>
 823173c:	00bfffc4 	movi	r2,-1
 8231740:	00000e06 	br	823177c <t_socketclose+0xb0>
   so->so_error = 0;
 8231744:	e0bffd17 	ldw	r2,-12(fp)
 8231748:	10000615 	stw	zero,24(r2)
   INET_TRACE ((INETM_CLOSE|INETM_SOCKET), ("INET:close, so %lx\n",so));

   LOCK_NET_RESOURCE(NET_RESID);
 823174c:	0009883a 	mov	r4,zero
 8231750:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   err = soclose(so);
 8231754:	e13ffd17 	ldw	r4,-12(fp)
 8231758:	8231c980 	call	8231c98 <soclose>
 823175c:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8231760:	0009883a 	mov	r4,zero
 8231764:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 8231768:	e0bffe17 	ldw	r2,-8(fp)
 823176c:	10000226 	beq	r2,zero,8231778 <t_socketclose+0xac>
   {
      /* do not do the following assignment since the socket structure
         addressed by so has been freed by this point, jharan 12-10-98 */
      /*      so->so_error = err;   */
      return SOCKET_ERROR;
 8231770:	00bfffc4 	movi	r2,-1
 8231774:	00000106 	br	823177c <t_socketclose+0xb0>
   }
   return 0;
 8231778:	0005883a 	mov	r2,zero
}
 823177c:	e037883a 	mov	sp,fp
 8231780:	dfc00117 	ldw	ra,4(sp)
 8231784:	df000017 	ldw	fp,0(sp)
 8231788:	dec00204 	addi	sp,sp,8
 823178c:	f800283a 	ret

08231790 <sockargs>:

static struct mbuf  * 
sockargs (void * arg, 
   int   arglen, 
   int   type)
{
 8231790:	defffa04 	addi	sp,sp,-24
 8231794:	dfc00515 	stw	ra,20(sp)
 8231798:	df000415 	stw	fp,16(sp)
 823179c:	df000404 	addi	fp,sp,16
 82317a0:	e13ffd15 	stw	r4,-12(fp)
 82317a4:	e17ffe15 	stw	r5,-8(fp)
 82317a8:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  m;

   LOCK_NET_RESOURCE(NET_RESID);    /* protect mfreeq */
 82317ac:	0009883a 	mov	r4,zero
 82317b0:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   m = m_getwithdata (type, arglen);
 82317b4:	e17ffe17 	ldw	r5,-8(fp)
 82317b8:	e13fff17 	ldw	r4,-4(fp)
 82317bc:	822e2280 	call	822e228 <m_getnbuf>
 82317c0:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 82317c4:	0009883a 	mov	r4,zero
 82317c8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   if (m == NULL)
 82317cc:	e0bffc17 	ldw	r2,-16(fp)
 82317d0:	1000021e 	bne	r2,zero,82317dc <sockargs+0x4c>
      return NULL;
 82317d4:	0005883a 	mov	r2,zero
 82317d8:	00000b06 	br	8231808 <sockargs+0x78>
   m->m_len = arglen;
 82317dc:	e0fffe17 	ldw	r3,-8(fp)
 82317e0:	e0bffc17 	ldw	r2,-16(fp)
 82317e4:	10c00215 	stw	r3,8(r2)
   MEMCPY(mtod (m, char *), arg, arglen);
 82317e8:	e0bffc17 	ldw	r2,-16(fp)
 82317ec:	10800317 	ldw	r2,12(r2)
 82317f0:	e0fffe17 	ldw	r3,-8(fp)
 82317f4:	180d883a 	mov	r6,r3
 82317f8:	e17ffd17 	ldw	r5,-12(fp)
 82317fc:	1009883a 	mov	r4,r2
 8231800:	8202e8c0 	call	8202e8c <memcpy>
   return m;
 8231804:	e0bffc17 	ldw	r2,-16(fp)
}
 8231808:	e037883a 	mov	sp,fp
 823180c:	dfc00117 	ldw	ra,4(sp)
 8231810:	df000017 	ldw	fp,0(sp)
 8231814:	dec00204 	addi	sp,sp,8
 8231818:	f800283a 	ret

0823181c <t_errno>:
 *                            ENOTSOCK if socket not found
 */

int
t_errno(long s)
{
 823181c:	defffa04 	addi	sp,sp,-24
 8231820:	dfc00515 	stw	ra,20(sp)
 8231824:	df000415 	stw	fp,16(sp)
 8231828:	df000404 	addi	fp,sp,16
 823182c:	e13fff15 	stw	r4,-4(fp)
   struct socket *so = LONG2SO(s);
 8231830:	e0bfff17 	ldw	r2,-4(fp)
 8231834:	10bff804 	addi	r2,r2,-32
 8231838:	1085883a 	add	r2,r2,r2
 823183c:	1085883a 	add	r2,r2,r2
 8231840:	e0bffe15 	stw	r2,-8(fp)
   struct socket *tmp;
   int errcode = ENOTSOCK;
 8231844:	00801b04 	movi	r2,108
 8231848:	e0bffd15 	stw	r2,-12(fp)

   LOCK_NET_RESOURCE(NET_RESID);    /* protect soq */
 823184c:	0009883a 	mov	r4,zero
 8231850:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 8231854:	008209b4 	movhi	r2,2086
 8231858:	10b96104 	addi	r2,r2,-6780
 823185c:	e0bffc15 	stw	r2,-16(fp)
 8231860:	00000a06 	br	823188c <t_errno+0x70>
   {
      if (tmp == so)  /* found socket, return error */
 8231864:	e0fffc17 	ldw	r3,-16(fp)
 8231868:	e0bffe17 	ldw	r2,-8(fp)
 823186c:	1880041e 	bne	r3,r2,8231880 <t_errno+0x64>
      {
         errcode = so->so_error;
 8231870:	e0bffe17 	ldw	r2,-8(fp)
 8231874:	10800617 	ldw	r2,24(r2)
 8231878:	e0bffd15 	stw	r2,-12(fp)
         break;
 823187c:	00000506 	br	8231894 <t_errno+0x78>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 8231880:	e0bffc17 	ldw	r2,-16(fp)
 8231884:	10800017 	ldw	r2,0(r2)
 8231888:	e0bffc15 	stw	r2,-16(fp)
 823188c:	e0bffc17 	ldw	r2,-16(fp)
 8231890:	103ff41e 	bne	r2,zero,8231864 <t_errno+0x48>
         errcode = so->so_error;
         break;
      }
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 8231894:	0009883a 	mov	r4,zero
 8231898:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   return errcode;
 823189c:	e0bffd17 	ldw	r2,-12(fp)
}
 82318a0:	e037883a 	mov	sp,fp
 82318a4:	dfc00117 	ldw	ra,4(sp)
 82318a8:	df000017 	ldw	fp,0(sp)
 82318ac:	dec00204 	addi	sp,sp,8
 82318b0:	f800283a 	ret

082318b4 <socreate>:
 * RETURNS: 
 */

struct socket *   
socreate (int dom, int type, int proto)
{
 82318b4:	defff704 	addi	sp,sp,-36
 82318b8:	dfc00815 	stw	ra,32(sp)
 82318bc:	df000715 	stw	fp,28(sp)
 82318c0:	df000704 	addi	fp,sp,28
 82318c4:	e13ffd15 	stw	r4,-12(fp)
 82318c8:	e17ffe15 	stw	r5,-8(fp)
 82318cc:	e1bfff15 	stw	r6,-4(fp)
   struct protosw *prp;
   struct socket *so;
   int   error;
   int rc;

   if (proto)
 82318d0:	e0bfff17 	ldw	r2,-4(fp)
 82318d4:	10000626 	beq	r2,zero,82318f0 <socreate+0x3c>
      prp = pffindproto(dom, proto, type);
 82318d8:	e1bffe17 	ldw	r6,-8(fp)
 82318dc:	e17fff17 	ldw	r5,-4(fp)
 82318e0:	e13ffd17 	ldw	r4,-12(fp)
 82318e4:	822e1640 	call	822e164 <pffindproto>
 82318e8:	e0bff915 	stw	r2,-28(fp)
 82318ec:	00000406 	br	8231900 <socreate+0x4c>
   else
      prp = pffindtype(dom, type);
 82318f0:	e17ffe17 	ldw	r5,-8(fp)
 82318f4:	e13ffd17 	ldw	r4,-12(fp)
 82318f8:	822e0d40 	call	822e0d4 <pffindtype>
 82318fc:	e0bff915 	stw	r2,-28(fp)
   if (prp == 0)
 8231900:	e0bff917 	ldw	r2,-28(fp)
 8231904:	1000021e 	bne	r2,zero,8231910 <socreate+0x5c>
      return NULL;
 8231908:	0005883a 	mov	r2,zero
 823190c:	00004e06 	br	8231a48 <socreate+0x194>
   if (prp->pr_type != type)
 8231910:	e0bff917 	ldw	r2,-28(fp)
 8231914:	1080000b 	ldhu	r2,0(r2)
 8231918:	10ffffcc 	andi	r3,r2,65535
 823191c:	18e0001c 	xori	r3,r3,32768
 8231920:	18e00004 	addi	r3,r3,-32768
 8231924:	e0bffe17 	ldw	r2,-8(fp)
 8231928:	18800226 	beq	r3,r2,8231934 <socreate+0x80>
      return NULL;
 823192c:	0005883a 	mov	r2,zero
 8231930:	00004506 	br	8231a48 <socreate+0x194>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 8231934:	01002104 	movi	r4,132
 8231938:	822dfec0 	call	822dfec <npalloc>
 823193c:	e0bffa15 	stw	r2,-24(fp)
 8231940:	e0bffa17 	ldw	r2,-24(fp)
 8231944:	1000021e 	bne	r2,zero,8231950 <socreate+0x9c>
      return NULL;
 8231948:	0005883a 	mov	r2,zero
 823194c:	00003e06 	br	8231a48 <socreate+0x194>
   so->next = NULL;
 8231950:	e0bffa17 	ldw	r2,-24(fp)
 8231954:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);
 8231958:	e17ffa17 	ldw	r5,-24(fp)
 823195c:	010209b4 	movhi	r4,2086
 8231960:	21396104 	addi	r4,r4,-6780
 8231964:	822cdfc0 	call	822cdfc <putq>

   so->so_options = socket_defaults;
 8231968:	d0a03c0b 	ldhu	r2,-32528(gp)
 823196c:	10ffffcc 	andi	r3,r2,65535
 8231970:	e0bffa17 	ldw	r2,-24(fp)
 8231974:	10c00415 	stw	r3,16(r2)
   so->so_domain = dom;
 8231978:	e0bffa17 	ldw	r2,-24(fp)
 823197c:	e0fffd17 	ldw	r3,-12(fp)
 8231980:	10c00515 	stw	r3,20(r2)
   so->so_state = 0;
 8231984:	e0bffa17 	ldw	r2,-24(fp)
 8231988:	1000088d 	sth	zero,34(r2)
   so->so_type = (char)type;
 823198c:	e0bffe17 	ldw	r2,-8(fp)
 8231990:	1007883a 	mov	r3,r2
 8231994:	e0bffa17 	ldw	r2,-24(fp)
 8231998:	10c00985 	stb	r3,38(r2)
   so->so_proto = prp;
 823199c:	e0bffa17 	ldw	r2,-24(fp)
 82319a0:	e0fff917 	ldw	r3,-28(fp)
 82319a4:	10c00215 	stw	r3,8(r2)

#ifdef IP_MULTICAST
   so->inp_moptions = NULL;
 82319a8:	e0bffa17 	ldw	r2,-24(fp)
 82319ac:	10000315 	stw	zero,12(r2)
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
 82319b0:	e0bffa17 	ldw	r2,-24(fp)
 82319b4:	10000715 	stw	zero,28(r2)
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
 82319b8:	e0bff917 	ldw	r2,-28(fp)
 82319bc:	10800317 	ldw	r2,12(r2)
 82319c0:	e0ffff17 	ldw	r3,-4(fp)
 82319c4:	180d883a 	mov	r6,r3
 82319c8:	000b883a 	mov	r5,zero
 82319cc:	e13ffa17 	ldw	r4,-24(fp)
 82319d0:	103ee83a 	callr	r2
 82319d4:	e0bffb15 	stw	r2,-20(fp)
   if (error) goto bad;
 82319d8:	e0bffb17 	ldw	r2,-20(fp)
 82319dc:	10000a1e 	bne	r2,zero,8231a08 <socreate+0x154>

   if (so_evtmap)
 82319e0:	d0a0ce03 	ldbu	r2,-31944(gp)
 82319e4:	10803fcc 	andi	r2,r2,255
 82319e8:	10001626 	beq	r2,zero,8231a44 <socreate+0x190>
   {                       
      rc = (*so_evtmap_create) (so);
 82319ec:	d0a0cc17 	ldw	r2,-31952(gp)
 82319f0:	e13ffa17 	ldw	r4,-24(fp)
 82319f4:	103ee83a 	callr	r2
 82319f8:	e0bffc15 	stw	r2,-16(fp)
      if (rc != 0)
 82319fc:	e0bffc17 	ldw	r2,-16(fp)
 8231a00:	10000c26 	beq	r2,zero,8231a34 <socreate+0x180>
 8231a04:	00000106 	br	8231a0c <socreate+0x158>
   so->inp_moptions = NULL;
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
   if (error) goto bad;
 8231a08:	0001883a 	nop
   {                       
      rc = (*so_evtmap_create) (so);
      if (rc != 0)
      {
bad:   
         so->so_state |= SS_NOFDREF;
 8231a0c:	e0bffa17 	ldw	r2,-24(fp)
 8231a10:	1080088b 	ldhu	r2,34(r2)
 8231a14:	10800054 	ori	r2,r2,1
 8231a18:	1007883a 	mov	r3,r2
 8231a1c:	e0bffa17 	ldw	r2,-24(fp)
 8231a20:	10c0088d 	sth	r3,34(r2)
         sofree (so);
 8231a24:	e13ffa17 	ldw	r4,-24(fp)
 8231a28:	8231b880 	call	8231b88 <sofree>
         return NULL;   
 8231a2c:	0005883a 	mov	r2,zero
 8231a30:	00000506 	br	8231a48 <socreate+0x194>
      /*
       * Altera Niche Stack Nios port modification:
       * Remove (void *) cast since -> owner is now TK_OBJECT
       * to fix build warning.
       */
      so->owner = TK_THIS;
 8231a34:	82296440 	call	8229644 <TK_OSTaskQuery>
 8231a38:	1007883a 	mov	r3,r2
 8231a3c:	e0bffa17 	ldw	r2,-24(fp)
 8231a40:	10c02005 	stb	r3,128(r2)
   }

   return so;
 8231a44:	e0bffa17 	ldw	r2,-24(fp)
}
 8231a48:	e037883a 	mov	sp,fp
 8231a4c:	dfc00117 	ldw	ra,4(sp)
 8231a50:	df000017 	ldw	fp,0(sp)
 8231a54:	dec00204 	addi	sp,sp,8
 8231a58:	f800283a 	ret

08231a5c <sobind>:
 */

int
sobind(struct socket * so, 
   struct mbuf *  nam)
{
 8231a5c:	defffb04 	addi	sp,sp,-20
 8231a60:	dfc00415 	stw	ra,16(sp)
 8231a64:	df000315 	stw	fp,12(sp)
 8231a68:	df000304 	addi	fp,sp,12
 8231a6c:	e13ffe15 	stw	r4,-8(fp)
 8231a70:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_BIND;
 8231a74:	e0bffe17 	ldw	r2,-8(fp)
 8231a78:	00c00084 	movi	r3,2
 8231a7c:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 8231a80:	e0bffe17 	ldw	r2,-8(fp)
 8231a84:	10800217 	ldw	r2,8(r2)
 8231a88:	10800317 	ldw	r2,12(r2)
 8231a8c:	e1bfff17 	ldw	r6,-4(fp)
 8231a90:	000b883a 	mov	r5,zero
 8231a94:	e13ffe17 	ldw	r4,-8(fp)
 8231a98:	103ee83a 	callr	r2
 8231a9c:	e0bffd15 	stw	r2,-12(fp)
   return (error);
 8231aa0:	e0bffd17 	ldw	r2,-12(fp)
}
 8231aa4:	e037883a 	mov	sp,fp
 8231aa8:	dfc00117 	ldw	ra,4(sp)
 8231aac:	df000017 	ldw	fp,0(sp)
 8231ab0:	dec00204 	addi	sp,sp,8
 8231ab4:	f800283a 	ret

08231ab8 <solisten>:
 */

int
solisten(struct socket * so, 
   int   backlog)
{
 8231ab8:	defffb04 	addi	sp,sp,-20
 8231abc:	dfc00415 	stw	ra,16(sp)
 8231ac0:	df000315 	stw	fp,12(sp)
 8231ac4:	df000304 	addi	fp,sp,12
 8231ac8:	e13ffe15 	stw	r4,-8(fp)
 8231acc:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_LISTEN;
 8231ad0:	e0bffe17 	ldw	r2,-8(fp)
 8231ad4:	00c000c4 	movi	r3,3
 8231ad8:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so,
 8231adc:	e0bffe17 	ldw	r2,-8(fp)
 8231ae0:	10800217 	ldw	r2,8(r2)
 8231ae4:	10800317 	ldw	r2,12(r2)
 8231ae8:	000d883a 	mov	r6,zero
 8231aec:	000b883a 	mov	r5,zero
 8231af0:	e13ffe17 	ldw	r4,-8(fp)
 8231af4:	103ee83a 	callr	r2
 8231af8:	e0bffd15 	stw	r2,-12(fp)
    (struct mbuf *)0, (struct mbuf *)0);
   if (error) 
 8231afc:	e0bffd17 	ldw	r2,-12(fp)
 8231b00:	10000226 	beq	r2,zero,8231b0c <solisten+0x54>
   {
      return (error);
 8231b04:	e0bffd17 	ldw	r2,-12(fp)
 8231b08:	00001a06 	br	8231b74 <solisten+0xbc>
   }
   if (so->so_q == 0) 
 8231b0c:	e0bffe17 	ldw	r2,-8(fp)
 8231b10:	10801d17 	ldw	r2,116(r2)
 8231b14:	10000b1e 	bne	r2,zero,8231b44 <solisten+0x8c>
   {
      so->so_q = so;
 8231b18:	e0bffe17 	ldw	r2,-8(fp)
 8231b1c:	e0fffe17 	ldw	r3,-8(fp)
 8231b20:	10c01d15 	stw	r3,116(r2)
      so->so_q0 = so;
 8231b24:	e0bffe17 	ldw	r2,-8(fp)
 8231b28:	e0fffe17 	ldw	r3,-8(fp)
 8231b2c:	10c01c15 	stw	r3,112(r2)
      so->so_options |= SO_ACCEPTCONN;
 8231b30:	e0bffe17 	ldw	r2,-8(fp)
 8231b34:	10800417 	ldw	r2,16(r2)
 8231b38:	10c00094 	ori	r3,r2,2
 8231b3c:	e0bffe17 	ldw	r2,-8(fp)
 8231b40:	10c00415 	stw	r3,16(r2)
   }
   if (backlog < 0)
 8231b44:	e0bfff17 	ldw	r2,-4(fp)
 8231b48:	1000010e 	bge	r2,zero,8231b50 <solisten+0x98>
      backlog = 0;
 8231b4c:	e03fff15 	stw	zero,-4(fp)
   so->so_qlimit = (char)MIN(backlog, SOMAXCONN);
 8231b50:	e0bfff17 	ldw	r2,-4(fp)
 8231b54:	10800188 	cmpgei	r2,r2,6
 8231b58:	1000021e 	bne	r2,zero,8231b64 <solisten+0xac>
 8231b5c:	e0bfff17 	ldw	r2,-4(fp)
 8231b60:	00000106 	br	8231b68 <solisten+0xb0>
 8231b64:	00800144 	movi	r2,5
 8231b68:	e0fffe17 	ldw	r3,-8(fp)
 8231b6c:	18801e85 	stb	r2,122(r3)
   return 0;
 8231b70:	0005883a 	mov	r2,zero
}
 8231b74:	e037883a 	mov	sp,fp
 8231b78:	dfc00117 	ldw	ra,4(sp)
 8231b7c:	df000017 	ldw	fp,0(sp)
 8231b80:	dec00204 	addi	sp,sp,8
 8231b84:	f800283a 	ret

08231b88 <sofree>:
 * RETURNS: 
 */

void
sofree(struct socket * so)
{
 8231b88:	defffd04 	addi	sp,sp,-12
 8231b8c:	dfc00215 	stw	ra,8(sp)
 8231b90:	df000115 	stw	fp,4(sp)
 8231b94:	df000104 	addi	fp,sp,4
 8231b98:	e13fff15 	stw	r4,-4(fp)
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
 8231b9c:	e0bfff17 	ldw	r2,-4(fp)
 8231ba0:	10800117 	ldw	r2,4(r2)
 8231ba4:	1000361e 	bne	r2,zero,8231c80 <sofree+0xf8>
 8231ba8:	e0bfff17 	ldw	r2,-4(fp)
 8231bac:	1080088b 	ldhu	r2,34(r2)
 8231bb0:	10bfffcc 	andi	r2,r2,65535
 8231bb4:	1080004c 	andi	r2,r2,1
 8231bb8:	10003126 	beq	r2,zero,8231c80 <sofree+0xf8>
      return;
   if (so->so_head) 
 8231bbc:	e0bfff17 	ldw	r2,-4(fp)
 8231bc0:	10801b17 	ldw	r2,108(r2)
 8231bc4:	10000d26 	beq	r2,zero,8231bfc <sofree+0x74>
   {
      if (!soqremque(so, 0) && !soqremque(so, 1))
 8231bc8:	000b883a 	mov	r5,zero
 8231bcc:	e13fff17 	ldw	r4,-4(fp)
 8231bd0:	8233e640 	call	8233e64 <soqremque>
 8231bd4:	1000071e 	bne	r2,zero,8231bf4 <sofree+0x6c>
 8231bd8:	01400044 	movi	r5,1
 8231bdc:	e13fff17 	ldw	r4,-4(fp)
 8231be0:	8233e640 	call	8233e64 <soqremque>
 8231be4:	1000031e 	bne	r2,zero,8231bf4 <sofree+0x6c>
         panic("sofree");
 8231be8:	01020974 	movhi	r4,2085
 8231bec:	21037f04 	addi	r4,r4,3580
 8231bf0:	8228aec0 	call	8228aec <panic>
      so->so_head = 0;
 8231bf4:	e0bfff17 	ldw	r2,-4(fp)
 8231bf8:	10001b15 	stw	zero,108(r2)
   }
   sbrelease(&so->so_snd);
 8231bfc:	e0bfff17 	ldw	r2,-4(fp)
 8231c00:	10801204 	addi	r2,r2,72
 8231c04:	1009883a 	mov	r4,r2
 8231c08:	82342280 	call	8234228 <sbrelease>
   sorflush(so);
 8231c0c:	e13fff17 	ldw	r4,-4(fp)
 8231c10:	8232ec80 	call	8232ec8 <sorflush>
      _socket_free_entry (so);
#endif   /* SAVE_SOCK_ENDPOINTS */

#ifdef IP_MULTICAST
   /* multicast opts? */
   if (so->inp_moptions)
 8231c14:	e0bfff17 	ldw	r2,-4(fp)
 8231c18:	10800317 	ldw	r2,12(r2)
 8231c1c:	10000426 	beq	r2,zero,8231c30 <sofree+0xa8>
	   ip_freemoptions(so->inp_moptions);
 8231c20:	e0bfff17 	ldw	r2,-4(fp)
 8231c24:	10800317 	ldw	r2,12(r2)
 8231c28:	1009883a 	mov	r4,r2
 8231c2c:	82464cc0 	call	82464cc <ip_freemoptions>
#endif   /* IP_MULTICAST */

   /* IP_TOS opts? */
   if (so->so_optsPack)
 8231c30:	e0bfff17 	ldw	r2,-4(fp)
 8231c34:	10801f17 	ldw	r2,124(r2)
 8231c38:	10000426 	beq	r2,zero,8231c4c <sofree+0xc4>
      SOCOPT_FREE(so->so_optsPack);
 8231c3c:	e0bfff17 	ldw	r2,-4(fp)
 8231c40:	10801f17 	ldw	r2,124(r2)
 8231c44:	1009883a 	mov	r4,r2
 8231c48:	822e0200 	call	822e020 <npfree>
	   
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 8231c4c:	e17fff17 	ldw	r5,-4(fp)
 8231c50:	010209b4 	movhi	r4,2086
 8231c54:	21396104 	addi	r4,r4,-6780
 8231c58:	822ceac0 	call	822ceac <qdel>
   
   if (so_evtmap)  
 8231c5c:	d0a0ce03 	ldbu	r2,-31944(gp)
 8231c60:	10803fcc 	andi	r2,r2,255
 8231c64:	10000326 	beq	r2,zero,8231c74 <sofree+0xec>
      (*so_evtmap_delete) (so);
 8231c68:	d0a0cd17 	ldw	r2,-31948(gp)
 8231c6c:	e13fff17 	ldw	r4,-4(fp)
 8231c70:	103ee83a 	callr	r2
   
   SOC_FREE(so);
 8231c74:	e13fff17 	ldw	r4,-4(fp)
 8231c78:	822e0200 	call	822e020 <npfree>
 8231c7c:	00000106 	br	8231c84 <sofree+0xfc>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
      return;
 8231c80:	0001883a 	nop
   
   if (so_evtmap)  
      (*so_evtmap_delete) (so);
   
   SOC_FREE(so);
}
 8231c84:	e037883a 	mov	sp,fp
 8231c88:	dfc00117 	ldw	ra,4(sp)
 8231c8c:	df000017 	ldw	fp,0(sp)
 8231c90:	dec00204 	addi	sp,sp,8
 8231c94:	f800283a 	ret

08231c98 <soclose>:
 * RETURNS: 
 */

int
soclose(struct socket * so)
{
 8231c98:	defff904 	addi	sp,sp,-28
 8231c9c:	dfc00615 	stw	ra,24(sp)
 8231ca0:	df000515 	stw	fp,20(sp)
 8231ca4:	df000504 	addi	fp,sp,20
 8231ca8:	e13fff15 	stw	r4,-4(fp)
   int   error =  0;
 8231cac:	e03ffb15 	stw	zero,-20(fp)
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 8231cb0:	008209b4 	movhi	r2,2086
 8231cb4:	10b96104 	addi	r2,r2,-6780
 8231cb8:	10800017 	ldw	r2,0(r2)
 8231cbc:	e0bffc15 	stw	r2,-16(fp)
 8231cc0:	00000606 	br	8231cdc <soclose+0x44>
   {
      if (so == tmpso)
 8231cc4:	e0ffff17 	ldw	r3,-4(fp)
 8231cc8:	e0bffc17 	ldw	r2,-16(fp)
 8231ccc:	18800626 	beq	r3,r2,8231ce8 <soclose+0x50>
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 8231cd0:	e0bffc17 	ldw	r2,-16(fp)
 8231cd4:	10800017 	ldw	r2,0(r2)
 8231cd8:	e0bffc15 	stw	r2,-16(fp)
 8231cdc:	e0bffc17 	ldw	r2,-16(fp)
 8231ce0:	103ff81e 	bne	r2,zero,8231cc4 <soclose+0x2c>
 8231ce4:	00000106 	br	8231cec <soclose+0x54>
   {
      if (so == tmpso)
         break;
 8231ce8:	0001883a 	nop
   }
   if ( tmpso == NULL)
 8231cec:	e0bffc17 	ldw	r2,-16(fp)
 8231cf0:	1000021e 	bne	r2,zero,8231cfc <soclose+0x64>
      return EINVAL;
 8231cf4:	00800584 	movi	r2,22
 8231cf8:	00009106 	br	8231f40 <soclose+0x2a8>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
 8231cfc:	e0bfff17 	ldw	r2,-4(fp)
 8231d00:	10800417 	ldw	r2,16(r2)
 8231d04:	1080008c 	andi	r2,r2,2
 8231d08:	10001226 	beq	r2,zero,8231d54 <soclose+0xbc>
   {
      while (so->so_q0 != so)
 8231d0c:	00000406 	br	8231d20 <soclose+0x88>
         (void) soabort(so->so_q0);
 8231d10:	e0bfff17 	ldw	r2,-4(fp)
 8231d14:	10801c17 	ldw	r2,112(r2)
 8231d18:	1009883a 	mov	r4,r2
 8231d1c:	8231f540 	call	8231f54 <soabort>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
 8231d20:	e0bfff17 	ldw	r2,-4(fp)
 8231d24:	10c01c17 	ldw	r3,112(r2)
 8231d28:	e0bfff17 	ldw	r2,-4(fp)
 8231d2c:	18bff81e 	bne	r3,r2,8231d10 <soclose+0x78>
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 8231d30:	00000406 	br	8231d44 <soclose+0xac>
         (void) soabort(so->so_q);
 8231d34:	e0bfff17 	ldw	r2,-4(fp)
 8231d38:	10801d17 	ldw	r2,116(r2)
 8231d3c:	1009883a 	mov	r4,r2
 8231d40:	8231f540 	call	8231f54 <soabort>
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 8231d44:	e0bfff17 	ldw	r2,-4(fp)
 8231d48:	10c01d17 	ldw	r3,116(r2)
 8231d4c:	e0bfff17 	ldw	r2,-4(fp)
 8231d50:	18bff81e 	bne	r3,r2,8231d34 <soclose+0x9c>
         (void) soabort(so->so_q);
   }
   /* for datagram-oriented sockets, dispense with further tests */
   if (so->so_type != SOCK_STREAM)
 8231d54:	e0bfff17 	ldw	r2,-4(fp)
 8231d58:	10800983 	ldbu	r2,38(r2)
 8231d5c:	10803fcc 	andi	r2,r2,255
 8231d60:	1080201c 	xori	r2,r2,128
 8231d64:	10bfe004 	addi	r2,r2,-128
 8231d68:	10800060 	cmpeqi	r2,r2,1
 8231d6c:	10000c1e 	bne	r2,zero,8231da0 <soclose+0x108>
   { 
      so->so_req = PRU_DETACH;
 8231d70:	e0bfff17 	ldw	r2,-4(fp)
 8231d74:	00c00044 	movi	r3,1
 8231d78:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so,
 8231d7c:	e0bfff17 	ldw	r2,-4(fp)
 8231d80:	10800217 	ldw	r2,8(r2)
 8231d84:	10800317 	ldw	r2,12(r2)
 8231d88:	000d883a 	mov	r6,zero
 8231d8c:	000b883a 	mov	r5,zero
 8231d90:	e13fff17 	ldw	r4,-4(fp)
 8231d94:	103ee83a 	callr	r2
 8231d98:	e0bffb15 	stw	r2,-20(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
 8231d9c:	00005906 	br	8231f04 <soclose+0x26c>
   }

   if (so->so_pcb == 0)
 8231da0:	e0bfff17 	ldw	r2,-4(fp)
 8231da4:	10800117 	ldw	r2,4(r2)
 8231da8:	10005526 	beq	r2,zero,8231f00 <soclose+0x268>
      goto discard;
   if (so->so_state & SS_ISCONNECTED) 
 8231dac:	e0bfff17 	ldw	r2,-4(fp)
 8231db0:	1080088b 	ldhu	r2,34(r2)
 8231db4:	10bfffcc 	andi	r2,r2,65535
 8231db8:	1080008c 	andi	r2,r2,2
 8231dbc:	10003d26 	beq	r2,zero,8231eb4 <soclose+0x21c>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
 8231dc0:	e0bfff17 	ldw	r2,-4(fp)
 8231dc4:	1080088b 	ldhu	r2,34(r2)
 8231dc8:	10bfffcc 	andi	r2,r2,65535
 8231dcc:	1080020c 	andi	r2,r2,8
 8231dd0:	1000051e 	bne	r2,zero,8231de8 <soclose+0x150>
      {
         error = sodisconnect(so);
 8231dd4:	e13fff17 	ldw	r4,-4(fp)
 8231dd8:	82320f40 	call	82320f4 <sodisconnect>
 8231ddc:	e0bffb15 	stw	r2,-20(fp)
         if (error)
 8231de0:	e0bffb17 	ldw	r2,-20(fp)
 8231de4:	1000301e 	bne	r2,zero,8231ea8 <soclose+0x210>
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
 8231de8:	e0bfff17 	ldw	r2,-4(fp)
 8231dec:	10800417 	ldw	r2,16(r2)
 8231df0:	1080200c 	andi	r2,r2,128
 8231df4:	10002126 	beq	r2,zero,8231e7c <soclose+0x1e4>
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 8231df8:	e0bfff17 	ldw	r2,-4(fp)
 8231dfc:	1080088b 	ldhu	r2,34(r2)
 8231e00:	10bfffcc 	andi	r2,r2,65535
 8231e04:	1080020c 	andi	r2,r2,8
 8231e08:	10000526 	beq	r2,zero,8231e20 <soclose+0x188>
             (so->so_state & SS_NBIO))
 8231e0c:	e0bfff17 	ldw	r2,-4(fp)
 8231e10:	1080088b 	ldhu	r2,34(r2)
 8231e14:	10bfffcc 	andi	r2,r2,65535
 8231e18:	1080400c 	andi	r2,r2,256
         if (error)
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 8231e1c:	1000241e 	bne	r2,zero,8231eb0 <soclose+0x218>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
 8231e20:	e0bfff17 	ldw	r2,-4(fp)
 8231e24:	1080080b 	ldhu	r2,32(r2)
 8231e28:	10bfffcc 	andi	r2,r2,65535
 8231e2c:	10a0001c 	xori	r2,r2,32768
 8231e30:	10a00004 	addi	r2,r2,-32768
 8231e34:	10c01924 	muli	r3,r2,100
 8231e38:	d0a0a817 	ldw	r2,-32096(gp)
 8231e3c:	1885883a 	add	r2,r3,r2
 8231e40:	e0bffd15 	stw	r2,-12(fp)
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 8231e44:	00000406 	br	8231e58 <soclose+0x1c0>
         {
            tcp_sleep((char *)&so->so_timeo);
 8231e48:	e0bfff17 	ldw	r2,-4(fp)
 8231e4c:	10800904 	addi	r2,r2,36
 8231e50:	1009883a 	mov	r4,r2
 8231e54:	82293d80 	call	82293d8 <tcp_sleep>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 8231e58:	e0bfff17 	ldw	r2,-4(fp)
 8231e5c:	1080088b 	ldhu	r2,34(r2)
 8231e60:	10bfffcc 	andi	r2,r2,65535
 8231e64:	1080008c 	andi	r2,r2,2
 8231e68:	10001226 	beq	r2,zero,8231eb4 <soclose+0x21c>
 8231e6c:	d0e0a817 	ldw	r3,-32096(gp)
 8231e70:	e0bffd17 	ldw	r2,-12(fp)
 8231e74:	18bff436 	bltu	r3,r2,8231e48 <soclose+0x1b0>
 8231e78:	00000e06 	br	8231eb4 <soclose+0x21c>
      {
         /* If socket still has send data just return now, leaving the 
          * socket intact so the data can be sent. Socket should be cleaned
          * up later by timers.
          */
         if(so->so_snd.sb_cc)
 8231e7c:	e0bfff17 	ldw	r2,-4(fp)
 8231e80:	10801217 	ldw	r2,72(r2)
 8231e84:	10000b26 	beq	r2,zero,8231eb4 <soclose+0x21c>
         {
            so->so_state |= SS_NOFDREF;   /* mark as OK to close */
 8231e88:	e0bfff17 	ldw	r2,-4(fp)
 8231e8c:	1080088b 	ldhu	r2,34(r2)
 8231e90:	10800054 	ori	r2,r2,1
 8231e94:	1007883a 	mov	r3,r2
 8231e98:	e0bfff17 	ldw	r2,-4(fp)
 8231e9c:	10c0088d 	sth	r3,34(r2)
            return 0;
 8231ea0:	0005883a 	mov	r2,zero
 8231ea4:	00002606 	br	8231f40 <soclose+0x2a8>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
      {
         error = sodisconnect(so);
         if (error)
            goto drop;
 8231ea8:	0001883a 	nop
 8231eac:	00000106 	br	8231eb4 <soclose+0x21c>
      if (so->so_options & SO_LINGER) 
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
             (so->so_state & SS_NBIO))
         {
            goto drop;
 8231eb0:	0001883a 	nop
            return 0;
         }
      }
   }
drop:
   if (so->so_pcb) 
 8231eb4:	e0bfff17 	ldw	r2,-4(fp)
 8231eb8:	10800117 	ldw	r2,4(r2)
 8231ebc:	10001126 	beq	r2,zero,8231f04 <soclose+0x26c>
   {
      int   error2;
      so->so_req = PRU_DETACH;
 8231ec0:	e0bfff17 	ldw	r2,-4(fp)
 8231ec4:	00c00044 	movi	r3,1
 8231ec8:	10c00715 	stw	r3,28(r2)
      error2 = (*so->so_proto->pr_usrreq)(so,
 8231ecc:	e0bfff17 	ldw	r2,-4(fp)
 8231ed0:	10800217 	ldw	r2,8(r2)
 8231ed4:	10800317 	ldw	r2,12(r2)
 8231ed8:	000d883a 	mov	r6,zero
 8231edc:	000b883a 	mov	r5,zero
 8231ee0:	e13fff17 	ldw	r4,-4(fp)
 8231ee4:	103ee83a 	callr	r2
 8231ee8:	e0bffe15 	stw	r2,-8(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
 8231eec:	e0bffb17 	ldw	r2,-20(fp)
 8231ef0:	1000041e 	bne	r2,zero,8231f04 <soclose+0x26c>
         error = error2;
 8231ef4:	e0bffe17 	ldw	r2,-8(fp)
 8231ef8:	e0bffb15 	stw	r2,-20(fp)
 8231efc:	00000106 	br	8231f04 <soclose+0x26c>
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
   }

   if (so->so_pcb == 0)
      goto discard;
 8231f00:	0001883a 	nop
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
         error = error2;
   }
discard:
   if (so->so_state & SS_NOFDREF)
 8231f04:	e0bfff17 	ldw	r2,-4(fp)
 8231f08:	1080088b 	ldhu	r2,34(r2)
 8231f0c:	10bfffcc 	andi	r2,r2,65535
 8231f10:	1080004c 	andi	r2,r2,1
 8231f14:	10000126 	beq	r2,zero,8231f1c <soclose+0x284>
   {
      /* panic("soclose");  - non-fatal - degrade to dtrap() for now */
      dtrap();
 8231f18:	822d4140 	call	822d414 <dtrap>
   }
   so->so_state |= SS_NOFDREF;
 8231f1c:	e0bfff17 	ldw	r2,-4(fp)
 8231f20:	1080088b 	ldhu	r2,34(r2)
 8231f24:	10800054 	ori	r2,r2,1
 8231f28:	1007883a 	mov	r3,r2
 8231f2c:	e0bfff17 	ldw	r2,-4(fp)
 8231f30:	10c0088d 	sth	r3,34(r2)
   sofree(so);
 8231f34:	e13fff17 	ldw	r4,-4(fp)
 8231f38:	8231b880 	call	8231b88 <sofree>
   return (error);
 8231f3c:	e0bffb17 	ldw	r2,-20(fp)
}
 8231f40:	e037883a 	mov	sp,fp
 8231f44:	dfc00117 	ldw	ra,4(sp)
 8231f48:	df000017 	ldw	fp,0(sp)
 8231f4c:	dec00204 	addi	sp,sp,8
 8231f50:	f800283a 	ret

08231f54 <soabort>:
 * RETURNS: 
 */

int
soabort(struct socket * so)
{
 8231f54:	defffd04 	addi	sp,sp,-12
 8231f58:	dfc00215 	stw	ra,8(sp)
 8231f5c:	df000115 	stw	fp,4(sp)
 8231f60:	df000104 	addi	fp,sp,4
 8231f64:	e13fff15 	stw	r4,-4(fp)
   so->so_req = PRU_ABORT;
 8231f68:	e0bfff17 	ldw	r2,-4(fp)
 8231f6c:	00c00284 	movi	r3,10
 8231f70:	10c00715 	stw	r3,28(r2)
   return(*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 8231f74:	e0bfff17 	ldw	r2,-4(fp)
 8231f78:	10800217 	ldw	r2,8(r2)
 8231f7c:	10800317 	ldw	r2,12(r2)
 8231f80:	000d883a 	mov	r6,zero
 8231f84:	000b883a 	mov	r5,zero
 8231f88:	e13fff17 	ldw	r4,-4(fp)
 8231f8c:	103ee83a 	callr	r2
}
 8231f90:	e037883a 	mov	sp,fp
 8231f94:	dfc00117 	ldw	ra,4(sp)
 8231f98:	df000017 	ldw	fp,0(sp)
 8231f9c:	dec00204 	addi	sp,sp,8
 8231fa0:	f800283a 	ret

08231fa4 <soaccept>:
 */

int
soaccept(struct socket * so, 
   struct mbuf *  nam)
{
 8231fa4:	defffb04 	addi	sp,sp,-20
 8231fa8:	dfc00415 	stw	ra,16(sp)
 8231fac:	df000315 	stw	fp,12(sp)
 8231fb0:	df000304 	addi	fp,sp,12
 8231fb4:	e13ffe15 	stw	r4,-8(fp)
 8231fb8:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if ((so->so_state & SS_NOFDREF) == 0)
 8231fbc:	e0bffe17 	ldw	r2,-8(fp)
 8231fc0:	1080088b 	ldhu	r2,34(r2)
 8231fc4:	10bfffcc 	andi	r2,r2,65535
 8231fc8:	1080004c 	andi	r2,r2,1
 8231fcc:	1000031e 	bne	r2,zero,8231fdc <soaccept+0x38>
      panic("soaccept");
 8231fd0:	01020974 	movhi	r4,2085
 8231fd4:	21038104 	addi	r4,r4,3588
 8231fd8:	8228aec0 	call	8228aec <panic>
   so->so_state &= ~SS_NOFDREF;
 8231fdc:	e0bffe17 	ldw	r2,-8(fp)
 8231fe0:	10c0088b 	ldhu	r3,34(r2)
 8231fe4:	00bfff84 	movi	r2,-2
 8231fe8:	1884703a 	and	r2,r3,r2
 8231fec:	1007883a 	mov	r3,r2
 8231ff0:	e0bffe17 	ldw	r2,-8(fp)
 8231ff4:	10c0088d 	sth	r3,34(r2)
   so->so_req = PRU_ACCEPT;
 8231ff8:	e0bffe17 	ldw	r2,-8(fp)
 8231ffc:	00c00144 	movi	r3,5
 8232000:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 8232004:	e0bffe17 	ldw	r2,-8(fp)
 8232008:	10800217 	ldw	r2,8(r2)
 823200c:	10800317 	ldw	r2,12(r2)
 8232010:	e1bfff17 	ldw	r6,-4(fp)
 8232014:	000b883a 	mov	r5,zero
 8232018:	e13ffe17 	ldw	r4,-8(fp)
 823201c:	103ee83a 	callr	r2
 8232020:	e0bffd15 	stw	r2,-12(fp)

   return (error);
 8232024:	e0bffd17 	ldw	r2,-12(fp)
}
 8232028:	e037883a 	mov	sp,fp
 823202c:	dfc00117 	ldw	ra,4(sp)
 8232030:	df000017 	ldw	fp,0(sp)
 8232034:	dec00204 	addi	sp,sp,8
 8232038:	f800283a 	ret

0823203c <soconnect>:
 */

int
soconnect(struct socket * so, 
   struct mbuf *  nam)
{
 823203c:	defffb04 	addi	sp,sp,-20
 8232040:	dfc00415 	stw	ra,16(sp)
 8232044:	df000315 	stw	fp,12(sp)
 8232048:	df000304 	addi	fp,sp,12
 823204c:	e13ffe15 	stw	r4,-8(fp)
 8232050:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if (so->so_options & SO_ACCEPTCONN)
 8232054:	e0bffe17 	ldw	r2,-8(fp)
 8232058:	10800417 	ldw	r2,16(r2)
 823205c:	1080008c 	andi	r2,r2,2
 8232060:	10000226 	beq	r2,zero,823206c <soconnect+0x30>
      return (EOPNOTSUPP);
 8232064:	008017c4 	movi	r2,95
 8232068:	00001d06 	br	82320e0 <soconnect+0xa4>
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 823206c:	e0bffe17 	ldw	r2,-8(fp)
 8232070:	1080088b 	ldhu	r2,34(r2)
 8232074:	10bfffcc 	andi	r2,r2,65535
 8232078:	1080018c 	andi	r2,r2,6
 823207c:	10000c26 	beq	r2,zero,82320b0 <soconnect+0x74>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
 8232080:	e0bffe17 	ldw	r2,-8(fp)
 8232084:	10800217 	ldw	r2,8(r2)
 8232088:	1080010b 	ldhu	r2,4(r2)
 823208c:	10bfffcc 	andi	r2,r2,65535
 8232090:	1080010c 	andi	r2,r2,4
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 8232094:	1000031e 	bne	r2,zero,82320a4 <soconnect+0x68>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
       (sodisconnect(so) != 0)))
 8232098:	e13ffe17 	ldw	r4,-8(fp)
 823209c:	82320f40 	call	82320f4 <sodisconnect>
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
 82320a0:	10000326 	beq	r2,zero,82320b0 <soconnect+0x74>
       (sodisconnect(so) != 0)))
   {
      error = EISCONN;
 82320a4:	00801fc4 	movi	r2,127
 82320a8:	e0bffd15 	stw	r2,-12(fp)
 82320ac:	00000b06 	br	82320dc <soconnect+0xa0>
   }
   else
   {
      so->so_req = PRU_CONNECT;
 82320b0:	e0bffe17 	ldw	r2,-8(fp)
 82320b4:	00c00104 	movi	r3,4
 82320b8:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 82320bc:	e0bffe17 	ldw	r2,-8(fp)
 82320c0:	10800217 	ldw	r2,8(r2)
 82320c4:	10800317 	ldw	r2,12(r2)
 82320c8:	e1bfff17 	ldw	r6,-4(fp)
 82320cc:	000b883a 	mov	r5,zero
 82320d0:	e13ffe17 	ldw	r4,-8(fp)
 82320d4:	103ee83a 	callr	r2
 82320d8:	e0bffd15 	stw	r2,-12(fp)
   }
   return error;
 82320dc:	e0bffd17 	ldw	r2,-12(fp)
}
 82320e0:	e037883a 	mov	sp,fp
 82320e4:	dfc00117 	ldw	ra,4(sp)
 82320e8:	df000017 	ldw	fp,0(sp)
 82320ec:	dec00204 	addi	sp,sp,8
 82320f0:	f800283a 	ret

082320f4 <sodisconnect>:
 * RETURNS: 
 */

int
sodisconnect(struct socket * so)
{
 82320f4:	defffc04 	addi	sp,sp,-16
 82320f8:	dfc00315 	stw	ra,12(sp)
 82320fc:	df000215 	stw	fp,8(sp)
 8232100:	df000204 	addi	fp,sp,8
 8232104:	e13fff15 	stw	r4,-4(fp)
   int   error;

   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sodisconnect, so %lx so_state %x\n", so, so->so_state));

   if ((so->so_state & SS_ISCONNECTED) == 0) 
 8232108:	e0bfff17 	ldw	r2,-4(fp)
 823210c:	1080088b 	ldhu	r2,34(r2)
 8232110:	10bfffcc 	andi	r2,r2,65535
 8232114:	1080008c 	andi	r2,r2,2
 8232118:	1000031e 	bne	r2,zero,8232128 <sodisconnect+0x34>
   {
      error = ENOTCONN;
 823211c:	00802004 	movi	r2,128
 8232120:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 8232124:	00001306 	br	8232174 <sodisconnect+0x80>
   }
   if (so->so_state & SS_ISDISCONNECTING) 
 8232128:	e0bfff17 	ldw	r2,-4(fp)
 823212c:	1080088b 	ldhu	r2,34(r2)
 8232130:	10bfffcc 	andi	r2,r2,65535
 8232134:	1080020c 	andi	r2,r2,8
 8232138:	10000326 	beq	r2,zero,8232148 <sodisconnect+0x54>
   {
      error = EALREADY;
 823213c:	00801e04 	movi	r2,120
 8232140:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 8232144:	00000b06 	br	8232174 <sodisconnect+0x80>
   }
   so->so_req = PRU_DISCONNECT;
 8232148:	e0bfff17 	ldw	r2,-4(fp)
 823214c:	00c00184 	movi	r3,6
 8232150:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 8232154:	e0bfff17 	ldw	r2,-4(fp)
 8232158:	10800217 	ldw	r2,8(r2)
 823215c:	10800317 	ldw	r2,12(r2)
 8232160:	000d883a 	mov	r6,zero
 8232164:	000b883a 	mov	r5,zero
 8232168:	e13fff17 	ldw	r4,-4(fp)
 823216c:	103ee83a 	callr	r2
 8232170:	e0bffe15 	stw	r2,-8(fp)

bad:
   return (error);
 8232174:	e0bffe17 	ldw	r2,-8(fp)
}
 8232178:	e037883a 	mov	sp,fp
 823217c:	dfc00117 	ldw	ra,4(sp)
 8232180:	df000017 	ldw	fp,0(sp)
 8232184:	dec00204 	addi	sp,sp,8
 8232188:	f800283a 	ret

0823218c <sosend>:
sosend(struct socket *so, 
       struct mbuf *nam,      /* sockaddr, if UDP socket, NULL if TCP */
       char  *data,           /* data to send */
       int   *data_length,    /* IN/OUT  length of (remaining) data */
       int   flags)
{
 823218c:	defff204 	addi	sp,sp,-56
 8232190:	dfc00d15 	stw	ra,52(sp)
 8232194:	df000c15 	stw	fp,48(sp)
 8232198:	df000c04 	addi	fp,sp,48
 823219c:	e13ffc15 	stw	r4,-16(fp)
 82321a0:	e17ffd15 	stw	r5,-12(fp)
 82321a4:	e1bffe15 	stw	r6,-8(fp)
 82321a8:	e1ffff15 	stw	r7,-4(fp)
   struct mbuf *head = (struct mbuf *)NULL;
 82321ac:	e03ff415 	stw	zero,-48(fp)
   struct mbuf *m;
   int   space;
   int   resid;
   int   len;
   int   error = 0;
 82321b0:	e03ff815 	stw	zero,-32(fp)
   int   dontroute;
   int   first = 1;
 82321b4:	00800044 	movi	r2,1
 82321b8:	e0bff915 	stw	r2,-28(fp)

   resid = *data_length;
 82321bc:	e0bfff17 	ldw	r2,-4(fp)
 82321c0:	10800017 	ldw	r2,0(r2)
 82321c4:	e0bff715 	stw	r2,-36(fp)
    * However, space must be signed, as it might be less than 0
    * if we over-committed, and we must use a signed comparison
    * of space and resid.  On the other hand, a negative resid
    * causes us to loop sending 0-length segments to the protocol.
    */
   if (resid < 0)
 82321c8:	e0bff717 	ldw	r2,-36(fp)
 82321cc:	1000020e 	bge	r2,zero,82321d8 <sosend+0x4c>
      return (EINVAL);
 82321d0:	00800584 	movi	r2,22
 82321d4:	00013e06 	br	82326d0 <sosend+0x544>

   INET_TRACE (INETM_IO, ("INET:sosend: so %lx resid %d sb_hiwat %d so_state %x\n",
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
 82321d8:	e0bffc17 	ldw	r2,-16(fp)
 82321dc:	10800217 	ldw	r2,8(r2)
 82321e0:	1080010b 	ldhu	r2,4(r2)
 82321e4:	10bfffcc 	andi	r2,r2,65535
 82321e8:	1080004c 	andi	r2,r2,1
 82321ec:	10000726 	beq	r2,zero,823220c <sosend+0x80>
 82321f0:	e0bffc17 	ldw	r2,-16(fp)
 82321f4:	10801317 	ldw	r2,76(r2)
 82321f8:	1007883a 	mov	r3,r2
 82321fc:	e0bff717 	ldw	r2,-36(fp)
 8232200:	1880020e 	bge	r3,r2,823220c <sosend+0x80>
      return (EMSGSIZE);
 8232204:	00801e84 	movi	r2,122
 8232208:	00013106 	br	82326d0 <sosend+0x544>

   dontroute = (flags & MSG_DONTROUTE) &&
 823220c:	e0800217 	ldw	r2,8(fp)
 8232210:	1080010c 	andi	r2,r2,4
               ((so->so_options & SO_DONTROUTE) == 0) &&
 8232214:	10000c26 	beq	r2,zero,8232248 <sosend+0xbc>
 8232218:	e0bffc17 	ldw	r2,-16(fp)
 823221c:	10800417 	ldw	r2,16(r2)
 8232220:	1080040c 	andi	r2,r2,16
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
 8232224:	1000081e 	bne	r2,zero,8232248 <sosend+0xbc>
               ((so->so_options & SO_DONTROUTE) == 0) &&
               (so->so_proto->pr_flags & PR_ATOMIC);
 8232228:	e0bffc17 	ldw	r2,-16(fp)
 823222c:	10800217 	ldw	r2,8(r2)
 8232230:	1080010b 	ldhu	r2,4(r2)
 8232234:	10bfffcc 	andi	r2,r2,65535
 8232238:	1080004c 	andi	r2,r2,1

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
               ((so->so_options & SO_DONTROUTE) == 0) &&
 823223c:	10000226 	beq	r2,zero,8232248 <sosend+0xbc>
 8232240:	00800044 	movi	r2,1
 8232244:	00000106 	br	823224c <sosend+0xc0>
 8232248:	0005883a 	mov	r2,zero
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
 823224c:	e0bffa15 	stw	r2,-24(fp)
               (so->so_proto->pr_flags & PR_ATOMIC);

#define     snderr(errno)     {  error =  errno;   goto  release; }

restart:
   sblock(&so->so_snd);
 8232250:	00000406 	br	8232264 <sosend+0xd8>
 8232254:	e0bffc17 	ldw	r2,-16(fp)
 8232258:	10801904 	addi	r2,r2,100
 823225c:	1009883a 	mov	r4,r2
 8232260:	82293d80 	call	82293d8 <tcp_sleep>
 8232264:	e0bffc17 	ldw	r2,-16(fp)
 8232268:	1080190b 	ldhu	r2,100(r2)
 823226c:	10bfffcc 	andi	r2,r2,65535
 8232270:	1080004c 	andi	r2,r2,1
 8232274:	103ff71e 	bne	r2,zero,8232254 <sosend+0xc8>
 8232278:	e0bffc17 	ldw	r2,-16(fp)
 823227c:	1080190b 	ldhu	r2,100(r2)
 8232280:	10800054 	ori	r2,r2,1
 8232284:	1007883a 	mov	r3,r2
 8232288:	e0bffc17 	ldw	r2,-16(fp)
 823228c:	10c0190d 	sth	r3,100(r2)
   do 
   {
      if (so->so_error) 
 8232290:	e0bffc17 	ldw	r2,-16(fp)
 8232294:	10800617 	ldw	r2,24(r2)
 8232298:	10000626 	beq	r2,zero,82322b4 <sosend+0x128>
      {
         error = so->so_error;
 823229c:	e0bffc17 	ldw	r2,-16(fp)
 82322a0:	10800617 	ldw	r2,24(r2)
 82322a4:	e0bff815 	stw	r2,-32(fp)
         so->so_error = 0;          /* ??? */
 82322a8:	e0bffc17 	ldw	r2,-16(fp)
 82322ac:	10000615 	stw	zero,24(r2)
         goto release;
 82322b0:	0000f706 	br	8232690 <sosend+0x504>
      }
      if (so->so_state & SS_CANTSENDMORE)
 82322b4:	e0bffc17 	ldw	r2,-16(fp)
 82322b8:	1080088b 	ldhu	r2,34(r2)
 82322bc:	10bfffcc 	andi	r2,r2,65535
 82322c0:	1080040c 	andi	r2,r2,16
 82322c4:	10000326 	beq	r2,zero,82322d4 <sosend+0x148>
         snderr(EPIPE);
 82322c8:	00800804 	movi	r2,32
 82322cc:	e0bff815 	stw	r2,-32(fp)
 82322d0:	0000ef06 	br	8232690 <sosend+0x504>
      if ((so->so_state & SS_ISCONNECTED) == 0) 
 82322d4:	e0bffc17 	ldw	r2,-16(fp)
 82322d8:	1080088b 	ldhu	r2,34(r2)
 82322dc:	10bfffcc 	andi	r2,r2,65535
 82322e0:	1080008c 	andi	r2,r2,2
 82322e4:	10000e1e 	bne	r2,zero,8232320 <sosend+0x194>
      {
         if (so->so_proto->pr_flags & PR_CONNREQUIRED)
 82322e8:	e0bffc17 	ldw	r2,-16(fp)
 82322ec:	10800217 	ldw	r2,8(r2)
 82322f0:	1080010b 	ldhu	r2,4(r2)
 82322f4:	10bfffcc 	andi	r2,r2,65535
 82322f8:	1080010c 	andi	r2,r2,4
 82322fc:	10000326 	beq	r2,zero,823230c <sosend+0x180>
            snderr(ENOTCONN);
 8232300:	00802004 	movi	r2,128
 8232304:	e0bff815 	stw	r2,-32(fp)
 8232308:	0000e106 	br	8232690 <sosend+0x504>
         if (nam == 0)
 823230c:	e0bffd17 	ldw	r2,-12(fp)
 8232310:	1000031e 	bne	r2,zero,8232320 <sosend+0x194>
            snderr(EDESTADDRREQ);
 8232314:	00801e44 	movi	r2,121
 8232318:	e0bff815 	stw	r2,-32(fp)
 823231c:	0000dc06 	br	8232690 <sosend+0x504>
      }
      if (flags & MSG_OOB)
 8232320:	e0800217 	ldw	r2,8(fp)
 8232324:	1080004c 	andi	r2,r2,1
 8232328:	10000326 	beq	r2,zero,8232338 <sosend+0x1ac>
         space = 1024;
 823232c:	00810004 	movi	r2,1024
 8232330:	e0bff615 	stw	r2,-40(fp)
 8232334:	00004706 	br	8232454 <sosend+0x2c8>
      else 
      {
         space = (int)sbspace(&so->so_snd);
 8232338:	e0bffc17 	ldw	r2,-16(fp)
 823233c:	10801317 	ldw	r2,76(r2)
 8232340:	1007883a 	mov	r3,r2
 8232344:	e0bffc17 	ldw	r2,-16(fp)
 8232348:	10801217 	ldw	r2,72(r2)
 823234c:	1885c83a 	sub	r2,r3,r2
 8232350:	10000616 	blt	r2,zero,823236c <sosend+0x1e0>
 8232354:	e0bffc17 	ldw	r2,-16(fp)
 8232358:	10c01317 	ldw	r3,76(r2)
 823235c:	e0bffc17 	ldw	r2,-16(fp)
 8232360:	10801217 	ldw	r2,72(r2)
 8232364:	1885c83a 	sub	r2,r3,r2
 8232368:	00000106 	br	8232370 <sosend+0x1e4>
 823236c:	0005883a 	mov	r2,zero
 8232370:	e0bff615 	stw	r2,-40(fp)
         if ((sosendallatonce(so) && (space < resid)) ||
 8232374:	e0bffc17 	ldw	r2,-16(fp)
 8232378:	10800217 	ldw	r2,8(r2)
 823237c:	1080010b 	ldhu	r2,4(r2)
 8232380:	10bfffcc 	andi	r2,r2,65535
 8232384:	1080004c 	andi	r2,r2,1
 8232388:	10000326 	beq	r2,zero,8232398 <sosend+0x20c>
 823238c:	e0fff617 	ldw	r3,-40(fp)
 8232390:	e0bff717 	ldw	r2,-36(fp)
 8232394:	18801216 	blt	r3,r2,82323e0 <sosend+0x254>
 8232398:	e0bff717 	ldw	r2,-36(fp)
 823239c:	10815e10 	cmplti	r2,r2,1400
 82323a0:	10002c1e 	bne	r2,zero,8232454 <sosend+0x2c8>
             ((resid >= CLBYTES) && (space < CLBYTES) &&
 82323a4:	e0bff617 	ldw	r2,-40(fp)
 82323a8:	10815e08 	cmpgei	r2,r2,1400
 82323ac:	1000291e 	bne	r2,zero,8232454 <sosend+0x2c8>
              (so->so_snd.sb_cc >= CLBYTES) &&
 82323b0:	e0bffc17 	ldw	r2,-16(fp)
 82323b4:	10801217 	ldw	r2,72(r2)
         space = 1024;
      else 
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
 82323b8:	10815e30 	cmpltui	r2,r2,1400
 82323bc:	1000251e 	bne	r2,zero,8232454 <sosend+0x2c8>
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
 82323c0:	e0bffc17 	ldw	r2,-16(fp)
 82323c4:	1080088b 	ldhu	r2,34(r2)
 82323c8:	10bfffcc 	andi	r2,r2,65535
 82323cc:	1080400c 	andi	r2,r2,256
      else 
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
 82323d0:	1000201e 	bne	r2,zero,8232454 <sosend+0x2c8>
              ((so->so_state & SS_NBIO) == 0) &&
              ((flags & MSG_DONTWAIT) == 0)))
 82323d4:	e0800217 	ldw	r2,8(fp)
 82323d8:	1080080c 	andi	r2,r2,32
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
 82323dc:	10001d1e 	bne	r2,zero,8232454 <sosend+0x2c8>
              ((flags & MSG_DONTWAIT) == 0)))
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 82323e0:	e0bffc17 	ldw	r2,-16(fp)
 82323e4:	1080088b 	ldhu	r2,34(r2)
 82323e8:	10bfffcc 	andi	r2,r2,65535
 82323ec:	1080400c 	andi	r2,r2,256
 82323f0:	1000031e 	bne	r2,zero,8232400 <sosend+0x274>
 82323f4:	e0800217 	ldw	r2,8(fp)
 82323f8:	1080080c 	andi	r2,r2,32
 82323fc:	10000526 	beq	r2,zero,8232414 <sosend+0x288>
            {
               if (first)
 8232400:	e0bff917 	ldw	r2,-28(fp)
 8232404:	10009d26 	beq	r2,zero,823267c <sosend+0x4f0>
                  error = EWOULDBLOCK;
 8232408:	008002c4 	movi	r2,11
 823240c:	e0bff815 	stw	r2,-32(fp)
               goto release;
 8232410:	00009a06 	br	823267c <sosend+0x4f0>
            }
            sbunlock(&so->so_snd);
 8232414:	e0bffc17 	ldw	r2,-16(fp)
 8232418:	10c0190b 	ldhu	r3,100(r2)
 823241c:	00bfff84 	movi	r2,-2
 8232420:	1884703a 	and	r2,r3,r2
 8232424:	1007883a 	mov	r3,r2
 8232428:	e0bffc17 	ldw	r2,-16(fp)
 823242c:	10c0190d 	sth	r3,100(r2)
 8232430:	e0bffc17 	ldw	r2,-16(fp)
 8232434:	10801904 	addi	r2,r2,100
 8232438:	1009883a 	mov	r4,r2
 823243c:	822954c0 	call	822954c <tcp_wakeup>
            sbwait(&so->so_snd);
 8232440:	e0bffc17 	ldw	r2,-16(fp)
 8232444:	10801204 	addi	r2,r2,72
 8232448:	1009883a 	mov	r4,r2
 823244c:	82340580 	call	8234058 <sbwait>
            goto restart;
 8232450:	003f7f06 	br	8232250 <sosend+0xc4>
         }
      }
      if ( space <= 0 ) 
 8232454:	e0bff617 	ldw	r2,-40(fp)
 8232458:	00805e16 	blt	zero,r2,82325d4 <sosend+0x448>
      {
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 823245c:	e0bffc17 	ldw	r2,-16(fp)
 8232460:	1080088b 	ldhu	r2,34(r2)
 8232464:	10bfffcc 	andi	r2,r2,65535
 8232468:	1080400c 	andi	r2,r2,256
 823246c:	1000031e 	bne	r2,zero,823247c <sosend+0x2f0>
 8232470:	e0800217 	ldw	r2,8(fp)
 8232474:	1080080c 	andi	r2,r2,32
 8232478:	10000526 	beq	r2,zero,8232490 <sosend+0x304>
         {
            if (first)     /* report first error */
 823247c:	e0bff917 	ldw	r2,-28(fp)
 8232480:	10008026 	beq	r2,zero,8232684 <sosend+0x4f8>
               error = EWOULDBLOCK;
 8232484:	008002c4 	movi	r2,11
 8232488:	e0bff815 	stw	r2,-32(fp)
            goto release;
 823248c:	00007d06 	br	8232684 <sosend+0x4f8>
         }
         /* If blocking socket, let someone else run */
         sbunlock(&so->so_snd);
 8232490:	e0bffc17 	ldw	r2,-16(fp)
 8232494:	10c0190b 	ldhu	r3,100(r2)
 8232498:	00bfff84 	movi	r2,-2
 823249c:	1884703a 	and	r2,r3,r2
 82324a0:	1007883a 	mov	r3,r2
 82324a4:	e0bffc17 	ldw	r2,-16(fp)
 82324a8:	10c0190d 	sth	r3,100(r2)
 82324ac:	e0bffc17 	ldw	r2,-16(fp)
 82324b0:	10801904 	addi	r2,r2,100
 82324b4:	1009883a 	mov	r4,r2
 82324b8:	822954c0 	call	822954c <tcp_wakeup>
         sbwait(&so->so_snd);
 82324bc:	e0bffc17 	ldw	r2,-16(fp)
 82324c0:	10801204 	addi	r2,r2,72
 82324c4:	1009883a 	mov	r4,r2
 82324c8:	82340580 	call	8234058 <sbwait>
         goto restart;
 82324cc:	003f6006 	br	8232250 <sosend+0xc4>
      }

      while (space > 0) 
      {
         len = resid;
 82324d0:	e0bff717 	ldw	r2,-36(fp)
 82324d4:	e0bffb15 	stw	r2,-20(fp)
         if ( so->so_type == SOCK_STREAM )
 82324d8:	e0bffc17 	ldw	r2,-16(fp)
 82324dc:	10800983 	ldbu	r2,38(r2)
 82324e0:	10803fcc 	andi	r2,r2,255
 82324e4:	1080201c 	xori	r2,r2,128
 82324e8:	10bfe004 	addi	r2,r2,-128
 82324ec:	10800058 	cmpnei	r2,r2,1
 82324f0:	1000171e 	bne	r2,zero,8232550 <sosend+0x3c4>
         {
            m = m_getwithdata(MT_TXDATA, len);
 82324f4:	e17ffb17 	ldw	r5,-20(fp)
 82324f8:	01000084 	movi	r4,2
 82324fc:	822e2280 	call	822e228 <m_getnbuf>
 8232500:	e0bff515 	stw	r2,-44(fp)
            if (!m)   
 8232504:	e0bff517 	ldw	r2,-44(fp)
 8232508:	1000031e 	bne	r2,zero,8232518 <sosend+0x38c>
               snderr(ENOBUFS);
 823250c:	00801a44 	movi	r2,105
 8232510:	e0bff815 	stw	r2,-32(fp)
 8232514:	00005e06 	br	8232690 <sosend+0x504>
            MEMCPY(m->m_data, data, len);
 8232518:	e0bff517 	ldw	r2,-44(fp)
 823251c:	10800317 	ldw	r2,12(r2)
 8232520:	e0fffb17 	ldw	r3,-20(fp)
 8232524:	180d883a 	mov	r6,r3
 8232528:	e17ffe17 	ldw	r5,-8(fp)
 823252c:	1009883a 	mov	r4,r2
 8232530:	8202e8c0 	call	8202e8c <memcpy>
            so->so_snd.sb_flags |= SB_MBCOMP;   /* allow compression */
 8232534:	e0bffc17 	ldw	r2,-16(fp)
 8232538:	1080190b 	ldhu	r2,100(r2)
 823253c:	10802014 	ori	r2,r2,128
 8232540:	1007883a 	mov	r3,r2
 8232544:	e0bffc17 	ldw	r2,-16(fp)
 8232548:	10c0190d 	sth	r3,100(r2)
 823254c:	00000706 	br	823256c <sosend+0x3e0>
         }
         else
         {
            m = m_get (M_WAIT, MT_TXDATA);
 8232550:	000b883a 	mov	r5,zero
 8232554:	01000084 	movi	r4,2
 8232558:	822e2280 	call	822e228 <m_getnbuf>
 823255c:	e0bff515 	stw	r2,-44(fp)
            m->m_data = data;
 8232560:	e0bff517 	ldw	r2,-44(fp)
 8232564:	e0fffe17 	ldw	r3,-8(fp)
 8232568:	10c00315 	stw	r3,12(r2)
         }
         INET_TRACE (INETM_IO,
          ("sosend:got %d bytes so %lx mlen %d, off %d mtod %x\n",
             len, so, m->m_len, m->m_off, mtod (m, caddr_t)));

         *data_length -= len;
 823256c:	e0bfff17 	ldw	r2,-4(fp)
 8232570:	10c00017 	ldw	r3,0(r2)
 8232574:	e0bffb17 	ldw	r2,-20(fp)
 8232578:	1887c83a 	sub	r3,r3,r2
 823257c:	e0bfff17 	ldw	r2,-4(fp)
 8232580:	10c00015 	stw	r3,0(r2)
         resid -= len;
 8232584:	e0fff717 	ldw	r3,-36(fp)
 8232588:	e0bffb17 	ldw	r2,-20(fp)
 823258c:	1885c83a 	sub	r2,r3,r2
 8232590:	e0bff715 	stw	r2,-36(fp)
         data += len;
 8232594:	e0bffb17 	ldw	r2,-20(fp)
 8232598:	e0fffe17 	ldw	r3,-8(fp)
 823259c:	1885883a 	add	r2,r3,r2
 82325a0:	e0bffe15 	stw	r2,-8(fp)
         m->m_len = len;
 82325a4:	e0fffb17 	ldw	r3,-20(fp)
 82325a8:	e0bff517 	ldw	r2,-44(fp)
 82325ac:	10c00215 	stw	r3,8(r2)
         if (head == (struct mbuf *)NULL)
 82325b0:	e0bff417 	ldw	r2,-48(fp)
 82325b4:	1000021e 	bne	r2,zero,82325c0 <sosend+0x434>
            head = m;
 82325b8:	e0bff517 	ldw	r2,-44(fp)
 82325bc:	e0bff415 	stw	r2,-48(fp)
         if (error)
 82325c0:	e0bff817 	ldw	r2,-32(fp)
 82325c4:	1000311e 	bne	r2,zero,823268c <sosend+0x500>
            goto release;
         if (*data_length <= 0)
 82325c8:	e0bfff17 	ldw	r2,-4(fp)
 82325cc:	10800017 	ldw	r2,0(r2)
 82325d0:	0080030e 	bge	zero,r2,82325e0 <sosend+0x454>
         sbunlock(&so->so_snd);
         sbwait(&so->so_snd);
         goto restart;
      }

      while (space > 0) 
 82325d4:	e0bff617 	ldw	r2,-40(fp)
 82325d8:	00bfbd16 	blt	zero,r2,82324d0 <sosend+0x344>
 82325dc:	00000106 	br	82325e4 <sosend+0x458>
         if (head == (struct mbuf *)NULL)
            head = m;
         if (error)
            goto release;
         if (*data_length <= 0)
            break;
 82325e0:	0001883a 	nop
      }

      if (dontroute)
 82325e4:	e0bffa17 	ldw	r2,-24(fp)
 82325e8:	10000526 	beq	r2,zero,8232600 <sosend+0x474>
         so->so_options |= SO_DONTROUTE;
 82325ec:	e0bffc17 	ldw	r2,-16(fp)
 82325f0:	10800417 	ldw	r2,16(r2)
 82325f4:	10c00414 	ori	r3,r2,16
 82325f8:	e0bffc17 	ldw	r2,-16(fp)
 82325fc:	10c00415 	stw	r3,16(r2)

      so->so_req = (flags & MSG_OOB) ? PRU_SENDOOB : PRU_SEND;
 8232600:	e0800217 	ldw	r2,8(fp)
 8232604:	1080004c 	andi	r2,r2,1
 8232608:	10000226 	beq	r2,zero,8232614 <sosend+0x488>
 823260c:	00800384 	movi	r2,14
 8232610:	00000106 	br	8232618 <sosend+0x48c>
 8232614:	00800244 	movi	r2,9
 8232618:	e0fffc17 	ldw	r3,-16(fp)
 823261c:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so, head, nam);
 8232620:	e0bffc17 	ldw	r2,-16(fp)
 8232624:	10800217 	ldw	r2,8(r2)
 8232628:	10800317 	ldw	r2,12(r2)
 823262c:	e1bffd17 	ldw	r6,-12(fp)
 8232630:	e17ff417 	ldw	r5,-48(fp)
 8232634:	e13ffc17 	ldw	r4,-16(fp)
 8232638:	103ee83a 	callr	r2
 823263c:	e0bff815 	stw	r2,-32(fp)

      if (dontroute)
 8232640:	e0bffa17 	ldw	r2,-24(fp)
 8232644:	10000626 	beq	r2,zero,8232660 <sosend+0x4d4>
         so->so_options &= ~SO_DONTROUTE;
 8232648:	e0bffc17 	ldw	r2,-16(fp)
 823264c:	10c00417 	ldw	r3,16(r2)
 8232650:	00bffbc4 	movi	r2,-17
 8232654:	1886703a 	and	r3,r3,r2
 8232658:	e0bffc17 	ldw	r2,-16(fp)
 823265c:	10c00415 	stw	r3,16(r2)

      head = (struct mbuf *)NULL;
 8232660:	e03ff415 	stw	zero,-48(fp)
      first = 0;
 8232664:	e03ff915 	stw	zero,-28(fp)
   } while ((resid != 0) && (error == 0));
 8232668:	e0bff717 	ldw	r2,-36(fp)
 823266c:	10000826 	beq	r2,zero,8232690 <sosend+0x504>
 8232670:	e0bff817 	ldw	r2,-32(fp)
 8232674:	103f0626 	beq	r2,zero,8232290 <sosend+0x104>
 8232678:	00000506 	br	8232690 <sosend+0x504>
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
            {
               if (first)
                  error = EWOULDBLOCK;
               goto release;
 823267c:	0001883a 	nop
 8232680:	00000306 	br	8232690 <sosend+0x504>
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
         {
            if (first)     /* report first error */
               error = EWOULDBLOCK;
            goto release;
 8232684:	0001883a 	nop
 8232688:	00000106 	br	8232690 <sosend+0x504>
         data += len;
         m->m_len = len;
         if (head == (struct mbuf *)NULL)
            head = m;
         if (error)
            goto release;
 823268c:	0001883a 	nop
      head = (struct mbuf *)NULL;
      first = 0;
   } while ((resid != 0) && (error == 0));

release:
   sbunlock(&so->so_snd);  
 8232690:	e0bffc17 	ldw	r2,-16(fp)
 8232694:	10c0190b 	ldhu	r3,100(r2)
 8232698:	00bfff84 	movi	r2,-2
 823269c:	1884703a 	and	r2,r3,r2
 82326a0:	1007883a 	mov	r3,r2
 82326a4:	e0bffc17 	ldw	r2,-16(fp)
 82326a8:	10c0190d 	sth	r3,100(r2)
 82326ac:	e0bffc17 	ldw	r2,-16(fp)
 82326b0:	10801904 	addi	r2,r2,100
 82326b4:	1009883a 	mov	r4,r2
 82326b8:	822954c0 	call	822954c <tcp_wakeup>
   if (head)
 82326bc:	e0bff417 	ldw	r2,-48(fp)
 82326c0:	10000226 	beq	r2,zero,82326cc <sosend+0x540>
      m_freem(head);
 82326c4:	e13ff417 	ldw	r4,-48(fp)
 82326c8:	822e4b80 	call	822e4b8 <m_freem>
   return error;
 82326cc:	e0bff817 	ldw	r2,-32(fp)
}
 82326d0:	e037883a 	mov	sp,fp
 82326d4:	dfc00117 	ldw	ra,4(sp)
 82326d8:	df000017 	ldw	fp,0(sp)
 82326dc:	dec00204 	addi	sp,sp,8
 82326e0:	f800283a 	ret

082326e4 <soreceive>:
soreceive(struct socket * so, 
   struct mbuf **aname,
   char * data,
   int * datalen,
   int   flags)
{
 82326e4:	defff204 	addi	sp,sp,-56
 82326e8:	dfc00d15 	stw	ra,52(sp)
 82326ec:	df000c15 	stw	fp,48(sp)
 82326f0:	df000c04 	addi	fp,sp,48
 82326f4:	e13ffc15 	stw	r4,-16(fp)
 82326f8:	e17ffd15 	stw	r5,-12(fp)
 82326fc:	e1bffe15 	stw	r6,-8(fp)
 8232700:	e1ffff15 	stw	r7,-4(fp)
   struct mbuf *  m;
   int   len;
   int   error =  0;
 8232704:	e03ff615 	stw	zero,-40(fp)
   int   offset;
   struct protosw *  pr =  so->so_proto;
 8232708:	e0bffc17 	ldw	r2,-16(fp)
 823270c:	10800217 	ldw	r2,8(r2)
 8232710:	e0bffa15 	stw	r2,-24(fp)
   struct mbuf *  nextrecord;
   int   moff;
   int   lflags;

   if (aname)
 8232714:	e0bffd17 	ldw	r2,-12(fp)
 8232718:	10000226 	beq	r2,zero,8232724 <soreceive+0x40>
      *aname = 0;
 823271c:	e0bffd17 	ldw	r2,-12(fp)
 8232720:	10000015 	stw	zero,0(r2)
   if (flags & MSG_OOB) 
 8232724:	e0800217 	ldw	r2,8(fp)
 8232728:	1080004c 	andi	r2,r2,1
 823272c:	10004626 	beq	r2,zero,8232848 <soreceive+0x164>
   {
      m = m_get (M_WAIT, MT_RXDATA);
 8232730:	000b883a 	mov	r5,zero
 8232734:	01000044 	movi	r4,1
 8232738:	822e2280 	call	822e228 <m_getnbuf>
 823273c:	e0bff415 	stw	r2,-48(fp)
      if (m == NULL)
 8232740:	e0bff417 	ldw	r2,-48(fp)
 8232744:	1000021e 	bne	r2,zero,8232750 <soreceive+0x6c>
         return ENOBUFS;
 8232748:	00801a44 	movi	r2,105
 823274c:	0001b306 	br	8232e1c <soreceive+0x738>
      lflags = flags & MSG_PEEK;
 8232750:	e0800217 	ldw	r2,8(fp)
 8232754:	1080008c 	andi	r2,r2,2
 8232758:	e0bffb15 	stw	r2,-20(fp)

      so->so_req = PRU_RCVOOB;
 823275c:	e0bffc17 	ldw	r2,-16(fp)
 8232760:	00c00344 	movi	r3,13
 8232764:	10c00715 	stw	r3,28(r2)
      error = (*pr->pr_usrreq)(so, m, LONG2MBUF((long)lflags));
 8232768:	e0bffa17 	ldw	r2,-24(fp)
 823276c:	10800317 	ldw	r2,12(r2)
 8232770:	e0fffb17 	ldw	r3,-20(fp)
 8232774:	180d883a 	mov	r6,r3
 8232778:	e17ff417 	ldw	r5,-48(fp)
 823277c:	e13ffc17 	ldw	r4,-16(fp)
 8232780:	103ee83a 	callr	r2
 8232784:	e0bff615 	stw	r2,-40(fp)
      if (error == 0)
 8232788:	e0bff617 	ldw	r2,-40(fp)
 823278c:	1000231e 	bne	r2,zero,823281c <soreceive+0x138>
      {
         do 
         {
            len = *datalen;
 8232790:	e0bfff17 	ldw	r2,-4(fp)
 8232794:	10800017 	ldw	r2,0(r2)
 8232798:	e0bff515 	stw	r2,-44(fp)
            if (len > (int)m->m_len)
 823279c:	e0bff417 	ldw	r2,-48(fp)
 82327a0:	10800217 	ldw	r2,8(r2)
 82327a4:	1007883a 	mov	r3,r2
 82327a8:	e0bff517 	ldw	r2,-44(fp)
 82327ac:	1880030e 	bge	r3,r2,82327bc <soreceive+0xd8>
               len = m->m_len;
 82327b0:	e0bff417 	ldw	r2,-48(fp)
 82327b4:	10800217 	ldw	r2,8(r2)
 82327b8:	e0bff515 	stw	r2,-44(fp)

            MEMCPY(data, mtod(m, char*), len);
 82327bc:	e0bff417 	ldw	r2,-48(fp)
 82327c0:	10800317 	ldw	r2,12(r2)
 82327c4:	e0fff517 	ldw	r3,-44(fp)
 82327c8:	180d883a 	mov	r6,r3
 82327cc:	100b883a 	mov	r5,r2
 82327d0:	e13ffe17 	ldw	r4,-8(fp)
 82327d4:	8202e8c0 	call	8202e8c <memcpy>
            data += len;
 82327d8:	e0bff517 	ldw	r2,-44(fp)
 82327dc:	e0fffe17 	ldw	r3,-8(fp)
 82327e0:	1885883a 	add	r2,r3,r2
 82327e4:	e0bffe15 	stw	r2,-8(fp)
            *datalen = len;
 82327e8:	e0bfff17 	ldw	r2,-4(fp)
 82327ec:	e0fff517 	ldw	r3,-44(fp)
 82327f0:	10c00015 	stw	r3,0(r2)
            m = m_free(m);
 82327f4:	e13ff417 	ldw	r4,-48(fp)
 82327f8:	822e3b00 	call	822e3b0 <m_free>
 82327fc:	e0bff415 	stw	r2,-48(fp)
         } while (*datalen && (error == 0) && m);
 8232800:	e0bfff17 	ldw	r2,-4(fp)
 8232804:	10800017 	ldw	r2,0(r2)
 8232808:	10000426 	beq	r2,zero,823281c <soreceive+0x138>
 823280c:	e0bff617 	ldw	r2,-40(fp)
 8232810:	1000021e 	bne	r2,zero,823281c <soreceive+0x138>
 8232814:	e0bff417 	ldw	r2,-48(fp)
 8232818:	103fdd1e 	bne	r2,zero,8232790 <soreceive+0xac>
      }

      if (m)
 823281c:	e0bff417 	ldw	r2,-48(fp)
 8232820:	10000226 	beq	r2,zero,823282c <soreceive+0x148>
         m_freem(m);
 8232824:	e13ff417 	ldw	r4,-48(fp)
 8232828:	822e4b80 	call	822e4b8 <m_freem>
      return (error);
 823282c:	e0bff617 	ldw	r2,-40(fp)
 8232830:	00017a06 	br	8232e1c <soreceive+0x738>
   }

restart:
   sblock (&so->so_rcv);
 8232834:	00000406 	br	8232848 <soreceive+0x164>
 8232838:	e0bffc17 	ldw	r2,-16(fp)
 823283c:	10801104 	addi	r2,r2,68
 8232840:	1009883a 	mov	r4,r2
 8232844:	82293d80 	call	82293d8 <tcp_sleep>
 8232848:	e0bffc17 	ldw	r2,-16(fp)
 823284c:	1080110b 	ldhu	r2,68(r2)
 8232850:	10bfffcc 	andi	r2,r2,65535
 8232854:	1080004c 	andi	r2,r2,1
 8232858:	103ff71e 	bne	r2,zero,8232838 <soreceive+0x154>
 823285c:	e0bffc17 	ldw	r2,-16(fp)
 8232860:	1080110b 	ldhu	r2,68(r2)
 8232864:	10800054 	ori	r2,r2,1
 8232868:	1007883a 	mov	r3,r2
 823286c:	e0bffc17 	ldw	r2,-16(fp)
 8232870:	10c0110d 	sth	r3,68(r2)
   INET_TRACE (INETM_IO,
    ("INET:soreceive sbcc %d soerror %d so_state %d *datalen %d\n",
    so->so_rcv.sb_cc, so->so_error, so->so_state, *datalen));

   /* If no data is ready, see if we should wait or return */
   if (so->so_rcv.sb_cc == 0) 
 8232874:	e0bffc17 	ldw	r2,-16(fp)
 8232878:	10800a17 	ldw	r2,40(r2)
 823287c:	10003a1e 	bne	r2,zero,8232968 <soreceive+0x284>
   {
      if (so->so_error) 
 8232880:	e0bffc17 	ldw	r2,-16(fp)
 8232884:	10800617 	ldw	r2,24(r2)
 8232888:	10000626 	beq	r2,zero,82328a4 <soreceive+0x1c0>
      {
         error = so->so_error;
 823288c:	e0bffc17 	ldw	r2,-16(fp)
 8232890:	10800617 	ldw	r2,24(r2)
 8232894:	e0bff615 	stw	r2,-40(fp)
         so->so_error = 0;
 8232898:	e0bffc17 	ldw	r2,-16(fp)
 823289c:	10000615 	stw	zero,24(r2)
         goto release;
 82328a0:	00015206 	br	8232dec <soreceive+0x708>
      }
      if (so->so_state & SS_CANTRCVMORE)
 82328a4:	e0bffc17 	ldw	r2,-16(fp)
 82328a8:	1080088b 	ldhu	r2,34(r2)
 82328ac:	10bfffcc 	andi	r2,r2,65535
 82328b0:	1080080c 	andi	r2,r2,32
 82328b4:	10014a1e 	bne	r2,zero,8232de0 <soreceive+0x6fc>
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 82328b8:	e0bffc17 	ldw	r2,-16(fp)
 82328bc:	1080088b 	ldhu	r2,34(r2)
 82328c0:	10bfffcc 	andi	r2,r2,65535
 82328c4:	1080008c 	andi	r2,r2,2
 82328c8:	1000091e 	bne	r2,zero,82328f0 <soreceive+0x20c>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
 82328cc:	e0bffc17 	ldw	r2,-16(fp)
 82328d0:	10800217 	ldw	r2,8(r2)
 82328d4:	1080010b 	ldhu	r2,4(r2)
 82328d8:	10bfffcc 	andi	r2,r2,65535
 82328dc:	1080010c 	andi	r2,r2,4
         so->so_error = 0;
         goto release;
      }
      if (so->so_state & SS_CANTRCVMORE)
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 82328e0:	10000326 	beq	r2,zero,82328f0 <soreceive+0x20c>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
      {
         error = ENOTCONN;
 82328e4:	00802004 	movi	r2,128
 82328e8:	e0bff615 	stw	r2,-40(fp)
         goto release;
 82328ec:	00013f06 	br	8232dec <soreceive+0x708>
      }
      if (*datalen == 0)
 82328f0:	e0bfff17 	ldw	r2,-4(fp)
 82328f4:	10800017 	ldw	r2,0(r2)
 82328f8:	10013b26 	beq	r2,zero,8232de8 <soreceive+0x704>
         goto release;
      if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT)) 
 82328fc:	e0bffc17 	ldw	r2,-16(fp)
 8232900:	1080088b 	ldhu	r2,34(r2)
 8232904:	10bfffcc 	andi	r2,r2,65535
 8232908:	1080400c 	andi	r2,r2,256
 823290c:	1000031e 	bne	r2,zero,823291c <soreceive+0x238>
 8232910:	e0800217 	ldw	r2,8(fp)
 8232914:	1080080c 	andi	r2,r2,32
 8232918:	10000326 	beq	r2,zero,8232928 <soreceive+0x244>
      {
         error = EWOULDBLOCK;
 823291c:	008002c4 	movi	r2,11
 8232920:	e0bff615 	stw	r2,-40(fp)
         goto release;
 8232924:	00013106 	br	8232dec <soreceive+0x708>
      }
      sbunlock(&so->so_rcv);
 8232928:	e0bffc17 	ldw	r2,-16(fp)
 823292c:	10c0110b 	ldhu	r3,68(r2)
 8232930:	00bfff84 	movi	r2,-2
 8232934:	1884703a 	and	r2,r3,r2
 8232938:	1007883a 	mov	r3,r2
 823293c:	e0bffc17 	ldw	r2,-16(fp)
 8232940:	10c0110d 	sth	r3,68(r2)
 8232944:	e0bffc17 	ldw	r2,-16(fp)
 8232948:	10801104 	addi	r2,r2,68
 823294c:	1009883a 	mov	r4,r2
 8232950:	822954c0 	call	822954c <tcp_wakeup>
      sbwait(&so->so_rcv);
 8232954:	e0bffc17 	ldw	r2,-16(fp)
 8232958:	10800a04 	addi	r2,r2,40
 823295c:	1009883a 	mov	r4,r2
 8232960:	82340580 	call	8234058 <sbwait>
      goto restart;
 8232964:	003fb306 	br	8232834 <soreceive+0x150>
   }
   m = so->so_rcv.sb_mb;
 8232968:	e0bffc17 	ldw	r2,-16(fp)
 823296c:	10801017 	ldw	r2,64(r2)
 8232970:	e0bff415 	stw	r2,-48(fp)
   if (m == 0)
 8232974:	e0bff417 	ldw	r2,-48(fp)
 8232978:	1000031e 	bne	r2,zero,8232988 <soreceive+0x2a4>
      panic("sorecv 1");
 823297c:	01020974 	movhi	r4,2085
 8232980:	21038404 	addi	r4,r4,3600
 8232984:	8228aec0 	call	8228aec <panic>
   nextrecord = m->m_act;
 8232988:	e0bff417 	ldw	r2,-48(fp)
 823298c:	10800717 	ldw	r2,28(r2)
 8232990:	e0bff815 	stw	r2,-32(fp)
   if (pr->pr_flags & PR_ADDR) 
 8232994:	e0bffa17 	ldw	r2,-24(fp)
 8232998:	1080010b 	ldhu	r2,4(r2)
 823299c:	10bfffcc 	andi	r2,r2,65535
 82329a0:	1080008c 	andi	r2,r2,2
 82329a4:	10004226 	beq	r2,zero,8232ab0 <soreceive+0x3cc>
   {
      if (m->m_type != MT_SONAME) 
 82329a8:	e0bff417 	ldw	r2,-48(fp)
 82329ac:	10800817 	ldw	r2,32(r2)
 82329b0:	10800260 	cmpeqi	r2,r2,9
 82329b4:	1000091e 	bne	r2,zero,82329dc <soreceive+0x2f8>
      {
         dprintf ("sorecv:type %d not nam", m->m_type);
 82329b8:	e0bff417 	ldw	r2,-48(fp)
 82329bc:	10800817 	ldw	r2,32(r2)
 82329c0:	100b883a 	mov	r5,r2
 82329c4:	01020974 	movhi	r4,2085
 82329c8:	21038704 	addi	r4,r4,3612
 82329cc:	820331c0 	call	820331c <printf>
         panic("sorecv 2");
 82329d0:	01020974 	movhi	r4,2085
 82329d4:	21038d04 	addi	r4,r4,3636
 82329d8:	8228aec0 	call	8228aec <panic>
      }
      if (flags & MSG_PEEK) 
 82329dc:	e0800217 	ldw	r2,8(fp)
 82329e0:	1080008c 	andi	r2,r2,2
 82329e4:	10000f26 	beq	r2,zero,8232a24 <soreceive+0x340>
      {
         if (aname)
 82329e8:	e0bffd17 	ldw	r2,-12(fp)
 82329ec:	10000926 	beq	r2,zero,8232a14 <soreceive+0x330>
            *aname = m_copy (m, 0, m->m_len);
 82329f0:	e0bff417 	ldw	r2,-48(fp)
 82329f4:	10800217 	ldw	r2,8(r2)
 82329f8:	100d883a 	mov	r6,r2
 82329fc:	000b883a 	mov	r5,zero
 8232a00:	e13ff417 	ldw	r4,-48(fp)
 8232a04:	822e4fc0 	call	822e4fc <m_copy>
 8232a08:	1007883a 	mov	r3,r2
 8232a0c:	e0bffd17 	ldw	r2,-12(fp)
 8232a10:	10c00015 	stw	r3,0(r2)
         m = m->m_next;
 8232a14:	e0bff417 	ldw	r2,-48(fp)
 8232a18:	10800617 	ldw	r2,24(r2)
 8232a1c:	e0bff415 	stw	r2,-48(fp)
 8232a20:	00002306 	br	8232ab0 <soreceive+0x3cc>
      } else 
      {
         sbfree (&so->so_rcv, m);
 8232a24:	e0bffc17 	ldw	r2,-16(fp)
 8232a28:	10c00a17 	ldw	r3,40(r2)
 8232a2c:	e0bff417 	ldw	r2,-48(fp)
 8232a30:	10800217 	ldw	r2,8(r2)
 8232a34:	1887c83a 	sub	r3,r3,r2
 8232a38:	e0bffc17 	ldw	r2,-16(fp)
 8232a3c:	10c00a15 	stw	r3,40(r2)
         if (aname) 
 8232a40:	e0bffd17 	ldw	r2,-12(fp)
 8232a44:	10000d26 	beq	r2,zero,8232a7c <soreceive+0x398>
         {
            *aname = m;
 8232a48:	e0bffd17 	ldw	r2,-12(fp)
 8232a4c:	e0fff417 	ldw	r3,-48(fp)
 8232a50:	10c00015 	stw	r3,0(r2)
            m = m->m_next;
 8232a54:	e0bff417 	ldw	r2,-48(fp)
 8232a58:	10800617 	ldw	r2,24(r2)
 8232a5c:	e0bff415 	stw	r2,-48(fp)
            (*aname)->m_next = 0;
 8232a60:	e0bffd17 	ldw	r2,-12(fp)
 8232a64:	10800017 	ldw	r2,0(r2)
 8232a68:	10000615 	stw	zero,24(r2)
            so->so_rcv.sb_mb = m;
 8232a6c:	e0bffc17 	ldw	r2,-16(fp)
 8232a70:	e0fff417 	ldw	r3,-48(fp)
 8232a74:	10c01015 	stw	r3,64(r2)
 8232a78:	00000806 	br	8232a9c <soreceive+0x3b8>
         } else 
         {
            MFREE(m, so->so_rcv.sb_mb);
 8232a7c:	e13ff417 	ldw	r4,-48(fp)
 8232a80:	822e3b00 	call	822e3b0 <m_free>
 8232a84:	1007883a 	mov	r3,r2
 8232a88:	e0bffc17 	ldw	r2,-16(fp)
 8232a8c:	10c01015 	stw	r3,64(r2)
            m = so->so_rcv.sb_mb;
 8232a90:	e0bffc17 	ldw	r2,-16(fp)
 8232a94:	10801017 	ldw	r2,64(r2)
 8232a98:	e0bff415 	stw	r2,-48(fp)
         }
         if (m)
 8232a9c:	e0bff417 	ldw	r2,-48(fp)
 8232aa0:	10000326 	beq	r2,zero,8232ab0 <soreceive+0x3cc>
            m->m_act = nextrecord;
 8232aa4:	e0bff417 	ldw	r2,-48(fp)
 8232aa8:	e0fff817 	ldw	r3,-32(fp)
 8232aac:	10c00715 	stw	r3,28(r2)
      }
   }
   moff = 0;
 8232ab0:	e03ff915 	stw	zero,-28(fp)
   offset = 0;
 8232ab4:	e03ff715 	stw	zero,-36(fp)
   while (m && (*datalen > 0) && (error == 0))
 8232ab8:	00009e06 	br	8232d34 <soreceive+0x650>
   {
      if (m->m_type != MT_RXDATA && m->m_type != MT_HEADER)
 8232abc:	e0bff417 	ldw	r2,-48(fp)
 8232ac0:	10800817 	ldw	r2,32(r2)
 8232ac4:	10800060 	cmpeqi	r2,r2,1
 8232ac8:	1000071e 	bne	r2,zero,8232ae8 <soreceive+0x404>
 8232acc:	e0bff417 	ldw	r2,-48(fp)
 8232ad0:	10800817 	ldw	r2,32(r2)
 8232ad4:	108000e0 	cmpeqi	r2,r2,3
 8232ad8:	1000031e 	bne	r2,zero,8232ae8 <soreceive+0x404>
         panic("sorecv 3");
 8232adc:	01020974 	movhi	r4,2085
 8232ae0:	21039004 	addi	r4,r4,3648
 8232ae4:	8228aec0 	call	8228aec <panic>
      len = *datalen;
 8232ae8:	e0bfff17 	ldw	r2,-4(fp)
 8232aec:	10800017 	ldw	r2,0(r2)
 8232af0:	e0bff515 	stw	r2,-44(fp)
      so->so_state &= ~SS_RCVATMARK;
 8232af4:	e0bffc17 	ldw	r2,-16(fp)
 8232af8:	10c0088b 	ldhu	r3,34(r2)
 8232afc:	00bfefc4 	movi	r2,-65
 8232b00:	1884703a 	and	r2,r3,r2
 8232b04:	1007883a 	mov	r3,r2
 8232b08:	e0bffc17 	ldw	r2,-16(fp)
 8232b0c:	10c0088d 	sth	r3,34(r2)
      if (so->so_oobmark && (len > (int)(so->so_oobmark - offset)))
 8232b10:	e0bffc17 	ldw	r2,-16(fp)
 8232b14:	10801a17 	ldw	r2,104(r2)
 8232b18:	10000c26 	beq	r2,zero,8232b4c <soreceive+0x468>
 8232b1c:	e0bffc17 	ldw	r2,-16(fp)
 8232b20:	10c01a17 	ldw	r3,104(r2)
 8232b24:	e0bff717 	ldw	r2,-36(fp)
 8232b28:	1885c83a 	sub	r2,r3,r2
 8232b2c:	1007883a 	mov	r3,r2
 8232b30:	e0bff517 	ldw	r2,-44(fp)
 8232b34:	1880050e 	bge	r3,r2,8232b4c <soreceive+0x468>
         len = (int)(so->so_oobmark - offset);
 8232b38:	e0bffc17 	ldw	r2,-16(fp)
 8232b3c:	10c01a17 	ldw	r3,104(r2)
 8232b40:	e0bff717 	ldw	r2,-36(fp)
 8232b44:	1885c83a 	sub	r2,r3,r2
 8232b48:	e0bff515 	stw	r2,-44(fp)
      if (len > (int)(m->m_len - moff))
 8232b4c:	e0bff417 	ldw	r2,-48(fp)
 8232b50:	10c00217 	ldw	r3,8(r2)
 8232b54:	e0bff917 	ldw	r2,-28(fp)
 8232b58:	1885c83a 	sub	r2,r3,r2
 8232b5c:	1007883a 	mov	r3,r2
 8232b60:	e0bff517 	ldw	r2,-44(fp)
 8232b64:	1880050e 	bge	r3,r2,8232b7c <soreceive+0x498>
         len = m->m_len - moff;
 8232b68:	e0bff417 	ldw	r2,-48(fp)
 8232b6c:	10c00217 	ldw	r3,8(r2)
 8232b70:	e0bff917 	ldw	r2,-28(fp)
 8232b74:	1885c83a 	sub	r2,r3,r2
 8232b78:	e0bff515 	stw	r2,-44(fp)
       * it points to next record) when we drop priority;
       * we must note any additions to the sockbuf when we
       * block interrupts again.
       */

      MEMCPY(data, (mtod(m, char *) + moff), len);
 8232b7c:	e0bff417 	ldw	r2,-48(fp)
 8232b80:	10c00317 	ldw	r3,12(r2)
 8232b84:	e0bff917 	ldw	r2,-28(fp)
 8232b88:	1885883a 	add	r2,r3,r2
 8232b8c:	e0fff517 	ldw	r3,-44(fp)
 8232b90:	180d883a 	mov	r6,r3
 8232b94:	100b883a 	mov	r5,r2
 8232b98:	e13ffe17 	ldw	r4,-8(fp)
 8232b9c:	8202e8c0 	call	8202e8c <memcpy>
      data += len;
 8232ba0:	e0bff517 	ldw	r2,-44(fp)
 8232ba4:	e0fffe17 	ldw	r3,-8(fp)
 8232ba8:	1885883a 	add	r2,r3,r2
 8232bac:	e0bffe15 	stw	r2,-8(fp)
      *datalen -= len;
 8232bb0:	e0bfff17 	ldw	r2,-4(fp)
 8232bb4:	10c00017 	ldw	r3,0(r2)
 8232bb8:	e0bff517 	ldw	r2,-44(fp)
 8232bbc:	1887c83a 	sub	r3,r3,r2
 8232bc0:	e0bfff17 	ldw	r2,-4(fp)
 8232bc4:	10c00015 	stw	r3,0(r2)

      if (len == (int)(m->m_len - moff))
 8232bc8:	e0bff417 	ldw	r2,-48(fp)
 8232bcc:	10c00217 	ldw	r3,8(r2)
 8232bd0:	e0bff917 	ldw	r2,-28(fp)
 8232bd4:	1885c83a 	sub	r2,r3,r2
 8232bd8:	1007883a 	mov	r3,r2
 8232bdc:	e0bff517 	ldw	r2,-44(fp)
 8232be0:	1880201e 	bne	r3,r2,8232c64 <soreceive+0x580>
      {
         if (flags & MSG_PEEK) 
 8232be4:	e0800217 	ldw	r2,8(fp)
 8232be8:	1080008c 	andi	r2,r2,2
 8232bec:	10000526 	beq	r2,zero,8232c04 <soreceive+0x520>
         {
            m = m->m_next;
 8232bf0:	e0bff417 	ldw	r2,-48(fp)
 8232bf4:	10800617 	ldw	r2,24(r2)
 8232bf8:	e0bff415 	stw	r2,-48(fp)
            moff = 0;
 8232bfc:	e03ff915 	stw	zero,-28(fp)
 8232c00:	00003206 	br	8232ccc <soreceive+0x5e8>
         } else 
         {
            nextrecord = m->m_act;
 8232c04:	e0bff417 	ldw	r2,-48(fp)
 8232c08:	10800717 	ldw	r2,28(r2)
 8232c0c:	e0bff815 	stw	r2,-32(fp)
            sbfree(&so->so_rcv, m);
 8232c10:	e0bffc17 	ldw	r2,-16(fp)
 8232c14:	10c00a17 	ldw	r3,40(r2)
 8232c18:	e0bff417 	ldw	r2,-48(fp)
 8232c1c:	10800217 	ldw	r2,8(r2)
 8232c20:	1887c83a 	sub	r3,r3,r2
 8232c24:	e0bffc17 	ldw	r2,-16(fp)
 8232c28:	10c00a15 	stw	r3,40(r2)
            {
               MFREE(m, so->so_rcv.sb_mb);
 8232c2c:	e13ff417 	ldw	r4,-48(fp)
 8232c30:	822e3b00 	call	822e3b0 <m_free>
 8232c34:	1007883a 	mov	r3,r2
 8232c38:	e0bffc17 	ldw	r2,-16(fp)
 8232c3c:	10c01015 	stw	r3,64(r2)
               m = so->so_rcv.sb_mb;
 8232c40:	e0bffc17 	ldw	r2,-16(fp)
 8232c44:	10801017 	ldw	r2,64(r2)
 8232c48:	e0bff415 	stw	r2,-48(fp)
            }
            if (m)
 8232c4c:	e0bff417 	ldw	r2,-48(fp)
 8232c50:	10001e26 	beq	r2,zero,8232ccc <soreceive+0x5e8>
               m->m_act = nextrecord;
 8232c54:	e0bff417 	ldw	r2,-48(fp)
 8232c58:	e0fff817 	ldw	r3,-32(fp)
 8232c5c:	10c00715 	stw	r3,28(r2)
 8232c60:	00001a06 	br	8232ccc <soreceive+0x5e8>
         }
      } else 
      {
         if (flags & MSG_PEEK)
 8232c64:	e0800217 	ldw	r2,8(fp)
 8232c68:	1080008c 	andi	r2,r2,2
 8232c6c:	10000526 	beq	r2,zero,8232c84 <soreceive+0x5a0>
            moff += len;
 8232c70:	e0fff917 	ldw	r3,-28(fp)
 8232c74:	e0bff517 	ldw	r2,-44(fp)
 8232c78:	1885883a 	add	r2,r3,r2
 8232c7c:	e0bff915 	stw	r2,-28(fp)
 8232c80:	00001206 	br	8232ccc <soreceive+0x5e8>
         else 
         {
            m->m_data += len;
 8232c84:	e0bff417 	ldw	r2,-48(fp)
 8232c88:	10c00317 	ldw	r3,12(r2)
 8232c8c:	e0bff517 	ldw	r2,-44(fp)
 8232c90:	1887883a 	add	r3,r3,r2
 8232c94:	e0bff417 	ldw	r2,-48(fp)
 8232c98:	10c00315 	stw	r3,12(r2)
            m->m_len -= len;
 8232c9c:	e0bff417 	ldw	r2,-48(fp)
 8232ca0:	10c00217 	ldw	r3,8(r2)
 8232ca4:	e0bff517 	ldw	r2,-44(fp)
 8232ca8:	1887c83a 	sub	r3,r3,r2
 8232cac:	e0bff417 	ldw	r2,-48(fp)
 8232cb0:	10c00215 	stw	r3,8(r2)
            so->so_rcv.sb_cc -= len;
 8232cb4:	e0bffc17 	ldw	r2,-16(fp)
 8232cb8:	10c00a17 	ldw	r3,40(r2)
 8232cbc:	e0bff517 	ldw	r2,-44(fp)
 8232cc0:	1887c83a 	sub	r3,r3,r2
 8232cc4:	e0bffc17 	ldw	r2,-16(fp)
 8232cc8:	10c00a15 	stw	r3,40(r2)
         }
      }
      if (so->so_oobmark) 
 8232ccc:	e0bffc17 	ldw	r2,-16(fp)
 8232cd0:	10801a17 	ldw	r2,104(r2)
 8232cd4:	10001726 	beq	r2,zero,8232d34 <soreceive+0x650>
      {
         if ((flags & MSG_PEEK) == 0) 
 8232cd8:	e0800217 	ldw	r2,8(fp)
 8232cdc:	1080008c 	andi	r2,r2,2
 8232ce0:	1000101e 	bne	r2,zero,8232d24 <soreceive+0x640>
         {
            so->so_oobmark -= len;
 8232ce4:	e0bffc17 	ldw	r2,-16(fp)
 8232ce8:	10c01a17 	ldw	r3,104(r2)
 8232cec:	e0bff517 	ldw	r2,-44(fp)
 8232cf0:	1887c83a 	sub	r3,r3,r2
 8232cf4:	e0bffc17 	ldw	r2,-16(fp)
 8232cf8:	10c01a15 	stw	r3,104(r2)
            if (so->so_oobmark == 0) 
 8232cfc:	e0bffc17 	ldw	r2,-16(fp)
 8232d00:	10801a17 	ldw	r2,104(r2)
 8232d04:	10000b1e 	bne	r2,zero,8232d34 <soreceive+0x650>
            {
               so->so_state |= SS_RCVATMARK;
 8232d08:	e0bffc17 	ldw	r2,-16(fp)
 8232d0c:	1080088b 	ldhu	r2,34(r2)
 8232d10:	10801014 	ori	r2,r2,64
 8232d14:	1007883a 	mov	r3,r2
 8232d18:	e0bffc17 	ldw	r2,-16(fp)
 8232d1c:	10c0088d 	sth	r3,34(r2)
               break;
 8232d20:	00000b06 	br	8232d50 <soreceive+0x66c>
            }
         } else
            offset += len;
 8232d24:	e0fff717 	ldw	r3,-36(fp)
 8232d28:	e0bff517 	ldw	r2,-44(fp)
 8232d2c:	1885883a 	add	r2,r3,r2
 8232d30:	e0bff715 	stw	r2,-36(fp)
            m->m_act = nextrecord;
      }
   }
   moff = 0;
   offset = 0;
   while (m && (*datalen > 0) && (error == 0))
 8232d34:	e0bff417 	ldw	r2,-48(fp)
 8232d38:	10000526 	beq	r2,zero,8232d50 <soreceive+0x66c>
 8232d3c:	e0bfff17 	ldw	r2,-4(fp)
 8232d40:	10800017 	ldw	r2,0(r2)
 8232d44:	0080020e 	bge	zero,r2,8232d50 <soreceive+0x66c>
 8232d48:	e0bff617 	ldw	r2,-40(fp)
 8232d4c:	103f5b26 	beq	r2,zero,8232abc <soreceive+0x3d8>
         } else
            offset += len;
      }
   }

   if ((flags & MSG_PEEK) == 0) 
 8232d50:	e0800217 	ldw	r2,8(fp)
 8232d54:	1080008c 	andi	r2,r2,2
 8232d58:	1000241e 	bne	r2,zero,8232dec <soreceive+0x708>
   {
      if (m == 0)
 8232d5c:	e0bff417 	ldw	r2,-48(fp)
 8232d60:	1000041e 	bne	r2,zero,8232d74 <soreceive+0x690>
         so->so_rcv.sb_mb = nextrecord;
 8232d64:	e0bffc17 	ldw	r2,-16(fp)
 8232d68:	e0fff817 	ldw	r3,-32(fp)
 8232d6c:	10c01015 	stw	r3,64(r2)
 8232d70:	00000906 	br	8232d98 <soreceive+0x6b4>
      else if (pr->pr_flags & PR_ATOMIC)
 8232d74:	e0bffa17 	ldw	r2,-24(fp)
 8232d78:	1080010b 	ldhu	r2,4(r2)
 8232d7c:	10bfffcc 	andi	r2,r2,65535
 8232d80:	1080004c 	andi	r2,r2,1
 8232d84:	10000426 	beq	r2,zero,8232d98 <soreceive+0x6b4>
         (void) sbdroprecord(&so->so_rcv);
 8232d88:	e0bffc17 	ldw	r2,-16(fp)
 8232d8c:	10800a04 	addi	r2,r2,40
 8232d90:	1009883a 	mov	r4,r2
 8232d94:	8234ae40 	call	8234ae4 <sbdroprecord>
      if (pr->pr_flags & PR_WANTRCVD && so->so_pcb)
 8232d98:	e0bffa17 	ldw	r2,-24(fp)
 8232d9c:	1080010b 	ldhu	r2,4(r2)
 8232da0:	10bfffcc 	andi	r2,r2,65535
 8232da4:	1080020c 	andi	r2,r2,8
 8232da8:	10001026 	beq	r2,zero,8232dec <soreceive+0x708>
 8232dac:	e0bffc17 	ldw	r2,-16(fp)
 8232db0:	10800117 	ldw	r2,4(r2)
 8232db4:	10000d26 	beq	r2,zero,8232dec <soreceive+0x708>
      {
         so->so_req = PRU_RCVD;
 8232db8:	e0bffc17 	ldw	r2,-16(fp)
 8232dbc:	00c00204 	movi	r3,8
 8232dc0:	10c00715 	stw	r3,28(r2)
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
 8232dc4:	e0bffa17 	ldw	r2,-24(fp)
 8232dc8:	10800317 	ldw	r2,12(r2)
 8232dcc:	000d883a 	mov	r6,zero
 8232dd0:	000b883a 	mov	r5,zero
 8232dd4:	e13ffc17 	ldw	r4,-16(fp)
 8232dd8:	103ee83a 	callr	r2
 8232ddc:	00000306 	br	8232dec <soreceive+0x708>
         error = so->so_error;
         so->so_error = 0;
         goto release;
      }
      if (so->so_state & SS_CANTRCVMORE)
         goto release;
 8232de0:	0001883a 	nop
 8232de4:	00000106 	br	8232dec <soreceive+0x708>
      {
         error = ENOTCONN;
         goto release;
      }
      if (*datalen == 0)
         goto release;
 8232de8:	0001883a 	nop
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
          (struct mbuf *)0);
      }
   }
release:
   sbunlock(&so->so_rcv);
 8232dec:	e0bffc17 	ldw	r2,-16(fp)
 8232df0:	10c0110b 	ldhu	r3,68(r2)
 8232df4:	00bfff84 	movi	r2,-2
 8232df8:	1884703a 	and	r2,r3,r2
 8232dfc:	1007883a 	mov	r3,r2
 8232e00:	e0bffc17 	ldw	r2,-16(fp)
 8232e04:	10c0110d 	sth	r3,68(r2)
 8232e08:	e0bffc17 	ldw	r2,-16(fp)
 8232e0c:	10801104 	addi	r2,r2,68
 8232e10:	1009883a 	mov	r4,r2
 8232e14:	822954c0 	call	822954c <tcp_wakeup>
   return (error);
 8232e18:	e0bff617 	ldw	r2,-40(fp)
}
 8232e1c:	e037883a 	mov	sp,fp
 8232e20:	dfc00117 	ldw	ra,4(sp)
 8232e24:	df000017 	ldw	fp,0(sp)
 8232e28:	dec00204 	addi	sp,sp,8
 8232e2c:	f800283a 	ret

08232e30 <soshutdown>:
 *
 * RETURNS: int               0 if successful, else error code
 */
int
soshutdown(struct socket *so, int how)
{
 8232e30:	defffc04 	addi	sp,sp,-16
 8232e34:	dfc00315 	stw	ra,12(sp)
 8232e38:	df000215 	stw	fp,8(sp)
 8232e3c:	df000204 	addi	fp,sp,8
 8232e40:	e13ffe15 	stw	r4,-8(fp)
 8232e44:	e17fff15 	stw	r5,-4(fp)
   how++;   /* convert 0,1,2 into 1,2,3 */
 8232e48:	e0bfff17 	ldw	r2,-4(fp)
 8232e4c:	10800044 	addi	r2,r2,1
 8232e50:	e0bfff15 	stw	r2,-4(fp)
   if (how & 1)   /* caller wanted READ or BOTH */
 8232e54:	e0bfff17 	ldw	r2,-4(fp)
 8232e58:	1080004c 	andi	r2,r2,1
 8232e5c:	10000226 	beq	r2,zero,8232e68 <soshutdown+0x38>
      sorflush(so);
 8232e60:	e13ffe17 	ldw	r4,-8(fp)
 8232e64:	8232ec80 	call	8232ec8 <sorflush>

   if (how & 2)   /* caller wanted WRITE or BOTH */
 8232e68:	e0bfff17 	ldw	r2,-4(fp)
 8232e6c:	1080008c 	andi	r2,r2,2
 8232e70:	10000f26 	beq	r2,zero,8232eb0 <soshutdown+0x80>
   {
      sbflush(&so->so_snd); /* flush the socket send queue */
 8232e74:	e0bffe17 	ldw	r2,-8(fp)
 8232e78:	10801204 	addi	r2,r2,72
 8232e7c:	1009883a 	mov	r4,r2
 8232e80:	82347a80 	call	82347a8 <sbflush>
      so->so_req = PRU_SHUTDOWN;
 8232e84:	e0bffe17 	ldw	r2,-8(fp)
 8232e88:	00c001c4 	movi	r3,7
 8232e8c:	10c00715 	stw	r3,28(r2)
      return ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0));
 8232e90:	e0bffe17 	ldw	r2,-8(fp)
 8232e94:	10800217 	ldw	r2,8(r2)
 8232e98:	10800317 	ldw	r2,12(r2)
 8232e9c:	000d883a 	mov	r6,zero
 8232ea0:	000b883a 	mov	r5,zero
 8232ea4:	e13ffe17 	ldw	r4,-8(fp)
 8232ea8:	103ee83a 	callr	r2
 8232eac:	00000106 	br	8232eb4 <soshutdown+0x84>
   }

   return 0;
 8232eb0:	0005883a 	mov	r2,zero
}
 8232eb4:	e037883a 	mov	sp,fp
 8232eb8:	dfc00117 	ldw	ra,4(sp)
 8232ebc:	df000017 	ldw	fp,0(sp)
 8232ec0:	dec00204 	addi	sp,sp,8
 8232ec4:	f800283a 	ret

08232ec8 <sorflush>:
 * socket receive buffer is discarded. Wakeup any processes waiting
 * on the socket.
 */
void
sorflush(struct socket * so)
{
 8232ec8:	defffb04 	addi	sp,sp,-20
 8232ecc:	dfc00415 	stw	ra,16(sp)
 8232ed0:	df000315 	stw	fp,12(sp)
 8232ed4:	df000304 	addi	fp,sp,12
 8232ed8:	e13fff15 	stw	r4,-4(fp)
   struct sockbuf *sb =  &so->so_rcv;
 8232edc:	e0bfff17 	ldw	r2,-4(fp)
 8232ee0:	10800a04 	addi	r2,r2,40
 8232ee4:	e0bffd15 	stw	r2,-12(fp)
   int   s;

   sblock(sb);
 8232ee8:	00000406 	br	8232efc <sorflush+0x34>
 8232eec:	e0bffd17 	ldw	r2,-12(fp)
 8232ef0:	10800704 	addi	r2,r2,28
 8232ef4:	1009883a 	mov	r4,r2
 8232ef8:	82293d80 	call	82293d8 <tcp_sleep>
 8232efc:	e0bffd17 	ldw	r2,-12(fp)
 8232f00:	1080070b 	ldhu	r2,28(r2)
 8232f04:	10bfffcc 	andi	r2,r2,65535
 8232f08:	1080004c 	andi	r2,r2,1
 8232f0c:	103ff71e 	bne	r2,zero,8232eec <sorflush+0x24>
 8232f10:	e0bffd17 	ldw	r2,-12(fp)
 8232f14:	1080070b 	ldhu	r2,28(r2)
 8232f18:	10800054 	ori	r2,r2,1
 8232f1c:	1007883a 	mov	r3,r2
 8232f20:	e0bffd17 	ldw	r2,-12(fp)
 8232f24:	10c0070d 	sth	r3,28(r2)
   socantrcvmore(so);
 8232f28:	e13fff17 	ldw	r4,-4(fp)
 8232f2c:	8233fc40 	call	8233fc4 <socantrcvmore>
   sbunlock(sb);
 8232f30:	e0bffd17 	ldw	r2,-12(fp)
 8232f34:	10c0070b 	ldhu	r3,28(r2)
 8232f38:	00bfff84 	movi	r2,-2
 8232f3c:	1884703a 	and	r2,r3,r2
 8232f40:	1007883a 	mov	r3,r2
 8232f44:	e0bffd17 	ldw	r2,-12(fp)
 8232f48:	10c0070d 	sth	r3,28(r2)
 8232f4c:	e0bffd17 	ldw	r2,-12(fp)
 8232f50:	10800704 	addi	r2,r2,28
 8232f54:	1009883a 	mov	r4,r2
 8232f58:	822954c0 	call	822954c <tcp_wakeup>
   sbrelease(sb);
 8232f5c:	e13ffd17 	ldw	r4,-12(fp)
 8232f60:	82342280 	call	8234228 <sbrelease>
   MEMSET((char *)sb, 0, sizeof (*sb));
 8232f64:	01800804 	movi	r6,32
 8232f68:	000b883a 	mov	r5,zero
 8232f6c:	e13ffd17 	ldw	r4,-12(fp)
 8232f70:	82031300 	call	8203130 <memset>
   s = so->so_error;
 8232f74:	e0bfff17 	ldw	r2,-4(fp)
 8232f78:	10800617 	ldw	r2,24(r2)
 8232f7c:	e0bffe15 	stw	r2,-8(fp)
   so->so_error = ESHUTDOWN;
 8232f80:	e0bfff17 	ldw	r2,-4(fp)
 8232f84:	00c01b84 	movi	r3,110
 8232f88:	10c00615 	stw	r3,24(r2)
   sorwakeup(so);
 8232f8c:	e0bfff17 	ldw	r2,-4(fp)
 8232f90:	10800a04 	addi	r2,r2,40
 8232f94:	100b883a 	mov	r5,r2
 8232f98:	e13fff17 	ldw	r4,-4(fp)
 8232f9c:	82340c40 	call	82340c4 <sbwakeup>
   so->so_error = s;
 8232fa0:	e0bfff17 	ldw	r2,-4(fp)
 8232fa4:	e0fffe17 	ldw	r3,-8(fp)
 8232fa8:	10c00615 	stw	r3,24(r2)
}
 8232fac:	0001883a 	nop
 8232fb0:	e037883a 	mov	sp,fp
 8232fb4:	dfc00117 	ldw	ra,4(sp)
 8232fb8:	df000017 	ldw	fp,0(sp)
 8232fbc:	dec00204 	addi	sp,sp,8
 8232fc0:	f800283a 	ret

08232fc4 <sosetopt>:

int
sosetopt(struct socket * so, 
   int   optname,
   void *   arg)
{
 8232fc4:	defff604 	addi	sp,sp,-40
 8232fc8:	dfc00915 	stw	ra,36(sp)
 8232fcc:	df000815 	stw	fp,32(sp)
 8232fd0:	df000804 	addi	fp,sp,32
 8232fd4:	e13ffd15 	stw	r4,-12(fp)
 8232fd8:	e17ffe15 	stw	r5,-8(fp)
 8232fdc:	e1bfff15 	stw	r6,-4(fp)
   int   error =  0;
 8232fe0:	e03ff815 	stw	zero,-32(fp)

   switch (optname) 
 8232fe4:	e0bffe17 	ldw	r2,-8(fp)
 8232fe8:	10c08020 	cmpeqi	r3,r2,512
 8232fec:	18003b1e 	bne	r3,zero,82330dc <sosetopt+0x118>
 8232ff0:	10c08048 	cmpgei	r3,r2,513
 8232ff4:	1800171e 	bne	r3,zero,8233054 <sosetopt+0x90>
 8232ff8:	10c00388 	cmpgei	r3,r2,14
 8232ffc:	1800091e 	bne	r3,zero,8233024 <sosetopt+0x60>
 8233000:	10c00248 	cmpgei	r3,r2,9
 8233004:	1800831e 	bne	r3,zero,8233214 <sosetopt+0x250>
 8233008:	10c00120 	cmpeqi	r3,r2,4
 823300c:	1800331e 	bne	r3,zero,82330dc <sosetopt+0x118>
 8233010:	10c00220 	cmpeqi	r3,r2,8
 8233014:	1800311e 	bne	r3,zero,82330dc <sosetopt+0x118>
 8233018:	108000a0 	cmpeqi	r2,r2,2
 823301c:	1000831e 	bne	r2,zero,823322c <sosetopt+0x268>
 8233020:	0000ea06 	br	82333cc <sosetopt+0x408>
 8233024:	10c00820 	cmpeqi	r3,r2,32
 8233028:	18002c1e 	bne	r3,zero,82330dc <sosetopt+0x118>
 823302c:	10c00848 	cmpgei	r3,r2,33
 8233030:	1800031e 	bne	r3,zero,8233040 <sosetopt+0x7c>
 8233034:	10800420 	cmpeqi	r2,r2,16
 8233038:	1000281e 	bne	r2,zero,82330dc <sosetopt+0x118>
 823303c:	0000e306 	br	82333cc <sosetopt+0x408>
 8233040:	10c02020 	cmpeqi	r3,r2,128
 8233044:	1800201e 	bne	r3,zero,82330c8 <sosetopt+0x104>
 8233048:	10804020 	cmpeqi	r2,r2,256
 823304c:	1000231e 	bne	r2,zero,82330dc <sosetopt+0x118>
 8233050:	0000de06 	br	82333cc <sosetopt+0x408>
 8233054:	10c40520 	cmpeqi	r3,r2,4116
 8233058:	1800481e 	bne	r3,zero,823317c <sosetopt+0x1b8>
 823305c:	10c40548 	cmpgei	r3,r2,4117
 8233060:	18000b1e 	bne	r3,zero,8233090 <sosetopt+0xcc>
 8233064:	10c401a0 	cmpeqi	r3,r2,4102
 8233068:	18003f1e 	bne	r3,zero,8233168 <sosetopt+0x1a4>
 823306c:	10c401c8 	cmpgei	r3,r2,4103
 8233070:	1800041e 	bne	r3,zero,8233084 <sosetopt+0xc0>
 8233074:	10bbffc4 	addi	r2,r2,-4097
 8233078:	108000a8 	cmpgeui	r2,r2,2
 823307c:	1000d31e 	bne	r2,zero,82333cc <sosetopt+0x408>
 8233080:	00002806 	br	8233124 <sosetopt+0x160>
 8233084:	10840420 	cmpeqi	r2,r2,4112
 8233088:	1000a91e 	bne	r2,zero,8233330 <sosetopt+0x36c>
 823308c:	0000cf06 	br	82333cc <sosetopt+0x408>
 8233090:	10c800e0 	cmpeqi	r3,r2,8195
 8233094:	1800a61e 	bne	r3,zero,8233330 <sosetopt+0x36c>
 8233098:	10c80108 	cmpgei	r3,r2,8196
 823309c:	1800051e 	bne	r3,zero,82330b4 <sosetopt+0xf0>
 82330a0:	10c40560 	cmpeqi	r3,r2,4117
 82330a4:	18003c1e 	bne	r3,zero,8233198 <sosetopt+0x1d4>
 82330a8:	108405a0 	cmpeqi	r2,r2,4118
 82330ac:	1000421e 	bne	r2,zero,82331b8 <sosetopt+0x1f4>
 82330b0:	0000c606 	br	82333cc <sosetopt+0x408>
 82330b4:	10c80120 	cmpeqi	r3,r2,8196
 82330b8:	1800711e 	bne	r3,zero,8233280 <sosetopt+0x2bc>
 82330bc:	10900020 	cmpeqi	r2,r2,16384
 82330c0:	1000061e 	bne	r2,zero,82330dc <sosetopt+0x118>
 82330c4:	0000c106 	br	82333cc <sosetopt+0x408>
   {
   case SO_LINGER:
      so->so_linger = (short)((struct linger *)arg)->l_linger;
 82330c8:	e0bfff17 	ldw	r2,-4(fp)
 82330cc:	10800117 	ldw	r2,4(r2)
 82330d0:	1007883a 	mov	r3,r2
 82330d4:	e0bffd17 	ldw	r2,-12(fp)
 82330d8:	10c0080d 	sth	r3,32(r2)
   case SO_TCPSACK:
   case SO_NOSLOWSTART:
#ifdef SUPPORT_SO_FULLMSS
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
 82330dc:	e0bfff17 	ldw	r2,-4(fp)
 82330e0:	10800017 	ldw	r2,0(r2)
 82330e4:	10000726 	beq	r2,zero,8233104 <sosetopt+0x140>
         so->so_options |= optname;
 82330e8:	e0bffd17 	ldw	r2,-12(fp)
 82330ec:	10c00417 	ldw	r3,16(r2)
 82330f0:	e0bffe17 	ldw	r2,-8(fp)
 82330f4:	1886b03a 	or	r3,r3,r2
 82330f8:	e0bffd17 	ldw	r2,-12(fp)
 82330fc:	10c00415 	stw	r3,16(r2)
      else
         so->so_options &= ~optname;
      break;
 8233100:	0000b606 	br	82333dc <sosetopt+0x418>
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
         so->so_options |= optname;
      else
         so->so_options &= ~optname;
 8233104:	e0bffd17 	ldw	r2,-12(fp)
 8233108:	10800417 	ldw	r2,16(r2)
 823310c:	e0fffe17 	ldw	r3,-8(fp)
 8233110:	00c6303a 	nor	r3,zero,r3
 8233114:	10c6703a 	and	r3,r2,r3
 8233118:	e0bffd17 	ldw	r2,-12(fp)
 823311c:	10c00415 	stw	r3,16(r2)
      break;
 8233120:	0000ae06 	br	82333dc <sosetopt+0x418>
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 8233124:	e0bffe17 	ldw	r2,-8(fp)
 8233128:	10840058 	cmpnei	r2,r2,4097
 823312c:	1000031e 	bne	r2,zero,823313c <sosetopt+0x178>
 8233130:	e0bffd17 	ldw	r2,-12(fp)
 8233134:	10801204 	addi	r2,r2,72
 8233138:	00000206 	br	8233144 <sosetopt+0x180>
 823313c:	e0bffd17 	ldw	r2,-12(fp)
 8233140:	10800a04 	addi	r2,r2,40
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
 8233144:	e0ffff17 	ldw	r3,-4(fp)
 8233148:	18c00017 	ldw	r3,0(r3)
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 823314c:	180b883a 	mov	r5,r3
 8233150:	1009883a 	mov	r4,r2
 8233154:	82341d80 	call	82341d8 <sbreserve>
 8233158:	10009f1e 	bne	r2,zero,82333d8 <sosetopt+0x414>
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
 823315c:	00801a44 	movi	r2,105
 8233160:	e0bff815 	stw	r2,-32(fp)
         goto bad;
 8233164:	00009d06 	br	82333dc <sosetopt+0x418>
      }
      break;

   case SO_RCVTIMEO:
      so->so_rcv.sb_timeo = *(short *)arg;
 8233168:	e0bfff17 	ldw	r2,-4(fp)
 823316c:	10c0000b 	ldhu	r3,0(r2)
 8233170:	e0bffd17 	ldw	r2,-12(fp)
 8233174:	10c0118d 	sth	r3,70(r2)
      break;
 8233178:	00009806 	br	82333dc <sosetopt+0x418>

   case SO_NBIO:     /* set socket into NON-blocking mode */
      so->so_state |= SS_NBIO;
 823317c:	e0bffd17 	ldw	r2,-12(fp)
 8233180:	1080088b 	ldhu	r2,34(r2)
 8233184:	10804014 	ori	r2,r2,256
 8233188:	1007883a 	mov	r3,r2
 823318c:	e0bffd17 	ldw	r2,-12(fp)
 8233190:	10c0088d 	sth	r3,34(r2)
      break;
 8233194:	00009106 	br	82333dc <sosetopt+0x418>

   case SO_BIO:   /* set socket into blocking mode */
      so->so_state &= ~SS_NBIO;
 8233198:	e0bffd17 	ldw	r2,-12(fp)
 823319c:	10c0088b 	ldhu	r3,34(r2)
 82331a0:	00bfbfc4 	movi	r2,-257
 82331a4:	1884703a 	and	r2,r3,r2
 82331a8:	1007883a 	mov	r3,r2
 82331ac:	e0bffd17 	ldw	r2,-12(fp)
 82331b0:	10c0088d 	sth	r3,34(r2)
      break;
 82331b4:	00008906 	br	82333dc <sosetopt+0x418>

   case SO_NONBLOCK:    /* set blocking mode according to arg */
      /* sanity check the arg parameter */
      if (!arg)
 82331b8:	e0bfff17 	ldw	r2,-4(fp)
 82331bc:	1000031e 	bne	r2,zero,82331cc <sosetopt+0x208>
      {
         error = ENP_PARAM;
 82331c0:	00bffd84 	movi	r2,-10
 82331c4:	e0bff815 	stw	r2,-32(fp)
         break;
 82331c8:	00008406 	br	82333dc <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 82331cc:	e0bfff17 	ldw	r2,-4(fp)
 82331d0:	10800017 	ldw	r2,0(r2)
 82331d4:	10000726 	beq	r2,zero,82331f4 <sosetopt+0x230>
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
 82331d8:	e0bffd17 	ldw	r2,-12(fp)
 82331dc:	1080088b 	ldhu	r2,34(r2)
 82331e0:	10804014 	ori	r2,r2,256
 82331e4:	1007883a 	mov	r3,r2
 82331e8:	e0bffd17 	ldw	r2,-12(fp)
 82331ec:	10c0088d 	sth	r3,34(r2)
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
      break;
 82331f0:	00007a06 	br	82333dc <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
 82331f4:	e0bffd17 	ldw	r2,-12(fp)
 82331f8:	10c0088b 	ldhu	r3,34(r2)
 82331fc:	00bfbfc4 	movi	r2,-257
 8233200:	1884703a 	and	r2,r3,r2
 8233204:	1007883a 	mov	r3,r2
 8233208:	e0bffd17 	ldw	r2,-12(fp)
 823320c:	10c0088d 	sth	r3,34(r2)
      break;
 8233210:	00007206 	br	82333dc <sosetopt+0x418>
   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      error = ip_setmoptions(optname, so, arg);
 8233214:	e1bfff17 	ldw	r6,-4(fp)
 8233218:	e17ffd17 	ldw	r5,-12(fp)
 823321c:	e13ffe17 	ldw	r4,-8(fp)
 8233220:	8245dfc0 	call	8245dfc <ip_setmoptions>
 8233224:	e0bff815 	stw	r2,-32(fp)
      break;
 8233228:	00006c06 	br	82333dc <sosetopt+0x418>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 823322c:	e0bfff17 	ldw	r2,-4(fp)
 8233230:	1000031e 	bne	r2,zero,8233240 <sosetopt+0x27c>
      {
         error = ENP_PARAM;
 8233234:	00bffd84 	movi	r2,-10
 8233238:	e0bff815 	stw	r2,-32(fp)
         break;
 823323c:	00006706 	br	82333dc <sosetopt+0x418>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
 8233240:	e0bfff17 	ldw	r2,-4(fp)
 8233244:	10800017 	ldw	r2,0(r2)
 8233248:	10000626 	beq	r2,zero,8233264 <sosetopt+0x2a0>
         so->so_options |= SO_HDRINCL;
 823324c:	e0bffd17 	ldw	r2,-12(fp)
 8233250:	10800417 	ldw	r2,16(r2)
 8233254:	10c80014 	ori	r3,r2,8192
 8233258:	e0bffd17 	ldw	r2,-12(fp)
 823325c:	10c00415 	stw	r3,16(r2)
      else
         so->so_options &= ~SO_HDRINCL;
      break;
 8233260:	00005e06 	br	82333dc <sosetopt+0x418>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
         so->so_options |= SO_HDRINCL;
      else
         so->so_options &= ~SO_HDRINCL;
 8233264:	e0bffd17 	ldw	r2,-12(fp)
 8233268:	10c00417 	ldw	r3,16(r2)
 823326c:	00b7ffc4 	movi	r2,-8193
 8233270:	1886703a 	and	r3,r3,r2
 8233274:	e0bffd17 	ldw	r2,-12(fp)
 8233278:	10c00415 	stw	r3,16(r2)
      break;
 823327c:	00005706 	br	82333dc <sosetopt+0x418>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 8233280:	e0bffd17 	ldw	r2,-12(fp)
 8233284:	10800983 	ldbu	r2,38(r2)
 8233288:	10803fcc 	andi	r2,r2,255
 823328c:	1080201c 	xori	r2,r2,128
 8233290:	10bfe004 	addi	r2,r2,-128
 8233294:	10800060 	cmpeqi	r2,r2,1
 8233298:	1000031e 	bne	r2,zero,82332a8 <sosetopt+0x2e4>
      {
         error = EINVAL;
 823329c:	00800584 	movi	r2,22
 82332a0:	e0bff815 	stw	r2,-32(fp)
         break;
 82332a4:	00004d06 	br	82333dc <sosetopt+0x418>
      }
      inp = (struct inpcb *)(so->so_pcb);
 82332a8:	e0bffd17 	ldw	r2,-12(fp)
 82332ac:	10800117 	ldw	r2,4(r2)
 82332b0:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 82332b4:	e0bff917 	ldw	r2,-28(fp)
 82332b8:	10800917 	ldw	r2,36(r2)
 82332bc:	e0bffa15 	stw	r2,-24(fp)
      if(!tp)
 82332c0:	e0bffa17 	ldw	r2,-24(fp)
 82332c4:	1000031e 	bne	r2,zero,82332d4 <sosetopt+0x310>
      {
         error = ENOTCONN;
 82332c8:	00802004 	movi	r2,128
 82332cc:	e0bff815 	stw	r2,-32(fp)
         break;
 82332d0:	00004206 	br	82333dc <sosetopt+0x418>
      }
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 82332d4:	e0bfff17 	ldw	r2,-4(fp)
 82332d8:	1000031e 	bne	r2,zero,82332e8 <sosetopt+0x324>
      {
         error = ENP_PARAM;
 82332dc:	00bffd84 	movi	r2,-10
 82332e0:	e0bff815 	stw	r2,-32(fp)
         break;
 82332e4:	00003d06 	br	82333dc <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 82332e8:	e0bfff17 	ldw	r2,-4(fp)
 82332ec:	10800017 	ldw	r2,0(r2)
 82332f0:	10000726 	beq	r2,zero,8233310 <sosetopt+0x34c>
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
 82332f4:	e0bffa17 	ldw	r2,-24(fp)
 82332f8:	10800b0b 	ldhu	r2,44(r2)
 82332fc:	10800114 	ori	r2,r2,4
 8233300:	1007883a 	mov	r3,r2
 8233304:	e0bffa17 	ldw	r2,-24(fp)
 8233308:	10c00b0d 	sth	r3,44(r2)
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */

      break;
 823330c:	00003306 	br	82333dc <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */
 8233310:	e0bffa17 	ldw	r2,-24(fp)
 8233314:	10c00b0b 	ldhu	r3,44(r2)
 8233318:	00bffec4 	movi	r2,-5
 823331c:	1884703a 	and	r2,r3,r2
 8233320:	1007883a 	mov	r3,r2
 8233324:	e0bffa17 	ldw	r2,-24(fp)
 8233328:	10c00b0d 	sth	r3,44(r2)

      break;
 823332c:	00002b06 	br	82333dc <sosetopt+0x418>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 8233330:	e0bffd17 	ldw	r2,-12(fp)
 8233334:	10800983 	ldbu	r2,38(r2)
 8233338:	10803fcc 	andi	r2,r2,255
 823333c:	1080201c 	xori	r2,r2,128
 8233340:	10bfe004 	addi	r2,r2,-128
 8233344:	10800060 	cmpeqi	r2,r2,1
 8233348:	1000031e 	bne	r2,zero,8233358 <sosetopt+0x394>
      {
         error = EINVAL;
 823334c:	00800584 	movi	r2,22
 8233350:	e0bff815 	stw	r2,-32(fp)
         break;
 8233354:	00002106 	br	82333dc <sosetopt+0x418>
      }
      inp = (struct inpcb *)(so->so_pcb);
 8233358:	e0bffd17 	ldw	r2,-12(fp)
 823335c:	10800117 	ldw	r2,4(r2)
 8233360:	e0bffb15 	stw	r2,-20(fp)
      tp = intotcpcb(inp);
 8233364:	e0bffb17 	ldw	r2,-20(fp)
 8233368:	10800917 	ldw	r2,36(r2)
 823336c:	e0bffc15 	stw	r2,-16(fp)
      if(!tp)
 8233370:	e0bffc17 	ldw	r2,-16(fp)
 8233374:	1000031e 	bne	r2,zero,8233384 <sosetopt+0x3c0>
      {
         error = ENOTCONN;
 8233378:	00802004 	movi	r2,128
 823337c:	e0bff815 	stw	r2,-32(fp)
         break;
 8233380:	00001606 	br	82333dc <sosetopt+0x418>
      }
      if (tp->t_state != TCPS_CLOSED)
 8233384:	e0bffc17 	ldw	r2,-16(fp)
 8233388:	10800217 	ldw	r2,8(r2)
 823338c:	10000326 	beq	r2,zero,823339c <sosetopt+0x3d8>
      {
         error = EINVAL;
 8233390:	00800584 	movi	r2,22
 8233394:	e0bff815 	stw	r2,-32(fp)
         break;
 8233398:	00001006 	br	82333dc <sosetopt+0x418>
      }
      tp->t_maxseg = *(int*)(arg);    /* set TCP MSS */
 823339c:	e0bfff17 	ldw	r2,-4(fp)
 82333a0:	10800017 	ldw	r2,0(r2)
 82333a4:	1007883a 	mov	r3,r2
 82333a8:	e0bffc17 	ldw	r2,-16(fp)
 82333ac:	10c00a0d 	sth	r3,40(r2)
      tp->t_flags |= TF_MAXSEG;   /* mark as user set max seg */
 82333b0:	e0bffc17 	ldw	r2,-16(fp)
 82333b4:	10800b0b 	ldhu	r2,44(r2)
 82333b8:	10810014 	ori	r2,r2,1024
 82333bc:	1007883a 	mov	r3,r2
 82333c0:	e0bffc17 	ldw	r2,-16(fp)
 82333c4:	10c00b0d 	sth	r3,44(r2)
      break;
 82333c8:	00000406 	br	82333dc <sosetopt+0x418>
   }
   default:
      error = ENOPROTOOPT;
 82333cc:	00801b44 	movi	r2,109
 82333d0:	e0bff815 	stw	r2,-32(fp)
      break;
 82333d4:	00000106 	br	82333dc <sosetopt+0x418>
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
         goto bad;
      }
      break;
 82333d8:	0001883a 	nop
   default:
      error = ENOPROTOOPT;
      break;
   }
bad:
   return (error);
 82333dc:	e0bff817 	ldw	r2,-32(fp)
}
 82333e0:	e037883a 	mov	sp,fp
 82333e4:	dfc00117 	ldw	ra,4(sp)
 82333e8:	df000017 	ldw	fp,0(sp)
 82333ec:	dec00204 	addi	sp,sp,8
 82333f0:	f800283a 	ret

082333f4 <sogetopt>:

int
sogetopt(struct socket * so, 
   int   optname,
   void *   val)
{
 82333f4:	defff504 	addi	sp,sp,-44
 82333f8:	dfc00a15 	stw	ra,40(sp)
 82333fc:	df000915 	stw	fp,36(sp)
 8233400:	df000904 	addi	fp,sp,36
 8233404:	e13ffd15 	stw	r4,-12(fp)
 8233408:	e17ffe15 	stw	r5,-8(fp)
 823340c:	e1bfff15 	stw	r6,-4(fp)
   int   error =  0;
 8233410:	e03ff715 	stw	zero,-36(fp)

   /* sanity check the val parameter */
   if (!val)
 8233414:	e0bfff17 	ldw	r2,-4(fp)
 8233418:	1000021e 	bne	r2,zero,8233424 <sogetopt+0x30>
   {
      return ENP_PARAM;
 823341c:	00bffd84 	movi	r2,-10
 8233420:	00011906 	br	8233888 <sogetopt+0x494>
   }

   switch (optname) 
 8233424:	e0bffe17 	ldw	r2,-8(fp)
 8233428:	10c400e0 	cmpeqi	r3,r2,4099
 823342c:	1800701e 	bne	r3,zero,82335f0 <sogetopt+0x1fc>
 8233430:	10c40108 	cmpgei	r3,r2,4100
 8233434:	1800201e 	bne	r3,zero,82334b8 <sogetopt+0xc4>
 8233438:	10c00420 	cmpeqi	r3,r2,16
 823343c:	1800641e 	bne	r3,zero,82335d0 <sogetopt+0x1dc>
 8233440:	10c00448 	cmpgei	r3,r2,17
 8233444:	18000c1e 	bne	r3,zero,8233478 <sogetopt+0x84>
 8233448:	10c00220 	cmpeqi	r3,r2,8
 823344c:	1800601e 	bne	r3,zero,82335d0 <sogetopt+0x1dc>
 8233450:	10c00248 	cmpgei	r3,r2,9
 8233454:	1800051e 	bne	r3,zero,823346c <sogetopt+0x78>
 8233458:	10c000a0 	cmpeqi	r3,r2,2
 823345c:	1800d61e 	bne	r3,zero,82337b8 <sogetopt+0x3c4>
 8233460:	10800120 	cmpeqi	r2,r2,4
 8233464:	10005a1e 	bne	r2,zero,82335d0 <sogetopt+0x1dc>
 8233468:	00010406 	br	823387c <sogetopt+0x488>
 823346c:	10800308 	cmpgei	r2,r2,12
 8233470:	1001021e 	bne	r2,zero,823387c <sogetopt+0x488>
 8233474:	0000ca06 	br	82337a0 <sogetopt+0x3ac>
 8233478:	10c04020 	cmpeqi	r3,r2,256
 823347c:	1800541e 	bne	r3,zero,82335d0 <sogetopt+0x1dc>
 8233480:	10c04048 	cmpgei	r3,r2,257
 8233484:	1800051e 	bne	r3,zero,823349c <sogetopt+0xa8>
 8233488:	10c00820 	cmpeqi	r3,r2,32
 823348c:	1800501e 	bne	r3,zero,82335d0 <sogetopt+0x1dc>
 8233490:	10802020 	cmpeqi	r2,r2,128
 8233494:	10003f1e 	bne	r2,zero,8233594 <sogetopt+0x1a0>
 8233498:	0000f806 	br	823387c <sogetopt+0x488>
 823349c:	10c40060 	cmpeqi	r3,r2,4097
 82334a0:	18005f1e 	bne	r3,zero,8233620 <sogetopt+0x22c>
 82334a4:	10c40088 	cmpgei	r3,r2,4098
 82334a8:	1800631e 	bne	r3,zero,8233638 <sogetopt+0x244>
 82334ac:	10808020 	cmpeqi	r2,r2,512
 82334b0:	1000471e 	bne	r2,zero,82335d0 <sogetopt+0x1dc>
 82334b4:	0000f106 	br	823387c <sogetopt+0x488>
 82334b8:	10c40420 	cmpeqi	r3,r2,4112
 82334bc:	18007f1e 	bne	r3,zero,82336bc <sogetopt+0x2c8>
 82334c0:	10c40448 	cmpgei	r3,r2,4113
 82334c4:	1800101e 	bne	r3,zero,8233508 <sogetopt+0x114>
 82334c8:	10c401a0 	cmpeqi	r3,r2,4102
 82334cc:	18009b1e 	bne	r3,zero,823373c <sogetopt+0x348>
 82334d0:	10c401c8 	cmpgei	r3,r2,4103
 82334d4:	1800051e 	bne	r3,zero,82334ec <sogetopt+0xf8>
 82334d8:	10c40120 	cmpeqi	r3,r2,4100
 82334dc:	18004a1e 	bne	r3,zero,8233608 <sogetopt+0x214>
 82334e0:	10840160 	cmpeqi	r2,r2,4101
 82334e4:	1000901e 	bne	r2,zero,8233728 <sogetopt+0x334>
 82334e8:	0000e406 	br	823387c <sogetopt+0x488>
 82334ec:	10c40220 	cmpeqi	r3,r2,4104
 82334f0:	1800631e 	bne	r3,zero,8233680 <sogetopt+0x28c>
 82334f4:	10c40210 	cmplti	r3,r2,4104
 82334f8:	1800691e 	bne	r3,zero,82336a0 <sogetopt+0x2ac>
 82334fc:	10840260 	cmpeqi	r2,r2,4105
 8233500:	1000931e 	bne	r2,zero,8233750 <sogetopt+0x35c>
 8233504:	0000dd06 	br	823387c <sogetopt+0x488>
 8233508:	10c404e0 	cmpeqi	r3,r2,4115
 823350c:	18000e1e 	bne	r3,zero,8233548 <sogetopt+0x154>
 8233510:	10c40508 	cmpgei	r3,r2,4116
 8233514:	1800051e 	bne	r3,zero,823352c <sogetopt+0x138>
 8233518:	10c40460 	cmpeqi	r3,r2,4113
 823351c:	18004c1e 	bne	r3,zero,8233650 <sogetopt+0x25c>
 8233520:	108404a0 	cmpeqi	r2,r2,4114
 8233524:	1000501e 	bne	r2,zero,8233668 <sogetopt+0x274>
 8233528:	0000d406 	br	823387c <sogetopt+0x488>
 823352c:	10c800e0 	cmpeqi	r3,r2,8195
 8233530:	1800621e 	bne	r3,zero,82336bc <sogetopt+0x2c8>
 8233534:	10c80120 	cmpeqi	r3,r2,8196
 8233538:	1800aa1e 	bne	r3,zero,82337e4 <sogetopt+0x3f0>
 823353c:	108405a0 	cmpeqi	r2,r2,4118
 8233540:	10008b1e 	bne	r2,zero,8233770 <sogetopt+0x37c>
 8233544:	0000cd06 	br	823387c <sogetopt+0x488>
   {
   case SO_MYADDR:
      /* Get my IP address. */
      if (so->so_state & SS_ISCONNECTED)
 8233548:	e0bffd17 	ldw	r2,-12(fp)
 823354c:	1080088b 	ldhu	r2,34(r2)
 8233550:	10bfffcc 	andi	r2,r2,65535
 8233554:	1080008c 	andi	r2,r2,2
 8233558:	10000726 	beq	r2,zero,8233578 <sogetopt+0x184>
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
 823355c:	e0bffd17 	ldw	r2,-12(fp)
 8233560:	10800117 	ldw	r2,4(r2)
 8233564:	10800a17 	ldw	r2,40(r2)
 8233568:	10c00a17 	ldw	r3,40(r2)
 823356c:	e0bfff17 	ldw	r2,-4(fp)
 8233570:	10c00015 	stw	r3,0(r2)
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
      break;
 8233574:	0000c306 	br	8233884 <sogetopt+0x490>
      if (so->so_state & SS_ISCONNECTED)
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
 8233578:	008209b4 	movhi	r2,2086
 823357c:	10b82404 	addi	r2,r2,-8048
 8233580:	10800017 	ldw	r2,0(r2)
 8233584:	10c00a17 	ldw	r3,40(r2)
 8233588:	e0bfff17 	ldw	r2,-4(fp)
 823358c:	10c00015 	stw	r3,0(r2)
      break;
 8233590:	0000bc06 	br	8233884 <sogetopt+0x490>
   case SO_LINGER:
      {
         struct linger *   l  =  (struct  linger *)val;
 8233594:	e0bfff17 	ldw	r2,-4(fp)
 8233598:	e0bff815 	stw	r2,-32(fp)
         l->l_onoff = so->so_options & SO_LINGER;
 823359c:	e0bffd17 	ldw	r2,-12(fp)
 82335a0:	10800417 	ldw	r2,16(r2)
 82335a4:	10c0200c 	andi	r3,r2,128
 82335a8:	e0bff817 	ldw	r2,-32(fp)
 82335ac:	10c00015 	stw	r3,0(r2)
         l->l_linger = so->so_linger;
 82335b0:	e0bffd17 	ldw	r2,-12(fp)
 82335b4:	1080080b 	ldhu	r2,32(r2)
 82335b8:	10ffffcc 	andi	r3,r2,65535
 82335bc:	18e0001c 	xori	r3,r3,32768
 82335c0:	18e00004 	addi	r3,r3,-32768
 82335c4:	e0bff817 	ldw	r2,-32(fp)
 82335c8:	10c00115 	stw	r3,4(r2)
      }
      break;
 82335cc:	0000ad06 	br	8233884 <sogetopt+0x490>
   case SO_OOBINLINE:
   case SO_DONTROUTE:
   case SO_REUSEADDR:
   case SO_BROADCAST:
   case SO_TCPSACK:
      *(int *)val = so->so_options & optname;
 82335d0:	e0bffd17 	ldw	r2,-12(fp)
 82335d4:	10c00417 	ldw	r3,16(r2)
 82335d8:	e0bffe17 	ldw	r2,-8(fp)
 82335dc:	1884703a 	and	r2,r3,r2
 82335e0:	1007883a 	mov	r3,r2
 82335e4:	e0bfff17 	ldw	r2,-4(fp)
 82335e8:	10c00015 	stw	r3,0(r2)
      break;
 82335ec:	0000a506 	br	8233884 <sogetopt+0x490>

   case SO_SNDLOWAT:
      *(int *)val = (int)so->so_snd.sb_lowat;
 82335f0:	e0bffd17 	ldw	r2,-12(fp)
 82335f4:	10801617 	ldw	r2,88(r2)
 82335f8:	1007883a 	mov	r3,r2
 82335fc:	e0bfff17 	ldw	r2,-4(fp)
 8233600:	10c00015 	stw	r3,0(r2)
      break;
 8233604:	00009f06 	br	8233884 <sogetopt+0x490>

   case SO_RCVLOWAT:
      *(int *)val = (int)so->so_rcv.sb_lowat;
 8233608:	e0bffd17 	ldw	r2,-12(fp)
 823360c:	10800e17 	ldw	r2,56(r2)
 8233610:	1007883a 	mov	r3,r2
 8233614:	e0bfff17 	ldw	r2,-4(fp)
 8233618:	10c00015 	stw	r3,0(r2)
      break;
 823361c:	00009906 	br	8233884 <sogetopt+0x490>

   case SO_SNDBUF:
      *(int *)val = (int)so->so_snd.sb_hiwat;
 8233620:	e0bffd17 	ldw	r2,-12(fp)
 8233624:	10801317 	ldw	r2,76(r2)
 8233628:	1007883a 	mov	r3,r2
 823362c:	e0bfff17 	ldw	r2,-4(fp)
 8233630:	10c00015 	stw	r3,0(r2)
      break;
 8233634:	00009306 	br	8233884 <sogetopt+0x490>

   case SO_RCVBUF:
      *(int *)val = (int)so->so_rcv.sb_hiwat;
 8233638:	e0bffd17 	ldw	r2,-12(fp)
 823363c:	10800b17 	ldw	r2,44(r2)
 8233640:	1007883a 	mov	r3,r2
 8233644:	e0bfff17 	ldw	r2,-4(fp)
 8233648:	10c00015 	stw	r3,0(r2)
      break;
 823364c:	00008d06 	br	8233884 <sogetopt+0x490>

   case SO_RXDATA:   /* added, JB */
      *(int *)val = (int)so->so_rcv.sb_cc;
 8233650:	e0bffd17 	ldw	r2,-12(fp)
 8233654:	10800a17 	ldw	r2,40(r2)
 8233658:	1007883a 	mov	r3,r2
 823365c:	e0bfff17 	ldw	r2,-4(fp)
 8233660:	10c00015 	stw	r3,0(r2)
      break;
 8233664:	00008706 	br	8233884 <sogetopt+0x490>

   case SO_TXDATA:   /* added for rel 1.8 */
      *(int *)val = (int)so->so_snd.sb_cc;
 8233668:	e0bffd17 	ldw	r2,-12(fp)
 823366c:	10801217 	ldw	r2,72(r2)
 8233670:	1007883a 	mov	r3,r2
 8233674:	e0bfff17 	ldw	r2,-4(fp)
 8233678:	10c00015 	stw	r3,0(r2)
      break;
 823367c:	00008106 	br	8233884 <sogetopt+0x490>

   case SO_TYPE:
      *(int *)val = so->so_type;
 8233680:	e0bffd17 	ldw	r2,-12(fp)
 8233684:	10800983 	ldbu	r2,38(r2)
 8233688:	10c03fcc 	andi	r3,r2,255
 823368c:	18c0201c 	xori	r3,r3,128
 8233690:	18ffe004 	addi	r3,r3,-128
 8233694:	e0bfff17 	ldw	r2,-4(fp)
 8233698:	10c00015 	stw	r3,0(r2)
      break;
 823369c:	00007906 	br	8233884 <sogetopt+0x490>

   case SO_ERROR:
      *(int *)val = so->so_error;
 82336a0:	e0bffd17 	ldw	r2,-12(fp)
 82336a4:	10c00617 	ldw	r3,24(r2)
 82336a8:	e0bfff17 	ldw	r2,-4(fp)
 82336ac:	10c00015 	stw	r3,0(r2)
      so->so_error = 0;
 82336b0:	e0bffd17 	ldw	r2,-12(fp)
 82336b4:	10000615 	stw	zero,24(r2)
      break;
 82336b8:	00007206 	br	8233884 <sogetopt+0x490>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 82336bc:	e0bffd17 	ldw	r2,-12(fp)
 82336c0:	10800983 	ldbu	r2,38(r2)
 82336c4:	10803fcc 	andi	r2,r2,255
 82336c8:	1080201c 	xori	r2,r2,128
 82336cc:	10bfe004 	addi	r2,r2,-128
 82336d0:	10800060 	cmpeqi	r2,r2,1
 82336d4:	1000031e 	bne	r2,zero,82336e4 <sogetopt+0x2f0>
      {
         error = EINVAL;
 82336d8:	00800584 	movi	r2,22
 82336dc:	e0bff715 	stw	r2,-36(fp)
         break;
 82336e0:	00006806 	br	8233884 <sogetopt+0x490>
      }
      inp = (struct inpcb *)(so->so_pcb);
 82336e4:	e0bffd17 	ldw	r2,-12(fp)
 82336e8:	10800117 	ldw	r2,4(r2)
 82336ec:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 82336f0:	e0bff917 	ldw	r2,-28(fp)
 82336f4:	10800917 	ldw	r2,36(r2)
 82336f8:	e0bffa15 	stw	r2,-24(fp)
      if(!tp)
 82336fc:	e0bffa17 	ldw	r2,-24(fp)
 8233700:	1000031e 	bne	r2,zero,8233710 <sogetopt+0x31c>
      {
         error = ENOTCONN;
 8233704:	00802004 	movi	r2,128
 8233708:	e0bff715 	stw	r2,-36(fp)
         break;
 823370c:	00005d06 	br	8233884 <sogetopt+0x490>
      }
      *(int *)val = tp->t_maxseg;     /* Fill in TCP MSS for current socket */
 8233710:	e0bffa17 	ldw	r2,-24(fp)
 8233714:	10800a0b 	ldhu	r2,40(r2)
 8233718:	10ffffcc 	andi	r3,r2,65535
 823371c:	e0bfff17 	ldw	r2,-4(fp)
 8233720:	10c00015 	stw	r3,0(r2)
      break;
 8233724:	00005706 	br	8233884 <sogetopt+0x490>
   }
 
   case SO_SNDTIMEO:
      *(short*)val = so->so_snd.sb_timeo;
 8233728:	e0bffd17 	ldw	r2,-12(fp)
 823372c:	10c0198b 	ldhu	r3,102(r2)
 8233730:	e0bfff17 	ldw	r2,-4(fp)
 8233734:	10c0000d 	sth	r3,0(r2)
      break;
 8233738:	00005206 	br	8233884 <sogetopt+0x490>

   case SO_RCVTIMEO:
      *(short*)val = so->so_rcv.sb_timeo;
 823373c:	e0bffd17 	ldw	r2,-12(fp)
 8233740:	10c0118b 	ldhu	r3,70(r2)
 8233744:	e0bfff17 	ldw	r2,-4(fp)
 8233748:	10c0000d 	sth	r3,0(r2)
      break;
 823374c:	00004d06 	br	8233884 <sogetopt+0x490>

   case SO_HOPCNT:
      *(int *)val = so->so_hopcnt;
 8233750:	e0bffd17 	ldw	r2,-12(fp)
 8233754:	108009c3 	ldbu	r2,39(r2)
 8233758:	10c03fcc 	andi	r3,r2,255
 823375c:	18c0201c 	xori	r3,r3,128
 8233760:	18ffe004 	addi	r3,r3,-128
 8233764:	e0bfff17 	ldw	r2,-4(fp)
 8233768:	10c00015 	stw	r3,0(r2)
      break;
 823376c:	00004506 	br	8233884 <sogetopt+0x490>

   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
 8233770:	e0bffd17 	ldw	r2,-12(fp)
 8233774:	1080088b 	ldhu	r2,34(r2)
 8233778:	10bfffcc 	andi	r2,r2,65535
 823377c:	1080400c 	andi	r2,r2,256
 8233780:	10000426 	beq	r2,zero,8233794 <sogetopt+0x3a0>
         *(int *)val = 1;   /* return 1 in val */
 8233784:	e0bfff17 	ldw	r2,-4(fp)
 8233788:	00c00044 	movi	r3,1
 823378c:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;     /* return 0 in val */
      break;
 8233790:	00003c06 	br	8233884 <sogetopt+0x490>
   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
         *(int *)val = 1;   /* return 1 in val */
      else
         *(int *)val = 0;     /* return 0 in val */
 8233794:	e0bfff17 	ldw	r2,-4(fp)
 8233798:	10000015 	stw	zero,0(r2)
      break;
 823379c:	00003906 	br	8233884 <sogetopt+0x490>
#ifdef IP_MULTICAST

   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      error = ip_getmoptions(optname, so, val);
 82337a0:	e1bfff17 	ldw	r6,-4(fp)
 82337a4:	e17ffd17 	ldw	r5,-12(fp)
 82337a8:	e13ffe17 	ldw	r4,-8(fp)
 82337ac:	82463c40 	call	82463c4 <ip_getmoptions>
 82337b0:	e0bff715 	stw	r2,-36(fp)
      break;
 82337b4:	00003306 	br	8233884 <sogetopt+0x490>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
 82337b8:	e0bffd17 	ldw	r2,-12(fp)
 82337bc:	10800417 	ldw	r2,16(r2)
 82337c0:	1088000c 	andi	r2,r2,8192
 82337c4:	10000426 	beq	r2,zero,82337d8 <sogetopt+0x3e4>
         *(int *)val = 1;
 82337c8:	e0bfff17 	ldw	r2,-4(fp)
 82337cc:	00c00044 	movi	r3,1
 82337d0:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;
      break;
 82337d4:	00002b06 	br	8233884 <sogetopt+0x490>
   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
         *(int *)val = 1;
      else
         *(int *)val = 0;
 82337d8:	e0bfff17 	ldw	r2,-4(fp)
 82337dc:	10000015 	stw	zero,0(r2)
      break;
 82337e0:	00002806 	br	8233884 <sogetopt+0x490>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 82337e4:	e0bffd17 	ldw	r2,-12(fp)
 82337e8:	10800983 	ldbu	r2,38(r2)
 82337ec:	10803fcc 	andi	r2,r2,255
 82337f0:	1080201c 	xori	r2,r2,128
 82337f4:	10bfe004 	addi	r2,r2,-128
 82337f8:	10800060 	cmpeqi	r2,r2,1
 82337fc:	1000031e 	bne	r2,zero,823380c <sogetopt+0x418>
      {
         error = EINVAL;
 8233800:	00800584 	movi	r2,22
 8233804:	e0bff715 	stw	r2,-36(fp)
         break;
 8233808:	00001e06 	br	8233884 <sogetopt+0x490>
      }
      inp = (struct inpcb *)(so->so_pcb);
 823380c:	e0bffd17 	ldw	r2,-12(fp)
 8233810:	10800117 	ldw	r2,4(r2)
 8233814:	e0bffb15 	stw	r2,-20(fp)
      tp = intotcpcb(inp);
 8233818:	e0bffb17 	ldw	r2,-20(fp)
 823381c:	10800917 	ldw	r2,36(r2)
 8233820:	e0bffc15 	stw	r2,-16(fp)
      if (!tp)
 8233824:	e0bffc17 	ldw	r2,-16(fp)
 8233828:	1000031e 	bne	r2,zero,8233838 <sogetopt+0x444>
      {
         error = ENOTCONN;
 823382c:	00802004 	movi	r2,128
 8233830:	e0bff715 	stw	r2,-36(fp)
         break;
 8233834:	00001306 	br	8233884 <sogetopt+0x490>
      }
      /* try to make sure that the argument pointer is valid */
      if (val == NULL)
 8233838:	e0bfff17 	ldw	r2,-4(fp)
 823383c:	1000031e 	bne	r2,zero,823384c <sogetopt+0x458>
      {
         error = ENP_PARAM;
 8233840:	00bffd84 	movi	r2,-10
 8233844:	e0bff715 	stw	r2,-36(fp)
         break;
 8233848:	00000e06 	br	8233884 <sogetopt+0x490>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
 823384c:	e0bffc17 	ldw	r2,-16(fp)
 8233850:	10800b0b 	ldhu	r2,44(r2)
 8233854:	10bfffcc 	andi	r2,r2,65535
 8233858:	1080010c 	andi	r2,r2,4
 823385c:	10000426 	beq	r2,zero,8233870 <sogetopt+0x47c>
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
 8233860:	e0bfff17 	ldw	r2,-4(fp)
 8233864:	00c00044 	movi	r3,1
 8233868:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */

      break;
 823386c:	00000506 	br	8233884 <sogetopt+0x490>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */
 8233870:	e0bfff17 	ldw	r2,-4(fp)
 8233874:	10000015 	stw	zero,0(r2)

      break;
 8233878:	00000206 	br	8233884 <sogetopt+0x490>
   }

   default:
      return ENOPROTOOPT;
 823387c:	00801b44 	movi	r2,109
 8233880:	00000106 	br	8233888 <sogetopt+0x494>
   }
   return error;     /* no error */
 8233884:	e0bff717 	ldw	r2,-36(fp)
}
 8233888:	e037883a 	mov	sp,fp
 823388c:	dfc00117 	ldw	ra,4(sp)
 8233890:	df000017 	ldw	fp,0(sp)
 8233894:	dec00204 	addi	sp,sp,8
 8233898:	f800283a 	ret

0823389c <sohasoutofband>:
 * RETURNS: 
 */

void
sohasoutofband(struct socket * so)
{
 823389c:	defffd04 	addi	sp,sp,-12
 82338a0:	dfc00215 	stw	ra,8(sp)
 82338a4:	df000115 	stw	fp,4(sp)
 82338a8:	df000104 	addi	fp,sp,4
 82338ac:	e13fff15 	stw	r4,-4(fp)
   so->so_error = EHAVEOOB;   /* WILL be picked up by the socket */
 82338b0:	e0bfff17 	ldw	r2,-4(fp)
 82338b4:	00c03644 	movi	r3,217
 82338b8:	10c00615 	stw	r3,24(r2)
   sorwakeup (so);
 82338bc:	e0bfff17 	ldw	r2,-4(fp)
 82338c0:	10800a04 	addi	r2,r2,40
 82338c4:	100b883a 	mov	r5,r2
 82338c8:	e13fff17 	ldw	r4,-4(fp)
 82338cc:	82340c40 	call	82340c4 <sbwakeup>
}
 82338d0:	0001883a 	nop
 82338d4:	e037883a 	mov	sp,fp
 82338d8:	dfc00117 	ldw	ra,4(sp)
 82338dc:	df000017 	ldw	fp,0(sp)
 82338e0:	dec00204 	addi	sp,sp,8
 82338e4:	f800283a 	ret

082338e8 <soisconnecting>:
 * RETURNS: 
 */

void
soisconnecting(struct socket * so)
{
 82338e8:	defffd04 	addi	sp,sp,-12
 82338ec:	dfc00215 	stw	ra,8(sp)
 82338f0:	df000115 	stw	fp,4(sp)
 82338f4:	df000104 	addi	fp,sp,4
 82338f8:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~(SS_ISCONNECTED|SS_ISDISCONNECTING);
 82338fc:	e0bfff17 	ldw	r2,-4(fp)
 8233900:	10c0088b 	ldhu	r3,34(r2)
 8233904:	00bffd44 	movi	r2,-11
 8233908:	1884703a 	and	r2,r3,r2
 823390c:	1007883a 	mov	r3,r2
 8233910:	e0bfff17 	ldw	r2,-4(fp)
 8233914:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTING;
 8233918:	e0bfff17 	ldw	r2,-4(fp)
 823391c:	1080088b 	ldhu	r2,34(r2)
 8233920:	10800114 	ori	r2,r2,4
 8233924:	1007883a 	mov	r3,r2
 8233928:	e0bfff17 	ldw	r2,-4(fp)
 823392c:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 8233930:	e0bfff17 	ldw	r2,-4(fp)
 8233934:	10800904 	addi	r2,r2,36
 8233938:	1009883a 	mov	r4,r2
 823393c:	822954c0 	call	822954c <tcp_wakeup>
}
 8233940:	0001883a 	nop
 8233944:	e037883a 	mov	sp,fp
 8233948:	dfc00117 	ldw	ra,4(sp)
 823394c:	df000017 	ldw	fp,0(sp)
 8233950:	dec00204 	addi	sp,sp,8
 8233954:	f800283a 	ret

08233958 <soisconnected>:
 * RETURNS: 
 */

void
soisconnected(struct socket * so)
{
 8233958:	defffc04 	addi	sp,sp,-16
 823395c:	dfc00315 	stw	ra,12(sp)
 8233960:	df000215 	stw	fp,8(sp)
 8233964:	df000204 	addi	fp,sp,8
 8233968:	e13fff15 	stw	r4,-4(fp)
   struct socket *   head  =  so->so_head;
 823396c:	e0bfff17 	ldw	r2,-4(fp)
 8233970:	10801b17 	ldw	r2,108(r2)
 8233974:	e0bffe15 	stw	r2,-8(fp)

   if (head) 
 8233978:	e0bffe17 	ldw	r2,-8(fp)
 823397c:	10001426 	beq	r2,zero,82339d0 <soisconnected+0x78>
   {
      if (soqremque(so, 0) == 0)
 8233980:	000b883a 	mov	r5,zero
 8233984:	e13fff17 	ldw	r4,-4(fp)
 8233988:	8233e640 	call	8233e64 <soqremque>
 823398c:	1000031e 	bne	r2,zero,823399c <soisconnected+0x44>
         panic("soisconnected");
 8233990:	01020974 	movhi	r4,2085
 8233994:	21039304 	addi	r4,r4,3660
 8233998:	8228aec0 	call	8228aec <panic>
      soqinsque(head, so, 1);
 823399c:	01800044 	movi	r6,1
 82339a0:	e17fff17 	ldw	r5,-4(fp)
 82339a4:	e13ffe17 	ldw	r4,-8(fp)
 82339a8:	8233db80 	call	8233db8 <soqinsque>
      sorwakeup(head);
 82339ac:	e0bffe17 	ldw	r2,-8(fp)
 82339b0:	10800a04 	addi	r2,r2,40
 82339b4:	100b883a 	mov	r5,r2
 82339b8:	e13ffe17 	ldw	r4,-8(fp)
 82339bc:	82340c40 	call	82340c4 <sbwakeup>
      tcp_wakeup ((char *)&head->so_timeo);
 82339c0:	e0bffe17 	ldw	r2,-8(fp)
 82339c4:	10800904 	addi	r2,r2,36
 82339c8:	1009883a 	mov	r4,r2
 82339cc:	822954c0 	call	822954c <tcp_wakeup>
   }

   so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 82339d0:	e0bfff17 	ldw	r2,-4(fp)
 82339d4:	10c0088b 	ldhu	r3,34(r2)
 82339d8:	00bffcc4 	movi	r2,-13
 82339dc:	1884703a 	and	r2,r3,r2
 82339e0:	1007883a 	mov	r3,r2
 82339e4:	e0bfff17 	ldw	r2,-4(fp)
 82339e8:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTED;
 82339ec:	e0bfff17 	ldw	r2,-4(fp)
 82339f0:	1080088b 	ldhu	r2,34(r2)
 82339f4:	10800094 	ori	r2,r2,2
 82339f8:	1007883a 	mov	r3,r2
 82339fc:	e0bfff17 	ldw	r2,-4(fp)
 8233a00:	10c0088d 	sth	r3,34(r2)
   so->so_error = 0;
 8233a04:	e0bfff17 	ldw	r2,-4(fp)
 8233a08:	10000615 	stw	zero,24(r2)
   tcp_wakeup  ((char *)&so->so_timeo);
 8233a0c:	e0bfff17 	ldw	r2,-4(fp)
 8233a10:	10800904 	addi	r2,r2,36
 8233a14:	1009883a 	mov	r4,r2
 8233a18:	822954c0 	call	822954c <tcp_wakeup>
   sorwakeup (so);
 8233a1c:	e0bfff17 	ldw	r2,-4(fp)
 8233a20:	10800a04 	addi	r2,r2,40
 8233a24:	100b883a 	mov	r5,r2
 8233a28:	e13fff17 	ldw	r4,-4(fp)
 8233a2c:	82340c40 	call	82340c4 <sbwakeup>
   sowwakeup (so);
 8233a30:	e0bfff17 	ldw	r2,-4(fp)
 8233a34:	10801204 	addi	r2,r2,72
 8233a38:	100b883a 	mov	r5,r2
 8233a3c:	e13fff17 	ldw	r4,-4(fp)
 8233a40:	82340c40 	call	82340c4 <sbwakeup>
}
 8233a44:	0001883a 	nop
 8233a48:	e037883a 	mov	sp,fp
 8233a4c:	dfc00117 	ldw	ra,4(sp)
 8233a50:	df000017 	ldw	fp,0(sp)
 8233a54:	dec00204 	addi	sp,sp,8
 8233a58:	f800283a 	ret

08233a5c <soisdisconnecting>:
 * RETURNS: 
 */

void
soisdisconnecting(struct socket * so)
{
 8233a5c:	defffd04 	addi	sp,sp,-12
 8233a60:	dfc00215 	stw	ra,8(sp)
 8233a64:	df000115 	stw	fp,4(sp)
 8233a68:	df000104 	addi	fp,sp,4
 8233a6c:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~SS_ISCONNECTING;
 8233a70:	e0bfff17 	ldw	r2,-4(fp)
 8233a74:	10c0088b 	ldhu	r3,34(r2)
 8233a78:	00bffec4 	movi	r2,-5
 8233a7c:	1884703a 	and	r2,r3,r2
 8233a80:	1007883a 	mov	r3,r2
 8233a84:	e0bfff17 	ldw	r2,-4(fp)
 8233a88:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_ISDISCONNECTING|SS_CANTRCVMORE|SS_CANTSENDMORE);
 8233a8c:	e0bfff17 	ldw	r2,-4(fp)
 8233a90:	1080088b 	ldhu	r2,34(r2)
 8233a94:	10800e14 	ori	r2,r2,56
 8233a98:	1007883a 	mov	r3,r2
 8233a9c:	e0bfff17 	ldw	r2,-4(fp)
 8233aa0:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup  ((char *)&so->so_timeo);   
 8233aa4:	e0bfff17 	ldw	r2,-4(fp)
 8233aa8:	10800904 	addi	r2,r2,36
 8233aac:	1009883a 	mov	r4,r2
 8233ab0:	822954c0 	call	822954c <tcp_wakeup>
   sowwakeup (so);
 8233ab4:	e0bfff17 	ldw	r2,-4(fp)
 8233ab8:	10801204 	addi	r2,r2,72
 8233abc:	100b883a 	mov	r5,r2
 8233ac0:	e13fff17 	ldw	r4,-4(fp)
 8233ac4:	82340c40 	call	82340c4 <sbwakeup>
   sorwakeup (so);
 8233ac8:	e0bfff17 	ldw	r2,-4(fp)
 8233acc:	10800a04 	addi	r2,r2,40
 8233ad0:	100b883a 	mov	r5,r2
 8233ad4:	e13fff17 	ldw	r4,-4(fp)
 8233ad8:	82340c40 	call	82340c4 <sbwakeup>
}
 8233adc:	0001883a 	nop
 8233ae0:	e037883a 	mov	sp,fp
 8233ae4:	dfc00117 	ldw	ra,4(sp)
 8233ae8:	df000017 	ldw	fp,0(sp)
 8233aec:	dec00204 	addi	sp,sp,8
 8233af0:	f800283a 	ret

08233af4 <soisdisconnected>:
 * RETURNS: 
 */

void
soisdisconnected(struct socket * so)
{
 8233af4:	defffd04 	addi	sp,sp,-12
 8233af8:	dfc00215 	stw	ra,8(sp)
 8233afc:	df000115 	stw	fp,4(sp)
 8233b00:	df000104 	addi	fp,sp,4
 8233b04:	e13fff15 	stw	r4,-4(fp)
   if (so->so_state & SS_ISCONNECTING)
 8233b08:	e0bfff17 	ldw	r2,-4(fp)
 8233b0c:	1080088b 	ldhu	r2,34(r2)
 8233b10:	10bfffcc 	andi	r2,r2,65535
 8233b14:	1080010c 	andi	r2,r2,4
 8233b18:	10000626 	beq	r2,zero,8233b34 <soisdisconnected+0x40>
      so->so_state |= SS_WASCONNECTING;
 8233b1c:	e0bfff17 	ldw	r2,-4(fp)
 8233b20:	1080088b 	ldhu	r2,34(r2)
 8233b24:	10880014 	ori	r2,r2,8192
 8233b28:	1007883a 	mov	r3,r2
 8233b2c:	e0bfff17 	ldw	r2,-4(fp)
 8233b30:	10c0088d 	sth	r3,34(r2)
   so->so_state &= ~(SS_ISCONNECTING|SS_ISCONNECTED|SS_ISDISCONNECTING);
 8233b34:	e0bfff17 	ldw	r2,-4(fp)
 8233b38:	10c0088b 	ldhu	r3,34(r2)
 8233b3c:	00bffc44 	movi	r2,-15
 8233b40:	1884703a 	and	r2,r3,r2
 8233b44:	1007883a 	mov	r3,r2
 8233b48:	e0bfff17 	ldw	r2,-4(fp)
 8233b4c:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_CANTRCVMORE|SS_CANTSENDMORE);
 8233b50:	e0bfff17 	ldw	r2,-4(fp)
 8233b54:	1080088b 	ldhu	r2,34(r2)
 8233b58:	10800c14 	ori	r2,r2,48
 8233b5c:	1007883a 	mov	r3,r2
 8233b60:	e0bfff17 	ldw	r2,-4(fp)
 8233b64:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 8233b68:	e0bfff17 	ldw	r2,-4(fp)
 8233b6c:	10800904 	addi	r2,r2,36
 8233b70:	1009883a 	mov	r4,r2
 8233b74:	822954c0 	call	822954c <tcp_wakeup>
   sowwakeup (so);
 8233b78:	e0bfff17 	ldw	r2,-4(fp)
 8233b7c:	10801204 	addi	r2,r2,72
 8233b80:	100b883a 	mov	r5,r2
 8233b84:	e13fff17 	ldw	r4,-4(fp)
 8233b88:	82340c40 	call	82340c4 <sbwakeup>
   sorwakeup (so);
 8233b8c:	e0bfff17 	ldw	r2,-4(fp)
 8233b90:	10800a04 	addi	r2,r2,40
 8233b94:	100b883a 	mov	r5,r2
 8233b98:	e13fff17 	ldw	r4,-4(fp)
 8233b9c:	82340c40 	call	82340c4 <sbwakeup>
}
 8233ba0:	0001883a 	nop
 8233ba4:	e037883a 	mov	sp,fp
 8233ba8:	dfc00117 	ldw	ra,4(sp)
 8233bac:	df000017 	ldw	fp,0(sp)
 8233bb0:	dec00204 	addi	sp,sp,8
 8233bb4:	f800283a 	ret

08233bb8 <sonewconn>:
 * RETURNS: 
 */

struct socket *   
sonewconn(struct socket * head)
{
 8233bb8:	defffb04 	addi	sp,sp,-20
 8233bbc:	dfc00415 	stw	ra,16(sp)
 8233bc0:	df000315 	stw	fp,12(sp)
 8233bc4:	df000304 	addi	fp,sp,12
 8233bc8:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
 8233bcc:	e0bfff17 	ldw	r2,-4(fp)
 8233bd0:	10801e43 	ldbu	r2,121(r2)
 8233bd4:	10c03fcc 	andi	r3,r2,255
 8233bd8:	18c0201c 	xori	r3,r3,128
 8233bdc:	18ffe004 	addi	r3,r3,-128
 8233be0:	e0bfff17 	ldw	r2,-4(fp)
 8233be4:	10801e03 	ldbu	r2,120(r2)
 8233be8:	10803fcc 	andi	r2,r2,255
 8233bec:	1080201c 	xori	r2,r2,128
 8233bf0:	10bfe004 	addi	r2,r2,-128
 8233bf4:	1889883a 	add	r4,r3,r2
 8233bf8:	e0bfff17 	ldw	r2,-4(fp)
 8233bfc:	10801e83 	ldbu	r2,122(r2)
 8233c00:	10c03fcc 	andi	r3,r2,255
 8233c04:	18c0201c 	xori	r3,r3,128
 8233c08:	18ffe004 	addi	r3,r3,-128
 8233c0c:	1805883a 	mov	r2,r3
 8233c10:	1085883a 	add	r2,r2,r2
 8233c14:	10c5883a 	add	r2,r2,r3
 8233c18:	1006d7fa 	srli	r3,r2,31
 8233c1c:	1885883a 	add	r2,r3,r2
 8233c20:	1005d07a 	srai	r2,r2,1
 8233c24:	11005b16 	blt	r2,r4,8233d94 <sonewconn+0x1dc>
      goto bad;
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 8233c28:	01002104 	movi	r4,132
 8233c2c:	822dfec0 	call	822dfec <npalloc>
 8233c30:	e0bffd15 	stw	r2,-12(fp)
 8233c34:	e0bffd17 	ldw	r2,-12(fp)
 8233c38:	10005826 	beq	r2,zero,8233d9c <sonewconn+0x1e4>
      goto bad;
   so->next = NULL;
 8233c3c:	e0bffd17 	ldw	r2,-12(fp)
 8233c40:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);      /* Place newly created socket in a queue */
 8233c44:	e17ffd17 	ldw	r5,-12(fp)
 8233c48:	010209b4 	movhi	r4,2086
 8233c4c:	21396104 	addi	r4,r4,-6780
 8233c50:	822cdfc0 	call	822cdfc <putq>
   so->so_type = head->so_type;
 8233c54:	e0bfff17 	ldw	r2,-4(fp)
 8233c58:	10c00983 	ldbu	r3,38(r2)
 8233c5c:	e0bffd17 	ldw	r2,-12(fp)
 8233c60:	10c00985 	stb	r3,38(r2)
   so->so_options = head->so_options &~ (unshort)SO_ACCEPTCONN;
 8233c64:	e0bfff17 	ldw	r2,-4(fp)
 8233c68:	10c00417 	ldw	r3,16(r2)
 8233c6c:	00bfff44 	movi	r2,-3
 8233c70:	1886703a 	and	r3,r3,r2
 8233c74:	e0bffd17 	ldw	r2,-12(fp)
 8233c78:	10c00415 	stw	r3,16(r2)
   so->so_linger = head->so_linger;
 8233c7c:	e0bfff17 	ldw	r2,-4(fp)
 8233c80:	10c0080b 	ldhu	r3,32(r2)
 8233c84:	e0bffd17 	ldw	r2,-12(fp)
 8233c88:	10c0080d 	sth	r3,32(r2)
   so->so_state = head->so_state | (unshort)SS_NOFDREF;
 8233c8c:	e0bfff17 	ldw	r2,-4(fp)
 8233c90:	1080088b 	ldhu	r2,34(r2)
 8233c94:	10800054 	ori	r2,r2,1
 8233c98:	1007883a 	mov	r3,r2
 8233c9c:	e0bffd17 	ldw	r2,-12(fp)
 8233ca0:	10c0088d 	sth	r3,34(r2)
   so->so_proto = head->so_proto;
 8233ca4:	e0bfff17 	ldw	r2,-4(fp)
 8233ca8:	10c00217 	ldw	r3,8(r2)
 8233cac:	e0bffd17 	ldw	r2,-12(fp)
 8233cb0:	10c00215 	stw	r3,8(r2)
   so->so_timeo = head->so_timeo;
 8233cb4:	e0bfff17 	ldw	r2,-4(fp)
 8233cb8:	10c0090b 	ldhu	r3,36(r2)
 8233cbc:	e0bffd17 	ldw	r2,-12(fp)
 8233cc0:	10c0090d 	sth	r3,36(r2)
   so->so_rcv.sb_hiwat = (u_int)tcp_recvspace;
 8233cc4:	d0e04117 	ldw	r3,-32508(gp)
 8233cc8:	e0bffd17 	ldw	r2,-12(fp)
 8233ccc:	10c00b15 	stw	r3,44(r2)
   so->so_snd.sb_hiwat = (u_int)tcp_sendspace;
 8233cd0:	d0e04017 	ldw	r3,-32512(gp)
 8233cd4:	e0bffd17 	ldw	r2,-12(fp)
 8233cd8:	10c01315 	stw	r3,76(r2)
   soqinsque (head, so, 0);
 8233cdc:	000d883a 	mov	r6,zero
 8233ce0:	e17ffd17 	ldw	r5,-12(fp)
 8233ce4:	e13fff17 	ldw	r4,-4(fp)
 8233ce8:	8233db80 	call	8233db8 <soqinsque>
   so->so_req = PRU_ATTACH;
 8233cec:	e0bffd17 	ldw	r2,-12(fp)
 8233cf0:	10000715 	stw	zero,28(r2)
   so->so_domain = head->so_domain;
 8233cf4:	e0bfff17 	ldw	r2,-4(fp)
 8233cf8:	10c00517 	ldw	r3,20(r2)
 8233cfc:	e0bffd17 	ldw	r2,-12(fp)
 8233d00:	10c00515 	stw	r3,20(r2)

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
 8233d04:	e0bffd17 	ldw	r2,-12(fp)
 8233d08:	10800217 	ldw	r2,8(r2)
 8233d0c:	10800317 	ldw	r2,12(r2)
 8233d10:	000d883a 	mov	r6,zero
 8233d14:	000b883a 	mov	r5,zero
 8233d18:	e13ffd17 	ldw	r4,-12(fp)
 8233d1c:	103ee83a 	callr	r2
 8233d20:	10000f1e 	bne	r2,zero,8233d60 <sonewconn+0x1a8>
      goto bad2;
   if (so_evtmap)
 8233d24:	d0a0ce03 	ldbu	r2,-31944(gp)
 8233d28:	10803fcc 	andi	r2,r2,255
 8233d2c:	10000a26 	beq	r2,zero,8233d58 <sonewconn+0x1a0>
   {
      rc = (*so_evtmap_create) (so);                       
 8233d30:	d0a0cc17 	ldw	r2,-31952(gp)
 8233d34:	e13ffd17 	ldw	r4,-12(fp)
 8233d38:	103ee83a 	callr	r2
 8233d3c:	e0bffe15 	stw	r2,-8(fp)
      if (rc != 0) goto bad2;
 8233d40:	e0bffe17 	ldw	r2,-8(fp)
 8233d44:	1000081e 	bne	r2,zero,8233d68 <sonewconn+0x1b0>
      so->owner = head->owner;
 8233d48:	e0bfff17 	ldw	r2,-4(fp)
 8233d4c:	10c02003 	ldbu	r3,128(r2)
 8233d50:	e0bffd17 	ldw	r2,-12(fp)
 8233d54:	10c02005 	stb	r3,128(r2)
   }
   return (so);
 8233d58:	e0bffd17 	ldw	r2,-12(fp)
 8233d5c:	00001106 	br	8233da4 <sonewconn+0x1ec>
   soqinsque (head, so, 0);
   so->so_req = PRU_ATTACH;
   so->so_domain = head->so_domain;

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
      goto bad2;
 8233d60:	0001883a 	nop
 8233d64:	00000106 	br	8233d6c <sonewconn+0x1b4>
   if (so_evtmap)
   {
      rc = (*so_evtmap_create) (so);                       
      if (rc != 0) goto bad2;
 8233d68:	0001883a 	nop
      so->owner = head->owner;
   }
   return (so);
   
bad2:
   (void) soqremque (so, 0);
 8233d6c:	000b883a 	mov	r5,zero
 8233d70:	e13ffd17 	ldw	r4,-12(fp)
 8233d74:	8233e640 	call	8233e64 <soqremque>
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 8233d78:	e17ffd17 	ldw	r5,-12(fp)
 8233d7c:	010209b4 	movhi	r4,2086
 8233d80:	21396104 	addi	r4,r4,-6780
 8233d84:	822ceac0 	call	822ceac <qdel>
   SOC_FREE(so);  /* Free the socket structure */
 8233d88:	e13ffd17 	ldw	r4,-12(fp)
 8233d8c:	822e0200 	call	822e020 <npfree>
 8233d90:	00000306 	br	8233da0 <sonewconn+0x1e8>
{
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
      goto bad;
 8233d94:	0001883a 	nop
 8233d98:	00000106 	br	8233da0 <sonewconn+0x1e8>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
      goto bad;
 8233d9c:	0001883a 	nop
bad2:
   (void) soqremque (so, 0);
   qdel(&soq, so);   /* Delete the socket entry from the queue */
   SOC_FREE(so);  /* Free the socket structure */
bad:
   return ((struct socket *)0);
 8233da0:	0005883a 	mov	r2,zero
}
 8233da4:	e037883a 	mov	sp,fp
 8233da8:	dfc00117 	ldw	ra,4(sp)
 8233dac:	df000017 	ldw	fp,0(sp)
 8233db0:	dec00204 	addi	sp,sp,8
 8233db4:	f800283a 	ret

08233db8 <soqinsque>:

void
soqinsque(struct socket * head, 
   struct socket *   so,
   int   q)
{
 8233db8:	defffc04 	addi	sp,sp,-16
 8233dbc:	df000315 	stw	fp,12(sp)
 8233dc0:	df000304 	addi	fp,sp,12
 8233dc4:	e13ffd15 	stw	r4,-12(fp)
 8233dc8:	e17ffe15 	stw	r5,-8(fp)
 8233dcc:	e1bfff15 	stw	r6,-4(fp)
   so->so_head = head;
 8233dd0:	e0bffe17 	ldw	r2,-8(fp)
 8233dd4:	e0fffd17 	ldw	r3,-12(fp)
 8233dd8:	10c01b15 	stw	r3,108(r2)
   if (q == 0) 
 8233ddc:	e0bfff17 	ldw	r2,-4(fp)
 8233de0:	10000e1e 	bne	r2,zero,8233e1c <soqinsque+0x64>
   {
      head->so_q0len++;
 8233de4:	e0bffd17 	ldw	r2,-12(fp)
 8233de8:	10801e03 	ldbu	r2,120(r2)
 8233dec:	10800044 	addi	r2,r2,1
 8233df0:	1007883a 	mov	r3,r2
 8233df4:	e0bffd17 	ldw	r2,-12(fp)
 8233df8:	10c01e05 	stb	r3,120(r2)
      so->so_q0 = head->so_q0;
 8233dfc:	e0bffd17 	ldw	r2,-12(fp)
 8233e00:	10c01c17 	ldw	r3,112(r2)
 8233e04:	e0bffe17 	ldw	r2,-8(fp)
 8233e08:	10c01c15 	stw	r3,112(r2)
      head->so_q0 = so;
 8233e0c:	e0bffd17 	ldw	r2,-12(fp)
 8233e10:	e0fffe17 	ldw	r3,-8(fp)
 8233e14:	10c01c15 	stw	r3,112(r2)
   {
      head->so_qlen++;
      so->so_q = head->so_q;
      head->so_q = so;
   }
}
 8233e18:	00000d06 	br	8233e50 <soqinsque+0x98>
      head->so_q0len++;
      so->so_q0 = head->so_q0;
      head->so_q0 = so;
   } else 
   {
      head->so_qlen++;
 8233e1c:	e0bffd17 	ldw	r2,-12(fp)
 8233e20:	10801e43 	ldbu	r2,121(r2)
 8233e24:	10800044 	addi	r2,r2,1
 8233e28:	1007883a 	mov	r3,r2
 8233e2c:	e0bffd17 	ldw	r2,-12(fp)
 8233e30:	10c01e45 	stb	r3,121(r2)
      so->so_q = head->so_q;
 8233e34:	e0bffd17 	ldw	r2,-12(fp)
 8233e38:	10c01d17 	ldw	r3,116(r2)
 8233e3c:	e0bffe17 	ldw	r2,-8(fp)
 8233e40:	10c01d15 	stw	r3,116(r2)
      head->so_q = so;
 8233e44:	e0bffd17 	ldw	r2,-12(fp)
 8233e48:	e0fffe17 	ldw	r3,-8(fp)
 8233e4c:	10c01d15 	stw	r3,116(r2)
   }
}
 8233e50:	0001883a 	nop
 8233e54:	e037883a 	mov	sp,fp
 8233e58:	df000017 	ldw	fp,0(sp)
 8233e5c:	dec00104 	addi	sp,sp,4
 8233e60:	f800283a 	ret

08233e64 <soqremque>:
 * RETURNS: 
 */

int
soqremque(struct socket * so, int q)
{
 8233e64:	defffa04 	addi	sp,sp,-24
 8233e68:	df000515 	stw	fp,20(sp)
 8233e6c:	df000504 	addi	fp,sp,20
 8233e70:	e13ffe15 	stw	r4,-8(fp)
 8233e74:	e17fff15 	stw	r5,-4(fp)
   struct socket *   head, *  prev, *  next;

   head = so->so_head;
 8233e78:	e0bffe17 	ldw	r2,-8(fp)
 8233e7c:	10801b17 	ldw	r2,108(r2)
 8233e80:	e0bffc15 	stw	r2,-16(fp)
   prev = head;
 8233e84:	e0bffc17 	ldw	r2,-16(fp)
 8233e88:	e0bffb15 	stw	r2,-20(fp)
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
 8233e8c:	e0bfff17 	ldw	r2,-4(fp)
 8233e90:	10000326 	beq	r2,zero,8233ea0 <soqremque+0x3c>
 8233e94:	e0bffb17 	ldw	r2,-20(fp)
 8233e98:	10801d17 	ldw	r2,116(r2)
 8233e9c:	00000206 	br	8233ea8 <soqremque+0x44>
 8233ea0:	e0bffb17 	ldw	r2,-20(fp)
 8233ea4:	10801c17 	ldw	r2,112(r2)
 8233ea8:	e0bffd15 	stw	r2,-12(fp)
      if (next == so)
 8233eac:	e0fffd17 	ldw	r3,-12(fp)
 8233eb0:	e0bffe17 	ldw	r2,-8(fp)
 8233eb4:	18800826 	beq	r3,r2,8233ed8 <soqremque+0x74>
         break;
      if (next == head)
 8233eb8:	e0fffd17 	ldw	r3,-12(fp)
 8233ebc:	e0bffc17 	ldw	r2,-16(fp)
 8233ec0:	1880021e 	bne	r3,r2,8233ecc <soqremque+0x68>
         return (0);
 8233ec4:	0005883a 	mov	r2,zero
 8233ec8:	00002406 	br	8233f5c <soqremque+0xf8>
      prev = next;
 8233ecc:	e0bffd17 	ldw	r2,-12(fp)
 8233ed0:	e0bffb15 	stw	r2,-20(fp)
   }
 8233ed4:	003fed06 	br	8233e8c <soqremque+0x28>
   prev = head;
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
      if (next == so)
         break;
 8233ed8:	0001883a 	nop
      if (next == head)
         return (0);
      prev = next;
   }
   if (q == 0) 
 8233edc:	e0bfff17 	ldw	r2,-4(fp)
 8233ee0:	10000b1e 	bne	r2,zero,8233f10 <soqremque+0xac>
   {
      prev->so_q0 = next->so_q0;
 8233ee4:	e0bffd17 	ldw	r2,-12(fp)
 8233ee8:	10c01c17 	ldw	r3,112(r2)
 8233eec:	e0bffb17 	ldw	r2,-20(fp)
 8233ef0:	10c01c15 	stw	r3,112(r2)
      head->so_q0len--;
 8233ef4:	e0bffc17 	ldw	r2,-16(fp)
 8233ef8:	10801e03 	ldbu	r2,120(r2)
 8233efc:	10bfffc4 	addi	r2,r2,-1
 8233f00:	1007883a 	mov	r3,r2
 8233f04:	e0bffc17 	ldw	r2,-16(fp)
 8233f08:	10c01e05 	stb	r3,120(r2)
 8233f0c:	00000a06 	br	8233f38 <soqremque+0xd4>
   } else 
   {
      prev->so_q = next->so_q;
 8233f10:	e0bffd17 	ldw	r2,-12(fp)
 8233f14:	10c01d17 	ldw	r3,116(r2)
 8233f18:	e0bffb17 	ldw	r2,-20(fp)
 8233f1c:	10c01d15 	stw	r3,116(r2)
      head->so_qlen--;
 8233f20:	e0bffc17 	ldw	r2,-16(fp)
 8233f24:	10801e43 	ldbu	r2,121(r2)
 8233f28:	10bfffc4 	addi	r2,r2,-1
 8233f2c:	1007883a 	mov	r3,r2
 8233f30:	e0bffc17 	ldw	r2,-16(fp)
 8233f34:	10c01e45 	stb	r3,121(r2)
   }
   next->so_q0 = next->so_q = 0;
 8233f38:	e0bffd17 	ldw	r2,-12(fp)
 8233f3c:	10001d15 	stw	zero,116(r2)
 8233f40:	e0bffd17 	ldw	r2,-12(fp)
 8233f44:	10c01d17 	ldw	r3,116(r2)
 8233f48:	e0bffd17 	ldw	r2,-12(fp)
 8233f4c:	10c01c15 	stw	r3,112(r2)
   next->so_head = 0;
 8233f50:	e0bffd17 	ldw	r2,-12(fp)
 8233f54:	10001b15 	stw	zero,108(r2)
   return 1;
 8233f58:	00800044 	movi	r2,1
}
 8233f5c:	e037883a 	mov	sp,fp
 8233f60:	df000017 	ldw	fp,0(sp)
 8233f64:	dec00104 	addi	sp,sp,4
 8233f68:	f800283a 	ret

08233f6c <socantsendmore>:
 * RETURNS: 
 */

void
socantsendmore(struct socket * so)
{
 8233f6c:	defffd04 	addi	sp,sp,-12
 8233f70:	dfc00215 	stw	ra,8(sp)
 8233f74:	df000115 	stw	fp,4(sp)
 8233f78:	df000104 	addi	fp,sp,4
 8233f7c:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTSENDMORE;
 8233f80:	e0bfff17 	ldw	r2,-4(fp)
 8233f84:	1080088b 	ldhu	r2,34(r2)
 8233f88:	10800414 	ori	r2,r2,16
 8233f8c:	1007883a 	mov	r3,r2
 8233f90:	e0bfff17 	ldw	r2,-4(fp)
 8233f94:	10c0088d 	sth	r3,34(r2)
   sowwakeup(so);
 8233f98:	e0bfff17 	ldw	r2,-4(fp)
 8233f9c:	10801204 	addi	r2,r2,72
 8233fa0:	100b883a 	mov	r5,r2
 8233fa4:	e13fff17 	ldw	r4,-4(fp)
 8233fa8:	82340c40 	call	82340c4 <sbwakeup>
}
 8233fac:	0001883a 	nop
 8233fb0:	e037883a 	mov	sp,fp
 8233fb4:	dfc00117 	ldw	ra,4(sp)
 8233fb8:	df000017 	ldw	fp,0(sp)
 8233fbc:	dec00204 	addi	sp,sp,8
 8233fc0:	f800283a 	ret

08233fc4 <socantrcvmore>:
 * RETURNS: 
 */

void
socantrcvmore(struct socket * so)
{
 8233fc4:	defffd04 	addi	sp,sp,-12
 8233fc8:	dfc00215 	stw	ra,8(sp)
 8233fcc:	df000115 	stw	fp,4(sp)
 8233fd0:	df000104 	addi	fp,sp,4
 8233fd4:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTRCVMORE;
 8233fd8:	e0bfff17 	ldw	r2,-4(fp)
 8233fdc:	1080088b 	ldhu	r2,34(r2)
 8233fe0:	10800814 	ori	r2,r2,32
 8233fe4:	1007883a 	mov	r3,r2
 8233fe8:	e0bfff17 	ldw	r2,-4(fp)
 8233fec:	10c0088d 	sth	r3,34(r2)
   sorwakeup(so);
 8233ff0:	e0bfff17 	ldw	r2,-4(fp)
 8233ff4:	10800a04 	addi	r2,r2,40
 8233ff8:	100b883a 	mov	r5,r2
 8233ffc:	e13fff17 	ldw	r4,-4(fp)
 8234000:	82340c40 	call	82340c4 <sbwakeup>
}
 8234004:	0001883a 	nop
 8234008:	e037883a 	mov	sp,fp
 823400c:	dfc00117 	ldw	ra,4(sp)
 8234010:	df000017 	ldw	fp,0(sp)
 8234014:	dec00204 	addi	sp,sp,8
 8234018:	f800283a 	ret

0823401c <sbselqueue>:
 * RETURNS: 
 */

void
sbselqueue(struct sockbuf * sb)
{
 823401c:	defffe04 	addi	sp,sp,-8
 8234020:	df000115 	stw	fp,4(sp)
 8234024:	df000104 	addi	fp,sp,4
 8234028:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_SEL;
 823402c:	e0bfff17 	ldw	r2,-4(fp)
 8234030:	1080070b 	ldhu	r2,28(r2)
 8234034:	10800214 	ori	r2,r2,8
 8234038:	1007883a 	mov	r3,r2
 823403c:	e0bfff17 	ldw	r2,-4(fp)
 8234040:	10c0070d 	sth	r3,28(r2)
}
 8234044:	0001883a 	nop
 8234048:	e037883a 	mov	sp,fp
 823404c:	df000017 	ldw	fp,0(sp)
 8234050:	dec00104 	addi	sp,sp,4
 8234054:	f800283a 	ret

08234058 <sbwait>:
 * RETURNS: 
 */

void
sbwait(struct sockbuf * sb)
{
 8234058:	defffd04 	addi	sp,sp,-12
 823405c:	dfc00215 	stw	ra,8(sp)
 8234060:	df000115 	stw	fp,4(sp)
 8234064:	df000104 	addi	fp,sp,4
 8234068:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_WAIT;
 823406c:	e0bfff17 	ldw	r2,-4(fp)
 8234070:	1080070b 	ldhu	r2,28(r2)
 8234074:	10800114 	ori	r2,r2,4
 8234078:	1007883a 	mov	r3,r2
 823407c:	e0bfff17 	ldw	r2,-4(fp)
 8234080:	10c0070d 	sth	r3,28(r2)
   tcp_sleep ((char *)&sb->sb_cc);
 8234084:	e0bfff17 	ldw	r2,-4(fp)
 8234088:	1009883a 	mov	r4,r2
 823408c:	82293d80 	call	82293d8 <tcp_sleep>
   sb->sb_flags &= ~SB_WAIT;
 8234090:	e0bfff17 	ldw	r2,-4(fp)
 8234094:	10c0070b 	ldhu	r3,28(r2)
 8234098:	00bffec4 	movi	r2,-5
 823409c:	1884703a 	and	r2,r3,r2
 82340a0:	1007883a 	mov	r3,r2
 82340a4:	e0bfff17 	ldw	r2,-4(fp)
 82340a8:	10c0070d 	sth	r3,28(r2)
}
 82340ac:	0001883a 	nop
 82340b0:	e037883a 	mov	sp,fp
 82340b4:	dfc00117 	ldw	ra,4(sp)
 82340b8:	df000017 	ldw	fp,0(sp)
 82340bc:	dec00204 	addi	sp,sp,8
 82340c0:	f800283a 	ret

082340c4 <sbwakeup>:
 * RETURNS: 
 */

void
sbwakeup(struct socket * so, struct sockbuf * sb)
{
 82340c4:	defffc04 	addi	sp,sp,-16
 82340c8:	dfc00315 	stw	ra,12(sp)
 82340cc:	df000215 	stw	fp,8(sp)
 82340d0:	df000204 	addi	fp,sp,8
 82340d4:	e13ffe15 	stw	r4,-8(fp)
 82340d8:	e17fff15 	stw	r5,-4(fp)
   if (sb->sb_flags & SB_SEL) 
 82340dc:	e0bfff17 	ldw	r2,-4(fp)
 82340e0:	1080070b 	ldhu	r2,28(r2)
 82340e4:	10bfffcc 	andi	r2,r2,65535
 82340e8:	1080020c 	andi	r2,r2,8
 82340ec:	10000a26 	beq	r2,zero,8234118 <sbwakeup+0x54>
   {
      select_wait = 0;
 82340f0:	d020b00d 	sth	zero,-32064(gp)
#ifndef SOCK_MAP_EVENTS
      tcp_wakeup ((char *)&select_wait);
 82340f4:	d120b004 	addi	r4,gp,-32064
 82340f8:	822954c0 	call	822954c <tcp_wakeup>
#else
      tcp_wakeup2 (so->owner);
#endif      
      sb->sb_flags &= ~SB_SEL;
 82340fc:	e0bfff17 	ldw	r2,-4(fp)
 8234100:	10c0070b 	ldhu	r3,28(r2)
 8234104:	00bffdc4 	movi	r2,-9
 8234108:	1884703a 	and	r2,r3,r2
 823410c:	1007883a 	mov	r3,r2
 8234110:	e0bfff17 	ldw	r2,-4(fp)
 8234114:	10c0070d 	sth	r3,28(r2)
#ifdef SOCK_WAKEALWAYS  /* Always wake the socket? */
   /* Systems Like Green Hills Integrity RTOS, need to process socket
      input even if looks like no one is blocked on the socket */
   tcp_wakeup ((char *)&sb->sb_cc); /* signal wake on socket */
#else /* older BSD style code - only call tcp_wakeup if blocked */
   if (sb->sb_flags & SB_WAIT)   /* is sockbuf's WAIT flag set? */
 8234118:	e0bfff17 	ldw	r2,-4(fp)
 823411c:	1080070b 	ldhu	r2,28(r2)
 8234120:	10bfffcc 	andi	r2,r2,65535
 8234124:	1080010c 	andi	r2,r2,4
 8234128:	10000326 	beq	r2,zero,8234138 <sbwakeup+0x74>
   {
      tcp_wakeup ((char *)&sb->sb_cc);   /* call port wakeup routine */
 823412c:	e0bfff17 	ldw	r2,-4(fp)
 8234130:	1009883a 	mov	r4,r2
 8234134:	822954c0 	call	822954c <tcp_wakeup>
   }
#endif   /* SOCK_WAKEALWAYS */
}
 8234138:	0001883a 	nop
 823413c:	e037883a 	mov	sp,fp
 8234140:	dfc00117 	ldw	ra,4(sp)
 8234144:	df000017 	ldw	fp,0(sp)
 8234148:	dec00204 	addi	sp,sp,8
 823414c:	f800283a 	ret

08234150 <soreserve>:

int
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
 8234150:	defffb04 	addi	sp,sp,-20
 8234154:	dfc00415 	stw	ra,16(sp)
 8234158:	df000315 	stw	fp,12(sp)
 823415c:	df000304 	addi	fp,sp,12
 8234160:	e13ffd15 	stw	r4,-12(fp)
 8234164:	e17ffe15 	stw	r5,-8(fp)
 8234168:	e1bfff15 	stw	r6,-4(fp)
   if (sbreserve(&so->so_snd, sndcc) == 0)
 823416c:	e0bffd17 	ldw	r2,-12(fp)
 8234170:	10801204 	addi	r2,r2,72
 8234174:	e17ffe17 	ldw	r5,-8(fp)
 8234178:	1009883a 	mov	r4,r2
 823417c:	82341d80 	call	82341d8 <sbreserve>
 8234180:	10000e26 	beq	r2,zero,82341bc <soreserve+0x6c>
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
 8234184:	e0bffd17 	ldw	r2,-12(fp)
 8234188:	10800a04 	addi	r2,r2,40
 823418c:	e17fff17 	ldw	r5,-4(fp)
 8234190:	1009883a 	mov	r4,r2
 8234194:	82341d80 	call	82341d8 <sbreserve>
 8234198:	10000226 	beq	r2,zero,82341a4 <soreserve+0x54>
      goto bad2;
   return (0);
 823419c:	0005883a 	mov	r2,zero
 82341a0:	00000806 	br	82341c4 <soreserve+0x74>
   u_long   rcvcc)
{
   if (sbreserve(&so->so_snd, sndcc) == 0)
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
      goto bad2;
 82341a4:	0001883a 	nop
   return (0);
bad2:
   sbrelease(&so->so_snd);
 82341a8:	e0bffd17 	ldw	r2,-12(fp)
 82341ac:	10801204 	addi	r2,r2,72
 82341b0:	1009883a 	mov	r4,r2
 82341b4:	82342280 	call	8234228 <sbrelease>
 82341b8:	00000106 	br	82341c0 <soreserve+0x70>
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
   if (sbreserve(&so->so_snd, sndcc) == 0)
      goto bad;
 82341bc:	0001883a 	nop
      goto bad2;
   return (0);
bad2:
   sbrelease(&so->so_snd);
bad:
   return (ENOBUFS);
 82341c0:	00801a44 	movi	r2,105
}
 82341c4:	e037883a 	mov	sp,fp
 82341c8:	dfc00117 	ldw	ra,4(sp)
 82341cc:	df000017 	ldw	fp,0(sp)
 82341d0:	dec00204 	addi	sp,sp,8
 82341d4:	f800283a 	ret

082341d8 <sbreserve>:
 * RETURNS: 
 */

int
sbreserve(struct sockbuf * sb, u_long cc)
{
 82341d8:	defffd04 	addi	sp,sp,-12
 82341dc:	df000215 	stw	fp,8(sp)
 82341e0:	df000204 	addi	fp,sp,8
 82341e4:	e13ffe15 	stw	r4,-8(fp)
 82341e8:	e17fff15 	stw	r5,-4(fp)
#ifdef COMPILER_32BIT
   if (cc > (u_long)SB_MAX * CLBYTES / (2 * MSIZE + CLBYTES))
      return (0);
#endif
   sb->sb_hiwat = cc;
 82341ec:	e0bffe17 	ldw	r2,-8(fp)
 82341f0:	e0ffff17 	ldw	r3,-4(fp)
 82341f4:	10c00115 	stw	r3,4(r2)
   sb->sb_mbmax = MIN(cc * 2, SB_MAX);
 82341f8:	e0bfff17 	ldw	r2,-4(fp)
 82341fc:	1085883a 	add	r2,r2,r2
 8234200:	10d00070 	cmpltui	r3,r2,16385
 8234204:	1800011e 	bne	r3,zero,823420c <sbreserve+0x34>
 8234208:	00900004 	movi	r2,16384
 823420c:	e0fffe17 	ldw	r3,-8(fp)
 8234210:	18800315 	stw	r2,12(r3)
   return (1);
 8234214:	00800044 	movi	r2,1
}
 8234218:	e037883a 	mov	sp,fp
 823421c:	df000017 	ldw	fp,0(sp)
 8234220:	dec00104 	addi	sp,sp,4
 8234224:	f800283a 	ret

08234228 <sbrelease>:
 * RETURNS: 
 */

void
sbrelease(struct sockbuf * sb)
{
 8234228:	defffd04 	addi	sp,sp,-12
 823422c:	dfc00215 	stw	ra,8(sp)
 8234230:	df000115 	stw	fp,4(sp)
 8234234:	df000104 	addi	fp,sp,4
 8234238:	e13fff15 	stw	r4,-4(fp)
   sbflush(sb);
 823423c:	e13fff17 	ldw	r4,-4(fp)
 8234240:	82347a80 	call	82347a8 <sbflush>
   sb->sb_hiwat = sb->sb_mbmax = 0;
 8234244:	e0bfff17 	ldw	r2,-4(fp)
 8234248:	10000315 	stw	zero,12(r2)
 823424c:	e0bfff17 	ldw	r2,-4(fp)
 8234250:	10c00317 	ldw	r3,12(r2)
 8234254:	e0bfff17 	ldw	r2,-4(fp)
 8234258:	10c00115 	stw	r3,4(r2)
}
 823425c:	0001883a 	nop
 8234260:	e037883a 	mov	sp,fp
 8234264:	dfc00117 	ldw	ra,4(sp)
 8234268:	df000017 	ldw	fp,0(sp)
 823426c:	dec00204 	addi	sp,sp,8
 8234270:	f800283a 	ret

08234274 <sbappend>:
 * RETURNS: 
 */

void
sbappend(struct sockbuf * sb, struct mbuf * m)
{
 8234274:	defffb04 	addi	sp,sp,-20
 8234278:	dfc00415 	stw	ra,16(sp)
 823427c:	df000315 	stw	fp,12(sp)
 8234280:	df000304 	addi	fp,sp,12
 8234284:	e13ffe15 	stw	r4,-8(fp)
 8234288:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  n;

   if (m == 0)
 823428c:	e0bfff17 	ldw	r2,-4(fp)
 8234290:	10001a26 	beq	r2,zero,82342fc <sbappend+0x88>
      return;
   ENTER_CRIT_SECTION(sb);
 8234294:	822d5ec0 	call	822d5ec <irq_Mask>
   if ((n = sb->sb_mb) != NULL) 
 8234298:	e0bffe17 	ldw	r2,-8(fp)
 823429c:	10800617 	ldw	r2,24(r2)
 82342a0:	e0bffd15 	stw	r2,-12(fp)
 82342a4:	e0bffd17 	ldw	r2,-12(fp)
 82342a8:	10000e26 	beq	r2,zero,82342e4 <sbappend+0x70>
   {
      while (n->m_act)
 82342ac:	00000306 	br	82342bc <sbappend+0x48>
         n = n->m_act;
 82342b0:	e0bffd17 	ldw	r2,-12(fp)
 82342b4:	10800717 	ldw	r2,28(r2)
 82342b8:	e0bffd15 	stw	r2,-12(fp)
   if (m == 0)
      return;
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 82342bc:	e0bffd17 	ldw	r2,-12(fp)
 82342c0:	10800717 	ldw	r2,28(r2)
 82342c4:	103ffa1e 	bne	r2,zero,82342b0 <sbappend+0x3c>
         n = n->m_act;
      while (n->m_next)
 82342c8:	00000306 	br	82342d8 <sbappend+0x64>
         n = n->m_next;
 82342cc:	e0bffd17 	ldw	r2,-12(fp)
 82342d0:	10800617 	ldw	r2,24(r2)
 82342d4:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
         n = n->m_act;
      while (n->m_next)
 82342d8:	e0bffd17 	ldw	r2,-12(fp)
 82342dc:	10800617 	ldw	r2,24(r2)
 82342e0:	103ffa1e 	bne	r2,zero,82342cc <sbappend+0x58>
         n = n->m_next;
   }
   sbcompress(sb, m, n);
 82342e4:	e1bffd17 	ldw	r6,-12(fp)
 82342e8:	e17fff17 	ldw	r5,-4(fp)
 82342ec:	e13ffe17 	ldw	r4,-8(fp)
 82342f0:	82345c80 	call	82345c8 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 82342f4:	822d64c0 	call	822d64c <irq_Unmask>
 82342f8:	00000106 	br	8234300 <sbappend+0x8c>
sbappend(struct sockbuf * sb, struct mbuf * m)
{
   struct mbuf *  n;

   if (m == 0)
      return;
 82342fc:	0001883a 	nop
      while (n->m_next)
         n = n->m_next;
   }
   sbcompress(sb, m, n);
   EXIT_CRIT_SECTION(sb);
}
 8234300:	e037883a 	mov	sp,fp
 8234304:	dfc00117 	ldw	ra,4(sp)
 8234308:	df000017 	ldw	fp,0(sp)
 823430c:	dec00204 	addi	sp,sp,8
 8234310:	f800283a 	ret

08234314 <sbappendrecord>:
 */

void
sbappendrecord(struct sockbuf * sb, 
   struct mbuf *  m0)
{
 8234314:	defffb04 	addi	sp,sp,-20
 8234318:	dfc00415 	stw	ra,16(sp)
 823431c:	df000315 	stw	fp,12(sp)
 8234320:	df000304 	addi	fp,sp,12
 8234324:	e13ffe15 	stw	r4,-8(fp)
 8234328:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;

   if (m0 == 0)
 823432c:	e0bfff17 	ldw	r2,-4(fp)
 8234330:	10002826 	beq	r2,zero,82343d4 <sbappendrecord+0xc0>
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
 8234334:	822d5ec0 	call	822d5ec <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 8234338:	e0bffe17 	ldw	r2,-8(fp)
 823433c:	10800617 	ldw	r2,24(r2)
 8234340:	e0bffd15 	stw	r2,-12(fp)
 8234344:	e0bffd17 	ldw	r2,-12(fp)
 8234348:	10000726 	beq	r2,zero,8234368 <sbappendrecord+0x54>
      while (m->m_act)
 823434c:	00000306 	br	823435c <sbappendrecord+0x48>
      m = m->m_act;
 8234350:	e0bffd17 	ldw	r2,-12(fp)
 8234354:	10800717 	ldw	r2,28(r2)
 8234358:	e0bffd15 	stw	r2,-12(fp)

   if (m0 == 0)
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
   if ((m = sb->sb_mb) != NULL)
      while (m->m_act)
 823435c:	e0bffd17 	ldw	r2,-12(fp)
 8234360:	10800717 	ldw	r2,28(r2)
 8234364:	103ffa1e 	bne	r2,zero,8234350 <sbappendrecord+0x3c>
      m = m->m_act;
   /*
    * Put the first mbuf on the queue.
    * Note this permits zero length records.
    */
   sballoc(sb, m0);
 8234368:	e0bffe17 	ldw	r2,-8(fp)
 823436c:	10c00017 	ldw	r3,0(r2)
 8234370:	e0bfff17 	ldw	r2,-4(fp)
 8234374:	10800217 	ldw	r2,8(r2)
 8234378:	1887883a 	add	r3,r3,r2
 823437c:	e0bffe17 	ldw	r2,-8(fp)
 8234380:	10c00015 	stw	r3,0(r2)
   if (m)
 8234384:	e0bffd17 	ldw	r2,-12(fp)
 8234388:	10000426 	beq	r2,zero,823439c <sbappendrecord+0x88>
      m->m_act = m0;
 823438c:	e0bffd17 	ldw	r2,-12(fp)
 8234390:	e0ffff17 	ldw	r3,-4(fp)
 8234394:	10c00715 	stw	r3,28(r2)
 8234398:	00000306 	br	82343a8 <sbappendrecord+0x94>
   else
      sb->sb_mb = m0;
 823439c:	e0bffe17 	ldw	r2,-8(fp)
 82343a0:	e0ffff17 	ldw	r3,-4(fp)
 82343a4:	10c00615 	stw	r3,24(r2)
   m = m0->m_next;
 82343a8:	e0bfff17 	ldw	r2,-4(fp)
 82343ac:	10800617 	ldw	r2,24(r2)
 82343b0:	e0bffd15 	stw	r2,-12(fp)
   m0->m_next = 0;
 82343b4:	e0bfff17 	ldw	r2,-4(fp)
 82343b8:	10000615 	stw	zero,24(r2)
   sbcompress(sb, m, m0);
 82343bc:	e1bfff17 	ldw	r6,-4(fp)
 82343c0:	e17ffd17 	ldw	r5,-12(fp)
 82343c4:	e13ffe17 	ldw	r4,-8(fp)
 82343c8:	82345c80 	call	82345c8 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 82343cc:	822d64c0 	call	822d64c <irq_Unmask>
 82343d0:	00000106 	br	82343d8 <sbappendrecord+0xc4>
   struct mbuf *  m0)
{
   struct mbuf *  m;

   if (m0 == 0)
      return;
 82343d4:	0001883a 	nop
      sb->sb_mb = m0;
   m = m0->m_next;
   m0->m_next = 0;
   sbcompress(sb, m, m0);
   EXIT_CRIT_SECTION(sb);
}
 82343d8:	e037883a 	mov	sp,fp
 82343dc:	dfc00117 	ldw	ra,4(sp)
 82343e0:	df000017 	ldw	fp,0(sp)
 82343e4:	dec00204 	addi	sp,sp,8
 82343e8:	f800283a 	ret

082343ec <sbappendaddr>:

int
sbappendaddr(struct sockbuf * sb, 
   struct sockaddr * asa,
   struct mbuf *  m0)
{
 82343ec:	defff804 	addi	sp,sp,-32
 82343f0:	dfc00715 	stw	ra,28(sp)
 82343f4:	df000615 	stw	fp,24(sp)
 82343f8:	df000604 	addi	fp,sp,24
 82343fc:	e13ffd15 	stw	r4,-12(fp)
 8234400:	e17ffe15 	stw	r5,-8(fp)
 8234404:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);
 8234408:	00800404 	movi	r2,16
 823440c:	e0bffc15 	stw	r2,-16(fp)

   ENTER_CRIT_SECTION(sb);
 8234410:	822d5ec0 	call	822d5ec <irq_Mask>
   for (m = m0; m; m = m->m_next)
 8234414:	e0bfff17 	ldw	r2,-4(fp)
 8234418:	e0bffa15 	stw	r2,-24(fp)
 823441c:	00000806 	br	8234440 <sbappendaddr+0x54>
      space += m->m_len;
 8234420:	e0bffa17 	ldw	r2,-24(fp)
 8234424:	10c00217 	ldw	r3,8(r2)
 8234428:	e0bffc17 	ldw	r2,-16(fp)
 823442c:	1885883a 	add	r2,r3,r2
 8234430:	e0bffc15 	stw	r2,-16(fp)
{
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);

   ENTER_CRIT_SECTION(sb);
   for (m = m0; m; m = m->m_next)
 8234434:	e0bffa17 	ldw	r2,-24(fp)
 8234438:	10800617 	ldw	r2,24(r2)
 823443c:	e0bffa15 	stw	r2,-24(fp)
 8234440:	e0bffa17 	ldw	r2,-24(fp)
 8234444:	103ff61e 	bne	r2,zero,8234420 <sbappendaddr+0x34>
      space += m->m_len;
   if (space > (int)sbspace(sb))
 8234448:	e0bffd17 	ldw	r2,-12(fp)
 823444c:	10800117 	ldw	r2,4(r2)
 8234450:	1007883a 	mov	r3,r2
 8234454:	e0bffd17 	ldw	r2,-12(fp)
 8234458:	10800017 	ldw	r2,0(r2)
 823445c:	1885c83a 	sub	r2,r3,r2
 8234460:	10000716 	blt	r2,zero,8234480 <sbappendaddr+0x94>
 8234464:	e0bffd17 	ldw	r2,-12(fp)
 8234468:	10c00117 	ldw	r3,4(r2)
 823446c:	e0bffd17 	ldw	r2,-12(fp)
 8234470:	10800017 	ldw	r2,0(r2)
 8234474:	1885c83a 	sub	r2,r3,r2
 8234478:	1007883a 	mov	r3,r2
 823447c:	00000106 	br	8234484 <sbappendaddr+0x98>
 8234480:	0007883a 	mov	r3,zero
 8234484:	e0bffc17 	ldw	r2,-16(fp)
 8234488:	1880030e 	bge	r3,r2,8234498 <sbappendaddr+0xac>
   {
      EXIT_CRIT_SECTION(sb);
 823448c:	822d64c0 	call	822d64c <irq_Unmask>
      return (0);
 8234490:	0005883a 	mov	r2,zero
 8234494:	00004706 	br	82345b4 <sbappendaddr+0x1c8>
   }
   if ((m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr))) == NULL)
 8234498:	01400404 	movi	r5,16
 823449c:	01000244 	movi	r4,9
 82344a0:	822e2280 	call	822e228 <m_getnbuf>
 82344a4:	e0bffa15 	stw	r2,-24(fp)
 82344a8:	e0bffa17 	ldw	r2,-24(fp)
 82344ac:	1000031e 	bne	r2,zero,82344bc <sbappendaddr+0xd0>
   {
      EXIT_CRIT_SECTION(sb);
 82344b0:	822d64c0 	call	822d64c <irq_Unmask>
      return 0;
 82344b4:	0005883a 	mov	r2,zero
 82344b8:	00003e06 	br	82345b4 <sbappendaddr+0x1c8>
   }
   *mtod(m, struct sockaddr *) = *asa;
 82344bc:	e0bffa17 	ldw	r2,-24(fp)
 82344c0:	10800317 	ldw	r2,12(r2)
 82344c4:	e0fffe17 	ldw	r3,-8(fp)
 82344c8:	1900000b 	ldhu	r4,0(r3)
 82344cc:	1100000d 	sth	r4,0(r2)
 82344d0:	1900008b 	ldhu	r4,2(r3)
 82344d4:	1100008d 	sth	r4,2(r2)
 82344d8:	1900010b 	ldhu	r4,4(r3)
 82344dc:	1100010d 	sth	r4,4(r2)
 82344e0:	1900018b 	ldhu	r4,6(r3)
 82344e4:	1100018d 	sth	r4,6(r2)
 82344e8:	1900020b 	ldhu	r4,8(r3)
 82344ec:	1100020d 	sth	r4,8(r2)
 82344f0:	1900028b 	ldhu	r4,10(r3)
 82344f4:	1100028d 	sth	r4,10(r2)
 82344f8:	1900030b 	ldhu	r4,12(r3)
 82344fc:	1100030d 	sth	r4,12(r2)
 8234500:	18c0038b 	ldhu	r3,14(r3)
 8234504:	10c0038d 	sth	r3,14(r2)
   m->m_len = sizeof (*asa);
 8234508:	e0bffa17 	ldw	r2,-24(fp)
 823450c:	00c00404 	movi	r3,16
 8234510:	10c00215 	stw	r3,8(r2)
   sballoc (sb, m);
 8234514:	e0bffd17 	ldw	r2,-12(fp)
 8234518:	10c00017 	ldw	r3,0(r2)
 823451c:	e0bffa17 	ldw	r2,-24(fp)
 8234520:	10800217 	ldw	r2,8(r2)
 8234524:	1887883a 	add	r3,r3,r2
 8234528:	e0bffd17 	ldw	r2,-12(fp)
 823452c:	10c00015 	stw	r3,0(r2)
   if ((n = sb->sb_mb) != NULL) 
 8234530:	e0bffd17 	ldw	r2,-12(fp)
 8234534:	10800617 	ldw	r2,24(r2)
 8234538:	e0bffb15 	stw	r2,-20(fp)
 823453c:	e0bffb17 	ldw	r2,-20(fp)
 8234540:	10000b26 	beq	r2,zero,8234570 <sbappendaddr+0x184>
   {
      while (n->m_act)
 8234544:	00000306 	br	8234554 <sbappendaddr+0x168>
         n = n->m_act;
 8234548:	e0bffb17 	ldw	r2,-20(fp)
 823454c:	10800717 	ldw	r2,28(r2)
 8234550:	e0bffb15 	stw	r2,-20(fp)
   *mtod(m, struct sockaddr *) = *asa;
   m->m_len = sizeof (*asa);
   sballoc (sb, m);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 8234554:	e0bffb17 	ldw	r2,-20(fp)
 8234558:	10800717 	ldw	r2,28(r2)
 823455c:	103ffa1e 	bne	r2,zero,8234548 <sbappendaddr+0x15c>
         n = n->m_act;
      n->m_act = m;
 8234560:	e0bffb17 	ldw	r2,-20(fp)
 8234564:	e0fffa17 	ldw	r3,-24(fp)
 8234568:	10c00715 	stw	r3,28(r2)
 823456c:	00000306 	br	823457c <sbappendaddr+0x190>
   } else
      sb->sb_mb = m;
 8234570:	e0bffd17 	ldw	r2,-12(fp)
 8234574:	e0fffa17 	ldw	r3,-24(fp)
 8234578:	10c00615 	stw	r3,24(r2)
   if (m->m_next)
 823457c:	e0bffa17 	ldw	r2,-24(fp)
 8234580:	10800617 	ldw	r2,24(r2)
 8234584:	10000326 	beq	r2,zero,8234594 <sbappendaddr+0x1a8>
      m = m->m_next;
 8234588:	e0bffa17 	ldw	r2,-24(fp)
 823458c:	10800617 	ldw	r2,24(r2)
 8234590:	e0bffa15 	stw	r2,-24(fp)
   if (m0)
 8234594:	e0bfff17 	ldw	r2,-4(fp)
 8234598:	10000426 	beq	r2,zero,82345ac <sbappendaddr+0x1c0>
      sbcompress(sb, m0, m);
 823459c:	e1bffa17 	ldw	r6,-24(fp)
 82345a0:	e17fff17 	ldw	r5,-4(fp)
 82345a4:	e13ffd17 	ldw	r4,-12(fp)
 82345a8:	82345c80 	call	82345c8 <sbcompress>

   EXIT_CRIT_SECTION(sb);
 82345ac:	822d64c0 	call	822d64c <irq_Unmask>
   return (1);
 82345b0:	00800044 	movi	r2,1
}
 82345b4:	e037883a 	mov	sp,fp
 82345b8:	dfc00117 	ldw	ra,4(sp)
 82345bc:	df000017 	ldw	fp,0(sp)
 82345c0:	dec00204 	addi	sp,sp,8
 82345c4:	f800283a 	ret

082345c8 <sbcompress>:

void
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{
 82345c8:	defffb04 	addi	sp,sp,-20
 82345cc:	dfc00415 	stw	ra,16(sp)
 82345d0:	df000315 	stw	fp,12(sp)
 82345d4:	df000304 	addi	fp,sp,12
 82345d8:	e13ffd15 	stw	r4,-12(fp)
 82345dc:	e17ffe15 	stw	r5,-8(fp)
 82345e0:	e1bfff15 	stw	r6,-4(fp)

   while (m) 
 82345e4:	00006806 	br	8234788 <sbcompress+0x1c0>
   {
      if (m->m_len == 0) 
 82345e8:	e0bffe17 	ldw	r2,-8(fp)
 82345ec:	10800217 	ldw	r2,8(r2)
 82345f0:	1000041e 	bne	r2,zero,8234604 <sbcompress+0x3c>
      {
         m = m_free(m);
 82345f4:	e13ffe17 	ldw	r4,-8(fp)
 82345f8:	822e3b00 	call	822e3b0 <m_free>
 82345fc:	e0bffe15 	stw	r2,-8(fp)
         continue;
 8234600:	00006106 	br	8234788 <sbcompress+0x1c0>
      }
      if (m->m_type != MT_RXDATA && 
 8234604:	e0bffe17 	ldw	r2,-8(fp)
 8234608:	10800817 	ldw	r2,32(r2)
 823460c:	10800060 	cmpeqi	r2,r2,1
 8234610:	1000111e 	bne	r2,zero,8234658 <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
 8234614:	e0bffe17 	ldw	r2,-8(fp)
 8234618:	10800817 	ldw	r2,32(r2)
      if (m->m_len == 0) 
      {
         m = m_free(m);
         continue;
      }
      if (m->m_type != MT_RXDATA && 
 823461c:	108000a0 	cmpeqi	r2,r2,2
 8234620:	10000d1e 	bne	r2,zero,8234658 <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
          m->m_type != MT_SONAME) 
 8234624:	e0bffe17 	ldw	r2,-8(fp)
 8234628:	10800817 	ldw	r2,32(r2)
      {
         m = m_free(m);
         continue;
      }
      if (m->m_type != MT_RXDATA && 
          m->m_type != MT_TXDATA && 
 823462c:	10800260 	cmpeqi	r2,r2,9
 8234630:	1000091e 	bne	r2,zero,8234658 <sbcompress+0x90>
          m->m_type != MT_SONAME) 
      {
         dprintf ("sbcomp:bad type %d\n", m->m_type);
 8234634:	e0bffe17 	ldw	r2,-8(fp)
 8234638:	10800817 	ldw	r2,32(r2)
 823463c:	100b883a 	mov	r5,r2
 8234640:	01020974 	movhi	r4,2085
 8234644:	21039704 	addi	r4,r4,3676
 8234648:	820331c0 	call	820331c <printf>
         panic ("sbcomp:bad");
 823464c:	01020974 	movhi	r4,2085
 8234650:	21039c04 	addi	r4,r4,3696
 8234654:	8228aec0 	call	8228aec <panic>
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 8234658:	e0bfff17 	ldw	r2,-4(fp)
 823465c:	10003326 	beq	r2,zero,823472c <sbcompress+0x164>
 8234660:	e0bffd17 	ldw	r2,-12(fp)
 8234664:	1080070b 	ldhu	r2,28(r2)
 8234668:	10bfffcc 	andi	r2,r2,65535
 823466c:	1080200c 	andi	r2,r2,128
 8234670:	10002e26 	beq	r2,zero,823472c <sbcompress+0x164>
          ((n->m_len + m->m_len) <
 8234674:	e0bfff17 	ldw	r2,-4(fp)
 8234678:	10c00217 	ldw	r3,8(r2)
 823467c:	e0bffe17 	ldw	r2,-8(fp)
 8234680:	10800217 	ldw	r2,8(r2)
 8234684:	1887883a 	add	r3,r3,r2
          n->m_memsz - (n->m_data - n->m_base) ) ) 
 8234688:	e0bfff17 	ldw	r2,-4(fp)
 823468c:	10800517 	ldw	r2,20(r2)
 8234690:	e13fff17 	ldw	r4,-4(fp)
 8234694:	21000317 	ldw	r4,12(r4)
 8234698:	200b883a 	mov	r5,r4
 823469c:	e13fff17 	ldw	r4,-4(fp)
 82346a0:	21000417 	ldw	r4,16(r4)
 82346a4:	2909c83a 	sub	r4,r5,r4
 82346a8:	1105c83a 	sub	r2,r2,r4
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 82346ac:	18801f2e 	bgeu	r3,r2,823472c <sbcompress+0x164>
          ((n->m_len + m->m_len) <
          n->m_memsz - (n->m_data - n->m_base) ) ) 
      {
         MEMCPY(n->m_data+n->m_len, m->m_data, m->m_len);
 82346b0:	e0bfff17 	ldw	r2,-4(fp)
 82346b4:	10c00317 	ldw	r3,12(r2)
 82346b8:	e0bfff17 	ldw	r2,-4(fp)
 82346bc:	10800217 	ldw	r2,8(r2)
 82346c0:	1887883a 	add	r3,r3,r2
 82346c4:	e0bffe17 	ldw	r2,-8(fp)
 82346c8:	11000317 	ldw	r4,12(r2)
 82346cc:	e0bffe17 	ldw	r2,-8(fp)
 82346d0:	10800217 	ldw	r2,8(r2)
 82346d4:	100d883a 	mov	r6,r2
 82346d8:	200b883a 	mov	r5,r4
 82346dc:	1809883a 	mov	r4,r3
 82346e0:	8202e8c0 	call	8202e8c <memcpy>
         sballoc(sb, m);
 82346e4:	e0bffd17 	ldw	r2,-12(fp)
 82346e8:	10c00017 	ldw	r3,0(r2)
 82346ec:	e0bffe17 	ldw	r2,-8(fp)
 82346f0:	10800217 	ldw	r2,8(r2)
 82346f4:	1887883a 	add	r3,r3,r2
 82346f8:	e0bffd17 	ldw	r2,-12(fp)
 82346fc:	10c00015 	stw	r3,0(r2)
         n->m_len += m->m_len;
 8234700:	e0bfff17 	ldw	r2,-4(fp)
 8234704:	10c00217 	ldw	r3,8(r2)
 8234708:	e0bffe17 	ldw	r2,-8(fp)
 823470c:	10800217 	ldw	r2,8(r2)
 8234710:	1887883a 	add	r3,r3,r2
 8234714:	e0bfff17 	ldw	r2,-4(fp)
 8234718:	10c00215 	stw	r3,8(r2)
         m = m_free(m);
 823471c:	e13ffe17 	ldw	r4,-8(fp)
 8234720:	822e3b00 	call	822e3b0 <m_free>
 8234724:	e0bffe15 	stw	r2,-8(fp)
         continue;
 8234728:	00001706 	br	8234788 <sbcompress+0x1c0>
      }
      sballoc(sb, m);
 823472c:	e0bffd17 	ldw	r2,-12(fp)
 8234730:	10c00017 	ldw	r3,0(r2)
 8234734:	e0bffe17 	ldw	r2,-8(fp)
 8234738:	10800217 	ldw	r2,8(r2)
 823473c:	1887883a 	add	r3,r3,r2
 8234740:	e0bffd17 	ldw	r2,-12(fp)
 8234744:	10c00015 	stw	r3,0(r2)
      if (n)
 8234748:	e0bfff17 	ldw	r2,-4(fp)
 823474c:	10000426 	beq	r2,zero,8234760 <sbcompress+0x198>
         n->m_next = m;
 8234750:	e0bfff17 	ldw	r2,-4(fp)
 8234754:	e0fffe17 	ldw	r3,-8(fp)
 8234758:	10c00615 	stw	r3,24(r2)
 823475c:	00000306 	br	823476c <sbcompress+0x1a4>
      else
         sb->sb_mb = m;
 8234760:	e0bffd17 	ldw	r2,-12(fp)
 8234764:	e0fffe17 	ldw	r3,-8(fp)
 8234768:	10c00615 	stw	r3,24(r2)
      n = m;
 823476c:	e0bffe17 	ldw	r2,-8(fp)
 8234770:	e0bfff15 	stw	r2,-4(fp)
      m = m->m_next;
 8234774:	e0bffe17 	ldw	r2,-8(fp)
 8234778:	10800617 	ldw	r2,24(r2)
 823477c:	e0bffe15 	stw	r2,-8(fp)
      n->m_next = 0;
 8234780:	e0bfff17 	ldw	r2,-4(fp)
 8234784:	10000615 	stw	zero,24(r2)
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{

   while (m) 
 8234788:	e0bffe17 	ldw	r2,-8(fp)
 823478c:	103f961e 	bne	r2,zero,82345e8 <sbcompress+0x20>
         sb->sb_mb = m;
      n = m;
      m = m->m_next;
      n->m_next = 0;
   }
}
 8234790:	0001883a 	nop
 8234794:	e037883a 	mov	sp,fp
 8234798:	dfc00117 	ldw	ra,4(sp)
 823479c:	df000017 	ldw	fp,0(sp)
 82347a0:	dec00204 	addi	sp,sp,8
 82347a4:	f800283a 	ret

082347a8 <sbflush>:
 * RETURNS: 
 */

void
sbflush(struct sockbuf * sb)
{
 82347a8:	defffd04 	addi	sp,sp,-12
 82347ac:	dfc00215 	stw	ra,8(sp)
 82347b0:	df000115 	stw	fp,4(sp)
 82347b4:	df000104 	addi	fp,sp,4
 82347b8:	e13fff15 	stw	r4,-4(fp)
   ENTER_CRIT_SECTION(sb);
 82347bc:	822d5ec0 	call	822d5ec <irq_Mask>
   if (sb->sb_flags & SB_LOCK)
 82347c0:	e0bfff17 	ldw	r2,-4(fp)
 82347c4:	1080070b 	ldhu	r2,28(r2)
 82347c8:	10bfffcc 	andi	r2,r2,65535
 82347cc:	1080004c 	andi	r2,r2,1
 82347d0:	10000926 	beq	r2,zero,82347f8 <sbflush+0x50>
      panic("sbflush");
 82347d4:	01020974 	movhi	r4,2085
 82347d8:	21039f04 	addi	r4,r4,3708
 82347dc:	8228aec0 	call	8228aec <panic>
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 82347e0:	00000506 	br	82347f8 <sbflush+0x50>
      sbdrop (sb, (int)sb->sb_cc);
 82347e4:	e0bfff17 	ldw	r2,-4(fp)
 82347e8:	10800017 	ldw	r2,0(r2)
 82347ec:	100b883a 	mov	r5,r2
 82347f0:	e13fff17 	ldw	r4,-4(fp)
 82347f4:	823482c0 	call	823482c <sbdrop>
sbflush(struct sockbuf * sb)
{
   ENTER_CRIT_SECTION(sb);
   if (sb->sb_flags & SB_LOCK)
      panic("sbflush");
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 82347f8:	e0bfff17 	ldw	r2,-4(fp)
 82347fc:	10800217 	ldw	r2,8(r2)
 8234800:	103ff81e 	bne	r2,zero,82347e4 <sbflush+0x3c>
 8234804:	e0bfff17 	ldw	r2,-4(fp)
 8234808:	10800017 	ldw	r2,0(r2)
 823480c:	103ff51e 	bne	r2,zero,82347e4 <sbflush+0x3c>
      sbdrop (sb, (int)sb->sb_cc);
   EXIT_CRIT_SECTION(sb);
 8234810:	822d64c0 	call	822d64c <irq_Unmask>
}
 8234814:	0001883a 	nop
 8234818:	e037883a 	mov	sp,fp
 823481c:	dfc00117 	ldw	ra,4(sp)
 8234820:	df000017 	ldw	fp,0(sp)
 8234824:	dec00204 	addi	sp,sp,8
 8234828:	f800283a 	ret

0823482c <sbdrop>:
 * RETURNS: 
 */

void
sbdrop(struct sockbuf * sb, int len)
{
 823482c:	defff904 	addi	sp,sp,-28
 8234830:	dfc00615 	stw	ra,24(sp)
 8234834:	df000515 	stw	fp,20(sp)
 8234838:	df000504 	addi	fp,sp,20
 823483c:	e13ffe15 	stw	r4,-8(fp)
 8234840:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m, *  mn;
   struct mbuf *  next;

   ENTER_CRIT_SECTION(sb);
 8234844:	822d5ec0 	call	822d5ec <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 8234848:	e0bffe17 	ldw	r2,-8(fp)
 823484c:	10800617 	ldw	r2,24(r2)
 8234850:	e0bffb15 	stw	r2,-20(fp)
 8234854:	e0bffb17 	ldw	r2,-20(fp)
 8234858:	10000426 	beq	r2,zero,823486c <sbdrop+0x40>
      next = m->m_act;
 823485c:	e0bffb17 	ldw	r2,-20(fp)
 8234860:	10800717 	ldw	r2,28(r2)
 8234864:	e0bffc15 	stw	r2,-16(fp)
 8234868:	00003706 	br	8234948 <sbdrop+0x11c>
   else
      next = NULL;
 823486c:	e03ffc15 	stw	zero,-16(fp)
   while (len > 0) 
 8234870:	00003506 	br	8234948 <sbdrop+0x11c>
   {
      if (m == 0) 
 8234874:	e0bffb17 	ldw	r2,-20(fp)
 8234878:	10000b1e 	bne	r2,zero,82348a8 <sbdrop+0x7c>
      {
         if (next == 0)
 823487c:	e0bffc17 	ldw	r2,-16(fp)
 8234880:	1000031e 	bne	r2,zero,8234890 <sbdrop+0x64>
            panic("sbdrop");
 8234884:	01020974 	movhi	r4,2085
 8234888:	2103a104 	addi	r4,r4,3716
 823488c:	8228aec0 	call	8228aec <panic>
         m = next;
 8234890:	e0bffc17 	ldw	r2,-16(fp)
 8234894:	e0bffb15 	stw	r2,-20(fp)
         next = m->m_act;
 8234898:	e0bffb17 	ldw	r2,-20(fp)
 823489c:	10800717 	ldw	r2,28(r2)
 82348a0:	e0bffc15 	stw	r2,-16(fp)
         continue;
 82348a4:	00002806 	br	8234948 <sbdrop+0x11c>
      }
      if (m->m_len > (unsigned)len) 
 82348a8:	e0bffb17 	ldw	r2,-20(fp)
 82348ac:	10800217 	ldw	r2,8(r2)
 82348b0:	e0ffff17 	ldw	r3,-4(fp)
 82348b4:	1880132e 	bgeu	r3,r2,8234904 <sbdrop+0xd8>
      {
         m->m_len -= len;
 82348b8:	e0bffb17 	ldw	r2,-20(fp)
 82348bc:	10c00217 	ldw	r3,8(r2)
 82348c0:	e0bfff17 	ldw	r2,-4(fp)
 82348c4:	1887c83a 	sub	r3,r3,r2
 82348c8:	e0bffb17 	ldw	r2,-20(fp)
 82348cc:	10c00215 	stw	r3,8(r2)
         m->m_data += len;
 82348d0:	e0bffb17 	ldw	r2,-20(fp)
 82348d4:	10c00317 	ldw	r3,12(r2)
 82348d8:	e0bfff17 	ldw	r2,-4(fp)
 82348dc:	1887883a 	add	r3,r3,r2
 82348e0:	e0bffb17 	ldw	r2,-20(fp)
 82348e4:	10c00315 	stw	r3,12(r2)
         sb->sb_cc -= len;
 82348e8:	e0bffe17 	ldw	r2,-8(fp)
 82348ec:	10c00017 	ldw	r3,0(r2)
 82348f0:	e0bfff17 	ldw	r2,-4(fp)
 82348f4:	1887c83a 	sub	r3,r3,r2
 82348f8:	e0bffe17 	ldw	r2,-8(fp)
 82348fc:	10c00015 	stw	r3,0(r2)
         break;
 8234900:	00001306 	br	8234950 <sbdrop+0x124>
      }
      len -= m->m_len;
 8234904:	e0ffff17 	ldw	r3,-4(fp)
 8234908:	e0bffb17 	ldw	r2,-20(fp)
 823490c:	10800217 	ldw	r2,8(r2)
 8234910:	1885c83a 	sub	r2,r3,r2
 8234914:	e0bfff15 	stw	r2,-4(fp)
      sbfree (sb, m);
 8234918:	e0bffe17 	ldw	r2,-8(fp)
 823491c:	10c00017 	ldw	r3,0(r2)
 8234920:	e0bffb17 	ldw	r2,-20(fp)
 8234924:	10800217 	ldw	r2,8(r2)
 8234928:	1887c83a 	sub	r3,r3,r2
 823492c:	e0bffe17 	ldw	r2,-8(fp)
 8234930:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 8234934:	e13ffb17 	ldw	r4,-20(fp)
 8234938:	822e3b00 	call	822e3b0 <m_free>
 823493c:	e0bffd15 	stw	r2,-12(fp)
      m = mn;
 8234940:	e0bffd17 	ldw	r2,-12(fp)
 8234944:	e0bffb15 	stw	r2,-20(fp)
   ENTER_CRIT_SECTION(sb);
   if ((m = sb->sb_mb) != NULL)
      next = m->m_act;
   else
      next = NULL;
   while (len > 0) 
 8234948:	e0bfff17 	ldw	r2,-4(fp)
 823494c:	00bfc916 	blt	zero,r2,8234874 <sbdrop+0x48>
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 8234950:	00000c06 	br	8234984 <sbdrop+0x158>
   {
      sbfree(sb, m);
 8234954:	e0bffe17 	ldw	r2,-8(fp)
 8234958:	10c00017 	ldw	r3,0(r2)
 823495c:	e0bffb17 	ldw	r2,-20(fp)
 8234960:	10800217 	ldw	r2,8(r2)
 8234964:	1887c83a 	sub	r3,r3,r2
 8234968:	e0bffe17 	ldw	r2,-8(fp)
 823496c:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 8234970:	e13ffb17 	ldw	r4,-20(fp)
 8234974:	822e3b00 	call	822e3b0 <m_free>
 8234978:	e0bffd15 	stw	r2,-12(fp)
      m = mn;
 823497c:	e0bffd17 	ldw	r2,-12(fp)
 8234980:	e0bffb15 	stw	r2,-20(fp)
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 8234984:	e0bffb17 	ldw	r2,-20(fp)
 8234988:	10000326 	beq	r2,zero,8234998 <sbdrop+0x16c>
 823498c:	e0bffb17 	ldw	r2,-20(fp)
 8234990:	10800217 	ldw	r2,8(r2)
 8234994:	103fef26 	beq	r2,zero,8234954 <sbdrop+0x128>
   {
      sbfree(sb, m);
      MFREE(m, mn);
      m = mn;
   }
   if (m) 
 8234998:	e0bffb17 	ldw	r2,-20(fp)
 823499c:	10000726 	beq	r2,zero,82349bc <sbdrop+0x190>
   {
      sb->sb_mb = m;
 82349a0:	e0bffe17 	ldw	r2,-8(fp)
 82349a4:	e0fffb17 	ldw	r3,-20(fp)
 82349a8:	10c00615 	stw	r3,24(r2)
      m->m_act = next;
 82349ac:	e0bffb17 	ldw	r2,-20(fp)
 82349b0:	e0fffc17 	ldw	r3,-16(fp)
 82349b4:	10c00715 	stw	r3,28(r2)
 82349b8:	00000306 	br	82349c8 <sbdrop+0x19c>
   } else
      sb->sb_mb = next;
 82349bc:	e0bffe17 	ldw	r2,-8(fp)
 82349c0:	e0fffc17 	ldw	r3,-16(fp)
 82349c4:	10c00615 	stw	r3,24(r2)
   EXIT_CRIT_SECTION(sb);
 82349c8:	822d64c0 	call	822d64c <irq_Unmask>
}
 82349cc:	0001883a 	nop
 82349d0:	e037883a 	mov	sp,fp
 82349d4:	dfc00117 	ldw	ra,4(sp)
 82349d8:	df000017 	ldw	fp,0(sp)
 82349dc:	dec00204 	addi	sp,sp,8
 82349e0:	f800283a 	ret

082349e4 <sbdropend>:
 * RETURNS: 
 */

void
sbdropend(struct sockbuf * sb, struct mbuf * m)
{
 82349e4:	defff904 	addi	sp,sp,-28
 82349e8:	dfc00615 	stw	ra,24(sp)
 82349ec:	df000515 	stw	fp,20(sp)
 82349f0:	df000504 	addi	fp,sp,20
 82349f4:	e13ffe15 	stw	r4,-8(fp)
 82349f8:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  nmb, *   pmb;
   int   len;
   ENTER_CRIT_SECTION(sb);
 82349fc:	822d5ec0 	call	822d5ec <irq_Mask>
   len = mbuf_len(m);
 8234a00:	e13fff17 	ldw	r4,-4(fp)
 8234a04:	822e9b00 	call	822e9b0 <mbuf_len>
 8234a08:	e0bffd15 	stw	r2,-12(fp)
   if (len > 0)
 8234a0c:	e0bffd17 	ldw	r2,-12(fp)
 8234a10:	0080070e 	bge	zero,r2,8234a30 <sbdropend+0x4c>
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
 8234a14:	e0bffe17 	ldw	r2,-8(fp)
 8234a18:	10c00617 	ldw	r3,24(r2)
 8234a1c:	e0bffd17 	ldw	r2,-12(fp)
 8234a20:	0085c83a 	sub	r2,zero,r2
 8234a24:	100b883a 	mov	r5,r2
 8234a28:	1809883a 	mov	r4,r3
 8234a2c:	822e7f00 	call	822e7f0 <m_adj>
   nmb = sb->sb_mb;
 8234a30:	e0bffe17 	ldw	r2,-8(fp)
 8234a34:	10800617 	ldw	r2,24(r2)
 8234a38:	e0bffb15 	stw	r2,-20(fp)
   pmb = NULL;
 8234a3c:	e03ffc15 	stw	zero,-16(fp)
   if (sb->sb_mb->m_len == 0)
 8234a40:	e0bffe17 	ldw	r2,-8(fp)
 8234a44:	10800617 	ldw	r2,24(r2)
 8234a48:	10800217 	ldw	r2,8(r2)
 8234a4c:	1000081e 	bne	r2,zero,8234a70 <sbdropend+0x8c>
      sb->sb_mb = NULL;
 8234a50:	e0bffe17 	ldw	r2,-8(fp)
 8234a54:	10000615 	stw	zero,24(r2)
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 8234a58:	00000506 	br	8234a70 <sbdropend+0x8c>
   {
      pmb = nmb;  /* Remember previous */
 8234a5c:	e0bffb17 	ldw	r2,-20(fp)
 8234a60:	e0bffc15 	stw	r2,-16(fp)
      nmb = nmb->m_next;    
 8234a64:	e0bffb17 	ldw	r2,-20(fp)
 8234a68:	10800617 	ldw	r2,24(r2)
 8234a6c:	e0bffb15 	stw	r2,-20(fp)
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
   nmb = sb->sb_mb;
   pmb = NULL;
   if (sb->sb_mb->m_len == 0)
      sb->sb_mb = NULL;
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 8234a70:	e0bffb17 	ldw	r2,-20(fp)
 8234a74:	10000326 	beq	r2,zero,8234a84 <sbdropend+0xa0>
 8234a78:	e0bffb17 	ldw	r2,-20(fp)
 8234a7c:	10800217 	ldw	r2,8(r2)
 8234a80:	103ff61e 	bne	r2,zero,8234a5c <sbdropend+0x78>
   {
      pmb = nmb;  /* Remember previous */
      nmb = nmb->m_next;    
   }
   if (nmb && (nmb->m_len == 0)) /* Assume once 0 len found, all the rest */
 8234a84:	e0bffb17 	ldw	r2,-20(fp)
 8234a88:	10000926 	beq	r2,zero,8234ab0 <sbdropend+0xcc>
 8234a8c:	e0bffb17 	ldw	r2,-20(fp)
 8234a90:	10800217 	ldw	r2,8(r2)
 8234a94:	1000061e 	bne	r2,zero,8234ab0 <sbdropend+0xcc>
   {                             /* are zeroes */ 
      if (pmb != NULL)
 8234a98:	e0bffc17 	ldw	r2,-16(fp)
 8234a9c:	10000226 	beq	r2,zero,8234aa8 <sbdropend+0xc4>
         pmb->m_next = NULL;
 8234aa0:	e0bffc17 	ldw	r2,-16(fp)
 8234aa4:	10000615 	stw	zero,24(r2)
      m_freem(nmb);            
 8234aa8:	e13ffb17 	ldw	r4,-20(fp)
 8234aac:	822e4b80 	call	822e4b8 <m_freem>
   }
   sb->sb_cc -= len;       /* Do a sbfree using the len */
 8234ab0:	e0bffe17 	ldw	r2,-8(fp)
 8234ab4:	10c00017 	ldw	r3,0(r2)
 8234ab8:	e0bffd17 	ldw	r2,-12(fp)
 8234abc:	1887c83a 	sub	r3,r3,r2
 8234ac0:	e0bffe17 	ldw	r2,-8(fp)
 8234ac4:	10c00015 	stw	r3,0(r2)
   EXIT_CRIT_SECTION(sb);
 8234ac8:	822d64c0 	call	822d64c <irq_Unmask>
}
 8234acc:	0001883a 	nop
 8234ad0:	e037883a 	mov	sp,fp
 8234ad4:	dfc00117 	ldw	ra,4(sp)
 8234ad8:	df000017 	ldw	fp,0(sp)
 8234adc:	dec00204 	addi	sp,sp,8
 8234ae0:	f800283a 	ret

08234ae4 <sbdroprecord>:
 * RETURNS: 
 */

void
sbdroprecord(struct sockbuf * sb)
{
 8234ae4:	defffb04 	addi	sp,sp,-20
 8234ae8:	dfc00415 	stw	ra,16(sp)
 8234aec:	df000315 	stw	fp,12(sp)
 8234af0:	df000304 	addi	fp,sp,12
 8234af4:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  m, *  mn;

   ENTER_CRIT_SECTION(sb);
 8234af8:	822d5ec0 	call	822d5ec <irq_Mask>
   m = sb->sb_mb;
 8234afc:	e0bfff17 	ldw	r2,-4(fp)
 8234b00:	10800617 	ldw	r2,24(r2)
 8234b04:	e0bffd15 	stw	r2,-12(fp)
   if (m)
 8234b08:	e0bffd17 	ldw	r2,-12(fp)
 8234b0c:	10001226 	beq	r2,zero,8234b58 <sbdroprecord+0x74>
   {  sb->sb_mb = m->m_act;
 8234b10:	e0bffd17 	ldw	r2,-12(fp)
 8234b14:	10c00717 	ldw	r3,28(r2)
 8234b18:	e0bfff17 	ldw	r2,-4(fp)
 8234b1c:	10c00615 	stw	r3,24(r2)
      do 
      {  sbfree(sb, m);
 8234b20:	e0bfff17 	ldw	r2,-4(fp)
 8234b24:	10c00017 	ldw	r3,0(r2)
 8234b28:	e0bffd17 	ldw	r2,-12(fp)
 8234b2c:	10800217 	ldw	r2,8(r2)
 8234b30:	1887c83a 	sub	r3,r3,r2
 8234b34:	e0bfff17 	ldw	r2,-4(fp)
 8234b38:	10c00015 	stw	r3,0(r2)
         MFREE(m, mn);
 8234b3c:	e13ffd17 	ldw	r4,-12(fp)
 8234b40:	822e3b00 	call	822e3b0 <m_free>
 8234b44:	e0bffe15 	stw	r2,-8(fp)
      } while ((m = mn) != NULL);
 8234b48:	e0bffe17 	ldw	r2,-8(fp)
 8234b4c:	e0bffd15 	stw	r2,-12(fp)
 8234b50:	e0bffd17 	ldw	r2,-12(fp)
 8234b54:	103ff21e 	bne	r2,zero,8234b20 <sbdroprecord+0x3c>
         }
   EXIT_CRIT_SECTION(sb);
 8234b58:	822d64c0 	call	822d64c <irq_Unmask>
}
 8234b5c:	0001883a 	nop
 8234b60:	e037883a 	mov	sp,fp
 8234b64:	dfc00117 	ldw	ra,4(sp)
 8234b68:	df000017 	ldw	fp,0(sp)
 8234b6c:	dec00204 	addi	sp,sp,8
 8234b70:	f800283a 	ret

08234b74 <t_select>:
int
t_select(fd_set * in,   /* lists of sockets to watch */
   fd_set * out,
   fd_set * ex,
   long  tv)   /* ticks to wait */
{
 8234b74:	defe7204 	addi	sp,sp,-1592
 8234b78:	dfc18d15 	stw	ra,1588(sp)
 8234b7c:	df018c15 	stw	fp,1584(sp)
 8234b80:	df018c04 	addi	fp,sp,1584
 8234b84:	e13ffc15 	stw	r4,-16(fp)
 8234b88:	e17ffd15 	stw	r5,-12(fp)
 8234b8c:	e1bffe15 	stw	r6,-8(fp)
 8234b90:	e1ffff15 	stw	r7,-4(fp)
   fd_set obits[3], ibits [3];
   u_long   tmo;
   int   retval   =  0;
 8234b94:	e03e7415 	stw	zero,-1584(fp)

   MEMSET(&obits, 0, sizeof(obits));
 8234b98:	e0be7604 	addi	r2,fp,-1576
 8234b9c:	0180c304 	movi	r6,780
 8234ba0:	000b883a 	mov	r5,zero
 8234ba4:	1009883a 	mov	r4,r2
 8234ba8:	82031300 	call	8203130 <memset>
   MEMSET(&ibits, 0, sizeof(ibits));
 8234bac:	e0bf3904 	addi	r2,fp,-796
 8234bb0:	0180c304 	movi	r6,780
 8234bb4:	000b883a 	mov	r5,zero
 8234bb8:	1009883a 	mov	r4,r2
 8234bbc:	82031300 	call	8203130 <memset>

   if (in)
 8234bc0:	e0bffc17 	ldw	r2,-16(fp)
 8234bc4:	10000526 	beq	r2,zero,8234bdc <t_select+0x68>
      MEMCPY(&ibits[0], in, sizeof(fd_set));
 8234bc8:	e0bf3904 	addi	r2,fp,-796
 8234bcc:	01804104 	movi	r6,260
 8234bd0:	e17ffc17 	ldw	r5,-16(fp)
 8234bd4:	1009883a 	mov	r4,r2
 8234bd8:	8202e8c0 	call	8202e8c <memcpy>
   if (out)
 8234bdc:	e0bffd17 	ldw	r2,-12(fp)
 8234be0:	10000626 	beq	r2,zero,8234bfc <t_select+0x88>
      MEMCPY(&ibits[1], out, sizeof(fd_set));
 8234be4:	e0bf3904 	addi	r2,fp,-796
 8234be8:	10804104 	addi	r2,r2,260
 8234bec:	01804104 	movi	r6,260
 8234bf0:	e17ffd17 	ldw	r5,-12(fp)
 8234bf4:	1009883a 	mov	r4,r2
 8234bf8:	8202e8c0 	call	8202e8c <memcpy>
   if (ex)
 8234bfc:	e0bffe17 	ldw	r2,-8(fp)
 8234c00:	10000626 	beq	r2,zero,8234c1c <t_select+0xa8>
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
 8234c04:	e0bf3904 	addi	r2,fp,-796
 8234c08:	10808204 	addi	r2,r2,520
 8234c0c:	01804104 	movi	r6,260
 8234c10:	e17ffe17 	ldw	r5,-8(fp)
 8234c14:	1009883a 	mov	r4,r2
 8234c18:	8202e8c0 	call	8202e8c <memcpy>
   tmo = cticks + tv;
 8234c1c:	d0e0a817 	ldw	r3,-32096(gp)
 8234c20:	e0bfff17 	ldw	r2,-4(fp)
 8234c24:	1885883a 	add	r2,r3,r2
 8234c28:	e0be7515 	stw	r2,-1580(fp)

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 8234c2c:	e0bf3917 	ldw	r2,-796(fp)
 8234c30:	10000c1e 	bne	r2,zero,8234c64 <t_select+0xf0>
 8234c34:	e0bf7a17 	ldw	r2,-536(fp)
 8234c38:	10000a1e 	bne	r2,zero,8234c64 <t_select+0xf0>
       (ibits[2].fd_count == 0))
 8234c3c:	e0bfbb17 	ldw	r2,-276(fp)
   if (ex)
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
   tmo = cticks + tv;

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 8234c40:	1000081e 	bne	r2,zero,8234c64 <t_select+0xf0>
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 8234c44:	e0bfff17 	ldw	r2,-4(fp)
 8234c48:	00801f0e 	bge	zero,r2,8234cc8 <t_select+0x154>
         while (tmo > cticks)
         {
            tk_yield();
         }
#else
         TK_SLEEP(tv);
 8234c4c:	e0bfff17 	ldw	r2,-4(fp)
 8234c50:	10800044 	addi	r2,r2,1
 8234c54:	10bfffcc 	andi	r2,r2,65535
 8234c58:	1009883a 	mov	r4,r2
 8234c5c:	821be3c0 	call	821be3c <OSTimeDly>

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 8234c60:	00001906 	br	8234cc8 <t_select+0x154>

      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
 8234c64:	0009883a 	mov	r4,zero
 8234c68:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      while ((retval = sock_selscan(ibits, obits)) == 0)
 8234c6c:	00000a06 	br	8234c98 <t_select+0x124>
      {
         if (tv != -1L) 
 8234c70:	e0bfff17 	ldw	r2,-4(fp)
 8234c74:	10bfffe0 	cmpeqi	r2,r2,-1
 8234c78:	1000031e 	bne	r2,zero,8234c88 <t_select+0x114>
         {
            if (tmo <= cticks)
 8234c7c:	d0e0a817 	ldw	r3,-32096(gp)
 8234c80:	e0be7517 	ldw	r2,-1580(fp)
 8234c84:	18800d2e 	bgeu	r3,r2,8234cbc <t_select+0x148>
               break;
         }
         select_wait = 1;
 8234c88:	00800044 	movi	r2,1
 8234c8c:	d0a0b00d 	sth	r2,-32064(gp)
         tcp_sleep (&select_wait);
 8234c90:	d120b004 	addi	r4,gp,-32064
 8234c94:	82293d80 	call	82293d8 <tcp_sleep>
      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
      while ((retval = sock_selscan(ibits, obits)) == 0)
 8234c98:	e0fe7604 	addi	r3,fp,-1576
 8234c9c:	e0bf3904 	addi	r2,fp,-796
 8234ca0:	180b883a 	mov	r5,r3
 8234ca4:	1009883a 	mov	r4,r2
 8234ca8:	8234d440 	call	8234d44 <sock_selscan>
 8234cac:	e0be7415 	stw	r2,-1584(fp)
 8234cb0:	e0be7417 	ldw	r2,-1584(fp)
 8234cb4:	103fee26 	beq	r2,zero,8234c70 <t_select+0xfc>
 8234cb8:	00000106 	br	8234cc0 <t_select+0x14c>
      {
         if (tv != -1L) 
         {
            if (tmo <= cticks)
               break;
 8234cbc:	0001883a 	nop
         }
         select_wait = 1;
         tcp_sleep (&select_wait);
      }
      UNLOCK_NET_RESOURCE(NET_RESID);
 8234cc0:	0009883a 	mov	r4,zero
 8234cc4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   }

   if (retval >= 0)
 8234cc8:	e0be7417 	ldw	r2,-1584(fp)
 8234ccc:	10001716 	blt	r2,zero,8234d2c <t_select+0x1b8>
   {
      if (in)
 8234cd0:	e0bffc17 	ldw	r2,-16(fp)
 8234cd4:	10000526 	beq	r2,zero,8234cec <t_select+0x178>
         MEMCPY(in, &obits[0], sizeof(fd_set));
 8234cd8:	e0be7604 	addi	r2,fp,-1576
 8234cdc:	01804104 	movi	r6,260
 8234ce0:	100b883a 	mov	r5,r2
 8234ce4:	e13ffc17 	ldw	r4,-16(fp)
 8234ce8:	8202e8c0 	call	8202e8c <memcpy>
      if (out)
 8234cec:	e0bffd17 	ldw	r2,-12(fp)
 8234cf0:	10000626 	beq	r2,zero,8234d0c <t_select+0x198>
         MEMCPY(out, &obits[1], sizeof(fd_set));
 8234cf4:	e0be7604 	addi	r2,fp,-1576
 8234cf8:	10804104 	addi	r2,r2,260
 8234cfc:	01804104 	movi	r6,260
 8234d00:	100b883a 	mov	r5,r2
 8234d04:	e13ffd17 	ldw	r4,-12(fp)
 8234d08:	8202e8c0 	call	8202e8c <memcpy>
      if (ex)
 8234d0c:	e0bffe17 	ldw	r2,-8(fp)
 8234d10:	10000626 	beq	r2,zero,8234d2c <t_select+0x1b8>
         MEMCPY(ex, &obits[2], sizeof(fd_set));
 8234d14:	e0be7604 	addi	r2,fp,-1576
 8234d18:	10808204 	addi	r2,r2,520
 8234d1c:	01804104 	movi	r6,260
 8234d20:	100b883a 	mov	r5,r2
 8234d24:	e13ffe17 	ldw	r4,-8(fp)
 8234d28:	8202e8c0 	call	8202e8c <memcpy>
   }
   return retval;
 8234d2c:	e0be7417 	ldw	r2,-1584(fp)
}
 8234d30:	e037883a 	mov	sp,fp
 8234d34:	dfc00117 	ldw	ra,4(sp)
 8234d38:	df000017 	ldw	fp,0(sp)
 8234d3c:	dec00204 	addi	sp,sp,8
 8234d40:	f800283a 	ret

08234d44 <sock_selscan>:
 * RETURNS: 
 */

int
sock_selscan(fd_set * ibits, fd_set * obits)
{
 8234d44:	defff604 	addi	sp,sp,-40
 8234d48:	dfc00915 	stw	ra,36(sp)
 8234d4c:	df000815 	stw	fp,32(sp)
 8234d50:	df000804 	addi	fp,sp,32
 8234d54:	e13ffe15 	stw	r4,-8(fp)
 8234d58:	e17fff15 	stw	r5,-4(fp)
   fd_set *in, *out;
   int   which;
   int   sock;
   int   flag  =  0;
 8234d5c:	e03ffa15 	stw	zero,-24(fp)
   int   num_sel  =  0;
 8234d60:	e03ffb15 	stw	zero,-20(fp)

   for (which = 0; which < 3; which++)
 8234d64:	e03ff815 	stw	zero,-32(fp)
 8234d68:	00003d06 	br	8234e60 <sock_selscan+0x11c>
   {
      switch (which)
 8234d6c:	e0bff817 	ldw	r2,-32(fp)
 8234d70:	10c00060 	cmpeqi	r3,r2,1
 8234d74:	1800061e 	bne	r3,zero,8234d90 <sock_selscan+0x4c>
 8234d78:	10c000a0 	cmpeqi	r3,r2,2
 8234d7c:	1800071e 	bne	r3,zero,8234d9c <sock_selscan+0x58>
 8234d80:	1000081e 	bne	r2,zero,8234da4 <sock_selscan+0x60>
      {
      case 0:
         flag = SOREAD; break;
 8234d84:	00800044 	movi	r2,1
 8234d88:	e0bffa15 	stw	r2,-24(fp)
 8234d8c:	00000506 	br	8234da4 <sock_selscan+0x60>

      case 1:
         flag = SOWRITE; break;
 8234d90:	00800084 	movi	r2,2
 8234d94:	e0bffa15 	stw	r2,-24(fp)
 8234d98:	00000206 	br	8234da4 <sock_selscan+0x60>

      case 2:
         flag = 0; break;
 8234d9c:	e03ffa15 	stw	zero,-24(fp)
 8234da0:	0001883a 	nop
      }
      in = &ibits [which];
 8234da4:	e0bff817 	ldw	r2,-32(fp)
 8234da8:	10804124 	muli	r2,r2,260
 8234dac:	e0fffe17 	ldw	r3,-8(fp)
 8234db0:	1885883a 	add	r2,r3,r2
 8234db4:	e0bffc15 	stw	r2,-16(fp)
      out = &obits [which];
 8234db8:	e0bff817 	ldw	r2,-32(fp)
 8234dbc:	10804124 	muli	r2,r2,260
 8234dc0:	e0ffff17 	ldw	r3,-4(fp)
 8234dc4:	1885883a 	add	r2,r3,r2
 8234dc8:	e0bffd15 	stw	r2,-12(fp)
      for (sock = 0; sock < (int)in->fd_count; sock++)
 8234dcc:	e03ff915 	stw	zero,-28(fp)
 8234dd0:	00001b06 	br	8234e40 <sock_selscan+0xfc>
      {
         if (sock_select (in->fd_array[sock], flag))
 8234dd4:	e0fffc17 	ldw	r3,-16(fp)
 8234dd8:	e0bff917 	ldw	r2,-28(fp)
 8234ddc:	10800044 	addi	r2,r2,1
 8234de0:	1085883a 	add	r2,r2,r2
 8234de4:	1085883a 	add	r2,r2,r2
 8234de8:	1885883a 	add	r2,r3,r2
 8234dec:	10800017 	ldw	r2,0(r2)
 8234df0:	e17ffa17 	ldw	r5,-24(fp)
 8234df4:	1009883a 	mov	r4,r2
 8234df8:	8234e840 	call	8234e84 <sock_select>
 8234dfc:	10000d26 	beq	r2,zero,8234e34 <sock_selscan+0xf0>
         {
            FD_SET(in->fd_array[sock], out);
 8234e00:	e0fffc17 	ldw	r3,-16(fp)
 8234e04:	e0bff917 	ldw	r2,-28(fp)
 8234e08:	10800044 	addi	r2,r2,1
 8234e0c:	1085883a 	add	r2,r2,r2
 8234e10:	1085883a 	add	r2,r2,r2
 8234e14:	1885883a 	add	r2,r3,r2
 8234e18:	10800017 	ldw	r2,0(r2)
 8234e1c:	e17ffd17 	ldw	r5,-12(fp)
 8234e20:	1009883a 	mov	r4,r2
 8234e24:	823529c0 	call	823529c <ifd_set>
            num_sel++;
 8234e28:	e0bffb17 	ldw	r2,-20(fp)
 8234e2c:	10800044 	addi	r2,r2,1
 8234e30:	e0bffb15 	stw	r2,-20(fp)
      case 2:
         flag = 0; break;
      }
      in = &ibits [which];
      out = &obits [which];
      for (sock = 0; sock < (int)in->fd_count; sock++)
 8234e34:	e0bff917 	ldw	r2,-28(fp)
 8234e38:	10800044 	addi	r2,r2,1
 8234e3c:	e0bff915 	stw	r2,-28(fp)
 8234e40:	e0bffc17 	ldw	r2,-16(fp)
 8234e44:	10800017 	ldw	r2,0(r2)
 8234e48:	1007883a 	mov	r3,r2
 8234e4c:	e0bff917 	ldw	r2,-28(fp)
 8234e50:	10ffe016 	blt	r2,r3,8234dd4 <sock_selscan+0x90>
   int   which;
   int   sock;
   int   flag  =  0;
   int   num_sel  =  0;

   for (which = 0; which < 3; which++)
 8234e54:	e0bff817 	ldw	r2,-32(fp)
 8234e58:	10800044 	addi	r2,r2,1
 8234e5c:	e0bff815 	stw	r2,-32(fp)
 8234e60:	e0bff817 	ldw	r2,-32(fp)
 8234e64:	108000d0 	cmplti	r2,r2,3
 8234e68:	103fc01e 	bne	r2,zero,8234d6c <sock_selscan+0x28>
            FD_SET(in->fd_array[sock], out);
            num_sel++;
         }
      }
   }
   return num_sel;
 8234e6c:	e0bffb17 	ldw	r2,-20(fp)
}
 8234e70:	e037883a 	mov	sp,fp
 8234e74:	dfc00117 	ldw	ra,4(sp)
 8234e78:	df000017 	ldw	fp,0(sp)
 8234e7c:	dec00204 	addi	sp,sp,8
 8234e80:	f800283a 	ret

08234e84 <sock_select>:
 * RETURNS: 
 */

int
sock_select(long sock, int flag)
{
 8234e84:	defffa04 	addi	sp,sp,-24
 8234e88:	dfc00515 	stw	ra,20(sp)
 8234e8c:	df000415 	stw	fp,16(sp)
 8234e90:	df000404 	addi	fp,sp,16
 8234e94:	e13ffe15 	stw	r4,-8(fp)
 8234e98:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so;
   int   ready =  0;
 8234e9c:	e03ffc15 	stw	zero,-16(fp)

   so = LONG2SO(sock);
 8234ea0:	e0bffe17 	ldw	r2,-8(fp)
 8234ea4:	10bff804 	addi	r2,r2,-32
 8234ea8:	1085883a 	add	r2,r2,r2
 8234eac:	1085883a 	add	r2,r2,r2
 8234eb0:	e0bffd15 	stw	r2,-12(fp)

   switch (flag) 
 8234eb4:	e0bfff17 	ldw	r2,-4(fp)
 8234eb8:	10c00060 	cmpeqi	r3,r2,1
 8234ebc:	1800041e 	bne	r3,zero,8234ed0 <sock_select+0x4c>
 8234ec0:	10c000a0 	cmpeqi	r3,r2,2
 8234ec4:	1800201e 	bne	r3,zero,8234f48 <sock_select+0xc4>
 8234ec8:	10004326 	beq	r2,zero,8234fd8 <sock_select+0x154>
 8234ecc:	00006006 	br	8235050 <sock_select+0x1cc>
   {
   case SOREAD:
      /* can we read something from so? */
      if (so->so_rcv.sb_cc)
 8234ed0:	e0bffd17 	ldw	r2,-12(fp)
 8234ed4:	10800a17 	ldw	r2,40(r2)
 8234ed8:	10000326 	beq	r2,zero,8234ee8 <sock_select+0x64>
      {
         ready = 1;
 8234edc:	00800044 	movi	r2,1
 8234ee0:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234ee4:	00005a06 	br	8235050 <sock_select+0x1cc>
      }
      if (so->so_state & SS_CANTRCVMORE)
 8234ee8:	e0bffd17 	ldw	r2,-12(fp)
 8234eec:	1080088b 	ldhu	r2,34(r2)
 8234ef0:	10bfffcc 	andi	r2,r2,65535
 8234ef4:	1080080c 	andi	r2,r2,32
 8234ef8:	10000326 	beq	r2,zero,8234f08 <sock_select+0x84>
      {  ready = 1;
 8234efc:	00800044 	movi	r2,1
 8234f00:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234f04:	00005206 	br	8235050 <sock_select+0x1cc>
      }
      if (so->so_qlen)  /* attach is ready */
 8234f08:	e0bffd17 	ldw	r2,-12(fp)
 8234f0c:	10801e43 	ldbu	r2,121(r2)
 8234f10:	10803fcc 	andi	r2,r2,255
 8234f14:	1080201c 	xori	r2,r2,128
 8234f18:	10bfe004 	addi	r2,r2,-128
 8234f1c:	10000326 	beq	r2,zero,8234f2c <sock_select+0xa8>
      {
         ready = 1;
 8234f20:	00800044 	movi	r2,1
 8234f24:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234f28:	00004906 	br	8235050 <sock_select+0x1cc>
         }
      }
#endif   /* TCP_ZEROCOPY */

      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
 8234f2c:	e0bffd17 	ldw	r2,-12(fp)
 8234f30:	1080110b 	ldhu	r2,68(r2)
 8234f34:	10800214 	ori	r2,r2,8
 8234f38:	1007883a 	mov	r3,r2
 8234f3c:	e0bffd17 	ldw	r2,-12(fp)
 8234f40:	10c0110d 	sth	r3,68(r2)
      break;
 8234f44:	00004206 	br	8235050 <sock_select+0x1cc>

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 8234f48:	e0bffd17 	ldw	r2,-12(fp)
 8234f4c:	10801317 	ldw	r2,76(r2)
 8234f50:	1007883a 	mov	r3,r2
 8234f54:	e0bffd17 	ldw	r2,-12(fp)
 8234f58:	10801217 	ldw	r2,72(r2)
 8234f5c:	1885c83a 	sub	r2,r3,r2
 8234f60:	10001816 	blt	r2,zero,8234fc4 <sock_select+0x140>
 8234f64:	e0bffd17 	ldw	r2,-12(fp)
 8234f68:	10c01317 	ldw	r3,76(r2)
 8234f6c:	e0bffd17 	ldw	r2,-12(fp)
 8234f70:	10801217 	ldw	r2,72(r2)
 8234f74:	18801326 	beq	r3,r2,8234fc4 <sock_select+0x140>
          ((((so)->so_state&SS_ISCONNECTED) || 
 8234f78:	e0bffd17 	ldw	r2,-12(fp)
 8234f7c:	1080088b 	ldhu	r2,34(r2)
 8234f80:	10bfffcc 	andi	r2,r2,65535
 8234f84:	1080008c 	andi	r2,r2,2
      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 8234f88:	10000b1e 	bne	r2,zero,8234fb8 <sock_select+0x134>
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
 8234f8c:	e0bffd17 	ldw	r2,-12(fp)
 8234f90:	10800217 	ldw	r2,8(r2)
 8234f94:	1080010b 	ldhu	r2,4(r2)
 8234f98:	10bfffcc 	andi	r2,r2,65535
 8234f9c:	1080010c 	andi	r2,r2,4
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
          ((((so)->so_state&SS_ISCONNECTED) || 
 8234fa0:	10000526 	beq	r2,zero,8234fb8 <sock_select+0x134>
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
           ((so)->so_state & SS_CANTSENDMORE)))
 8234fa4:	e0bffd17 	ldw	r2,-12(fp)
 8234fa8:	1080088b 	ldhu	r2,34(r2)
 8234fac:	10bfffcc 	andi	r2,r2,65535
 8234fb0:	1080040c 	andi	r2,r2,16
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
 8234fb4:	10000326 	beq	r2,zero,8234fc4 <sock_select+0x140>
           ((so)->so_state & SS_CANTSENDMORE)))
      {
         ready = 1;
 8234fb8:	00800044 	movi	r2,1
 8234fbc:	e0bffc15 	stw	r2,-16(fp)
         break;
 8234fc0:	00002306 	br	8235050 <sock_select+0x1cc>
      }
      sbselqueue (&so->so_snd);
 8234fc4:	e0bffd17 	ldw	r2,-12(fp)
 8234fc8:	10801204 	addi	r2,r2,72
 8234fcc:	1009883a 	mov	r4,r2
 8234fd0:	823401c0 	call	823401c <sbselqueue>
      break;
 8234fd4:	00001e06 	br	8235050 <sock_select+0x1cc>

   case 0:
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
 8234fd8:	e0bffd17 	ldw	r2,-12(fp)
 8234fdc:	10801a17 	ldw	r2,104(r2)
 8234fe0:	1000051e 	bne	r2,zero,8234ff8 <sock_select+0x174>
 8234fe4:	e0bffd17 	ldw	r2,-12(fp)
 8234fe8:	1080088b 	ldhu	r2,34(r2)
 8234fec:	10bfffcc 	andi	r2,r2,65535
 8234ff0:	1080100c 	andi	r2,r2,64
 8234ff4:	10000326 	beq	r2,zero,8235004 <sock_select+0x180>
      {
         ready = 1;
 8234ff8:	00800044 	movi	r2,1
 8234ffc:	e0bffc15 	stw	r2,-16(fp)
         break;
 8235000:	00001306 	br	8235050 <sock_select+0x1cc>
      }
      if (so->so_error &&
 8235004:	e0bffd17 	ldw	r2,-12(fp)
 8235008:	10800617 	ldw	r2,24(r2)
 823500c:	10000b26 	beq	r2,zero,823503c <sock_select+0x1b8>
          (so->so_error != EINPROGRESS) &&
 8235010:	e0bffd17 	ldw	r2,-12(fp)
 8235014:	10800617 	ldw	r2,24(r2)
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
      {
         ready = 1;
         break;
      }
      if (so->so_error &&
 8235018:	10801de0 	cmpeqi	r2,r2,119
 823501c:	1000071e 	bne	r2,zero,823503c <sock_select+0x1b8>
          (so->so_error != EINPROGRESS) &&
          (so->so_error != EWOULDBLOCK))
 8235020:	e0bffd17 	ldw	r2,-12(fp)
 8235024:	10800617 	ldw	r2,24(r2)
      {
         ready = 1;
         break;
      }
      if (so->so_error &&
          (so->so_error != EINPROGRESS) &&
 8235028:	108002e0 	cmpeqi	r2,r2,11
 823502c:	1000031e 	bne	r2,zero,823503c <sock_select+0x1b8>
          (so->so_error != EWOULDBLOCK))
      {
         ready = 1;
 8235030:	00800044 	movi	r2,1
 8235034:	e0bffc15 	stw	r2,-16(fp)
         break;
 8235038:	00000506 	br	8235050 <sock_select+0x1cc>
      }
      sbselqueue(&so->so_rcv);
 823503c:	e0bffd17 	ldw	r2,-12(fp)
 8235040:	10800a04 	addi	r2,r2,40
 8235044:	1009883a 	mov	r4,r2
 8235048:	823401c0 	call	823401c <sbselqueue>
      break;
 823504c:	0001883a 	nop
   }

   return ready;
 8235050:	e0bffc17 	ldw	r2,-16(fp)
}
 8235054:	e037883a 	mov	sp,fp
 8235058:	dfc00117 	ldw	ra,4(sp)
 823505c:	df000017 	ldw	fp,0(sp)
 8235060:	dec00204 	addi	sp,sp,8
 8235064:	f800283a 	ret

08235068 <in_pcbnotify>:
void
in_pcbnotify(struct inpcb * head, 
   struct in_addr *  dst,
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
 8235068:	defff804 	addi	sp,sp,-32
 823506c:	dfc00715 	stw	ra,28(sp)
 8235070:	df000615 	stw	fp,24(sp)
 8235074:	df000604 	addi	fp,sp,24
 8235078:	e13ffc15 	stw	r4,-16(fp)
 823507c:	e17ffd15 	stw	r5,-12(fp)
 8235080:	e1bffe15 	stw	r6,-8(fp)
 8235084:	e1ffff15 	stw	r7,-4(fp)
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 8235088:	e0bffc17 	ldw	r2,-16(fp)
 823508c:	10800017 	ldw	r2,0(r2)
 8235090:	e0bffa15 	stw	r2,-24(fp)
 8235094:	00001c06 	br	8235108 <in_pcbnotify+0xa0>
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 8235098:	e0bffa17 	ldw	r2,-24(fp)
 823509c:	10c00317 	ldw	r3,12(r2)
 82350a0:	e0bffd17 	ldw	r2,-12(fp)
 82350a4:	10800017 	ldw	r2,0(r2)
 82350a8:	1880031e 	bne	r3,r2,82350b8 <in_pcbnotify+0x50>
          inp->inp_socket == 0) 
 82350ac:	e0bffa17 	ldw	r2,-24(fp)
 82350b0:	10800817 	ldw	r2,32(r2)
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 82350b4:	1000041e 	bne	r2,zero,82350c8 <in_pcbnotify+0x60>
          inp->inp_socket == 0) 
      {
         inp = inp->inp_next;
 82350b8:	e0bffa17 	ldw	r2,-24(fp)
 82350bc:	10800017 	ldw	r2,0(r2)
 82350c0:	e0bffa15 	stw	r2,-24(fp)
         continue;
 82350c4:	00001006 	br	8235108 <in_pcbnotify+0xa0>
      }
      if (errnum) 
 82350c8:	e0bffe17 	ldw	r2,-8(fp)
 82350cc:	10000426 	beq	r2,zero,82350e0 <in_pcbnotify+0x78>
         inp->inp_socket->so_error = errnum;
 82350d0:	e0bffa17 	ldw	r2,-24(fp)
 82350d4:	10800817 	ldw	r2,32(r2)
 82350d8:	e0fffe17 	ldw	r3,-8(fp)
 82350dc:	10c00615 	stw	r3,24(r2)
      oinp = inp;
 82350e0:	e0bffa17 	ldw	r2,-24(fp)
 82350e4:	e0bffb15 	stw	r2,-20(fp)
      inp = inp->inp_next;
 82350e8:	e0bffa17 	ldw	r2,-24(fp)
 82350ec:	10800017 	ldw	r2,0(r2)
 82350f0:	e0bffa15 	stw	r2,-24(fp)
      if (notify)
 82350f4:	e0bfff17 	ldw	r2,-4(fp)
 82350f8:	10000326 	beq	r2,zero,8235108 <in_pcbnotify+0xa0>
         (*notify)(oinp);
 82350fc:	e0bfff17 	ldw	r2,-4(fp)
 8235100:	e13ffb17 	ldw	r4,-20(fp)
 8235104:	103ee83a 	callr	r2
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 8235108:	e0fffa17 	ldw	r3,-24(fp)
 823510c:	e0bffc17 	ldw	r2,-16(fp)
 8235110:	18bfe11e 	bne	r3,r2,8235098 <in_pcbnotify+0x30>
      oinp = inp;
      inp = inp->inp_next;
      if (notify)
         (*notify)(oinp);
   }
}
 8235114:	0001883a 	nop
 8235118:	e037883a 	mov	sp,fp
 823511c:	dfc00117 	ldw	ra,4(sp)
 8235120:	df000017 	ldw	fp,0(sp)
 8235124:	dec00204 	addi	sp,sp,8
 8235128:	f800283a 	ret

0823512c <tcp_notify>:
 * RETURNS: 
 */

void
tcp_notify(struct inpcb * inp)
{
 823512c:	defffd04 	addi	sp,sp,-12
 8235130:	dfc00215 	stw	ra,8(sp)
 8235134:	df000115 	stw	fp,4(sp)
 8235138:	df000104 	addi	fp,sp,4
 823513c:	e13fff15 	stw	r4,-4(fp)
   tcp_wakeup(&inp->inp_socket->so_timeo);
 8235140:	e0bfff17 	ldw	r2,-4(fp)
 8235144:	10800817 	ldw	r2,32(r2)
 8235148:	10800904 	addi	r2,r2,36
 823514c:	1009883a 	mov	r4,r2
 8235150:	822954c0 	call	822954c <tcp_wakeup>
   sorwakeup(inp->inp_socket);
 8235154:	e0bfff17 	ldw	r2,-4(fp)
 8235158:	10c00817 	ldw	r3,32(r2)
 823515c:	e0bfff17 	ldw	r2,-4(fp)
 8235160:	10800817 	ldw	r2,32(r2)
 8235164:	10800a04 	addi	r2,r2,40
 8235168:	100b883a 	mov	r5,r2
 823516c:	1809883a 	mov	r4,r3
 8235170:	82340c40 	call	82340c4 <sbwakeup>
   sowwakeup(inp->inp_socket);
 8235174:	e0bfff17 	ldw	r2,-4(fp)
 8235178:	10c00817 	ldw	r3,32(r2)
 823517c:	e0bfff17 	ldw	r2,-4(fp)
 8235180:	10800817 	ldw	r2,32(r2)
 8235184:	10801204 	addi	r2,r2,72
 8235188:	100b883a 	mov	r5,r2
 823518c:	1809883a 	mov	r4,r3
 8235190:	82340c40 	call	82340c4 <sbwakeup>
}
 8235194:	0001883a 	nop
 8235198:	e037883a 	mov	sp,fp
 823519c:	dfc00117 	ldw	ra,4(sp)
 82351a0:	df000017 	ldw	fp,0(sp)
 82351a4:	dec00204 	addi	sp,sp,8
 82351a8:	f800283a 	ret

082351ac <ifd_clr>:
 * compacts the fd_set.
 */

void
ifd_clr(long sock, fd_set *set)
{
 82351ac:	defffb04 	addi	sp,sp,-20
 82351b0:	dfc00415 	stw	ra,16(sp)
 82351b4:	df000315 	stw	fp,12(sp)
 82351b8:	df000304 	addi	fp,sp,12
 82351bc:	e13ffe15 	stw	r4,-8(fp)
 82351c0:	e17fff15 	stw	r5,-4(fp)
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 82351c4:	e03ffd15 	stw	zero,-12(fp)
 82351c8:	00002a06 	br	8235274 <ifd_clr+0xc8>
   {
      if (set->fd_array[i] == sock)
 82351cc:	e0ffff17 	ldw	r3,-4(fp)
 82351d0:	e0bffd17 	ldw	r2,-12(fp)
 82351d4:	10800044 	addi	r2,r2,1
 82351d8:	1085883a 	add	r2,r2,r2
 82351dc:	1085883a 	add	r2,r2,r2
 82351e0:	1885883a 	add	r2,r3,r2
 82351e4:	10c00017 	ldw	r3,0(r2)
 82351e8:	e0bffe17 	ldw	r2,-8(fp)
 82351ec:	18801e1e 	bne	r3,r2,8235268 <ifd_clr+0xbc>
      {
         while (i + 1 < set->fd_count)
 82351f0:	00001206 	br	823523c <ifd_clr+0x90>
         {
            set->fd_array[i] = set->fd_array[i + 1];
 82351f4:	e0bffd17 	ldw	r2,-12(fp)
 82351f8:	10800044 	addi	r2,r2,1
 82351fc:	e0ffff17 	ldw	r3,-4(fp)
 8235200:	10800044 	addi	r2,r2,1
 8235204:	1085883a 	add	r2,r2,r2
 8235208:	1085883a 	add	r2,r2,r2
 823520c:	1885883a 	add	r2,r3,r2
 8235210:	10c00017 	ldw	r3,0(r2)
 8235214:	e13fff17 	ldw	r4,-4(fp)
 8235218:	e0bffd17 	ldw	r2,-12(fp)
 823521c:	10800044 	addi	r2,r2,1
 8235220:	1085883a 	add	r2,r2,r2
 8235224:	1085883a 	add	r2,r2,r2
 8235228:	2085883a 	add	r2,r4,r2
 823522c:	10c00015 	stw	r3,0(r2)
            i++;
 8235230:	e0bffd17 	ldw	r2,-12(fp)
 8235234:	10800044 	addi	r2,r2,1
 8235238:	e0bffd15 	stw	r2,-12(fp)

   for (i = 0; i < set->fd_count ; i++) 
   {
      if (set->fd_array[i] == sock)
      {
         while (i + 1 < set->fd_count)
 823523c:	e0bffd17 	ldw	r2,-12(fp)
 8235240:	10c00044 	addi	r3,r2,1
 8235244:	e0bfff17 	ldw	r2,-4(fp)
 8235248:	10800017 	ldw	r2,0(r2)
 823524c:	18bfe936 	bltu	r3,r2,82351f4 <ifd_clr+0x48>
         {
            set->fd_array[i] = set->fd_array[i + 1];
            i++;
         }
         set->fd_count--;
 8235250:	e0bfff17 	ldw	r2,-4(fp)
 8235254:	10800017 	ldw	r2,0(r2)
 8235258:	10ffffc4 	addi	r3,r2,-1
 823525c:	e0bfff17 	ldw	r2,-4(fp)
 8235260:	10c00015 	stw	r3,0(r2)
         return;
 8235264:	00000806 	br	8235288 <ifd_clr+0xdc>
void
ifd_clr(long sock, fd_set *set)
{
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 8235268:	e0bffd17 	ldw	r2,-12(fp)
 823526c:	10800044 	addi	r2,r2,1
 8235270:	e0bffd15 	stw	r2,-12(fp)
 8235274:	e0bfff17 	ldw	r2,-4(fp)
 8235278:	10800017 	ldw	r2,0(r2)
 823527c:	e0fffd17 	ldw	r3,-12(fp)
 8235280:	18bfd236 	bltu	r3,r2,82351cc <ifd_clr+0x20>
         return;
      }
   }

#ifdef NPDEBUG
   dtrap(); /* socket wasn't found in array */
 8235284:	822d4140 	call	822d414 <dtrap>
#endif
}
 8235288:	e037883a 	mov	sp,fp
 823528c:	dfc00117 	ldw	ra,4(sp)
 8235290:	df000017 	ldw	fp,0(sp)
 8235294:	dec00204 	addi	sp,sp,8
 8235298:	f800283a 	ret

0823529c <ifd_set>:
 * called if the fd_set structure is already full.
 */

void
ifd_set(long sock, fd_set *set)
{
 823529c:	defffc04 	addi	sp,sp,-16
 82352a0:	dfc00315 	stw	ra,12(sp)
 82352a4:	df000215 	stw	fp,8(sp)
 82352a8:	df000204 	addi	fp,sp,8
 82352ac:	e13ffe15 	stw	r4,-8(fp)
 82352b0:	e17fff15 	stw	r5,-4(fp)
   if (set->fd_count < FD_SETSIZE)
 82352b4:	e0bfff17 	ldw	r2,-4(fp)
 82352b8:	10800017 	ldw	r2,0(r2)
 82352bc:	10801028 	cmpgeui	r2,r2,64
 82352c0:	10000d1e 	bne	r2,zero,82352f8 <ifd_set+0x5c>
      set->fd_array[set->fd_count++] = sock;
 82352c4:	e0bfff17 	ldw	r2,-4(fp)
 82352c8:	10800017 	ldw	r2,0(r2)
 82352cc:	11000044 	addi	r4,r2,1
 82352d0:	e0ffff17 	ldw	r3,-4(fp)
 82352d4:	19000015 	stw	r4,0(r3)
 82352d8:	e0ffff17 	ldw	r3,-4(fp)
 82352dc:	10800044 	addi	r2,r2,1
 82352e0:	1085883a 	add	r2,r2,r2
 82352e4:	1085883a 	add	r2,r2,r2
 82352e8:	1885883a 	add	r2,r3,r2
 82352ec:	e0fffe17 	ldw	r3,-8(fp)
 82352f0:	10c00015 	stw	r3,0(r2)
#ifdef NPDEBUG
   else
      dtrap();
#endif
}
 82352f4:	00000106 	br	82352fc <ifd_set+0x60>
{
   if (set->fd_count < FD_SETSIZE)
      set->fd_array[set->fd_count++] = sock;
#ifdef NPDEBUG
   else
      dtrap();
 82352f8:	822d4140 	call	822d414 <dtrap>
#endif
}
 82352fc:	0001883a 	nop
 8235300:	e037883a 	mov	sp,fp
 8235304:	dfc00117 	ldw	ra,4(sp)
 8235308:	df000017 	ldw	fp,0(sp)
 823530c:	dec00204 	addi	sp,sp,8
 8235310:	f800283a 	ret

08235314 <ifd_isset>:
 * Tests if a socket is a member of a file descriptor set.
 */

int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
 8235314:	defffc04 	addi	sp,sp,-16
 8235318:	df000315 	stw	fp,12(sp)
 823531c:	df000304 	addi	fp,sp,12
 8235320:	e13ffe15 	stw	r4,-8(fp)
 8235324:	e17fff15 	stw	r5,-4(fp)
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 8235328:	e03ffd15 	stw	zero,-12(fp)
 823532c:	00000e06 	br	8235368 <ifd_isset+0x54>
   {
      if (set->fd_array[i] == sock)
 8235330:	e0ffff17 	ldw	r3,-4(fp)
 8235334:	e0bffd17 	ldw	r2,-12(fp)
 8235338:	10800044 	addi	r2,r2,1
 823533c:	1085883a 	add	r2,r2,r2
 8235340:	1085883a 	add	r2,r2,r2
 8235344:	1885883a 	add	r2,r3,r2
 8235348:	10c00017 	ldw	r3,0(r2)
 823534c:	e0bffe17 	ldw	r2,-8(fp)
 8235350:	1880021e 	bne	r3,r2,823535c <ifd_isset+0x48>
         return TRUE;
 8235354:	00800044 	movi	r2,1
 8235358:	00000806 	br	823537c <ifd_isset+0x68>
int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 823535c:	e0bffd17 	ldw	r2,-12(fp)
 8235360:	10800044 	addi	r2,r2,1
 8235364:	e0bffd15 	stw	r2,-12(fp)
 8235368:	e0bfff17 	ldw	r2,-4(fp)
 823536c:	10800017 	ldw	r2,0(r2)
 8235370:	e0fffd17 	ldw	r3,-12(fp)
 8235374:	18bfee36 	bltu	r3,r2,8235330 <ifd_isset+0x1c>
   {
      if (set->fd_array[i] == sock)
         return TRUE;
   }
   return FALSE;
 8235378:	0005883a 	mov	r2,zero
}
 823537c:	e037883a 	mov	sp,fp
 8235380:	df000017 	ldw	fp,0(sp)
 8235384:	dec00104 	addi	sp,sp,4
 8235388:	f800283a 	ret

0823538c <ifd_get>:
 * NOTE: This is not part of the original FD_XXX() functionality.
 */

long
ifd_get(unsigned i, fd_set *set)
{
 823538c:	defffc04 	addi	sp,sp,-16
 8235390:	dfc00315 	stw	ra,12(sp)
 8235394:	df000215 	stw	fp,8(sp)
 8235398:	df000204 	addi	fp,sp,8
 823539c:	e13ffe15 	stw	r4,-8(fp)
 82353a0:	e17fff15 	stw	r5,-4(fp)
   if (i < set->fd_count)
 82353a4:	e0bfff17 	ldw	r2,-4(fp)
 82353a8:	10800017 	ldw	r2,0(r2)
 82353ac:	e0fffe17 	ldw	r3,-8(fp)
 82353b0:	1880082e 	bgeu	r3,r2,82353d4 <ifd_get+0x48>
      return set->fd_array[i];
 82353b4:	e0ffff17 	ldw	r3,-4(fp)
 82353b8:	e0bffe17 	ldw	r2,-8(fp)
 82353bc:	10800044 	addi	r2,r2,1
 82353c0:	1085883a 	add	r2,r2,r2
 82353c4:	1085883a 	add	r2,r2,r2
 82353c8:	1885883a 	add	r2,r3,r2
 82353cc:	10800017 	ldw	r2,0(r2)
 82353d0:	00000206 	br	82353dc <ifd_get+0x50>
   else
   {
#ifdef NPDEBUG
      dtrap();
 82353d4:	822d4140 	call	822d414 <dtrap>
#endif
      return INVALID_SOCKET;
 82353d8:	00bfffc4 	movi	r2,-1
   }
}
 82353dc:	e037883a 	mov	sp,fp
 82353e0:	dfc00117 	ldw	ra,4(sp)
 82353e4:	df000017 	ldw	fp,0(sp)
 82353e8:	dec00204 	addi	sp,sp,8
 82353ec:	f800283a 	ret

082353f0 <tcp_reass>:

int
tcp_reass(struct tcpcb * tp, 
   struct tcpiphdr * ti,
   struct mbuf *  ti_mbuf)
{
 82353f0:	defff504 	addi	sp,sp,-44
 82353f4:	dfc00a15 	stw	ra,40(sp)
 82353f8:	df000915 	stw	fp,36(sp)
 82353fc:	df000904 	addi	fp,sp,36
 8235400:	e13ffd15 	stw	r4,-12(fp)
 8235404:	e17ffe15 	stw	r5,-8(fp)
 8235408:	e1bfff15 	stw	r6,-4(fp)
   struct tcpiphdr * q;
   struct socket *   so =  tp->t_inpcb->inp_socket;
 823540c:	e0bffd17 	ldw	r2,-12(fp)
 8235410:	10800d17 	ldw	r2,52(r2)
 8235414:	10800817 	ldw	r2,32(r2)
 8235418:	e0bff815 	stw	r2,-32(fp)

   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
 823541c:	e0bffe17 	ldw	r2,-8(fp)
 8235420:	1000a426 	beq	r2,zero,82356b4 <tcp_reass+0x2c4>
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 8235424:	e0bffd17 	ldw	r2,-12(fp)
 8235428:	10800017 	ldw	r2,0(r2)
 823542c:	e0bff715 	stw	r2,-36(fp)
 8235430:	00000906 	br	8235458 <tcp_reass+0x68>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
 8235434:	e0bff717 	ldw	r2,-36(fp)
 8235438:	10c00617 	ldw	r3,24(r2)
 823543c:	e0bffe17 	ldw	r2,-8(fp)
 8235440:	10800617 	ldw	r2,24(r2)
 8235444:	1885c83a 	sub	r2,r3,r2
 8235448:	00800716 	blt	zero,r2,8235468 <tcp_reass+0x78>

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
       q = (struct tcpiphdr *)q->ti_next)
 823544c:	e0bff717 	ldw	r2,-36(fp)
 8235450:	10800017 	ldw	r2,0(r2)
 8235454:	e0bff715 	stw	r2,-36(fp)
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 8235458:	e0fff717 	ldw	r3,-36(fp)
 823545c:	e0bffd17 	ldw	r2,-12(fp)
 8235460:	18bff41e 	bne	r3,r2,8235434 <tcp_reass+0x44>
 8235464:	00000106 	br	823546c <tcp_reass+0x7c>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
      break;
 8235468:	0001883a 	nop
   /*
    * If there is a preceding segment, it may provide some of
    * our data already.  If so, drop the data from the incoming
    * segment.  If it provides all of our data, drop us.
    */
   if ((struct tcpiphdr *)q->ti_prev != (struct tcpiphdr *)tp) 
 823546c:	e0bff717 	ldw	r2,-36(fp)
 8235470:	10c00117 	ldw	r3,4(r2)
 8235474:	e0bffd17 	ldw	r2,-12(fp)
 8235478:	18803f26 	beq	r3,r2,8235578 <tcp_reass+0x188>
   {
      long  i;
      q = (struct tcpiphdr *)q->ti_prev;
 823547c:	e0bff717 	ldw	r2,-36(fp)
 8235480:	10800117 	ldw	r2,4(r2)
 8235484:	e0bff715 	stw	r2,-36(fp)
      /* conversion to int (in i) handles seq wraparound */
      i = q->ti_seq + q->ti_len - ti->ti_seq;
 8235488:	e0bff717 	ldw	r2,-36(fp)
 823548c:	10c00617 	ldw	r3,24(r2)
 8235490:	e0bff717 	ldw	r2,-36(fp)
 8235494:	1080028b 	ldhu	r2,10(r2)
 8235498:	10bfffcc 	andi	r2,r2,65535
 823549c:	1887883a 	add	r3,r3,r2
 82354a0:	e0bffe17 	ldw	r2,-8(fp)
 82354a4:	10800617 	ldw	r2,24(r2)
 82354a8:	1885c83a 	sub	r2,r3,r2
 82354ac:	e0bff915 	stw	r2,-28(fp)
      if (i > 0) 
 82354b0:	e0bff917 	ldw	r2,-28(fp)
 82354b4:	00802d0e 	bge	zero,r2,823556c <tcp_reass+0x17c>
      {
         if (i >= (long)ti->ti_len) 
 82354b8:	e0bffe17 	ldw	r2,-8(fp)
 82354bc:	1080028b 	ldhu	r2,10(r2)
 82354c0:	10bfffcc 	andi	r2,r2,65535
 82354c4:	e0fff917 	ldw	r3,-28(fp)
 82354c8:	18801816 	blt	r3,r2,823552c <tcp_reass+0x13c>
         {
            tcpstat.tcps_rcvduppack++;
 82354cc:	008209b4 	movhi	r2,2086
 82354d0:	10b99404 	addi	r2,r2,-6576
 82354d4:	10801f17 	ldw	r2,124(r2)
 82354d8:	10c00044 	addi	r3,r2,1
 82354dc:	008209b4 	movhi	r2,2086
 82354e0:	10b99404 	addi	r2,r2,-6576
 82354e4:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
 82354e8:	008209b4 	movhi	r2,2086
 82354ec:	10b99404 	addi	r2,r2,-6576
 82354f0:	10c02017 	ldw	r3,128(r2)
 82354f4:	e0bffe17 	ldw	r2,-8(fp)
 82354f8:	1080028b 	ldhu	r2,10(r2)
 82354fc:	10bfffcc 	andi	r2,r2,65535
 8235500:	1887883a 	add	r3,r3,r2
 8235504:	008209b4 	movhi	r2,2086
 8235508:	10b99404 	addi	r2,r2,-6576
 823550c:	10c02015 	stw	r3,128(r2)
            GOTO_DROP;
 8235510:	008025c4 	movi	r2,151
 8235514:	d0a0b215 	stw	r2,-32056(gp)
 8235518:	0001883a 	nop
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
      sorwakeup(so);
   return (flags);
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
 823551c:	e13fff17 	ldw	r4,-4(fp)
 8235520:	822e4b80 	call	822e4b8 <m_freem>
   return (0);
 8235524:	0005883a 	mov	r2,zero
 8235528:	0000b006 	br	82357ec <tcp_reass+0x3fc>
         {
            tcpstat.tcps_rcvduppack++;
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
            GOTO_DROP;
         }
         m_adj (ti_mbuf, (int)i);
 823552c:	e17ff917 	ldw	r5,-28(fp)
 8235530:	e13fff17 	ldw	r4,-4(fp)
 8235534:	822e7f00 	call	822e7f0 <m_adj>
         ti->ti_len -= (short)i;
 8235538:	e0bffe17 	ldw	r2,-8(fp)
 823553c:	1080028b 	ldhu	r2,10(r2)
 8235540:	e0fff917 	ldw	r3,-28(fp)
 8235544:	10c5c83a 	sub	r2,r2,r3
 8235548:	1007883a 	mov	r3,r2
 823554c:	e0bffe17 	ldw	r2,-8(fp)
 8235550:	10c0028d 	sth	r3,10(r2)
         ti->ti_seq += (tcp_seq)i;
 8235554:	e0bffe17 	ldw	r2,-8(fp)
 8235558:	10c00617 	ldw	r3,24(r2)
 823555c:	e0bff917 	ldw	r2,-28(fp)
 8235560:	1887883a 	add	r3,r3,r2
 8235564:	e0bffe17 	ldw	r2,-8(fp)
 8235568:	10c00615 	stw	r3,24(r2)
      }
      q = (struct tcpiphdr *)(q->ti_next);
 823556c:	e0bff717 	ldw	r2,-36(fp)
 8235570:	10800017 	ldw	r2,0(r2)
 8235574:	e0bff715 	stw	r2,-36(fp)
   }
   tcpstat.tcps_rcvoopack++;
 8235578:	008209b4 	movhi	r2,2086
 823557c:	10b99404 	addi	r2,r2,-6576
 8235580:	10802317 	ldw	r2,140(r2)
 8235584:	10c00044 	addi	r3,r2,1
 8235588:	008209b4 	movhi	r2,2086
 823558c:	10b99404 	addi	r2,r2,-6576
 8235590:	10c02315 	stw	r3,140(r2)
   tcpstat.tcps_rcvoobyte += ti->ti_len;
 8235594:	008209b4 	movhi	r2,2086
 8235598:	10b99404 	addi	r2,r2,-6576
 823559c:	10c02417 	ldw	r3,144(r2)
 82355a0:	e0bffe17 	ldw	r2,-8(fp)
 82355a4:	1080028b 	ldhu	r2,10(r2)
 82355a8:	10bfffcc 	andi	r2,r2,65535
 82355ac:	1887883a 	add	r3,r3,r2
 82355b0:	008209b4 	movhi	r2,2086
 82355b4:	10b99404 	addi	r2,r2,-6576
 82355b8:	10c02415 	stw	r3,144(r2)

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 82355bc:	00003206 	br	8235688 <tcp_reass+0x298>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
 82355c0:	e0bffe17 	ldw	r2,-8(fp)
 82355c4:	10c00617 	ldw	r3,24(r2)
 82355c8:	e0bffe17 	ldw	r2,-8(fp)
 82355cc:	1080028b 	ldhu	r2,10(r2)
 82355d0:	10bfffcc 	andi	r2,r2,65535
 82355d4:	1887883a 	add	r3,r3,r2
 82355d8:	e0bff717 	ldw	r2,-36(fp)
 82355dc:	10800617 	ldw	r2,24(r2)
 82355e0:	1885c83a 	sub	r2,r3,r2
 82355e4:	e0bffa15 	stw	r2,-24(fp)
      if (i <= 0)
 82355e8:	e0bffa17 	ldw	r2,-24(fp)
 82355ec:	00802a0e 	bge	zero,r2,8235698 <tcp_reass+0x2a8>
         break;
      if (i < (int)(q->ti_len))
 82355f0:	e0bff717 	ldw	r2,-36(fp)
 82355f4:	1080028b 	ldhu	r2,10(r2)
 82355f8:	10bfffcc 	andi	r2,r2,65535
 82355fc:	e0fffa17 	ldw	r3,-24(fp)
 8235600:	1880130e 	bge	r3,r2,8235650 <tcp_reass+0x260>
      {
         q->ti_seq += i;
 8235604:	e0bff717 	ldw	r2,-36(fp)
 8235608:	10c00617 	ldw	r3,24(r2)
 823560c:	e0bffa17 	ldw	r2,-24(fp)
 8235610:	1887883a 	add	r3,r3,r2
 8235614:	e0bff717 	ldw	r2,-36(fp)
 8235618:	10c00615 	stw	r3,24(r2)
         q->ti_len -= (u_short)i;
 823561c:	e0bff717 	ldw	r2,-36(fp)
 8235620:	1080028b 	ldhu	r2,10(r2)
 8235624:	e0fffa17 	ldw	r3,-24(fp)
 8235628:	10c5c83a 	sub	r2,r2,r3
 823562c:	1007883a 	mov	r3,r2
 8235630:	e0bff717 	ldw	r2,-36(fp)
 8235634:	10c0028d 	sth	r3,10(r2)
         m_adj (dtom(q), (int)i);
 8235638:	e13ff717 	ldw	r4,-36(fp)
 823563c:	822ea040 	call	822ea04 <dtom>
 8235640:	e17ffa17 	ldw	r5,-24(fp)
 8235644:	1009883a 	mov	r4,r2
 8235648:	822e7f00 	call	822e7f0 <m_adj>
         break;
 823564c:	00001306 	br	823569c <tcp_reass+0x2ac>
      }
      q = (struct tcpiphdr *)q->ti_next;
 8235650:	e0bff717 	ldw	r2,-36(fp)
 8235654:	10800017 	ldw	r2,0(r2)
 8235658:	e0bff715 	stw	r2,-36(fp)
      m = dtom(q->ti_prev);
 823565c:	e0bff717 	ldw	r2,-36(fp)
 8235660:	10800117 	ldw	r2,4(r2)
 8235664:	1009883a 	mov	r4,r2
 8235668:	822ea040 	call	822ea04 <dtom>
 823566c:	e0bffb15 	stw	r2,-20(fp)
      remque (q->ti_prev);
 8235670:	e0bff717 	ldw	r2,-36(fp)
 8235674:	10800117 	ldw	r2,4(r2)
 8235678:	1009883a 	mov	r4,r2
 823567c:	822eaa00 	call	822eaa0 <remque>
      m_freem (m);
 8235680:	e13ffb17 	ldw	r4,-20(fp)
 8235684:	822e4b80 	call	822e4b8 <m_freem>

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 8235688:	e0fff717 	ldw	r3,-36(fp)
 823568c:	e0bffd17 	ldw	r2,-12(fp)
 8235690:	18bfcb1e 	bne	r3,r2,82355c0 <tcp_reass+0x1d0>
 8235694:	00000106 	br	823569c <tcp_reass+0x2ac>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
      if (i <= 0)
         break;
 8235698:	0001883a 	nop
   }

   /*
    * Stick new segment in its place.
    */
   insque(ti, q->ti_prev);
 823569c:	e0bff717 	ldw	r2,-36(fp)
 82356a0:	10800117 	ldw	r2,4(r2)
 82356a4:	100b883a 	mov	r5,r2
 82356a8:	e13ffe17 	ldw	r4,-8(fp)
 82356ac:	822eb100 	call	822eb10 <insque>
 82356b0:	00000106 	br	82356b8 <tcp_reass+0x2c8>
   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
      goto present;
 82356b4:	0001883a 	nop
present:
   /*
    * Present data to user, advancing rcv_nxt through
    * completed sequence space.
    */
   if (TCPS_HAVERCVDSYN (tp->t_state) == 0)
 82356b8:	e0bffd17 	ldw	r2,-12(fp)
 82356bc:	10800217 	ldw	r2,8(r2)
 82356c0:	108000c8 	cmpgei	r2,r2,3
 82356c4:	1000021e 	bne	r2,zero,82356d0 <tcp_reass+0x2e0>
      return (0);
 82356c8:	0005883a 	mov	r2,zero
 82356cc:	00004706 	br	82357ec <tcp_reass+0x3fc>
   ti = tp->seg_next;
 82356d0:	e0bffd17 	ldw	r2,-12(fp)
 82356d4:	10800017 	ldw	r2,0(r2)
 82356d8:	e0bffe15 	stw	r2,-8(fp)
   if (ti == (struct tcpiphdr *)tp || ti->ti_seq != tp->rcv_nxt)
 82356dc:	e0fffe17 	ldw	r3,-8(fp)
 82356e0:	e0bffd17 	ldw	r2,-12(fp)
 82356e4:	18800526 	beq	r3,r2,82356fc <tcp_reass+0x30c>
 82356e8:	e0bffe17 	ldw	r2,-8(fp)
 82356ec:	10c00617 	ldw	r3,24(r2)
 82356f0:	e0bffd17 	ldw	r2,-12(fp)
 82356f4:	10801617 	ldw	r2,88(r2)
 82356f8:	18800226 	beq	r3,r2,8235704 <tcp_reass+0x314>
      return (0);
 82356fc:	0005883a 	mov	r2,zero
 8235700:	00003a06 	br	82357ec <tcp_reass+0x3fc>
   if (tp->t_state == TCPS_SYN_RECEIVED && ti->ti_len)
 8235704:	e0bffd17 	ldw	r2,-12(fp)
 8235708:	10800217 	ldw	r2,8(r2)
 823570c:	108000d8 	cmpnei	r2,r2,3
 8235710:	1000061e 	bne	r2,zero,823572c <tcp_reass+0x33c>
 8235714:	e0bffe17 	ldw	r2,-8(fp)
 8235718:	1080028b 	ldhu	r2,10(r2)
 823571c:	10bfffcc 	andi	r2,r2,65535
 8235720:	10000226 	beq	r2,zero,823572c <tcp_reass+0x33c>
      return (0);
 8235724:	0005883a 	mov	r2,zero
 8235728:	00003006 	br	82357ec <tcp_reass+0x3fc>
   do 
   {
      tp->rcv_nxt += ti->ti_len;
 823572c:	e0bffd17 	ldw	r2,-12(fp)
 8235730:	10c01617 	ldw	r3,88(r2)
 8235734:	e0bffe17 	ldw	r2,-8(fp)
 8235738:	1080028b 	ldhu	r2,10(r2)
 823573c:	10bfffcc 	andi	r2,r2,65535
 8235740:	1887883a 	add	r3,r3,r2
 8235744:	e0bffd17 	ldw	r2,-12(fp)
 8235748:	10c01615 	stw	r3,88(r2)
      flags = ti->ti_flags & TH_FIN;
 823574c:	e0bffe17 	ldw	r2,-8(fp)
 8235750:	10800843 	ldbu	r2,33(r2)
 8235754:	10803fcc 	andi	r2,r2,255
 8235758:	1080004c 	andi	r2,r2,1
 823575c:	e0bffc15 	stw	r2,-16(fp)
      remque(ti);
 8235760:	e13ffe17 	ldw	r4,-8(fp)
 8235764:	822eaa00 	call	822eaa0 <remque>
      m = dtom(ti);
 8235768:	e13ffe17 	ldw	r4,-8(fp)
 823576c:	822ea040 	call	822ea04 <dtom>
 8235770:	e0bffb15 	stw	r2,-20(fp)
      ti = (struct tcpiphdr *)ti->ti_next;
 8235774:	e0bffe17 	ldw	r2,-8(fp)
 8235778:	10800017 	ldw	r2,0(r2)
 823577c:	e0bffe15 	stw	r2,-8(fp)
      if (so->so_state & SS_CANTRCVMORE)
 8235780:	e0bff817 	ldw	r2,-32(fp)
 8235784:	1080088b 	ldhu	r2,34(r2)
 8235788:	10bfffcc 	andi	r2,r2,65535
 823578c:	1080080c 	andi	r2,r2,32
 8235790:	10000326 	beq	r2,zero,82357a0 <tcp_reass+0x3b0>
         m_freem (m);
 8235794:	e13ffb17 	ldw	r4,-20(fp)
 8235798:	822e4b80 	call	822e4b8 <m_freem>
 823579c:	00000506 	br	82357b4 <tcp_reass+0x3c4>
      else
         sbappend (&so->so_rcv, m);
 82357a0:	e0bff817 	ldw	r2,-32(fp)
 82357a4:	10800a04 	addi	r2,r2,40
 82357a8:	e17ffb17 	ldw	r5,-20(fp)
 82357ac:	1009883a 	mov	r4,r2
 82357b0:	82342740 	call	8234274 <sbappend>
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
 82357b4:	e0fffe17 	ldw	r3,-8(fp)
 82357b8:	e0bffd17 	ldw	r2,-12(fp)
 82357bc:	18800526 	beq	r3,r2,82357d4 <tcp_reass+0x3e4>
 82357c0:	e0bffe17 	ldw	r2,-8(fp)
 82357c4:	10c00617 	ldw	r3,24(r2)
 82357c8:	e0bffd17 	ldw	r2,-12(fp)
 82357cc:	10801617 	ldw	r2,88(r2)
 82357d0:	18bfd626 	beq	r3,r2,823572c <tcp_reass+0x33c>
      sorwakeup(so);
 82357d4:	e0bff817 	ldw	r2,-32(fp)
 82357d8:	10800a04 	addi	r2,r2,40
 82357dc:	100b883a 	mov	r5,r2
 82357e0:	e13ff817 	ldw	r4,-32(fp)
 82357e4:	82340c40 	call	82340c4 <sbwakeup>
   return (flags);
 82357e8:	e0bffc17 	ldw	r2,-16(fp)
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
   return (0);
}
 82357ec:	e037883a 	mov	sp,fp
 82357f0:	dfc00117 	ldw	ra,4(sp)
 82357f4:	df000017 	ldw	fp,0(sp)
 82357f8:	dec00204 	addi	sp,sp,8
 82357fc:	f800283a 	ret

08235800 <tcp_input>:
 * RETURNS: void
 */

void
tcp_input(struct mbuf * m, NET ifp)
{
 8235800:	deffdf04 	addi	sp,sp,-132
 8235804:	dfc02015 	stw	ra,128(sp)
 8235808:	df001f15 	stw	fp,124(sp)
 823580c:	df001f04 	addi	fp,sp,124
 8235810:	e13ffe15 	stw	r4,-8(fp)
 8235814:	e17fff15 	stw	r5,-4(fp)
   ip6_addr    ip6_src;
   ip6_addr    ip6_dst;
#endif   /* IP_V6 */
   struct tcpiphdr * ti;
   struct inpcb * inp;
   struct mbuf *  om =  0;
 8235818:	e03fe515 	stw	zero,-108(fp)
   int   len,  tlen, off;
   struct tcpcb * tp =  0;
 823581c:	e03fe615 	stw	zero,-104(fp)
   int   tiflags;
   struct socket *   so =  NULL;
 8235820:	e03fe815 	stw	zero,-96(fp)
   int   todrop,  acked,   ourfinisacked, needoutput  =  0;
 8235824:	e03feb15 	stw	zero,-84(fp)
   int   dropsocket  =  0;
 8235828:	e03fec15 	stw	zero,-80(fp)
   long  iss   =  0;
 823582c:	e03fed15 	stw	zero,-76(fp)
#ifdef DO_TCPTRACE
   int   ostate;
#endif


   tcpstat.tcps_rcvtotal++;
 8235830:	008209b4 	movhi	r2,2086
 8235834:	10b99404 	addi	r2,r2,-6576
 8235838:	10801917 	ldw	r2,100(r2)
 823583c:	10c00044 	addi	r3,r2,1
 8235840:	008209b4 	movhi	r2,2086
 8235844:	10b99404 	addi	r2,r2,-6576
 8235848:	10c01915 	stw	r3,100(r2)
   TCP_MIB_INC(tcpInSegs);    /* keep MIB stats */
 823584c:	008209b4 	movhi	r2,2086
 8235850:	10b96604 	addi	r2,r2,-6760
 8235854:	10800917 	ldw	r2,36(r2)
 8235858:	10c00044 	addi	r3,r2,1
 823585c:	008209b4 	movhi	r2,2086
 8235860:	10b96604 	addi	r2,r2,-6760
 8235864:	10c00915 	stw	r3,36(r2)
   {
      /*
       * Get IP and TCP header together in first mbuf.
       * Note: IP leaves IP header in first mbuf.
       */
      pip = mtod(m, struct ip *);
 8235868:	e0bffe17 	ldw	r2,-8(fp)
 823586c:	10800317 	ldw	r2,12(r2)
 8235870:	e0bfe315 	stw	r2,-116(fp)
      if (pip->ip_ver_ihl > 0x45)   /* IP v4, 5 dword hdr len */
 8235874:	e0bfe317 	ldw	r2,-116(fp)
 8235878:	10800003 	ldbu	r2,0(r2)
 823587c:	10803fcc 	andi	r2,r2,255
 8235880:	108011b0 	cmpltui	r2,r2,70
 8235884:	1000061e 	bne	r2,zero,82358a0 <tcp_input+0xa0>
      {
         np_stripoptions(pip, (struct mbuf *)m);
 8235888:	e17ffe17 	ldw	r5,-8(fp)
 823588c:	e13fe317 	ldw	r4,-116(fp)
 8235890:	822f43c0 	call	822f43c <np_stripoptions>
         pip = mtod(m, struct ip *);
 8235894:	e0bffe17 	ldw	r2,-8(fp)
 8235898:	10800317 	ldw	r2,12(r2)
 823589c:	e0bfe315 	stw	r2,-116(fp)
      }
      if (m->m_len < ((sizeof (struct ip) + sizeof (struct tcphdr))))
 82358a0:	e0bffe17 	ldw	r2,-8(fp)
 82358a4:	10800217 	ldw	r2,8(r2)
 82358a8:	10800a28 	cmpgeui	r2,r2,40
 82358ac:	1000081e 	bne	r2,zero,82358d0 <tcp_input+0xd0>
      {
         tcpstat.tcps_rcvshort++;
 82358b0:	008209b4 	movhi	r2,2086
 82358b4:	10b99404 	addi	r2,r2,-6576
 82358b8:	10801e17 	ldw	r2,120(r2)
 82358bc:	10c00044 	addi	r3,r2,1
 82358c0:	008209b4 	movhi	r2,2086
 82358c4:	10b99404 	addi	r2,r2,-6576
 82358c8:	10c01e15 	stw	r3,120(r2)
         return;
 82358cc:	00089306 	br	8237b1c <tcp_input+0x231c>
      }
      tlen = pip->ip_len;     /* this was fudged by IP layer */
 82358d0:	e0bfe317 	ldw	r2,-116(fp)
 82358d4:	1080008b 	ldhu	r2,2(r2)
 82358d8:	10bfffcc 	andi	r2,r2,65535
 82358dc:	e0bff115 	stw	r2,-60(fp)
      /* The following is needed in the cases where the size of the
       * overlay structure is larger than the size of the ip header.
       * This can happen if the ih_next and ih_prev pointers in the
       * overlay structure are larger than 32 bit pointers.
       */
      ti = (struct tcpiphdr *)(m->m_data + sizeof(struct ip) - 
 82358e0:	e0bffe17 	ldw	r2,-8(fp)
 82358e4:	10800317 	ldw	r2,12(r2)
 82358e8:	e0bff215 	stw	r2,-56(fp)
         sizeof(struct ipovly));
      if ((char *)ti < m->pkt->nb_buff)
 82358ec:	e0bffe17 	ldw	r2,-8(fp)
 82358f0:	10800117 	ldw	r2,4(r2)
 82358f4:	10800117 	ldw	r2,4(r2)
 82358f8:	e0fff217 	ldw	r3,-56(fp)
 82358fc:	1880032e 	bgeu	r3,r2,823590c <tcp_input+0x10c>
      {
         panic("tcp_input");
 8235900:	01020974 	movhi	r4,2085
 8235904:	2103a304 	addi	r4,r4,3724
 8235908:	8228aec0 	call	8228aec <panic>
   /*
    * Check that TCP offset makes sense,
    * pull out TCP options and adjust length.
    */

   off = GET_TH_OFF(ti->ti_t) << 2;
 823590c:	e0bff217 	ldw	r2,-56(fp)
 8235910:	10800803 	ldbu	r2,32(r2)
 8235914:	10803fcc 	andi	r2,r2,255
 8235918:	1004d13a 	srli	r2,r2,4
 823591c:	10803fcc 	andi	r2,r2,255
 8235920:	1085883a 	add	r2,r2,r2
 8235924:	1085883a 	add	r2,r2,r2
 8235928:	e0bff315 	stw	r2,-52(fp)
   if (off < sizeof (struct tcphdr) || off > tlen) 
 823592c:	e0bff317 	ldw	r2,-52(fp)
 8235930:	10800530 	cmpltui	r2,r2,20
 8235934:	1000031e 	bne	r2,zero,8235944 <tcp_input+0x144>
 8235938:	e0bff317 	ldw	r2,-52(fp)
 823593c:	e0fff117 	ldw	r3,-60(fp)
 8235940:	1880110e 	bge	r3,r2,8235988 <tcp_input+0x188>
   {
#ifdef DO_TCPTRACE
      tcp_trace("tcp off: src %x off %d\n", ti->ti_src, off);
#endif
      tcpstat.tcps_rcvbadoff++;
 8235944:	008209b4 	movhi	r2,2086
 8235948:	10b99404 	addi	r2,r2,-6576
 823594c:	10801d17 	ldw	r2,116(r2)
 8235950:	10c00044 	addi	r3,r2,1
 8235954:	008209b4 	movhi	r2,2086
 8235958:	10b99404 	addi	r2,r2,-6576
 823595c:	10c01d15 	stw	r3,116(r2)
      TCP_MIB_INC(tcpInErrs);   /* keep MIB stats */
 8235960:	008209b4 	movhi	r2,2086
 8235964:	10b96604 	addi	r2,r2,-6760
 8235968:	10800d17 	ldw	r2,52(r2)
 823596c:	10c00044 	addi	r3,r2,1
 8235970:	008209b4 	movhi	r2,2086
 8235974:	10b96604 	addi	r2,r2,-6760
 8235978:	10c00d15 	stw	r3,52(r2)
      GOTO_DROP;
 823597c:	00805784 	movi	r2,350
 8235980:	d0a0b215 	stw	r2,-32056(gp)
 8235984:	00085006 	br	8237ac8 <tcp_input+0x22c8>
   }
   tlen -= (int)off;
 8235988:	e0fff117 	ldw	r3,-60(fp)
 823598c:	e0bff317 	ldw	r2,-52(fp)
 8235990:	1885c83a 	sub	r2,r3,r2
 8235994:	e0bff115 	stw	r2,-60(fp)
   ti->ti_len = (u_short)tlen;
 8235998:	e0bff117 	ldw	r2,-60(fp)
 823599c:	1007883a 	mov	r3,r2
 82359a0:	e0bff217 	ldw	r2,-56(fp)
 82359a4:	10c0028d 	sth	r3,10(r2)
   if (off > sizeof (struct tcphdr)) 
 82359a8:	e0bff317 	ldw	r2,-52(fp)
 82359ac:	10800570 	cmpltui	r2,r2,21
 82359b0:	1000331e 	bne	r2,zero,8235a80 <tcp_input+0x280>
   {
      int olen;      /* length of options field */
      u_char * op;   /* scratch option pointer */

      olen = off - sizeof (struct tcphdr);   /* get options length */
 82359b4:	e0bff317 	ldw	r2,-52(fp)
 82359b8:	10bffb04 	addi	r2,r2,-20
 82359bc:	e0bff415 	stw	r2,-48(fp)
      om = m_getwithdata (MT_RXDATA, olen);  /* get mbuf for opts */
 82359c0:	e17ff417 	ldw	r5,-48(fp)
 82359c4:	01000044 	movi	r4,1
 82359c8:	822e2280 	call	822e228 <m_getnbuf>
 82359cc:	e0bfe515 	stw	r2,-108(fp)
      if (om == 0)
 82359d0:	e0bfe517 	ldw	r2,-108(fp)
 82359d4:	1000031e 	bne	r2,zero,82359e4 <tcp_input+0x1e4>
         GOTO_DROP;
 82359d8:	00805a84 	movi	r2,362
 82359dc:	d0a0b215 	stw	r2,-32056(gp)
 82359e0:	00083906 	br	8237ac8 <tcp_input+0x22c8>
      om->m_len = olen;       /* set mbuf length */
 82359e4:	e0fff417 	ldw	r3,-48(fp)
 82359e8:	e0bfe517 	ldw	r2,-108(fp)
 82359ec:	10c00215 	stw	r3,8(r2)
      /* set pointer to options field at end of TCP header */
      if(m->pkt->type == htons(0x86DD))   /* IPv6 packet */
 82359f0:	e0bffe17 	ldw	r2,-8(fp)
 82359f4:	10800117 	ldw	r2,4(r2)
 82359f8:	1080080b 	ldhu	r2,32(r2)
 82359fc:	10ffffcc 	andi	r3,r2,65535
 8235a00:	00b76194 	movui	r2,56710
 8235a04:	1880051e 	bne	r3,r2,8235a1c <tcp_input+0x21c>
         op = (u_char*)(m->m_data + 20);  /* past TCP header */
 8235a08:	e0bffe17 	ldw	r2,-8(fp)
 8235a0c:	10800317 	ldw	r2,12(r2)
 8235a10:	10800504 	addi	r2,r2,20
 8235a14:	e0bfee15 	stw	r2,-72(fp)
 8235a18:	00000406 	br	8235a2c <tcp_input+0x22c>
      else
         op = (u_char*)(m->m_data + 40);  /* past IP + TCP */
 8235a1c:	e0bffe17 	ldw	r2,-8(fp)
 8235a20:	10800317 	ldw	r2,12(r2)
 8235a24:	10800a04 	addi	r2,r2,40
 8235a28:	e0bfee15 	stw	r2,-72(fp)
      MEMCPY(om->m_data, op, olen); /* copy to new mbuf */
 8235a2c:	e0bfe517 	ldw	r2,-108(fp)
 8235a30:	10800317 	ldw	r2,12(r2)
 8235a34:	e0fff417 	ldw	r3,-48(fp)
 8235a38:	180d883a 	mov	r6,r3
 8235a3c:	e17fee17 	ldw	r5,-72(fp)
 8235a40:	1009883a 	mov	r4,r2
 8235a44:	8202e8c0 	call	8202e8c <memcpy>

      /* strip options from data mbuf. This actually just cuts the first 
       * m_len bytes from the TCP header, but it leaves the mbuf members 
       * set so the adjustment below does the right thing.
       */
      m->m_data += om->m_len;
 8235a48:	e0bffe17 	ldw	r2,-8(fp)
 8235a4c:	10c00317 	ldw	r3,12(r2)
 8235a50:	e0bfe517 	ldw	r2,-108(fp)
 8235a54:	10800217 	ldw	r2,8(r2)
 8235a58:	1887883a 	add	r3,r3,r2
 8235a5c:	e0bffe17 	ldw	r2,-8(fp)
 8235a60:	10c00315 	stw	r3,12(r2)
      m->m_len -= om->m_len;
 8235a64:	e0bffe17 	ldw	r2,-8(fp)
 8235a68:	10c00217 	ldw	r3,8(r2)
 8235a6c:	e0bfe517 	ldw	r2,-108(fp)
 8235a70:	10800217 	ldw	r2,8(r2)
 8235a74:	1887c83a 	sub	r3,r3,r2
 8235a78:	e0bffe17 	ldw	r2,-8(fp)
 8235a7c:	10c00215 	stw	r3,8(r2)
   }
   tiflags = ti->ti_flags;
 8235a80:	e0bff217 	ldw	r2,-56(fp)
 8235a84:	10800843 	ldbu	r2,33(r2)
 8235a88:	10803fcc 	andi	r2,r2,255
 8235a8c:	e0bfe715 	stw	r2,-100(fp)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   /* Convert TCP protocol specific fields to host format. */
   ti->ti_seq = ntohl(ti->ti_seq);
 8235a90:	e0bff217 	ldw	r2,-56(fp)
 8235a94:	10800617 	ldw	r2,24(r2)
 8235a98:	1006d63a 	srli	r3,r2,24
 8235a9c:	e0bff217 	ldw	r2,-56(fp)
 8235aa0:	10800617 	ldw	r2,24(r2)
 8235aa4:	1004d23a 	srli	r2,r2,8
 8235aa8:	10bfc00c 	andi	r2,r2,65280
 8235aac:	1886b03a 	or	r3,r3,r2
 8235ab0:	e0bff217 	ldw	r2,-56(fp)
 8235ab4:	10800617 	ldw	r2,24(r2)
 8235ab8:	10bfc00c 	andi	r2,r2,65280
 8235abc:	1004923a 	slli	r2,r2,8
 8235ac0:	1886b03a 	or	r3,r3,r2
 8235ac4:	e0bff217 	ldw	r2,-56(fp)
 8235ac8:	10800617 	ldw	r2,24(r2)
 8235acc:	1004963a 	slli	r2,r2,24
 8235ad0:	1886b03a 	or	r3,r3,r2
 8235ad4:	e0bff217 	ldw	r2,-56(fp)
 8235ad8:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = ntohl(ti->ti_ack);
 8235adc:	e0bff217 	ldw	r2,-56(fp)
 8235ae0:	10800717 	ldw	r2,28(r2)
 8235ae4:	1006d63a 	srli	r3,r2,24
 8235ae8:	e0bff217 	ldw	r2,-56(fp)
 8235aec:	10800717 	ldw	r2,28(r2)
 8235af0:	1004d23a 	srli	r2,r2,8
 8235af4:	10bfc00c 	andi	r2,r2,65280
 8235af8:	1886b03a 	or	r3,r3,r2
 8235afc:	e0bff217 	ldw	r2,-56(fp)
 8235b00:	10800717 	ldw	r2,28(r2)
 8235b04:	10bfc00c 	andi	r2,r2,65280
 8235b08:	1004923a 	slli	r2,r2,8
 8235b0c:	1886b03a 	or	r3,r3,r2
 8235b10:	e0bff217 	ldw	r2,-56(fp)
 8235b14:	10800717 	ldw	r2,28(r2)
 8235b18:	1004963a 	slli	r2,r2,24
 8235b1c:	1886b03a 	or	r3,r3,r2
 8235b20:	e0bff217 	ldw	r2,-56(fp)
 8235b24:	10c00715 	stw	r3,28(r2)
   ti->ti_urp = ntohs(ti->ti_urp);
 8235b28:	e0bff217 	ldw	r2,-56(fp)
 8235b2c:	1080098b 	ldhu	r2,38(r2)
 8235b30:	10bfffcc 	andi	r2,r2,65535
 8235b34:	1004d23a 	srli	r2,r2,8
 8235b38:	1007883a 	mov	r3,r2
 8235b3c:	e0bff217 	ldw	r2,-56(fp)
 8235b40:	1080098b 	ldhu	r2,38(r2)
 8235b44:	10bfffcc 	andi	r2,r2,65535
 8235b48:	1004923a 	slli	r2,r2,8
 8235b4c:	1884b03a 	or	r2,r3,r2
 8235b50:	1007883a 	mov	r3,r2
 8235b54:	e0bff217 	ldw	r2,-56(fp)
 8235b58:	10c0098d 	sth	r3,38(r2)
   /*
    * Locate pcb for segment.
    */
findpcb:

   switch(m->pkt->type)
 8235b5c:	e0bffe17 	ldw	r2,-8(fp)
 8235b60:	10800117 	ldw	r2,4(r2)
 8235b64:	1080080b 	ldhu	r2,32(r2)
 8235b68:	10bfffcc 	andi	r2,r2,65535
 8235b6c:	10800220 	cmpeqi	r2,r2,8
 8235b70:	10002226 	beq	r2,zero,8235bfc <tcp_input+0x3fc>
   {
#ifdef IP_V4
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
 8235b74:	e0bffe17 	ldw	r2,-8(fp)
 8235b78:	10800317 	ldw	r2,12(r2)
 8235b7c:	10c00a04 	addi	r3,r2,40
 8235b80:	e0bffe17 	ldw	r2,-8(fp)
 8235b84:	10c00315 	stw	r3,12(r2)
      m->m_len -= 40;
 8235b88:	e0bffe17 	ldw	r2,-8(fp)
 8235b8c:	10800217 	ldw	r2,8(r2)
 8235b90:	10fff604 	addi	r3,r2,-40
 8235b94:	e0bffe17 	ldw	r2,-8(fp)
 8235b98:	10c00215 	stw	r3,8(r2)

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 8235b9c:	e0bff217 	ldw	r2,-56(fp)
 8235ba0:	11000317 	ldw	r4,12(r2)
 8235ba4:	e0bff217 	ldw	r2,-56(fp)
 8235ba8:	1080050b 	ldhu	r2,20(r2)
 8235bac:	117fffcc 	andi	r5,r2,65535
 8235bb0:	e0bff217 	ldw	r2,-56(fp)
 8235bb4:	11800417 	ldw	r6,16(r2)
         ti->ti_dst.s_addr, ti->ti_dport, INPLOOKUP_WILDCARD);
 8235bb8:	e0bff217 	ldw	r2,-56(fp)
 8235bbc:	1080058b 	ldhu	r2,22(r2)
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
      m->m_len -= 40;

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 8235bc0:	10bfffcc 	andi	r2,r2,65535
 8235bc4:	00c00044 	movi	r3,1
 8235bc8:	d8c00115 	stw	r3,4(sp)
 8235bcc:	d8800015 	stw	r2,0(sp)
 8235bd0:	300f883a 	mov	r7,r6
 8235bd4:	280d883a 	mov	r6,r5
 8235bd8:	200b883a 	mov	r5,r4
 8235bdc:	010209b4 	movhi	r4,2086
 8235be0:	21398904 	addi	r4,r4,-6620
 8235be4:	82482bc0 	call	82482bc <in_pcblookup>
 8235be8:	e0bfe415 	stw	r2,-112(fp)
         ti->ti_dst.s_addr, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
 8235bec:	0001883a 	nop
    * If the state is CLOSED (i.e., TCB does not exist) then
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
 8235bf0:	e0bfe417 	ldw	r2,-112(fp)
 8235bf4:	1000061e 	bne	r2,zero,8235c10 <tcp_input+0x410>
 8235bf8:	00000206 	br	8235c04 <tcp_input+0x404>
      inp = ip6_pcblookup(&tcb, &ip6_src, ti->ti_sport, 
         &ip6_dst, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
#endif   /* IP_V6 */
   default:
      dtrap();
 8235bfc:	822d4140 	call	822d414 <dtrap>
      return;
 8235c00:	0007c606 	br	8237b1c <tcp_input+0x231c>
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
      GOTO_DROPWITHRESET;
 8235c04:	00806b04 	movi	r2,428
 8235c08:	d0a0b215 	stw	r2,-32056(gp)
 8235c0c:	00076d06 	br	82379c4 <tcp_input+0x21c4>
   tp = intotcpcb (inp);
 8235c10:	e0bfe417 	ldw	r2,-112(fp)
 8235c14:	10800917 	ldw	r2,36(r2)
 8235c18:	e0bfe615 	stw	r2,-104(fp)
   if (tp == 0)
 8235c1c:	e0bfe617 	ldw	r2,-104(fp)
 8235c20:	1000031e 	bne	r2,zero,8235c30 <tcp_input+0x430>
      GOTO_DROPWITHRESET;
 8235c24:	00806bc4 	movi	r2,431
 8235c28:	d0a0b215 	stw	r2,-32056(gp)
 8235c2c:	00076506 	br	82379c4 <tcp_input+0x21c4>
   if (tp->t_state == TCPS_CLOSED)
 8235c30:	e0bfe617 	ldw	r2,-104(fp)
 8235c34:	10800217 	ldw	r2,8(r2)
 8235c38:	1000031e 	bne	r2,zero,8235c48 <tcp_input+0x448>
      GOTO_DROP;
 8235c3c:	00806c44 	movi	r2,433
 8235c40:	d0a0b215 	stw	r2,-32056(gp)
 8235c44:	0007a006 	br	8237ac8 <tcp_input+0x22c8>
   so = inp->inp_socket;
 8235c48:	e0bfe417 	ldw	r2,-112(fp)
 8235c4c:	10800817 	ldw	r2,32(r2)
 8235c50:	e0bfe815 	stw	r2,-96(fp)
      tcp_saveti = *ti;
   }
#endif

   /* figure out the size of the other guy's receive window */
   rx_win = (tcp_win)(ntohs(ti->ti_win));    /* convert endian */
 8235c54:	e0bff217 	ldw	r2,-56(fp)
 8235c58:	1080088b 	ldhu	r2,34(r2)
 8235c5c:	10bfffcc 	andi	r2,r2,65535
 8235c60:	1004d23a 	srli	r2,r2,8
 8235c64:	10bfffcc 	andi	r2,r2,65535
 8235c68:	10c03fcc 	andi	r3,r2,255
 8235c6c:	e0bff217 	ldw	r2,-56(fp)
 8235c70:	1080088b 	ldhu	r2,34(r2)
 8235c74:	10bfffcc 	andi	r2,r2,65535
 8235c78:	1004923a 	slli	r2,r2,8
 8235c7c:	10bfffcc 	andi	r2,r2,65535
 8235c80:	1884b03a 	or	r2,r3,r2
 8235c84:	e0bff515 	stw	r2,-44(fp)
   {
      rx_win <<= tp->snd_wind_scale;         /* apply scale */
   }
#endif /* TCP_WIN_SCALE */

   if (so->so_options & SO_ACCEPTCONN) 
 8235c88:	e0bfe817 	ldw	r2,-96(fp)
 8235c8c:	10800417 	ldw	r2,16(r2)
 8235c90:	1080008c 	andi	r2,r2,2
 8235c94:	10002c26 	beq	r2,zero,8235d48 <tcp_input+0x548>
   {
      so = sonewconn(so);
 8235c98:	e13fe817 	ldw	r4,-96(fp)
 8235c9c:	8233bb80 	call	8233bb8 <sonewconn>
 8235ca0:	e0bfe815 	stw	r2,-96(fp)
      if (so == 0)
 8235ca4:	e0bfe817 	ldw	r2,-96(fp)
 8235ca8:	1000031e 	bne	r2,zero,8235cb8 <tcp_input+0x4b8>
         GOTO_DROP;
 8235cac:	00807344 	movi	r2,461
 8235cb0:	d0a0b215 	stw	r2,-32056(gp)
 8235cb4:	00078406 	br	8237ac8 <tcp_input+0x22c8>
       * flag dropsocket to see if the temporary
       * socket created here should be discarded.
       * We mark the socket as discardable until
       * we're committed to it below in TCPS_LISTEN.
       */
      dropsocket++;
 8235cb8:	e0bfec17 	ldw	r2,-80(fp)
 8235cbc:	10800044 	addi	r2,r2,1
 8235cc0:	e0bfec15 	stw	r2,-80(fp)

      inp = (struct inpcb *)so->so_pcb;
 8235cc4:	e0bfe817 	ldw	r2,-96(fp)
 8235cc8:	10800117 	ldw	r2,4(r2)
 8235ccc:	e0bfe415 	stw	r2,-112(fp)
      inp->ifp = ifp;      /* save iface to peer */
 8235cd0:	e0bfe417 	ldw	r2,-112(fp)
 8235cd4:	e0ffff17 	ldw	r3,-4(fp)
 8235cd8:	10c00a15 	stw	r3,40(r2)

      switch(so->so_domain)
 8235cdc:	e0bfe817 	ldw	r2,-96(fp)
 8235ce0:	10800517 	ldw	r2,20(r2)
 8235ce4:	108000a0 	cmpeqi	r2,r2,2
 8235ce8:	10000d26 	beq	r2,zero,8235d20 <tcp_input+0x520>
      {
#ifdef IP_V4
      case AF_INET:
         inp->inp_laddr = ti->ti_dst;
 8235cec:	e0bfe417 	ldw	r2,-112(fp)
 8235cf0:	e0fff217 	ldw	r3,-56(fp)
 8235cf4:	18c00417 	ldw	r3,16(r3)
 8235cf8:	10c00415 	stw	r3,16(r2)
#ifdef IP_PMTU
         inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
         inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 8235cfc:	e0bfff17 	ldw	r2,-4(fp)
 8235d00:	10c00917 	ldw	r3,36(r2)
 8235d04:	e0bfff17 	ldw	r2,-4(fp)
 8235d08:	10800817 	ldw	r2,32(r2)
 8235d0c:	10800a04 	addi	r2,r2,40
 8235d10:	1887c83a 	sub	r3,r3,r2
 8235d14:	e0bfe417 	ldw	r2,-112(fp)
 8235d18:	10c00615 	stw	r3,24(r2)
#endif   /* IP_PMTU */
         break;
 8235d1c:	0001883a 	nop
         inp->inp_pmtu = ip6_pmtulookup(&ip6_src, ifp);
         break;
#endif   /* end v6 */
      }

      inp->inp_lport = ti->ti_dport;
 8235d20:	e0bff217 	ldw	r2,-56(fp)
 8235d24:	10c0058b 	ldhu	r3,22(r2)
 8235d28:	e0bfe417 	ldw	r2,-112(fp)
 8235d2c:	10c0078d 	sth	r3,30(r2)
      tp = intotcpcb(inp);
 8235d30:	e0bfe417 	ldw	r2,-112(fp)
 8235d34:	10800917 	ldw	r2,36(r2)
 8235d38:	e0bfe615 	stw	r2,-104(fp)
      tp->t_state = TCPS_LISTEN;
 8235d3c:	e0bfe617 	ldw	r2,-104(fp)
 8235d40:	00c00044 	movi	r3,1
 8235d44:	10c00215 	stw	r3,8(r2)

   /*
    * Segment received on connection.
    * Reset idle time and keep-alive timer.
    */
   tp->t_idle = 0;
 8235d48:	e0bfe617 	ldw	r2,-104(fp)
 8235d4c:	10001d15 	stw	zero,116(r2)
   tp->t_timer[TCPT_KEEP] = tcp_keepidle;
 8235d50:	d0e03e17 	ldw	r3,-32520(gp)
 8235d54:	e0bfe617 	ldw	r2,-104(fp)
 8235d58:	10c00515 	stw	r3,20(r2)

   /*
    * Process options if not in LISTEN state,
    * else do it below (after getting remote address).
    */
   if (om && tp->t_state != TCPS_LISTEN) 
 8235d5c:	e0bfe517 	ldw	r2,-108(fp)
 8235d60:	10000926 	beq	r2,zero,8235d88 <tcp_input+0x588>
 8235d64:	e0bfe617 	ldw	r2,-104(fp)
 8235d68:	10800217 	ldw	r2,8(r2)
 8235d6c:	10800060 	cmpeqi	r2,r2,1
 8235d70:	1000051e 	bne	r2,zero,8235d88 <tcp_input+0x588>
   {
      tcp_dooptions(tp, om, ti);
 8235d74:	e1bff217 	ldw	r6,-56(fp)
 8235d78:	e17fe517 	ldw	r5,-108(fp)
 8235d7c:	e13fe617 	ldw	r4,-104(fp)
 8235d80:	8237b300 	call	8237b30 <tcp_dooptions>
      om = 0;
 8235d84:	e03fe515 	stw	zero,-108(fp)
   }

   acked = (int)(ti->ti_ack - tp->snd_una);
 8235d88:	e0bff217 	ldw	r2,-56(fp)
 8235d8c:	10c00717 	ldw	r3,28(r2)
 8235d90:	e0bfe617 	ldw	r2,-104(fp)
 8235d94:	10800e17 	ldw	r2,56(r2)
 8235d98:	1885c83a 	sub	r2,r3,r2
 8235d9c:	e0bff615 	stw	r2,-40(fp)
    * Receive window is amount of space in rcv queue,
    * but not less than advertised window.
    */
   { long win;

      win = (long)sbspace(&so->so_rcv);
 8235da0:	e0bfe817 	ldw	r2,-96(fp)
 8235da4:	10800b17 	ldw	r2,44(r2)
 8235da8:	1007883a 	mov	r3,r2
 8235dac:	e0bfe817 	ldw	r2,-96(fp)
 8235db0:	10800a17 	ldw	r2,40(r2)
 8235db4:	1885c83a 	sub	r2,r3,r2
 8235db8:	10000616 	blt	r2,zero,8235dd4 <tcp_input+0x5d4>
 8235dbc:	e0bfe817 	ldw	r2,-96(fp)
 8235dc0:	10c00b17 	ldw	r3,44(r2)
 8235dc4:	e0bfe817 	ldw	r2,-96(fp)
 8235dc8:	10800a17 	ldw	r2,40(r2)
 8235dcc:	1885c83a 	sub	r2,r3,r2
 8235dd0:	00000106 	br	8235dd8 <tcp_input+0x5d8>
 8235dd4:	0005883a 	mov	r2,zero
 8235dd8:	e0bfef15 	stw	r2,-68(fp)
      if (win < 0)
 8235ddc:	e0bfef17 	ldw	r2,-68(fp)
 8235de0:	1000010e 	bge	r2,zero,8235de8 <tcp_input+0x5e8>
         win = 0;
 8235de4:	e03fef15 	stw	zero,-68(fp)
      tp->rcv_wnd = (tcp_win)MAX((u_long)win, (tp->rcv_adv - tp->rcv_nxt));
 8235de8:	e0bfe617 	ldw	r2,-104(fp)
 8235dec:	10c01917 	ldw	r3,100(r2)
 8235df0:	e0bfe617 	ldw	r2,-104(fp)
 8235df4:	10801617 	ldw	r2,88(r2)
 8235df8:	1885c83a 	sub	r2,r3,r2
 8235dfc:	e0ffef17 	ldw	r3,-68(fp)
 8235e00:	10c0012e 	bgeu	r2,r3,8235e08 <tcp_input+0x608>
 8235e04:	1805883a 	mov	r2,r3
 8235e08:	e0ffe617 	ldw	r3,-104(fp)
 8235e0c:	18801515 	stw	r2,84(r3)
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 8235e10:	e0bfe617 	ldw	r2,-104(fp)
 8235e14:	10800217 	ldw	r2,8(r2)
 8235e18:	10800118 	cmpnei	r2,r2,4
 8235e1c:	1001021e 	bne	r2,zero,8236228 <tcp_input+0xa28>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
 8235e20:	e0bfe717 	ldw	r2,-100(fp)
 8235e24:	10800dcc 	andi	r2,r2,55
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 8235e28:	10800418 	cmpnei	r2,r2,16
 8235e2c:	1000fe1e 	bne	r2,zero,8236228 <tcp_input+0xa28>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
 8235e30:	e0bff217 	ldw	r2,-56(fp)
 8235e34:	10c00617 	ldw	r3,24(r2)
 8235e38:	e0bfe617 	ldw	r2,-104(fp)
 8235e3c:	10801617 	ldw	r2,88(r2)
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
 8235e40:	1880f91e 	bne	r3,r2,8236228 <tcp_input+0xa28>
       (ti->ti_seq == tp->rcv_nxt) &&
 8235e44:	e0bff517 	ldw	r2,-44(fp)
 8235e48:	1000f726 	beq	r2,zero,8236228 <tcp_input+0xa28>
       (rx_win && rx_win == tp->snd_wnd) &&
 8235e4c:	e0bfe617 	ldw	r2,-104(fp)
 8235e50:	10c01417 	ldw	r3,80(r2)
 8235e54:	e0bff517 	ldw	r2,-44(fp)
 8235e58:	1880f31e 	bne	r3,r2,8236228 <tcp_input+0xa28>
       (tp->snd_nxt == tp->snd_max))
 8235e5c:	e0bfe617 	ldw	r2,-104(fp)
 8235e60:	10c00f17 	ldw	r3,60(r2)
 8235e64:	e0bfe617 	ldw	r2,-104(fp)
 8235e68:	10801a17 	ldw	r2,104(r2)
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
       (rx_win && rx_win == tp->snd_wnd) &&
 8235e6c:	1880ee1e 	bne	r3,r2,8236228 <tcp_input+0xa28>
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
 8235e70:	e0bff217 	ldw	r2,-56(fp)
 8235e74:	1080028b 	ldhu	r2,10(r2)
 8235e78:	10bfffcc 	andi	r2,r2,65535
 8235e7c:	1000611e 	bne	r2,zero,8236004 <tcp_input+0x804>
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 8235e80:	e0bff217 	ldw	r2,-56(fp)
 8235e84:	10c00717 	ldw	r3,28(r2)
 8235e88:	e0bfe617 	ldw	r2,-104(fp)
 8235e8c:	10800e17 	ldw	r2,56(r2)
 8235e90:	1885c83a 	sub	r2,r3,r2
 8235e94:	0080e40e 	bge	zero,r2,8236228 <tcp_input+0xa28>
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
 8235e98:	e0bff217 	ldw	r2,-56(fp)
 8235e9c:	10c00717 	ldw	r3,28(r2)
 8235ea0:	e0bfe617 	ldw	r2,-104(fp)
 8235ea4:	10801a17 	ldw	r2,104(r2)
 8235ea8:	1885c83a 	sub	r2,r3,r2
       (rx_win && rx_win == tp->snd_wnd) &&
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 8235eac:	0080de16 	blt	zero,r2,8236228 <tcp_input+0xa28>
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
             tp->snd_cwnd >= tp->snd_wnd) 
 8235eb0:	e0bfe617 	ldw	r2,-104(fp)
 8235eb4:	10c01b17 	ldw	r3,108(r2)
 8235eb8:	e0bfe617 	ldw	r2,-104(fp)
 8235ebc:	10801417 	ldw	r2,80(r2)
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
 8235ec0:	1880d936 	bltu	r3,r2,8236228 <tcp_input+0xa28>
             tp->snd_cwnd >= tp->snd_wnd) 
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
 8235ec4:	008209b4 	movhi	r2,2086
 8235ec8:	10b99404 	addi	r2,r2,-6576
 8235ecc:	10803517 	ldw	r2,212(r2)
 8235ed0:	10c00044 	addi	r3,r2,1
 8235ed4:	008209b4 	movhi	r2,2086
 8235ed8:	10b99404 	addi	r2,r2,-6576
 8235edc:	10c03515 	stw	r3,212(r2)
            if (tp->t_rttick && 
 8235ee0:	e0bfe617 	ldw	r2,-104(fp)
 8235ee4:	10801e17 	ldw	r2,120(r2)
 8235ee8:	10000826 	beq	r2,zero,8235f0c <tcp_input+0x70c>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
 8235eec:	e0bff217 	ldw	r2,-56(fp)
 8235ef0:	10c00717 	ldw	r3,28(r2)
 8235ef4:	e0bfe617 	ldw	r2,-104(fp)
 8235ef8:	10801f17 	ldw	r2,124(r2)
 8235efc:	1885c83a 	sub	r2,r3,r2
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
            if (tp->t_rttick && 
 8235f00:	0080020e 	bge	zero,r2,8235f0c <tcp_input+0x70c>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
            {
               tcp_xmit_timer(tp);
 8235f04:	e13fe617 	ldw	r4,-104(fp)
 8235f08:	8237de40 	call	8237de4 <tcp_xmit_timer>
            }

            tcpstat.tcps_rcvackpack++;
 8235f0c:	008209b4 	movhi	r2,2086
 8235f10:	10b99404 	addi	r2,r2,-6576
 8235f14:	10802b17 	ldw	r2,172(r2)
 8235f18:	10c00044 	addi	r3,r2,1
 8235f1c:	008209b4 	movhi	r2,2086
 8235f20:	10b99404 	addi	r2,r2,-6576
 8235f24:	10c02b15 	stw	r3,172(r2)
            tcpstat.tcps_rcvackbyte += acked;
 8235f28:	008209b4 	movhi	r2,2086
 8235f2c:	10b99404 	addi	r2,r2,-6576
 8235f30:	10c02c17 	ldw	r3,176(r2)
 8235f34:	e0bff617 	ldw	r2,-40(fp)
 8235f38:	1887883a 	add	r3,r3,r2
 8235f3c:	008209b4 	movhi	r2,2086
 8235f40:	10b99404 	addi	r2,r2,-6576
 8235f44:	10c02c15 	stw	r3,176(r2)
            sbdrop(&so->so_snd, acked);
 8235f48:	e0bfe817 	ldw	r2,-96(fp)
 8235f4c:	10801204 	addi	r2,r2,72
 8235f50:	e17ff617 	ldw	r5,-40(fp)
 8235f54:	1009883a 	mov	r4,r2
 8235f58:	823482c0 	call	823482c <sbdrop>
            tp->snd_una = ti->ti_ack;
 8235f5c:	e0bff217 	ldw	r2,-56(fp)
 8235f60:	10c00717 	ldw	r3,28(r2)
 8235f64:	e0bfe617 	ldw	r2,-104(fp)
 8235f68:	10c00e15 	stw	r3,56(r2)
            m_freem(m);
 8235f6c:	e13ffe17 	ldw	r4,-8(fp)
 8235f70:	822e4b80 	call	822e4b8 <m_freem>
             * If process is waiting for space,
             * wakeup/selwakeup/signal.  If data
             * are ready to send, let tcp_output
             * decide between more output or persist.
             */
            if (tp->snd_una == tp->snd_max)
 8235f74:	e0bfe617 	ldw	r2,-104(fp)
 8235f78:	10c00e17 	ldw	r3,56(r2)
 8235f7c:	e0bfe617 	ldw	r2,-104(fp)
 8235f80:	10801a17 	ldw	r2,104(r2)
 8235f84:	1880031e 	bne	r3,r2,8235f94 <tcp_input+0x794>
               tp->t_timer[TCPT_REXMT] = 0;
 8235f88:	e0bfe617 	ldw	r2,-104(fp)
 8235f8c:	10000315 	stw	zero,12(r2)
 8235f90:	00000706 	br	8235fb0 <tcp_input+0x7b0>
            else if (tp->t_timer[TCPT_PERSIST] == 0)
 8235f94:	e0bfe617 	ldw	r2,-104(fp)
 8235f98:	10800417 	ldw	r2,16(r2)
 8235f9c:	1000041e 	bne	r2,zero,8235fb0 <tcp_input+0x7b0>
               tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 8235fa0:	e0bfe617 	ldw	r2,-104(fp)
 8235fa4:	10c00817 	ldw	r3,32(r2)
 8235fa8:	e0bfe617 	ldw	r2,-104(fp)
 8235fac:	10c00315 	stw	r3,12(r2)

            if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 8235fb0:	e0bfe817 	ldw	r2,-96(fp)
 8235fb4:	1080190b 	ldhu	r2,100(r2)
 8235fb8:	10bfffcc 	andi	r2,r2,65535
 8235fbc:	1080030c 	andi	r2,r2,12
 8235fc0:	10000526 	beq	r2,zero,8235fd8 <tcp_input+0x7d8>
               sowwakeup(so);
 8235fc4:	e0bfe817 	ldw	r2,-96(fp)
 8235fc8:	10801204 	addi	r2,r2,72
 8235fcc:	100b883a 	mov	r5,r2
 8235fd0:	e13fe817 	ldw	r4,-96(fp)
 8235fd4:	82340c40 	call	82340c4 <sbwakeup>

            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
 8235fd8:	e0bfe817 	ldw	r2,-96(fp)
 8235fdc:	10801217 	ldw	r2,72(r2)
 8235fe0:	e0ffe617 	ldw	r3,-104(fp)
 8235fe4:	19000f17 	ldw	r4,60(r3)
 8235fe8:	e0ffe617 	ldw	r3,-104(fp)
 8235fec:	18c00e17 	ldw	r3,56(r3)
 8235ff0:	20c7c83a 	sub	r3,r4,r3
 8235ff4:	1886c02e 	bgeu	r3,r2,8237af8 <tcp_input+0x22f8>
               (void) tcp_output(tp);
 8235ff8:	e13fe617 	ldw	r4,-104(fp)
 8235ffc:	82381700 	call	8238170 <tcp_output>
            return;
 8236000:	0006bd06 	br	8237af8 <tcp_input+0x22f8>
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 8236004:	e0bff217 	ldw	r2,-56(fp)
 8236008:	10c00717 	ldw	r3,28(r2)
 823600c:	e0bfe617 	ldw	r2,-104(fp)
 8236010:	10800e17 	ldw	r2,56(r2)
 8236014:	1880841e 	bne	r3,r2,8236228 <tcp_input+0xa28>
          tp->seg_next == (struct tcpiphdr *)tp &&
 8236018:	e0bfe617 	ldw	r2,-104(fp)
 823601c:	10c00017 	ldw	r3,0(r2)
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
               (void) tcp_output(tp);
            return;
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 8236020:	e0bfe617 	ldw	r2,-104(fp)
 8236024:	1880801e 	bne	r3,r2,8236228 <tcp_input+0xa28>
          tp->seg_next == (struct tcpiphdr *)tp &&
          ti->ti_len <= sbspace(&so->so_rcv))
 8236028:	e0bff217 	ldw	r2,-56(fp)
 823602c:	1080028b 	ldhu	r2,10(r2)
 8236030:	10ffffcc 	andi	r3,r2,65535
 8236034:	e0bfe817 	ldw	r2,-96(fp)
 8236038:	10800b17 	ldw	r2,44(r2)
 823603c:	1009883a 	mov	r4,r2
 8236040:	e0bfe817 	ldw	r2,-96(fp)
 8236044:	10800a17 	ldw	r2,40(r2)
 8236048:	2085c83a 	sub	r2,r4,r2
 823604c:	10000616 	blt	r2,zero,8236068 <tcp_input+0x868>
 8236050:	e0bfe817 	ldw	r2,-96(fp)
 8236054:	11000b17 	ldw	r4,44(r2)
 8236058:	e0bfe817 	ldw	r2,-96(fp)
 823605c:	10800a17 	ldw	r2,40(r2)
 8236060:	2085c83a 	sub	r2,r4,r2
 8236064:	00000106 	br	823606c <tcp_input+0x86c>
 8236068:	0005883a 	mov	r2,zero
               (void) tcp_output(tp);
            return;
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
          tp->seg_next == (struct tcpiphdr *)tp &&
 823606c:	10c06e36 	bltu	r2,r3,8236228 <tcp_input+0xa28>
#endif   /* TCP_ZEROCOPY */

         /* this may also be a garden-variety probe received because
          * the socket sendbuf was full.
          */
         if(tp->rcv_wnd == 0)
 8236070:	e0bfe617 	ldw	r2,-104(fp)
 8236074:	10801517 	ldw	r2,84(r2)
 8236078:	10000c1e 	bne	r2,zero,82360ac <tcp_input+0x8ac>
             * info in this seg, but Windows NT 4.0 has a nasty bug where it
             * will hammer us mericilessly with these probes (one customer
             * reports thousands per second) so we just dump it ASAP to
             * save cycles.
             */
            tcpstat.tcps_rcvwinprobe++;
 823607c:	008209b4 	movhi	r2,2086
 8236080:	10b99404 	addi	r2,r2,-6576
 8236084:	10802817 	ldw	r2,160(r2)
 8236088:	10c00044 	addi	r3,r2,1
 823608c:	008209b4 	movhi	r2,2086
 8236090:	10b99404 	addi	r2,r2,-6576
 8236094:	10c02815 	stw	r3,160(r2)
            m_freem (m);      /* free the received mbuf */
 8236098:	e13ffe17 	ldw	r4,-8(fp)
 823609c:	822e4b80 	call	822e4b8 <m_freem>
            tcp_output(tp);   /* send the ack now... */
 82360a0:	e13fe617 	ldw	r4,-104(fp)
 82360a4:	82381700 	call	8238170 <tcp_output>
            return;
 82360a8:	00069c06 	br	8237b1c <tcp_input+0x231c>
         /*
          * this is a pure, in-sequence data packet
          * with nothing on the reassembly queue and
          * we have enough buffer space to take it.
          */
         ++tcpstat.tcps_preddat;
 82360ac:	008209b4 	movhi	r2,2086
 82360b0:	10b99404 	addi	r2,r2,-6576
 82360b4:	10803617 	ldw	r2,216(r2)
 82360b8:	10c00044 	addi	r3,r2,1
 82360bc:	008209b4 	movhi	r2,2086
 82360c0:	10b99404 	addi	r2,r2,-6576
 82360c4:	10c03615 	stw	r3,216(r2)
         tp->rcv_nxt += ti->ti_len;
 82360c8:	e0bfe617 	ldw	r2,-104(fp)
 82360cc:	10c01617 	ldw	r3,88(r2)
 82360d0:	e0bff217 	ldw	r2,-56(fp)
 82360d4:	1080028b 	ldhu	r2,10(r2)
 82360d8:	10bfffcc 	andi	r2,r2,65535
 82360dc:	1887883a 	add	r3,r3,r2
 82360e0:	e0bfe617 	ldw	r2,-104(fp)
 82360e4:	10c01615 	stw	r3,88(r2)
         tcpstat.tcps_rcvpack++;
 82360e8:	008209b4 	movhi	r2,2086
 82360ec:	10b99404 	addi	r2,r2,-6576
 82360f0:	10801a17 	ldw	r2,104(r2)
 82360f4:	10c00044 	addi	r3,r2,1
 82360f8:	008209b4 	movhi	r2,2086
 82360fc:	10b99404 	addi	r2,r2,-6576
 8236100:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 8236104:	008209b4 	movhi	r2,2086
 8236108:	10b99404 	addi	r2,r2,-6576
 823610c:	10c01b17 	ldw	r3,108(r2)
 8236110:	e0bff217 	ldw	r2,-56(fp)
 8236114:	1080028b 	ldhu	r2,10(r2)
 8236118:	10bfffcc 	andi	r2,r2,65535
 823611c:	1887883a 	add	r3,r3,r2
 8236120:	008209b4 	movhi	r2,2086
 8236124:	10b99404 	addi	r2,r2,-6576
 8236128:	10c01b15 	stw	r3,108(r2)
         /*
          * Add data to socket buffer.
          */
         sbappend(&so->so_rcv, m);
 823612c:	e0bfe817 	ldw	r2,-96(fp)
 8236130:	10800a04 	addi	r2,r2,40
 8236134:	e17ffe17 	ldw	r5,-8(fp)
 8236138:	1009883a 	mov	r4,r2
 823613c:	82342740 	call	8234274 <sbappend>
         sorwakeup(so);
 8236140:	e0bfe817 	ldw	r2,-96(fp)
 8236144:	10800a04 	addi	r2,r2,40
 8236148:	100b883a 	mov	r5,r2
 823614c:	e13fe817 	ldw	r4,-96(fp)
 8236150:	82340c40 	call	82340c4 <sbwakeup>
         /*
          * If this is a short packet, then ACK now - with Nagel
          *   congestion avoidance sender won't send more until
          *   he gets an ACK.
          */
         if (tiflags & TH_PUSH)
 8236154:	e0bfe717 	ldw	r2,-100(fp)
 8236158:	1080020c 	andi	r2,r2,8
 823615c:	10000726 	beq	r2,zero,823617c <tcp_input+0x97c>
            tp->t_flags |= TF_ACKNOW;
 8236160:	e0bfe617 	ldw	r2,-104(fp)
 8236164:	10800b0b 	ldhu	r2,44(r2)
 8236168:	10800054 	ori	r2,r2,1
 823616c:	1007883a 	mov	r3,r2
 8236170:	e0bfe617 	ldw	r2,-104(fp)
 8236174:	10c00b0d 	sth	r3,44(r2)
 8236178:	00000606 	br	8236194 <tcp_input+0x994>
         else
            tp->t_flags |= TF_DELACK;
 823617c:	e0bfe617 	ldw	r2,-104(fp)
 8236180:	10800b0b 	ldhu	r2,44(r2)
 8236184:	10800094 	ori	r2,r2,2
 8236188:	1007883a 	mov	r3,r2
 823618c:	e0bfe617 	ldw	r2,-104(fp)
 8236190:	10c00b0d 	sth	r3,44(r2)

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));
 8236194:	e0bfe617 	ldw	r2,-104(fp)
 8236198:	10c01517 	ldw	r3,84(r2)
 823619c:	e0bfe617 	ldw	r2,-104(fp)
 82361a0:	11001617 	ldw	r4,88(r2)
 82361a4:	e0bfe617 	ldw	r2,-104(fp)
 82361a8:	10801917 	ldw	r2,100(r2)
 82361ac:	2085c83a 	sub	r2,r4,r2
 82361b0:	1885883a 	add	r2,r3,r2
 82361b4:	e0bff715 	stw	r2,-36(fp)

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 82361b8:	e0bfe617 	ldw	r2,-104(fp)
 82361bc:	10800a0b 	ldhu	r2,40(r2)
 82361c0:	10bfffcc 	andi	r2,r2,65535
 82361c4:	1085883a 	add	r2,r2,r2
 82361c8:	1007883a 	mov	r3,r2
 82361cc:	e0bff717 	ldw	r2,-36(fp)
 82361d0:	10c0050e 	bge	r2,r3,82361e8 <tcp_input+0x9e8>
             (tp->t_flags & TF_ACKNOW))
 82361d4:	e0bfe617 	ldw	r2,-104(fp)
 82361d8:	10800b0b 	ldhu	r2,44(r2)
 82361dc:	10bfffcc 	andi	r2,r2,65535
 82361e0:	1080004c 	andi	r2,r2,1
            tp->t_flags |= TF_DELACK;

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 82361e4:	10064626 	beq	r2,zero,8237b00 <tcp_input+0x2300>
               tp->t_flags &= ~TF_ACKNOW;
               return;
            }
#endif   /* DO_DELAY_ACKS */

            tp->t_flags |= TF_ACKNOW;
 82361e8:	e0bfe617 	ldw	r2,-104(fp)
 82361ec:	10800b0b 	ldhu	r2,44(r2)
 82361f0:	10800054 	ori	r2,r2,1
 82361f4:	1007883a 	mov	r3,r2
 82361f8:	e0bfe617 	ldw	r2,-104(fp)
 82361fc:	10c00b0d 	sth	r3,44(r2)
            tp->t_flags &= ~TF_DELACK;
 8236200:	e0bfe617 	ldw	r2,-104(fp)
 8236204:	10c00b0b 	ldhu	r3,44(r2)
 8236208:	00bfff44 	movi	r2,-3
 823620c:	1884703a 	and	r2,r3,r2
 8236210:	1007883a 	mov	r3,r2
 8236214:	e0bfe617 	ldw	r2,-104(fp)
 8236218:	10c00b0d 	sth	r3,44(r2)
            tcp_output(tp);   /* send the ack now... */
 823621c:	e13fe617 	ldw	r4,-104(fp)
 8236220:	82381700 	call	8238170 <tcp_output>
         }

         return;
 8236224:	00063606 	br	8237b00 <tcp_input+0x2300>
      }
   }

   switch (tp->t_state) 
 8236228:	e0bfe617 	ldw	r2,-104(fp)
 823622c:	10800217 	ldw	r2,8(r2)
 8236230:	10c00060 	cmpeqi	r3,r2,1
 8236234:	1800031e 	bne	r3,zero,8236244 <tcp_input+0xa44>
 8236238:	108000a0 	cmpeqi	r2,r2,2
 823623c:	1000aa1e 	bne	r2,zero,82364e8 <tcp_input+0xce8>
 8236240:	00017e06 	br	823683c <tcp_input+0x103c>
    */
   case TCPS_LISTEN: 
   {
         struct mbuf *  am;

         if (tiflags & TH_RST)
 8236244:	e0bfe717 	ldw	r2,-100(fp)
 8236248:	1080010c 	andi	r2,r2,4
 823624c:	10000326 	beq	r2,zero,823625c <tcp_input+0xa5c>
            GOTO_DROP;
 8236250:	0080bec4 	movi	r2,763
 8236254:	d0a0b215 	stw	r2,-32056(gp)
 8236258:	00061b06 	br	8237ac8 <tcp_input+0x22c8>
         if (tiflags & TH_ACK)
 823625c:	e0bfe717 	ldw	r2,-100(fp)
 8236260:	1080040c 	andi	r2,r2,16
 8236264:	10000326 	beq	r2,zero,8236274 <tcp_input+0xa74>
            GOTO_DROPWITHRESET;
 8236268:	0080bf44 	movi	r2,765
 823626c:	d0a0b215 	stw	r2,-32056(gp)
 8236270:	0005d406 	br	82379c4 <tcp_input+0x21c4>
         if ((tiflags & TH_SYN) == 0)
 8236274:	e0bfe717 	ldw	r2,-100(fp)
 8236278:	1080008c 	andi	r2,r2,2
 823627c:	1000031e 	bne	r2,zero,823628c <tcp_input+0xa8c>
            GOTO_DROP;
 8236280:	0080bfc4 	movi	r2,767
 8236284:	d0a0b215 	stw	r2,-32056(gp)
 8236288:	00060f06 	br	8237ac8 <tcp_input+0x22c8>
         if(in_broadcast(ti->ti_dst.s_addr))
 823628c:	e0bff217 	ldw	r2,-56(fp)
 8236290:	10800417 	ldw	r2,16(r2)
 8236294:	1009883a 	mov	r4,r2
 8236298:	822f4040 	call	822f404 <in_broadcast>
 823629c:	10000326 	beq	r2,zero,82362ac <tcp_input+0xaac>
            GOTO_DROP;
 82362a0:	0080c044 	movi	r2,769
 82362a4:	d0a0b215 	stw	r2,-32056(gp)
 82362a8:	00060706 	br	8237ac8 <tcp_input+0x22c8>
         am = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 82362ac:	01400404 	movi	r5,16
 82362b0:	01000244 	movi	r4,9
 82362b4:	822e2280 	call	822e228 <m_getnbuf>
 82362b8:	e0bffa15 	stw	r2,-24(fp)
         if (am == NULL)
 82362bc:	e0bffa17 	ldw	r2,-24(fp)
 82362c0:	1000031e 	bne	r2,zero,82362d0 <tcp_input+0xad0>
            GOTO_DROP;
 82362c4:	0080c104 	movi	r2,772
 82362c8:	d0a0b215 	stw	r2,-32056(gp)
 82362cc:	0005fe06 	br	8237ac8 <tcp_input+0x22c8>

#ifdef IP_V4
         if(inp->inp_socket->so_domain == AF_INET)
 82362d0:	e0bfe417 	ldw	r2,-112(fp)
 82362d4:	10800817 	ldw	r2,32(r2)
 82362d8:	10800517 	ldw	r2,20(r2)
 82362dc:	10800098 	cmpnei	r2,r2,2
 82362e0:	10002c1e 	bne	r2,zero,8236394 <tcp_input+0xb94>
         {
         struct sockaddr_in * sin;
         am->m_len = sizeof (struct sockaddr_in);
 82362e4:	e0bffa17 	ldw	r2,-24(fp)
 82362e8:	00c00404 	movi	r3,16
 82362ec:	10c00215 	stw	r3,8(r2)
         sin = mtod(am, struct sockaddr_in *);
 82362f0:	e0bffa17 	ldw	r2,-24(fp)
 82362f4:	10800317 	ldw	r2,12(r2)
 82362f8:	e0bffb15 	stw	r2,-20(fp)
         sin->sin_family = AF_INET;
 82362fc:	e0bffb17 	ldw	r2,-20(fp)
 8236300:	00c00084 	movi	r3,2
 8236304:	10c0000d 	sth	r3,0(r2)
         sin->sin_addr = ti->ti_src;
 8236308:	e0bffb17 	ldw	r2,-20(fp)
 823630c:	e0fff217 	ldw	r3,-56(fp)
 8236310:	18c00317 	ldw	r3,12(r3)
 8236314:	10c00115 	stw	r3,4(r2)
         sin->sin_port = ti->ti_sport;
 8236318:	e0bff217 	ldw	r2,-56(fp)
 823631c:	10c0050b 	ldhu	r3,20(r2)
 8236320:	e0bffb17 	ldw	r2,-20(fp)
 8236324:	10c0008d 	sth	r3,2(r2)
         /* Assuming pcbconnect will work, we put the sender's address in 
          * the inp_laddr (after saving a local laddr copy). If the connect
          * fails we restore the inpcb before going to drop:
          */
         laddr = inp->inp_laddr;    /* save tmp laddr */
 8236328:	e0bfe417 	ldw	r2,-112(fp)
 823632c:	10800417 	ldw	r2,16(r2)
 8236330:	e0bffd15 	stw	r2,-12(fp)
         if (inp->inp_laddr.s_addr == INADDR_ANY)
 8236334:	e0bfe417 	ldw	r2,-112(fp)
 8236338:	10800417 	ldw	r2,16(r2)
 823633c:	1000041e 	bne	r2,zero,8236350 <tcp_input+0xb50>
            inp->inp_laddr = ti->ti_dst;
 8236340:	e0bfe417 	ldw	r2,-112(fp)
 8236344:	e0fff217 	ldw	r3,-56(fp)
 8236348:	18c00417 	ldw	r3,16(r3)
 823634c:	10c00415 	stw	r3,16(r2)
         if (in_pcbconnect (inp, am)) 
 8236350:	e17ffa17 	ldw	r5,-24(fp)
 8236354:	e13fe417 	ldw	r4,-112(fp)
 8236358:	8247f780 	call	8247f78 <in_pcbconnect>
 823635c:	10000826 	beq	r2,zero,8236380 <tcp_input+0xb80>
         {
            inp->inp_laddr = laddr;
 8236360:	e0bfe417 	ldw	r2,-112(fp)
 8236364:	e0fffd17 	ldw	r3,-12(fp)
 8236368:	10c00415 	stw	r3,16(r2)
            (void) m_free(am);
 823636c:	e13ffa17 	ldw	r4,-24(fp)
 8236370:	822e3b00 	call	822e3b0 <m_free>
            GOTO_DROP;
 8236374:	0080c684 	movi	r2,794
 8236378:	d0a0b215 	stw	r2,-32056(gp)
 823637c:	0005d206 	br	8237ac8 <tcp_input+0x22c8>
         }
         
         inp->ifp = ifp;      /* set interface for conn.*/
 8236380:	e0bfe417 	ldw	r2,-112(fp)
 8236384:	e0ffff17 	ldw	r3,-4(fp)
 8236388:	10c00a15 	stw	r3,40(r2)
         
         (void) m_free (am);
 823638c:	e13ffa17 	ldw	r4,-24(fp)
 8236390:	822e3b00 	call	822e3b0 <m_free>
            }
            (void) m_free(am);
         }
#endif   /* end v6 */

         tp->t_template = tcp_template(tp);
 8236394:	e13fe617 	ldw	r4,-104(fp)
 8236398:	82393900 	call	8239390 <tcp_template>
 823639c:	1007883a 	mov	r3,r2
 82363a0:	e0bfe617 	ldw	r2,-104(fp)
 82363a4:	10c00c15 	stw	r3,48(r2)
         if (tp->t_template == 0) 
 82363a8:	e0bfe617 	ldw	r2,-104(fp)
 82363ac:	10800c17 	ldw	r2,48(r2)
 82363b0:	1000071e 	bne	r2,zero,82363d0 <tcp_input+0xbd0>
         {
            SETTP(tp, tcp_drop(tp, ENOBUFS));
 82363b4:	01401a44 	movi	r5,105
 82363b8:	e13fe617 	ldw	r4,-104(fp)
 82363bc:	82399a40 	call	82399a4 <tcp_drop>
            dropsocket = 0;      /* socket is already gone */
 82363c0:	e03fec15 	stw	zero,-80(fp)
            GOTO_DROP;
 82363c4:	0080d1c4 	movi	r2,839
 82363c8:	d0a0b215 	stw	r2,-32056(gp)
 82363cc:	0005be06 	br	8237ac8 <tcp_input+0x22c8>
         }
         if (om) 
 82363d0:	e0bfe517 	ldw	r2,-108(fp)
 82363d4:	10000526 	beq	r2,zero,82363ec <tcp_input+0xbec>
         {
            tcp_dooptions(tp, om, ti);
 82363d8:	e1bff217 	ldw	r6,-56(fp)
 82363dc:	e17fe517 	ldw	r5,-108(fp)
 82363e0:	e13fe617 	ldw	r4,-104(fp)
 82363e4:	8237b300 	call	8237b30 <tcp_dooptions>
            om = 0;
 82363e8:	e03fe515 	stw	zero,-108(fp)
         }
         if (iss)
 82363ec:	e0bfed17 	ldw	r2,-76(fp)
 82363f0:	10000426 	beq	r2,zero,8236404 <tcp_input+0xc04>
            tp->iss = iss;
 82363f4:	e0ffed17 	ldw	r3,-76(fp)
 82363f8:	e0bfe617 	ldw	r2,-104(fp)
 82363fc:	10c01315 	stw	r3,76(r2)
 8236400:	00000306 	br	8236410 <tcp_input+0xc10>
         else
            tp->iss = tcp_iss;
 8236404:	d0e0b517 	ldw	r3,-32044(gp)
 8236408:	e0bfe617 	ldw	r2,-104(fp)
 823640c:	10c01315 	stw	r3,76(r2)
         tcp_iss += (unsigned)(TCP_ISSINCR/2);
 8236410:	d0e0b517 	ldw	r3,-32044(gp)
 8236414:	00be9fd4 	movui	r2,64127
 8236418:	1885883a 	add	r2,r3,r2
 823641c:	d0a0b515 	stw	r2,-32044(gp)
         tp->irs = ti->ti_seq;
 8236420:	e0bff217 	ldw	r2,-56(fp)
 8236424:	10c00617 	ldw	r3,24(r2)
 8236428:	e0bfe617 	ldw	r2,-104(fp)
 823642c:	10c01815 	stw	r3,96(r2)
         tcp_sendseqinit(tp);
 8236430:	e0bfe617 	ldw	r2,-104(fp)
 8236434:	10c01317 	ldw	r3,76(r2)
 8236438:	e0bfe617 	ldw	r2,-104(fp)
 823643c:	10c01015 	stw	r3,64(r2)
 8236440:	e0bfe617 	ldw	r2,-104(fp)
 8236444:	10c01017 	ldw	r3,64(r2)
 8236448:	e0bfe617 	ldw	r2,-104(fp)
 823644c:	10c01a15 	stw	r3,104(r2)
 8236450:	e0bfe617 	ldw	r2,-104(fp)
 8236454:	10c01a17 	ldw	r3,104(r2)
 8236458:	e0bfe617 	ldw	r2,-104(fp)
 823645c:	10c00f15 	stw	r3,60(r2)
 8236460:	e0bfe617 	ldw	r2,-104(fp)
 8236464:	10c00f17 	ldw	r3,60(r2)
 8236468:	e0bfe617 	ldw	r2,-104(fp)
 823646c:	10c00e15 	stw	r3,56(r2)
         tcp_rcvseqinit(tp);
 8236470:	e0bfe617 	ldw	r2,-104(fp)
 8236474:	10801817 	ldw	r2,96(r2)
 8236478:	10c00044 	addi	r3,r2,1
 823647c:	e0bfe617 	ldw	r2,-104(fp)
 8236480:	10c01615 	stw	r3,88(r2)
 8236484:	e0bfe617 	ldw	r2,-104(fp)
 8236488:	10c01617 	ldw	r3,88(r2)
 823648c:	e0bfe617 	ldw	r2,-104(fp)
 8236490:	10c01915 	stw	r3,100(r2)
         tp->t_flags |= TF_ACKNOW;
 8236494:	e0bfe617 	ldw	r2,-104(fp)
 8236498:	10800b0b 	ldhu	r2,44(r2)
 823649c:	10800054 	ori	r2,r2,1
 82364a0:	1007883a 	mov	r3,r2
 82364a4:	e0bfe617 	ldw	r2,-104(fp)
 82364a8:	10c00b0d 	sth	r3,44(r2)
         tp->t_state = TCPS_SYN_RECEIVED;
 82364ac:	e0bfe617 	ldw	r2,-104(fp)
 82364b0:	00c000c4 	movi	r3,3
 82364b4:	10c00215 	stw	r3,8(r2)
         tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 82364b8:	e0bfe617 	ldw	r2,-104(fp)
 82364bc:	00c02584 	movi	r3,150
 82364c0:	10c00515 	stw	r3,20(r2)
         dropsocket = 0;      /* committed to socket */
 82364c4:	e03fec15 	stw	zero,-80(fp)
         tcpstat.tcps_accepts++;
 82364c8:	008209b4 	movhi	r2,2086
 82364cc:	10b99404 	addi	r2,r2,-6576
 82364d0:	10800117 	ldw	r2,4(r2)
 82364d4:	10c00044 	addi	r3,r2,1
 82364d8:	008209b4 	movhi	r2,2086
 82364dc:	10b99404 	addi	r2,r2,-6576
 82364e0:	10c00115 	stw	r3,4(r2)
         goto trimthenstep6;
 82364e4:	00009006 	br	8236728 <tcp_input+0xf28>
    *   if SYN has been acked change to ESTABLISHED else SYN_RCVD state
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
 82364e8:	e0bfe417 	ldw	r2,-112(fp)
 82364ec:	e0ffff17 	ldw	r3,-4(fp)
 82364f0:	10c00a15 	stw	r3,40(r2)
      if ((tiflags & TH_ACK) &&
 82364f4:	e0bfe717 	ldw	r2,-100(fp)
 82364f8:	1080040c 	andi	r2,r2,16
 82364fc:	10000f26 	beq	r2,zero,823653c <tcp_input+0xd3c>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
 8236500:	e0bff217 	ldw	r2,-56(fp)
 8236504:	10c00717 	ldw	r3,28(r2)
 8236508:	e0bfe617 	ldw	r2,-104(fp)
 823650c:	10801317 	ldw	r2,76(r2)
 8236510:	1885c83a 	sub	r2,r3,r2
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
      if ((tiflags & TH_ACK) &&
 8236514:	0080060e 	bge	zero,r2,8236530 <tcp_input+0xd30>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
          SEQ_GT(ti->ti_ack, tp->snd_max)))
 8236518:	e0bff217 	ldw	r2,-56(fp)
 823651c:	10c00717 	ldw	r3,28(r2)
 8236520:	e0bfe617 	ldw	r2,-104(fp)
 8236524:	10801a17 	ldw	r2,104(r2)
 8236528:	1885c83a 	sub	r2,r3,r2
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
      if ((tiflags & TH_ACK) &&
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
 823652c:	0080030e 	bge	zero,r2,823653c <tcp_input+0xd3c>
          SEQ_GT(ti->ti_ack, tp->snd_max)))
      {
         GOTO_DROPWITHRESET;
 8236530:	0080dc04 	movi	r2,880
 8236534:	d0a0b215 	stw	r2,-32056(gp)
 8236538:	00052206 	br	82379c4 <tcp_input+0x21c4>
      }
      if (tiflags & TH_RST) 
 823653c:	e0bfe717 	ldw	r2,-100(fp)
 8236540:	1080010c 	andi	r2,r2,4
 8236544:	10000926 	beq	r2,zero,823656c <tcp_input+0xd6c>
      {
         if (tiflags & TH_ACK)
 8236548:	e0bfe717 	ldw	r2,-100(fp)
 823654c:	1080040c 	andi	r2,r2,16
 8236550:	10000326 	beq	r2,zero,8236560 <tcp_input+0xd60>
            SETTP(tp, tcp_drop(tp, ECONNREFUSED));
 8236554:	01401bc4 	movi	r5,111
 8236558:	e13fe617 	ldw	r4,-104(fp)
 823655c:	82399a40 	call	82399a4 <tcp_drop>
         GOTO_DROP;
 8236560:	0080dd84 	movi	r2,886
 8236564:	d0a0b215 	stw	r2,-32056(gp)
 8236568:	00055706 	br	8237ac8 <tcp_input+0x22c8>
      }
      if ((tiflags & TH_SYN) == 0)
 823656c:	e0bfe717 	ldw	r2,-100(fp)
 8236570:	1080008c 	andi	r2,r2,2
 8236574:	1000031e 	bne	r2,zero,8236584 <tcp_input+0xd84>
         GOTO_DROP;
 8236578:	0080de44 	movi	r2,889
 823657c:	d0a0b215 	stw	r2,-32056(gp)
 8236580:	00055106 	br	8237ac8 <tcp_input+0x22c8>
      if (tiflags & TH_ACK) 
 8236584:	e0bfe717 	ldw	r2,-100(fp)
 8236588:	1080040c 	andi	r2,r2,16
 823658c:	10000e26 	beq	r2,zero,82365c8 <tcp_input+0xdc8>
      {
         tp->snd_una = ti->ti_ack;
 8236590:	e0bff217 	ldw	r2,-56(fp)
 8236594:	10c00717 	ldw	r3,28(r2)
 8236598:	e0bfe617 	ldw	r2,-104(fp)
 823659c:	10c00e15 	stw	r3,56(r2)
         if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 82365a0:	e0bfe617 	ldw	r2,-104(fp)
 82365a4:	10c00f17 	ldw	r3,60(r2)
 82365a8:	e0bfe617 	ldw	r2,-104(fp)
 82365ac:	10800e17 	ldw	r2,56(r2)
 82365b0:	1885c83a 	sub	r2,r3,r2
 82365b4:	1000040e 	bge	r2,zero,82365c8 <tcp_input+0xdc8>
            tp->snd_nxt = tp->snd_una;
 82365b8:	e0bfe617 	ldw	r2,-104(fp)
 82365bc:	10c00e17 	ldw	r3,56(r2)
 82365c0:	e0bfe617 	ldw	r2,-104(fp)
 82365c4:	10c00f15 	stw	r3,60(r2)
      }
      tp->t_timer[TCPT_REXMT] = 0;
 82365c8:	e0bfe617 	ldw	r2,-104(fp)
 82365cc:	10000315 	stw	zero,12(r2)
      tp->irs = ti->ti_seq;
 82365d0:	e0bff217 	ldw	r2,-56(fp)
 82365d4:	10c00617 	ldw	r3,24(r2)
 82365d8:	e0bfe617 	ldw	r2,-104(fp)
 82365dc:	10c01815 	stw	r3,96(r2)
      tcp_rcvseqinit(tp);
 82365e0:	e0bfe617 	ldw	r2,-104(fp)
 82365e4:	10801817 	ldw	r2,96(r2)
 82365e8:	10c00044 	addi	r3,r2,1
 82365ec:	e0bfe617 	ldw	r2,-104(fp)
 82365f0:	10c01615 	stw	r3,88(r2)
 82365f4:	e0bfe617 	ldw	r2,-104(fp)
 82365f8:	10c01617 	ldw	r3,88(r2)
 82365fc:	e0bfe617 	ldw	r2,-104(fp)
 8236600:	10c01915 	stw	r3,100(r2)
      if (inp->inp_laddr.s_addr != ti->ti_dst.s_addr) 
 8236604:	e0bfe417 	ldw	r2,-112(fp)
 8236608:	10c00417 	ldw	r3,16(r2)
 823660c:	e0bff217 	ldw	r2,-56(fp)
 8236610:	10800417 	ldw	r2,16(r2)
 8236614:	18801726 	beq	r3,r2,8236674 <tcp_input+0xe74>
          * the IP interface may have changed address since we sent our SYN
          * (e.g. PPP brings link up as a result of said SYN and gets new
          * address via IPCP); if so we need to update the inpcb and the
          * TCP header template with the new address.
          */
         if ((m->pkt->net != NULL)
 8236618:	e0bffe17 	ldw	r2,-8(fp)
 823661c:	10800117 	ldw	r2,4(r2)
 8236620:	10800617 	ldw	r2,24(r2)
 8236624:	10001326 	beq	r2,zero,8236674 <tcp_input+0xe74>
             && (m->pkt->net->n_ipaddr == ti->ti_dst.s_addr)) 
 8236628:	e0bffe17 	ldw	r2,-8(fp)
 823662c:	10800117 	ldw	r2,4(r2)
 8236630:	10800617 	ldw	r2,24(r2)
 8236634:	10c00a17 	ldw	r3,40(r2)
 8236638:	e0bff217 	ldw	r2,-56(fp)
 823663c:	10800417 	ldw	r2,16(r2)
 8236640:	18800c1e 	bne	r3,r2,8236674 <tcp_input+0xe74>
      /* send an ack */
         {
            inp->inp_laddr = ti->ti_dst;
 8236644:	e0bfe417 	ldw	r2,-112(fp)
 8236648:	e0fff217 	ldw	r3,-56(fp)
 823664c:	18c00417 	ldw	r3,16(r3)
 8236650:	10c00415 	stw	r3,16(r2)
            if (tp->t_template != NULL)
 8236654:	e0bfe617 	ldw	r2,-104(fp)
 8236658:	10800c17 	ldw	r2,48(r2)
 823665c:	10000526 	beq	r2,zero,8236674 <tcp_input+0xe74>
               tp->t_template->ti_src = ti->ti_dst;
 8236660:	e0bfe617 	ldw	r2,-104(fp)
 8236664:	10800c17 	ldw	r2,48(r2)
 8236668:	e0fff217 	ldw	r3,-56(fp)
 823666c:	18c00417 	ldw	r3,16(r3)
 8236670:	10c00315 	stw	r3,12(r2)
         }
      }
      tp->t_flags |= TF_ACKNOW;
 8236674:	e0bfe617 	ldw	r2,-104(fp)
 8236678:	10800b0b 	ldhu	r2,44(r2)
 823667c:	10800054 	ori	r2,r2,1
 8236680:	1007883a 	mov	r3,r2
 8236684:	e0bfe617 	ldw	r2,-104(fp)
 8236688:	10c00b0d 	sth	r3,44(r2)
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 823668c:	e0bfe717 	ldw	r2,-100(fp)
 8236690:	1080040c 	andi	r2,r2,16
 8236694:	10002126 	beq	r2,zero,823671c <tcp_input+0xf1c>
 8236698:	e0bfe617 	ldw	r2,-104(fp)
 823669c:	10c00e17 	ldw	r3,56(r2)
 82366a0:	e0bfe617 	ldw	r2,-104(fp)
 82366a4:	10801317 	ldw	r2,76(r2)
 82366a8:	1885c83a 	sub	r2,r3,r2
 82366ac:	00801b0e 	bge	zero,r2,823671c <tcp_input+0xf1c>
      {
         tcpstat.tcps_connects++;
 82366b0:	008209b4 	movhi	r2,2086
 82366b4:	10b99404 	addi	r2,r2,-6576
 82366b8:	10800217 	ldw	r2,8(r2)
 82366bc:	10c00044 	addi	r3,r2,1
 82366c0:	008209b4 	movhi	r2,2086
 82366c4:	10b99404 	addi	r2,r2,-6576
 82366c8:	10c00215 	stw	r3,8(r2)
         tp->t_state = TCPS_ESTABLISHED;
 82366cc:	e0bfe617 	ldw	r2,-104(fp)
 82366d0:	00c00104 	movi	r3,4
 82366d4:	10c00215 	stw	r3,8(r2)
         soisconnected (so);
 82366d8:	e13fe817 	ldw	r4,-96(fp)
 82366dc:	82339580 	call	8233958 <soisconnected>
         tp->t_maxseg = tcp_mss(so);
 82366e0:	e13fe817 	ldw	r4,-96(fp)
 82366e4:	82380780 	call	8238078 <tcp_mss>
 82366e8:	1007883a 	mov	r3,r2
 82366ec:	e0bfe617 	ldw	r2,-104(fp)
 82366f0:	10c00a0d 	sth	r3,40(r2)
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
 82366f4:	e1bffe17 	ldw	r6,-8(fp)
 82366f8:	000b883a 	mov	r5,zero
 82366fc:	e13fe617 	ldw	r4,-104(fp)
 8236700:	82353f00 	call	82353f0 <tcp_reass>
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 8236704:	e0bfe617 	ldw	r2,-104(fp)
 8236708:	10801e17 	ldw	r2,120(r2)
 823670c:	10000626 	beq	r2,zero,8236728 <tcp_input+0xf28>
         {
            tcp_xmit_timer(tp);
 8236710:	e13fe617 	ldw	r4,-104(fp)
 8236714:	8237de40 	call	8237de4 <tcp_xmit_timer>
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 8236718:	00000306 	br	8236728 <tcp_input+0xf28>
         {
            tcp_xmit_timer(tp);
         }
      } else
         tp->t_state = TCPS_SYN_RECEIVED;
 823671c:	e0bfe617 	ldw	r2,-104(fp)
 8236720:	00c000c4 	movi	r3,3
 8236724:	10c00215 	stw	r3,8(r2)
      /*
       * Advance ti->ti_seq to correspond to first data byte.
       * If data, trim to stay within window,
       * dropping FIN if necessary.
       */
      ti->ti_seq++;
 8236728:	e0bff217 	ldw	r2,-56(fp)
 823672c:	10800617 	ldw	r2,24(r2)
 8236730:	10c00044 	addi	r3,r2,1
 8236734:	e0bff217 	ldw	r2,-56(fp)
 8236738:	10c00615 	stw	r3,24(r2)
      if ((tcp_win)ti->ti_len > tp->rcv_wnd) 
 823673c:	e0bff217 	ldw	r2,-56(fp)
 8236740:	1080028b 	ldhu	r2,10(r2)
 8236744:	10bfffcc 	andi	r2,r2,65535
 8236748:	e0ffe617 	ldw	r3,-104(fp)
 823674c:	18c01517 	ldw	r3,84(r3)
 8236750:	1880302e 	bgeu	r3,r2,8236814 <tcp_input+0x1014>
      {
         todrop = ti->ti_len - (u_short)tp->rcv_wnd;
 8236754:	e0bff217 	ldw	r2,-56(fp)
 8236758:	1080028b 	ldhu	r2,10(r2)
 823675c:	10ffffcc 	andi	r3,r2,65535
 8236760:	e0bfe617 	ldw	r2,-104(fp)
 8236764:	10801517 	ldw	r2,84(r2)
 8236768:	10bfffcc 	andi	r2,r2,65535
 823676c:	1885c83a 	sub	r2,r3,r2
 8236770:	e0bfe915 	stw	r2,-92(fp)
         /* XXX work around 4.2 m_adj bug */
         if (m->m_len) 
 8236774:	e0bffe17 	ldw	r2,-8(fp)
 8236778:	10800217 	ldw	r2,8(r2)
 823677c:	10000626 	beq	r2,zero,8236798 <tcp_input+0xf98>
         {
            m_adj(m, -todrop);
 8236780:	e0bfe917 	ldw	r2,-92(fp)
 8236784:	0085c83a 	sub	r2,zero,r2
 8236788:	100b883a 	mov	r5,r2
 823678c:	e13ffe17 	ldw	r4,-8(fp)
 8236790:	822e7f00 	call	822e7f0 <m_adj>
 8236794:	00000706 	br	82367b4 <tcp_input+0xfb4>
         }
         else 
         {
            /* skip tcp/ip header in first mbuf */
            m_adj(m->m_next, -todrop);
 8236798:	e0bffe17 	ldw	r2,-8(fp)
 823679c:	10c00617 	ldw	r3,24(r2)
 82367a0:	e0bfe917 	ldw	r2,-92(fp)
 82367a4:	0085c83a 	sub	r2,zero,r2
 82367a8:	100b883a 	mov	r5,r2
 82367ac:	1809883a 	mov	r4,r3
 82367b0:	822e7f00 	call	822e7f0 <m_adj>
         }
         ti->ti_len = (u_short)tp->rcv_wnd;
 82367b4:	e0bfe617 	ldw	r2,-104(fp)
 82367b8:	10801517 	ldw	r2,84(r2)
 82367bc:	1007883a 	mov	r3,r2
 82367c0:	e0bff217 	ldw	r2,-56(fp)
 82367c4:	10c0028d 	sth	r3,10(r2)
         tiflags &= ~TH_FIN;
 82367c8:	e0ffe717 	ldw	r3,-100(fp)
 82367cc:	00bfff84 	movi	r2,-2
 82367d0:	1884703a 	and	r2,r3,r2
 82367d4:	e0bfe715 	stw	r2,-100(fp)
         tcpstat.tcps_rcvpackafterwin++;
 82367d8:	008209b4 	movhi	r2,2086
 82367dc:	10b99404 	addi	r2,r2,-6576
 82367e0:	10802517 	ldw	r2,148(r2)
 82367e4:	10c00044 	addi	r3,r2,1
 82367e8:	008209b4 	movhi	r2,2086
 82367ec:	10b99404 	addi	r2,r2,-6576
 82367f0:	10c02515 	stw	r3,148(r2)
         tcpstat.tcps_rcvbyteafterwin += todrop;
 82367f4:	008209b4 	movhi	r2,2086
 82367f8:	10b99404 	addi	r2,r2,-6576
 82367fc:	10c02617 	ldw	r3,152(r2)
 8236800:	e0bfe917 	ldw	r2,-92(fp)
 8236804:	1887883a 	add	r3,r3,r2
 8236808:	008209b4 	movhi	r2,2086
 823680c:	10b99404 	addi	r2,r2,-6576
 8236810:	10c02615 	stw	r3,152(r2)
      }
      tp->snd_wl1 = ti->ti_seq - 1;
 8236814:	e0bff217 	ldw	r2,-56(fp)
 8236818:	10800617 	ldw	r2,24(r2)
 823681c:	10ffffc4 	addi	r3,r2,-1
 8236820:	e0bfe617 	ldw	r2,-104(fp)
 8236824:	10c01115 	stw	r3,68(r2)
      tp->rcv_up = ti->ti_seq;
 8236828:	e0bff217 	ldw	r2,-56(fp)
 823682c:	10c00617 	ldw	r3,24(r2)
 8236830:	e0bfe617 	ldw	r2,-104(fp)
 8236834:	10c01715 	stw	r3,92(r2)
      goto step6;
 8236838:	0002ee06 	br	82373f4 <tcp_input+0x1bf4>
    * States other than LISTEN or SYN_SENT.
    * First check that at least some bytes of segment are within 
    * receive window.  If segment begins before rcv_nxt,
    * drop leading data (and SYN); if nothing left, just ack.
    */
   todrop = (int)(tp->rcv_nxt - ti->ti_seq);
 823683c:	e0bfe617 	ldw	r2,-104(fp)
 8236840:	10c01617 	ldw	r3,88(r2)
 8236844:	e0bff217 	ldw	r2,-56(fp)
 8236848:	10800617 	ldw	r2,24(r2)
 823684c:	1885c83a 	sub	r2,r3,r2
 8236850:	e0bfe915 	stw	r2,-92(fp)
   if (todrop > 0) 
 8236854:	e0bfe917 	ldw	r2,-92(fp)
 8236858:	0080910e 	bge	zero,r2,8236aa0 <tcp_input+0x12a0>
   {
      if (tiflags & TH_SYN) 
 823685c:	e0bfe717 	ldw	r2,-100(fp)
 8236860:	1080008c 	andi	r2,r2,2
 8236864:	10001c26 	beq	r2,zero,82368d8 <tcp_input+0x10d8>
      {
         tiflags &= ~TH_SYN;
 8236868:	e0ffe717 	ldw	r3,-100(fp)
 823686c:	00bfff44 	movi	r2,-3
 8236870:	1884703a 	and	r2,r3,r2
 8236874:	e0bfe715 	stw	r2,-100(fp)
         ti->ti_seq++;
 8236878:	e0bff217 	ldw	r2,-56(fp)
 823687c:	10800617 	ldw	r2,24(r2)
 8236880:	10c00044 	addi	r3,r2,1
 8236884:	e0bff217 	ldw	r2,-56(fp)
 8236888:	10c00615 	stw	r3,24(r2)
         if (ti->ti_urp > 1) 
 823688c:	e0bff217 	ldw	r2,-56(fp)
 8236890:	1080098b 	ldhu	r2,38(r2)
 8236894:	10bfffcc 	andi	r2,r2,65535
 8236898:	108000b0 	cmpltui	r2,r2,2
 823689c:	1000071e 	bne	r2,zero,82368bc <tcp_input+0x10bc>
            ti->ti_urp--;
 82368a0:	e0bff217 	ldw	r2,-56(fp)
 82368a4:	1080098b 	ldhu	r2,38(r2)
 82368a8:	10bfffc4 	addi	r2,r2,-1
 82368ac:	1007883a 	mov	r3,r2
 82368b0:	e0bff217 	ldw	r2,-56(fp)
 82368b4:	10c0098d 	sth	r3,38(r2)
 82368b8:	00000406 	br	82368cc <tcp_input+0x10cc>
         else
            tiflags &= ~TH_URG;
 82368bc:	e0ffe717 	ldw	r3,-100(fp)
 82368c0:	00bff7c4 	movi	r2,-33
 82368c4:	1884703a 	and	r2,r3,r2
 82368c8:	e0bfe715 	stw	r2,-100(fp)
         todrop--;
 82368cc:	e0bfe917 	ldw	r2,-92(fp)
 82368d0:	10bfffc4 	addi	r2,r2,-1
 82368d4:	e0bfe915 	stw	r2,-92(fp)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 82368d8:	e0bff217 	ldw	r2,-56(fp)
 82368dc:	1080028b 	ldhu	r2,10(r2)
 82368e0:	10ffffcc 	andi	r3,r2,65535
 82368e4:	e0bfe917 	ldw	r2,-92(fp)
 82368e8:	18800816 	blt	r3,r2,823690c <tcp_input+0x110c>
          ((todrop == (int)ti->ti_len) && 
 82368ec:	e0bff217 	ldw	r2,-56(fp)
 82368f0:	1080028b 	ldhu	r2,10(r2)
 82368f4:	10ffffcc 	andi	r3,r2,65535
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 82368f8:	e0bfe917 	ldw	r2,-92(fp)
 82368fc:	1880351e 	bne	r3,r2,82369d4 <tcp_input+0x11d4>
          ((todrop == (int)ti->ti_len) && 
          (tiflags&TH_FIN) == 0)) 
 8236900:	e0bfe717 	ldw	r2,-100(fp)
 8236904:	1080004c 	andi	r2,r2,1
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
          ((todrop == (int)ti->ti_len) && 
 8236908:	1000321e 	bne	r2,zero,82369d4 <tcp_input+0x11d4>
          (tiflags&TH_FIN) == 0)) 
      {
         tcpstat.tcps_rcvduppack++;
 823690c:	008209b4 	movhi	r2,2086
 8236910:	10b99404 	addi	r2,r2,-6576
 8236914:	10801f17 	ldw	r2,124(r2)
 8236918:	10c00044 	addi	r3,r2,1
 823691c:	008209b4 	movhi	r2,2086
 8236920:	10b99404 	addi	r2,r2,-6576
 8236924:	10c01f15 	stw	r3,124(r2)
         tcpstat.tcps_rcvdupbyte += ti->ti_len;
 8236928:	008209b4 	movhi	r2,2086
 823692c:	10b99404 	addi	r2,r2,-6576
 8236930:	10c02017 	ldw	r3,128(r2)
 8236934:	e0bff217 	ldw	r2,-56(fp)
 8236938:	1080028b 	ldhu	r2,10(r2)
 823693c:	10bfffcc 	andi	r2,r2,65535
 8236940:	1887883a 	add	r3,r3,r2
 8236944:	008209b4 	movhi	r2,2086
 8236948:	10b99404 	addi	r2,r2,-6576
 823694c:	10c02015 	stw	r3,128(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 8236950:	e0bfe717 	ldw	r2,-100(fp)
 8236954:	1080004c 	andi	r2,r2,1
 8236958:	10000626 	beq	r2,zero,8236974 <tcp_input+0x1174>
 823695c:	e0bff217 	ldw	r2,-56(fp)
 8236960:	1080028b 	ldhu	r2,10(r2)
 8236964:	10bfffcc 	andi	r2,r2,65535
 8236968:	10c00044 	addi	r3,r2,1
 823696c:	e0bfe917 	ldw	r2,-92(fp)
 8236970:	18800926 	beq	r3,r2,8236998 <tcp_input+0x1198>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
 8236974:	e0bfe717 	ldw	r2,-100(fp)
 8236978:	1080010c 	andi	r2,r2,4
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 823697c:	10040026 	beq	r2,zero,8237980 <tcp_input+0x2180>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
 8236980:	e0bff217 	ldw	r2,-56(fp)
 8236984:	10c00617 	ldw	r3,24(r2)
 8236988:	e0bfe617 	ldw	r2,-104(fp)
 823698c:	10801617 	ldw	r2,88(r2)
 8236990:	10bfffc4 	addi	r2,r2,-1
 8236994:	1883fa1e 	bne	r3,r2,8237980 <tcp_input+0x2180>
         {
            todrop = ti->ti_len;
 8236998:	e0bff217 	ldw	r2,-56(fp)
 823699c:	1080028b 	ldhu	r2,10(r2)
 82369a0:	10bfffcc 	andi	r2,r2,65535
 82369a4:	e0bfe915 	stw	r2,-92(fp)
            tiflags &= ~TH_FIN;
 82369a8:	e0ffe717 	ldw	r3,-100(fp)
 82369ac:	00bfff84 	movi	r2,-2
 82369b0:	1884703a 	and	r2,r3,r2
 82369b4:	e0bfe715 	stw	r2,-100(fp)
            tp->t_flags |= TF_ACKNOW;
 82369b8:	e0bfe617 	ldw	r2,-104(fp)
 82369bc:	10800b0b 	ldhu	r2,44(r2)
 82369c0:	10800054 	ori	r2,r2,1
 82369c4:	1007883a 	mov	r3,r2
 82369c8:	e0bfe617 	ldw	r2,-104(fp)
 82369cc:	10c00b0d 	sth	r3,44(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 82369d0:	00000f06 	br	8236a10 <tcp_input+0x1210>
         else
            goto dropafterack;
      }
      else 
      {
         tcpstat.tcps_rcvpartduppack++;
 82369d4:	008209b4 	movhi	r2,2086
 82369d8:	10b99404 	addi	r2,r2,-6576
 82369dc:	10802117 	ldw	r2,132(r2)
 82369e0:	10c00044 	addi	r3,r2,1
 82369e4:	008209b4 	movhi	r2,2086
 82369e8:	10b99404 	addi	r2,r2,-6576
 82369ec:	10c02115 	stw	r3,132(r2)
         tcpstat.tcps_rcvpartdupbyte += todrop;
 82369f0:	008209b4 	movhi	r2,2086
 82369f4:	10b99404 	addi	r2,r2,-6576
 82369f8:	10c02217 	ldw	r3,136(r2)
 82369fc:	e0bfe917 	ldw	r2,-92(fp)
 8236a00:	1887883a 	add	r3,r3,r2
 8236a04:	008209b4 	movhi	r2,2086
 8236a08:	10b99404 	addi	r2,r2,-6576
 8236a0c:	10c02215 	stw	r3,136(r2)
      }
      m_adj(m, todrop);
 8236a10:	e17fe917 	ldw	r5,-92(fp)
 8236a14:	e13ffe17 	ldw	r4,-8(fp)
 8236a18:	822e7f00 	call	822e7f0 <m_adj>
      ti->ti_seq += todrop;
 8236a1c:	e0bff217 	ldw	r2,-56(fp)
 8236a20:	10c00617 	ldw	r3,24(r2)
 8236a24:	e0bfe917 	ldw	r2,-92(fp)
 8236a28:	1887883a 	add	r3,r3,r2
 8236a2c:	e0bff217 	ldw	r2,-56(fp)
 8236a30:	10c00615 	stw	r3,24(r2)
      ti->ti_len -= (u_short)todrop;
 8236a34:	e0bff217 	ldw	r2,-56(fp)
 8236a38:	1080028b 	ldhu	r2,10(r2)
 8236a3c:	e0ffe917 	ldw	r3,-92(fp)
 8236a40:	10c5c83a 	sub	r2,r2,r3
 8236a44:	1007883a 	mov	r3,r2
 8236a48:	e0bff217 	ldw	r2,-56(fp)
 8236a4c:	10c0028d 	sth	r3,10(r2)
      if (ti->ti_urp > (u_short)todrop)
 8236a50:	e0bff217 	ldw	r2,-56(fp)
 8236a54:	1080098b 	ldhu	r2,38(r2)
 8236a58:	10bfffcc 	andi	r2,r2,65535
 8236a5c:	e0ffe917 	ldw	r3,-92(fp)
 8236a60:	18ffffcc 	andi	r3,r3,65535
 8236a64:	1880080e 	bge	r3,r2,8236a88 <tcp_input+0x1288>
         ti->ti_urp -= (u_short)todrop;
 8236a68:	e0bff217 	ldw	r2,-56(fp)
 8236a6c:	1080098b 	ldhu	r2,38(r2)
 8236a70:	e0ffe917 	ldw	r3,-92(fp)
 8236a74:	10c5c83a 	sub	r2,r2,r3
 8236a78:	1007883a 	mov	r3,r2
 8236a7c:	e0bff217 	ldw	r2,-56(fp)
 8236a80:	10c0098d 	sth	r3,38(r2)
 8236a84:	00000606 	br	8236aa0 <tcp_input+0x12a0>
      else 
      {
         tiflags &= ~TH_URG;
 8236a88:	e0ffe717 	ldw	r3,-100(fp)
 8236a8c:	00bff7c4 	movi	r2,-33
 8236a90:	1884703a 	and	r2,r3,r2
 8236a94:	e0bfe715 	stw	r2,-100(fp)
         ti->ti_urp = 0;
 8236a98:	e0bff217 	ldw	r2,-56(fp)
 8236a9c:	1000098d 	sth	zero,38(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 8236aa0:	e0bfe817 	ldw	r2,-96(fp)
 8236aa4:	1080088b 	ldhu	r2,34(r2)
 8236aa8:	10bfffcc 	andi	r2,r2,65535
 8236aac:	1080004c 	andi	r2,r2,1
 8236ab0:	10001526 	beq	r2,zero,8236b08 <tcp_input+0x1308>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
 8236ab4:	e0bfe617 	ldw	r2,-104(fp)
 8236ab8:	10800217 	ldw	r2,8(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 8236abc:	10800190 	cmplti	r2,r2,6
 8236ac0:	1000111e 	bne	r2,zero,8236b08 <tcp_input+0x1308>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
 8236ac4:	e0bff217 	ldw	r2,-56(fp)
 8236ac8:	1080028b 	ldhu	r2,10(r2)
 8236acc:	10bfffcc 	andi	r2,r2,65535
 8236ad0:	10000d26 	beq	r2,zero,8236b08 <tcp_input+0x1308>
   {
      tp = tcp_close(tp);
 8236ad4:	e13fe617 	ldw	r4,-104(fp)
 8236ad8:	8239a500 	call	8239a50 <tcp_close>
 8236adc:	e0bfe615 	stw	r2,-104(fp)
      tcpstat.tcps_rcvafterclose++;
 8236ae0:	008209b4 	movhi	r2,2086
 8236ae4:	10b99404 	addi	r2,r2,-6576
 8236ae8:	10802717 	ldw	r2,156(r2)
 8236aec:	10c00044 	addi	r3,r2,1
 8236af0:	008209b4 	movhi	r2,2086
 8236af4:	10b99404 	addi	r2,r2,-6576
 8236af8:	10c02715 	stw	r3,156(r2)
      GOTO_DROPWITHRESET;
 8236afc:	00810444 	movi	r2,1041
 8236b00:	d0a0b215 	stw	r2,-32056(gp)
 8236b04:	0003af06 	br	82379c4 <tcp_input+0x21c4>

   /*
    * If segment ends after window, drop trailing data
    * (and PUSH and FIN); if nothing left, just ACK.
    */
   todrop = (int)((ti->ti_seq + (short)ti->ti_len) - (tp->rcv_nxt+tp->rcv_wnd));
 8236b08:	e0bff217 	ldw	r2,-56(fp)
 8236b0c:	10c00617 	ldw	r3,24(r2)
 8236b10:	e0bff217 	ldw	r2,-56(fp)
 8236b14:	1080028b 	ldhu	r2,10(r2)
 8236b18:	10bfffcc 	andi	r2,r2,65535
 8236b1c:	10a0001c 	xori	r2,r2,32768
 8236b20:	10a00004 	addi	r2,r2,-32768
 8236b24:	1887883a 	add	r3,r3,r2
 8236b28:	e0bfe617 	ldw	r2,-104(fp)
 8236b2c:	11001617 	ldw	r4,88(r2)
 8236b30:	e0bfe617 	ldw	r2,-104(fp)
 8236b34:	10801517 	ldw	r2,84(r2)
 8236b38:	2085883a 	add	r2,r4,r2
 8236b3c:	1885c83a 	sub	r2,r3,r2
 8236b40:	e0bfe915 	stw	r2,-92(fp)
   if (todrop > 0) 
 8236b44:	e0bfe917 	ldw	r2,-92(fp)
 8236b48:	0080690e 	bge	zero,r2,8236cf0 <tcp_input+0x14f0>
   {
      tcpstat.tcps_rcvpackafterwin++;
 8236b4c:	008209b4 	movhi	r2,2086
 8236b50:	10b99404 	addi	r2,r2,-6576
 8236b54:	10802517 	ldw	r2,148(r2)
 8236b58:	10c00044 	addi	r3,r2,1
 8236b5c:	008209b4 	movhi	r2,2086
 8236b60:	10b99404 	addi	r2,r2,-6576
 8236b64:	10c02515 	stw	r3,148(r2)
      if (todrop >= (int)ti->ti_len) 
 8236b68:	e0bff217 	ldw	r2,-56(fp)
 8236b6c:	1080028b 	ldhu	r2,10(r2)
 8236b70:	10bfffcc 	andi	r2,r2,65535
 8236b74:	e0ffe917 	ldw	r3,-92(fp)
 8236b78:	18803a16 	blt	r3,r2,8236c64 <tcp_input+0x1464>
      {
         tcpstat.tcps_rcvbyteafterwin += ti->ti_len;
 8236b7c:	008209b4 	movhi	r2,2086
 8236b80:	10b99404 	addi	r2,r2,-6576
 8236b84:	10c02617 	ldw	r3,152(r2)
 8236b88:	e0bff217 	ldw	r2,-56(fp)
 8236b8c:	1080028b 	ldhu	r2,10(r2)
 8236b90:	10bfffcc 	andi	r2,r2,65535
 8236b94:	1887883a 	add	r3,r3,r2
 8236b98:	008209b4 	movhi	r2,2086
 8236b9c:	10b99404 	addi	r2,r2,-6576
 8236ba0:	10c02615 	stw	r3,152(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 8236ba4:	e0bfe717 	ldw	r2,-100(fp)
 8236ba8:	1080008c 	andi	r2,r2,2
 8236bac:	10001726 	beq	r2,zero,8236c0c <tcp_input+0x140c>
             tp->t_state == TCPS_TIME_WAIT &&
 8236bb0:	e0bfe617 	ldw	r2,-104(fp)
 8236bb4:	10800217 	ldw	r2,8(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 8236bb8:	10800298 	cmpnei	r2,r2,10
 8236bbc:	1000131e 	bne	r2,zero,8236c0c <tcp_input+0x140c>
             tp->t_state == TCPS_TIME_WAIT &&
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
 8236bc0:	e0bff217 	ldw	r2,-56(fp)
 8236bc4:	10c00617 	ldw	r3,24(r2)
 8236bc8:	e0bfe617 	ldw	r2,-104(fp)
 8236bcc:	10801617 	ldw	r2,88(r2)
 8236bd0:	1885c83a 	sub	r2,r3,r2
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
             tp->t_state == TCPS_TIME_WAIT &&
 8236bd4:	00800d0e 	bge	zero,r2,8236c0c <tcp_input+0x140c>
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
         {
            iss = (tcp_seq)(tp->rcv_nxt + (TCP_ISSINCR));
 8236bd8:	e0bfe617 	ldw	r2,-104(fp)
 8236bdc:	10c01617 	ldw	r3,88(r2)
 8236be0:	008000b4 	movhi	r2,2
 8236be4:	10bd3fc4 	addi	r2,r2,-2817
 8236be8:	1885883a 	add	r2,r3,r2
 8236bec:	e0bfed15 	stw	r2,-76(fp)
            if (iss & 0xff000000)
 8236bf0:	e0bfed17 	ldw	r2,-76(fp)
 8236bf4:	10bfc02c 	andhi	r2,r2,65280
 8236bf8:	10000126 	beq	r2,zero,8236c00 <tcp_input+0x1400>
            {
               iss = 0L;
 8236bfc:	e03fed15 	stw	zero,-76(fp)
            }
            (void) tcp_close(tp);
 8236c00:	e13fe617 	ldw	r4,-104(fp)
 8236c04:	8239a500 	call	8239a50 <tcp_close>
            goto findpcb;
 8236c08:	003bd406 	br	8235b5c <tcp_input+0x35c>
          * window edge, and have to drop data and PUSH from
          * incoming segments.  Continue processing, but
          * remember to ack.  Otherwise, drop segment
          * and ack.
          */
         if ((tp->rcv_wnd == 0) && (ti->ti_seq == tp->rcv_nxt))
 8236c0c:	e0bfe617 	ldw	r2,-104(fp)
 8236c10:	10801517 	ldw	r2,84(r2)
 8236c14:	10035a1e 	bne	r2,zero,8237980 <tcp_input+0x2180>
 8236c18:	e0bff217 	ldw	r2,-56(fp)
 8236c1c:	10c00617 	ldw	r3,24(r2)
 8236c20:	e0bfe617 	ldw	r2,-104(fp)
 8236c24:	10801617 	ldw	r2,88(r2)
 8236c28:	1883551e 	bne	r3,r2,8237980 <tcp_input+0x2180>
         {
            tp->t_flags |= TF_ACKNOW;
 8236c2c:	e0bfe617 	ldw	r2,-104(fp)
 8236c30:	10800b0b 	ldhu	r2,44(r2)
 8236c34:	10800054 	ori	r2,r2,1
 8236c38:	1007883a 	mov	r3,r2
 8236c3c:	e0bfe617 	ldw	r2,-104(fp)
 8236c40:	10c00b0d 	sth	r3,44(r2)
            tcpstat.tcps_rcvwinprobe++;
 8236c44:	008209b4 	movhi	r2,2086
 8236c48:	10b99404 	addi	r2,r2,-6576
 8236c4c:	10802817 	ldw	r2,160(r2)
 8236c50:	10c00044 	addi	r3,r2,1
 8236c54:	008209b4 	movhi	r2,2086
 8236c58:	10b99404 	addi	r2,r2,-6576
 8236c5c:	10c02815 	stw	r3,160(r2)
 8236c60:	00000806 	br	8236c84 <tcp_input+0x1484>
         } else
            goto dropafterack;
      } else
         tcpstat.tcps_rcvbyteafterwin += todrop;
 8236c64:	008209b4 	movhi	r2,2086
 8236c68:	10b99404 	addi	r2,r2,-6576
 8236c6c:	10c02617 	ldw	r3,152(r2)
 8236c70:	e0bfe917 	ldw	r2,-92(fp)
 8236c74:	1887883a 	add	r3,r3,r2
 8236c78:	008209b4 	movhi	r2,2086
 8236c7c:	10b99404 	addi	r2,r2,-6576
 8236c80:	10c02615 	stw	r3,152(r2)
      /* XXX work around m_adj bug */
      if (m->m_len) 
 8236c84:	e0bffe17 	ldw	r2,-8(fp)
 8236c88:	10800217 	ldw	r2,8(r2)
 8236c8c:	10000626 	beq	r2,zero,8236ca8 <tcp_input+0x14a8>
      {
         m_adj(m, -todrop);
 8236c90:	e0bfe917 	ldw	r2,-92(fp)
 8236c94:	0085c83a 	sub	r2,zero,r2
 8236c98:	100b883a 	mov	r5,r2
 8236c9c:	e13ffe17 	ldw	r4,-8(fp)
 8236ca0:	822e7f00 	call	822e7f0 <m_adj>
 8236ca4:	00000706 	br	8236cc4 <tcp_input+0x14c4>
      }
      else 
      {
         /* skip tcp/ip header in first mbuf */
         m_adj(m->m_next, -todrop);
 8236ca8:	e0bffe17 	ldw	r2,-8(fp)
 8236cac:	10c00617 	ldw	r3,24(r2)
 8236cb0:	e0bfe917 	ldw	r2,-92(fp)
 8236cb4:	0085c83a 	sub	r2,zero,r2
 8236cb8:	100b883a 	mov	r5,r2
 8236cbc:	1809883a 	mov	r4,r3
 8236cc0:	822e7f00 	call	822e7f0 <m_adj>
      }
      ti->ti_len -= (u_short)todrop;
 8236cc4:	e0bff217 	ldw	r2,-56(fp)
 8236cc8:	1080028b 	ldhu	r2,10(r2)
 8236ccc:	e0ffe917 	ldw	r3,-92(fp)
 8236cd0:	10c5c83a 	sub	r2,r2,r3
 8236cd4:	1007883a 	mov	r3,r2
 8236cd8:	e0bff217 	ldw	r2,-56(fp)
 8236cdc:	10c0028d 	sth	r3,10(r2)
      tiflags &= ~(TH_PUSH|TH_FIN);
 8236ce0:	e0ffe717 	ldw	r3,-100(fp)
 8236ce4:	00bffd84 	movi	r2,-10
 8236ce8:	1884703a 	and	r2,r3,r2
 8236cec:	e0bfe715 	stw	r2,-100(fp)
      tiflags &= ~TH_RST;  /* clear reset flag */
      goto dropafterack;   /* send an ack and drop current packet */
   }
#endif /* DOS_RST */

   if (tiflags&TH_RST) 
 8236cf0:	e0bfe717 	ldw	r2,-100(fp)
 8236cf4:	1080010c 	andi	r2,r2,4
 8236cf8:	10003426 	beq	r2,zero,8236dcc <tcp_input+0x15cc>
   {
      switch (tp->t_state) 
 8236cfc:	e0bfe617 	ldw	r2,-104(fp)
 8236d00:	10800217 	ldw	r2,8(r2)
 8236d04:	10bfff44 	addi	r2,r2,-3
 8236d08:	10c00228 	cmpgeui	r3,r2,8
 8236d0c:	18002f1e 	bne	r3,zero,8236dcc <tcp_input+0x15cc>
 8236d10:	100690ba 	slli	r3,r2,2
 8236d14:	008208f4 	movhi	r2,2083
 8236d18:	109b4a04 	addi	r2,r2,27944
 8236d1c:	1885883a 	add	r2,r3,r2
 8236d20:	10800017 	ldw	r2,0(r2)
 8236d24:	1000683a 	jmp	r2
 8236d28:	08236d48 	cmpgei	zero,at,-29259
 8236d2c:	08236d58 	cmpnei	zero,at,-29259
 8236d30:	08236d74 	orhi	zero,at,36277
 8236d34:	08236d74 	orhi	zero,at,36277
 8236d38:	08236db8 	rdprs	zero,at,-29258
 8236d3c:	08236db8 	rdprs	zero,at,-29258
 8236d40:	08236d74 	orhi	zero,at,36277
 8236d44:	08236db8 	rdprs	zero,at,-29258
      {
   
      case TCPS_SYN_RECEIVED:
         so->so_error = ECONNREFUSED;
 8236d48:	e0bfe817 	ldw	r2,-96(fp)
 8236d4c:	00c01bc4 	movi	r3,111
 8236d50:	10c00615 	stw	r3,24(r2)
         goto close;
 8236d54:	00000a06 	br	8236d80 <tcp_input+0x1580>
   
      case TCPS_ESTABLISHED:
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 8236d58:	008209b4 	movhi	r2,2086
 8236d5c:	10b96604 	addi	r2,r2,-6760
 8236d60:	10800717 	ldw	r2,28(r2)
 8236d64:	10c00044 	addi	r3,r2,1
 8236d68:	008209b4 	movhi	r2,2086
 8236d6c:	10b96604 	addi	r2,r2,-6760
 8236d70:	10c00715 	stw	r3,28(r2)
      case TCPS_FIN_WAIT_1:
      case TCPS_FIN_WAIT_2:
      case TCPS_CLOSE_WAIT:
         so->so_error = ECONNRESET;
 8236d74:	e0bfe817 	ldw	r2,-96(fp)
 8236d78:	00c01a04 	movi	r3,104
 8236d7c:	10c00615 	stw	r3,24(r2)
         close:
         tp->t_state = TCPS_CLOSED;
 8236d80:	e0bfe617 	ldw	r2,-104(fp)
 8236d84:	10000215 	stw	zero,8(r2)
         tcpstat.tcps_drops++;
 8236d88:	008209b4 	movhi	r2,2086
 8236d8c:	10b99404 	addi	r2,r2,-6576
 8236d90:	10800317 	ldw	r2,12(r2)
 8236d94:	10c00044 	addi	r3,r2,1
 8236d98:	008209b4 	movhi	r2,2086
 8236d9c:	10b99404 	addi	r2,r2,-6576
 8236da0:	10c00315 	stw	r3,12(r2)
         SETTP(tp, tcp_close(tp));
 8236da4:	e13fe617 	ldw	r4,-104(fp)
 8236da8:	8239a500 	call	8239a50 <tcp_close>
#ifdef TCP_ZEROCOPY
         if (so->rx_upcall)
            so->rx_upcall(so, NULL, ECONNRESET);
#endif   /* TCP_ZEROCOPY */
         GOTO_DROP;
 8236dac:	00812204 	movi	r2,1160
 8236db0:	d0a0b215 	stw	r2,-32056(gp)
 8236db4:	00034406 	br	8237ac8 <tcp_input+0x22c8>
   
      case TCPS_CLOSING:
      case TCPS_LAST_ACK:
      case TCPS_TIME_WAIT:
         SETTP(tp, tcp_close(tp));
 8236db8:	e13fe617 	ldw	r4,-104(fp)
 8236dbc:	8239a500 	call	8239a50 <tcp_close>
         GOTO_DROP;
 8236dc0:	00812384 	movi	r2,1166
 8236dc4:	d0a0b215 	stw	r2,-32056(gp)
 8236dc8:	00033f06 	br	8237ac8 <tcp_input+0x22c8>
     tcp_trace("rcvd SYN in established state - ignoring SYN.\n");
#endif
      GOTO_DROP;
   }
#else
   if (tiflags & TH_SYN) 
 8236dcc:	e0bfe717 	ldw	r2,-100(fp)
 8236dd0:	1080008c 	andi	r2,r2,2
 8236dd4:	10000726 	beq	r2,zero,8236df4 <tcp_input+0x15f4>
   {
      tp = tcp_drop(tp, ECONNRESET);
 8236dd8:	01401a04 	movi	r5,104
 8236ddc:	e13fe617 	ldw	r4,-104(fp)
 8236de0:	82399a40 	call	82399a4 <tcp_drop>
 8236de4:	e0bfe615 	stw	r2,-104(fp)
      GOTO_DROPWITHRESET;
 8236de8:	00812b04 	movi	r2,1196
 8236dec:	d0a0b215 	stw	r2,-32056(gp)
 8236df0:	0002f406 	br	82379c4 <tcp_input+0x21c4>
#endif /* end of else of DOS_SYN */

   /*
    * If the ACK bit is off we drop the segment and return.
    */
   if ((tiflags & TH_ACK) == 0)
 8236df4:	e0bfe717 	ldw	r2,-100(fp)
 8236df8:	1080040c 	andi	r2,r2,16
 8236dfc:	1000031e 	bne	r2,zero,8236e0c <tcp_input+0x160c>
      GOTO_DROP;
 8236e00:	00812d04 	movi	r2,1204
 8236e04:	d0a0b215 	stw	r2,-32056(gp)
 8236e08:	00032f06 	br	8237ac8 <tcp_input+0x22c8>

   /*
    * Ack processing.
    */
   switch (tp->t_state) 
 8236e0c:	e0bfe617 	ldw	r2,-104(fp)
 8236e10:	10800217 	ldw	r2,8(r2)
 8236e14:	10c000e0 	cmpeqi	r3,r2,3
 8236e18:	1800051e 	bne	r3,zero,8236e30 <tcp_input+0x1630>
 8236e1c:	10c000d0 	cmplti	r3,r2,3
 8236e20:	1801741e 	bne	r3,zero,82373f4 <tcp_input+0x1bf4>
 8236e24:	108002c8 	cmpgei	r2,r2,11
 8236e28:	1001721e 	bne	r2,zero,82373f4 <tcp_input+0x1bf4>
 8236e2c:	00003006 	br	8236ef0 <tcp_input+0x16f0>
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 8236e30:	e0bfe617 	ldw	r2,-104(fp)
 8236e34:	10c00e17 	ldw	r3,56(r2)
 8236e38:	e0bff217 	ldw	r2,-56(fp)
 8236e3c:	10800717 	ldw	r2,28(r2)
 8236e40:	1885c83a 	sub	r2,r3,r2
 8236e44:	00800616 	blt	zero,r2,8236e60 <tcp_input+0x1660>
          SEQ_GT(ti->ti_ack, tp->snd_max))
 8236e48:	e0bff217 	ldw	r2,-56(fp)
 8236e4c:	10c00717 	ldw	r3,28(r2)
 8236e50:	e0bfe617 	ldw	r2,-104(fp)
 8236e54:	10801a17 	ldw	r2,104(r2)
 8236e58:	1885c83a 	sub	r2,r3,r2
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 8236e5c:	00800a0e 	bge	zero,r2,8236e88 <tcp_input+0x1688>
          SEQ_GT(ti->ti_ack, tp->snd_max))
      {
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 8236e60:	008209b4 	movhi	r2,2086
 8236e64:	10b96604 	addi	r2,r2,-6760
 8236e68:	10800717 	ldw	r2,28(r2)
 8236e6c:	10c00044 	addi	r3,r2,1
 8236e70:	008209b4 	movhi	r2,2086
 8236e74:	10b96604 	addi	r2,r2,-6760
 8236e78:	10c00715 	stw	r3,28(r2)
         GOTO_DROPWITHRESET;
 8236e7c:	00813184 	movi	r2,1222
 8236e80:	d0a0b215 	stw	r2,-32056(gp)
 8236e84:	0002cf06 	br	82379c4 <tcp_input+0x21c4>
      }
      tcpstat.tcps_connects++;
 8236e88:	008209b4 	movhi	r2,2086
 8236e8c:	10b99404 	addi	r2,r2,-6576
 8236e90:	10800217 	ldw	r2,8(r2)
 8236e94:	10c00044 	addi	r3,r2,1
 8236e98:	008209b4 	movhi	r2,2086
 8236e9c:	10b99404 	addi	r2,r2,-6576
 8236ea0:	10c00215 	stw	r3,8(r2)
      tp->t_state = TCPS_ESTABLISHED;
 8236ea4:	e0bfe617 	ldw	r2,-104(fp)
 8236ea8:	00c00104 	movi	r3,4
 8236eac:	10c00215 	stw	r3,8(r2)
      soisconnected(so);
 8236eb0:	e13fe817 	ldw	r4,-96(fp)
 8236eb4:	82339580 	call	8233958 <soisconnected>
      tp->t_maxseg = tcp_mss(so);
 8236eb8:	e13fe817 	ldw	r4,-96(fp)
 8236ebc:	82380780 	call	8238078 <tcp_mss>
 8236ec0:	1007883a 	mov	r3,r2
 8236ec4:	e0bfe617 	ldw	r2,-104(fp)
 8236ec8:	10c00a0d 	sth	r3,40(r2)
      (void) tcp_reass(tp, (struct tcpiphdr *)0, m);
 8236ecc:	e1bffe17 	ldw	r6,-8(fp)
 8236ed0:	000b883a 	mov	r5,zero
 8236ed4:	e13fe617 	ldw	r4,-104(fp)
 8236ed8:	82353f00 	call	82353f0 <tcp_reass>
      tp->snd_wl1 = ti->ti_seq - 1;
 8236edc:	e0bff217 	ldw	r2,-56(fp)
 8236ee0:	10800617 	ldw	r2,24(r2)
 8236ee4:	10ffffc4 	addi	r3,r2,-1
 8236ee8:	e0bfe617 	ldw	r2,-104(fp)
 8236eec:	10c01115 	stw	r3,68(r2)
   case TCPS_CLOSE_WAIT:
   case TCPS_CLOSING:
   case TCPS_LAST_ACK:
   case TCPS_TIME_WAIT:

      if (SEQ_LEQ(ti->ti_ack, tp->snd_una)) 
 8236ef0:	e0bff217 	ldw	r2,-56(fp)
 8236ef4:	10c00717 	ldw	r3,28(r2)
 8236ef8:	e0bfe617 	ldw	r2,-104(fp)
 8236efc:	10800e17 	ldw	r2,56(r2)
 8236f00:	1885c83a 	sub	r2,r3,r2
 8236f04:	00806316 	blt	zero,r2,8237094 <tcp_input+0x1894>
      {
         if (ti->ti_len == 0 && rx_win == tp->snd_wnd) 
 8236f08:	e0bff217 	ldw	r2,-56(fp)
 8236f0c:	1080028b 	ldhu	r2,10(r2)
 8236f10:	10bfffcc 	andi	r2,r2,65535
 8236f14:	10005a1e 	bne	r2,zero,8237080 <tcp_input+0x1880>
 8236f18:	e0bfe617 	ldw	r2,-104(fp)
 8236f1c:	10c01417 	ldw	r3,80(r2)
 8236f20:	e0bff517 	ldw	r2,-44(fp)
 8236f24:	1880561e 	bne	r3,r2,8237080 <tcp_input+0x1880>
         {
            tcpstat.tcps_rcvdupack++;
 8236f28:	008209b4 	movhi	r2,2086
 8236f2c:	10b99404 	addi	r2,r2,-6576
 8236f30:	10802917 	ldw	r2,164(r2)
 8236f34:	10c00044 	addi	r3,r2,1
 8236f38:	008209b4 	movhi	r2,2086
 8236f3c:	10b99404 	addi	r2,r2,-6576
 8236f40:	10c02915 	stw	r3,164(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 8236f44:	e0bfe617 	ldw	r2,-104(fp)
 8236f48:	10800317 	ldw	r2,12(r2)
 8236f4c:	10000526 	beq	r2,zero,8236f64 <tcp_input+0x1764>
                ti->ti_ack != tp->snd_una)
 8236f50:	e0bff217 	ldw	r2,-56(fp)
 8236f54:	10c00717 	ldw	r3,28(r2)
 8236f58:	e0bfe617 	ldw	r2,-104(fp)
 8236f5c:	10800e17 	ldw	r2,56(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 8236f60:	18800326 	beq	r3,r2,8236f70 <tcp_input+0x1770>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
 8236f64:	e0bfe617 	ldw	r2,-104(fp)
 8236f68:	10000915 	stw	zero,36(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 8236f6c:	00004706 	br	823708c <tcp_input+0x188c>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
 8236f70:	e0bfe617 	ldw	r2,-104(fp)
 8236f74:	10800917 	ldw	r2,36(r2)
 8236f78:	10c00044 	addi	r3,r2,1
 8236f7c:	e0bfe617 	ldw	r2,-104(fp)
 8236f80:	10c00915 	stw	r3,36(r2)
 8236f84:	e0bfe617 	ldw	r2,-104(fp)
 8236f88:	10c00917 	ldw	r3,36(r2)
 8236f8c:	d0a03c83 	ldbu	r2,-32526(gp)
 8236f90:	10803fcc 	andi	r2,r2,255
 8236f94:	1080201c 	xori	r2,r2,128
 8236f98:	10bfe004 	addi	r2,r2,-128
 8236f9c:	18803b1e 	bne	r3,r2,823708c <tcp_input+0x188c>
            {
               tcp_seq onxt = tp->snd_nxt;
 8236fa0:	e0bfe617 	ldw	r2,-104(fp)
 8236fa4:	10800f17 	ldw	r2,60(r2)
 8236fa8:	e0bff815 	stw	r2,-32(fp)
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
 8236fac:	e0bfe617 	ldw	r2,-104(fp)
 8236fb0:	11001417 	ldw	r4,80(r2)
 8236fb4:	e0bfe617 	ldw	r2,-104(fp)
 8236fb8:	10c01b17 	ldw	r3,108(r2)
 8236fbc:	2005883a 	mov	r2,r4
 8236fc0:	1880012e 	bgeu	r3,r2,8236fc8 <tcp_input+0x17c8>
 8236fc4:	1805883a 	mov	r2,r3
 8236fc8:	1006d07a 	srli	r3,r2,1
               tp->t_maxseg;
 8236fcc:	e0bfe617 	ldw	r2,-104(fp)
 8236fd0:	10800a0b 	ldhu	r2,40(r2)
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
            {
               tcp_seq onxt = tp->snd_nxt;
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
 8236fd4:	10bfffcc 	andi	r2,r2,65535
 8236fd8:	100b883a 	mov	r5,r2
 8236fdc:	1809883a 	mov	r4,r3
 8236fe0:	8202b8c0 	call	8202b8c <__udivsi3>
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
            {
               tcp_seq onxt = tp->snd_nxt;
               u_short  win   =
 8236fe4:	e0bff00d 	sth	r2,-64(fp)
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
               tp->t_maxseg;

               if (win < 2)
 8236fe8:	e0bff00b 	ldhu	r2,-64(fp)
 8236fec:	108000a8 	cmpgeui	r2,r2,2
 8236ff0:	1000021e 	bne	r2,zero,8236ffc <tcp_input+0x17fc>
                  win = 2;
 8236ff4:	00800084 	movi	r2,2
 8236ff8:	e0bff00d 	sth	r2,-64(fp)
               tp->snd_ssthresh = (u_short)(win * tp->t_maxseg);
 8236ffc:	e0bfe617 	ldw	r2,-104(fp)
 8237000:	10c00a0b 	ldhu	r3,40(r2)
 8237004:	e0bff00b 	ldhu	r2,-64(fp)
 8237008:	1885383a 	mul	r2,r3,r2
 823700c:	10ffffcc 	andi	r3,r2,65535
 8237010:	e0bfe617 	ldw	r2,-104(fp)
 8237014:	10c01c15 	stw	r3,112(r2)

               tp->t_timer[TCPT_REXMT] = 0;
 8237018:	e0bfe617 	ldw	r2,-104(fp)
 823701c:	10000315 	stw	zero,12(r2)
               tp->t_rttick = 0;
 8237020:	e0bfe617 	ldw	r2,-104(fp)
 8237024:	10001e15 	stw	zero,120(r2)
               tp->snd_nxt = ti->ti_ack;
 8237028:	e0bff217 	ldw	r2,-56(fp)
 823702c:	10c00717 	ldw	r3,28(r2)
 8237030:	e0bfe617 	ldw	r2,-104(fp)
 8237034:	10c00f15 	stw	r3,60(r2)
               tp->snd_cwnd = tp->t_maxseg;
 8237038:	e0bfe617 	ldw	r2,-104(fp)
 823703c:	10800a0b 	ldhu	r2,40(r2)
 8237040:	10ffffcc 	andi	r3,r2,65535
 8237044:	e0bfe617 	ldw	r2,-104(fp)
 8237048:	10c01b15 	stw	r3,108(r2)
               (void) tcp_output(tp);
 823704c:	e13fe617 	ldw	r4,-104(fp)
 8237050:	82381700 	call	8238170 <tcp_output>

               if (SEQ_GT(onxt, tp->snd_nxt))
 8237054:	e0bfe617 	ldw	r2,-104(fp)
 8237058:	10800f17 	ldw	r2,60(r2)
 823705c:	e0fff817 	ldw	r3,-32(fp)
 8237060:	1885c83a 	sub	r2,r3,r2
 8237064:	0080030e 	bge	zero,r2,8237074 <tcp_input+0x1874>
                  tp->snd_nxt = onxt;
 8237068:	e0bfe617 	ldw	r2,-104(fp)
 823706c:	e0fff817 	ldw	r3,-32(fp)
 8237070:	10c00f15 	stw	r3,60(r2)
               GOTO_DROP;
 8237074:	00814544 	movi	r2,1301
 8237078:	d0a0b215 	stw	r2,-32056(gp)
 823707c:	00029206 	br	8237ac8 <tcp_input+0x22c8>
            }
         } else
            tp->t_dupacks = 0;
 8237080:	e0bfe617 	ldw	r2,-104(fp)
 8237084:	10000915 	stw	zero,36(r2)
         break;
 8237088:	0000da06 	br	82373f4 <tcp_input+0x1bf4>
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 823708c:	0001883a 	nop
                  tp->snd_nxt = onxt;
               GOTO_DROP;
            }
         } else
            tp->t_dupacks = 0;
         break;
 8237090:	0000d806 	br	82373f4 <tcp_input+0x1bf4>
      }
      tp->t_dupacks = 0;
 8237094:	e0bfe617 	ldw	r2,-104(fp)
 8237098:	10000915 	stw	zero,36(r2)
      if (SEQ_GT(ti->ti_ack, tp->snd_max)) 
 823709c:	e0bff217 	ldw	r2,-56(fp)
 82370a0:	10c00717 	ldw	r3,28(r2)
 82370a4:	e0bfe617 	ldw	r2,-104(fp)
 82370a8:	10801a17 	ldw	r2,104(r2)
 82370ac:	1885c83a 	sub	r2,r3,r2
 82370b0:	0080080e 	bge	zero,r2,82370d4 <tcp_input+0x18d4>
      {
         tcpstat.tcps_rcvacktoomuch++;
 82370b4:	008209b4 	movhi	r2,2086
 82370b8:	10b99404 	addi	r2,r2,-6576
 82370bc:	10802a17 	ldw	r2,168(r2)
 82370c0:	10c00044 	addi	r3,r2,1
 82370c4:	008209b4 	movhi	r2,2086
 82370c8:	10b99404 	addi	r2,r2,-6576
 82370cc:	10c02a15 	stw	r3,168(r2)
         goto dropafterack;
 82370d0:	00022b06 	br	8237980 <tcp_input+0x2180>
      }
      acked = (int)(ti->ti_ack - tp->snd_una);
 82370d4:	e0bff217 	ldw	r2,-56(fp)
 82370d8:	10c00717 	ldw	r3,28(r2)
 82370dc:	e0bfe617 	ldw	r2,-104(fp)
 82370e0:	10800e17 	ldw	r2,56(r2)
 82370e4:	1885c83a 	sub	r2,r3,r2
 82370e8:	e0bff615 	stw	r2,-40(fp)
      tcpstat.tcps_rcvackpack++;
 82370ec:	008209b4 	movhi	r2,2086
 82370f0:	10b99404 	addi	r2,r2,-6576
 82370f4:	10802b17 	ldw	r2,172(r2)
 82370f8:	10c00044 	addi	r3,r2,1
 82370fc:	008209b4 	movhi	r2,2086
 8237100:	10b99404 	addi	r2,r2,-6576
 8237104:	10c02b15 	stw	r3,172(r2)
      tcpstat.tcps_rcvackbyte += acked;
 8237108:	008209b4 	movhi	r2,2086
 823710c:	10b99404 	addi	r2,r2,-6576
 8237110:	10c02c17 	ldw	r3,176(r2)
 8237114:	e0bff617 	ldw	r2,-40(fp)
 8237118:	1887883a 	add	r3,r3,r2
 823711c:	008209b4 	movhi	r2,2086
 8237120:	10b99404 	addi	r2,r2,-6576
 8237124:	10c02c15 	stw	r3,176(r2)
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 8237128:	e0bfe617 	ldw	r2,-104(fp)
 823712c:	10801e17 	ldw	r2,120(r2)
 8237130:	10000826 	beq	r2,zero,8237154 <tcp_input+0x1954>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
 8237134:	e0bff217 	ldw	r2,-56(fp)
 8237138:	10c00717 	ldw	r3,28(r2)
 823713c:	e0bfe617 	ldw	r2,-104(fp)
 8237140:	10801f17 	ldw	r2,124(r2)
 8237144:	1885c83a 	sub	r2,r3,r2
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 8237148:	0080020e 	bge	zero,r2,8237154 <tcp_input+0x1954>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
         tcp_xmit_timer(tp);
 823714c:	e13fe617 	ldw	r4,-104(fp)
 8237150:	8237de40 	call	8237de4 <tcp_xmit_timer>
       * If all outstanding data is acked, stop retransmit
       * timer and remember to restart (more output or persist).
       * If there is more data to be acked, restart retransmit
       * timer, using current (possibly backed-off) value.
       */
      if (ti->ti_ack == tp->snd_max) 
 8237154:	e0bff217 	ldw	r2,-56(fp)
 8237158:	10c00717 	ldw	r3,28(r2)
 823715c:	e0bfe617 	ldw	r2,-104(fp)
 8237160:	10801a17 	ldw	r2,104(r2)
 8237164:	1880051e 	bne	r3,r2,823717c <tcp_input+0x197c>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 8237168:	e0bfe617 	ldw	r2,-104(fp)
 823716c:	10000315 	stw	zero,12(r2)
         needoutput = 1;
 8237170:	00800044 	movi	r2,1
 8237174:	e0bfeb15 	stw	r2,-84(fp)
 8237178:	00000706 	br	8237198 <tcp_input+0x1998>
      } else if (tp->t_timer[TCPT_PERSIST] == 0)
 823717c:	e0bfe617 	ldw	r2,-104(fp)
 8237180:	10800417 	ldw	r2,16(r2)
 8237184:	1000041e 	bne	r2,zero,8237198 <tcp_input+0x1998>
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 8237188:	e0bfe617 	ldw	r2,-104(fp)
 823718c:	10c00817 	ldw	r3,32(r2)
 8237190:	e0bfe617 	ldw	r2,-104(fp)
 8237194:	10c00315 	stw	r3,12(r2)
       * in flight, open exponentially (maxseg per packet).
       * Otherwise open linearly (maxseg per window,
       * or maxseg^2 / cwnd per packet).
       */
      {
         tcp_win  cw =  tp->snd_cwnd;
 8237198:	e0bfe617 	ldw	r2,-104(fp)
 823719c:	10801b17 	ldw	r2,108(r2)
 82371a0:	e0bff915 	stw	r2,-28(fp)
         u_short  incr  =  tp->t_maxseg;
 82371a4:	e0bfe617 	ldw	r2,-104(fp)
 82371a8:	10800a0b 	ldhu	r2,40(r2)
 82371ac:	e0bff08d 	sth	r2,-62(fp)

         if (cw > tp->snd_ssthresh)
 82371b0:	e0bfe617 	ldw	r2,-104(fp)
 82371b4:	10c01c17 	ldw	r3,112(r2)
 82371b8:	e0bff917 	ldw	r2,-28(fp)
 82371bc:	18800a2e 	bgeu	r3,r2,82371e8 <tcp_input+0x19e8>
            incr = MAX( (incr * incr / cw), (ALIGN_TYPE << 2) );
 82371c0:	e0fff08b 	ldhu	r3,-62(fp)
 82371c4:	e0bff08b 	ldhu	r2,-62(fp)
 82371c8:	1885383a 	mul	r2,r3,r2
 82371cc:	e17ff917 	ldw	r5,-28(fp)
 82371d0:	1009883a 	mov	r4,r2
 82371d4:	8202b8c0 	call	8202b8c <__udivsi3>
 82371d8:	10c00428 	cmpgeui	r3,r2,16
 82371dc:	1800011e 	bne	r3,zero,82371e4 <tcp_input+0x19e4>
 82371e0:	00800404 	movi	r2,16
 82371e4:	e0bff08d 	sth	r2,-62(fp)

         tp->snd_cwnd = MIN(cw + (u_short)incr, (IP_MAXPACKET));
 82371e8:	e0fff08b 	ldhu	r3,-62(fp)
 82371ec:	e0bff917 	ldw	r2,-28(fp)
 82371f0:	1885883a 	add	r2,r3,r2
 82371f4:	10d80070 	cmpltui	r3,r2,24577
 82371f8:	1800011e 	bne	r3,zero,8237200 <tcp_input+0x1a00>
 82371fc:	00980004 	movi	r2,24576
 8237200:	e0ffe617 	ldw	r3,-104(fp)
 8237204:	18801b15 	stw	r2,108(r3)
      }
      if (acked > (int)so->so_snd.sb_cc) 
 8237208:	e0bfe817 	ldw	r2,-96(fp)
 823720c:	10801217 	ldw	r2,72(r2)
 8237210:	1007883a 	mov	r3,r2
 8237214:	e0bff617 	ldw	r2,-40(fp)
 8237218:	1880120e 	bge	r3,r2,8237264 <tcp_input+0x1a64>
      {
         tp->snd_wnd -= (u_short)so->so_snd.sb_cc;
 823721c:	e0bfe617 	ldw	r2,-104(fp)
 8237220:	10c01417 	ldw	r3,80(r2)
 8237224:	e0bfe817 	ldw	r2,-96(fp)
 8237228:	10801217 	ldw	r2,72(r2)
 823722c:	10bfffcc 	andi	r2,r2,65535
 8237230:	1887c83a 	sub	r3,r3,r2
 8237234:	e0bfe617 	ldw	r2,-104(fp)
 8237238:	10c01415 	stw	r3,80(r2)
         sbdrop(&so->so_snd, (int)so->so_snd.sb_cc);
 823723c:	e0bfe817 	ldw	r2,-96(fp)
 8237240:	10c01204 	addi	r3,r2,72
 8237244:	e0bfe817 	ldw	r2,-96(fp)
 8237248:	10801217 	ldw	r2,72(r2)
 823724c:	100b883a 	mov	r5,r2
 8237250:	1809883a 	mov	r4,r3
 8237254:	823482c0 	call	823482c <sbdrop>
         ourfinisacked = 1;
 8237258:	00800044 	movi	r2,1
 823725c:	e0bfea15 	stw	r2,-88(fp)
 8237260:	00000d06 	br	8237298 <tcp_input+0x1a98>
      } 
      else 
      {
         sbdrop(&so->so_snd, acked);
 8237264:	e0bfe817 	ldw	r2,-96(fp)
 8237268:	10801204 	addi	r2,r2,72
 823726c:	e17ff617 	ldw	r5,-40(fp)
 8237270:	1009883a 	mov	r4,r2
 8237274:	823482c0 	call	823482c <sbdrop>
         tp->snd_wnd -= (u_short)acked;
 8237278:	e0bfe617 	ldw	r2,-104(fp)
 823727c:	10c01417 	ldw	r3,80(r2)
 8237280:	e0bff617 	ldw	r2,-40(fp)
 8237284:	10bfffcc 	andi	r2,r2,65535
 8237288:	1887c83a 	sub	r3,r3,r2
 823728c:	e0bfe617 	ldw	r2,-104(fp)
 8237290:	10c01415 	stw	r3,80(r2)
         ourfinisacked = 0;
 8237294:	e03fea15 	stw	zero,-88(fp)
      }

      if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 8237298:	e0bfe817 	ldw	r2,-96(fp)
 823729c:	1080190b 	ldhu	r2,100(r2)
 82372a0:	10bfffcc 	andi	r2,r2,65535
 82372a4:	1080030c 	andi	r2,r2,12
 82372a8:	10000526 	beq	r2,zero,82372c0 <tcp_input+0x1ac0>
         sowwakeup(so);
 82372ac:	e0bfe817 	ldw	r2,-96(fp)
 82372b0:	10801204 	addi	r2,r2,72
 82372b4:	100b883a 	mov	r5,r2
 82372b8:	e13fe817 	ldw	r4,-96(fp)
 82372bc:	82340c40 	call	82340c4 <sbwakeup>

      tp->snd_una = ti->ti_ack;
 82372c0:	e0bff217 	ldw	r2,-56(fp)
 82372c4:	10c00717 	ldw	r3,28(r2)
 82372c8:	e0bfe617 	ldw	r2,-104(fp)
 82372cc:	10c00e15 	stw	r3,56(r2)
      if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 82372d0:	e0bfe617 	ldw	r2,-104(fp)
 82372d4:	10c00f17 	ldw	r3,60(r2)
 82372d8:	e0bfe617 	ldw	r2,-104(fp)
 82372dc:	10800e17 	ldw	r2,56(r2)
 82372e0:	1885c83a 	sub	r2,r3,r2
 82372e4:	1000040e 	bge	r2,zero,82372f8 <tcp_input+0x1af8>
         tp->snd_nxt = tp->snd_una;
 82372e8:	e0bfe617 	ldw	r2,-104(fp)
 82372ec:	10c00e17 	ldw	r3,56(r2)
 82372f0:	e0bfe617 	ldw	r2,-104(fp)
 82372f4:	10c00f15 	stw	r3,60(r2)


      switch (tp->t_state) 
 82372f8:	e0bfe617 	ldw	r2,-104(fp)
 82372fc:	10800217 	ldw	r2,8(r2)
 8237300:	10c001e0 	cmpeqi	r3,r2,7
 8237304:	18001a1e 	bne	r3,zero,8237370 <tcp_input+0x1b70>
 8237308:	10c00208 	cmpgei	r3,r2,8
 823730c:	1800031e 	bne	r3,zero,823731c <tcp_input+0x1b1c>
 8237310:	108001a0 	cmpeqi	r2,r2,6
 8237314:	1000061e 	bne	r2,zero,8237330 <tcp_input+0x1b30>
 8237318:	00003606 	br	82373f4 <tcp_input+0x1bf4>
 823731c:	10c00220 	cmpeqi	r3,r2,8
 8237320:	1800221e 	bne	r3,zero,82373ac <tcp_input+0x1bac>
 8237324:	108002a0 	cmpeqi	r2,r2,10
 8237328:	1000271e 	bne	r2,zero,82373c8 <tcp_input+0x1bc8>
 823732c:	00003106 	br	82373f4 <tcp_input+0x1bf4>
       * In FIN_WAIT_1 STATE in addition to the processing
       * for the ESTABLISHED state if our FIN is now acknowledged
       * then enter FIN_WAIT_2.
       */
      case TCPS_FIN_WAIT_1:
         if (ourfinisacked) 
 8237330:	e0bfea17 	ldw	r2,-88(fp)
 8237334:	10002a26 	beq	r2,zero,82373e0 <tcp_input+0x1be0>
             * data, then closing user can proceed.
             * Starting the timer is contrary to the
             * specification, but if we don't get a FIN
             * we'll hang forever.
             */
            if (so->so_state & SS_CANTRCVMORE) 
 8237338:	e0bfe817 	ldw	r2,-96(fp)
 823733c:	1080088b 	ldhu	r2,34(r2)
 8237340:	10bfffcc 	andi	r2,r2,65535
 8237344:	1080080c 	andi	r2,r2,32
 8237348:	10000526 	beq	r2,zero,8237360 <tcp_input+0x1b60>
            {
               soisdisconnected(so);
 823734c:	e13fe817 	ldw	r4,-96(fp)
 8237350:	8233af40 	call	8233af4 <soisdisconnected>
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
 8237354:	d0e0b417 	ldw	r3,-32048(gp)
 8237358:	e0bfe617 	ldw	r2,-104(fp)
 823735c:	10c00615 	stw	r3,24(r2)
            }
            tp->t_state = TCPS_FIN_WAIT_2;
 8237360:	e0bfe617 	ldw	r2,-104(fp)
 8237364:	00c00244 	movi	r3,9
 8237368:	10c00215 	stw	r3,8(r2)
         }
         break;
 823736c:	00001c06 	br	82373e0 <tcp_input+0x1be0>
       * the ESTABLISHED state if the ACK acknowledges our FIN
       * then enter the TIME-WAIT state, otherwise ignore
       * the segment.
       */
      case TCPS_CLOSING:
         if (ourfinisacked) 
 8237370:	e0bfea17 	ldw	r2,-88(fp)
 8237374:	10001c26 	beq	r2,zero,82373e8 <tcp_input+0x1be8>
         {
            tp->t_state = TCPS_TIME_WAIT;
 8237378:	e0bfe617 	ldw	r2,-104(fp)
 823737c:	00c00284 	movi	r3,10
 8237380:	10c00215 	stw	r3,8(r2)
            tcp_canceltimers(tp);
 8237384:	e13fe617 	ldw	r4,-104(fp)
 8237388:	8239ee80 	call	8239ee8 <tcp_canceltimers>
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 823738c:	d0a03b17 	ldw	r2,-32532(gp)
 8237390:	1085883a 	add	r2,r2,r2
 8237394:	1007883a 	mov	r3,r2
 8237398:	e0bfe617 	ldw	r2,-104(fp)
 823739c:	10c00615 	stw	r3,24(r2)
            soisdisconnected(so);
 82373a0:	e13fe817 	ldw	r4,-96(fp)
 82373a4:	8233af40 	call	8233af4 <soisdisconnected>
         }
         break;
 82373a8:	00000f06 	br	82373e8 <tcp_input+0x1be8>
       * and/or to be acked, as well as for the ack of our FIN.
       * If our FIN is now acknowledged, delete the TCB,
       * enter the closed state and return.
       */
      case TCPS_LAST_ACK:
         if (ourfinisacked) 
 82373ac:	e0bfea17 	ldw	r2,-88(fp)
 82373b0:	10000f26 	beq	r2,zero,82373f0 <tcp_input+0x1bf0>
         {
            SETTP(tp, tcp_close(tp));
 82373b4:	e13fe617 	ldw	r4,-104(fp)
 82373b8:	8239a500 	call	8239a50 <tcp_close>
            GOTO_DROP;
 82373bc:	00816644 	movi	r2,1433
 82373c0:	d0a0b215 	stw	r2,-32056(gp)
 82373c4:	0001c006 	br	8237ac8 <tcp_input+0x22c8>
       * In TIME_WAIT state the only thing that should arrive
       * is a retransmission of the remote FIN.  Acknowledge
       * it and restart the finack timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 82373c8:	d0a03b17 	ldw	r2,-32532(gp)
 82373cc:	1085883a 	add	r2,r2,r2
 82373d0:	1007883a 	mov	r3,r2
 82373d4:	e0bfe617 	ldw	r2,-104(fp)
 82373d8:	10c00615 	stw	r3,24(r2)
         goto dropafterack;
 82373dc:	00016806 	br	8237980 <tcp_input+0x2180>
               soisdisconnected(so);
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
            }
            tp->t_state = TCPS_FIN_WAIT_2;
         }
         break;
 82373e0:	0001883a 	nop
 82373e4:	00000306 	br	82373f4 <tcp_input+0x1bf4>
            tp->t_state = TCPS_TIME_WAIT;
            tcp_canceltimers(tp);
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
            soisdisconnected(so);
         }
         break;
 82373e8:	0001883a 	nop
 82373ec:	00000106 	br	82373f4 <tcp_input+0x1bf4>
         if (ourfinisacked) 
         {
            SETTP(tp, tcp_close(tp));
            GOTO_DROP;
         }
         break;
 82373f0:	0001883a 	nop
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 82373f4:	e0bfe717 	ldw	r2,-100(fp)
 82373f8:	1080040c 	andi	r2,r2,16
 82373fc:	10004426 	beq	r2,zero,8237510 <tcp_input+0x1d10>
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 8237400:	e0bfe617 	ldw	r2,-104(fp)
 8237404:	10c01117 	ldw	r3,68(r2)
 8237408:	e0bff217 	ldw	r2,-56(fp)
 823740c:	10800617 	ldw	r2,24(r2)
 8237410:	1885c83a 	sub	r2,r3,r2
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 8237414:	10001416 	blt	r2,zero,8237468 <tcp_input+0x1c68>
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 8237418:	e0bfe617 	ldw	r2,-104(fp)
 823741c:	10c01117 	ldw	r3,68(r2)
 8237420:	e0bff217 	ldw	r2,-56(fp)
 8237424:	10800617 	ldw	r2,24(r2)
 8237428:	1880391e 	bne	r3,r2,8237510 <tcp_input+0x1d10>
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
 823742c:	e0bfe617 	ldw	r2,-104(fp)
 8237430:	10c01217 	ldw	r3,72(r2)
 8237434:	e0bff217 	ldw	r2,-56(fp)
 8237438:	10800717 	ldw	r2,28(r2)
 823743c:	1885c83a 	sub	r2,r3,r2
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 8237440:	10000916 	blt	r2,zero,8237468 <tcp_input+0x1c68>
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
 8237444:	e0bfe617 	ldw	r2,-104(fp)
 8237448:	10c01217 	ldw	r3,72(r2)
 823744c:	e0bff217 	ldw	r2,-56(fp)
 8237450:	10800717 	ldw	r2,28(r2)
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
 8237454:	18802e1e 	bne	r3,r2,8237510 <tcp_input+0x1d10>
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
 8237458:	e0bfe617 	ldw	r2,-104(fp)
 823745c:	10c01417 	ldw	r3,80(r2)
 8237460:	e0bff517 	ldw	r2,-44(fp)
 8237464:	18802a2e 	bgeu	r3,r2,8237510 <tcp_input+0x1d10>
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 8237468:	e0bff217 	ldw	r2,-56(fp)
 823746c:	1080028b 	ldhu	r2,10(r2)
 8237470:	10bfffcc 	andi	r2,r2,65535
 8237474:	1000101e 	bne	r2,zero,82374b8 <tcp_input+0x1cb8>
          (tp->snd_wl2 == ti->ti_ack) &&
 8237478:	e0bfe617 	ldw	r2,-104(fp)
 823747c:	10c01217 	ldw	r3,72(r2)
 8237480:	e0bff217 	ldw	r2,-56(fp)
 8237484:	10800717 	ldw	r2,28(r2)
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 8237488:	18800b1e 	bne	r3,r2,82374b8 <tcp_input+0x1cb8>
          (tp->snd_wl2 == ti->ti_ack) &&
          (rx_win > tp->snd_wnd))
 823748c:	e0bfe617 	ldw	r2,-104(fp)
 8237490:	10c01417 	ldw	r3,80(r2)
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
          (tp->snd_wl2 == ti->ti_ack) &&
 8237494:	e0bff517 	ldw	r2,-44(fp)
 8237498:	1880072e 	bgeu	r3,r2,82374b8 <tcp_input+0x1cb8>
          (rx_win > tp->snd_wnd))
      {
         tcpstat.tcps_rcvwinupd++;
 823749c:	008209b4 	movhi	r2,2086
 82374a0:	10b99404 	addi	r2,r2,-6576
 82374a4:	10802d17 	ldw	r2,180(r2)
 82374a8:	10c00044 	addi	r3,r2,1
 82374ac:	008209b4 	movhi	r2,2086
 82374b0:	10b99404 	addi	r2,r2,-6576
 82374b4:	10c02d15 	stw	r3,180(r2)
      }
      tp->snd_wnd = rx_win;
 82374b8:	e0bfe617 	ldw	r2,-104(fp)
 82374bc:	e0fff517 	ldw	r3,-44(fp)
 82374c0:	10c01415 	stw	r3,80(r2)
      tp->snd_wl1 = ti->ti_seq;
 82374c4:	e0bff217 	ldw	r2,-56(fp)
 82374c8:	10c00617 	ldw	r3,24(r2)
 82374cc:	e0bfe617 	ldw	r2,-104(fp)
 82374d0:	10c01115 	stw	r3,68(r2)
      tp->snd_wl2 = ti->ti_ack;
 82374d4:	e0bff217 	ldw	r2,-56(fp)
 82374d8:	10c00717 	ldw	r3,28(r2)
 82374dc:	e0bfe617 	ldw	r2,-104(fp)
 82374e0:	10c01215 	stw	r3,72(r2)
      if (tp->snd_wnd > tp->max_sndwnd)
 82374e4:	e0bfe617 	ldw	r2,-104(fp)
 82374e8:	10801417 	ldw	r2,80(r2)
 82374ec:	e0ffe617 	ldw	r3,-104(fp)
 82374f0:	18c02317 	ldw	r3,140(r3)
 82374f4:	1880042e 	bgeu	r3,r2,8237508 <tcp_input+0x1d08>
         tp->max_sndwnd = tp->snd_wnd;
 82374f8:	e0bfe617 	ldw	r2,-104(fp)
 82374fc:	10c01417 	ldw	r3,80(r2)
 8237500:	e0bfe617 	ldw	r2,-104(fp)
 8237504:	10c02315 	stw	r3,140(r2)
      needoutput = 1;
 8237508:	00800044 	movi	r2,1
 823750c:	e0bfeb15 	stw	r2,-84(fp)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 8237510:	e0bfe717 	ldw	r2,-100(fp)
 8237514:	1080080c 	andi	r2,r2,32
 8237518:	10005626 	beq	r2,zero,8237674 <tcp_input+0x1e74>
 823751c:	e0bff217 	ldw	r2,-56(fp)
 8237520:	1080098b 	ldhu	r2,38(r2)
 8237524:	10bfffcc 	andi	r2,r2,65535
 8237528:	10005226 	beq	r2,zero,8237674 <tcp_input+0x1e74>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 823752c:	e0bfe617 	ldw	r2,-104(fp)
 8237530:	10800217 	ldw	r2,8(r2)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 8237534:	10800288 	cmpgei	r2,r2,10
 8237538:	10004e1e 	bne	r2,zero,8237674 <tcp_input+0x1e74>
       * This is a kludge, but if we receive and accept
       * random urgent pointers, we'll crash in
       * soreceive.  It's hard to imagine someone
       * actually wanting to send this much urgent data.
       */
      if (ti->ti_urp + so->so_rcv.sb_cc > SB_MAX) 
 823753c:	e0bff217 	ldw	r2,-56(fp)
 8237540:	1080098b 	ldhu	r2,38(r2)
 8237544:	10ffffcc 	andi	r3,r2,65535
 8237548:	e0bfe817 	ldw	r2,-96(fp)
 823754c:	10800a17 	ldw	r2,40(r2)
 8237550:	1885883a 	add	r2,r3,r2
 8237554:	10900070 	cmpltui	r2,r2,16385
 8237558:	1000071e 	bne	r2,zero,8237578 <tcp_input+0x1d78>
      {
         ti->ti_urp = 0;         /* XXX */
 823755c:	e0bff217 	ldw	r2,-56(fp)
 8237560:	1000098d 	sth	zero,38(r2)
         tiflags &= ~TH_URG;     /* XXX */
 8237564:	e0ffe717 	ldw	r3,-100(fp)
 8237568:	00bff7c4 	movi	r2,-33
 823756c:	1884703a 	and	r2,r3,r2
 8237570:	e0bfe715 	stw	r2,-100(fp)
         goto dodata;         /* XXX */
 8237574:	00004b06 	br	82376a4 <tcp_input+0x1ea4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
 8237578:	e0bff217 	ldw	r2,-56(fp)
 823757c:	10c00617 	ldw	r3,24(r2)
 8237580:	e0bff217 	ldw	r2,-56(fp)
 8237584:	1080098b 	ldhu	r2,38(r2)
 8237588:	10bfffcc 	andi	r2,r2,65535
 823758c:	1887883a 	add	r3,r3,r2
 8237590:	e0bfe617 	ldw	r2,-104(fp)
 8237594:	10801717 	ldw	r2,92(r2)
 8237598:	1885c83a 	sub	r2,r3,r2
 823759c:	0080250e 	bge	zero,r2,8237634 <tcp_input+0x1e34>
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
 82375a0:	e0bff217 	ldw	r2,-56(fp)
 82375a4:	10c00617 	ldw	r3,24(r2)
 82375a8:	e0bff217 	ldw	r2,-56(fp)
 82375ac:	1080098b 	ldhu	r2,38(r2)
 82375b0:	10bfffcc 	andi	r2,r2,65535
 82375b4:	1887883a 	add	r3,r3,r2
 82375b8:	e0bfe617 	ldw	r2,-104(fp)
 82375bc:	10c01715 	stw	r3,92(r2)
         so->so_oobmark = so->so_rcv.sb_cc +
 82375c0:	e0bfe817 	ldw	r2,-96(fp)
 82375c4:	10c00a17 	ldw	r3,40(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
 82375c8:	e0bfe617 	ldw	r2,-104(fp)
 82375cc:	11001717 	ldw	r4,92(r2)
 82375d0:	e0bfe617 	ldw	r2,-104(fp)
 82375d4:	10801617 	ldw	r2,88(r2)
 82375d8:	2085c83a 	sub	r2,r4,r2
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
         so->so_oobmark = so->so_rcv.sb_cc +
 82375dc:	1885883a 	add	r2,r3,r2
         (tp->rcv_up - tp->rcv_nxt) - 1;
 82375e0:	10ffffc4 	addi	r3,r2,-1
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
         so->so_oobmark = so->so_rcv.sb_cc +
 82375e4:	e0bfe817 	ldw	r2,-96(fp)
 82375e8:	10c01a15 	stw	r3,104(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
         if (so->so_oobmark == 0)
 82375ec:	e0bfe817 	ldw	r2,-96(fp)
 82375f0:	10801a17 	ldw	r2,104(r2)
 82375f4:	1000061e 	bne	r2,zero,8237610 <tcp_input+0x1e10>
            so->so_state |= SS_RCVATMARK;
 82375f8:	e0bfe817 	ldw	r2,-96(fp)
 82375fc:	1080088b 	ldhu	r2,34(r2)
 8237600:	10801014 	ori	r2,r2,64
 8237604:	1007883a 	mov	r3,r2
 8237608:	e0bfe817 	ldw	r2,-96(fp)
 823760c:	10c0088d 	sth	r3,34(r2)
         sohasoutofband(so);
 8237610:	e13fe817 	ldw	r4,-96(fp)
 8237614:	823389c0 	call	823389c <sohasoutofband>
         tp->t_oobflags &= ~(TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 8237618:	e0bfe617 	ldw	r2,-104(fp)
 823761c:	10c02403 	ldbu	r3,144(r2)
 8237620:	00bfff04 	movi	r2,-4
 8237624:	1884703a 	and	r2,r3,r2
 8237628:	1007883a 	mov	r3,r2
 823762c:	e0bfe617 	ldw	r2,-104(fp)
 8237630:	10c02405 	stb	r3,144(r2)
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 8237634:	e0bff217 	ldw	r2,-56(fp)
 8237638:	1100098b 	ldhu	r4,38(r2)
 823763c:	e0bff217 	ldw	r2,-56(fp)
 8237640:	10c0028b 	ldhu	r3,10(r2)
 8237644:	20bfffcc 	andi	r2,r4,65535
 8237648:	18ffffcc 	andi	r3,r3,65535
 823764c:	18801436 	bltu	r3,r2,82376a0 <tcp_input+0x1ea0>
#ifdef SO_OOBINLINE
       && (so->so_options & SO_OOBINLINE) == 0
 8237650:	e0bfe817 	ldw	r2,-96(fp)
 8237654:	10800417 	ldw	r2,16(r2)
 8237658:	1080400c 	andi	r2,r2,256
 823765c:	1000101e 	bne	r2,zero,82376a0 <tcp_input+0x1ea0>
#endif
       )
      {
         tcp_pulloutofband(so, ti, m);
 8237660:	e1bffe17 	ldw	r6,-8(fp)
 8237664:	e17ff217 	ldw	r5,-56(fp)
 8237668:	e13fe817 	ldw	r4,-96(fp)
 823766c:	8237cb80 	call	8237cb8 <tcp_pulloutofband>
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 8237670:	00000b06 	br	82376a0 <tcp_input+0x1ea0>
      /*
       * If no out of band data is expected,
       * pull receive urgent pointer along
       * with the receive window.
       */
   if (SEQ_GT(tp->rcv_nxt, tp->rcv_up))
 8237674:	e0bfe617 	ldw	r2,-104(fp)
 8237678:	10c01617 	ldw	r3,88(r2)
 823767c:	e0bfe617 	ldw	r2,-104(fp)
 8237680:	10801717 	ldw	r2,92(r2)
 8237684:	1885c83a 	sub	r2,r3,r2
 8237688:	0080060e 	bge	zero,r2,82376a4 <tcp_input+0x1ea4>
      tp->rcv_up = tp->rcv_nxt;
 823768c:	e0bfe617 	ldw	r2,-104(fp)
 8237690:	10c01617 	ldw	r3,88(r2)
 8237694:	e0bfe617 	ldw	r2,-104(fp)
 8237698:	10c01715 	stw	r3,92(r2)
 823769c:	00000106 	br	82376a4 <tcp_input+0x1ea4>
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 82376a0:	0001883a 	nop
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 82376a4:	e0bff217 	ldw	r2,-56(fp)
 82376a8:	1080028b 	ldhu	r2,10(r2)
 82376ac:	10bfffcc 	andi	r2,r2,65535
 82376b0:	1000031e 	bne	r2,zero,82376c0 <tcp_input+0x1ec0>
 82376b4:	e0bfe717 	ldw	r2,-100(fp)
 82376b8:	1080004c 	andi	r2,r2,1
 82376bc:	10005e26 	beq	r2,zero,8237838 <tcp_input+0x2038>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 82376c0:	e0bfe617 	ldw	r2,-104(fp)
 82376c4:	10800217 	ldw	r2,8(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 82376c8:	10800288 	cmpgei	r2,r2,10
 82376cc:	10005a1e 	bne	r2,zero,8237838 <tcp_input+0x2038>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 82376d0:	e0bff217 	ldw	r2,-56(fp)
 82376d4:	10c00617 	ldw	r3,24(r2)
 82376d8:	e0bfe617 	ldw	r2,-104(fp)
 82376dc:	10801617 	ldw	r2,88(r2)
 82376e0:	1880371e 	bne	r3,r2,82377c0 <tcp_input+0x1fc0>
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
 82376e4:	e0bfe617 	ldw	r2,-104(fp)
 82376e8:	10c00017 	ldw	r3,0(r2)
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 82376ec:	e0bfe617 	ldw	r2,-104(fp)
 82376f0:	1880331e 	bne	r3,r2,82377c0 <tcp_input+0x1fc0>
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
         (tp->t_state == TCPS_ESTABLISHED))
 82376f4:	e0bfe617 	ldw	r2,-104(fp)
 82376f8:	10800217 	ldw	r2,8(r2)
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
 82376fc:	10800118 	cmpnei	r2,r2,4
 8237700:	10002f1e 	bne	r2,zero,82377c0 <tcp_input+0x1fc0>
         else
         {
            tp->t_flags |= TF_ACKNOW;
         }
#else    /* not DO_DELAY_ACKS */
            tp->t_flags |= TF_ACKNOW;
 8237704:	e0bfe617 	ldw	r2,-104(fp)
 8237708:	10800b0b 	ldhu	r2,44(r2)
 823770c:	10800054 	ori	r2,r2,1
 8237710:	1007883a 	mov	r3,r2
 8237714:	e0bfe617 	ldw	r2,-104(fp)
 8237718:	10c00b0d 	sth	r3,44(r2)
#endif   /* DO_DELAY_ACKS */

         tp->rcv_nxt += ti->ti_len;
 823771c:	e0bfe617 	ldw	r2,-104(fp)
 8237720:	10c01617 	ldw	r3,88(r2)
 8237724:	e0bff217 	ldw	r2,-56(fp)
 8237728:	1080028b 	ldhu	r2,10(r2)
 823772c:	10bfffcc 	andi	r2,r2,65535
 8237730:	1887883a 	add	r3,r3,r2
 8237734:	e0bfe617 	ldw	r2,-104(fp)
 8237738:	10c01615 	stw	r3,88(r2)
         tiflags = ti->ti_flags & TH_FIN;
 823773c:	e0bff217 	ldw	r2,-56(fp)
 8237740:	10800843 	ldbu	r2,33(r2)
 8237744:	10803fcc 	andi	r2,r2,255
 8237748:	1080004c 	andi	r2,r2,1
 823774c:	e0bfe715 	stw	r2,-100(fp)
         tcpstat.tcps_rcvpack++;
 8237750:	008209b4 	movhi	r2,2086
 8237754:	10b99404 	addi	r2,r2,-6576
 8237758:	10801a17 	ldw	r2,104(r2)
 823775c:	10c00044 	addi	r3,r2,1
 8237760:	008209b4 	movhi	r2,2086
 8237764:	10b99404 	addi	r2,r2,-6576
 8237768:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 823776c:	008209b4 	movhi	r2,2086
 8237770:	10b99404 	addi	r2,r2,-6576
 8237774:	10c01b17 	ldw	r3,108(r2)
 8237778:	e0bff217 	ldw	r2,-56(fp)
 823777c:	1080028b 	ldhu	r2,10(r2)
 8237780:	10bfffcc 	andi	r2,r2,65535
 8237784:	1887883a 	add	r3,r3,r2
 8237788:	008209b4 	movhi	r2,2086
 823778c:	10b99404 	addi	r2,r2,-6576
 8237790:	10c01b15 	stw	r3,108(r2)
         sbappend(&so->so_rcv, (m));
 8237794:	e0bfe817 	ldw	r2,-96(fp)
 8237798:	10800a04 	addi	r2,r2,40
 823779c:	e17ffe17 	ldw	r5,-8(fp)
 82377a0:	1009883a 	mov	r4,r2
 82377a4:	82342740 	call	8234274 <sbappend>
         sorwakeup(so);
 82377a8:	e0bfe817 	ldw	r2,-96(fp)
 82377ac:	10800a04 	addi	r2,r2,40
 82377b0:	100b883a 	mov	r5,r2
 82377b4:	e13fe817 	ldw	r4,-96(fp)
 82377b8:	82340c40 	call	82340c4 <sbwakeup>
 82377bc:	00000b06 	br	82377ec <tcp_input+0x1fec>
#endif /* TCP_SACK */
      }
      else     /* received out of sequence segment */
      {
         /* Drop it in the reassmbly queue */
         tiflags = tcp_reass(tp, ti, m);
 82377c0:	e1bffe17 	ldw	r6,-8(fp)
 82377c4:	e17ff217 	ldw	r5,-56(fp)
 82377c8:	e13fe617 	ldw	r4,-104(fp)
 82377cc:	82353f00 	call	82353f0 <tcp_reass>
 82377d0:	e0bfe715 	stw	r2,-100(fp)
         tp->t_flags |= TF_ACKNOW;
 82377d4:	e0bfe617 	ldw	r2,-104(fp)
 82377d8:	10800b0b 	ldhu	r2,44(r2)
 82377dc:	10800054 	ori	r2,r2,1
 82377e0:	1007883a 	mov	r3,r2
 82377e4:	e0bfe617 	ldw	r2,-104(fp)
 82377e8:	10c00b0d 	sth	r3,44(r2)
      /*
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
 82377ec:	e0bfe817 	ldw	r2,-96(fp)
 82377f0:	10c00b17 	ldw	r3,44(r2)
 82377f4:	e0bfe617 	ldw	r2,-104(fp)
 82377f8:	11001617 	ldw	r4,88(r2)
 82377fc:	e0bfe617 	ldw	r2,-104(fp)
 8237800:	10801917 	ldw	r2,100(r2)
 8237804:	2085c83a 	sub	r2,r4,r2
 8237808:	1885883a 	add	r2,r3,r2
 823780c:	e0bffc15 	stw	r2,-16(fp)
      if (len > (int)tp->max_rcvd)
 8237810:	e0bfe617 	ldw	r2,-104(fp)
 8237814:	10802217 	ldw	r2,136(r2)
 8237818:	1007883a 	mov	r3,r2
 823781c:	e0bffc17 	ldw	r2,-16(fp)
 8237820:	18800b0e 	bge	r3,r2,8237850 <tcp_input+0x2050>
         tp->max_rcvd = (u_short)len;
 8237824:	e0bffc17 	ldw	r2,-16(fp)
 8237828:	10ffffcc 	andi	r3,r2,65535
 823782c:	e0bfe617 	ldw	r2,-104(fp)
 8237830:	10c02215 	stw	r3,136(r2)
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
      if (len > (int)tp->max_rcvd)
 8237834:	00000606 	br	8237850 <tcp_input+0x2050>
      }
#endif   /* TCP_ZEROCOPY */
   } 
   else
   {
      m_freem(m);
 8237838:	e13ffe17 	ldw	r4,-8(fp)
 823783c:	822e4b80 	call	822e4b8 <m_freem>
      tiflags &= ~TH_FIN;
 8237840:	e0ffe717 	ldw	r3,-100(fp)
 8237844:	00bfff84 	movi	r2,-2
 8237848:	1884703a 	and	r2,r3,r2
 823784c:	e0bfe715 	stw	r2,-100(fp)

   /*
    * If FIN is received ACK the FIN and let the user know
    * that the connection is closing.
    */
   if (tiflags & TH_FIN) 
 8237850:	e0bfe717 	ldw	r2,-100(fp)
 8237854:	1080004c 	andi	r2,r2,1
 8237858:	10003f26 	beq	r2,zero,8237958 <tcp_input+0x2158>
   {
      if (TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 823785c:	e0bfe617 	ldw	r2,-104(fp)
 8237860:	10800217 	ldw	r2,8(r2)
 8237864:	10800288 	cmpgei	r2,r2,10
 8237868:	10000d1e 	bne	r2,zero,82378a0 <tcp_input+0x20a0>
      {
         socantrcvmore(so);
 823786c:	e13fe817 	ldw	r4,-96(fp)
 8237870:	8233fc40 	call	8233fc4 <socantrcvmore>
         tp->t_flags |= TF_ACKNOW;
 8237874:	e0bfe617 	ldw	r2,-104(fp)
 8237878:	10800b0b 	ldhu	r2,44(r2)
 823787c:	10800054 	ori	r2,r2,1
 8237880:	1007883a 	mov	r3,r2
 8237884:	e0bfe617 	ldw	r2,-104(fp)
 8237888:	10c00b0d 	sth	r3,44(r2)
         tp->rcv_nxt++;
 823788c:	e0bfe617 	ldw	r2,-104(fp)
 8237890:	10801617 	ldw	r2,88(r2)
 8237894:	10c00044 	addi	r3,r2,1
 8237898:	e0bfe617 	ldw	r2,-104(fp)
 823789c:	10c01615 	stw	r3,88(r2)
      }
      switch (tp->t_state) 
 82378a0:	e0bfe617 	ldw	r2,-104(fp)
 82378a4:	10800217 	ldw	r2,8(r2)
 82378a8:	10bfff44 	addi	r2,r2,-3
 82378ac:	10c00228 	cmpgeui	r3,r2,8
 82378b0:	1800291e 	bne	r3,zero,8237958 <tcp_input+0x2158>
 82378b4:	100690ba 	slli	r3,r2,2
 82378b8:	008208f4 	movhi	r2,2083
 82378bc:	109e3304 	addi	r2,r2,30924
 82378c0:	1885883a 	add	r2,r3,r2
 82378c4:	10800017 	ldw	r2,0(r2)
 82378c8:	1000683a 	jmp	r2
 82378cc:	082378ec 	andhi	zero,at,36323
 82378d0:	082378ec 	andhi	zero,at,36323
 82378d4:	08237958 	cmpnei	zero,at,-29211
 82378d8:	082378fc 	xorhi	zero,at,36323
 82378dc:	08237958 	cmpnei	zero,at,-29211
 82378e0:	08237958 	cmpnei	zero,at,-29211
 82378e4:	0823790c 	andi	zero,at,36324
 82378e8:	08237940 	call	823794 <OSCtxSw_SWITCH_PC+0x823754>
       * In SYN_RECEIVED and ESTABLISHED STATES
       * enter the CLOSE_WAIT state.
       */
      case TCPS_SYN_RECEIVED:
      case TCPS_ESTABLISHED:
         tp->t_state = TCPS_CLOSE_WAIT;
 82378ec:	e0bfe617 	ldw	r2,-104(fp)
 82378f0:	00c00144 	movi	r3,5
 82378f4:	10c00215 	stw	r3,8(r2)
         break;
 82378f8:	00001706 	br	8237958 <tcp_input+0x2158>
       /*
       * If still in FIN_WAIT_1 STATE FIN has not been acked so
       * enter the CLOSING state.
       */
      case TCPS_FIN_WAIT_1:
         tp->t_state = TCPS_CLOSING;
 82378fc:	e0bfe617 	ldw	r2,-104(fp)
 8237900:	00c001c4 	movi	r3,7
 8237904:	10c00215 	stw	r3,8(r2)
         break;
 8237908:	00001306 	br	8237958 <tcp_input+0x2158>
       * In FIN_WAIT_2 state enter the TIME_WAIT state,
       * starting the time-wait timer, turning off the other 
       * standard timers.
       */
      case TCPS_FIN_WAIT_2:
         tp->t_state = TCPS_TIME_WAIT;
 823790c:	e0bfe617 	ldw	r2,-104(fp)
 8237910:	00c00284 	movi	r3,10
 8237914:	10c00215 	stw	r3,8(r2)
         tcp_canceltimers(tp);
 8237918:	e13fe617 	ldw	r4,-104(fp)
 823791c:	8239ee80 	call	8239ee8 <tcp_canceltimers>
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 8237920:	d0a03b17 	ldw	r2,-32532(gp)
 8237924:	1085883a 	add	r2,r2,r2
 8237928:	1007883a 	mov	r3,r2
 823792c:	e0bfe617 	ldw	r2,-104(fp)
 8237930:	10c00615 	stw	r3,24(r2)
         soisdisconnected(so);
 8237934:	e13fe817 	ldw	r4,-96(fp)
 8237938:	8233af40 	call	8233af4 <soisdisconnected>
         break;
 823793c:	00000606 	br	8237958 <tcp_input+0x2158>

      /*
       * In TIME_WAIT state restart the 2 MSL time_wait timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 8237940:	d0a03b17 	ldw	r2,-32532(gp)
 8237944:	1085883a 	add	r2,r2,r2
 8237948:	1007883a 	mov	r3,r2
 823794c:	e0bfe617 	ldw	r2,-104(fp)
 8237950:	10c00615 	stw	r3,24(r2)
         break;
 8237954:	0001883a 	nop
    ostate, tp, &tcp_saveti);
#endif
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
 8237958:	e0bfeb17 	ldw	r2,-84(fp)
 823795c:	1000051e 	bne	r2,zero,8237974 <tcp_input+0x2174>
 8237960:	e0bfe617 	ldw	r2,-104(fp)
 8237964:	10800b0b 	ldhu	r2,44(r2)
 8237968:	10bfffcc 	andi	r2,r2,65535
 823796c:	1080004c 	andi	r2,r2,1
 8237970:	10006526 	beq	r2,zero,8237b08 <tcp_input+0x2308>
      (void) tcp_output(tp);
 8237974:	e13fe617 	ldw	r4,-104(fp)
 8237978:	82381700 	call	8238170 <tcp_output>
   return;
 823797c:	00006206 	br	8237b08 <tcp_input+0x2308>
dropafterack:
   /*
    * Generate an ACK dropping incoming segment if it occupies
    * sequence space, where the ACK reflects our state.
    */
   if (tiflags & TH_RST)
 8237980:	e0bfe717 	ldw	r2,-100(fp)
 8237984:	1080010c 	andi	r2,r2,4
 8237988:	10000326 	beq	r2,zero,8237998 <tcp_input+0x2198>
      GOTO_DROP;
 823798c:	0081a904 	movi	r2,1700
 8237990:	d0a0b215 	stw	r2,-32056(gp)
 8237994:	00004c06 	br	8237ac8 <tcp_input+0x22c8>
   m_freem (m);
 8237998:	e13ffe17 	ldw	r4,-8(fp)
 823799c:	822e4b80 	call	822e4b8 <m_freem>
   tp->t_flags |= TF_ACKNOW;
 82379a0:	e0bfe617 	ldw	r2,-104(fp)
 82379a4:	10800b0b 	ldhu	r2,44(r2)
 82379a8:	10800054 	ori	r2,r2,1
 82379ac:	1007883a 	mov	r3,r2
 82379b0:	e0bfe617 	ldw	r2,-104(fp)
 82379b4:	10c00b0d 	sth	r3,44(r2)
   (void) tcp_output (tp);
 82379b8:	e13fe617 	ldw	r4,-104(fp)
 82379bc:	82381700 	call	8238170 <tcp_output>
   return;
 82379c0:	00005606 	br	8237b1c <tcp_input+0x231c>

dropwithreset:
   TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 82379c4:	008209b4 	movhi	r2,2086
 82379c8:	10b96604 	addi	r2,r2,-6760
 82379cc:	10800d17 	ldw	r2,52(r2)
 82379d0:	10c00044 	addi	r3,r2,1
 82379d4:	008209b4 	movhi	r2,2086
 82379d8:	10b96604 	addi	r2,r2,-6760
 82379dc:	10c00d15 	stw	r3,52(r2)
   if (om) 
 82379e0:	e0bfe517 	ldw	r2,-108(fp)
 82379e4:	10000326 	beq	r2,zero,82379f4 <tcp_input+0x21f4>
   {
      (void) m_free(om);
 82379e8:	e13fe517 	ldw	r4,-108(fp)
 82379ec:	822e3b00 	call	822e3b0 <m_free>
      om = 0;
 82379f0:	e03fe515 	stw	zero,-108(fp)
   }

   /* Don't reset resets */
   if (tiflags & TH_RST)
 82379f4:	e0bfe717 	ldw	r2,-100(fp)
 82379f8:	1080010c 	andi	r2,r2,4
 82379fc:	10000326 	beq	r2,zero,8237a0c <tcp_input+0x220c>
      GOTO_DROP;
 8237a00:	0081ad04 	movi	r2,1716
 8237a04:	d0a0b215 	stw	r2,-32056(gp)
 8237a08:	00002f06 	br	8237ac8 <tcp_input+0x22c8>
    * Generate a RST, dropping incoming segment.
    * Make ACK acceptable to originator of segment.
    * Don't bother to respond if destination was broadcast.
    */
#ifdef IP_V4
   if (in_broadcast(ti->ti_dst.s_addr))
 8237a0c:	e0bff217 	ldw	r2,-56(fp)
 8237a10:	10800417 	ldw	r2,16(r2)
 8237a14:	1009883a 	mov	r4,r2
 8237a18:	822f4040 	call	822f404 <in_broadcast>
 8237a1c:	10000326 	beq	r2,zero,8237a2c <tcp_input+0x222c>
      GOTO_DROP;
 8237a20:	0081af44 	movi	r2,1725
 8237a24:	d0a0b215 	stw	r2,-32056(gp)
 8237a28:	00002706 	br	8237ac8 <tcp_input+0x22c8>
      IP6CPY(&(m->pkt->ip6_hdr->ip_src), &ip6_src);
      IP6CPY(&(m->pkt->ip6_hdr->ip_dest), &ip6_dst);
   }
#endif   /* IP_V6 */

   if (tiflags & TH_ACK)
 8237a2c:	e0bfe717 	ldw	r2,-100(fp)
 8237a30:	1080040c 	andi	r2,r2,16
 8237a34:	10000c26 	beq	r2,zero,8237a68 <tcp_input+0x2268>
      tcp_respond (tp, ti, (tcp_seq)0, ti->ti_ack, TH_RST, m);
 8237a38:	e0bff217 	ldw	r2,-56(fp)
 8237a3c:	10c00717 	ldw	r3,28(r2)
 8237a40:	e0bffe17 	ldw	r2,-8(fp)
 8237a44:	d8800115 	stw	r2,4(sp)
 8237a48:	00800104 	movi	r2,4
 8237a4c:	d8800015 	stw	r2,0(sp)
 8237a50:	180f883a 	mov	r7,r3
 8237a54:	000d883a 	mov	r6,zero
 8237a58:	e17ff217 	ldw	r5,-56(fp)
 8237a5c:	e13fe617 	ldw	r4,-104(fp)
 8237a60:	82394980 	call	8239498 <tcp_respond>
 8237a64:	00001306 	br	8237ab4 <tcp_input+0x22b4>
   else
   {
      if (tiflags & TH_SYN)
 8237a68:	e0bfe717 	ldw	r2,-100(fp)
 8237a6c:	1080008c 	andi	r2,r2,2
 8237a70:	10000526 	beq	r2,zero,8237a88 <tcp_input+0x2288>
         ti->ti_seq++;
 8237a74:	e0bff217 	ldw	r2,-56(fp)
 8237a78:	10800617 	ldw	r2,24(r2)
 8237a7c:	10c00044 	addi	r3,r2,1
 8237a80:	e0bff217 	ldw	r2,-56(fp)
 8237a84:	10c00615 	stw	r3,24(r2)
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
 8237a88:	e0bff217 	ldw	r2,-56(fp)
 8237a8c:	10c00617 	ldw	r3,24(r2)
 8237a90:	e0bffe17 	ldw	r2,-8(fp)
 8237a94:	d8800115 	stw	r2,4(sp)
 8237a98:	00800504 	movi	r2,20
 8237a9c:	d8800015 	stw	r2,0(sp)
 8237aa0:	000f883a 	mov	r7,zero
 8237aa4:	180d883a 	mov	r6,r3
 8237aa8:	e17ff217 	ldw	r5,-56(fp)
 8237aac:	e13fe617 	ldw	r4,-104(fp)
 8237ab0:	82394980 	call	8239498 <tcp_respond>
   }
   /* destroy temporarily created socket */
   if (dropsocket)
 8237ab4:	e0bfec17 	ldw	r2,-80(fp)
 8237ab8:	10001526 	beq	r2,zero,8237b10 <tcp_input+0x2310>
      (void) soabort(so);
 8237abc:	e13fe817 	ldw	r4,-96(fp)
 8237ac0:	8231f540 	call	8231f54 <soabort>
   return;
 8237ac4:	00001206 	br	8237b10 <tcp_input+0x2310>

drop:
   if (om)
 8237ac8:	e0bfe517 	ldw	r2,-108(fp)
 8237acc:	10000226 	beq	r2,zero,8237ad8 <tcp_input+0x22d8>
      (void) m_free(om);
 8237ad0:	e13fe517 	ldw	r4,-108(fp)
 8237ad4:	822e3b00 	call	822e3b0 <m_free>
#ifdef DO_TCPTRACE
   if (tp && (tp->t_inpcb->inp_socket->so_options & SO_DEBUG))
      tcp_trace("drop: state %d, tcpcb: %x, saveti: %x",
    ostate, tp, &tcp_saveti);
#endif
   m_freem(m);
 8237ad8:	e13ffe17 	ldw	r4,-8(fp)
 8237adc:	822e4b80 	call	822e4b8 <m_freem>
   /* destroy temporarily created socket */
   if (dropsocket)
 8237ae0:	e0bfec17 	ldw	r2,-80(fp)
 8237ae4:	10000c26 	beq	r2,zero,8237b18 <tcp_input+0x2318>
      (void) soabort(so);
 8237ae8:	e13fe817 	ldw	r4,-96(fp)
 8237aec:	8231f540 	call	8231f54 <soabort>
   return;
 8237af0:	0001883a 	nop
 8237af4:	00000806 	br	8237b18 <tcp_input+0x2318>
            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
               (void) tcp_output(tp);
            return;
 8237af8:	0001883a 	nop
 8237afc:	00000706 	br	8237b1c <tcp_input+0x231c>
            tp->t_flags |= TF_ACKNOW;
            tp->t_flags &= ~TF_DELACK;
            tcp_output(tp);   /* send the ack now... */
         }

         return;
 8237b00:	0001883a 	nop
 8237b04:	00000506 	br	8237b1c <tcp_input+0x231c>
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
      (void) tcp_output(tp);
   return;
 8237b08:	0001883a 	nop
 8237b0c:	00000306 	br	8237b1c <tcp_input+0x231c>
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
   }
   /* destroy temporarily created socket */
   if (dropsocket)
      (void) soabort(so);
   return;
 8237b10:	0001883a 	nop
 8237b14:	00000106 	br	8237b1c <tcp_input+0x231c>
#endif
   m_freem(m);
   /* destroy temporarily created socket */
   if (dropsocket)
      (void) soabort(so);
   return;
 8237b18:	0001883a 	nop
}
 8237b1c:	e037883a 	mov	sp,fp
 8237b20:	dfc00117 	ldw	ra,4(sp)
 8237b24:	df000017 	ldw	fp,0(sp)
 8237b28:	dec00204 	addi	sp,sp,8
 8237b2c:	f800283a 	ret

08237b30 <tcp_dooptions>:

void
tcp_dooptions(struct tcpcb * tp, 
   struct mbuf *  om,
   struct tcpiphdr * ti)
{
 8237b30:	defff404 	addi	sp,sp,-48
 8237b34:	dfc00b15 	stw	ra,44(sp)
 8237b38:	df000a15 	stw	fp,40(sp)
 8237b3c:	dc000915 	stw	r16,36(sp)
 8237b40:	df000a04 	addi	fp,sp,40
 8237b44:	e13ffc15 	stw	r4,-16(fp)
 8237b48:	e17ffd15 	stw	r5,-12(fp)
 8237b4c:	e1bffe15 	stw	r6,-8(fp)
   u_char * cp;   /* pointer into option buffer */
   int   opt;     /* current option code */
   int   optlen;  /* length of current option */
   int   cnt;     /* byte count left in header */
   struct socket * so = tp->t_inpcb->inp_socket;
 8237b50:	e0bffc17 	ldw	r2,-16(fp)
 8237b54:	10800d17 	ldw	r2,52(r2)
 8237b58:	10800817 	ldw	r2,32(r2)
 8237b5c:	e0bff915 	stw	r2,-28(fp)
#ifdef TCP_TIMESTAMP
   int   gotstamp = FALSE;    /* TRUE if we got a timestamp */
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
 8237b60:	e0bffd17 	ldw	r2,-12(fp)
 8237b64:	10800317 	ldw	r2,12(r2)
 8237b68:	e0bff615 	stw	r2,-40(fp)
   cnt = om->m_len;
 8237b6c:	e0bffd17 	ldw	r2,-12(fp)
 8237b70:	10800217 	ldw	r2,8(r2)
 8237b74:	e0bff815 	stw	r2,-32(fp)
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 8237b78:	00004006 	br	8237c7c <tcp_dooptions+0x14c>
   {
      opt = cp[0];
 8237b7c:	e0bff617 	ldw	r2,-40(fp)
 8237b80:	10800003 	ldbu	r2,0(r2)
 8237b84:	10803fcc 	andi	r2,r2,255
 8237b88:	e0bffa15 	stw	r2,-24(fp)
      if (opt == TCPOPT_EOL)
 8237b8c:	e0bffa17 	ldw	r2,-24(fp)
 8237b90:	10003d26 	beq	r2,zero,8237c88 <tcp_dooptions+0x158>
         break;
      if (opt == TCPOPT_NOP)
 8237b94:	e0bffa17 	ldw	r2,-24(fp)
 8237b98:	10800058 	cmpnei	r2,r2,1
 8237b9c:	1000031e 	bne	r2,zero,8237bac <tcp_dooptions+0x7c>
         optlen = 1;
 8237ba0:	00800044 	movi	r2,1
 8237ba4:	e0bff715 	stw	r2,-36(fp)
 8237ba8:	00000706 	br	8237bc8 <tcp_dooptions+0x98>
      else 
      {
         optlen = cp[1];
 8237bac:	e0bff617 	ldw	r2,-40(fp)
 8237bb0:	10800044 	addi	r2,r2,1
 8237bb4:	10800003 	ldbu	r2,0(r2)
 8237bb8:	10803fcc 	andi	r2,r2,255
 8237bbc:	e0bff715 	stw	r2,-36(fp)
         if (optlen <= 0)
 8237bc0:	e0bff717 	ldw	r2,-36(fp)
 8237bc4:	0080320e 	bge	zero,r2,8237c90 <tcp_dooptions+0x160>
            break;
      }

      switch (opt) 
 8237bc8:	e0bffa17 	ldw	r2,-24(fp)
 8237bcc:	108000a0 	cmpeqi	r2,r2,2
 8237bd0:	1000011e 	bne	r2,zero,8237bd8 <tcp_dooptions+0xa8>
         }
         break;
#endif   /* TCP_TIMESTAMP */

      default:
         break;
 8237bd4:	00002106 	br	8237c5c <tcp_dooptions+0x12c>
      switch (opt) 
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
 8237bd8:	e0bff717 	ldw	r2,-36(fp)
 8237bdc:	10800120 	cmpeqi	r2,r2,4
 8237be0:	10001b26 	beq	r2,zero,8237c50 <tcp_dooptions+0x120>
            continue;
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
 8237be4:	e0bffe17 	ldw	r2,-8(fp)
 8237be8:	10800843 	ldbu	r2,33(r2)
 8237bec:	10803fcc 	andi	r2,r2,255
 8237bf0:	1080008c 	andi	r2,r2,2
 8237bf4:	10001826 	beq	r2,zero,8237c58 <tcp_dooptions+0x128>
            continue;
         mssval = *(u_short *)(cp + 2);
 8237bf8:	e0bff617 	ldw	r2,-40(fp)
 8237bfc:	1080008b 	ldhu	r2,2(r2)
 8237c00:	e0bffb0d 	sth	r2,-20(fp)
         mssval = ntohs(mssval);
 8237c04:	e0bffb0b 	ldhu	r2,-20(fp)
 8237c08:	1004d23a 	srli	r2,r2,8
 8237c0c:	1007883a 	mov	r3,r2
 8237c10:	e0bffb0b 	ldhu	r2,-20(fp)
 8237c14:	1004923a 	slli	r2,r2,8
 8237c18:	1884b03a 	or	r2,r3,r2
 8237c1c:	e0bffb0d 	sth	r2,-20(fp)
         tp->t_maxseg = (u_short)MIN(mssval, (u_short)tcp_mss(so));
 8237c20:	e43ffb0b 	ldhu	r16,-20(fp)
 8237c24:	e13ff917 	ldw	r4,-28(fp)
 8237c28:	82380780 	call	8238078 <tcp_mss>
 8237c2c:	10bfffcc 	andi	r2,r2,65535
 8237c30:	1400030e 	bge	r2,r16,8237c40 <tcp_dooptions+0x110>
 8237c34:	e13ff917 	ldw	r4,-28(fp)
 8237c38:	82380780 	call	8238078 <tcp_mss>
 8237c3c:	00000106 	br	8237c44 <tcp_dooptions+0x114>
 8237c40:	e0bffb0b 	ldhu	r2,-20(fp)
 8237c44:	e0fffc17 	ldw	r3,-16(fp)
 8237c48:	18800a0d 	sth	r2,40(r3)
         break;
 8237c4c:	00000306 	br	8237c5c <tcp_dooptions+0x12c>
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
            continue;
 8237c50:	0001883a 	nop
 8237c54:	00000106 	br	8237c5c <tcp_dooptions+0x12c>
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
            continue;
 8237c58:	0001883a 	nop
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
   cnt = om->m_len;
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 8237c5c:	e0fff817 	ldw	r3,-32(fp)
 8237c60:	e0bff717 	ldw	r2,-36(fp)
 8237c64:	1885c83a 	sub	r2,r3,r2
 8237c68:	e0bff815 	stw	r2,-32(fp)
 8237c6c:	e0bff717 	ldw	r2,-36(fp)
 8237c70:	e0fff617 	ldw	r3,-40(fp)
 8237c74:	1885883a 	add	r2,r3,r2
 8237c78:	e0bff615 	stw	r2,-40(fp)
 8237c7c:	e0bff817 	ldw	r2,-32(fp)
 8237c80:	00bfbe16 	blt	zero,r2,8237b7c <tcp_dooptions+0x4c>
 8237c84:	00000306 	br	8237c94 <tcp_dooptions+0x164>
   {
      opt = cp[0];
      if (opt == TCPOPT_EOL)
         break;
 8237c88:	0001883a 	nop
 8237c8c:	00000106 	br	8237c94 <tcp_dooptions+0x164>
         optlen = 1;
      else 
      {
         optlen = cp[1];
         if (optlen <= 0)
            break;
 8237c90:	0001883a 	nop

      default:
         break;
      }
   }
   (void) m_free(om);
 8237c94:	e13ffd17 	ldw	r4,-12(fp)
 8237c98:	822e3b00 	call	822e3b0 <m_free>
      if(!gotstamp)
         tp->t_flags &= ~TF_TIMESTAMP;
   }
#endif /* TCP_TIMESTAMP */

   return;
 8237c9c:	0001883a 	nop
}
 8237ca0:	e6ffff04 	addi	sp,fp,-4
 8237ca4:	dfc00217 	ldw	ra,8(sp)
 8237ca8:	df000117 	ldw	fp,4(sp)
 8237cac:	dc000017 	ldw	r16,0(sp)
 8237cb0:	dec00304 	addi	sp,sp,12
 8237cb4:	f800283a 	ret

08237cb8 <tcp_pulloutofband>:

void
tcp_pulloutofband(struct socket * so, 
   struct tcpiphdr * ti,
   struct mbuf *  m)
{
 8237cb8:	defff804 	addi	sp,sp,-32
 8237cbc:	dfc00715 	stw	ra,28(sp)
 8237cc0:	df000615 	stw	fp,24(sp)
 8237cc4:	df000604 	addi	fp,sp,24
 8237cc8:	e13ffd15 	stw	r4,-12(fp)
 8237ccc:	e17ffe15 	stw	r5,-8(fp)
 8237cd0:	e1bfff15 	stw	r6,-4(fp)
   int   cnt   =  ti->ti_urp  -  1;
 8237cd4:	e0bffe17 	ldw	r2,-8(fp)
 8237cd8:	1080098b 	ldhu	r2,38(r2)
 8237cdc:	10bfffcc 	andi	r2,r2,65535
 8237ce0:	10bfffc4 	addi	r2,r2,-1
 8237ce4:	e0bffa15 	stw	r2,-24(fp)

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 8237ce8:	00003206 	br	8237db4 <tcp_pulloutofband+0xfc>
   {
      if (m->m_len > (unsigned)cnt) 
 8237cec:	e0bfff17 	ldw	r2,-4(fp)
 8237cf0:	10800217 	ldw	r2,8(r2)
 8237cf4:	e0fffa17 	ldw	r3,-24(fp)
 8237cf8:	1880242e 	bgeu	r3,r2,8237d8c <tcp_pulloutofband+0xd4>
      {
         char *   cp =  mtod(m,  char *) +  cnt;
 8237cfc:	e0bfff17 	ldw	r2,-4(fp)
 8237d00:	10c00317 	ldw	r3,12(r2)
 8237d04:	e0bffa17 	ldw	r2,-24(fp)
 8237d08:	1885883a 	add	r2,r3,r2
 8237d0c:	e0bffb15 	stw	r2,-20(fp)
         struct tcpcb * tp =  sototcpcb(so);
 8237d10:	e0bffd17 	ldw	r2,-12(fp)
 8237d14:	10800117 	ldw	r2,4(r2)
 8237d18:	10800917 	ldw	r2,36(r2)
 8237d1c:	e0bffc15 	stw	r2,-16(fp)

         tp->t_iobc = *cp;
 8237d20:	e0bffb17 	ldw	r2,-20(fp)
 8237d24:	10c00003 	ldbu	r3,0(r2)
 8237d28:	e0bffc17 	ldw	r2,-16(fp)
 8237d2c:	10c02445 	stb	r3,145(r2)
         tp->t_oobflags |= TCPOOB_HAVEDATA;
 8237d30:	e0bffc17 	ldw	r2,-16(fp)
 8237d34:	10802403 	ldbu	r2,144(r2)
 8237d38:	10800054 	ori	r2,r2,1
 8237d3c:	1007883a 	mov	r3,r2
 8237d40:	e0bffc17 	ldw	r2,-16(fp)
 8237d44:	10c02405 	stb	r3,144(r2)
         MEMCPY(cp, cp+1, (unsigned)(m->m_len - cnt - 1));
 8237d48:	e0bffb17 	ldw	r2,-20(fp)
 8237d4c:	11000044 	addi	r4,r2,1
 8237d50:	e0bfff17 	ldw	r2,-4(fp)
 8237d54:	10c00217 	ldw	r3,8(r2)
 8237d58:	e0bffa17 	ldw	r2,-24(fp)
 8237d5c:	1885c83a 	sub	r2,r3,r2
 8237d60:	10bfffc4 	addi	r2,r2,-1
 8237d64:	100d883a 	mov	r6,r2
 8237d68:	200b883a 	mov	r5,r4
 8237d6c:	e13ffb17 	ldw	r4,-20(fp)
 8237d70:	8202e8c0 	call	8202e8c <memcpy>
         m->m_len--;
 8237d74:	e0bfff17 	ldw	r2,-4(fp)
 8237d78:	10800217 	ldw	r2,8(r2)
 8237d7c:	10ffffc4 	addi	r3,r2,-1
 8237d80:	e0bfff17 	ldw	r2,-4(fp)
 8237d84:	10c00215 	stw	r3,8(r2)
         return;
 8237d88:	00001106 	br	8237dd0 <tcp_pulloutofband+0x118>
      }
      cnt -= m->m_len;
 8237d8c:	e0fffa17 	ldw	r3,-24(fp)
 8237d90:	e0bfff17 	ldw	r2,-4(fp)
 8237d94:	10800217 	ldw	r2,8(r2)
 8237d98:	1885c83a 	sub	r2,r3,r2
 8237d9c:	e0bffa15 	stw	r2,-24(fp)
      m = m->m_next;
 8237da0:	e0bfff17 	ldw	r2,-4(fp)
 8237da4:	10800617 	ldw	r2,24(r2)
 8237da8:	e0bfff15 	stw	r2,-4(fp)
      if (m == 0)
 8237dac:	e0bfff17 	ldw	r2,-4(fp)
 8237db0:	10000326 	beq	r2,zero,8237dc0 <tcp_pulloutofband+0x108>
   struct mbuf *  m)
{
   int   cnt   =  ti->ti_urp  -  1;

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 8237db4:	e0bffa17 	ldw	r2,-24(fp)
 8237db8:	103fcc0e 	bge	r2,zero,8237cec <tcp_pulloutofband+0x34>
 8237dbc:	00000106 	br	8237dc4 <tcp_pulloutofband+0x10c>
         return;
      }
      cnt -= m->m_len;
      m = m->m_next;
      if (m == 0)
         break;
 8237dc0:	0001883a 	nop
   }
   panic("tcp_pulloutofband");
 8237dc4:	01020974 	movhi	r4,2085
 8237dc8:	2103a604 	addi	r4,r4,3736
 8237dcc:	8228aec0 	call	8228aec <panic>
}
 8237dd0:	e037883a 	mov	sp,fp
 8237dd4:	dfc00117 	ldw	ra,4(sp)
 8237dd8:	df000017 	ldw	fp,0(sp)
 8237ddc:	dec00204 	addi	sp,sp,8
 8237de0:	f800283a 	ret

08237de4 <tcp_xmit_timer>:
 * RETURNS: 
 */

void
tcp_xmit_timer(struct tcpcb * tp)
{
 8237de4:	defffb04 	addi	sp,sp,-20
 8237de8:	dfc00415 	stw	ra,16(sp)
 8237dec:	df000315 	stw	fp,12(sp)
 8237df0:	df000304 	addi	fp,sp,12
 8237df4:	e13fff15 	stw	r4,-4(fp)
   int delta;
   int rtt;

#ifdef NPDEBUG
   if(tp->t_rttick == 0){ dtrap(); return; }
 8237df8:	e0bfff17 	ldw	r2,-4(fp)
 8237dfc:	10801e17 	ldw	r2,120(r2)
 8237e00:	1000021e 	bne	r2,zero,8237e0c <tcp_xmit_timer+0x28>
 8237e04:	822d4140 	call	822d414 <dtrap>
 8237e08:	00008406 	br	823801c <tcp_xmit_timer+0x238>
#endif

   tcpstat.tcps_rttupdated++;
 8237e0c:	008209b4 	movhi	r2,2086
 8237e10:	10b99404 	addi	r2,r2,-6576
 8237e14:	10800717 	ldw	r2,28(r2)
 8237e18:	10c00044 	addi	r3,r2,1
 8237e1c:	008209b4 	movhi	r2,2086
 8237e20:	10b99404 	addi	r2,r2,-6576
 8237e24:	10c00715 	stw	r3,28(r2)

   /* get  this rtt. Convert from cticks to TCP slow ticks */
   rtt = (int)((cticks - tp->t_rttick) / (TPS/2));
 8237e28:	d0e0a817 	ldw	r3,-32096(gp)
 8237e2c:	e0bfff17 	ldw	r2,-4(fp)
 8237e30:	10801e17 	ldw	r2,120(r2)
 8237e34:	1885c83a 	sub	r2,r3,r2
 8237e38:	01400c84 	movi	r5,50
 8237e3c:	1009883a 	mov	r4,r2
 8237e40:	8202b8c0 	call	8202b8c <__udivsi3>
 8237e44:	e0bffe15 	stw	r2,-8(fp)
   if(tp->t_srtt != 0)
 8237e48:	e0bfff17 	ldw	r2,-4(fp)
 8237e4c:	10802017 	ldw	r2,128(r2)
 8237e50:	10004626 	beq	r2,zero,8237f6c <tcp_xmit_timer+0x188>
   {
      if(rtt == 0)      /* fast path for small round trip */
 8237e54:	e0bffe17 	ldw	r2,-8(fp)
 8237e58:	1000131e 	bne	r2,zero,8237ea8 <tcp_xmit_timer+0xc4>
      {
         /* if either the rtt or varience is over 1, reduce it. */
         if(tp->t_srtt > 1)
 8237e5c:	e0bfff17 	ldw	r2,-4(fp)
 8237e60:	10802017 	ldw	r2,128(r2)
 8237e64:	10800090 	cmplti	r2,r2,2
 8237e68:	1000051e 	bne	r2,zero,8237e80 <tcp_xmit_timer+0x9c>
            tp->t_srtt--;
 8237e6c:	e0bfff17 	ldw	r2,-4(fp)
 8237e70:	10802017 	ldw	r2,128(r2)
 8237e74:	10ffffc4 	addi	r3,r2,-1
 8237e78:	e0bfff17 	ldw	r2,-4(fp)
 8237e7c:	10c02015 	stw	r3,128(r2)
         if(tp->t_rttvar > 1)
 8237e80:	e0bfff17 	ldw	r2,-4(fp)
 8237e84:	10802117 	ldw	r2,132(r2)
 8237e88:	10800090 	cmplti	r2,r2,2
 8237e8c:	1000441e 	bne	r2,zero,8237fa0 <tcp_xmit_timer+0x1bc>
            tp->t_rttvar--;
 8237e90:	e0bfff17 	ldw	r2,-4(fp)
 8237e94:	10802117 	ldw	r2,132(r2)
 8237e98:	10ffffc4 	addi	r3,r2,-1
 8237e9c:	e0bfff17 	ldw	r2,-4(fp)
 8237ea0:	10c02115 	stw	r3,132(r2)
 8237ea4:	00003e06 	br	8237fa0 <tcp_xmit_timer+0x1bc>
       * The following magic is equivalent
       * to the smoothing algorithm in rfc793
       * with an alpha of .875
       * (srtt = rtt/8 + srtt*7/8 in fixed point).
       */
      delta = ((rtt - 1) << 2) - (int)(tp->t_srtt >> 3);
 8237ea8:	e0bffe17 	ldw	r2,-8(fp)
 8237eac:	10bfffc4 	addi	r2,r2,-1
 8237eb0:	1085883a 	add	r2,r2,r2
 8237eb4:	1085883a 	add	r2,r2,r2
 8237eb8:	1007883a 	mov	r3,r2
 8237ebc:	e0bfff17 	ldw	r2,-4(fp)
 8237ec0:	10802017 	ldw	r2,128(r2)
 8237ec4:	1005d0fa 	srai	r2,r2,3
 8237ec8:	1885c83a 	sub	r2,r3,r2
 8237ecc:	e0bffd15 	stw	r2,-12(fp)
      if ((tp->t_srtt += delta) <= 0)
 8237ed0:	e0bfff17 	ldw	r2,-4(fp)
 8237ed4:	10c02017 	ldw	r3,128(r2)
 8237ed8:	e0bffd17 	ldw	r2,-12(fp)
 8237edc:	1887883a 	add	r3,r3,r2
 8237ee0:	e0bfff17 	ldw	r2,-4(fp)
 8237ee4:	10c02015 	stw	r3,128(r2)
 8237ee8:	e0bfff17 	ldw	r2,-4(fp)
 8237eec:	10802017 	ldw	r2,128(r2)
 8237ef0:	00800316 	blt	zero,r2,8237f00 <tcp_xmit_timer+0x11c>
         tp->t_srtt = 1;
 8237ef4:	e0bfff17 	ldw	r2,-4(fp)
 8237ef8:	00c00044 	movi	r3,1
 8237efc:	10c02015 	stw	r3,128(r2)
       * (scaled by 4).  The following is equivalent
       * to rfc793 smoothing with an alpha of .75
       * (rttvar = rttvar*3/4 + |delta| / 4).
       * This replaces rfc793's wired-in beta.
       */
      if (delta < 0)
 8237f00:	e0bffd17 	ldw	r2,-12(fp)
 8237f04:	1000030e 	bge	r2,zero,8237f14 <tcp_xmit_timer+0x130>
         delta = -delta;
 8237f08:	e0bffd17 	ldw	r2,-12(fp)
 8237f0c:	0085c83a 	sub	r2,zero,r2
 8237f10:	e0bffd15 	stw	r2,-12(fp)
      delta -= (short)(tp->t_rttvar >> 1);
 8237f14:	e0bfff17 	ldw	r2,-4(fp)
 8237f18:	10802117 	ldw	r2,132(r2)
 8237f1c:	1005d07a 	srai	r2,r2,1
 8237f20:	10bfffcc 	andi	r2,r2,65535
 8237f24:	10a0001c 	xori	r2,r2,32768
 8237f28:	10a00004 	addi	r2,r2,-32768
 8237f2c:	e0fffd17 	ldw	r3,-12(fp)
 8237f30:	1885c83a 	sub	r2,r3,r2
 8237f34:	e0bffd15 	stw	r2,-12(fp)
      if ((tp->t_rttvar += delta) <= 0)
 8237f38:	e0bfff17 	ldw	r2,-4(fp)
 8237f3c:	10c02117 	ldw	r3,132(r2)
 8237f40:	e0bffd17 	ldw	r2,-12(fp)
 8237f44:	1887883a 	add	r3,r3,r2
 8237f48:	e0bfff17 	ldw	r2,-4(fp)
 8237f4c:	10c02115 	stw	r3,132(r2)
 8237f50:	e0bfff17 	ldw	r2,-4(fp)
 8237f54:	10802117 	ldw	r2,132(r2)
 8237f58:	00801116 	blt	zero,r2,8237fa0 <tcp_xmit_timer+0x1bc>
         tp->t_rttvar = 1;
 8237f5c:	e0bfff17 	ldw	r2,-4(fp)
 8237f60:	00c00044 	movi	r3,1
 8237f64:	10c02115 	stw	r3,132(r2)
 8237f68:	00000d06 	br	8237fa0 <tcp_xmit_timer+0x1bc>
       * No rtt measurement yet - use the
       * unsmoothed rtt.  Set the variance
       * to half the rtt (so our first
       * retransmit happens at 2*rtt)
       */
      if(rtt < 1)
 8237f6c:	e0bffe17 	ldw	r2,-8(fp)
 8237f70:	00800216 	blt	zero,r2,8237f7c <tcp_xmit_timer+0x198>
         rtt = 1;
 8237f74:	00800044 	movi	r2,1
 8237f78:	e0bffe15 	stw	r2,-8(fp)
      tp->t_srtt = rtt << 3;
 8237f7c:	e0bffe17 	ldw	r2,-8(fp)
 8237f80:	100690fa 	slli	r3,r2,3
 8237f84:	e0bfff17 	ldw	r2,-4(fp)
 8237f88:	10c02015 	stw	r3,128(r2)
      tp->t_rttvar = rtt << 1;
 8237f8c:	e0bffe17 	ldw	r2,-8(fp)
 8237f90:	1085883a 	add	r2,r2,r2
 8237f94:	1007883a 	mov	r3,r2
 8237f98:	e0bfff17 	ldw	r2,-4(fp)
 8237f9c:	10c02115 	stw	r3,132(r2)
   }
   tp->t_rttick = 0;       /* clear RT timer */
 8237fa0:	e0bfff17 	ldw	r2,-4(fp)
 8237fa4:	10001e15 	stw	zero,120(r2)
   tp->t_rxtshift = 0;
 8237fa8:	e0bfff17 	ldw	r2,-4(fp)
 8237fac:	10000715 	stw	zero,28(r2)
   TCPT_RANGESET(tp->t_rxtcur, 
 8237fb0:	e0bfff17 	ldw	r2,-4(fp)
 8237fb4:	10802017 	ldw	r2,128(r2)
 8237fb8:	1007d0ba 	srai	r3,r2,2
 8237fbc:	e0bfff17 	ldw	r2,-4(fp)
 8237fc0:	10802117 	ldw	r2,132(r2)
 8237fc4:	1885883a 	add	r2,r3,r2
 8237fc8:	1005d07a 	srai	r2,r2,1
 8237fcc:	10ffffcc 	andi	r3,r2,65535
 8237fd0:	18e0001c 	xori	r3,r3,32768
 8237fd4:	18e00004 	addi	r3,r3,-32768
 8237fd8:	e0bfff17 	ldw	r2,-4(fp)
 8237fdc:	10c00815 	stw	r3,32(r2)
 8237fe0:	e0bfff17 	ldw	r2,-4(fp)
 8237fe4:	10800817 	ldw	r2,32(r2)
 8237fe8:	10800088 	cmpgei	r2,r2,2
 8237fec:	1000041e 	bne	r2,zero,8238000 <tcp_xmit_timer+0x21c>
 8237ff0:	e0bfff17 	ldw	r2,-4(fp)
 8237ff4:	00c00084 	movi	r3,2
 8237ff8:	10c00815 	stw	r3,32(r2)
 8237ffc:	00000706 	br	823801c <tcp_xmit_timer+0x238>
 8238000:	e0bfff17 	ldw	r2,-4(fp)
 8238004:	10800817 	ldw	r2,32(r2)
 8238008:	10802050 	cmplti	r2,r2,129
 823800c:	1000031e 	bne	r2,zero,823801c <tcp_xmit_timer+0x238>
 8238010:	e0bfff17 	ldw	r2,-4(fp)
 8238014:	00c02004 	movi	r3,128
 8238018:	10c00815 	stw	r3,32(r2)
    ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1,
    TCPTV_MIN, TCPTV_REXMTMAX);
}
 823801c:	e037883a 	mov	sp,fp
 8238020:	dfc00117 	ldw	ra,4(sp)
 8238024:	df000017 	ldw	fp,0(sp)
 8238028:	dec00204 	addi	sp,sp,8
 823802c:	f800283a 	ret

08238030 <ip4_tcpmss>:


#ifdef IP_V4
int
ip4_tcpmss(struct socket * so)
{
 8238030:	defffd04 	addi	sp,sp,-12
 8238034:	df000215 	stw	fp,8(sp)
 8238038:	df000204 	addi	fp,sp,8
 823803c:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = so->so_pcb->ifp;
 8238040:	e0bfff17 	ldw	r2,-4(fp)
 8238044:	10800117 	ldw	r2,4(r2)
 8238048:	10800a17 	ldw	r2,40(r2)
 823804c:	e0bffe15 	stw	r2,-8(fp)
   return(ifp->n_mtu - (40 + ifp->n_lnh));
 8238050:	e0bffe17 	ldw	r2,-8(fp)
 8238054:	10c00917 	ldw	r3,36(r2)
 8238058:	e0bffe17 	ldw	r2,-8(fp)
 823805c:	10800817 	ldw	r2,32(r2)
 8238060:	10800a04 	addi	r2,r2,40
 8238064:	1885c83a 	sub	r2,r3,r2
}
 8238068:	e037883a 	mov	sp,fp
 823806c:	df000017 	ldw	fp,0(sp)
 8238070:	dec00104 	addi	sp,sp,4
 8238074:	f800283a 	ret

08238078 <tcp_mss>:
 */


int
tcp_mss(struct socket * so)
{
 8238078:	defffa04 	addi	sp,sp,-24
 823807c:	dfc00515 	stw	ra,20(sp)
 8238080:	df000415 	stw	fp,16(sp)
 8238084:	df000404 	addi	fp,sp,16
 8238088:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 823808c:	e0bfff17 	ldw	r2,-4(fp)
 8238090:	10000726 	beq	r2,zero,82380b0 <tcp_mss+0x38>
       (so->so_pcb == NULL) ||
 8238094:	e0bfff17 	ldw	r2,-4(fp)
 8238098:	10800117 	ldw	r2,4(r2)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 823809c:	10000426 	beq	r2,zero,82380b0 <tcp_mss+0x38>
       (so->so_pcb == NULL) ||
       (so->so_pcb->ifp == NULL))
 82380a0:	e0bfff17 	ldw	r2,-4(fp)
 82380a4:	10800117 	ldw	r2,4(r2)
 82380a8:	10800a17 	ldw	r2,40(r2)
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
       (so->so_pcb == NULL) ||
 82380ac:	1000061e 	bne	r2,zero,82380c8 <tcp_mss+0x50>
       (so->so_pcb->ifp == NULL))
   {
      if (so->so_domain == AF_INET)  /* IPv4 */
 82380b0:	e0bfff17 	ldw	r2,-4(fp)
 82380b4:	10800517 	ldw	r2,20(r2)
 82380b8:	10800098 	cmpnei	r2,r2,2
 82380bc:	1000021e 	bne	r2,zero,82380c8 <tcp_mss+0x50>
         return TCP_MSS;            /* user defined */
 82380c0:	00816d04 	movi	r2,1460
 82380c4:	00002506 	br	823815c <tcp_mss+0xe4>
#endif   /* IP_V6 */


#ifdef IP_V4   /* Begin messy domain defines */
#ifndef IP_V6  /* V4 only version */
   mss = ip4_tcpmss(so);
 82380c8:	e13fff17 	ldw	r4,-4(fp)
 82380cc:	82380300 	call	8238030 <ip4_tcpmss>
 82380d0:	e0bffc15 	stw	r2,-16(fp)
#endif         /* end of dual mode */
#else          /* no IP_v4, assume V6 only */
      mss = ip6_tcpmss(so, ifp);
#endif         /* end messy domain defines */

   if (mss > TCP_MSS)    /* check upper limit from compile */
 82380d4:	e0bffc17 	ldw	r2,-16(fp)
 82380d8:	10816d50 	cmplti	r2,r2,1461
 82380dc:	1000021e 	bne	r2,zero,82380e8 <tcp_mss+0x70>
      mss = TCP_MSS;
 82380e0:	00816d04 	movi	r2,1460
 82380e4:	e0bffc15 	stw	r2,-16(fp)

   /* check upper limit which may be set by setsockopt() */
   inp = (struct inpcb *)so->so_pcb;         /* Map socket to IP cb */
 82380e8:	e0bfff17 	ldw	r2,-4(fp)
 82380ec:	10800117 	ldw	r2,4(r2)
 82380f0:	e0bffd15 	stw	r2,-12(fp)
   tp = (struct tcpcb *)inp->inp_ppcb;       /* Map IP to TCP cb */
 82380f4:	e0bffd17 	ldw	r2,-12(fp)
 82380f8:	10800917 	ldw	r2,36(r2)
 82380fc:	e0bffe15 	stw	r2,-8(fp)
   
   /* has user set max seg? */
   if (tp->t_flags & TF_MAXSEG)
 8238100:	e0bffe17 	ldw	r2,-8(fp)
 8238104:	10800b0b 	ldhu	r2,44(r2)
 8238108:	10bfffcc 	andi	r2,r2,65535
 823810c:	1081000c 	andi	r2,r2,1024
 8238110:	10000426 	beq	r2,zero,8238124 <tcp_mss+0xac>
      return tp->t_maxseg;    /* yup */
 8238114:	e0bffe17 	ldw	r2,-8(fp)
 8238118:	10800a0b 	ldhu	r2,40(r2)
 823811c:	10bfffcc 	andi	r2,r2,65535
 8238120:	00000e06 	br	823815c <tcp_mss+0xe4>
      
   if (tp->t_maxseg && (mss > tp->t_maxseg))  /* check tcp's mss */
 8238124:	e0bffe17 	ldw	r2,-8(fp)
 8238128:	10800a0b 	ldhu	r2,40(r2)
 823812c:	10bfffcc 	andi	r2,r2,65535
 8238130:	10000926 	beq	r2,zero,8238158 <tcp_mss+0xe0>
 8238134:	e0bffe17 	ldw	r2,-8(fp)
 8238138:	10800a0b 	ldhu	r2,40(r2)
 823813c:	10ffffcc 	andi	r3,r2,65535
 8238140:	e0bffc17 	ldw	r2,-16(fp)
 8238144:	1880040e 	bge	r3,r2,8238158 <tcp_mss+0xe0>
   {
      mss = tp->t_maxseg;        /* limit new MSS to set MSS */
 8238148:	e0bffe17 	ldw	r2,-8(fp)
 823814c:	10800a0b 	ldhu	r2,40(r2)
 8238150:	10bfffcc 	andi	r2,r2,65535
 8238154:	e0bffc15 	stw	r2,-16(fp)
   }

   return mss;
 8238158:	e0bffc17 	ldw	r2,-16(fp)
}
 823815c:	e037883a 	mov	sp,fp
 8238160:	dfc00117 	ldw	ra,4(sp)
 8238164:	df000017 	ldw	fp,0(sp)
 8238168:	dec00204 	addi	sp,sp,8
 823816c:	f800283a 	ret

08238170 <tcp_output>:
 * RETURNS: 0 if OK, else a sockets error code.
 */

int
tcp_output(struct tcpcb * tp)
{
 8238170:	deffe804 	addi	sp,sp,-96
 8238174:	dfc01715 	stw	ra,92(sp)
 8238178:	df001615 	stw	fp,88(sp)
 823817c:	df001604 	addi	fp,sp,88
 8238180:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 8238184:	e0bfff17 	ldw	r2,-4(fp)
 8238188:	10800d17 	ldw	r2,52(r2)
 823818c:	10800817 	ldw	r2,32(r2)
 8238190:	e0bff215 	stw	r2,-56(fp)
   int   len;
   long  win;
   int   off,  flags,   error;
   struct mbuf *  m;
   struct tcpiphdr * ti;
   unsigned optlen = 0;
 8238194:	e03fee15 	stw	zero,-72(fp)
    * Determine length of data that should be transmitted,
    * and flags that will be used.
    * If there is some data or critical controls (SYN, RST)
    * to send, then transmit; otherwise, investigate further.
    */
   idle = (tp->snd_max == tp->snd_una);
 8238198:	e0bfff17 	ldw	r2,-4(fp)
 823819c:	10c01a17 	ldw	r3,104(r2)
 82381a0:	e0bfff17 	ldw	r2,-4(fp)
 82381a4:	10800e17 	ldw	r2,56(r2)
 82381a8:	1885003a 	cmpeq	r2,r3,r2
 82381ac:	10803fcc 	andi	r2,r2,255
 82381b0:	e0bff315 	stw	r2,-52(fp)

again:
   sendalot = 0;
 82381b4:	e03fef15 	stw	zero,-68(fp)
   off = (int)(tp->snd_nxt - tp->snd_una);
 82381b8:	e0bfff17 	ldw	r2,-4(fp)
 82381bc:	10c00f17 	ldw	r3,60(r2)
 82381c0:	e0bfff17 	ldw	r2,-4(fp)
 82381c4:	10800e17 	ldw	r2,56(r2)
 82381c8:	1885c83a 	sub	r2,r3,r2
 82381cc:	e0bff415 	stw	r2,-48(fp)
   win = (long)tp->snd_wnd;   /* set basic send window */
 82381d0:	e0bfff17 	ldw	r2,-4(fp)
 82381d4:	10801417 	ldw	r2,80(r2)
 82381d8:	e0bfeb15 	stw	r2,-84(fp)
   if (win > (long)tp->snd_cwnd) /* see if we need congestion control */
 82381dc:	e0bfff17 	ldw	r2,-4(fp)
 82381e0:	10801b17 	ldw	r2,108(r2)
 82381e4:	1007883a 	mov	r3,r2
 82381e8:	e0bfeb17 	ldw	r2,-84(fp)
 82381ec:	1880060e 	bge	r3,r2,8238208 <tcp_output+0x98>
   {
      win = (int)(tp->snd_cwnd & ~(ALIGN_TYPE-1)); /* keep data aligned */
 82381f0:	e0bfff17 	ldw	r2,-4(fp)
 82381f4:	10801b17 	ldw	r2,108(r2)
 82381f8:	1007883a 	mov	r3,r2
 82381fc:	00bfff04 	movi	r2,-4
 8238200:	1884703a 	and	r2,r3,r2
 8238204:	e0bfeb15 	stw	r2,-84(fp)
    * If in persist timeout with window of 0, send 1 byte.
    * Otherwise, if window is small but nonzero
    * and timer expired, we will send what we can
    * and go to transmit state.
    */
   if (tp->t_force) 
 8238208:	e0bfff17 	ldw	r2,-4(fp)
 823820c:	10800a83 	ldbu	r2,42(r2)
 8238210:	10803fcc 	andi	r2,r2,255
 8238214:	1080201c 	xori	r2,r2,128
 8238218:	10bfe004 	addi	r2,r2,-128
 823821c:	10000926 	beq	r2,zero,8238244 <tcp_output+0xd4>
   {
      if (win == 0)
 8238220:	e0bfeb17 	ldw	r2,-84(fp)
 8238224:	1000031e 	bne	r2,zero,8238234 <tcp_output+0xc4>
         win = 1;
 8238228:	00800044 	movi	r2,1
 823822c:	e0bfeb15 	stw	r2,-84(fp)
 8238230:	00000406 	br	8238244 <tcp_output+0xd4>
      else 
      {
         tp->t_timer[TCPT_PERSIST] = 0;
 8238234:	e0bfff17 	ldw	r2,-4(fp)
 8238238:	10000415 	stw	zero,16(r2)
         tp->t_rxtshift = 0;
 823823c:	e0bfff17 	ldw	r2,-4(fp)
 8238240:	10000715 	stw	zero,28(r2)
   }
   else
#endif /* TCP_SACK */
   {
      /* set length of packets which are not sack resends */
      len = (int)MIN(so->so_snd.sb_cc, (unsigned)win) - off;
 8238244:	e0bff217 	ldw	r2,-56(fp)
 8238248:	10801217 	ldw	r2,72(r2)
 823824c:	e0ffeb17 	ldw	r3,-84(fp)
 8238250:	1880012e 	bgeu	r3,r2,8238258 <tcp_output+0xe8>
 8238254:	1805883a 	mov	r2,r3
 8238258:	1007883a 	mov	r3,r2
 823825c:	e0bff417 	ldw	r2,-48(fp)
 8238260:	1885c83a 	sub	r2,r3,r2
 8238264:	e0bfea15 	stw	r2,-88(fp)
   }

   flags = tcp_outflags[tp->t_state];
 8238268:	e0bfff17 	ldw	r2,-4(fp)
 823826c:	10c00217 	ldw	r3,8(r2)
 8238270:	00820974 	movhi	r2,2085
 8238274:	108ecc04 	addi	r2,r2,15152
 8238278:	10c5883a 	add	r2,r2,r3
 823827c:	10800003 	ldbu	r2,0(r2)
 8238280:	10803fcc 	andi	r2,r2,255
 8238284:	e0bfec15 	stw	r2,-80(fp)
   }
#else
   /* If other options not defined this build then don't bother to call bld_options() except 
    * on SYN packets
    */
   if(flags & TH_SYN)
 8238288:	e0bfec17 	ldw	r2,-80(fp)
 823828c:	1080008c 	andi	r2,r2,2
 8238290:	10000926 	beq	r2,zero,82382b8 <tcp_output+0x148>
   {
      optlen = bld_options(tp, &tcp_optionbuf[optlen], flags, so);
 8238294:	e0ffee17 	ldw	r3,-72(fp)
 8238298:	d0a0b304 	addi	r2,gp,-32052
 823829c:	1885883a 	add	r2,r3,r2
 82382a0:	e1fff217 	ldw	r7,-56(fp)
 82382a4:	e1bfec17 	ldw	r6,-80(fp)
 82382a8:	100b883a 	mov	r5,r2
 82382ac:	e13fff17 	ldw	r4,-4(fp)
 82382b0:	82392740 	call	8239274 <bld_options>
 82382b4:	e0bfee15 	stw	r2,-72(fp)
   }
#endif

   if (len < 0)
 82382b8:	e0bfea17 	ldw	r2,-88(fp)
 82382bc:	1000090e 	bge	r2,zero,82382e4 <tcp_output+0x174>
       * cancel pending retransmit and pull snd_nxt
       * back to (closed) window.  We will enter persist
       * state below.  If the window didn't close completely,
       * just wait for an ACK.
       */
      len = 0;
 82382c0:	e03fea15 	stw	zero,-88(fp)
      if (win == 0) 
 82382c4:	e0bfeb17 	ldw	r2,-84(fp)
 82382c8:	1000061e 	bne	r2,zero,82382e4 <tcp_output+0x174>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 82382cc:	e0bfff17 	ldw	r2,-4(fp)
 82382d0:	10000315 	stw	zero,12(r2)
         tp->snd_nxt = tp->snd_una;
 82382d4:	e0bfff17 	ldw	r2,-4(fp)
 82382d8:	10c00e17 	ldw	r3,56(r2)
 82382dc:	e0bfff17 	ldw	r2,-4(fp)
 82382e0:	10c00f15 	stw	r3,60(r2)
      }
   }

   if (len > (int)tp->t_maxseg)
 82382e4:	e0bfff17 	ldw	r2,-4(fp)
 82382e8:	10800a0b 	ldhu	r2,40(r2)
 82382ec:	10ffffcc 	andi	r3,r2,65535
 82382f0:	e0bfea17 	ldw	r2,-88(fp)
 82382f4:	1880060e 	bge	r3,r2,8238310 <tcp_output+0x1a0>
   {
      len = tp->t_maxseg;
 82382f8:	e0bfff17 	ldw	r2,-4(fp)
 82382fc:	10800a0b 	ldhu	r2,40(r2)
 8238300:	10bfffcc 	andi	r2,r2,65535
 8238304:	e0bfea15 	stw	r2,-88(fp)
      sendalot = 1;
 8238308:	00800044 	movi	r2,1
 823830c:	e0bfef15 	stw	r2,-68(fp)
   /* We don't need a pmtu test for IPv6. V6 code limits t_maxseg to
    * the Path MTU, so the test above the v4 ifdef above covers us.
    */
#endif /* IP_V4 */

   if (SEQ_LT(tp->snd_nxt + len, tp->snd_una + so->so_snd.sb_cc))
 8238310:	e0bfff17 	ldw	r2,-4(fp)
 8238314:	10c00f17 	ldw	r3,60(r2)
 8238318:	e0bfea17 	ldw	r2,-88(fp)
 823831c:	1887883a 	add	r3,r3,r2
 8238320:	e0bfff17 	ldw	r2,-4(fp)
 8238324:	11000e17 	ldw	r4,56(r2)
 8238328:	e0bff217 	ldw	r2,-56(fp)
 823832c:	10801217 	ldw	r2,72(r2)
 8238330:	2085883a 	add	r2,r4,r2
 8238334:	1885c83a 	sub	r2,r3,r2
 8238338:	1000040e 	bge	r2,zero,823834c <tcp_output+0x1dc>
      flags &= ~TH_FIN;
 823833c:	e0ffec17 	ldw	r3,-80(fp)
 8238340:	00bfff84 	movi	r2,-2
 8238344:	1884703a 	and	r2,r3,r2
 8238348:	e0bfec15 	stw	r2,-80(fp)
   win = (long)(sbspace(&so->so_rcv));
 823834c:	e0bff217 	ldw	r2,-56(fp)
 8238350:	10800b17 	ldw	r2,44(r2)
 8238354:	1007883a 	mov	r3,r2
 8238358:	e0bff217 	ldw	r2,-56(fp)
 823835c:	10800a17 	ldw	r2,40(r2)
 8238360:	1885c83a 	sub	r2,r3,r2
 8238364:	10000616 	blt	r2,zero,8238380 <tcp_output+0x210>
 8238368:	e0bff217 	ldw	r2,-56(fp)
 823836c:	10c00b17 	ldw	r3,44(r2)
 8238370:	e0bff217 	ldw	r2,-56(fp)
 8238374:	10800a17 	ldw	r2,40(r2)
 8238378:	1885c83a 	sub	r2,r3,r2
 823837c:	00000106 	br	8238384 <tcp_output+0x214>
 8238380:	0005883a 	mov	r2,zero
 8238384:	e0bfeb15 	stw	r2,-84(fp)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 8238388:	e0bfec17 	ldw	r2,-80(fp)
 823838c:	1080004c 	andi	r2,r2,1
 8238390:	10000d26 	beq	r2,zero,82383c8 <tcp_output+0x258>
       (so->so_snd.sb_cc == 0) &&
 8238394:	e0bff217 	ldw	r2,-56(fp)
 8238398:	10801217 	ldw	r2,72(r2)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 823839c:	10000a1e 	bne	r2,zero,82383c8 <tcp_output+0x258>
       (so->so_snd.sb_cc == 0) &&
       ((tp->t_flags & TF_SENTFIN) == 0 || tp->snd_nxt == tp->snd_una))
 82383a0:	e0bfff17 	ldw	r2,-4(fp)
 82383a4:	10800b0b 	ldhu	r2,44(r2)
 82383a8:	10bfffcc 	andi	r2,r2,65535
 82383ac:	1080040c 	andi	r2,r2,16
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
       (so->so_snd.sb_cc == 0) &&
 82383b0:	10007926 	beq	r2,zero,8238598 <tcp_output+0x428>
       ((tp->t_flags & TF_SENTFIN) == 0 || tp->snd_nxt == tp->snd_una))
 82383b4:	e0bfff17 	ldw	r2,-4(fp)
 82383b8:	10c00f17 	ldw	r3,60(r2)
 82383bc:	e0bfff17 	ldw	r2,-4(fp)
 82383c0:	10800e17 	ldw	r2,56(r2)
 82383c4:	18807426 	beq	r3,r2,8238598 <tcp_output+0x428>
      goto send;
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
 82383c8:	e0bfff17 	ldw	r2,-4(fp)
 82383cc:	10800b0b 	ldhu	r2,44(r2)
 82383d0:	10bfffcc 	andi	r2,r2,65535
 82383d4:	1080004c 	andi	r2,r2,1
 82383d8:	10005c1e 	bne	r2,zero,823854c <tcp_output+0x3dc>
      goto send;
   if (flags & (TH_SYN|TH_RST))
 82383dc:	e0bfec17 	ldw	r2,-80(fp)
 82383e0:	1080018c 	andi	r2,r2,6
 82383e4:	10005b1e 	bne	r2,zero,8238554 <tcp_output+0x3e4>
      goto send;
   if (SEQ_GT(tp->snd_up, tp->snd_una))
 82383e8:	e0bfff17 	ldw	r2,-4(fp)
 82383ec:	10c01017 	ldw	r3,64(r2)
 82383f0:	e0bfff17 	ldw	r2,-4(fp)
 82383f4:	10800e17 	ldw	r2,56(r2)
 82383f8:	1885c83a 	sub	r2,r3,r2
 82383fc:	00805716 	blt	zero,r2,823855c <tcp_output+0x3ec>
    * If peer's buffer is tiny, then send
    * when window is at least half open.
    * If retransmitting (possibly after persist timer forced us
    * to send into a small window), then must resend.
    */
   if (len)
 8238400:	e0bfea17 	ldw	r2,-88(fp)
 8238404:	10002426 	beq	r2,zero,8238498 <tcp_output+0x328>
   {
      if (len == (int)tp->t_maxseg)
 8238408:	e0bfff17 	ldw	r2,-4(fp)
 823840c:	10800a0b 	ldhu	r2,40(r2)
 8238410:	10ffffcc 	andi	r3,r2,65535
 8238414:	e0bfea17 	ldw	r2,-88(fp)
 8238418:	18805226 	beq	r3,r2,8238564 <tcp_output+0x3f4>
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 823841c:	e0bff317 	ldw	r2,-52(fp)
 8238420:	1000051e 	bne	r2,zero,8238438 <tcp_output+0x2c8>
 8238424:	e0bfff17 	ldw	r2,-4(fp)
 8238428:	10800b0b 	ldhu	r2,44(r2)
 823842c:	10bfffcc 	andi	r2,r2,65535
 8238430:	1080010c 	andi	r2,r2,4
 8238434:	10000626 	beq	r2,zero,8238450 <tcp_output+0x2e0>
          len + off >= (int)so->so_snd.sb_cc)
 8238438:	e0ffea17 	ldw	r3,-88(fp)
 823843c:	e0bff417 	ldw	r2,-48(fp)
 8238440:	1885883a 	add	r2,r3,r2
 8238444:	e0fff217 	ldw	r3,-56(fp)
 8238448:	18c01217 	ldw	r3,72(r3)
    */
   if (len)
   {
      if (len == (int)tp->t_maxseg)
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 823844c:	10c0470e 	bge	r2,r3,823856c <tcp_output+0x3fc>
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
      }
      if (tp->t_force)
 8238450:	e0bfff17 	ldw	r2,-4(fp)
 8238454:	10800a83 	ldbu	r2,42(r2)
 8238458:	10803fcc 	andi	r2,r2,255
 823845c:	1080201c 	xori	r2,r2,128
 8238460:	10bfe004 	addi	r2,r2,-128
 8238464:	1000431e 	bne	r2,zero,8238574 <tcp_output+0x404>
         goto send;
      if (len >= (int)(tp->max_sndwnd / 2))
 8238468:	e0bfff17 	ldw	r2,-4(fp)
 823846c:	10802317 	ldw	r2,140(r2)
 8238470:	1004d07a 	srli	r2,r2,1
 8238474:	1007883a 	mov	r3,r2
 8238478:	e0bfea17 	ldw	r2,-88(fp)
 823847c:	10c03f0e 	bge	r2,r3,823857c <tcp_output+0x40c>
         goto send;
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
 8238480:	e0bfff17 	ldw	r2,-4(fp)
 8238484:	10c00f17 	ldw	r3,60(r2)
 8238488:	e0bfff17 	ldw	r2,-4(fp)
 823848c:	10801a17 	ldw	r2,104(r2)
 8238490:	1885c83a 	sub	r2,r3,r2
 8238494:	10003b16 	blt	r2,zero,8238584 <tcp_output+0x414>
    * known to peer (as advertised window less
    * next expected input).  If the difference is at least two
    * max size segments or at least 35% of the maximum possible
    * window, then want to send a window update to peer.
    */
   if (win > 0)
 8238498:	e0bfeb17 	ldw	r2,-84(fp)
 823849c:	00801c0e 	bge	zero,r2,8238510 <tcp_output+0x3a0>
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);
 82384a0:	e0bfff17 	ldw	r2,-4(fp)
 82384a4:	10c01617 	ldw	r3,88(r2)
 82384a8:	e0bfff17 	ldw	r2,-4(fp)
 82384ac:	10801917 	ldw	r2,100(r2)
 82384b0:	1885c83a 	sub	r2,r3,r2
 82384b4:	1007883a 	mov	r3,r2
 82384b8:	e0bfeb17 	ldw	r2,-84(fp)
 82384bc:	1885883a 	add	r2,r3,r2
 82384c0:	e0bffd15 	stw	r2,-12(fp)

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
 82384c4:	e0bff217 	ldw	r2,-56(fp)
 82384c8:	10800a17 	ldw	r2,40(r2)
 82384cc:	1000071e 	bne	r2,zero,82384ec <tcp_output+0x37c>
 82384d0:	e0bfff17 	ldw	r2,-4(fp)
 82384d4:	10800a0b 	ldhu	r2,40(r2)
 82384d8:	10bfffcc 	andi	r2,r2,65535
 82384dc:	1085883a 	add	r2,r2,r2
 82384e0:	1007883a 	mov	r3,r2
 82384e4:	e0bffd17 	ldw	r2,-12(fp)
 82384e8:	10c0280e 	bge	r2,r3,823858c <tcp_output+0x41c>
         goto send;
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
 82384ec:	e0bffd17 	ldw	r2,-12(fp)
 82384f0:	10c01924 	muli	r3,r2,100
 82384f4:	e0bff217 	ldw	r2,-56(fp)
 82384f8:	10800b17 	ldw	r2,44(r2)
 82384fc:	100b883a 	mov	r5,r2
 8238500:	1809883a 	mov	r4,r3
 8238504:	8202b8c0 	call	8202b8c <__udivsi3>
 8238508:	108008f0 	cmpltui	r2,r2,35
 823850c:	10002126 	beq	r2,zero,8238594 <tcp_output+0x424>
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 8238510:	e0bff217 	ldw	r2,-56(fp)
 8238514:	10801217 	ldw	r2,72(r2)
 8238518:	10000a26 	beq	r2,zero,8238544 <tcp_output+0x3d4>
 823851c:	e0bfff17 	ldw	r2,-4(fp)
 8238520:	10800317 	ldw	r2,12(r2)
 8238524:	1000071e 	bne	r2,zero,8238544 <tcp_output+0x3d4>
       tp->t_timer[TCPT_PERSIST] == 0) 
 8238528:	e0bfff17 	ldw	r2,-4(fp)
 823852c:	10800417 	ldw	r2,16(r2)
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 8238530:	1000041e 	bne	r2,zero,8238544 <tcp_output+0x3d4>
       tp->t_timer[TCPT_PERSIST] == 0) 
   {
      tp->t_rxtshift = 0;
 8238534:	e0bfff17 	ldw	r2,-4(fp)
 8238538:	10000715 	stw	zero,28(r2)
      tcp_setpersist(tp);
 823853c:	e13fff17 	ldw	r4,-4(fp)
 8238540:	82391740 	call	8239174 <tcp_setpersist>
   }

   /*
    * No reason to send a segment, just return.
    */
   return (0);
 8238544:	0005883a 	mov	r2,zero
 8238548:	00030506 	br	8239160 <tcp_output+0xff0>
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
      goto send;
 823854c:	0001883a 	nop
 8238550:	00001106 	br	8238598 <tcp_output+0x428>
   if (flags & (TH_SYN|TH_RST))
      goto send;
 8238554:	0001883a 	nop
 8238558:	00000f06 	br	8238598 <tcp_output+0x428>
   if (SEQ_GT(tp->snd_up, tp->snd_una))
      goto send;
 823855c:	0001883a 	nop
 8238560:	00000d06 	br	8238598 <tcp_output+0x428>
    * to send into a small window), then must resend.
    */
   if (len)
   {
      if (len == (int)tp->t_maxseg)
         goto send;
 8238564:	0001883a 	nop
 8238568:	00000b06 	br	8238598 <tcp_output+0x428>
      if ((idle || tp->t_flags & TF_NODELAY) &&
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
 823856c:	0001883a 	nop
 8238570:	00000906 	br	8238598 <tcp_output+0x428>
      }
      if (tp->t_force)
         goto send;
 8238574:	0001883a 	nop
 8238578:	00000706 	br	8238598 <tcp_output+0x428>
      if (len >= (int)(tp->max_sndwnd / 2))
         goto send;
 823857c:	0001883a 	nop
 8238580:	00000506 	br	8238598 <tcp_output+0x428>
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
         goto send;
 8238584:	0001883a 	nop
 8238588:	00000306 	br	8238598 <tcp_output+0x428>
   if (win > 0)
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
         goto send;
 823858c:	0001883a 	nop
 8238590:	00000106 	br	8238598 <tcp_output+0x428>
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
         goto send;
 8238594:	0001883a 	nop
    * No reason to send a segment, just return.
    */
   return (0);

send:
   ENTER_CRIT_SECTION(tp);
 8238598:	822d5ec0 	call	822d5ec <irq_Mask>

   /* Limit send length to the current buffer so as to
    * avoid doing the "mbuf shuffle" in m_copy().
    */
   bufoff = off;
 823859c:	e0bff417 	ldw	r2,-48(fp)
 82385a0:	e0bff115 	stw	r2,-60(fp)
   sendm = so->so_snd.sb_mb;
 82385a4:	e0bff217 	ldw	r2,-56(fp)
 82385a8:	10801817 	ldw	r2,96(r2)
 82385ac:	e0bff015 	stw	r2,-64(fp)
   if (len)
 82385b0:	e0bfea17 	ldw	r2,-88(fp)
 82385b4:	10005526 	beq	r2,zero,823870c <tcp_output+0x59c>
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 82385b8:	00000a06 	br	82385e4 <tcp_output+0x474>
      {
         bufoff -= sendm->m_len;
 82385bc:	e0fff117 	ldw	r3,-60(fp)
 82385c0:	e0bff017 	ldw	r2,-64(fp)
 82385c4:	10800217 	ldw	r2,8(r2)
 82385c8:	1885c83a 	sub	r2,r3,r2
 82385cc:	e0bff115 	stw	r2,-60(fp)
         if (bufoff < 0)   /* if off is in this buffer, break */
 82385d0:	e0bff117 	ldw	r2,-60(fp)
 82385d4:	10000616 	blt	r2,zero,82385f0 <tcp_output+0x480>
            break;
         sendm = sendm->m_next;
 82385d8:	e0bff017 	ldw	r2,-64(fp)
 82385dc:	10800617 	ldw	r2,24(r2)
 82385e0:	e0bff015 	stw	r2,-64(fp)
   bufoff = off;
   sendm = so->so_snd.sb_mb;
   if (len)
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 82385e4:	e0bff017 	ldw	r2,-64(fp)
 82385e8:	103ff41e 	bne	r2,zero,82385bc <tcp_output+0x44c>
 82385ec:	00000106 	br	82385f4 <tcp_output+0x484>
      {
         bufoff -= sendm->m_len;
         if (bufoff < 0)   /* if off is in this buffer, break */
            break;
 82385f0:	0001883a 	nop
         sendm = sendm->m_next;
      }
      if (!sendm) { dtrap();  /* shouldn't happen */ }
 82385f4:	e0bff017 	ldw	r2,-64(fp)
 82385f8:	1000011e 	bne	r2,zero,8238600 <tcp_output+0x490>
 82385fc:	822d4140 	call	822d414 <dtrap>
      bufoff += sendm->m_len; /* index to next data to send in msend */
 8238600:	e0bff017 	ldw	r2,-64(fp)
 8238604:	10c00217 	ldw	r3,8(r2)
 8238608:	e0bff117 	ldw	r2,-60(fp)
 823860c:	1885883a 	add	r2,r3,r2
 8238610:	e0bff115 	stw	r2,-60(fp)

      /* if socket has multiple unsent mbufs, set flag for send to loop */
      if ((sendm->m_next) && (len > (int)sendm->m_len))
 8238614:	e0bff017 	ldw	r2,-64(fp)
 8238618:	10800617 	ldw	r2,24(r2)
 823861c:	10000b26 	beq	r2,zero,823864c <tcp_output+0x4dc>
 8238620:	e0bff017 	ldw	r2,-64(fp)
 8238624:	10800217 	ldw	r2,8(r2)
 8238628:	1007883a 	mov	r3,r2
 823862c:	e0bfea17 	ldw	r2,-88(fp)
 8238630:	1880060e 	bge	r3,r2,823864c <tcp_output+0x4dc>
      {
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 8238634:	e0ffec17 	ldw	r3,-80(fp)
 8238638:	00bfff84 	movi	r2,-2
 823863c:	1884703a 	and	r2,r3,r2
 8238640:	e0bfec15 	stw	r2,-80(fp)
         sendalot = 1;     /* set to send more segments */
 8238644:	00800044 	movi	r2,1
 8238648:	e0bfef15 	stw	r2,-68(fp)
      }
      if((flags & TH_FIN) && (so->so_snd.sb_cc > (unsigned)len))
 823864c:	e0bfec17 	ldw	r2,-80(fp)
 8238650:	1080004c 	andi	r2,r2,1
 8238654:	10000826 	beq	r2,zero,8238678 <tcp_output+0x508>
 8238658:	e0bff217 	ldw	r2,-56(fp)
 823865c:	10801217 	ldw	r2,72(r2)
 8238660:	e0ffea17 	ldw	r3,-88(fp)
 8238664:	1880042e 	bgeu	r3,r2,8238678 <tcp_output+0x508>
      {
         /* This can happen on slow links (PPP) which retry the last 
          * segment - the one with the FIN bit attached to data.
          */
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 8238668:	e0ffec17 	ldw	r3,-80(fp)
 823866c:	00bfff84 	movi	r2,-2
 8238670:	1884703a 	and	r2,r3,r2
 8238674:	e0bfec15 	stw	r2,-80(fp)
      }

      /* only send the rest of msend */
      len = min(len, (int)sendm->m_len);
 8238678:	e0bff017 	ldw	r2,-64(fp)
 823867c:	10800217 	ldw	r2,8(r2)
 8238680:	e0ffea17 	ldw	r3,-88(fp)
 8238684:	1880010e 	bge	r3,r2,823868c <tcp_output+0x51c>
 8238688:	1805883a 	mov	r2,r3
 823868c:	e0bfea15 	stw	r2,-88(fp)
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 8238690:	e0bff117 	ldw	r2,-60(fp)
 8238694:	1000081e 	bne	r2,zero,82386b8 <tcp_output+0x548>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
 8238698:	e0bff017 	ldw	r2,-64(fp)
 823869c:	10800317 	ldw	r2,12(r2)
 82386a0:	1007883a 	mov	r3,r2
 82386a4:	e0bff017 	ldw	r2,-64(fp)
 82386a8:	10800417 	ldw	r2,16(r2)
 82386ac:	1885c83a 	sub	r2,r3,r2
 82386b0:	108000cc 	andi	r2,r2,3
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 82386b4:	10001526 	beq	r2,zero,823870c <tcp_output+0x59c>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
      {
         len = min(len, (int)(sendm->m_len - bufoff));   /* limit len again */
 82386b8:	e0bff017 	ldw	r2,-64(fp)
 82386bc:	10c00217 	ldw	r3,8(r2)
 82386c0:	e0bff117 	ldw	r2,-60(fp)
 82386c4:	1885c83a 	sub	r2,r3,r2
 82386c8:	e0ffea17 	ldw	r3,-88(fp)
 82386cc:	1880010e 	bge	r3,r2,82386d4 <tcp_output+0x564>
 82386d0:	1805883a 	mov	r2,r3
 82386d4:	e0bfea15 	stw	r2,-88(fp)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 82386d8:	d0a03717 	ldw	r2,-32548(gp)
 82386dc:	10bff204 	addi	r2,r2,-56
 82386e0:	1007883a 	mov	r3,r2
 82386e4:	e0bfea17 	ldw	r2,-88(fp)
 82386e8:	1880080e 	bge	r3,r2,823870c <tcp_output+0x59c>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
 82386ec:	008209b4 	movhi	r2,2086
 82386f0:	10b8cb04 	addi	r2,r2,-7380
 82386f4:	10800217 	ldw	r2,8(r2)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 82386f8:	10800088 	cmpgei	r2,r2,2
 82386fc:	1000031e 	bne	r2,zero,823870c <tcp_output+0x59c>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
         {
            len = lilbufsiz - HDRSLEN;
 8238700:	d0a03717 	ldw	r2,-32548(gp)
 8238704:	10bff204 	addi	r2,r2,-56
 8238708:	e0bfea15 	stw	r2,-88(fp)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 823870c:	e0bfea17 	ldw	r2,-88(fp)
 8238710:	10003626 	beq	r2,zero,82387ec <tcp_output+0x67c>
 8238714:	e0bff117 	ldw	r2,-60(fp)
 8238718:	1000341e 	bne	r2,zero,82387ec <tcp_output+0x67c>
       (sendm->pkt->inuse == 1) &&
 823871c:	e0bff017 	ldw	r2,-64(fp)
 8238720:	10800117 	ldw	r2,4(r2)
 8238724:	10800917 	ldw	r2,36(r2)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 8238728:	10800058 	cmpnei	r2,r2,1
 823872c:	10002f1e 	bne	r2,zero,82387ec <tcp_output+0x67c>
       (sendm->pkt->inuse == 1) &&
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
 8238730:	e0bff017 	ldw	r2,-64(fp)
 8238734:	10800317 	ldw	r2,12(r2)
 8238738:	1007883a 	mov	r3,r2
 823873c:	e0bff017 	ldw	r2,-64(fp)
 8238740:	10800417 	ldw	r2,16(r2)
 8238744:	1885c83a 	sub	r2,r3,r2
 8238748:	108000cc 	andi	r2,r2,3

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
       (sendm->pkt->inuse == 1) &&
 823874c:	1000271e 	bne	r2,zero,82387ec <tcp_output+0x67c>
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
 8238750:	e0bfee17 	ldw	r2,-72(fp)
 8238754:	1000251e 	bne	r2,zero,82387ec <tcp_output+0x67c>
       (optlen == 0))
   {
      /* get an empty mbuf to "clone" the data */
      m = m_getnbuf(MT_TXDATA, 0);
 8238758:	000b883a 	mov	r5,zero
 823875c:	01000084 	movi	r4,2
 8238760:	822e2280 	call	822e228 <m_getnbuf>
 8238764:	e0bfed15 	stw	r2,-76(fp)
      if (!m)
 8238768:	e0bfed17 	ldw	r2,-76(fp)
 823876c:	1000031e 	bne	r2,zero,823877c <tcp_output+0x60c>
      {
         EXIT_CRIT_SECTION(tp);
 8238770:	822d64c0 	call	822d64c <irq_Unmask>
         return (ENOBUFS);
 8238774:	00801a44 	movi	r2,105
 8238778:	00027906 	br	8239160 <tcp_output+0xff0>
      }
      m->pkt = sendm->pkt; /* copy packet location in new mbuf */
 823877c:	e0bff017 	ldw	r2,-64(fp)
 8238780:	10c00117 	ldw	r3,4(r2)
 8238784:	e0bfed17 	ldw	r2,-76(fp)
 8238788:	10c00115 	stw	r3,4(r2)
      m->pkt->inuse++;     /* bump packet's use count */
 823878c:	e0bfed17 	ldw	r2,-76(fp)
 8238790:	10800117 	ldw	r2,4(r2)
 8238794:	10c00917 	ldw	r3,36(r2)
 8238798:	18c00044 	addi	r3,r3,1
 823879c:	10c00915 	stw	r3,36(r2)
      m->m_base = sendm->m_base; /* clone mbuf members */
 82387a0:	e0bff017 	ldw	r2,-64(fp)
 82387a4:	10c00417 	ldw	r3,16(r2)
 82387a8:	e0bfed17 	ldw	r2,-76(fp)
 82387ac:	10c00415 	stw	r3,16(r2)
      m->m_memsz = sendm->m_memsz;
 82387b0:	e0bff017 	ldw	r2,-64(fp)
 82387b4:	10c00517 	ldw	r3,20(r2)
 82387b8:	e0bfed17 	ldw	r2,-76(fp)
 82387bc:	10c00515 	stw	r3,20(r2)
      m->m_len = len + TCPIPHDRSZ;  /* adjust clone for header */
 82387c0:	e0bfea17 	ldw	r2,-88(fp)
 82387c4:	10800a04 	addi	r2,r2,40
 82387c8:	1007883a 	mov	r3,r2
 82387cc:	e0bfed17 	ldw	r2,-76(fp)
 82387d0:	10c00215 	stw	r3,8(r2)
      m->m_data = sendm->m_data - TCPIPHDRSZ;
 82387d4:	e0bff017 	ldw	r2,-64(fp)
 82387d8:	10800317 	ldw	r2,12(r2)
 82387dc:	10fff604 	addi	r3,r2,-40
 82387e0:	e0bfed17 	ldw	r2,-76(fp)
 82387e4:	10c00315 	stw	r3,12(r2)
 82387e8:	00002706 	br	8238888 <tcp_output+0x718>
   {
      /* Grab a header mbuf, attaching a copy of data to be 
       * transmitted, and initialize the header from 
       * the template for sends on this connection.
       */
      m = m_getwithdata (MT_HEADER, IFNETHDR_SIZE + TCPIPHDRSZ);
 82387ec:	d0a08117 	ldw	r2,-32252(gp)
 82387f0:	10800a04 	addi	r2,r2,40
 82387f4:	100b883a 	mov	r5,r2
 82387f8:	010000c4 	movi	r4,3
 82387fc:	822e2280 	call	822e228 <m_getnbuf>
 8238800:	e0bfed15 	stw	r2,-76(fp)
      if (m ==(struct mbuf *)NULL)
 8238804:	e0bfed17 	ldw	r2,-76(fp)
 8238808:	1000031e 	bne	r2,zero,8238818 <tcp_output+0x6a8>
      {
         EXIT_CRIT_SECTION(tp);
 823880c:	822d64c0 	call	822d64c <irq_Unmask>
         return ENOBUFS;
 8238810:	00801a44 	movi	r2,105
 8238814:	00025206 	br	8239160 <tcp_output+0xff0>
      }

      m->m_len = TCPIPHDRSZ;
 8238818:	e0bfed17 	ldw	r2,-76(fp)
 823881c:	00c00a04 	movi	r3,40
 8238820:	10c00215 	stw	r3,8(r2)
      m->m_data += IFNETHDR_SIZE;/* Move this to sizeof tcpip hdr leave*/
 8238824:	e0bfed17 	ldw	r2,-76(fp)
 8238828:	10800317 	ldw	r2,12(r2)
 823882c:	d0e08117 	ldw	r3,-32252(gp)
 8238830:	10c7883a 	add	r3,r2,r3
 8238834:	e0bfed17 	ldw	r2,-76(fp)
 8238838:	10c00315 	stw	r3,12(r2)
      /* 14 bytes for ethernet header      */

      if (len) /* attach any data to send */
 823883c:	e0bfea17 	ldw	r2,-88(fp)
 8238840:	10001126 	beq	r2,zero,8238888 <tcp_output+0x718>
      {
         m->m_next = m_copy(so->so_snd.sb_mb, off, (int) len);
 8238844:	e0bff217 	ldw	r2,-56(fp)
 8238848:	10801817 	ldw	r2,96(r2)
 823884c:	e1bfea17 	ldw	r6,-88(fp)
 8238850:	e17ff417 	ldw	r5,-48(fp)
 8238854:	1009883a 	mov	r4,r2
 8238858:	822e4fc0 	call	822e4fc <m_copy>
 823885c:	1007883a 	mov	r3,r2
 8238860:	e0bfed17 	ldw	r2,-76(fp)
 8238864:	10c00615 	stw	r3,24(r2)
         if (m->m_next == 0)
 8238868:	e0bfed17 	ldw	r2,-76(fp)
 823886c:	10800617 	ldw	r2,24(r2)
 8238870:	1000051e 	bne	r2,zero,8238888 <tcp_output+0x718>
         {
            m_freem(m);
 8238874:	e13fed17 	ldw	r4,-76(fp)
 8238878:	822e4b80 	call	822e4b8 <m_freem>
            EXIT_CRIT_SECTION(tp);
 823887c:	822d64c0 	call	822d64c <irq_Unmask>
            return ENOBUFS;
 8238880:	00801a44 	movi	r2,105
 8238884:	00023606 	br	8239160 <tcp_output+0xff0>
         }
      }
   }
   EXIT_CRIT_SECTION(tp);
 8238888:	822d64c0 	call	822d64c <irq_Unmask>

   if (len) 
 823888c:	e0bfea17 	ldw	r2,-88(fp)
 8238890:	10003726 	beq	r2,zero,8238970 <tcp_output+0x800>
   {
      if (tp->t_force && len == 1)
 8238894:	e0bfff17 	ldw	r2,-4(fp)
 8238898:	10800a83 	ldbu	r2,42(r2)
 823889c:	10803fcc 	andi	r2,r2,255
 82388a0:	1080201c 	xori	r2,r2,128
 82388a4:	10bfe004 	addi	r2,r2,-128
 82388a8:	10000b26 	beq	r2,zero,82388d8 <tcp_output+0x768>
 82388ac:	e0bfea17 	ldw	r2,-88(fp)
 82388b0:	10800058 	cmpnei	r2,r2,1
 82388b4:	1000081e 	bne	r2,zero,82388d8 <tcp_output+0x768>
         tcpstat.tcps_sndprobe++;
 82388b8:	008209b4 	movhi	r2,2086
 82388bc:	10b99404 	addi	r2,r2,-6576
 82388c0:	10801517 	ldw	r2,84(r2)
 82388c4:	10c00044 	addi	r3,r2,1
 82388c8:	008209b4 	movhi	r2,2086
 82388cc:	10b99404 	addi	r2,r2,-6576
 82388d0:	10c01515 	stw	r3,84(r2)
 82388d4:	00005306 	br	8238a24 <tcp_output+0x8b4>
      else if (SEQ_LT(tp->snd_nxt, tp->snd_max)) 
 82388d8:	e0bfff17 	ldw	r2,-4(fp)
 82388dc:	10c00f17 	ldw	r3,60(r2)
 82388e0:	e0bfff17 	ldw	r2,-4(fp)
 82388e4:	10801a17 	ldw	r2,104(r2)
 82388e8:	1885c83a 	sub	r2,r3,r2
 82388ec:	1000100e 	bge	r2,zero,8238930 <tcp_output+0x7c0>
      {
         tcpstat.tcps_sndrexmitpack++;
 82388f0:	008209b4 	movhi	r2,2086
 82388f4:	10b99404 	addi	r2,r2,-6576
 82388f8:	10801217 	ldw	r2,72(r2)
 82388fc:	10c00044 	addi	r3,r2,1
 8238900:	008209b4 	movhi	r2,2086
 8238904:	10b99404 	addi	r2,r2,-6576
 8238908:	10c01215 	stw	r3,72(r2)
         tcpstat.tcps_sndrexmitbyte += len;
 823890c:	008209b4 	movhi	r2,2086
 8238910:	10b99404 	addi	r2,r2,-6576
 8238914:	10c01317 	ldw	r3,76(r2)
 8238918:	e0bfea17 	ldw	r2,-88(fp)
 823891c:	1887883a 	add	r3,r3,r2
 8238920:	008209b4 	movhi	r2,2086
 8238924:	10b99404 	addi	r2,r2,-6576
 8238928:	10c01315 	stw	r3,76(r2)
 823892c:	00003d06 	br	8238a24 <tcp_output+0x8b4>
         tcpstat.tcps_sackresend++;
#endif
      } 
      else 
      {
         tcpstat.tcps_sndpack++;
 8238930:	008209b4 	movhi	r2,2086
 8238934:	10b99404 	addi	r2,r2,-6576
 8238938:	10801017 	ldw	r2,64(r2)
 823893c:	10c00044 	addi	r3,r2,1
 8238940:	008209b4 	movhi	r2,2086
 8238944:	10b99404 	addi	r2,r2,-6576
 8238948:	10c01015 	stw	r3,64(r2)
         tcpstat.tcps_sndbyte += len;
 823894c:	008209b4 	movhi	r2,2086
 8238950:	10b99404 	addi	r2,r2,-6576
 8238954:	10c01117 	ldw	r3,68(r2)
 8238958:	e0bfea17 	ldw	r2,-88(fp)
 823895c:	1887883a 	add	r3,r3,r2
 8238960:	008209b4 	movhi	r2,2086
 8238964:	10b99404 	addi	r2,r2,-6576
 8238968:	10c01115 	stw	r3,68(r2)
 823896c:	00002d06 	br	8238a24 <tcp_output+0x8b4>
      }
   }
   else if (tp->t_flags & TF_ACKNOW)
 8238970:	e0bfff17 	ldw	r2,-4(fp)
 8238974:	10800b0b 	ldhu	r2,44(r2)
 8238978:	10bfffcc 	andi	r2,r2,65535
 823897c:	1080004c 	andi	r2,r2,1
 8238980:	10000826 	beq	r2,zero,82389a4 <tcp_output+0x834>
   {
      tcpstat.tcps_sndacks++;
 8238984:	008209b4 	movhi	r2,2086
 8238988:	10b99404 	addi	r2,r2,-6576
 823898c:	10801417 	ldw	r2,80(r2)
 8238990:	10c00044 	addi	r3,r2,1
 8238994:	008209b4 	movhi	r2,2086
 8238998:	10b99404 	addi	r2,r2,-6576
 823899c:	10c01415 	stw	r3,80(r2)
 82389a0:	00002006 	br	8238a24 <tcp_output+0x8b4>
   }
   else if (flags & (TH_SYN|TH_FIN|TH_RST))
 82389a4:	e0bfec17 	ldw	r2,-80(fp)
 82389a8:	108001cc 	andi	r2,r2,7
 82389ac:	10000826 	beq	r2,zero,82389d0 <tcp_output+0x860>
      tcpstat.tcps_sndctrl++;
 82389b0:	008209b4 	movhi	r2,2086
 82389b4:	10b99404 	addi	r2,r2,-6576
 82389b8:	10801817 	ldw	r2,96(r2)
 82389bc:	10c00044 	addi	r3,r2,1
 82389c0:	008209b4 	movhi	r2,2086
 82389c4:	10b99404 	addi	r2,r2,-6576
 82389c8:	10c01815 	stw	r3,96(r2)
 82389cc:	00001506 	br	8238a24 <tcp_output+0x8b4>
   else if (SEQ_GT(tp->snd_up, tp->snd_una))
 82389d0:	e0bfff17 	ldw	r2,-4(fp)
 82389d4:	10c01017 	ldw	r3,64(r2)
 82389d8:	e0bfff17 	ldw	r2,-4(fp)
 82389dc:	10800e17 	ldw	r2,56(r2)
 82389e0:	1885c83a 	sub	r2,r3,r2
 82389e4:	0080080e 	bge	zero,r2,8238a08 <tcp_output+0x898>
      tcpstat.tcps_sndurg++;
 82389e8:	008209b4 	movhi	r2,2086
 82389ec:	10b99404 	addi	r2,r2,-6576
 82389f0:	10801617 	ldw	r2,88(r2)
 82389f4:	10c00044 	addi	r3,r2,1
 82389f8:	008209b4 	movhi	r2,2086
 82389fc:	10b99404 	addi	r2,r2,-6576
 8238a00:	10c01615 	stw	r3,88(r2)
 8238a04:	00000706 	br	8238a24 <tcp_output+0x8b4>
   else
      tcpstat.tcps_sndwinup++;
 8238a08:	008209b4 	movhi	r2,2086
 8238a0c:	10b99404 	addi	r2,r2,-6576
 8238a10:	10801717 	ldw	r2,92(r2)
 8238a14:	10c00044 	addi	r3,r2,1
 8238a18:	008209b4 	movhi	r2,2086
 8238a1c:	10b99404 	addi	r2,r2,-6576
 8238a20:	10c01715 	stw	r3,92(r2)

   ti = (struct tcpiphdr *)(m->m_data+sizeof(struct ip)-sizeof(struct ipovly));
 8238a24:	e0bfed17 	ldw	r2,-76(fp)
 8238a28:	10800317 	ldw	r2,12(r2)
 8238a2c:	e0bff515 	stw	r2,-44(fp)
   if ((char *)ti < m->pkt->nb_buff)
 8238a30:	e0bfed17 	ldw	r2,-76(fp)
 8238a34:	10800117 	ldw	r2,4(r2)
 8238a38:	10800117 	ldw	r2,4(r2)
 8238a3c:	e0fff517 	ldw	r3,-44(fp)
 8238a40:	1880032e 	bgeu	r3,r2,8238a50 <tcp_output+0x8e0>
   {
      panic("tcp_out- packet ptr underflow\n");
 8238a44:	01020974 	movhi	r4,2085
 8238a48:	2103ab04 	addi	r4,r4,3756
 8238a4c:	8228aec0 	call	8228aec <panic>
   }
   tcp_mbuf = m;        /* flag TCP header mbuf */
 8238a50:	e0bfed17 	ldw	r2,-76(fp)
 8238a54:	e0bff615 	stw	r2,-40(fp)
      tcp_mbuf->m_data += sizeof(struct ipovly);
      tcp_mbuf->m_len -= sizeof(struct ipovly);
   }
#endif   /* end IP_V6 */

   if (tp->t_template == 0)
 8238a58:	e0bfff17 	ldw	r2,-4(fp)
 8238a5c:	10800c17 	ldw	r2,48(r2)
 8238a60:	1000031e 	bne	r2,zero,8238a70 <tcp_output+0x900>
      panic("tcp_output");
 8238a64:	01020974 	movhi	r4,2085
 8238a68:	2103b304 	addi	r4,r4,3788
 8238a6c:	8228aec0 	call	8228aec <panic>

   MEMCPY((char*)ti, (char*)tp->t_template, sizeof(struct tcpiphdr));
 8238a70:	e0bfff17 	ldw	r2,-4(fp)
 8238a74:	10800c17 	ldw	r2,48(r2)
 8238a78:	01800a04 	movi	r6,40
 8238a7c:	100b883a 	mov	r5,r2
 8238a80:	e13ff517 	ldw	r4,-44(fp)
 8238a84:	8202e8c0 	call	8202e8c <memcpy>
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 8238a88:	e0bfec17 	ldw	r2,-80(fp)
 8238a8c:	1080004c 	andi	r2,r2,1
 8238a90:	10000f26 	beq	r2,zero,8238ad0 <tcp_output+0x960>
 8238a94:	e0bfff17 	ldw	r2,-4(fp)
 8238a98:	10800b0b 	ldhu	r2,44(r2)
 8238a9c:	10bfffcc 	andi	r2,r2,65535
 8238aa0:	1080040c 	andi	r2,r2,16
 8238aa4:	10000a26 	beq	r2,zero,8238ad0 <tcp_output+0x960>
       tp->snd_nxt == tp->snd_max)
 8238aa8:	e0bfff17 	ldw	r2,-4(fp)
 8238aac:	10c00f17 	ldw	r3,60(r2)
 8238ab0:	e0bfff17 	ldw	r2,-4(fp)
 8238ab4:	10801a17 	ldw	r2,104(r2)
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 8238ab8:	1880051e 	bne	r3,r2,8238ad0 <tcp_output+0x960>
       tp->snd_nxt == tp->snd_max)
   {
      tp->snd_nxt--;
 8238abc:	e0bfff17 	ldw	r2,-4(fp)
 8238ac0:	10800f17 	ldw	r2,60(r2)
 8238ac4:	10ffffc4 	addi	r3,r2,-1
 8238ac8:	e0bfff17 	ldw	r2,-4(fp)
 8238acc:	10c00f15 	stw	r3,60(r2)
   }

   ti->ti_seq = htonl(tp->snd_nxt);
 8238ad0:	e0bfff17 	ldw	r2,-4(fp)
 8238ad4:	10800f17 	ldw	r2,60(r2)
 8238ad8:	1006d63a 	srli	r3,r2,24
 8238adc:	e0bfff17 	ldw	r2,-4(fp)
 8238ae0:	10800f17 	ldw	r2,60(r2)
 8238ae4:	1004d23a 	srli	r2,r2,8
 8238ae8:	10bfc00c 	andi	r2,r2,65280
 8238aec:	1886b03a 	or	r3,r3,r2
 8238af0:	e0bfff17 	ldw	r2,-4(fp)
 8238af4:	10800f17 	ldw	r2,60(r2)
 8238af8:	10bfc00c 	andi	r2,r2,65280
 8238afc:	1004923a 	slli	r2,r2,8
 8238b00:	1886b03a 	or	r3,r3,r2
 8238b04:	e0bfff17 	ldw	r2,-4(fp)
 8238b08:	10800f17 	ldw	r2,60(r2)
 8238b0c:	1004963a 	slli	r2,r2,24
 8238b10:	1886b03a 	or	r3,r3,r2
 8238b14:	e0bff517 	ldw	r2,-44(fp)
 8238b18:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(tp->rcv_nxt);
 8238b1c:	e0bfff17 	ldw	r2,-4(fp)
 8238b20:	10801617 	ldw	r2,88(r2)
 8238b24:	1006d63a 	srli	r3,r2,24
 8238b28:	e0bfff17 	ldw	r2,-4(fp)
 8238b2c:	10801617 	ldw	r2,88(r2)
 8238b30:	1004d23a 	srli	r2,r2,8
 8238b34:	10bfc00c 	andi	r2,r2,65280
 8238b38:	1886b03a 	or	r3,r3,r2
 8238b3c:	e0bfff17 	ldw	r2,-4(fp)
 8238b40:	10801617 	ldw	r2,88(r2)
 8238b44:	10bfc00c 	andi	r2,r2,65280
 8238b48:	1004923a 	slli	r2,r2,8
 8238b4c:	1886b03a 	or	r3,r3,r2
 8238b50:	e0bfff17 	ldw	r2,-4(fp)
 8238b54:	10801617 	ldw	r2,88(r2)
 8238b58:	1004963a 	slli	r2,r2,24
 8238b5c:	1886b03a 	or	r3,r3,r2
 8238b60:	e0bff517 	ldw	r2,-44(fp)
 8238b64:	10c00715 	stw	r3,28(r2)
    * a retransmission, and the original SYN caused PPP to start
    * bringing the interface up, and PPP has got a new IP address
    * via IPCP), update the template and the inpcb with the new 
    * address.
    */
   if (flags & TH_SYN)
 8238b68:	e0bfec17 	ldw	r2,-80(fp)
 8238b6c:	1080008c 	andi	r2,r2,2
 8238b70:	10002426 	beq	r2,zero,8238c04 <tcp_output+0xa94>
   {
      struct inpcb * inp;
      inp = (struct inpcb *)so->so_pcb;
 8238b74:	e0bff217 	ldw	r2,-56(fp)
 8238b78:	10800117 	ldw	r2,4(r2)
 8238b7c:	e0bff715 	stw	r2,-36(fp)

      switch(so->so_domain)
 8238b80:	e0bff217 	ldw	r2,-56(fp)
 8238b84:	10800517 	ldw	r2,20(r2)
 8238b88:	108000a0 	cmpeqi	r2,r2,2
 8238b8c:	10001a26 	beq	r2,zero,8238bf8 <tcp_output+0xa88>
         }
         }
#endif   /* INCLUDE_PPP */

         /* If this is a SYN (not a SYN/ACK) then set the pmtu */
         if((flags & TH_ACK) == 0)
 8238b90:	e0bfec17 	ldw	r2,-80(fp)
 8238b94:	1080040c 	andi	r2,r2,16
 8238b98:	1000191e 	bne	r2,zero,8238c00 <tcp_output+0xa90>
            inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
            {
               NET ifp;
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
 8238b9c:	e0bff517 	ldw	r2,-44(fp)
 8238ba0:	10800417 	ldw	r2,16(r2)
 8238ba4:	e0fffe04 	addi	r3,fp,-8
 8238ba8:	180b883a 	mov	r5,r3
 8238bac:	1009883a 	mov	r4,r2
 8238bb0:	8240b4c0 	call	8240b4c <iproute>
 8238bb4:	e0bff815 	stw	r2,-32(fp)
               if(ifp)
 8238bb8:	e0bff817 	ldw	r2,-32(fp)
 8238bbc:	10000926 	beq	r2,zero,8238be4 <tcp_output+0xa74>
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 8238bc0:	e0bff817 	ldw	r2,-32(fp)
 8238bc4:	10c00917 	ldw	r3,36(r2)
 8238bc8:	e0bff817 	ldw	r2,-32(fp)
 8238bcc:	10800817 	ldw	r2,32(r2)
 8238bd0:	10800a04 	addi	r2,r2,40
 8238bd4:	1887c83a 	sub	r3,r3,r2
 8238bd8:	e0bff717 	ldw	r2,-36(fp)
 8238bdc:	10c00615 	stw	r3,24(r2)
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
            }
#endif   /* IP_PMTU */
         }
         break;
 8238be0:	00000706 	br	8238c00 <tcp_output+0xa90>
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
               if(ifp)
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
 8238be4:	e0bff717 	ldw	r2,-36(fp)
 8238be8:	00c09104 	movi	r3,580
 8238bec:	10c00615 	stw	r3,24(r2)
            }
#endif   /* IP_PMTU */
         }
         break;
 8238bf0:	0001883a 	nop
 8238bf4:	00000206 	br	8238c00 <tcp_output+0xa90>
         }
         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();    /* bad domain setting */
 8238bf8:	822d4140 	call	822d414 <dtrap>
 8238bfc:	00000106 	br	8238c04 <tcp_output+0xa94>
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
            }
#endif   /* IP_PMTU */
         }
         break;
 8238c00:	0001883a 	nop
         dtrap();    /* bad domain setting */
      }
   }

   /* fill in options if any are set */
   if (optlen)
 8238c04:	e0bfee17 	ldw	r2,-72(fp)
 8238c08:	10002b26 	beq	r2,zero,8238cb8 <tcp_output+0xb48>
   {
      struct mbuf * mopt;

      mopt = m_getwithdata(MT_TXDATA, MAXOPTLEN);
 8238c0c:	01404004 	movi	r5,256
 8238c10:	01000084 	movi	r4,2
 8238c14:	822e2280 	call	822e228 <m_getnbuf>
 8238c18:	e0bff915 	stw	r2,-28(fp)
      if (mopt == NULL) 
 8238c1c:	e0bff917 	ldw	r2,-28(fp)
 8238c20:	1000041e 	bne	r2,zero,8238c34 <tcp_output+0xac4>
      {
         m_freem(m);
 8238c24:	e13fed17 	ldw	r4,-76(fp)
 8238c28:	822e4b80 	call	822e4b8 <m_freem>
         return (ENOBUFS);
 8238c2c:	00801a44 	movi	r2,105
 8238c30:	00014b06 	br	8239160 <tcp_output+0xff0>
      }

      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
 8238c34:	e0bff617 	ldw	r2,-40(fp)
 8238c38:	10c00617 	ldw	r3,24(r2)
 8238c3c:	e0bff917 	ldw	r2,-28(fp)
 8238c40:	10c00615 	stw	r3,24(r2)
      tcp_mbuf->m_next = mopt;
 8238c44:	e0bff617 	ldw	r2,-40(fp)
 8238c48:	e0fff917 	ldw	r3,-28(fp)
 8238c4c:	10c00615 	stw	r3,24(r2)

      /* extend options to aligned address */
      while(optlen & 0x03)
 8238c50:	00000606 	br	8238c6c <tcp_output+0xafc>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;
 8238c54:	e0bfee17 	ldw	r2,-72(fp)
 8238c58:	10c00044 	addi	r3,r2,1
 8238c5c:	e0ffee15 	stw	r3,-72(fp)
 8238c60:	d0e0b304 	addi	r3,gp,-32052
 8238c64:	10c5883a 	add	r2,r2,r3
 8238c68:	10000005 	stb	zero,0(r2)
      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
      tcp_mbuf->m_next = mopt;

      /* extend options to aligned address */
      while(optlen & 0x03)
 8238c6c:	e0bfee17 	ldw	r2,-72(fp)
 8238c70:	108000cc 	andi	r2,r2,3
 8238c74:	103ff71e 	bne	r2,zero,8238c54 <tcp_output+0xae4>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;

      MEMCPY(mtod(mopt, char *), tcp_optionbuf, optlen);
 8238c78:	e0bff917 	ldw	r2,-28(fp)
 8238c7c:	10800317 	ldw	r2,12(r2)
 8238c80:	e1bfee17 	ldw	r6,-72(fp)
 8238c84:	d160b304 	addi	r5,gp,-32052
 8238c88:	1009883a 	mov	r4,r2
 8238c8c:	8202e8c0 	call	8202e8c <memcpy>
      mopt->m_len = optlen;
 8238c90:	e0bff917 	ldw	r2,-28(fp)
 8238c94:	e0ffee17 	ldw	r3,-72(fp)
 8238c98:	10c00215 	stw	r3,8(r2)
      /* use portable macro to set tcp data offset bits */
      SET_TH_OFF(ti->ti_t, ((sizeof (struct tcphdr) + optlen) >> 2));
 8238c9c:	e0bfee17 	ldw	r2,-72(fp)
 8238ca0:	10800504 	addi	r2,r2,20
 8238ca4:	1004d0ba 	srli	r2,r2,2
 8238ca8:	1004913a 	slli	r2,r2,4
 8238cac:	1007883a 	mov	r3,r2
 8238cb0:	e0bff517 	ldw	r2,-44(fp)
 8238cb4:	10c00805 	stb	r3,32(r2)
   }

   ti->ti_flags = (u_char)flags;
 8238cb8:	e0bfec17 	ldw	r2,-80(fp)
 8238cbc:	1007883a 	mov	r3,r2
 8238cc0:	e0bff517 	ldw	r2,-44(fp)
 8238cc4:	10c00845 	stb	r3,33(r2)
   /*
    * Calculate receive window. Don't shrink window,
    * but avoid silly window syndrome.
    */
   if (win < (long)(so->so_rcv.sb_hiwat / 4) && win < (long)tp->t_maxseg)
 8238cc8:	e0bff217 	ldw	r2,-56(fp)
 8238ccc:	10800b17 	ldw	r2,44(r2)
 8238cd0:	1004d0ba 	srli	r2,r2,2
 8238cd4:	1007883a 	mov	r3,r2
 8238cd8:	e0bfeb17 	ldw	r2,-84(fp)
 8238cdc:	10c0060e 	bge	r2,r3,8238cf8 <tcp_output+0xb88>
 8238ce0:	e0bfff17 	ldw	r2,-4(fp)
 8238ce4:	10800a0b 	ldhu	r2,40(r2)
 8238ce8:	10bfffcc 	andi	r2,r2,65535
 8238cec:	e0ffeb17 	ldw	r3,-84(fp)
 8238cf0:	1880010e 	bge	r3,r2,8238cf8 <tcp_output+0xb88>
      win = 0;
 8238cf4:	e03feb15 	stw	zero,-84(fp)
   if (win < (long)(tp->rcv_adv - tp->rcv_nxt))
 8238cf8:	e0bfff17 	ldw	r2,-4(fp)
 8238cfc:	10c01917 	ldw	r3,100(r2)
 8238d00:	e0bfff17 	ldw	r2,-4(fp)
 8238d04:	10801617 	ldw	r2,88(r2)
 8238d08:	1885c83a 	sub	r2,r3,r2
 8238d0c:	1007883a 	mov	r3,r2
 8238d10:	e0bfeb17 	ldw	r2,-84(fp)
 8238d14:	10c0060e 	bge	r2,r3,8238d30 <tcp_output+0xbc0>
      win = (long)(tp->rcv_adv - tp->rcv_nxt);
 8238d18:	e0bfff17 	ldw	r2,-4(fp)
 8238d1c:	10c01917 	ldw	r3,100(r2)
 8238d20:	e0bfff17 	ldw	r2,-4(fp)
 8238d24:	10801617 	ldw	r2,88(r2)
 8238d28:	1885c83a 	sub	r2,r3,r2
 8238d2c:	e0bfeb15 	stw	r2,-84(fp)

   /* do check for Iniche buffer limits -JB- */
   if (bigfreeq.q_len == 0)   /* If queue length is 0, set window to 0 */
 8238d30:	008209b4 	movhi	r2,2086
 8238d34:	10b8cb04 	addi	r2,r2,-7380
 8238d38:	10800217 	ldw	r2,8(r2)
 8238d3c:	1000021e 	bne	r2,zero,8238d48 <tcp_output+0xbd8>
   {
      win = 0;
 8238d40:	e03feb15 	stw	zero,-84(fp)
 8238d44:	00001006 	br	8238d88 <tcp_output+0xc18>
   }
   else if(win > (((long)bigfreeq.q_len - 1) * (long)bigbufsiz))
 8238d48:	008209b4 	movhi	r2,2086
 8238d4c:	10b8cb04 	addi	r2,r2,-7380
 8238d50:	10800217 	ldw	r2,8(r2)
 8238d54:	10bfffc4 	addi	r2,r2,-1
 8238d58:	d0e03917 	ldw	r3,-32540(gp)
 8238d5c:	10c7383a 	mul	r3,r2,r3
 8238d60:	e0bfeb17 	ldw	r2,-84(fp)
 8238d64:	1880080e 	bge	r3,r2,8238d88 <tcp_output+0xc18>
   {
      win = ((long)bigfreeq.q_len - 1) * bigbufsiz;
 8238d68:	008209b4 	movhi	r2,2086
 8238d6c:	10b8cb04 	addi	r2,r2,-7380
 8238d70:	10800217 	ldw	r2,8(r2)
 8238d74:	10bfffc4 	addi	r2,r2,-1
 8238d78:	1007883a 	mov	r3,r2
 8238d7c:	d0a03917 	ldw	r2,-32540(gp)
 8238d80:	1885383a 	mul	r2,r3,r2
 8238d84:	e0bfeb15 	stw	r2,-84(fp)
      ti->ti_win = htons((u_short)(win >> tp->rcv_wind_scale)); /* apply scale */
   }
   else
#endif /* TCP_WIN_SCALE */
   {
      ti->ti_win = htons((u_short)win);
 8238d88:	e0bfeb17 	ldw	r2,-84(fp)
 8238d8c:	10bfffcc 	andi	r2,r2,65535
 8238d90:	1005d23a 	srai	r2,r2,8
 8238d94:	10803fcc 	andi	r2,r2,255
 8238d98:	1007883a 	mov	r3,r2
 8238d9c:	e0bfeb17 	ldw	r2,-84(fp)
 8238da0:	10bfffcc 	andi	r2,r2,65535
 8238da4:	1004923a 	slli	r2,r2,8
 8238da8:	1884b03a 	or	r2,r3,r2
 8238dac:	1007883a 	mov	r3,r2
 8238db0:	e0bff517 	ldw	r2,-44(fp)
 8238db4:	10c0088d 	sth	r3,34(r2)
   }

   if (SEQ_GT(tp->snd_up, tp->snd_nxt)) 
 8238db8:	e0bfff17 	ldw	r2,-4(fp)
 8238dbc:	10c01017 	ldw	r3,64(r2)
 8238dc0:	e0bfff17 	ldw	r2,-4(fp)
 8238dc4:	10800f17 	ldw	r2,60(r2)
 8238dc8:	1885c83a 	sub	r2,r3,r2
 8238dcc:	00801c0e 	bge	zero,r2,8238e40 <tcp_output+0xcd0>
   {
      ti->ti_urp = htons((u_short)(tp->snd_up - tp->snd_nxt));
 8238dd0:	e0bfff17 	ldw	r2,-4(fp)
 8238dd4:	10801017 	ldw	r2,64(r2)
 8238dd8:	1007883a 	mov	r3,r2
 8238ddc:	e0bfff17 	ldw	r2,-4(fp)
 8238de0:	10800f17 	ldw	r2,60(r2)
 8238de4:	1885c83a 	sub	r2,r3,r2
 8238de8:	10bfffcc 	andi	r2,r2,65535
 8238dec:	1004d23a 	srli	r2,r2,8
 8238df0:	1007883a 	mov	r3,r2
 8238df4:	e0bfff17 	ldw	r2,-4(fp)
 8238df8:	10801017 	ldw	r2,64(r2)
 8238dfc:	1009883a 	mov	r4,r2
 8238e00:	e0bfff17 	ldw	r2,-4(fp)
 8238e04:	10800f17 	ldw	r2,60(r2)
 8238e08:	2085c83a 	sub	r2,r4,r2
 8238e0c:	10bfffcc 	andi	r2,r2,65535
 8238e10:	1004923a 	slli	r2,r2,8
 8238e14:	1884b03a 	or	r2,r3,r2
 8238e18:	1007883a 	mov	r3,r2
 8238e1c:	e0bff517 	ldw	r2,-44(fp)
 8238e20:	10c0098d 	sth	r3,38(r2)
      ti->ti_flags |= TH_URG;
 8238e24:	e0bff517 	ldw	r2,-44(fp)
 8238e28:	10800843 	ldbu	r2,33(r2)
 8238e2c:	10800814 	ori	r2,r2,32
 8238e30:	1007883a 	mov	r3,r2
 8238e34:	e0bff517 	ldw	r2,-44(fp)
 8238e38:	10c00845 	stb	r3,33(r2)
 8238e3c:	00000406 	br	8238e50 <tcp_output+0xce0>
       * If no urgent pointer to send, then we pull
       * the urgent pointer to the left edge of the send window
       * so that it doesn't drift into the send window on sequence
       * number wraparound.
       */
      tp->snd_up = tp->snd_una;        /* drag it along */
 8238e40:	e0bfff17 	ldw	r2,-4(fp)
 8238e44:	10c00e17 	ldw	r3,56(r2)
 8238e48:	e0bfff17 	ldw	r2,-4(fp)
 8238e4c:	10c01015 	stw	r3,64(r2)
   /*
    * If anything to send and we can send it all, set PUSH.
    * (This will keep happy those implementations which only
    * give data to the user when a buffer fills or a PUSH comes in.)
    */
   if (len && off+len == (int)so->so_snd.sb_cc)
 8238e50:	e0bfea17 	ldw	r2,-88(fp)
 8238e54:	10000c26 	beq	r2,zero,8238e88 <tcp_output+0xd18>
 8238e58:	e0fff417 	ldw	r3,-48(fp)
 8238e5c:	e0bfea17 	ldw	r2,-88(fp)
 8238e60:	1885883a 	add	r2,r3,r2
 8238e64:	e0fff217 	ldw	r3,-56(fp)
 8238e68:	18c01217 	ldw	r3,72(r3)
 8238e6c:	10c0061e 	bne	r2,r3,8238e88 <tcp_output+0xd18>
      ti->ti_flags |= TH_PUSH;
 8238e70:	e0bff517 	ldw	r2,-44(fp)
 8238e74:	10800843 	ldbu	r2,33(r2)
 8238e78:	10800214 	ori	r2,r2,8
 8238e7c:	1007883a 	mov	r3,r2
 8238e80:	e0bff517 	ldw	r2,-44(fp)
 8238e84:	10c00845 	stb	r3,33(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 8238e88:	e0bfff17 	ldw	r2,-4(fp)
 8238e8c:	10800a83 	ldbu	r2,42(r2)
 8238e90:	10803fcc 	andi	r2,r2,255
 8238e94:	1080201c 	xori	r2,r2,128
 8238e98:	10bfe004 	addi	r2,r2,-128
 8238e9c:	10000326 	beq	r2,zero,8238eac <tcp_output+0xd3c>
 8238ea0:	e0bfff17 	ldw	r2,-4(fp)
 8238ea4:	10800417 	ldw	r2,16(r2)
 8238ea8:	10004d1e 	bne	r2,zero,8238fe0 <tcp_output+0xe70>
   {
      tcp_seq startseq = tp->snd_nxt;
 8238eac:	e0bfff17 	ldw	r2,-4(fp)
 8238eb0:	10800f17 	ldw	r2,60(r2)
 8238eb4:	e0bffa15 	stw	r2,-24(fp)

      /*
       * Advance snd_nxt over sequence space of this segment.
       */
      if (flags & TH_SYN)
 8238eb8:	e0bfec17 	ldw	r2,-80(fp)
 8238ebc:	1080008c 	andi	r2,r2,2
 8238ec0:	10000526 	beq	r2,zero,8238ed8 <tcp_output+0xd68>
         tp->snd_nxt++;
 8238ec4:	e0bfff17 	ldw	r2,-4(fp)
 8238ec8:	10800f17 	ldw	r2,60(r2)
 8238ecc:	10c00044 	addi	r3,r2,1
 8238ed0:	e0bfff17 	ldw	r2,-4(fp)
 8238ed4:	10c00f15 	stw	r3,60(r2)

      if (flags & TH_FIN)
 8238ed8:	e0bfec17 	ldw	r2,-80(fp)
 8238edc:	1080004c 	andi	r2,r2,1
 8238ee0:	10000b26 	beq	r2,zero,8238f10 <tcp_output+0xda0>
      {
         tp->snd_nxt++;
 8238ee4:	e0bfff17 	ldw	r2,-4(fp)
 8238ee8:	10800f17 	ldw	r2,60(r2)
 8238eec:	10c00044 	addi	r3,r2,1
 8238ef0:	e0bfff17 	ldw	r2,-4(fp)
 8238ef4:	10c00f15 	stw	r3,60(r2)
         tp->t_flags |= TF_SENTFIN;
 8238ef8:	e0bfff17 	ldw	r2,-4(fp)
 8238efc:	10800b0b 	ldhu	r2,44(r2)
 8238f00:	10800414 	ori	r2,r2,16
 8238f04:	1007883a 	mov	r3,r2
 8238f08:	e0bfff17 	ldw	r2,-4(fp)
 8238f0c:	10c00b0d 	sth	r3,44(r2)
      }
      tp->snd_nxt += len;
 8238f10:	e0bfff17 	ldw	r2,-4(fp)
 8238f14:	10c00f17 	ldw	r3,60(r2)
 8238f18:	e0bfea17 	ldw	r2,-88(fp)
 8238f1c:	1887883a 	add	r3,r3,r2
 8238f20:	e0bfff17 	ldw	r2,-4(fp)
 8238f24:	10c00f15 	stw	r3,60(r2)
      if (SEQ_GT(tp->snd_nxt, tp->snd_max)) 
 8238f28:	e0bfff17 	ldw	r2,-4(fp)
 8238f2c:	10c00f17 	ldw	r3,60(r2)
 8238f30:	e0bfff17 	ldw	r2,-4(fp)
 8238f34:	10801a17 	ldw	r2,104(r2)
 8238f38:	1885c83a 	sub	r2,r3,r2
 8238f3c:	0080140e 	bge	zero,r2,8238f90 <tcp_output+0xe20>
      {
         tp->snd_max = tp->snd_nxt;
 8238f40:	e0bfff17 	ldw	r2,-4(fp)
 8238f44:	10c00f17 	ldw	r3,60(r2)
 8238f48:	e0bfff17 	ldw	r2,-4(fp)
 8238f4c:	10c01a15 	stw	r3,104(r2)
         /*
          * Time this transmission if not a retransmission and
          * not currently timing anything.
          */
         if (tp->t_rttick == 0) 
 8238f50:	e0bfff17 	ldw	r2,-4(fp)
 8238f54:	10801e17 	ldw	r2,120(r2)
 8238f58:	10000d1e 	bne	r2,zero,8238f90 <tcp_output+0xe20>
         {
            tp->t_rttick = cticks;
 8238f5c:	d0e0a817 	ldw	r3,-32096(gp)
 8238f60:	e0bfff17 	ldw	r2,-4(fp)
 8238f64:	10c01e15 	stw	r3,120(r2)
            tp->t_rtseq = startseq;
 8238f68:	e0bfff17 	ldw	r2,-4(fp)
 8238f6c:	e0fffa17 	ldw	r3,-24(fp)
 8238f70:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_segstimed++;
 8238f74:	008209b4 	movhi	r2,2086
 8238f78:	10b99404 	addi	r2,r2,-6576
 8238f7c:	10800617 	ldw	r2,24(r2)
 8238f80:	10c00044 	addi	r3,r2,1
 8238f84:	008209b4 	movhi	r2,2086
 8238f88:	10b99404 	addi	r2,r2,-6576
 8238f8c:	10c00615 	stw	r3,24(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 8238f90:	e0bfff17 	ldw	r2,-4(fp)
 8238f94:	10800317 	ldw	r2,12(r2)
 8238f98:	1000201e 	bne	r2,zero,823901c <tcp_output+0xeac>
          tp->snd_nxt != tp->snd_una) 
 8238f9c:	e0bfff17 	ldw	r2,-4(fp)
 8238fa0:	10c00f17 	ldw	r3,60(r2)
 8238fa4:	e0bfff17 	ldw	r2,-4(fp)
 8238fa8:	10800e17 	ldw	r2,56(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 8238fac:	18801b26 	beq	r3,r2,823901c <tcp_output+0xeac>
          tp->snd_nxt != tp->snd_una) 
      {
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 8238fb0:	e0bfff17 	ldw	r2,-4(fp)
 8238fb4:	10c00817 	ldw	r3,32(r2)
 8238fb8:	e0bfff17 	ldw	r2,-4(fp)
 8238fbc:	10c00315 	stw	r3,12(r2)
         if (tp->t_timer[TCPT_PERSIST]) 
 8238fc0:	e0bfff17 	ldw	r2,-4(fp)
 8238fc4:	10800417 	ldw	r2,16(r2)
 8238fc8:	10001426 	beq	r2,zero,823901c <tcp_output+0xeac>
         {
            tp->t_timer[TCPT_PERSIST] = 0;
 8238fcc:	e0bfff17 	ldw	r2,-4(fp)
 8238fd0:	10000415 	stw	zero,16(r2)
            tp->t_rxtshift = 0;
 8238fd4:	e0bfff17 	ldw	r2,-4(fp)
 8238fd8:	10000715 	stw	zero,28(r2)
   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
   {
 8238fdc:	00000f06 	br	823901c <tcp_output+0xeac>
         }
      }
   }
   else
   {
      if (SEQ_GT(tp->snd_nxt + len, tp->snd_max))
 8238fe0:	e0bfff17 	ldw	r2,-4(fp)
 8238fe4:	10c00f17 	ldw	r3,60(r2)
 8238fe8:	e0bfea17 	ldw	r2,-88(fp)
 8238fec:	1887883a 	add	r3,r3,r2
 8238ff0:	e0bfff17 	ldw	r2,-4(fp)
 8238ff4:	10801a17 	ldw	r2,104(r2)
 8238ff8:	1885c83a 	sub	r2,r3,r2
 8238ffc:	0080080e 	bge	zero,r2,8239020 <tcp_output+0xeb0>
         tp->snd_max = tp->snd_nxt + len;
 8239000:	e0bfff17 	ldw	r2,-4(fp)
 8239004:	10c00f17 	ldw	r3,60(r2)
 8239008:	e0bfea17 	ldw	r2,-88(fp)
 823900c:	1887883a 	add	r3,r3,r2
 8239010:	e0bfff17 	ldw	r2,-4(fp)
 8239014:	10c01a15 	stw	r3,104(r2)
 8239018:	00000106 	br	8239020 <tcp_output+0xeb0>
   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
   {
 823901c:	0001883a 	nop
   tcp_trace("tcp_output: sending, state %d, tcpcb: %x",
    tp->t_state, tp );
#endif

#ifdef MUTE_WARNS
   error = 0;
 8239020:	e03ffb15 	stw	zero,-20(fp)
   if(so->so_domain != AF_INET6)
#endif   /* IP_V6 */
   {
      struct ip * pip;
   
      pip = mtod(m, struct ip *);
 8239024:	e0bfed17 	ldw	r2,-76(fp)
 8239028:	10800317 	ldw	r2,12(r2)
 823902c:	e0bffc15 	stw	r2,-16(fp)
      /* Fill in IP length and send to IP level. */
      pip->ip_len = (u_short)(TCPIPHDRSZ + optlen + len);
 8239030:	e0bfee17 	ldw	r2,-72(fp)
 8239034:	1007883a 	mov	r3,r2
 8239038:	e0bfea17 	ldw	r2,-88(fp)
 823903c:	1885883a 	add	r2,r3,r2
 8239040:	10800a04 	addi	r2,r2,40
 8239044:	1007883a 	mov	r3,r2
 8239048:	e0bffc17 	ldw	r2,-16(fp)
 823904c:	10c0008d 	sth	r3,2(r2)
      error = ip_output(m, so->so_optsPack);
 8239050:	e0bff217 	ldw	r2,-56(fp)
 8239054:	10801f17 	ldw	r2,124(r2)
 8239058:	100b883a 	mov	r5,r2
 823905c:	e13fed17 	ldw	r4,-76(fp)
 8239060:	822ee540 	call	822ee54 <ip_output>
 8239064:	e0bffb15 	stw	r2,-20(fp)
                    (sizeof(struct ipv6) + sizeof(struct tcphdr) + optlen + len),
                    (struct   ip_socopts *)0);          
   }
#endif   /* IP_V6 */

   if (error)
 8239068:	e0bffb17 	ldw	r2,-20(fp)
 823906c:	10001326 	beq	r2,zero,82390bc <tcp_output+0xf4c>
   {
      if (error == ENOBUFS)   /* ip_output needed a copy buffer it couldn't get */
 8239070:	e0bffb17 	ldw	r2,-20(fp)
 8239074:	10801a58 	cmpnei	r2,r2,105
 8239078:	10000e1e 	bne	r2,zero,82390b4 <tcp_output+0xf44>
      {
         if (m->m_type == MT_FREE)  /* ip_output() probably freed first mbuf */
 823907c:	e0bfed17 	ldw	r2,-76(fp)
 8239080:	10800817 	ldw	r2,32(r2)
 8239084:	1000031e 	bne	r2,zero,8239094 <tcp_output+0xf24>
            m = m->m_next;
 8239088:	e0bfed17 	ldw	r2,-76(fp)
 823908c:	10800617 	ldw	r2,24(r2)
 8239090:	e0bfed15 	stw	r2,-76(fp)
         m_freem(m); /* free the mbuf chain */
 8239094:	e13fed17 	ldw	r4,-76(fp)
 8239098:	822e4b80 	call	822e4b8 <m_freem>
         tcp_quench(tp->t_inpcb);
 823909c:	e0bfff17 	ldw	r2,-4(fp)
 82390a0:	10800d17 	ldw	r2,52(r2)
 82390a4:	1009883a 	mov	r4,r2
 82390a8:	8239b400 	call	8239b40 <tcp_quench>
         return (error);
 82390ac:	e0bffb17 	ldw	r2,-20(fp)
 82390b0:	00002b06 	br	8239160 <tcp_output+0xff0>
      }
      return (error);
 82390b4:	e0bffb17 	ldw	r2,-20(fp)
 82390b8:	00002906 	br	8239160 <tcp_output+0xff0>

   /*
    * Data sent (as far as we can tell).
    */

   TCP_MIB_INC(tcpOutSegs);   /* keep MIB stats */
 82390bc:	008209b4 	movhi	r2,2086
 82390c0:	10b96604 	addi	r2,r2,-6760
 82390c4:	10800a17 	ldw	r2,40(r2)
 82390c8:	10c00044 	addi	r3,r2,1
 82390cc:	008209b4 	movhi	r2,2086
 82390d0:	10b96604 	addi	r2,r2,-6760
 82390d4:	10c00a15 	stw	r3,40(r2)
   tcpstat.tcps_sndtotal++;
 82390d8:	008209b4 	movhi	r2,2086
 82390dc:	10b99404 	addi	r2,r2,-6576
 82390e0:	10800f17 	ldw	r2,60(r2)
 82390e4:	10c00044 	addi	r3,r2,1
 82390e8:	008209b4 	movhi	r2,2086
 82390ec:	10b99404 	addi	r2,r2,-6576
 82390f0:	10c00f15 	stw	r3,60(r2)
   /*
    * If this advertises a larger window than any other segment,
    * then remember the size of the advertised window.
    * Any pending ACK has now been sent.
    */
   if (win > 0 && SEQ_GT(tp->rcv_nxt+win, tp->rcv_adv))
 82390f4:	e0bfeb17 	ldw	r2,-84(fp)
 82390f8:	00800e0e 	bge	zero,r2,8239134 <tcp_output+0xfc4>
 82390fc:	e0bfff17 	ldw	r2,-4(fp)
 8239100:	10c01617 	ldw	r3,88(r2)
 8239104:	e0bfeb17 	ldw	r2,-84(fp)
 8239108:	1887883a 	add	r3,r3,r2
 823910c:	e0bfff17 	ldw	r2,-4(fp)
 8239110:	10801917 	ldw	r2,100(r2)
 8239114:	1885c83a 	sub	r2,r3,r2
 8239118:	0080060e 	bge	zero,r2,8239134 <tcp_output+0xfc4>
      tp->rcv_adv = tp->rcv_nxt + (unsigned)win;
 823911c:	e0bfff17 	ldw	r2,-4(fp)
 8239120:	10c01617 	ldw	r3,88(r2)
 8239124:	e0bfeb17 	ldw	r2,-84(fp)
 8239128:	1887883a 	add	r3,r3,r2
 823912c:	e0bfff17 	ldw	r2,-4(fp)
 8239130:	10c01915 	stw	r3,100(r2)
   tp->t_flags &= ~(TF_ACKNOW|TF_SACKNOW|TF_DELACK);
 8239134:	e0bfff17 	ldw	r2,-4(fp)
 8239138:	10c00b0b 	ldhu	r3,44(r2)
 823913c:	00bfef04 	movi	r2,-68
 8239140:	1884703a 	and	r2,r3,r2
 8239144:	1007883a 	mov	r3,r2
 8239148:	e0bfff17 	ldw	r2,-4(fp)
 823914c:	10c00b0d 	sth	r3,44(r2)
   if (sendalot)
 8239150:	e0bfef17 	ldw	r2,-68(fp)
 8239154:	10000126 	beq	r2,zero,823915c <tcp_output+0xfec>
      goto again;
 8239158:	003c1606 	br	82381b4 <tcp_output+0x44>
   return (0);
 823915c:	0005883a 	mov	r2,zero
}
 8239160:	e037883a 	mov	sp,fp
 8239164:	dfc00117 	ldw	ra,4(sp)
 8239168:	df000017 	ldw	fp,0(sp)
 823916c:	dec00204 	addi	sp,sp,8
 8239170:	f800283a 	ret

08239174 <tcp_setpersist>:
 * RETURNS: NA
 */

void
tcp_setpersist(struct tcpcb * tp)
{
 8239174:	defffc04 	addi	sp,sp,-16
 8239178:	dfc00315 	stw	ra,12(sp)
 823917c:	df000215 	stw	fp,8(sp)
 8239180:	df000204 	addi	fp,sp,8
 8239184:	e13fff15 	stw	r4,-4(fp)
   int   t;

   t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 8239188:	e0bfff17 	ldw	r2,-4(fp)
 823918c:	10802017 	ldw	r2,128(r2)
 8239190:	1007d0ba 	srai	r3,r2,2
 8239194:	e0bfff17 	ldw	r2,-4(fp)
 8239198:	10802117 	ldw	r2,132(r2)
 823919c:	1885883a 	add	r2,r3,r2
 82391a0:	1005d07a 	srai	r2,r2,1
 82391a4:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_timer[TCPT_REXMT])
 82391a8:	e0bfff17 	ldw	r2,-4(fp)
 82391ac:	10800317 	ldw	r2,12(r2)
 82391b0:	10000326 	beq	r2,zero,82391c0 <tcp_setpersist+0x4c>
      panic("tcp_output REXMT");
 82391b4:	01020974 	movhi	r4,2085
 82391b8:	2103b604 	addi	r4,r4,3800
 82391bc:	8228aec0 	call	8228aec <panic>
   /*
    * Start/restart persistance timer.
    */
   TCPT_RANGESET(tp->t_timer[TCPT_PERSIST],
 82391c0:	e0bffe17 	ldw	r2,-8(fp)
 82391c4:	1009883a 	mov	r4,r2
 82391c8:	e0bfff17 	ldw	r2,-4(fp)
 82391cc:	10c00717 	ldw	r3,28(r2)
 82391d0:	00820974 	movhi	r2,2085
 82391d4:	108ecec4 	addi	r2,r2,15163
 82391d8:	10c5883a 	add	r2,r2,r3
 82391dc:	10800003 	ldbu	r2,0(r2)
 82391e0:	10803fcc 	andi	r2,r2,255
 82391e4:	2085383a 	mul	r2,r4,r2
 82391e8:	10ffffcc 	andi	r3,r2,65535
 82391ec:	18e0001c 	xori	r3,r3,32768
 82391f0:	18e00004 	addi	r3,r3,-32768
 82391f4:	e0bfff17 	ldw	r2,-4(fp)
 82391f8:	10c00415 	stw	r3,16(r2)
 82391fc:	e0bfff17 	ldw	r2,-4(fp)
 8239200:	10800417 	ldw	r2,16(r2)
 8239204:	10800288 	cmpgei	r2,r2,10
 8239208:	1000041e 	bne	r2,zero,823921c <tcp_setpersist+0xa8>
 823920c:	e0bfff17 	ldw	r2,-4(fp)
 8239210:	00c00284 	movi	r3,10
 8239214:	10c00415 	stw	r3,16(r2)
 8239218:	00000706 	br	8239238 <tcp_setpersist+0xc4>
 823921c:	e0bfff17 	ldw	r2,-4(fp)
 8239220:	10800417 	ldw	r2,16(r2)
 8239224:	10801e50 	cmplti	r2,r2,121
 8239228:	1000031e 	bne	r2,zero,8239238 <tcp_setpersist+0xc4>
 823922c:	e0bfff17 	ldw	r2,-4(fp)
 8239230:	00c01e04 	movi	r3,120
 8239234:	10c00415 	stw	r3,16(r2)
    t * tcp_backoff[tp->t_rxtshift],
    TCPTV_PERSMIN, TCPTV_PERSMAX);
   if (tp->t_rxtshift < TCP_MAXRXTSHIFT)
 8239238:	e0bfff17 	ldw	r2,-4(fp)
 823923c:	10800717 	ldw	r2,28(r2)
 8239240:	10800308 	cmpgei	r2,r2,12
 8239244:	1000051e 	bne	r2,zero,823925c <tcp_setpersist+0xe8>
      tp->t_rxtshift++;
 8239248:	e0bfff17 	ldw	r2,-4(fp)
 823924c:	10800717 	ldw	r2,28(r2)
 8239250:	10c00044 	addi	r3,r2,1
 8239254:	e0bfff17 	ldw	r2,-4(fp)
 8239258:	10c00715 	stw	r3,28(r2)

}
 823925c:	0001883a 	nop
 8239260:	e037883a 	mov	sp,fp
 8239264:	dfc00117 	ldw	ra,4(sp)
 8239268:	df000017 	ldw	fp,0(sp)
 823926c:	dec00204 	addi	sp,sp,8
 8239270:	f800283a 	ret

08239274 <bld_options>:
 * RETURNS: length of option data added to buffer
 */

static int
bld_options(struct tcpcb * tp, u_char * cp, int flags, struct socket * so)
{
 8239274:	defff804 	addi	sp,sp,-32
 8239278:	dfc00715 	stw	ra,28(sp)
 823927c:	df000615 	stw	fp,24(sp)
 8239280:	df000604 	addi	fp,sp,24
 8239284:	e13ffc15 	stw	r4,-16(fp)
 8239288:	e17ffd15 	stw	r5,-12(fp)
 823928c:	e1bffe15 	stw	r6,-8(fp)
 8239290:	e1ffff15 	stw	r7,-4(fp)
   int      len;
   u_short  mss;

   if(tp->t_flags & TF_NOOPT)    /* no options allowed? */
 8239294:	e0bffc17 	ldw	r2,-16(fp)
 8239298:	10800b0b 	ldhu	r2,44(r2)
 823929c:	10bfffcc 	andi	r2,r2,65535
 82392a0:	1080020c 	andi	r2,r2,8
 82392a4:	10000226 	beq	r2,zero,82392b0 <bld_options+0x3c>
      return 0;
 82392a8:	0005883a 	mov	r2,zero
 82392ac:	00001e06 	br	8239328 <bld_options+0xb4>

   /* Alway put MSS option on SYN packets */
   if (flags & TH_SYN)
 82392b0:	e0bffe17 	ldw	r2,-8(fp)
 82392b4:	1080008c 	andi	r2,r2,2
 82392b8:	10001926 	beq	r2,zero,8239320 <bld_options+0xac>
   {
      mss   =  (u_short)tcp_mss(so);
 82392bc:	e13fff17 	ldw	r4,-4(fp)
 82392c0:	82380780 	call	8238078 <tcp_mss>
 82392c4:	e0bffb0d 	sth	r2,-20(fp)

      /* always send MSS option on SYN, fill in MSS parm */
      *(cp + 0) = TCPOPT_MAXSEG;
 82392c8:	e0bffd17 	ldw	r2,-12(fp)
 82392cc:	00c00084 	movi	r3,2
 82392d0:	10c00005 	stb	r3,0(r2)
      *(cp + 1) = MSSOPT_LEN;               /* length byte */
 82392d4:	e0bffd17 	ldw	r2,-12(fp)
 82392d8:	10800044 	addi	r2,r2,1
 82392dc:	00c00104 	movi	r3,4
 82392e0:	10c00005 	stb	r3,0(r2)
      *(cp + 2)  = (u_char) ((mss & 0xff00) >> 8);
 82392e4:	e0bffd17 	ldw	r2,-12(fp)
 82392e8:	10800084 	addi	r2,r2,2
 82392ec:	e0fffb0b 	ldhu	r3,-20(fp)
 82392f0:	1806d23a 	srli	r3,r3,8
 82392f4:	10c00005 	stb	r3,0(r2)
      *(cp + 3)  = (u_char) (mss & 0xff);
 82392f8:	e0bffd17 	ldw	r2,-12(fp)
 82392fc:	108000c4 	addi	r2,r2,3
 8239300:	e0fffb0b 	ldhu	r3,-20(fp)
 8239304:	10c00005 	stb	r3,0(r2)
      len = 4;
 8239308:	00800104 	movi	r2,4
 823930c:	e0bffa15 	stw	r2,-24(fp)
      cp += 4;
 8239310:	e0bffd17 	ldw	r2,-12(fp)
 8239314:	10800104 	addi	r2,r2,4
 8239318:	e0bffd15 	stw	r2,-12(fp)
 823931c:	00000106 	br	8239324 <bld_options+0xb0>
   }
   else
      len = 0;
 8239320:	e03ffa15 	stw	zero,-24(fp)
      len += 10;
   }
#endif   /* TCP_TIMESTAMP */

   USE_ARG(so);
   return len;
 8239324:	e0bffa17 	ldw	r2,-24(fp)
}
 8239328:	e037883a 	mov	sp,fp
 823932c:	dfc00117 	ldw	ra,4(sp)
 8239330:	df000017 	ldw	fp,0(sp)
 8239334:	dec00204 	addi	sp,sp,8
 8239338:	f800283a 	ret

0823933c <tcp_init>:
 * RETURNS: 
 */

void
tcp_init()
{
 823933c:	deffff04 	addi	sp,sp,-4
 8239340:	df000015 	stw	fp,0(sp)
 8239344:	d839883a 	mov	fp,sp
   tcp_iss = 1;      /* wrong */
 8239348:	00800044 	movi	r2,1
 823934c:	d0a0b515 	stw	r2,-32044(gp)
   tcb.inp_next = tcb.inp_prev = &tcb;
 8239350:	008209b4 	movhi	r2,2086
 8239354:	10b98904 	addi	r2,r2,-6620
 8239358:	00c209b4 	movhi	r3,2086
 823935c:	18f98904 	addi	r3,r3,-6620
 8239360:	10c00115 	stw	r3,4(r2)
 8239364:	008209b4 	movhi	r2,2086
 8239368:	10b98904 	addi	r2,r2,-6620
 823936c:	10c00117 	ldw	r3,4(r2)
 8239370:	008209b4 	movhi	r2,2086
 8239374:	10b98904 	addi	r2,r2,-6620
 8239378:	10c00015 	stw	r3,0(r2)
}
 823937c:	0001883a 	nop
 8239380:	e037883a 	mov	sp,fp
 8239384:	df000017 	ldw	fp,0(sp)
 8239388:	dec00104 	addi	sp,sp,4
 823938c:	f800283a 	ret

08239390 <tcp_template>:
 * RETURNS: 
 */

struct tcpiphdr * 
tcp_template(struct tcpcb * tp)
{
 8239390:	defffb04 	addi	sp,sp,-20
 8239394:	dfc00415 	stw	ra,16(sp)
 8239398:	df000315 	stw	fp,12(sp)
 823939c:	df000304 	addi	fp,sp,12
 82393a0:	e13fff15 	stw	r4,-4(fp)
   struct inpcb * inp   =  tp->t_inpcb;
 82393a4:	e0bfff17 	ldw	r2,-4(fp)
 82393a8:	10800d17 	ldw	r2,52(r2)
 82393ac:	e0bffe15 	stw	r2,-8(fp)
   struct tcpiphdr * n;

   if ((n = tp->t_template) == 0)
 82393b0:	e0bfff17 	ldw	r2,-4(fp)
 82393b4:	10800c17 	ldw	r2,48(r2)
 82393b8:	e0bffd15 	stw	r2,-12(fp)
 82393bc:	e0bffd17 	ldw	r2,-12(fp)
 82393c0:	1000071e 	bne	r2,zero,82393e0 <tcp_template+0x50>
   {
      n = (struct tcpiphdr *)TPH_ALLOC (sizeof (*n));
 82393c4:	01000a04 	movi	r4,40
 82393c8:	822dfec0 	call	822dfec <npalloc>
 82393cc:	e0bffd15 	stw	r2,-12(fp)
      if (n == NULL)
 82393d0:	e0bffd17 	ldw	r2,-12(fp)
 82393d4:	1000021e 	bne	r2,zero,82393e0 <tcp_template+0x50>
         return (0);
 82393d8:	0005883a 	mov	r2,zero
 82393dc:	00002906 	br	8239484 <tcp_template+0xf4>
   }
   n->ti_next = n->ti_prev = 0;
 82393e0:	e0bffd17 	ldw	r2,-12(fp)
 82393e4:	10000115 	stw	zero,4(r2)
 82393e8:	e0bffd17 	ldw	r2,-12(fp)
 82393ec:	10c00117 	ldw	r3,4(r2)
 82393f0:	e0bffd17 	ldw	r2,-12(fp)
 82393f4:	10c00015 	stw	r3,0(r2)
   n->ti_len = htons(sizeof (struct tcpiphdr) - sizeof (struct ip));
 82393f8:	e0bffd17 	ldw	r2,-12(fp)
 82393fc:	00c50004 	movi	r3,5120
 8239400:	10c0028d 	sth	r3,10(r2)
   n->ti_src = inp->inp_laddr;
 8239404:	e0bffd17 	ldw	r2,-12(fp)
 8239408:	e0fffe17 	ldw	r3,-8(fp)
 823940c:	18c00417 	ldw	r3,16(r3)
 8239410:	10c00315 	stw	r3,12(r2)
   n->ti_dst = inp->inp_faddr;
 8239414:	e0bffd17 	ldw	r2,-12(fp)
 8239418:	e0fffe17 	ldw	r3,-8(fp)
 823941c:	18c00317 	ldw	r3,12(r3)
 8239420:	10c00415 	stw	r3,16(r2)
   n->ti_sport = inp->inp_lport;
 8239424:	e0bffe17 	ldw	r2,-8(fp)
 8239428:	10c0078b 	ldhu	r3,30(r2)
 823942c:	e0bffd17 	ldw	r2,-12(fp)
 8239430:	10c0050d 	sth	r3,20(r2)
   n->ti_dport = inp->inp_fport;
 8239434:	e0bffe17 	ldw	r2,-8(fp)
 8239438:	10c0070b 	ldhu	r3,28(r2)
 823943c:	e0bffd17 	ldw	r2,-12(fp)
 8239440:	10c0058d 	sth	r3,22(r2)
   n->ti_seq = 0;
 8239444:	e0bffd17 	ldw	r2,-12(fp)
 8239448:	10000615 	stw	zero,24(r2)
   n->ti_ack = 0;
 823944c:	e0bffd17 	ldw	r2,-12(fp)
 8239450:	10000715 	stw	zero,28(r2)
   n->ti_t.th_doff = (5 << 4);   /* NetPort */
 8239454:	e0bffd17 	ldw	r2,-12(fp)
 8239458:	00c01404 	movi	r3,80
 823945c:	10c00805 	stb	r3,32(r2)
   n->ti_flags = 0;
 8239460:	e0bffd17 	ldw	r2,-12(fp)
 8239464:	10000845 	stb	zero,33(r2)
   n->ti_win = 0;
 8239468:	e0bffd17 	ldw	r2,-12(fp)
 823946c:	1000088d 	sth	zero,34(r2)
   n->ti_sum = 0;
 8239470:	e0bffd17 	ldw	r2,-12(fp)
 8239474:	1000090d 	sth	zero,36(r2)
   n->ti_urp = 0;
 8239478:	e0bffd17 	ldw	r2,-12(fp)
 823947c:	1000098d 	sth	zero,38(r2)
   return (n);
 8239480:	e0bffd17 	ldw	r2,-12(fp)
}
 8239484:	e037883a 	mov	sp,fp
 8239488:	dfc00117 	ldw	ra,4(sp)
 823948c:	df000017 	ldw	fp,0(sp)
 8239490:	dec00204 	addi	sp,sp,8
 8239494:	f800283a 	ret

08239498 <tcp_respond>:
   struct tcpiphdr * ti,
   tcp_seq  ack,
   tcp_seq  seq,
   int   flags,
   struct mbuf *  ti_mbuf)
{
 8239498:	defff204 	addi	sp,sp,-56
 823949c:	dfc00d15 	stw	ra,52(sp)
 82394a0:	df000c15 	stw	fp,48(sp)
 82394a4:	df000c04 	addi	fp,sp,48
 82394a8:	e13ffc15 	stw	r4,-16(fp)
 82394ac:	e17ffd15 	stw	r5,-12(fp)
 82394b0:	e1bffe15 	stw	r6,-8(fp)
 82394b4:	e1ffff15 	stw	r7,-4(fp)
   int      tlen;       /* tcp data len - 0 or 1 */
   int      domain;     /* AF_INET or AF_INET6 */
   int      win = 0;    /* window to use in sent packet */
 82394b8:	e03ff615 	stw	zero,-40(fp)
   struct mbuf *  m;    /* mbuf to send */
   struct tcpiphdr * tmp_thdr;   /* scratch */

   if (tp)
 82394bc:	e0bffc17 	ldw	r2,-16(fp)
 82394c0:	10001726 	beq	r2,zero,8239520 <tcp_respond+0x88>
      win = (int)sbspace(&tp->t_inpcb->inp_socket->so_rcv);
 82394c4:	e0bffc17 	ldw	r2,-16(fp)
 82394c8:	10800d17 	ldw	r2,52(r2)
 82394cc:	10800817 	ldw	r2,32(r2)
 82394d0:	10800b17 	ldw	r2,44(r2)
 82394d4:	1007883a 	mov	r3,r2
 82394d8:	e0bffc17 	ldw	r2,-16(fp)
 82394dc:	10800d17 	ldw	r2,52(r2)
 82394e0:	10800817 	ldw	r2,32(r2)
 82394e4:	10800a17 	ldw	r2,40(r2)
 82394e8:	1885c83a 	sub	r2,r3,r2
 82394ec:	10000a16 	blt	r2,zero,8239518 <tcp_respond+0x80>
 82394f0:	e0bffc17 	ldw	r2,-16(fp)
 82394f4:	10800d17 	ldw	r2,52(r2)
 82394f8:	10800817 	ldw	r2,32(r2)
 82394fc:	10c00b17 	ldw	r3,44(r2)
 8239500:	e0bffc17 	ldw	r2,-16(fp)
 8239504:	10800d17 	ldw	r2,52(r2)
 8239508:	10800817 	ldw	r2,32(r2)
 823950c:	10800a17 	ldw	r2,40(r2)
 8239510:	1885c83a 	sub	r2,r3,r2
 8239514:	00000106 	br	823951c <tcp_respond+0x84>
 8239518:	0005883a 	mov	r2,zero
 823951c:	e0bff615 	stw	r2,-40(fp)

   /* Figure out of we can recycle the passed buffer or if we need a 
    * new one. Construct the easy parts of the the TCP and IP headers.
    */
   if (flags == 0)   /* sending keepalive from timer */
 8239520:	e0800217 	ldw	r2,8(fp)
 8239524:	1000261e 	bne	r2,zero,82395c0 <tcp_respond+0x128>
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
 8239528:	01401004 	movi	r5,64
 823952c:	010000c4 	movi	r4,3
 8239530:	822e2280 	call	822e228 <m_getnbuf>
 8239534:	e0bff715 	stw	r2,-36(fp)
      if (m == NULL)
 8239538:	e0bff717 	ldw	r2,-36(fp)
 823953c:	1000d026 	beq	r2,zero,8239880 <tcp_respond+0x3e8>
         return;
      tlen = 1;   /* Keepalives have one byte of data */
 8239540:	00800044 	movi	r2,1
 8239544:	e0bff415 	stw	r2,-48(fp)
      m->m_len = TCPIPHDRSZ + tlen;
 8239548:	e0bff417 	ldw	r2,-48(fp)
 823954c:	10800a04 	addi	r2,r2,40
 8239550:	1007883a 	mov	r3,r2
 8239554:	e0bff717 	ldw	r2,-36(fp)
 8239558:	10c00215 	stw	r3,8(r2)
      /*
       * Copy template contents into the mbuf and set ti to point
       * to the header structure in the mbuf.
       */
      tmp_thdr = (struct tcpiphdr *)((char *)m->m_data+sizeof(struct ip)
 823955c:	e0bff717 	ldw	r2,-36(fp)
 8239560:	10800317 	ldw	r2,12(r2)
 8239564:	e0bff815 	stw	r2,-32(fp)
         - sizeof(struct ipovly));
      if ((char *)tmp_thdr < m->pkt->nb_buff)
 8239568:	e0bff717 	ldw	r2,-36(fp)
 823956c:	10800117 	ldw	r2,4(r2)
 8239570:	10800117 	ldw	r2,4(r2)
 8239574:	e0fff817 	ldw	r3,-32(fp)
 8239578:	1880032e 	bgeu	r3,r2,8239588 <tcp_respond+0xf0>
      {
         panic("tcp_respond- packet ptr underflow\n");
 823957c:	01020974 	movhi	r4,2085
 8239580:	2103bb04 	addi	r4,r4,3820
 8239584:	8228aec0 	call	8228aec <panic>
      }
      MEMCPY(tmp_thdr, ti, sizeof(struct tcpiphdr));
 8239588:	01800a04 	movi	r6,40
 823958c:	e17ffd17 	ldw	r5,-12(fp)
 8239590:	e13ff817 	ldw	r4,-32(fp)
 8239594:	8202e8c0 	call	8202e8c <memcpy>
      ti = tmp_thdr;
 8239598:	e0bff817 	ldw	r2,-32(fp)
 823959c:	e0bffd15 	stw	r2,-12(fp)
      flags = TH_ACK;
 82395a0:	00800404 	movi	r2,16
 82395a4:	e0800215 	stw	r2,8(fp)
      domain = tp->t_inpcb->inp_socket->so_domain;
 82395a8:	e0bffc17 	ldw	r2,-16(fp)
 82395ac:	10800d17 	ldw	r2,52(r2)
 82395b0:	10800817 	ldw	r2,32(r2)
 82395b4:	10800517 	ldw	r2,20(r2)
 82395b8:	e0bff515 	stw	r2,-44(fp)
 82395bc:	00003b06 	br	82396ac <tcp_respond+0x214>
   }
   else  /* Flag was passed (e.g. reset); recycle passed mbuf */
   {
      m = ti_mbuf;   /*dtom(ti);*/
 82395c0:	e0800317 	ldw	r2,12(fp)
 82395c4:	e0bff715 	stw	r2,-36(fp)
      if(m->pkt->type == IPTP)   /* IPv4 packet */
 82395c8:	e0bff717 	ldw	r2,-36(fp)
 82395cc:	10800117 	ldw	r2,4(r2)
 82395d0:	1080080b 	ldhu	r2,32(r2)
 82395d4:	10bfffcc 	andi	r2,r2,65535
 82395d8:	10800218 	cmpnei	r2,r2,8
 82395dc:	1000031e 	bne	r2,zero,82395ec <tcp_respond+0x154>
         domain = AF_INET;
 82395e0:	00800084 	movi	r2,2
 82395e4:	e0bff515 	stw	r2,-44(fp)
 82395e8:	00000206 	br	82395f4 <tcp_respond+0x15c>
      else
         domain = AF_INET6;
 82395ec:	008000c4 	movi	r2,3
 82395f0:	e0bff515 	stw	r2,-44(fp)

      m_freem(m->m_next);
 82395f4:	e0bff717 	ldw	r2,-36(fp)
 82395f8:	10800617 	ldw	r2,24(r2)
 82395fc:	1009883a 	mov	r4,r2
 8239600:	822e4b80 	call	822e4b8 <m_freem>
      m->m_next = 0;
 8239604:	e0bff717 	ldw	r2,-36(fp)
 8239608:	10000615 	stw	zero,24(r2)
      tlen = 0;         /* NO data */
 823960c:	e03ff415 	stw	zero,-48(fp)
      m->m_len = TCPIPHDRSZ;
 8239610:	e0bff717 	ldw	r2,-36(fp)
 8239614:	00c00a04 	movi	r3,40
 8239618:	10c00215 	stw	r3,8(r2)
      xchg(ti->ti_dport, ti->ti_sport, u_short);
 823961c:	e0bffd17 	ldw	r2,-12(fp)
 8239620:	1080058b 	ldhu	r2,22(r2)
 8239624:	e0bff90d 	sth	r2,-28(fp)
 8239628:	e0bffd17 	ldw	r2,-12(fp)
 823962c:	10c0050b 	ldhu	r3,20(r2)
 8239630:	e0bffd17 	ldw	r2,-12(fp)
 8239634:	10c0058d 	sth	r3,22(r2)
 8239638:	e0bffd17 	ldw	r2,-12(fp)
 823963c:	e0fff90b 	ldhu	r3,-28(fp)
 8239640:	10c0050d 	sth	r3,20(r2)
      if(m->pkt->type == IPTP)
 8239644:	e0bff717 	ldw	r2,-36(fp)
 8239648:	10800117 	ldw	r2,4(r2)
 823964c:	1080080b 	ldhu	r2,32(r2)
 8239650:	10bfffcc 	andi	r2,r2,65535
 8239654:	10800218 	cmpnei	r2,r2,8
 8239658:	10000a1e 	bne	r2,zero,8239684 <tcp_respond+0x1ec>
         xchg(ti->ti_dst.s_addr, ti->ti_src.s_addr, u_long);
 823965c:	e0bffd17 	ldw	r2,-12(fp)
 8239660:	10800417 	ldw	r2,16(r2)
 8239664:	e0bffa15 	stw	r2,-24(fp)
 8239668:	e0bffd17 	ldw	r2,-12(fp)
 823966c:	10c00317 	ldw	r3,12(r2)
 8239670:	e0bffd17 	ldw	r2,-12(fp)
 8239674:	10c00415 	stw	r3,16(r2)
 8239678:	e0bffd17 	ldw	r2,-12(fp)
 823967c:	e0fffa17 	ldw	r3,-24(fp)
 8239680:	10c00315 	stw	r3,12(r2)
      if (flags & TH_RST)  /* count resets in MIB */
 8239684:	e0800217 	ldw	r2,8(fp)
 8239688:	1080010c 	andi	r2,r2,4
 823968c:	10000726 	beq	r2,zero,82396ac <tcp_respond+0x214>
         TCP_MIB_INC(tcpOutRsts);   /* keep MIB stats */
 8239690:	008209b4 	movhi	r2,2086
 8239694:	10b96604 	addi	r2,r2,-6760
 8239698:	10800e17 	ldw	r2,56(r2)
 823969c:	10c00044 	addi	r3,r2,1
 82396a0:	008209b4 	movhi	r2,2086
 82396a4:	10b96604 	addi	r2,r2,-6760
 82396a8:	10c00e15 	stw	r3,56(r2)
   }

   /* finish constructing the TCP header */
   ti->ti_seq = htonl(seq);
 82396ac:	e0bfff17 	ldw	r2,-4(fp)
 82396b0:	1006d63a 	srli	r3,r2,24
 82396b4:	e0bfff17 	ldw	r2,-4(fp)
 82396b8:	1004d23a 	srli	r2,r2,8
 82396bc:	10bfc00c 	andi	r2,r2,65280
 82396c0:	1886b03a 	or	r3,r3,r2
 82396c4:	e0bfff17 	ldw	r2,-4(fp)
 82396c8:	10bfc00c 	andi	r2,r2,65280
 82396cc:	1004923a 	slli	r2,r2,8
 82396d0:	1886b03a 	or	r3,r3,r2
 82396d4:	e0bfff17 	ldw	r2,-4(fp)
 82396d8:	1004963a 	slli	r2,r2,24
 82396dc:	1886b03a 	or	r3,r3,r2
 82396e0:	e0bffd17 	ldw	r2,-12(fp)
 82396e4:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(ack);
 82396e8:	e0bffe17 	ldw	r2,-8(fp)
 82396ec:	1006d63a 	srli	r3,r2,24
 82396f0:	e0bffe17 	ldw	r2,-8(fp)
 82396f4:	1004d23a 	srli	r2,r2,8
 82396f8:	10bfc00c 	andi	r2,r2,65280
 82396fc:	1886b03a 	or	r3,r3,r2
 8239700:	e0bffe17 	ldw	r2,-8(fp)
 8239704:	10bfc00c 	andi	r2,r2,65280
 8239708:	1004923a 	slli	r2,r2,8
 823970c:	1886b03a 	or	r3,r3,r2
 8239710:	e0bffe17 	ldw	r2,-8(fp)
 8239714:	1004963a 	slli	r2,r2,24
 8239718:	1886b03a 	or	r3,r3,r2
 823971c:	e0bffd17 	ldw	r2,-12(fp)
 8239720:	10c00715 	stw	r3,28(r2)
   ti->ti_t.th_doff = 0x50;      /* NetPort: init data offset bits */
 8239724:	e0bffd17 	ldw	r2,-12(fp)
 8239728:	00c01404 	movi	r3,80
 823972c:	10c00805 	stb	r3,32(r2)
   ti->ti_flags = (u_char)flags;
 8239730:	e0800217 	ldw	r2,8(fp)
 8239734:	1007883a 	mov	r3,r2
 8239738:	e0bffd17 	ldw	r2,-12(fp)
 823973c:	10c00845 	stb	r3,33(r2)
   ti->ti_win = htons((u_short)win);
 8239740:	e0bff617 	ldw	r2,-40(fp)
 8239744:	10bfffcc 	andi	r2,r2,65535
 8239748:	1005d23a 	srai	r2,r2,8
 823974c:	10803fcc 	andi	r2,r2,255
 8239750:	1007883a 	mov	r3,r2
 8239754:	e0bff617 	ldw	r2,-40(fp)
 8239758:	10bfffcc 	andi	r2,r2,65535
 823975c:	1004923a 	slli	r2,r2,8
 8239760:	1884b03a 	or	r2,r3,r2
 8239764:	1007883a 	mov	r3,r2
 8239768:	e0bffd17 	ldw	r2,-12(fp)
 823976c:	10c0088d 	sth	r3,34(r2)
   ti->ti_urp = 0;
 8239770:	e0bffd17 	ldw	r2,-12(fp)
 8239774:	1000098d 	sth	zero,38(r2)

   /* Finish constructing IP header and send, based on IP type in use */
   switch(domain)
 8239778:	e0bff517 	ldw	r2,-44(fp)
 823977c:	108000a0 	cmpeqi	r2,r2,2
 8239780:	10003b26 	beq	r2,zero,8239870 <tcp_respond+0x3d8>
#ifdef IP_V4
      case AF_INET:
      {
         struct ip * pip;

         pip = (struct ip *)((char*)ti+sizeof(struct ipovly)-sizeof(struct ip));
 8239784:	e0bffd17 	ldw	r2,-12(fp)
 8239788:	e0bffb15 	stw	r2,-20(fp)

         pip->ip_len = (unshort)(TCPIPHDRSZ + tlen);
 823978c:	e0bff417 	ldw	r2,-48(fp)
 8239790:	10800a04 	addi	r2,r2,40
 8239794:	1007883a 	mov	r3,r2
 8239798:	e0bffb17 	ldw	r2,-20(fp)
 823979c:	10c0008d 	sth	r3,2(r2)
         /* If our system's max. MAC header size is geater than the size 
          * of the MAC header in the received packet then we need to 
          * adjust the IP header offset to allow for this. Since the packets 
          * are only headers they should always fit.
          */
         if(pip >= (struct ip *)(m->pkt->nb_buff + MaxLnh))
 82397a0:	e0bff717 	ldw	r2,-36(fp)
 82397a4:	10800117 	ldw	r2,4(r2)
 82397a8:	10800117 	ldw	r2,4(r2)
 82397ac:	d0e08117 	ldw	r3,-32252(gp)
 82397b0:	10c5883a 	add	r2,r2,r3
 82397b4:	e0fffb17 	ldw	r3,-20(fp)
 82397b8:	18800436 	bltu	r3,r2,82397cc <tcp_respond+0x334>
         {
            m->m_data = (char*)pip; /* headers will fit, just set pointer */
 82397bc:	e0bff717 	ldw	r2,-36(fp)
 82397c0:	e0fffb17 	ldw	r3,-20(fp)
 82397c4:	10c00315 	stw	r3,12(r2)
 82397c8:	00001106 	br	8239810 <tcp_respond+0x378>
         }
         else     /* MAC may not fit, adjust pointer and move headers back */
         {
            m->m_data = m->pkt->nb_prot = m->pkt->nb_buff + MaxLnh;  /* new ptr */
 82397cc:	e0bff717 	ldw	r2,-36(fp)
 82397d0:	10800117 	ldw	r2,4(r2)
 82397d4:	e0fff717 	ldw	r3,-36(fp)
 82397d8:	18c00117 	ldw	r3,4(r3)
 82397dc:	18c00117 	ldw	r3,4(r3)
 82397e0:	d1208117 	ldw	r4,-32252(gp)
 82397e4:	1907883a 	add	r3,r3,r4
 82397e8:	10c00315 	stw	r3,12(r2)
 82397ec:	10c00317 	ldw	r3,12(r2)
 82397f0:	e0bff717 	ldw	r2,-36(fp)
 82397f4:	10c00315 	stw	r3,12(r2)
            MEMMOVE(m->m_data, pip, TCPIPHDRSZ);  /* move back tcp/ip headers */
 82397f8:	e0bff717 	ldw	r2,-36(fp)
 82397fc:	10800317 	ldw	r2,12(r2)
 8239800:	01800a04 	movi	r6,40
 8239804:	e17ffb17 	ldw	r5,-20(fp)
 8239808:	1009883a 	mov	r4,r2
 823980c:	8202fd40 	call	8202fd4 <memmove>

         /*
          * In the case of a SYN DOS attack, many RST|ACK replies
          *   have no tp structure and need to be freed.
          */
         if (!tp)
 8239810:	e0bffc17 	ldw	r2,-16(fp)
 8239814:	1000031e 	bne	r2,zero,8239824 <tcp_respond+0x38c>
              m_freem(m);
 8239818:	e13ff717 	ldw	r4,-36(fp)
 823981c:	822e4b80 	call	822e4b8 <m_freem>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
		 }

         break;
 8239820:	00001506 	br	8239878 <tcp_respond+0x3e0>
          */
         if (!tp)
              m_freem(m);
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 8239824:	e0bffc17 	ldw	r2,-16(fp)
 8239828:	10800d17 	ldw	r2,52(r2)
 823982c:	10000c26 	beq	r2,zero,8239860 <tcp_respond+0x3c8>
 8239830:	e0bffc17 	ldw	r2,-16(fp)
 8239834:	10800d17 	ldw	r2,52(r2)
 8239838:	10800817 	ldw	r2,32(r2)
 823983c:	10000826 	beq	r2,zero,8239860 <tcp_respond+0x3c8>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
 8239840:	e0bffc17 	ldw	r2,-16(fp)
 8239844:	10800d17 	ldw	r2,52(r2)
 8239848:	10800817 	ldw	r2,32(r2)
 823984c:	10801f17 	ldw	r2,124(r2)
 8239850:	100b883a 	mov	r5,r2
 8239854:	e13ff717 	ldw	r4,-36(fp)
 8239858:	822ee540 	call	822ee54 <ip_output>
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
		 }

         break;
 823985c:	00000606 	br	8239878 <tcp_respond+0x3e0>
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
 8239860:	000b883a 	mov	r5,zero
 8239864:	e13ff717 	ldw	r4,-36(fp)
 8239868:	822ee540 	call	822ee54 <ip_output>
		 }

         break;
 823986c:	00000206 	br	8239878 <tcp_respond+0x3e0>

         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();
 8239870:	822d4140 	call	822d414 <dtrap>
         break;
 8239874:	0001883a 	nop
   }
   return;
 8239878:	0001883a 	nop
 823987c:	00000106 	br	8239884 <tcp_respond+0x3ec>
   if (flags == 0)   /* sending keepalive from timer */
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
      if (m == NULL)
         return;
 8239880:	0001883a 	nop
      default:
         dtrap();
         break;
   }
   return;
}
 8239884:	e037883a 	mov	sp,fp
 8239888:	dfc00117 	ldw	ra,4(sp)
 823988c:	df000017 	ldw	fp,0(sp)
 8239890:	dec00204 	addi	sp,sp,8
 8239894:	f800283a 	ret

08239898 <tcp_newtcpcb>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_newtcpcb(struct inpcb * inp)
{
 8239898:	defffb04 	addi	sp,sp,-20
 823989c:	dfc00415 	stw	ra,16(sp)
 82398a0:	df000315 	stw	fp,12(sp)
 82398a4:	df000304 	addi	fp,sp,12
 82398a8:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
   short t_time;

   tp = TCB_ALLOC(sizeof (*tp));
 82398ac:	01002504 	movi	r4,148
 82398b0:	822dfec0 	call	822dfec <npalloc>
 82398b4:	e0bffd15 	stw	r2,-12(fp)
   if (tp == NULL)
 82398b8:	e0bffd17 	ldw	r2,-12(fp)
 82398bc:	1000021e 	bne	r2,zero,82398c8 <tcp_newtcpcb+0x30>
      return (struct tcpcb *)NULL;
 82398c0:	0005883a 	mov	r2,zero
 82398c4:	00003206 	br	8239990 <tcp_newtcpcb+0xf8>
   tp->seg_next = tp->seg_prev = (struct tcpiphdr *)tp;
 82398c8:	e0bffd17 	ldw	r2,-12(fp)
 82398cc:	e0fffd17 	ldw	r3,-12(fp)
 82398d0:	10c00115 	stw	r3,4(r2)
 82398d4:	e0bffd17 	ldw	r2,-12(fp)
 82398d8:	10c00117 	ldw	r3,4(r2)
 82398dc:	e0bffd17 	ldw	r2,-12(fp)
 82398e0:	10c00015 	stw	r3,0(r2)
   tp->t_maxseg = TCP_MSS;
 82398e4:	e0bffd17 	ldw	r2,-12(fp)
 82398e8:	00c16d04 	movi	r3,1460
 82398ec:	10c00a0d 	sth	r3,40(r2)
   tp->t_flags = 0;        /* sends options! */
 82398f0:	e0bffd17 	ldw	r2,-12(fp)
 82398f4:	10000b0d 	sth	zero,44(r2)
   tp->t_inpcb = inp;
 82398f8:	e0bffd17 	ldw	r2,-12(fp)
 82398fc:	e0ffff17 	ldw	r3,-4(fp)
 8239900:	10c00d15 	stw	r3,52(r2)
   /*
    * Init srtt to TCPTV_SRTTBASE (0), so we can tell that we have no
    * rtt estimate.  Set rttvar so that srtt + 2 * rttvar gives
    * reasonable initial retransmit time.
    */
   tp->t_srtt = TCPTV_SRTTBASE;
 8239904:	e0bffd17 	ldw	r2,-12(fp)
 8239908:	10002015 	stw	zero,128(r2)
   tp->t_rttvar = TCPTV_SRTTDFLT << 2;
 823990c:	e0bffd17 	ldw	r2,-12(fp)
 8239910:	00c00604 	movi	r3,24
 8239914:	10c02115 	stw	r3,132(r2)

   t_time = ((TCPTV_SRTTBASE >> 2) + (TCPTV_SRTTDFLT << 2)) >> 1;
 8239918:	00800304 	movi	r2,12
 823991c:	e0bffe0d 	sth	r2,-8(fp)
   TCPT_RANGESET(tp->t_rxtcur, t_time, TCPTV_MIN, TCPTV_REXMTMAX);
 8239920:	e0fffe0f 	ldh	r3,-8(fp)
 8239924:	e0bffd17 	ldw	r2,-12(fp)
 8239928:	10c00815 	stw	r3,32(r2)
 823992c:	e0bffd17 	ldw	r2,-12(fp)
 8239930:	10800817 	ldw	r2,32(r2)
 8239934:	10800088 	cmpgei	r2,r2,2
 8239938:	1000041e 	bne	r2,zero,823994c <tcp_newtcpcb+0xb4>
 823993c:	e0bffd17 	ldw	r2,-12(fp)
 8239940:	00c00084 	movi	r3,2
 8239944:	10c00815 	stw	r3,32(r2)
 8239948:	00000706 	br	8239968 <tcp_newtcpcb+0xd0>
 823994c:	e0bffd17 	ldw	r2,-12(fp)
 8239950:	10800817 	ldw	r2,32(r2)
 8239954:	10802050 	cmplti	r2,r2,129
 8239958:	1000031e 	bne	r2,zero,8239968 <tcp_newtcpcb+0xd0>
 823995c:	e0bffd17 	ldw	r2,-12(fp)
 8239960:	00c02004 	movi	r3,128
 8239964:	10c00815 	stw	r3,32(r2)

   /* Set initial congestion window - RFC-2581, pg 4. */
   tp->snd_cwnd = 2 * TCP_MSS;
 8239968:	e0bffd17 	ldw	r2,-12(fp)
 823996c:	00c2da04 	movi	r3,2920
 8239970:	10c01b15 	stw	r3,108(r2)

#ifdef DO_DELAY_ACKS
   tp->t_delacktime = 1;
#endif   /* DO_DELAY_ACKS */

   tp->snd_ssthresh = 65535;  /* Start with high slow-start threshold */
 8239974:	e0bffd17 	ldw	r2,-12(fp)
 8239978:	00ffffd4 	movui	r3,65535
 823997c:	10c01c15 	stw	r3,112(r2)

   inp->inp_ppcb = (char *)tp;
 8239980:	e0bfff17 	ldw	r2,-4(fp)
 8239984:	e0fffd17 	ldw	r3,-12(fp)
 8239988:	10c00915 	stw	r3,36(r2)
   return (tp);
 823998c:	e0bffd17 	ldw	r2,-12(fp)
}
 8239990:	e037883a 	mov	sp,fp
 8239994:	dfc00117 	ldw	ra,4(sp)
 8239998:	df000017 	ldw	fp,0(sp)
 823999c:	dec00204 	addi	sp,sp,8
 82399a0:	f800283a 	ret

082399a4 <tcp_drop>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_drop(struct tcpcb * tp, int err)
{
 82399a4:	defffb04 	addi	sp,sp,-20
 82399a8:	dfc00415 	stw	ra,16(sp)
 82399ac:	df000315 	stw	fp,12(sp)
 82399b0:	df000304 	addi	fp,sp,12
 82399b4:	e13ffe15 	stw	r4,-8(fp)
 82399b8:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 82399bc:	e0bffe17 	ldw	r2,-8(fp)
 82399c0:	10800d17 	ldw	r2,52(r2)
 82399c4:	10800817 	ldw	r2,32(r2)
 82399c8:	e0bffd15 	stw	r2,-12(fp)

   if (TCPS_HAVERCVDSYN(tp->t_state)) 
 82399cc:	e0bffe17 	ldw	r2,-8(fp)
 82399d0:	10800217 	ldw	r2,8(r2)
 82399d4:	108000d0 	cmplti	r2,r2,3
 82399d8:	10000c1e 	bne	r2,zero,8239a0c <tcp_drop+0x68>
   {
      tp->t_state = TCPS_CLOSED;
 82399dc:	e0bffe17 	ldw	r2,-8(fp)
 82399e0:	10000215 	stw	zero,8(r2)
      (void) tcp_output(tp);
 82399e4:	e13ffe17 	ldw	r4,-8(fp)
 82399e8:	82381700 	call	8238170 <tcp_output>
      tcpstat.tcps_drops++;
 82399ec:	008209b4 	movhi	r2,2086
 82399f0:	10b99404 	addi	r2,r2,-6576
 82399f4:	10800317 	ldw	r2,12(r2)
 82399f8:	10c00044 	addi	r3,r2,1
 82399fc:	008209b4 	movhi	r2,2086
 8239a00:	10b99404 	addi	r2,r2,-6576
 8239a04:	10c00315 	stw	r3,12(r2)
 8239a08:	00000706 	br	8239a28 <tcp_drop+0x84>
   }
   else
      tcpstat.tcps_conndrops++;
 8239a0c:	008209b4 	movhi	r2,2086
 8239a10:	10b99404 	addi	r2,r2,-6576
 8239a14:	10800417 	ldw	r2,16(r2)
 8239a18:	10c00044 	addi	r3,r2,1
 8239a1c:	008209b4 	movhi	r2,2086
 8239a20:	10b99404 	addi	r2,r2,-6576
 8239a24:	10c00415 	stw	r3,16(r2)
   so->so_error = err;
 8239a28:	e0bffd17 	ldw	r2,-12(fp)
 8239a2c:	e0ffff17 	ldw	r3,-4(fp)
 8239a30:	10c00615 	stw	r3,24(r2)
#ifdef TCP_ZEROCOPY
   if (so->rx_upcall)
      so->rx_upcall(so, NULL, err);
#endif   /* TCP_ZEROCOPY */
   return (tcp_close(tp));
 8239a34:	e13ffe17 	ldw	r4,-8(fp)
 8239a38:	8239a500 	call	8239a50 <tcp_close>
}
 8239a3c:	e037883a 	mov	sp,fp
 8239a40:	dfc00117 	ldw	ra,4(sp)
 8239a44:	df000017 	ldw	fp,0(sp)
 8239a48:	dec00204 	addi	sp,sp,8
 8239a4c:	f800283a 	ret

08239a50 <tcp_close>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_close(struct tcpcb * tp)
{
 8239a50:	defff904 	addi	sp,sp,-28
 8239a54:	dfc00615 	stw	ra,24(sp)
 8239a58:	df000515 	stw	fp,20(sp)
 8239a5c:	df000504 	addi	fp,sp,20
 8239a60:	e13fff15 	stw	r4,-4(fp)
   struct tcpiphdr * t;
   struct inpcb * inp   =  tp->t_inpcb;
 8239a64:	e0bfff17 	ldw	r2,-4(fp)
 8239a68:	10800d17 	ldw	r2,52(r2)
 8239a6c:	e0bffc15 	stw	r2,-16(fp)
   struct socket *   so =  inp->inp_socket;
 8239a70:	e0bffc17 	ldw	r2,-16(fp)
 8239a74:	10800817 	ldw	r2,32(r2)
 8239a78:	e0bffd15 	stw	r2,-12(fp)
   struct mbuf *  m;

   t = tp->seg_next;
 8239a7c:	e0bfff17 	ldw	r2,-4(fp)
 8239a80:	10800017 	ldw	r2,0(r2)
 8239a84:	e0bffb15 	stw	r2,-20(fp)
   while (t != (struct tcpiphdr *)tp) 
 8239a88:	00000e06 	br	8239ac4 <tcp_close+0x74>
   {
      t = (struct tcpiphdr *)t->ti_next;
 8239a8c:	e0bffb17 	ldw	r2,-20(fp)
 8239a90:	10800017 	ldw	r2,0(r2)
 8239a94:	e0bffb15 	stw	r2,-20(fp)
      m = dtom(t->ti_prev);
 8239a98:	e0bffb17 	ldw	r2,-20(fp)
 8239a9c:	10800117 	ldw	r2,4(r2)
 8239aa0:	1009883a 	mov	r4,r2
 8239aa4:	822ea040 	call	822ea04 <dtom>
 8239aa8:	e0bffe15 	stw	r2,-8(fp)
      remque(t->ti_prev);
 8239aac:	e0bffb17 	ldw	r2,-20(fp)
 8239ab0:	10800117 	ldw	r2,4(r2)
 8239ab4:	1009883a 	mov	r4,r2
 8239ab8:	822eaa00 	call	822eaa0 <remque>
      m_freem (m);
 8239abc:	e13ffe17 	ldw	r4,-8(fp)
 8239ac0:	822e4b80 	call	822e4b8 <m_freem>
   struct inpcb * inp   =  tp->t_inpcb;
   struct socket *   so =  inp->inp_socket;
   struct mbuf *  m;

   t = tp->seg_next;
   while (t != (struct tcpiphdr *)tp) 
 8239ac4:	e0fffb17 	ldw	r3,-20(fp)
 8239ac8:	e0bfff17 	ldw	r2,-4(fp)
 8239acc:	18bfef1e 	bne	r3,r2,8239a8c <tcp_close+0x3c>
      t = (struct tcpiphdr *)t->ti_next;
      m = dtom(t->ti_prev);
      remque(t->ti_prev);
      m_freem (m);
   }
   if (tp->t_template)
 8239ad0:	e0bfff17 	ldw	r2,-4(fp)
 8239ad4:	10800c17 	ldw	r2,48(r2)
 8239ad8:	10000426 	beq	r2,zero,8239aec <tcp_close+0x9c>
      TPH_FREE (tp->t_template);
 8239adc:	e0bfff17 	ldw	r2,-4(fp)
 8239ae0:	10800c17 	ldw	r2,48(r2)
 8239ae4:	1009883a 	mov	r4,r2
 8239ae8:	822e0200 	call	822e020 <npfree>
   TCB_FREE (tp);
 8239aec:	e13fff17 	ldw	r4,-4(fp)
 8239af0:	822e0200 	call	822e020 <npfree>
   inp->inp_ppcb = 0;
 8239af4:	e0bffc17 	ldw	r2,-16(fp)
 8239af8:	10000915 	stw	zero,36(r2)
   soisdisconnected(so);
 8239afc:	e13ffd17 	ldw	r4,-12(fp)
 8239b00:	8233af40 	call	8233af4 <soisdisconnected>
   in_pcbdetach(inp);
 8239b04:	e13ffc17 	ldw	r4,-16(fp)
 8239b08:	8247d100 	call	8247d10 <in_pcbdetach>
   tcpstat.tcps_closed++;
 8239b0c:	008209b4 	movhi	r2,2086
 8239b10:	10b99404 	addi	r2,r2,-6576
 8239b14:	10800517 	ldw	r2,20(r2)
 8239b18:	10c00044 	addi	r3,r2,1
 8239b1c:	008209b4 	movhi	r2,2086
 8239b20:	10b99404 	addi	r2,r2,-6576
 8239b24:	10c00515 	stw	r3,20(r2)
   return ((struct tcpcb *)0);
 8239b28:	0005883a 	mov	r2,zero
}
 8239b2c:	e037883a 	mov	sp,fp
 8239b30:	dfc00117 	ldw	ra,4(sp)
 8239b34:	df000017 	ldw	fp,0(sp)
 8239b38:	dec00204 	addi	sp,sp,8
 8239b3c:	f800283a 	ret

08239b40 <tcp_quench>:
 * RETURNS: 
 */

void
tcp_quench(struct inpcb * inp)
{
 8239b40:	defffd04 	addi	sp,sp,-12
 8239b44:	df000215 	stw	fp,8(sp)
 8239b48:	df000204 	addi	fp,sp,8
 8239b4c:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp =  intotcpcb(inp);
 8239b50:	e0bfff17 	ldw	r2,-4(fp)
 8239b54:	10800917 	ldw	r2,36(r2)
 8239b58:	e0bffe15 	stw	r2,-8(fp)

   if (tp)
 8239b5c:	e0bffe17 	ldw	r2,-8(fp)
 8239b60:	10000526 	beq	r2,zero,8239b78 <tcp_quench+0x38>
      tp->snd_cwnd = tp->t_maxseg;
 8239b64:	e0bffe17 	ldw	r2,-8(fp)
 8239b68:	10800a0b 	ldhu	r2,40(r2)
 8239b6c:	10ffffcc 	andi	r3,r2,65535
 8239b70:	e0bffe17 	ldw	r2,-8(fp)
 8239b74:	10c01b15 	stw	r3,108(r2)
}
 8239b78:	0001883a 	nop
 8239b7c:	e037883a 	mov	sp,fp
 8239b80:	df000017 	ldw	fp,0(sp)
 8239b84:	dec00104 	addi	sp,sp,4
 8239b88:	f800283a 	ret

08239b8c <tcp_putseq>:

/* tcp_putseq()  */

u_char *
tcp_putseq(u_char * cp, tcp_seq seq)
{
 8239b8c:	defffc04 	addi	sp,sp,-16
 8239b90:	df000315 	stw	fp,12(sp)
 8239b94:	df000304 	addi	fp,sp,12
 8239b98:	e13ffe15 	stw	r4,-8(fp)
 8239b9c:	e17fff15 	stw	r5,-4(fp)
   int   i;

   cp += 3;                /* do low byte first */
 8239ba0:	e0bffe17 	ldw	r2,-8(fp)
 8239ba4:	108000c4 	addi	r2,r2,3
 8239ba8:	e0bffe15 	stw	r2,-8(fp)
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 8239bac:	e03ffd15 	stw	zero,-12(fp)
 8239bb0:	00000b06 	br	8239be0 <tcp_putseq+0x54>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
 8239bb4:	e0bffe17 	ldw	r2,-8(fp)
 8239bb8:	10ffffc4 	addi	r3,r2,-1
 8239bbc:	e0fffe15 	stw	r3,-8(fp)
 8239bc0:	e0ffff17 	ldw	r3,-4(fp)
 8239bc4:	10c00005 	stb	r3,0(r2)
      seq >>= 8;
 8239bc8:	e0bfff17 	ldw	r2,-4(fp)
 8239bcc:	1004d23a 	srli	r2,r2,8
 8239bd0:	e0bfff15 	stw	r2,-4(fp)
tcp_putseq(u_char * cp, tcp_seq seq)
{
   int   i;

   cp += 3;                /* do low byte first */
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 8239bd4:	e0bffd17 	ldw	r2,-12(fp)
 8239bd8:	10800044 	addi	r2,r2,1
 8239bdc:	e0bffd15 	stw	r2,-12(fp)
 8239be0:	e0bffd17 	ldw	r2,-12(fp)
 8239be4:	10800110 	cmplti	r2,r2,4
 8239be8:	103ff21e 	bne	r2,zero,8239bb4 <tcp_putseq+0x28>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
      seq >>= 8;
   }
   return (cp + 5);
 8239bec:	e0bffe17 	ldw	r2,-8(fp)
 8239bf0:	10800144 	addi	r2,r2,5
}
 8239bf4:	e037883a 	mov	sp,fp
 8239bf8:	df000017 	ldw	fp,0(sp)
 8239bfc:	dec00104 	addi	sp,sp,4
 8239c00:	f800283a 	ret

08239c04 <tcp_getseq>:
 * RETURNS: a long in local endian
 */

u_long
tcp_getseq(u_char * cp)
{
 8239c04:	defffc04 	addi	sp,sp,-16
 8239c08:	df000315 	stw	fp,12(sp)
 8239c0c:	df000304 	addi	fp,sp,12
 8239c10:	e13fff15 	stw	r4,-4(fp)
   int i;
   ulong seq = 0;
 8239c14:	e03ffe15 	stw	zero,-8(fp)

   for(i = 0; i < 4; i++)
 8239c18:	e03ffd15 	stw	zero,-12(fp)
 8239c1c:	00000e06 	br	8239c58 <tcp_getseq+0x54>
   {
      seq <<= 8;
 8239c20:	e0bffe17 	ldw	r2,-8(fp)
 8239c24:	1004923a 	slli	r2,r2,8
 8239c28:	e0bffe15 	stw	r2,-8(fp)
      seq += (u_long)*(cp++);
 8239c2c:	e0bfff17 	ldw	r2,-4(fp)
 8239c30:	10c00044 	addi	r3,r2,1
 8239c34:	e0ffff15 	stw	r3,-4(fp)
 8239c38:	10800003 	ldbu	r2,0(r2)
 8239c3c:	10803fcc 	andi	r2,r2,255
 8239c40:	e0fffe17 	ldw	r3,-8(fp)
 8239c44:	1885883a 	add	r2,r3,r2
 8239c48:	e0bffe15 	stw	r2,-8(fp)
tcp_getseq(u_char * cp)
{
   int i;
   ulong seq = 0;

   for(i = 0; i < 4; i++)
 8239c4c:	e0bffd17 	ldw	r2,-12(fp)
 8239c50:	10800044 	addi	r2,r2,1
 8239c54:	e0bffd15 	stw	r2,-12(fp)
 8239c58:	e0bffd17 	ldw	r2,-12(fp)
 8239c5c:	10800110 	cmplti	r2,r2,4
 8239c60:	103fef1e 	bne	r2,zero,8239c20 <tcp_getseq+0x1c>
   {
      seq <<= 8;
      seq += (u_long)*(cp++);
   }
   return seq;
 8239c64:	e0bffe17 	ldw	r2,-8(fp)
}
 8239c68:	e037883a 	mov	sp,fp
 8239c6c:	df000017 	ldw	fp,0(sp)
 8239c70:	dec00104 	addi	sp,sp,4
 8239c74:	f800283a 	ret

08239c78 <tcp_slowtimo>:
 * RETURNS: 
 */

void
tcp_slowtimo(void)
{
 8239c78:	defff704 	addi	sp,sp,-36
 8239c7c:	dfc00815 	stw	ra,32(sp)
 8239c80:	df000715 	stw	fp,28(sp)
 8239c84:	df000704 	addi	fp,sp,28
   struct tcpcb * tp;
   int   i;
   struct socket * so, * sonext;
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;
 8239c88:	d0a03f17 	ldw	r2,-32516(gp)
 8239c8c:	100490fa 	slli	r2,r2,3
 8239c90:	d0a0b415 	stw	r2,-32048(gp)

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 8239c94:	008209b4 	movhi	r2,2086
 8239c98:	10b96104 	addi	r2,r2,-6780
 8239c9c:	10800017 	ldw	r2,0(r2)
 8239ca0:	e0bffa15 	stw	r2,-24(fp)
 8239ca4:	00008006 	br	8239ea8 <tcp_slowtimo+0x230>
   {
      sonext = so->next;
 8239ca8:	e0bffa17 	ldw	r2,-24(fp)
 8239cac:	10800017 	ldw	r2,0(r2)
 8239cb0:	e0bffb15 	stw	r2,-20(fp)

      /* for SOCK_STREAM (TCP) sockets, we must do slow-timeout 
       * processing and (optionally) processing of pending 
       * zero-copy socket upcalls.
       */
      if (so->so_type == SOCK_STREAM)
 8239cb4:	e0bffa17 	ldw	r2,-24(fp)
 8239cb8:	10800983 	ldbu	r2,38(r2)
 8239cbc:	10803fcc 	andi	r2,r2,255
 8239cc0:	1080201c 	xori	r2,r2,128
 8239cc4:	10bfe004 	addi	r2,r2,-128
 8239cc8:	10800058 	cmpnei	r2,r2,1
 8239ccc:	1000461e 	bne	r2,zero,8239de8 <tcp_slowtimo+0x170>
      {
         ip = so->so_pcb;
 8239cd0:	e0bffa17 	ldw	r2,-24(fp)
 8239cd4:	10800117 	ldw	r2,4(r2)
 8239cd8:	e0bffc15 	stw	r2,-16(fp)
         if (!ip)
 8239cdc:	e0bffc17 	ldw	r2,-16(fp)
 8239ce0:	10006a26 	beq	r2,zero,8239e8c <tcp_slowtimo+0x214>
            continue;
         ipnxt = ip->inp_next;
 8239ce4:	e0bffc17 	ldw	r2,-16(fp)
 8239ce8:	10800017 	ldw	r2,0(r2)
 8239cec:	e0bffd15 	stw	r2,-12(fp)

         tp = intotcpcb(so->so_pcb);
 8239cf0:	e0bffa17 	ldw	r2,-24(fp)
 8239cf4:	10800117 	ldw	r2,4(r2)
 8239cf8:	10800917 	ldw	r2,36(r2)
 8239cfc:	e0bffe15 	stw	r2,-8(fp)
         if (!tp)
 8239d00:	e0bffe17 	ldw	r2,-8(fp)
 8239d04:	10006326 	beq	r2,zero,8239e94 <tcp_slowtimo+0x21c>
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 8239d08:	e03ff915 	stw	zero,-28(fp)
 8239d0c:	00002e06 	br	8239dc8 <tcp_slowtimo+0x150>
         {
            if (tp->t_timer[i] && --tp->t_timer[i] == 0) 
 8239d10:	e0fffe17 	ldw	r3,-8(fp)
 8239d14:	e0bff917 	ldw	r2,-28(fp)
 8239d18:	108000c4 	addi	r2,r2,3
 8239d1c:	1085883a 	add	r2,r2,r2
 8239d20:	1085883a 	add	r2,r2,r2
 8239d24:	1885883a 	add	r2,r3,r2
 8239d28:	10800017 	ldw	r2,0(r2)
 8239d2c:	10002326 	beq	r2,zero,8239dbc <tcp_slowtimo+0x144>
 8239d30:	e0fffe17 	ldw	r3,-8(fp)
 8239d34:	e0bff917 	ldw	r2,-28(fp)
 8239d38:	108000c4 	addi	r2,r2,3
 8239d3c:	1085883a 	add	r2,r2,r2
 8239d40:	1085883a 	add	r2,r2,r2
 8239d44:	1885883a 	add	r2,r3,r2
 8239d48:	10800017 	ldw	r2,0(r2)
 8239d4c:	10ffffc4 	addi	r3,r2,-1
 8239d50:	e13ffe17 	ldw	r4,-8(fp)
 8239d54:	e0bff917 	ldw	r2,-28(fp)
 8239d58:	108000c4 	addi	r2,r2,3
 8239d5c:	1085883a 	add	r2,r2,r2
 8239d60:	1085883a 	add	r2,r2,r2
 8239d64:	2085883a 	add	r2,r4,r2
 8239d68:	10c00015 	stw	r3,0(r2)
 8239d6c:	e0fffe17 	ldw	r3,-8(fp)
 8239d70:	e0bff917 	ldw	r2,-28(fp)
 8239d74:	108000c4 	addi	r2,r2,3
 8239d78:	1085883a 	add	r2,r2,r2
 8239d7c:	1085883a 	add	r2,r2,r2
 8239d80:	1885883a 	add	r2,r3,r2
 8239d84:	10800017 	ldw	r2,0(r2)
 8239d88:	10000c1e 	bne	r2,zero,8239dbc <tcp_slowtimo+0x144>
            {
               /* call usrreq to do actual work */
               so->so_req = PRU_SLOWTIMO;
 8239d8c:	e0bffa17 	ldw	r2,-24(fp)
 8239d90:	00c004c4 	movi	r3,19
 8239d94:	10c00715 	stw	r3,28(r2)
               (void) tcp_usrreq(so, (struct mbuf *)0, 
 8239d98:	e0bff917 	ldw	r2,-28(fp)
 8239d9c:	100d883a 	mov	r6,r2
 8239da0:	000b883a 	mov	r5,zero
 8239da4:	e13ffa17 	ldw	r4,-24(fp)
 8239da8:	823a3c80 	call	823a3c8 <tcp_usrreq>
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
 8239dac:	e0bffd17 	ldw	r2,-12(fp)
 8239db0:	10c00117 	ldw	r3,4(r2)
 8239db4:	e0bffc17 	ldw	r2,-16(fp)
 8239db8:	1880381e 	bne	r3,r2,8239e9c <tcp_slowtimo+0x224>

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 8239dbc:	e0bff917 	ldw	r2,-28(fp)
 8239dc0:	10800044 	addi	r2,r2,1
 8239dc4:	e0bff915 	stw	r2,-28(fp)
 8239dc8:	e0bff917 	ldw	r2,-28(fp)
 8239dcc:	10800110 	cmplti	r2,r2,4
 8239dd0:	103fcf1e 	bne	r2,zero,8239d10 <tcp_slowtimo+0x98>
               }
            }
         }
#endif   /* TCP_ZEROCOPY */

         tp->t_idle++;
 8239dd4:	e0bffe17 	ldw	r2,-8(fp)
 8239dd8:	10801d17 	ldw	r2,116(r2)
 8239ddc:	10c00044 	addi	r3,r2,1
 8239de0:	e0bffe17 	ldw	r2,-8(fp)
 8239de4:	10c01d15 	stw	r3,116(r2)
      }

      /* wake up anyone sleeping in a select() involving this socket */
      sb = &so->so_rcv;
 8239de8:	e0bffa17 	ldw	r2,-24(fp)
 8239dec:	10800a04 	addi	r2,r2,40
 8239df0:	e0bfff15 	stw	r2,-4(fp)
      if (sb->sb_flags & SB_SEL) 
 8239df4:	e0bfff17 	ldw	r2,-4(fp)
 8239df8:	1080070b 	ldhu	r2,28(r2)
 8239dfc:	10bfffcc 	andi	r2,r2,65535
 8239e00:	1080020c 	andi	r2,r2,8
 8239e04:	10000a26 	beq	r2,zero,8239e30 <tcp_slowtimo+0x1b8>
      {
         select_wait = 0;
 8239e08:	d020b00d 	sth	zero,-32064(gp)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 8239e0c:	d120b004 	addi	r4,gp,-32064
 8239e10:	822954c0 	call	822954c <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 8239e14:	e0bfff17 	ldw	r2,-4(fp)
 8239e18:	10c0070b 	ldhu	r3,28(r2)
 8239e1c:	00bffdc4 	movi	r2,-9
 8239e20:	1884703a 	and	r2,r3,r2
 8239e24:	1007883a 	mov	r3,r2
 8239e28:	e0bfff17 	ldw	r2,-4(fp)
 8239e2c:	10c0070d 	sth	r3,28(r2)
      }
      sb = &so->so_snd;
 8239e30:	e0bffa17 	ldw	r2,-24(fp)
 8239e34:	10801204 	addi	r2,r2,72
 8239e38:	e0bfff15 	stw	r2,-4(fp)
      if (sb->sb_flags & SB_SEL) 
 8239e3c:	e0bfff17 	ldw	r2,-4(fp)
 8239e40:	1080070b 	ldhu	r2,28(r2)
 8239e44:	10bfffcc 	andi	r2,r2,65535
 8239e48:	1080020c 	andi	r2,r2,8
 8239e4c:	10000a26 	beq	r2,zero,8239e78 <tcp_slowtimo+0x200>
      {
         select_wait = 0;         
 8239e50:	d020b00d 	sth	zero,-32064(gp)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 8239e54:	d120b004 	addi	r4,gp,-32064
 8239e58:	822954c0 	call	822954c <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 8239e5c:	e0bfff17 	ldw	r2,-4(fp)
 8239e60:	10c0070b 	ldhu	r3,28(r2)
 8239e64:	00bffdc4 	movi	r2,-9
 8239e68:	1884703a 	and	r2,r3,r2
 8239e6c:	1007883a 	mov	r3,r2
 8239e70:	e0bfff17 	ldw	r2,-4(fp)
 8239e74:	10c0070d 	sth	r3,28(r2)
      }

      /* wake any thread with a timer going for a connection state change */     
      tcp_wakeup((char*)&so->so_timeo);
 8239e78:	e0bffa17 	ldw	r2,-24(fp)
 8239e7c:	10800904 	addi	r2,r2,36
 8239e80:	1009883a 	mov	r4,r2
 8239e84:	822954c0 	call	822954c <tcp_wakeup>
 8239e88:	00000506 	br	8239ea0 <tcp_slowtimo+0x228>
       */
      if (so->so_type == SOCK_STREAM)
      {
         ip = so->so_pcb;
         if (!ip)
            continue;
 8239e8c:	0001883a 	nop
 8239e90:	00000306 	br	8239ea0 <tcp_slowtimo+0x228>
         ipnxt = ip->inp_next;

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;
 8239e94:	0001883a 	nop
 8239e98:	00000106 	br	8239ea0 <tcp_slowtimo+0x228>
               (void) tcp_usrreq(so, (struct mbuf *)0, 
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
                  goto tpgone;
 8239e9c:	0001883a 	nop
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 8239ea0:	e0bffb17 	ldw	r2,-20(fp)
 8239ea4:	e0bffa15 	stw	r2,-24(fp)
 8239ea8:	e0bffa17 	ldw	r2,-24(fp)
 8239eac:	103f7e1e 	bne	r2,zero,8239ca8 <tcp_slowtimo+0x30>

tpgone:
      ;
   }

   tcp_iss += (unsigned)(TCP_ISSINCR/PR_SLOWHZ);      /* increment iss */
 8239eb0:	d0e0b517 	ldw	r3,-32044(gp)
 8239eb4:	00be9fd4 	movui	r2,64127
 8239eb8:	1885883a 	add	r2,r3,r2
 8239ebc:	d0a0b515 	stw	r2,-32044(gp)

   if (tcp_iss & 0xff000000)
 8239ec0:	d0a0b517 	ldw	r2,-32044(gp)
 8239ec4:	10bfc02c 	andhi	r2,r2,65280
 8239ec8:	10000126 	beq	r2,zero,8239ed0 <tcp_slowtimo+0x258>
      tcp_iss = 0L;
 8239ecc:	d020b515 	stw	zero,-32044(gp)
}
 8239ed0:	0001883a 	nop
 8239ed4:	e037883a 	mov	sp,fp
 8239ed8:	dfc00117 	ldw	ra,4(sp)
 8239edc:	df000017 	ldw	fp,0(sp)
 8239ee0:	dec00204 	addi	sp,sp,8
 8239ee4:	f800283a 	ret

08239ee8 <tcp_canceltimers>:
 * RETURNS: 
 */

void
tcp_canceltimers(struct tcpcb * tp)
{
 8239ee8:	defffd04 	addi	sp,sp,-12
 8239eec:	df000215 	stw	fp,8(sp)
 8239ef0:	df000204 	addi	fp,sp,8
 8239ef4:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 8239ef8:	e03ffe15 	stw	zero,-8(fp)
 8239efc:	00000a06 	br	8239f28 <tcp_canceltimers+0x40>
      tp->t_timer[i] = 0;
 8239f00:	e0ffff17 	ldw	r3,-4(fp)
 8239f04:	e0bffe17 	ldw	r2,-8(fp)
 8239f08:	108000c4 	addi	r2,r2,3
 8239f0c:	1085883a 	add	r2,r2,r2
 8239f10:	1085883a 	add	r2,r2,r2
 8239f14:	1885883a 	add	r2,r3,r2
 8239f18:	10000015 	stw	zero,0(r2)
void
tcp_canceltimers(struct tcpcb * tp)
{
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 8239f1c:	e0bffe17 	ldw	r2,-8(fp)
 8239f20:	10800044 	addi	r2,r2,1
 8239f24:	e0bffe15 	stw	r2,-8(fp)
 8239f28:	e0bffe17 	ldw	r2,-8(fp)
 8239f2c:	10800110 	cmplti	r2,r2,4
 8239f30:	103ff31e 	bne	r2,zero,8239f00 <tcp_canceltimers+0x18>
      tp->t_timer[i] = 0;
}
 8239f34:	0001883a 	nop
 8239f38:	e037883a 	mov	sp,fp
 8239f3c:	df000017 	ldw	fp,0(sp)
 8239f40:	dec00104 	addi	sp,sp,4
 8239f44:	f800283a 	ret

08239f48 <tcp_timers>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_timers(struct tcpcb * tp, int timer)
{
 8239f48:	defff804 	addi	sp,sp,-32
 8239f4c:	dfc00715 	stw	ra,28(sp)
 8239f50:	df000615 	stw	fp,24(sp)
 8239f54:	df000604 	addi	fp,sp,24
 8239f58:	e13ffe15 	stw	r4,-8(fp)
 8239f5c:	e17fff15 	stw	r5,-4(fp)
   int   rexmt;

   switch (timer) 
 8239f60:	e0bfff17 	ldw	r2,-4(fp)
 8239f64:	10c00060 	cmpeqi	r3,r2,1
 8239f68:	1800b21e 	bne	r3,zero,823a234 <tcp_timers+0x2ec>
 8239f6c:	10c00088 	cmpgei	r3,r2,2
 8239f70:	1800021e 	bne	r3,zero,8239f7c <tcp_timers+0x34>
 8239f74:	10001826 	beq	r2,zero,8239fd8 <tcp_timers+0x90>
 8239f78:	00010d06 	br	823a3b0 <tcp_timers+0x468>
 8239f7c:	10c000a0 	cmpeqi	r3,r2,2
 8239f80:	1800bd1e 	bne	r3,zero,823a278 <tcp_timers+0x330>
 8239f84:	108000e0 	cmpeqi	r2,r2,3
 8239f88:	10010926 	beq	r2,zero,823a3b0 <tcp_timers+0x468>
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 8239f8c:	e0bffe17 	ldw	r2,-8(fp)
 8239f90:	10800217 	ldw	r2,8(r2)
 8239f94:	108002a0 	cmpeqi	r2,r2,10
 8239f98:	10000b1e 	bne	r2,zero,8239fc8 <tcp_timers+0x80>
          tp->t_idle <= tcp_maxidle)
 8239f9c:	e0bffe17 	ldw	r2,-8(fp)
 8239fa0:	10801d17 	ldw	r2,116(r2)
 8239fa4:	d0e0b417 	ldw	r3,-32048(gp)
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 8239fa8:	18800716 	blt	r3,r2,8239fc8 <tcp_timers+0x80>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
 8239fac:	d0a03f17 	ldw	r2,-32516(gp)
 8239fb0:	10ffffcc 	andi	r3,r2,65535
 8239fb4:	18e0001c 	xori	r3,r3,32768
 8239fb8:	18e00004 	addi	r3,r3,-32768
 8239fbc:	e0bffe17 	ldw	r2,-8(fp)
 8239fc0:	10c00615 	stw	r3,24(r2)
      }
      else
         tp = tcp_close(tp);
      break;
 8239fc4:	0000fa06 	br	823a3b0 <tcp_timers+0x468>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
      }
      else
         tp = tcp_close(tp);
 8239fc8:	e13ffe17 	ldw	r4,-8(fp)
 8239fcc:	8239a500 	call	8239a50 <tcp_close>
 8239fd0:	e0bffe15 	stw	r2,-8(fp)
      break;
 8239fd4:	0000f606 	br	823a3b0 <tcp_timers+0x468>
    * Retransmission timer went off.  Message has not
    * been acked within retransmit interval.  Back off
    * to a longer retransmit interval and retransmit one segment.
    */
   case TCPT_REXMT:
      TCP_MIB_INC(tcpRetransSegs);     /* keep MIB stats */
 8239fd8:	008209b4 	movhi	r2,2086
 8239fdc:	10b96604 	addi	r2,r2,-6760
 8239fe0:	10800b17 	ldw	r2,44(r2)
 8239fe4:	10c00044 	addi	r3,r2,1
 8239fe8:	008209b4 	movhi	r2,2086
 8239fec:	10b96604 	addi	r2,r2,-6760
 8239ff0:	10c00b15 	stw	r3,44(r2)
      if (++tp->t_rxtshift > TCP_MAXRXTSHIFT) 
 8239ff4:	e0bffe17 	ldw	r2,-8(fp)
 8239ff8:	10800717 	ldw	r2,28(r2)
 8239ffc:	10c00044 	addi	r3,r2,1
 823a000:	e0bffe17 	ldw	r2,-8(fp)
 823a004:	10c00715 	stw	r3,28(r2)
 823a008:	e0bffe17 	ldw	r2,-8(fp)
 823a00c:	10800717 	ldw	r2,28(r2)
 823a010:	10800350 	cmplti	r2,r2,13
 823a014:	10000f1e 	bne	r2,zero,823a054 <tcp_timers+0x10c>
      {
         tp->t_rxtshift = TCP_MAXRXTSHIFT;
 823a018:	e0bffe17 	ldw	r2,-8(fp)
 823a01c:	00c00304 	movi	r3,12
 823a020:	10c00715 	stw	r3,28(r2)
         tcpstat.tcps_timeoutdrop++;
 823a024:	008209b4 	movhi	r2,2086
 823a028:	10b99404 	addi	r2,r2,-6576
 823a02c:	10800917 	ldw	r2,36(r2)
 823a030:	10c00044 	addi	r3,r2,1
 823a034:	008209b4 	movhi	r2,2086
 823a038:	10b99404 	addi	r2,r2,-6576
 823a03c:	10c00915 	stw	r3,36(r2)
         tp = tcp_drop(tp, ETIMEDOUT);
 823a040:	01401d04 	movi	r5,116
 823a044:	e13ffe17 	ldw	r4,-8(fp)
 823a048:	82399a40 	call	82399a4 <tcp_drop>
 823a04c:	e0bffe15 	stw	r2,-8(fp)
         break;
 823a050:	0000d706 	br	823a3b0 <tcp_timers+0x468>
      }
      tcpstat.tcps_rexmttimeo++;
 823a054:	008209b4 	movhi	r2,2086
 823a058:	10b99404 	addi	r2,r2,-6576
 823a05c:	10800a17 	ldw	r2,40(r2)
 823a060:	10c00044 	addi	r3,r2,1
 823a064:	008209b4 	movhi	r2,2086
 823a068:	10b99404 	addi	r2,r2,-6576
 823a06c:	10c00a15 	stw	r3,40(r2)
      rexmt = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 823a070:	e0bffe17 	ldw	r2,-8(fp)
 823a074:	10802017 	ldw	r2,128(r2)
 823a078:	1007d0ba 	srai	r3,r2,2
 823a07c:	e0bffe17 	ldw	r2,-8(fp)
 823a080:	10802117 	ldw	r2,132(r2)
 823a084:	1885883a 	add	r2,r3,r2
 823a088:	1005d07a 	srai	r2,r2,1
 823a08c:	e0bffd15 	stw	r2,-12(fp)
      rexmt *= tcp_backoff[tp->t_rxtshift];
 823a090:	e0bffe17 	ldw	r2,-8(fp)
 823a094:	10c00717 	ldw	r3,28(r2)
 823a098:	00820974 	movhi	r2,2085
 823a09c:	108ecec4 	addi	r2,r2,15163
 823a0a0:	10c5883a 	add	r2,r2,r3
 823a0a4:	10800003 	ldbu	r2,0(r2)
 823a0a8:	10803fcc 	andi	r2,r2,255
 823a0ac:	e0fffd17 	ldw	r3,-12(fp)
 823a0b0:	1885383a 	mul	r2,r3,r2
 823a0b4:	e0bffd15 	stw	r2,-12(fp)
      TCPT_RANGESET(tp->t_rxtcur, rexmt, TCPTV_MIN, TCPTV_REXMTMAX);
 823a0b8:	e0bffd17 	ldw	r2,-12(fp)
 823a0bc:	10ffffcc 	andi	r3,r2,65535
 823a0c0:	18e0001c 	xori	r3,r3,32768
 823a0c4:	18e00004 	addi	r3,r3,-32768
 823a0c8:	e0bffe17 	ldw	r2,-8(fp)
 823a0cc:	10c00815 	stw	r3,32(r2)
 823a0d0:	e0bffe17 	ldw	r2,-8(fp)
 823a0d4:	10800817 	ldw	r2,32(r2)
 823a0d8:	10800088 	cmpgei	r2,r2,2
 823a0dc:	1000041e 	bne	r2,zero,823a0f0 <tcp_timers+0x1a8>
 823a0e0:	e0bffe17 	ldw	r2,-8(fp)
 823a0e4:	00c00084 	movi	r3,2
 823a0e8:	10c00815 	stw	r3,32(r2)
 823a0ec:	00000706 	br	823a10c <tcp_timers+0x1c4>
 823a0f0:	e0bffe17 	ldw	r2,-8(fp)
 823a0f4:	10800817 	ldw	r2,32(r2)
 823a0f8:	10802050 	cmplti	r2,r2,129
 823a0fc:	1000031e 	bne	r2,zero,823a10c <tcp_timers+0x1c4>
 823a100:	e0bffe17 	ldw	r2,-8(fp)
 823a104:	00c02004 	movi	r3,128
 823a108:	10c00815 	stw	r3,32(r2)
      tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 823a10c:	e0bffe17 	ldw	r2,-8(fp)
 823a110:	10c00817 	ldw	r3,32(r2)
 823a114:	e0bffe17 	ldw	r2,-8(fp)
 823a118:	10c00315 	stw	r3,12(r2)
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 823a11c:	e0bffe17 	ldw	r2,-8(fp)
 823a120:	10800717 	ldw	r2,28(r2)
 823a124:	10800110 	cmplti	r2,r2,4
 823a128:	10000f1e 	bne	r2,zero,823a168 <tcp_timers+0x220>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
 823a12c:	e0bffe17 	ldw	r2,-8(fp)
 823a130:	10800b0b 	ldhu	r2,44(r2)
 823a134:	10bfffcc 	andi	r2,r2,65535
 823a138:	1080400c 	andi	r2,r2,256
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 823a13c:	10000a1e 	bne	r2,zero,823a168 <tcp_timers+0x220>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
      {
         tp->t_rttvar += (tp->t_srtt >> 2);
 823a140:	e0bffe17 	ldw	r2,-8(fp)
 823a144:	10c02117 	ldw	r3,132(r2)
 823a148:	e0bffe17 	ldw	r2,-8(fp)
 823a14c:	10802017 	ldw	r2,128(r2)
 823a150:	1005d0ba 	srai	r2,r2,2
 823a154:	1887883a 	add	r3,r3,r2
 823a158:	e0bffe17 	ldw	r2,-8(fp)
 823a15c:	10c02115 	stw	r3,132(r2)
         tp->t_srtt = 0;
 823a160:	e0bffe17 	ldw	r2,-8(fp)
 823a164:	10002015 	stw	zero,128(r2)
      }
      tp->snd_nxt = tp->snd_una;
 823a168:	e0bffe17 	ldw	r2,-8(fp)
 823a16c:	10c00e17 	ldw	r3,56(r2)
 823a170:	e0bffe17 	ldw	r2,-8(fp)
 823a174:	10c00f15 	stw	r3,60(r2)
      /*
       * If timing a segment in this window, stop the timer.
       */
      tp->t_rttick = 0;
 823a178:	e0bffe17 	ldw	r2,-8(fp)
 823a17c:	10001e15 	stw	zero,120(r2)
       * to go below this.)
       *
       * Vers 1.9 - Skip slow start if the SO_NOSLOWSTART socket option
       * is set.
       */
      if((tp->t_inpcb->inp_socket->so_options & SO_NOSLOWSTART) == 0)
 823a180:	e0bffe17 	ldw	r2,-8(fp)
 823a184:	10800d17 	ldw	r2,52(r2)
 823a188:	10800817 	ldw	r2,32(r2)
 823a18c:	10800417 	ldw	r2,16(r2)
 823a190:	1090000c 	andi	r2,r2,16384
 823a194:	1000241e 	bne	r2,zero,823a228 <tcp_timers+0x2e0>
      {
         u_int win = MIN(tp->snd_wnd, tp->snd_cwnd);
 823a198:	e0bffe17 	ldw	r2,-8(fp)
 823a19c:	11001417 	ldw	r4,80(r2)
 823a1a0:	e0bffe17 	ldw	r2,-8(fp)
 823a1a4:	10c01b17 	ldw	r3,108(r2)
 823a1a8:	2005883a 	mov	r2,r4
 823a1ac:	1880012e 	bgeu	r3,r2,823a1b4 <tcp_timers+0x26c>
 823a1b0:	1805883a 	mov	r2,r3
 823a1b4:	e0bffc15 	stw	r2,-16(fp)
         win = win / 2 / tp->t_maxseg;
 823a1b8:	e0bffc17 	ldw	r2,-16(fp)
 823a1bc:	1006d07a 	srli	r3,r2,1
 823a1c0:	e0bffe17 	ldw	r2,-8(fp)
 823a1c4:	10800a0b 	ldhu	r2,40(r2)
 823a1c8:	10bfffcc 	andi	r2,r2,65535
 823a1cc:	100b883a 	mov	r5,r2
 823a1d0:	1809883a 	mov	r4,r3
 823a1d4:	8202b8c0 	call	8202b8c <__udivsi3>
 823a1d8:	e0bffc15 	stw	r2,-16(fp)
         if (win < 2)
 823a1dc:	e0bffc17 	ldw	r2,-16(fp)
 823a1e0:	108000a8 	cmpgeui	r2,r2,2
 823a1e4:	1000021e 	bne	r2,zero,823a1f0 <tcp_timers+0x2a8>
            win = 2;
 823a1e8:	00800084 	movi	r2,2
 823a1ec:	e0bffc15 	stw	r2,-16(fp)
         tp->snd_cwnd = tp->t_maxseg;
 823a1f0:	e0bffe17 	ldw	r2,-8(fp)
 823a1f4:	10800a0b 	ldhu	r2,40(r2)
 823a1f8:	10ffffcc 	andi	r3,r2,65535
 823a1fc:	e0bffe17 	ldw	r2,-8(fp)
 823a200:	10c01b15 	stw	r3,108(r2)
         tp->snd_ssthresh = (u_short)win * tp->t_maxseg;
 823a204:	e0bffc17 	ldw	r2,-16(fp)
 823a208:	10ffffcc 	andi	r3,r2,65535
 823a20c:	e0bffe17 	ldw	r2,-8(fp)
 823a210:	10800a0b 	ldhu	r2,40(r2)
 823a214:	10bfffcc 	andi	r2,r2,65535
 823a218:	1885383a 	mul	r2,r3,r2
 823a21c:	1007883a 	mov	r3,r2
 823a220:	e0bffe17 	ldw	r2,-8(fp)
 823a224:	10c01c15 	stw	r3,112(r2)
      }
      (void) tcp_output(tp);
 823a228:	e13ffe17 	ldw	r4,-8(fp)
 823a22c:	82381700 	call	8238170 <tcp_output>
      break;
 823a230:	00005f06 	br	823a3b0 <tcp_timers+0x468>
   /*
    * Persistance timer into zero window.
    * Force a byte to be output, if possible.
    */
   case TCPT_PERSIST:
      tcpstat.tcps_persisttimeo++;
 823a234:	008209b4 	movhi	r2,2086
 823a238:	10b99404 	addi	r2,r2,-6576
 823a23c:	10800b17 	ldw	r2,44(r2)
 823a240:	10c00044 	addi	r3,r2,1
 823a244:	008209b4 	movhi	r2,2086
 823a248:	10b99404 	addi	r2,r2,-6576
 823a24c:	10c00b15 	stw	r3,44(r2)
      tcp_setpersist(tp);
 823a250:	e13ffe17 	ldw	r4,-8(fp)
 823a254:	82391740 	call	8239174 <tcp_setpersist>
      tp->t_force = 1;
 823a258:	e0bffe17 	ldw	r2,-8(fp)
 823a25c:	00c00044 	movi	r3,1
 823a260:	10c00a85 	stb	r3,42(r2)
      (void) tcp_output(tp);
 823a264:	e13ffe17 	ldw	r4,-8(fp)
 823a268:	82381700 	call	8238170 <tcp_output>
      tp->t_force = 0;
 823a26c:	e0bffe17 	ldw	r2,-8(fp)
 823a270:	10000a85 	stb	zero,42(r2)
      break;
 823a274:	00004e06 	br	823a3b0 <tcp_timers+0x468>
   /*
    * Keep-alive timer went off; send something
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
 823a278:	008209b4 	movhi	r2,2086
 823a27c:	10b99404 	addi	r2,r2,-6576
 823a280:	10800c17 	ldw	r2,48(r2)
 823a284:	10c00044 	addi	r3,r2,1
 823a288:	008209b4 	movhi	r2,2086
 823a28c:	10b99404 	addi	r2,r2,-6576
 823a290:	10c00c15 	stw	r3,48(r2)
      if (tp->t_state < TCPS_ESTABLISHED)
 823a294:	e0bffe17 	ldw	r2,-8(fp)
 823a298:	10800217 	ldw	r2,8(r2)
 823a29c:	10800108 	cmpgei	r2,r2,4
 823a2a0:	10003426 	beq	r2,zero,823a374 <tcp_timers+0x42c>
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 823a2a4:	e0bffe17 	ldw	r2,-8(fp)
 823a2a8:	10800d17 	ldw	r2,52(r2)
 823a2ac:	10800817 	ldw	r2,32(r2)
 823a2b0:	10800417 	ldw	r2,16(r2)
 823a2b4:	1080020c 	andi	r2,r2,8
 823a2b8:	10002726 	beq	r2,zero,823a358 <tcp_timers+0x410>
          tp->t_state <= TCPS_CLOSE_WAIT) 
 823a2bc:	e0bffe17 	ldw	r2,-8(fp)
 823a2c0:	10800217 	ldw	r2,8(r2)
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 823a2c4:	10800188 	cmpgei	r2,r2,6
 823a2c8:	1000231e 	bne	r2,zero,823a358 <tcp_timers+0x410>
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
 823a2cc:	e0bffe17 	ldw	r2,-8(fp)
 823a2d0:	10c01d17 	ldw	r3,116(r2)
 823a2d4:	d1203e17 	ldw	r4,-32520(gp)
 823a2d8:	d0a0b417 	ldw	r2,-32048(gp)
 823a2dc:	2085883a 	add	r2,r4,r2
 823a2e0:	1880260e 	bge	r3,r2,823a37c <tcp_timers+0x434>
          * causes the transmitted zero-length segment
          * to lie outside the receive window;
          * by the protocol spec, this requires the
          * correspondent TCP to respond.
          */
         tcpstat.tcps_keepprobe++;
 823a2e4:	008209b4 	movhi	r2,2086
 823a2e8:	10b99404 	addi	r2,r2,-6576
 823a2ec:	10800d17 	ldw	r2,52(r2)
 823a2f0:	10c00044 	addi	r3,r2,1
 823a2f4:	008209b4 	movhi	r2,2086
 823a2f8:	10b99404 	addi	r2,r2,-6576
 823a2fc:	10c00d15 	stw	r3,52(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 823a300:	e0bffe17 	ldw	r2,-8(fp)
 823a304:	10c00c17 	ldw	r3,48(r2)
 823a308:	e0bffe17 	ldw	r2,-8(fp)
 823a30c:	10801617 	ldw	r2,88(r2)
 823a310:	113fffc4 	addi	r4,r2,-1
            tp->snd_una - 1, 0, (struct mbuf *)NULL);
 823a314:	e0bffe17 	ldw	r2,-8(fp)
 823a318:	10800e17 	ldw	r2,56(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 823a31c:	10bfffc4 	addi	r2,r2,-1
 823a320:	d8000115 	stw	zero,4(sp)
 823a324:	d8000015 	stw	zero,0(sp)
 823a328:	100f883a 	mov	r7,r2
 823a32c:	200d883a 	mov	r6,r4
 823a330:	180b883a 	mov	r5,r3
 823a334:	e13ffe17 	ldw	r4,-8(fp)
 823a338:	82394980 	call	8239498 <tcp_respond>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
 823a33c:	d0a03f17 	ldw	r2,-32516(gp)
 823a340:	10ffffcc 	andi	r3,r2,65535
 823a344:	18e0001c 	xori	r3,r3,32768
 823a348:	18e00004 	addi	r3,r3,-32768
 823a34c:	e0bffe17 	ldw	r2,-8(fp)
 823a350:	10c00515 	stw	r3,20(r2)
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
      break;
 823a354:	00001606 	br	823a3b0 <tcp_timers+0x468>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
 823a358:	d0a03e17 	ldw	r2,-32520(gp)
 823a35c:	10ffffcc 	andi	r3,r2,65535
 823a360:	18e0001c 	xori	r3,r3,32768
 823a364:	18e00004 	addi	r3,r3,-32768
 823a368:	e0bffe17 	ldw	r2,-8(fp)
 823a36c:	10c00515 	stw	r3,20(r2)
      break;
 823a370:	00000f06 	br	823a3b0 <tcp_timers+0x468>
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
 823a374:	0001883a 	nop
 823a378:	00000106 	br	823a380 <tcp_timers+0x438>
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
            goto dropit;
 823a37c:	0001883a 	nop
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
      break;
      dropit:
      tcpstat.tcps_keepdrops++;
 823a380:	008209b4 	movhi	r2,2086
 823a384:	10b99404 	addi	r2,r2,-6576
 823a388:	10800e17 	ldw	r2,56(r2)
 823a38c:	10c00044 	addi	r3,r2,1
 823a390:	008209b4 	movhi	r2,2086
 823a394:	10b99404 	addi	r2,r2,-6576
 823a398:	10c00e15 	stw	r3,56(r2)
      tp = tcp_drop (tp, ETIMEDOUT);
 823a39c:	01401d04 	movi	r5,116
 823a3a0:	e13ffe17 	ldw	r4,-8(fp)
 823a3a4:	82399a40 	call	82399a4 <tcp_drop>
 823a3a8:	e0bffe15 	stw	r2,-8(fp)
      break;
 823a3ac:	0001883a 	nop
   }
   return tp;
 823a3b0:	e0bffe17 	ldw	r2,-8(fp)
}
 823a3b4:	e037883a 	mov	sp,fp
 823a3b8:	dfc00117 	ldw	ra,4(sp)
 823a3bc:	df000017 	ldw	fp,0(sp)
 823a3c0:	dec00204 	addi	sp,sp,8
 823a3c4:	f800283a 	ret

0823a3c8 <tcp_usrreq>:

int
tcp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 823a3c8:	defff604 	addi	sp,sp,-40
 823a3cc:	dfc00915 	stw	ra,36(sp)
 823a3d0:	df000815 	stw	fp,32(sp)
 823a3d4:	df000804 	addi	fp,sp,32
 823a3d8:	e13ffd15 	stw	r4,-12(fp)
 823a3dc:	e17ffe15 	stw	r5,-8(fp)
 823a3e0:	e1bfff15 	stw	r6,-4(fp)
   struct inpcb * inp;
   struct tcpcb * tp;
   int   error =  0;
 823a3e4:	e03ff915 	stw	zero,-28(fp)

#ifdef DO_TCPTRACE
   int   ostate;
#endif

   req = so->so_req;    /* get request from socket struct */
 823a3e8:	e0bffd17 	ldw	r2,-12(fp)
 823a3ec:	10800717 	ldw	r2,28(r2)
 823a3f0:	e0bffa15 	stw	r2,-24(fp)
   inp = sotoinpcb(so);
 823a3f4:	e0bffd17 	ldw	r2,-12(fp)
 823a3f8:	10800117 	ldw	r2,4(r2)
 823a3fc:	e0bffb15 	stw	r2,-20(fp)
   /*
    * When a TCP is attached to a socket, then there will be
    * a (struct inpcb) pointed at by the socket, and this
    * structure will point at a subsidary (struct tcpcb).
    */
   if (inp == 0 && req != PRU_ATTACH) 
 823a400:	e0bffb17 	ldw	r2,-20(fp)
 823a404:	1000041e 	bne	r2,zero,823a418 <tcp_usrreq+0x50>
 823a408:	e0bffa17 	ldw	r2,-24(fp)
 823a40c:	10000226 	beq	r2,zero,823a418 <tcp_usrreq+0x50>
   {
      return (EINVAL);
 823a410:	00800584 	movi	r2,22
 823a414:	00019c06 	br	823aa88 <tcp_usrreq+0x6c0>
   }

   if (inp)
 823a418:	e0bffb17 	ldw	r2,-20(fp)
 823a41c:	10000426 	beq	r2,zero,823a430 <tcp_usrreq+0x68>
      tp = intotcpcb(inp);
 823a420:	e0bffb17 	ldw	r2,-20(fp)
 823a424:	10800917 	ldw	r2,36(r2)
 823a428:	e0bff815 	stw	r2,-32(fp)
 823a42c:	00000706 	br	823a44c <tcp_usrreq+0x84>
   else  /* inp and tp not set, make sure this is OK: */
   { 
      if (req == PRU_ATTACH)
 823a430:	e0bffa17 	ldw	r2,-24(fp)
 823a434:	1000021e 	bne	r2,zero,823a440 <tcp_usrreq+0x78>
         tp = NULL;  /* stifle compiler warnings about using unassigned tp*/
 823a438:	e03ff815 	stw	zero,-32(fp)
 823a43c:	00000306 	br	823a44c <tcp_usrreq+0x84>
      else
      {
         dtrap(); /* programming error? */
 823a440:	822d4140 	call	822d414 <dtrap>
         return EINVAL;
 823a444:	00800584 	movi	r2,22
 823a448:	00018f06 	br	823aa88 <tcp_usrreq+0x6c0>
      }
   }

   switch (req) 
 823a44c:	e0bffa17 	ldw	r2,-24(fp)
 823a450:	10800528 	cmpgeui	r2,r2,20
 823a454:	1001761e 	bne	r2,zero,823aa30 <tcp_usrreq+0x668>
 823a458:	e0bffa17 	ldw	r2,-24(fp)
 823a45c:	100690ba 	slli	r3,r2,2
 823a460:	00820934 	movhi	r2,2084
 823a464:	10a91d04 	addi	r2,r2,-23436
 823a468:	1885883a 	add	r2,r3,r2
 823a46c:	10800017 	ldw	r2,0(r2)
 823a470:	1000683a 	jmp	r2
 823a474:	0823a4c4 	addi	zero,at,-29037
 823a478:	0823a524 	muli	zero,at,-29036
 823a47c:	0823a54c 	andi	zero,at,36501
 823a480:	0823a584 	addi	zero,at,-29034
 823a484:	0823a5bc 	xorhi	zero,at,36502
 823a488:	0823a714 	ori	zero,at,36508
 823a48c:	0823a708 	cmpgei	zero,at,-29028
 823a490:	0823a7c4 	addi	zero,at,-29025
 823a494:	0823a7f0 	cmpltui	zero,at,36511
 823a498:	0823a7fc 	xorhi	zero,at,36511
 823a49c:	0823a858 	cmpnei	zero,at,-29023
 823a4a0:	0823aa30 	cmpltui	zero,at,36520
 823a4a4:	0823a868 	cmpgeui	zero,at,36513
 823a4a8:	0823a874 	orhi	zero,at,36513
 823a4ac:	0823a92c 	andhi	zero,at,36516
 823a4b0:	0823a9fc 	xorhi	zero,at,36519
 823a4b4:	0823aa0c 	andi	zero,at,36520
 823a4b8:	0823a6fc 	xorhi	zero,at,36507
 823a4bc:	0823aa30 	cmpltui	zero,at,36520
 823a4c0:	0823aa1c 	xori	zero,at,36520
   /*
    * TCP attaches to socket via PRU_ATTACH, reserving space,
    * and an internet control block.
    */
   case PRU_ATTACH:
      if (inp) 
 823a4c4:	e0bffb17 	ldw	r2,-20(fp)
 823a4c8:	10000326 	beq	r2,zero,823a4d8 <tcp_usrreq+0x110>
      {
         error = EISCONN;
 823a4cc:	00801fc4 	movi	r2,127
 823a4d0:	e0bff915 	stw	r2,-28(fp)
         break;
 823a4d4:	00016b06 	br	823aa84 <tcp_usrreq+0x6bc>
      }
      error = tcp_attach(so);
 823a4d8:	e13ffd17 	ldw	r4,-12(fp)
 823a4dc:	823aa9c0 	call	823aa9c <tcp_attach>
 823a4e0:	e0bff915 	stw	r2,-28(fp)
      if (error)
 823a4e4:	e0bff917 	ldw	r2,-28(fp)
 823a4e8:	1001551e 	bne	r2,zero,823aa40 <tcp_usrreq+0x678>
         break;
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 823a4ec:	e0bffd17 	ldw	r2,-12(fp)
 823a4f0:	10800417 	ldw	r2,16(r2)
 823a4f4:	1080200c 	andi	r2,r2,128
 823a4f8:	10015326 	beq	r2,zero,823aa48 <tcp_usrreq+0x680>
 823a4fc:	e0bffd17 	ldw	r2,-12(fp)
 823a500:	1080080b 	ldhu	r2,32(r2)
 823a504:	10bfffcc 	andi	r2,r2,65535
 823a508:	10a0001c 	xori	r2,r2,32768
 823a50c:	10a00004 	addi	r2,r2,-32768
 823a510:	10014d1e 	bne	r2,zero,823aa48 <tcp_usrreq+0x680>
         so->so_linger = TCP_LINGERTIME;
 823a514:	e0bffd17 	ldw	r2,-12(fp)
 823a518:	00c01e04 	movi	r3,120
 823a51c:	10c0080d 	sth	r3,32(r2)
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 823a520:	00014906 	br	823aa48 <tcp_usrreq+0x680>
    * do this directly: have to initiate a PRU_DISCONNECT,
    * which may finish later; embryonic TCB's can just
    * be discarded here.
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
 823a524:	e0bff817 	ldw	r2,-32(fp)
 823a528:	10800217 	ldw	r2,8(r2)
 823a52c:	10800090 	cmplti	r2,r2,2
 823a530:	1000031e 	bne	r2,zero,823a540 <tcp_usrreq+0x178>
         SETTP(tp, tcp_disconnect(tp));
 823a534:	e13ff817 	ldw	r4,-32(fp)
 823a538:	823abb40 	call	823abb4 <tcp_disconnect>
      else
         SETTP(tp, tcp_close(tp));
      break;
 823a53c:	00015106 	br	823aa84 <tcp_usrreq+0x6bc>
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
         SETTP(tp, tcp_disconnect(tp));
      else
         SETTP(tp, tcp_close(tp));
 823a540:	e13ff817 	ldw	r4,-32(fp)
 823a544:	8239a500 	call	8239a50 <tcp_close>
      break;
 823a548:	00014e06 	br	823aa84 <tcp_usrreq+0x6bc>
      /* bind is quite different for IPv4 and v6, so we use two 
       * seperate pcbbind routines. so_domain was checked for 
       * validity way up in t_bind()
       */
#ifdef IP_V4
      if(inp->inp_socket->so_domain == AF_INET)
 823a54c:	e0bffb17 	ldw	r2,-20(fp)
 823a550:	10800817 	ldw	r2,32(r2)
 823a554:	10800517 	ldw	r2,20(r2)
 823a558:	10800098 	cmpnei	r2,r2,2
 823a55c:	1000051e 	bne	r2,zero,823a574 <tcp_usrreq+0x1ac>
      {
         error = in_pcbbind(inp, nam);
 823a560:	e17fff17 	ldw	r5,-4(fp)
 823a564:	e13ffb17 	ldw	r4,-20(fp)
 823a568:	8247d680 	call	8247d68 <in_pcbbind>
 823a56c:	e0bff915 	stw	r2,-28(fp)
         break;
 823a570:	00014406 	br	823aa84 <tcp_usrreq+0x6bc>
      {
         error = ip6_pcbbind(inp, nam);
         break;
      }
#endif /* IP_V6 */
      dtrap();    /* not v4 or v6? */
 823a574:	822d4140 	call	822d414 <dtrap>
      error = EINVAL;
 823a578:	00800584 	movi	r2,22
 823a57c:	e0bff915 	stw	r2,-28(fp)
      break;
 823a580:	00014006 	br	823aa84 <tcp_usrreq+0x6bc>
   /*
    * Prepare to accept connections.
    */
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
 823a584:	e0bffb17 	ldw	r2,-20(fp)
 823a588:	1080078b 	ldhu	r2,30(r2)
 823a58c:	10bfffcc 	andi	r2,r2,65535
 823a590:	1000041e 	bne	r2,zero,823a5a4 <tcp_usrreq+0x1dc>
         error = in_pcbbind(inp, (struct mbuf *)0);
 823a594:	000b883a 	mov	r5,zero
 823a598:	e13ffb17 	ldw	r4,-20(fp)
 823a59c:	8247d680 	call	8247d68 <in_pcbbind>
 823a5a0:	e0bff915 	stw	r2,-28(fp)
      if (error == 0)
 823a5a4:	e0bff917 	ldw	r2,-28(fp)
 823a5a8:	1001291e 	bne	r2,zero,823aa50 <tcp_usrreq+0x688>
         tp->t_state = TCPS_LISTEN;
 823a5ac:	e0bff817 	ldw	r2,-32(fp)
 823a5b0:	00c00044 	movi	r3,1
 823a5b4:	10c00215 	stw	r3,8(r2)
      break;
 823a5b8:	00012506 	br	823aa50 <tcp_usrreq+0x688>
    * Enter SYN_SENT state, and mark socket as connecting.
    * Start keep-alive timer, and seed output sequence space.
    * Send initial segment on connection.
    */
   case PRU_CONNECT:
      if (inp->inp_lport == 0) 
 823a5bc:	e0bffb17 	ldw	r2,-20(fp)
 823a5c0:	1080078b 	ldhu	r2,30(r2)
 823a5c4:	10bfffcc 	andi	r2,r2,65535
 823a5c8:	1000061e 	bne	r2,zero,823a5e4 <tcp_usrreq+0x21c>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbbind(inp, (struct mbuf *)0);
 823a5cc:	000b883a 	mov	r5,zero
 823a5d0:	e13ffb17 	ldw	r4,-20(fp)
 823a5d4:	8247d680 	call	8247d68 <in_pcbbind>
 823a5d8:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
 823a5dc:	e0bff917 	ldw	r2,-28(fp)
 823a5e0:	10011d1e 	bne	r2,zero,823aa58 <tcp_usrreq+0x690>
            break;
      }

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbconnect(inp, nam);
 823a5e4:	e17fff17 	ldw	r5,-4(fp)
 823a5e8:	e13ffb17 	ldw	r4,-20(fp)
 823a5ec:	8247f780 	call	8247f78 <in_pcbconnect>
 823a5f0:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
 823a5f4:	e0bff917 	ldw	r2,-28(fp)
 823a5f8:	1001191e 	bne	r2,zero,823aa60 <tcp_usrreq+0x698>
         break;
      tp->t_template = tcp_template(tp);
 823a5fc:	e13ff817 	ldw	r4,-32(fp)
 823a600:	82393900 	call	8239390 <tcp_template>
 823a604:	1007883a 	mov	r3,r2
 823a608:	e0bff817 	ldw	r2,-32(fp)
 823a60c:	10c00c15 	stw	r3,48(r2)
      if (tp->t_template == 0) 
 823a610:	e0bff817 	ldw	r2,-32(fp)
 823a614:	10800c17 	ldw	r2,48(r2)
 823a618:	1000051e 	bne	r2,zero,823a630 <tcp_usrreq+0x268>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
         in_pcbdisconnect(inp);
 823a61c:	e13ffb17 	ldw	r4,-20(fp)
 823a620:	82481580 	call	8248158 <in_pcbdisconnect>
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
         ip6_pcbdisconnect(inp);
#endif   /* end v6 only */

         error = ENOBUFS;
 823a624:	00801a44 	movi	r2,105
 823a628:	e0bff915 	stw	r2,-28(fp)
         break;
 823a62c:	00011506 	br	823aa84 <tcp_usrreq+0x6bc>
      }

      soisconnecting(so);
 823a630:	e13ffd17 	ldw	r4,-12(fp)
 823a634:	82338e80 	call	82338e8 <soisconnecting>
      tcpstat.tcps_connattempt++;
 823a638:	008209b4 	movhi	r2,2086
 823a63c:	10b99404 	addi	r2,r2,-6576
 823a640:	10800017 	ldw	r2,0(r2)
 823a644:	10c00044 	addi	r3,r2,1
 823a648:	008209b4 	movhi	r2,2086
 823a64c:	10b99404 	addi	r2,r2,-6576
 823a650:	10c00015 	stw	r3,0(r2)
      tp->t_state = TCPS_SYN_SENT;
 823a654:	e0bff817 	ldw	r2,-32(fp)
 823a658:	00c00084 	movi	r3,2
 823a65c:	10c00215 	stw	r3,8(r2)
      tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 823a660:	e0bff817 	ldw	r2,-32(fp)
 823a664:	00c02584 	movi	r3,150
 823a668:	10c00515 	stw	r3,20(r2)
      tp->iss = tcp_iss; 
 823a66c:	d0e0b517 	ldw	r3,-32044(gp)
 823a670:	e0bff817 	ldw	r2,-32(fp)
 823a674:	10c01315 	stw	r3,76(r2)
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
 823a678:	d0e0b517 	ldw	r3,-32044(gp)
 823a67c:	00be9fd4 	movui	r2,64127
 823a680:	1885883a 	add	r2,r3,r2
 823a684:	d0a0b515 	stw	r2,-32044(gp)
      tcp_sendseqinit(tp);
 823a688:	e0bff817 	ldw	r2,-32(fp)
 823a68c:	10c01317 	ldw	r3,76(r2)
 823a690:	e0bff817 	ldw	r2,-32(fp)
 823a694:	10c01015 	stw	r3,64(r2)
 823a698:	e0bff817 	ldw	r2,-32(fp)
 823a69c:	10c01017 	ldw	r3,64(r2)
 823a6a0:	e0bff817 	ldw	r2,-32(fp)
 823a6a4:	10c01a15 	stw	r3,104(r2)
 823a6a8:	e0bff817 	ldw	r2,-32(fp)
 823a6ac:	10c01a17 	ldw	r3,104(r2)
 823a6b0:	e0bff817 	ldw	r2,-32(fp)
 823a6b4:	10c00f15 	stw	r3,60(r2)
 823a6b8:	e0bff817 	ldw	r2,-32(fp)
 823a6bc:	10c00f17 	ldw	r3,60(r2)
 823a6c0:	e0bff817 	ldw	r2,-32(fp)
 823a6c4:	10c00e15 	stw	r3,56(r2)
      error = tcp_output(tp);
 823a6c8:	e13ff817 	ldw	r4,-32(fp)
 823a6cc:	82381700 	call	8238170 <tcp_output>
 823a6d0:	e0bff915 	stw	r2,-28(fp)
      if (!error)
 823a6d4:	e0bff917 	ldw	r2,-28(fp)
 823a6d8:	1000e31e 	bne	r2,zero,823aa68 <tcp_usrreq+0x6a0>
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
 823a6dc:	008209b4 	movhi	r2,2086
 823a6e0:	10b96604 	addi	r2,r2,-6760
 823a6e4:	10800417 	ldw	r2,16(r2)
 823a6e8:	10c00044 	addi	r3,r2,1
 823a6ec:	008209b4 	movhi	r2,2086
 823a6f0:	10b96604 	addi	r2,r2,-6760
 823a6f4:	10c00415 	stw	r3,16(r2)
      break;
 823a6f8:	0000db06 	br	823aa68 <tcp_usrreq+0x6a0>

   /*
    * Create a TCP connection between two sockets.
    */
   case PRU_CONNECT2:
      error = EOPNOTSUPP;
 823a6fc:	008017c4 	movi	r2,95
 823a700:	e0bff915 	stw	r2,-28(fp)
      break;
 823a704:	0000df06 	br	823aa84 <tcp_usrreq+0x6bc>
    * when peer sends FIN and acks ours.
    *
    * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
    */
   case PRU_DISCONNECT:
      SETTP(tp, tcp_disconnect(tp));
 823a708:	e13ff817 	ldw	r4,-32(fp)
 823a70c:	823abb40 	call	823abb4 <tcp_disconnect>
      break;
 823a710:	0000dc06 	br	823aa84 <tcp_usrreq+0x6bc>
    * done at higher levels; just return the address
    * of the peer, storing through addr.
    */
   case PRU_ACCEPT: 
   {
         struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 823a714:	e0bfff17 	ldw	r2,-4(fp)
 823a718:	10800317 	ldw	r2,12(r2)
 823a71c:	e0bffc15 	stw	r2,-16(fp)
            IP6CPY(&sin6->sin6_addr, &inp->ip6_faddr);
         }
#endif

#ifdef IP_V4
         if (so->so_domain == AF_INET)
 823a720:	e0bffd17 	ldw	r2,-12(fp)
 823a724:	10800517 	ldw	r2,20(r2)
 823a728:	10800098 	cmpnei	r2,r2,2
 823a72c:	10000e1e 	bne	r2,zero,823a768 <tcp_usrreq+0x3a0>
         {
            nam->m_len = sizeof (struct sockaddr_in);
 823a730:	e0bfff17 	ldw	r2,-4(fp)
 823a734:	00c00404 	movi	r3,16
 823a738:	10c00215 	stw	r3,8(r2)
            sin->sin_family = AF_INET;
 823a73c:	e0bffc17 	ldw	r2,-16(fp)
 823a740:	00c00084 	movi	r3,2
 823a744:	10c0000d 	sth	r3,0(r2)
            sin->sin_port = inp->inp_fport;
 823a748:	e0bffb17 	ldw	r2,-20(fp)
 823a74c:	10c0070b 	ldhu	r3,28(r2)
 823a750:	e0bffc17 	ldw	r2,-16(fp)
 823a754:	10c0008d 	sth	r3,2(r2)
            sin->sin_addr = inp->inp_faddr;
 823a758:	e0bffc17 	ldw	r2,-16(fp)
 823a75c:	e0fffb17 	ldw	r3,-20(fp)
 823a760:	18c00317 	ldw	r3,12(r3)
 823a764:	10c00115 	stw	r3,4(r2)
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 823a768:	e0bffd17 	ldw	r2,-12(fp)
 823a76c:	10800517 	ldw	r2,20(r2)
 823a770:	108000a0 	cmpeqi	r2,r2,2
 823a774:	10000b1e 	bne	r2,zero,823a7a4 <tcp_usrreq+0x3dc>
              !(so->so_domain == AF_INET6)
 823a778:	e0bffd17 	ldw	r2,-12(fp)
 823a77c:	10800517 	ldw	r2,20(r2)
            sin->sin_family = AF_INET;
            sin->sin_port = inp->inp_fport;
            sin->sin_addr = inp->inp_faddr;
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 823a780:	108000e0 	cmpeqi	r2,r2,3
 823a784:	1000071e 	bne	r2,zero,823a7a4 <tcp_usrreq+0x3dc>
              !(so->so_domain == AF_INET6)
             )
         {
            dprintf("*** PRU_ACCEPT bad domain = %d\n", so->so_domain);
 823a788:	e0bffd17 	ldw	r2,-12(fp)
 823a78c:	10800517 	ldw	r2,20(r2)
 823a790:	100b883a 	mov	r5,r2
 823a794:	01020974 	movhi	r4,2085
 823a798:	2103c404 	addi	r4,r4,3856
 823a79c:	820331c0 	call	820331c <printf>
            dtrap();
 823a7a0:	822d4140 	call	822d414 <dtrap>
         } 
         TCP_MIB_INC(tcpPassiveOpens);    /* keep MIB stats */
 823a7a4:	008209b4 	movhi	r2,2086
 823a7a8:	10b96604 	addi	r2,r2,-6760
 823a7ac:	10800517 	ldw	r2,20(r2)
 823a7b0:	10c00044 	addi	r3,r2,1
 823a7b4:	008209b4 	movhi	r2,2086
 823a7b8:	10b96604 	addi	r2,r2,-6760
 823a7bc:	10c00515 	stw	r3,20(r2)
         break;
 823a7c0:	0000b006 	br	823aa84 <tcp_usrreq+0x6bc>

   /*
    * Mark the connection as being incapable of further output.
    */
   case PRU_SHUTDOWN:
      socantsendmore(so);
 823a7c4:	e13ffd17 	ldw	r4,-12(fp)
 823a7c8:	8233f6c0 	call	8233f6c <socantsendmore>
      tp = tcp_usrclosed(tp);
 823a7cc:	e13ff817 	ldw	r4,-32(fp)
 823a7d0:	823ac800 	call	823ac80 <tcp_usrclosed>
 823a7d4:	e0bff815 	stw	r2,-32(fp)
      if (tp)
 823a7d8:	e0bff817 	ldw	r2,-32(fp)
 823a7dc:	1000a426 	beq	r2,zero,823aa70 <tcp_usrreq+0x6a8>
         error = tcp_output(tp);
 823a7e0:	e13ff817 	ldw	r4,-32(fp)
 823a7e4:	82381700 	call	8238170 <tcp_output>
 823a7e8:	e0bff915 	stw	r2,-28(fp)
      break;
 823a7ec:	0000a006 	br	823aa70 <tcp_usrreq+0x6a8>

   /*
    * After a receive, possibly send window update to peer.
    */
   case PRU_RCVD:
      (void) tcp_output(tp);
 823a7f0:	e13ff817 	ldw	r4,-32(fp)
 823a7f4:	82381700 	call	8238170 <tcp_output>
      break;
 823a7f8:	0000a206 	br	823aa84 <tcp_usrreq+0x6bc>
   /*
    * Do a send by putting data in output queue and updating urgent
    * marker if URG set.  Possibly send more data.
    */
   case PRU_SEND:
      if (so->so_pcb == NULL)
 823a7fc:	e0bffd17 	ldw	r2,-12(fp)
 823a800:	10800117 	ldw	r2,4(r2)
 823a804:	1000031e 	bne	r2,zero,823a814 <tcp_usrreq+0x44c>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 823a808:	00800804 	movi	r2,32
 823a80c:	e0bff915 	stw	r2,-28(fp)
         break;
 823a810:	00009c06 	br	823aa84 <tcp_usrreq+0x6bc>
      }
      sbappend(&so->so_snd, m);
 823a814:	e0bffd17 	ldw	r2,-12(fp)
 823a818:	10801204 	addi	r2,r2,72
 823a81c:	e17ffe17 	ldw	r5,-8(fp)
 823a820:	1009883a 	mov	r4,r2
 823a824:	82342740 	call	8234274 <sbappend>
      error = tcp_output(tp);
 823a828:	e13ff817 	ldw	r4,-32(fp)
 823a82c:	82381700 	call	8238170 <tcp_output>
 823a830:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 823a834:	e0bff917 	ldw	r2,-28(fp)
 823a838:	10801a58 	cmpnei	r2,r2,105
 823a83c:	10008e1e 	bne	r2,zero,823aa78 <tcp_usrreq+0x6b0>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 823a840:	e0bffd17 	ldw	r2,-12(fp)
 823a844:	10801204 	addi	r2,r2,72
 823a848:	e17ffe17 	ldw	r5,-8(fp)
 823a84c:	1009883a 	mov	r4,r2
 823a850:	82349e40 	call	82349e4 <sbdropend>
      break;
 823a854:	00008806 	br	823aa78 <tcp_usrreq+0x6b0>

   /*
    * Abort the TCP.
    */
   case PRU_ABORT:
      SETTP(tp, tcp_drop(tp, ECONNABORTED));
 823a858:	01401c44 	movi	r5,113
 823a85c:	e13ff817 	ldw	r4,-32(fp)
 823a860:	82399a40 	call	82399a4 <tcp_drop>
      break;
 823a864:	00008706 	br	823aa84 <tcp_usrreq+0x6bc>

   case PRU_SENSE:
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
 823a868:	822d4140 	call	822d414 <dtrap>
      return (0);
 823a86c:	0005883a 	mov	r2,zero
 823a870:	00008506 	br	823aa88 <tcp_usrreq+0x6c0>

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 823a874:	e0bffd17 	ldw	r2,-12(fp)
 823a878:	10801a17 	ldw	r2,104(r2)
 823a87c:	1000051e 	bne	r2,zero,823a894 <tcp_usrreq+0x4cc>
          (so->so_state & SS_RCVATMARK) == 0) ||
 823a880:	e0bffd17 	ldw	r2,-12(fp)
 823a884:	1080088b 	ldhu	r2,34(r2)
 823a888:	10bfffcc 	andi	r2,r2,65535
 823a88c:	1080100c 	andi	r2,r2,64
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
      return (0);

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 823a890:	10000926 	beq	r2,zero,823a8b8 <tcp_usrreq+0x4f0>
          (so->so_state & SS_RCVATMARK) == 0) ||
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
 823a894:	e0bffd17 	ldw	r2,-12(fp)
 823a898:	10800417 	ldw	r2,16(r2)
 823a89c:	1080400c 	andi	r2,r2,256
      dtrap();    /* does this ever happen? */
      return (0);

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
          (so->so_state & SS_RCVATMARK) == 0) ||
 823a8a0:	1000051e 	bne	r2,zero,823a8b8 <tcp_usrreq+0x4f0>
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
 823a8a4:	e0bff817 	ldw	r2,-32(fp)
 823a8a8:	10802403 	ldbu	r2,144(r2)
 823a8ac:	10803fcc 	andi	r2,r2,255
 823a8b0:	1080008c 	andi	r2,r2,2

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
          (so->so_state & SS_RCVATMARK) == 0) ||
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
 823a8b4:	10000326 	beq	r2,zero,823a8c4 <tcp_usrreq+0x4fc>
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
       {
         error = EINVAL;
 823a8b8:	00800584 	movi	r2,22
 823a8bc:	e0bff915 	stw	r2,-28(fp)
         break;
 823a8c0:	00007006 	br	823aa84 <tcp_usrreq+0x6bc>
      }
      if ((tp->t_oobflags & TCPOOB_HAVEDATA) == 0) 
 823a8c4:	e0bff817 	ldw	r2,-32(fp)
 823a8c8:	10802403 	ldbu	r2,144(r2)
 823a8cc:	10803fcc 	andi	r2,r2,255
 823a8d0:	1080004c 	andi	r2,r2,1
 823a8d4:	1000031e 	bne	r2,zero,823a8e4 <tcp_usrreq+0x51c>
      {
         error = EWOULDBLOCK;
 823a8d8:	008002c4 	movi	r2,11
 823a8dc:	e0bff915 	stw	r2,-28(fp)
         break;
 823a8e0:	00006806 	br	823aa84 <tcp_usrreq+0x6bc>
      }
      m->m_len = 1;
 823a8e4:	e0bffe17 	ldw	r2,-8(fp)
 823a8e8:	00c00044 	movi	r3,1
 823a8ec:	10c00215 	stw	r3,8(r2)
      *mtod(m, char *) = tp->t_iobc;
 823a8f0:	e0bffe17 	ldw	r2,-8(fp)
 823a8f4:	10800317 	ldw	r2,12(r2)
 823a8f8:	e0fff817 	ldw	r3,-32(fp)
 823a8fc:	18c02443 	ldbu	r3,145(r3)
 823a900:	10c00005 	stb	r3,0(r2)
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
 823a904:	e0bfff17 	ldw	r2,-4(fp)
 823a908:	1080008c 	andi	r2,r2,2
 823a90c:	10005c1e 	bne	r2,zero,823aa80 <tcp_usrreq+0x6b8>
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 823a910:	e0bff817 	ldw	r2,-32(fp)
 823a914:	10802403 	ldbu	r2,144(r2)
 823a918:	108000dc 	xori	r2,r2,3
 823a91c:	1007883a 	mov	r3,r2
 823a920:	e0bff817 	ldw	r2,-32(fp)
 823a924:	10c02405 	stb	r3,144(r2)
      break;
 823a928:	00005506 	br	823aa80 <tcp_usrreq+0x6b8>

   case PRU_SENDOOB:
      if (so->so_pcb == NULL)
 823a92c:	e0bffd17 	ldw	r2,-12(fp)
 823a930:	10800117 	ldw	r2,4(r2)
 823a934:	1000031e 	bne	r2,zero,823a944 <tcp_usrreq+0x57c>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 823a938:	00800804 	movi	r2,32
 823a93c:	e0bff915 	stw	r2,-28(fp)
         break;
 823a940:	00005006 	br	823aa84 <tcp_usrreq+0x6bc>
      }
      if (sbspace(&so->so_snd) == 0) 
 823a944:	e0bffd17 	ldw	r2,-12(fp)
 823a948:	10801317 	ldw	r2,76(r2)
 823a94c:	1007883a 	mov	r3,r2
 823a950:	e0bffd17 	ldw	r2,-12(fp)
 823a954:	10801217 	ldw	r2,72(r2)
 823a958:	1885c83a 	sub	r2,r3,r2
 823a95c:	10000516 	blt	r2,zero,823a974 <tcp_usrreq+0x5ac>
 823a960:	e0bffd17 	ldw	r2,-12(fp)
 823a964:	10c01317 	ldw	r3,76(r2)
 823a968:	e0bffd17 	ldw	r2,-12(fp)
 823a96c:	10801217 	ldw	r2,72(r2)
 823a970:	1880051e 	bne	r3,r2,823a988 <tcp_usrreq+0x5c0>
      {
         m_freem(m);
 823a974:	e13ffe17 	ldw	r4,-8(fp)
 823a978:	822e4b80 	call	822e4b8 <m_freem>
         error = ENOBUFS;
 823a97c:	00801a44 	movi	r2,105
 823a980:	e0bff915 	stw	r2,-28(fp)
         break;
 823a984:	00003f06 	br	823aa84 <tcp_usrreq+0x6bc>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section.
       * Otherwise, snd_up should be one lower.
       */
      sbappend(&so->so_snd, m);
 823a988:	e0bffd17 	ldw	r2,-12(fp)
 823a98c:	10801204 	addi	r2,r2,72
 823a990:	e17ffe17 	ldw	r5,-8(fp)
 823a994:	1009883a 	mov	r4,r2
 823a998:	82342740 	call	8234274 <sbappend>
      tp->snd_up = tp->snd_una + so->so_snd.sb_cc;
 823a99c:	e0bff817 	ldw	r2,-32(fp)
 823a9a0:	10c00e17 	ldw	r3,56(r2)
 823a9a4:	e0bffd17 	ldw	r2,-12(fp)
 823a9a8:	10801217 	ldw	r2,72(r2)
 823a9ac:	1887883a 	add	r3,r3,r2
 823a9b0:	e0bff817 	ldw	r2,-32(fp)
 823a9b4:	10c01015 	stw	r3,64(r2)
      tp->t_force = 1;
 823a9b8:	e0bff817 	ldw	r2,-32(fp)
 823a9bc:	00c00044 	movi	r3,1
 823a9c0:	10c00a85 	stb	r3,42(r2)
      error = tcp_output(tp);
 823a9c4:	e13ff817 	ldw	r4,-32(fp)
 823a9c8:	82381700 	call	8238170 <tcp_output>
 823a9cc:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 823a9d0:	e0bff917 	ldw	r2,-28(fp)
 823a9d4:	10801a58 	cmpnei	r2,r2,105
 823a9d8:	1000051e 	bne	r2,zero,823a9f0 <tcp_usrreq+0x628>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 823a9dc:	e0bffd17 	ldw	r2,-12(fp)
 823a9e0:	10801204 	addi	r2,r2,72
 823a9e4:	e17ffe17 	ldw	r5,-8(fp)
 823a9e8:	1009883a 	mov	r4,r2
 823a9ec:	82349e40 	call	82349e4 <sbdropend>
      tp->t_force = 0;
 823a9f0:	e0bff817 	ldw	r2,-32(fp)
 823a9f4:	10000a85 	stb	zero,42(r2)
      break;
 823a9f8:	00002206 	br	823aa84 <tcp_usrreq+0x6bc>
   case PRU_SOCKADDR:

   /* sockaddr and peeraddr have to switch based on IP type */
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setsockaddr(inp, nam);
 823a9fc:	e17fff17 	ldw	r5,-4(fp)
 823aa00:	e13ffb17 	ldw	r4,-20(fp)
 823aa04:	82481b40 	call	82481b4 <in_setsockaddr>
         in_setsockaddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setsockaddr(inp, nam);
#endif
      break;         
 823aa08:	00001e06 	br	823aa84 <tcp_usrreq+0x6bc>

   case PRU_PEERADDR:
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setpeeraddr(inp, nam);
 823aa0c:	e17fff17 	ldw	r5,-4(fp)
 823aa10:	e13ffb17 	ldw	r4,-20(fp)
 823aa14:	82482380 	call	8248238 <in_setpeeraddr>
         in_setpeeraddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setpeeraddr(inp, nam);
#endif
      break;
 823aa18:	00001a06 	br	823aa84 <tcp_usrreq+0x6bc>

   case PRU_SLOWTIMO:
      SETTP(tp, tcp_timers(tp, (int)MBUF2LONG(nam)));
 823aa1c:	e0bfff17 	ldw	r2,-4(fp)
 823aa20:	100b883a 	mov	r5,r2
 823aa24:	e13ff817 	ldw	r4,-32(fp)
 823aa28:	8239f480 	call	8239f48 <tcp_timers>
#ifdef DO_TCPTRACE
      req |= (long)nam << 8;        /* for debug's sake */
#endif
      break;
 823aa2c:	00001506 	br	823aa84 <tcp_usrreq+0x6bc>

      default:
      panic("tcp_usrreq");
 823aa30:	01020974 	movhi	r4,2085
 823aa34:	2103cc04 	addi	r4,r4,3888
 823aa38:	8228aec0 	call	8228aec <panic>
 823aa3c:	00001106 	br	823aa84 <tcp_usrreq+0x6bc>
         error = EISCONN;
         break;
      }
      error = tcp_attach(so);
      if (error)
         break;
 823aa40:	0001883a 	nop
 823aa44:	00000f06 	br	823aa84 <tcp_usrreq+0x6bc>
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
         so->so_linger = TCP_LINGERTIME;
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 823aa48:	0001883a 	nop
 823aa4c:	00000d06 	br	823aa84 <tcp_usrreq+0x6bc>
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
         error = in_pcbbind(inp, (struct mbuf *)0);
      if (error == 0)
         tp->t_state = TCPS_LISTEN;
      break;
 823aa50:	0001883a 	nop
 823aa54:	00000b06 	br	823aa84 <tcp_usrreq+0x6bc>
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
            break;
 823aa58:	0001883a 	nop
 823aa5c:	00000906 	br	823aa84 <tcp_usrreq+0x6bc>
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
         break;
 823aa60:	0001883a 	nop
 823aa64:	00000706 	br	823aa84 <tcp_usrreq+0x6bc>
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
      tcp_sendseqinit(tp);
      error = tcp_output(tp);
      if (!error)
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
      break;
 823aa68:	0001883a 	nop
 823aa6c:	00000506 	br	823aa84 <tcp_usrreq+0x6bc>
   case PRU_SHUTDOWN:
      socantsendmore(so);
      tp = tcp_usrclosed(tp);
      if (tp)
         error = tcp_output(tp);
      break;
 823aa70:	0001883a 	nop
 823aa74:	00000306 	br	823aa84 <tcp_usrreq+0x6bc>
      }
      sbappend(&so->so_snd, m);
      error = tcp_output(tp);
      if (error == ENOBUFS)
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
      break;
 823aa78:	0001883a 	nop
 823aa7c:	00000106 	br	823aa84 <tcp_usrreq+0x6bc>
      }
      m->m_len = 1;
      *mtod(m, char *) = tp->t_iobc;
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
      break;
 823aa80:	0001883a 	nop
#ifdef DO_TCPTRACE
   if (tp && (so->so_options & SO_DEBUG))
      tcp_trace("usrreq: state: %d, tcpcb: %x, req: %d",
    ostate, tp, req);
#endif
   return (error);
 823aa84:	e0bff917 	ldw	r2,-28(fp)
}
 823aa88:	e037883a 	mov	sp,fp
 823aa8c:	dfc00117 	ldw	ra,4(sp)
 823aa90:	df000017 	ldw	fp,0(sp)
 823aa94:	dec00204 	addi	sp,sp,8
 823aa98:	f800283a 	ret

0823aa9c <tcp_attach>:
 * RETURNS: 0 if OK, or nonzero error code.
 */

int
tcp_attach(struct socket * so)
{
 823aa9c:	defff904 	addi	sp,sp,-28
 823aaa0:	dfc00615 	stw	ra,24(sp)
 823aaa4:	df000515 	stw	fp,20(sp)
 823aaa8:	df000504 	addi	fp,sp,20
 823aaac:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
   struct inpcb * inp;
   int   error;

   if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) 
 823aab0:	e0bfff17 	ldw	r2,-4(fp)
 823aab4:	10801317 	ldw	r2,76(r2)
 823aab8:	10000326 	beq	r2,zero,823aac8 <tcp_attach+0x2c>
 823aabc:	e0bfff17 	ldw	r2,-4(fp)
 823aac0:	10800b17 	ldw	r2,44(r2)
 823aac4:	10000b1e 	bne	r2,zero,823aaf4 <tcp_attach+0x58>
   {
      error = soreserve(so, tcp_sendspace, tcp_recvspace);
 823aac8:	d0a04017 	ldw	r2,-32512(gp)
 823aacc:	d0e04117 	ldw	r3,-32508(gp)
 823aad0:	180d883a 	mov	r6,r3
 823aad4:	100b883a 	mov	r5,r2
 823aad8:	e13fff17 	ldw	r4,-4(fp)
 823aadc:	82341500 	call	8234150 <soreserve>
 823aae0:	e0bffb15 	stw	r2,-20(fp)
      if (error)
 823aae4:	e0bffb17 	ldw	r2,-20(fp)
 823aae8:	10000226 	beq	r2,zero,823aaf4 <tcp_attach+0x58>
         return (error);
 823aaec:	e0bffb17 	ldw	r2,-20(fp)
 823aaf0:	00002b06 	br	823aba0 <tcp_attach+0x104>
   }
   error = in_pcballoc(so, &tcb);
 823aaf4:	014209b4 	movhi	r5,2086
 823aaf8:	29798904 	addi	r5,r5,-6620
 823aafc:	e13fff17 	ldw	r4,-4(fp)
 823ab00:	8247c880 	call	8247c88 <in_pcballoc>
 823ab04:	e0bffb15 	stw	r2,-20(fp)
   if (error)
 823ab08:	e0bffb17 	ldw	r2,-20(fp)
 823ab0c:	10000226 	beq	r2,zero,823ab18 <tcp_attach+0x7c>
      return (error);
 823ab10:	e0bffb17 	ldw	r2,-20(fp)
 823ab14:	00002206 	br	823aba0 <tcp_attach+0x104>
   inp = sotoinpcb(so);
 823ab18:	e0bfff17 	ldw	r2,-4(fp)
 823ab1c:	10800117 	ldw	r2,4(r2)
 823ab20:	e0bffc15 	stw	r2,-16(fp)
   tp = tcp_newtcpcb(inp);
 823ab24:	e13ffc17 	ldw	r4,-16(fp)
 823ab28:	82398980 	call	8239898 <tcp_newtcpcb>
 823ab2c:	e0bffd15 	stw	r2,-12(fp)
   if (tp == 0) 
 823ab30:	e0bffd17 	ldw	r2,-12(fp)
 823ab34:	1000171e 	bne	r2,zero,823ab94 <tcp_attach+0xf8>
   {
      int   nofd  =  so->so_state   &  SS_NOFDREF; /* XXX */
 823ab38:	e0bfff17 	ldw	r2,-4(fp)
 823ab3c:	1080088b 	ldhu	r2,34(r2)
 823ab40:	10bfffcc 	andi	r2,r2,65535
 823ab44:	1080004c 	andi	r2,r2,1
 823ab48:	e0bffe15 	stw	r2,-8(fp)

      so->so_state &= ~SS_NOFDREF;     /* don't free the socket yet */
 823ab4c:	e0bfff17 	ldw	r2,-4(fp)
 823ab50:	10c0088b 	ldhu	r3,34(r2)
 823ab54:	00bfff84 	movi	r2,-2
 823ab58:	1884703a 	and	r2,r3,r2
 823ab5c:	1007883a 	mov	r3,r2
 823ab60:	e0bfff17 	ldw	r2,-4(fp)
 823ab64:	10c0088d 	sth	r3,34(r2)
      in_pcbdetach(inp);
 823ab68:	e13ffc17 	ldw	r4,-16(fp)
 823ab6c:	8247d100 	call	8247d10 <in_pcbdetach>
      so->so_state |= nofd;
 823ab70:	e0bfff17 	ldw	r2,-4(fp)
 823ab74:	1080088b 	ldhu	r2,34(r2)
 823ab78:	e0fffe17 	ldw	r3,-8(fp)
 823ab7c:	10c4b03a 	or	r2,r2,r3
 823ab80:	1007883a 	mov	r3,r2
 823ab84:	e0bfff17 	ldw	r2,-4(fp)
 823ab88:	10c0088d 	sth	r3,34(r2)
      return (ENOBUFS);
 823ab8c:	00801a44 	movi	r2,105
 823ab90:	00000306 	br	823aba0 <tcp_attach+0x104>
   }
   tp->t_state = TCPS_CLOSED;
 823ab94:	e0bffd17 	ldw	r2,-12(fp)
 823ab98:	10000215 	stw	zero,8(r2)
   return (0);
 823ab9c:	0005883a 	mov	r2,zero
}
 823aba0:	e037883a 	mov	sp,fp
 823aba4:	dfc00117 	ldw	ra,4(sp)
 823aba8:	df000017 	ldw	fp,0(sp)
 823abac:	dec00204 	addi	sp,sp,8
 823abb0:	f800283a 	ret

0823abb4 <tcp_disconnect>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_disconnect(struct tcpcb * tp)
{
 823abb4:	defffc04 	addi	sp,sp,-16
 823abb8:	dfc00315 	stw	ra,12(sp)
 823abbc:	df000215 	stw	fp,8(sp)
 823abc0:	df000204 	addi	fp,sp,8
 823abc4:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 823abc8:	e0bfff17 	ldw	r2,-4(fp)
 823abcc:	10800d17 	ldw	r2,52(r2)
 823abd0:	10800817 	ldw	r2,32(r2)
 823abd4:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_state < TCPS_ESTABLISHED)
 823abd8:	e0bfff17 	ldw	r2,-4(fp)
 823abdc:	10800217 	ldw	r2,8(r2)
 823abe0:	10800108 	cmpgei	r2,r2,4
 823abe4:	1000041e 	bne	r2,zero,823abf8 <tcp_disconnect+0x44>
      tp = tcp_close(tp);
 823abe8:	e13fff17 	ldw	r4,-4(fp)
 823abec:	8239a500 	call	8239a50 <tcp_close>
 823abf0:	e0bfff15 	stw	r2,-4(fp)
 823abf4:	00001c06 	br	823ac68 <tcp_disconnect+0xb4>
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 823abf8:	e0bffe17 	ldw	r2,-8(fp)
 823abfc:	10800417 	ldw	r2,16(r2)
 823ac00:	1080200c 	andi	r2,r2,128
 823ac04:	10000b26 	beq	r2,zero,823ac34 <tcp_disconnect+0x80>
 823ac08:	e0bffe17 	ldw	r2,-8(fp)
 823ac0c:	1080080b 	ldhu	r2,32(r2)
 823ac10:	10bfffcc 	andi	r2,r2,65535
 823ac14:	10a0001c 	xori	r2,r2,32768
 823ac18:	10a00004 	addi	r2,r2,-32768
 823ac1c:	1000051e 	bne	r2,zero,823ac34 <tcp_disconnect+0x80>
      tp = tcp_drop(tp, 0);
 823ac20:	000b883a 	mov	r5,zero
 823ac24:	e13fff17 	ldw	r4,-4(fp)
 823ac28:	82399a40 	call	82399a4 <tcp_drop>
 823ac2c:	e0bfff15 	stw	r2,-4(fp)
 823ac30:	00000d06 	br	823ac68 <tcp_disconnect+0xb4>
   else 
   {
      soisdisconnecting(so);
 823ac34:	e13ffe17 	ldw	r4,-8(fp)
 823ac38:	8233a5c0 	call	8233a5c <soisdisconnecting>
      sbflush(&so->so_rcv);
 823ac3c:	e0bffe17 	ldw	r2,-8(fp)
 823ac40:	10800a04 	addi	r2,r2,40
 823ac44:	1009883a 	mov	r4,r2
 823ac48:	82347a80 	call	82347a8 <sbflush>
      tp = tcp_usrclosed(tp);
 823ac4c:	e13fff17 	ldw	r4,-4(fp)
 823ac50:	823ac800 	call	823ac80 <tcp_usrclosed>
 823ac54:	e0bfff15 	stw	r2,-4(fp)
      if (tp)
 823ac58:	e0bfff17 	ldw	r2,-4(fp)
 823ac5c:	10000226 	beq	r2,zero,823ac68 <tcp_disconnect+0xb4>
         (void) tcp_output(tp);
 823ac60:	e13fff17 	ldw	r4,-4(fp)
 823ac64:	82381700 	call	8238170 <tcp_output>
   }
   return (tp);
 823ac68:	e0bfff17 	ldw	r2,-4(fp)
}
 823ac6c:	e037883a 	mov	sp,fp
 823ac70:	dfc00117 	ldw	ra,4(sp)
 823ac74:	df000017 	ldw	fp,0(sp)
 823ac78:	dec00204 	addi	sp,sp,8
 823ac7c:	f800283a 	ret

0823ac80 <tcp_usrclosed>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_usrclosed(struct tcpcb * tp)
{
 823ac80:	defffd04 	addi	sp,sp,-12
 823ac84:	dfc00215 	stw	ra,8(sp)
 823ac88:	df000115 	stw	fp,4(sp)
 823ac8c:	df000104 	addi	fp,sp,4
 823ac90:	e13fff15 	stw	r4,-4(fp)

   switch (tp->t_state) 
 823ac94:	e0bfff17 	ldw	r2,-4(fp)
 823ac98:	10800217 	ldw	r2,8(r2)
 823ac9c:	10c001a8 	cmpgeui	r3,r2,6
 823aca0:	18001a1e 	bne	r3,zero,823ad0c <tcp_usrclosed+0x8c>
 823aca4:	100690ba 	slli	r3,r2,2
 823aca8:	00820934 	movhi	r2,2084
 823acac:	10ab2f04 	addi	r2,r2,-21316
 823acb0:	1885883a 	add	r2,r3,r2
 823acb4:	10800017 	ldw	r2,0(r2)
 823acb8:	1000683a 	jmp	r2
 823acbc:	0823acd4 	ori	zero,at,36531
 823acc0:	0823acd4 	ori	zero,at,36531
 823acc4:	0823acd4 	ori	zero,at,36531
 823acc8:	0823acec 	andhi	zero,at,36531
 823accc:	0823acec 	andhi	zero,at,36531
 823acd0:	0823acfc 	xorhi	zero,at,36531
   {
   case TCPS_CLOSED:
   case TCPS_LISTEN:
   case TCPS_SYN_SENT:
      tp->t_state = TCPS_CLOSED;
 823acd4:	e0bfff17 	ldw	r2,-4(fp)
 823acd8:	10000215 	stw	zero,8(r2)
      tp = tcp_close(tp);
 823acdc:	e13fff17 	ldw	r4,-4(fp)
 823ace0:	8239a500 	call	8239a50 <tcp_close>
 823ace4:	e0bfff15 	stw	r2,-4(fp)
      break;
 823ace8:	00000806 	br	823ad0c <tcp_usrclosed+0x8c>

   case TCPS_SYN_RECEIVED:
   case TCPS_ESTABLISHED:
      tp->t_state = TCPS_FIN_WAIT_1;
 823acec:	e0bfff17 	ldw	r2,-4(fp)
 823acf0:	00c00184 	movi	r3,6
 823acf4:	10c00215 	stw	r3,8(r2)
      break;
 823acf8:	00000406 	br	823ad0c <tcp_usrclosed+0x8c>

   case TCPS_CLOSE_WAIT:
      tp->t_state = TCPS_LAST_ACK;
 823acfc:	e0bfff17 	ldw	r2,-4(fp)
 823ad00:	00c00204 	movi	r3,8
 823ad04:	10c00215 	stw	r3,8(r2)
      break;
 823ad08:	0001883a 	nop
   }
   if (tp && tp->t_state >= TCPS_FIN_WAIT_2)
 823ad0c:	e0bfff17 	ldw	r2,-4(fp)
 823ad10:	10000926 	beq	r2,zero,823ad38 <tcp_usrclosed+0xb8>
 823ad14:	e0bfff17 	ldw	r2,-4(fp)
 823ad18:	10800217 	ldw	r2,8(r2)
 823ad1c:	10800250 	cmplti	r2,r2,9
 823ad20:	1000051e 	bne	r2,zero,823ad38 <tcp_usrclosed+0xb8>
      soisdisconnected(tp->t_inpcb->inp_socket);
 823ad24:	e0bfff17 	ldw	r2,-4(fp)
 823ad28:	10800d17 	ldw	r2,52(r2)
 823ad2c:	10800817 	ldw	r2,32(r2)
 823ad30:	1009883a 	mov	r4,r2
 823ad34:	8233af40 	call	8233af4 <soisdisconnected>
   return (tp);
 823ad38:	e0bfff17 	ldw	r2,-4(fp)
}
 823ad3c:	e037883a 	mov	sp,fp
 823ad40:	dfc00117 	ldw	ra,4(sp)
 823ad44:	df000017 	ldw	fp,0(sp)
 823ad48:	dec00204 	addi	sp,sp,8
 823ad4c:	f800283a 	ret

0823ad50 <tcpinit>:
 * RETURNS: 0 if OK, else one of the ENP_ error codes
 */

int
tcpinit(void)
{
 823ad50:	defffd04 	addi	sp,sp,-12
 823ad54:	dfc00215 	stw	ra,8(sp)
 823ad58:	df000115 	stw	fp,4(sp)
 823ad5c:	df000104 	addi	fp,sp,4
   tcp_sendspace = (TCP_MSS) * 2;
   tcp_recvspace = (TCP_MSS) * 2;
   TCPTV_MSL =    (4 * PR_SLOWHZ);     /* max seg lifetime default */
#endif

   e = nptcp_init();    /* call the NetPort init in nptcp.c */
 823ad60:	822eb8c0 	call	822eb8c <nptcp_init>
 823ad64:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 823ad68:	e0bfff17 	ldw	r2,-4(fp)
 823ad6c:	10000226 	beq	r2,zero,823ad78 <tcpinit+0x28>
      return e;
 823ad70:	e0bfff17 	ldw	r2,-4(fp)
 823ad74:	00000106 	br	823ad7c <tcpinit+0x2c>

   return 0;   /* good return */
 823ad78:	0005883a 	mov	r2,zero
}
 823ad7c:	e037883a 	mov	sp,fp
 823ad80:	dfc00117 	ldw	ra,4(sp)
 823ad84:	df000017 	ldw	fp,0(sp)
 823ad88:	dec00204 	addi	sp,sp,8
 823ad8c:	f800283a 	ret

0823ad90 <udp_lookup>:
 * RETURNS: 
 */

UDPCONN
udp_lookup(struct socket * so)
{
 823ad90:	defffd04 	addi	sp,sp,-12
 823ad94:	df000215 	stw	fp,8(sp)
 823ad98:	df000204 	addi	fp,sp,8
 823ad9c:	e13fff15 	stw	r4,-4(fp)
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 823ada0:	d0a09c17 	ldw	r2,-32144(gp)
 823ada4:	e0bffe15 	stw	r2,-8(fp)
 823ada8:	00000906 	br	823add0 <udp_lookup+0x40>
      if (tmp->u_data == (void*)so)
 823adac:	e0bffe17 	ldw	r2,-8(fp)
 823adb0:	10c00617 	ldw	r3,24(r2)
 823adb4:	e0bfff17 	ldw	r2,-4(fp)
 823adb8:	1880021e 	bne	r3,r2,823adc4 <udp_lookup+0x34>
      return (tmp);
 823adbc:	e0bffe17 	ldw	r2,-8(fp)
 823adc0:	00000606 	br	823addc <udp_lookup+0x4c>
UDPCONN
udp_lookup(struct socket * so)
{
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 823adc4:	e0bffe17 	ldw	r2,-8(fp)
 823adc8:	10800017 	ldw	r2,0(r2)
 823adcc:	e0bffe15 	stw	r2,-8(fp)
 823add0:	e0bffe17 	ldw	r2,-8(fp)
 823add4:	103ff51e 	bne	r2,zero,823adac <udp_lookup+0x1c>
      if (tmp->u_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 823add8:	0005883a 	mov	r2,zero
}
 823addc:	e037883a 	mov	sp,fp
 823ade0:	df000017 	ldw	fp,0(sp)
 823ade4:	dec00104 	addi	sp,sp,4
 823ade8:	f800283a 	ret

0823adec <udp_soinput>:
 * RETURNS: 
 */

int
udp_soinput(PACKET pkt, void * so_ptr)
{
 823adec:	defff504 	addi	sp,sp,-44
 823adf0:	dfc00a15 	stw	ra,40(sp)
 823adf4:	df000915 	stw	fp,36(sp)
 823adf8:	df000904 	addi	fp,sp,36
 823adfc:	e13ffe15 	stw	r4,-8(fp)
 823ae00:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 823ae04:	e0bfff17 	ldw	r2,-4(fp)
 823ae08:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;
   struct udp *   udpp;

   LOCK_NET_RESOURCE(NET_RESID); 
 823ae0c:	0009883a 	mov	r4,zero
 823ae10:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 823ae14:	e0bff717 	ldw	r2,-36(fp)
 823ae18:	10c00a17 	ldw	r3,40(r2)
 823ae1c:	e0bffe17 	ldw	r2,-8(fp)
 823ae20:	10800417 	ldw	r2,16(r2)
 823ae24:	1887883a 	add	r3,r3,r2
 823ae28:	e0bff717 	ldw	r2,-36(fp)
 823ae2c:	10800b17 	ldw	r2,44(r2)
 823ae30:	18800436 	bltu	r3,r2,823ae44 <udp_soinput+0x58>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 823ae34:	0009883a 	mov	r4,zero
 823ae38:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 823ae3c:	00801a44 	movi	r2,105
 823ae40:	00004d06 	br	823af78 <udp_soinput+0x18c>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 823ae44:	000b883a 	mov	r5,zero
 823ae48:	01000044 	movi	r4,1
 823ae4c:	822e2280 	call	822e228 <m_getnbuf>
 823ae50:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 823ae54:	e0bff817 	ldw	r2,-32(fp)
 823ae58:	1000041e 	bne	r2,zero,823ae6c <udp_soinput+0x80>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 823ae5c:	0009883a 	mov	r4,zero
 823ae60:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 823ae64:	00801a44 	movi	r2,105
 823ae68:	00004306 	br	823af78 <udp_soinput+0x18c>
   }

   /* set data mbuf to point to start of UDP data */
   m_in->pkt = pkt;
 823ae6c:	e0bff817 	ldw	r2,-32(fp)
 823ae70:	e0fffe17 	ldw	r3,-8(fp)
 823ae74:	10c00115 	stw	r3,4(r2)
   m_in->m_data = pkt->nb_prot;
 823ae78:	e0bffe17 	ldw	r2,-8(fp)
 823ae7c:	10c00317 	ldw	r3,12(r2)
 823ae80:	e0bff817 	ldw	r2,-32(fp)
 823ae84:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 823ae88:	e0bffe17 	ldw	r2,-8(fp)
 823ae8c:	10c00417 	ldw	r3,16(r2)
 823ae90:	e0bff817 	ldw	r2,-32(fp)
 823ae94:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;
 823ae98:	e0bffe17 	ldw	r2,-8(fp)
 823ae9c:	10c00117 	ldw	r3,4(r2)
 823aea0:	e0bff817 	ldw	r2,-32(fp)
 823aea4:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 823aea8:	e0bffe17 	ldw	r2,-8(fp)
 823aeac:	10c00217 	ldw	r3,8(r2)
 823aeb0:	e0bff817 	ldw	r2,-32(fp)
 823aeb4:	10c00515 	stw	r3,20(r2)

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 823aeb8:	e0bffe17 	ldw	r2,-8(fp)
 823aebc:	10800717 	ldw	r2,28(r2)
 823aec0:	e0bffb15 	stw	r2,-20(fp)
   udpp = (struct udp *)(pkt->nb_prot - sizeof(struct udp));
 823aec4:	e0bffe17 	ldw	r2,-8(fp)
 823aec8:	10800317 	ldw	r2,12(r2)
 823aecc:	10bffe04 	addi	r2,r2,-8
 823aed0:	e0bff915 	stw	r2,-28(fp)
   sin.sin_port = htons(udpp->ud_srcp);
 823aed4:	e0bff917 	ldw	r2,-28(fp)
 823aed8:	1080000b 	ldhu	r2,0(r2)
 823aedc:	10bfffcc 	andi	r2,r2,65535
 823aee0:	1004d23a 	srli	r2,r2,8
 823aee4:	1007883a 	mov	r3,r2
 823aee8:	e0bff917 	ldw	r2,-28(fp)
 823aeec:	1080000b 	ldhu	r2,0(r2)
 823aef0:	10bfffcc 	andi	r2,r2,65535
 823aef4:	1004923a 	slli	r2,r2,8
 823aef8:	1884b03a 	or	r2,r3,r2
 823aefc:	e0bffa8d 	sth	r2,-22(fp)
   sin.sin_family = AF_INET;
 823af00:	00800084 	movi	r2,2
 823af04:	e0bffa0d 	sth	r2,-24(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 823af08:	e0bff717 	ldw	r2,-36(fp)
 823af0c:	10800a04 	addi	r2,r2,40
 823af10:	e0fffa04 	addi	r3,fp,-24
 823af14:	e1bff817 	ldw	r6,-32(fp)
 823af18:	180b883a 	mov	r5,r3
 823af1c:	1009883a 	mov	r4,r2
 823af20:	82343ec0 	call	82343ec <sbappendaddr>
 823af24:	1000081e 	bne	r2,zero,823af48 <udp_soinput+0x15c>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       */
      m_in->pkt = NULL;
 823af28:	e0bff817 	ldw	r2,-32(fp)
 823af2c:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 823af30:	e13ff817 	ldw	r4,-32(fp)
 823af34:	822e3b00 	call	822e3b0 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 823af38:	0009883a 	mov	r4,zero
 823af3c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 823af40:	00801a44 	movi	r2,105
 823af44:	00000c06 	br	823af78 <udp_soinput+0x18c>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 823af48:	e0bff717 	ldw	r2,-36(fp)
 823af4c:	10800a04 	addi	r2,r2,40
 823af50:	1009883a 	mov	r4,r2
 823af54:	822954c0 	call	822954c <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 823af58:	e0bff717 	ldw	r2,-36(fp)
 823af5c:	10800a04 	addi	r2,r2,40
 823af60:	100b883a 	mov	r5,r2
 823af64:	e13ff717 	ldw	r4,-36(fp)
 823af68:	82340c40 	call	82340c4 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 823af6c:	0009883a 	mov	r4,zero
 823af70:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   return 0;
 823af74:	0005883a 	mov	r2,zero
}
 823af78:	e037883a 	mov	sp,fp
 823af7c:	dfc00117 	ldw	ra,4(sp)
 823af80:	df000017 	ldw	fp,0(sp)
 823af84:	dec00204 	addi	sp,sp,8
 823af88:	f800283a 	ret

0823af8c <udp_usrreq>:

int
udp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 823af8c:	defff804 	addi	sp,sp,-32
 823af90:	dfc00715 	stw	ra,28(sp)
 823af94:	df000615 	stw	fp,24(sp)
 823af98:	df000604 	addi	fp,sp,24
 823af9c:	e13ffd15 	stw	r4,-12(fp)
 823afa0:	e17ffe15 	stw	r5,-8(fp)
 823afa4:	e1bfff15 	stw	r6,-4(fp)
   UDPCONN udpconn = (UDPCONN)NULL;
 823afa8:	e03ffb15 	stw	zero,-20(fp)
   int   req;

   req = so->so_req;    /* get request from socket struct */
 823afac:	e0bffd17 	ldw	r2,-12(fp)
 823afb0:	10800717 	ldw	r2,28(r2)
 823afb4:	e0bffc15 	stw	r2,-16(fp)

   switch (req) 
 823afb8:	e0bffc17 	ldw	r2,-16(fp)
 823afbc:	10800468 	cmpgeui	r2,r2,17
 823afc0:	10007b1e 	bne	r2,zero,823b1b0 <udp_usrreq+0x224>
 823afc4:	e0bffc17 	ldw	r2,-16(fp)
 823afc8:	100690ba 	slli	r3,r2,2
 823afcc:	00820934 	movhi	r2,2084
 823afd0:	10abf804 	addi	r2,r2,-20512
 823afd4:	1885883a 	add	r2,r3,r2
 823afd8:	10800017 	ldw	r2,0(r2)
 823afdc:	1000683a 	jmp	r2
 823afe0:	0823b024 	muli	zero,at,-28992
 823afe4:	0823b0a8 	cmpgeui	zero,at,36546
 823afe8:	0823b0e4 	muli	zero,at,-28989
 823afec:	0823b1b0 	cmpltui	zero,at,36550
 823aff0:	0823b0e4 	muli	zero,at,-28989
 823aff4:	0823b1b0 	cmpltui	zero,at,36550
 823aff8:	0823b1a4 	muli	zero,at,-28986
 823affc:	0823b1b0 	cmpltui	zero,at,36550
 823b000:	0823b1a4 	muli	zero,at,-28986
 823b004:	0823b124 	muli	zero,at,-28988
 823b008:	0823b1b0 	cmpltui	zero,at,36550
 823b00c:	0823b1b0 	cmpltui	zero,at,36550
 823b010:	0823b1b0 	cmpltui	zero,at,36550
 823b014:	0823b1b0 	cmpltui	zero,at,36550
 823b018:	0823b1b0 	cmpltui	zero,at,36550
 823b01c:	0823b164 	muli	zero,at,-28987
 823b020:	0823b164 	muli	zero,at,-28987
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = udp_maxalloc();
 823b024:	82452f40 	call	82452f4 <udp_maxalloc>
 823b028:	1007883a 	mov	r3,r2
 823b02c:	e0bffd17 	ldw	r2,-12(fp)
 823b030:	10c01315 	stw	r3,76(r2)
 823b034:	e0bffd17 	ldw	r2,-12(fp)
 823b038:	10c01317 	ldw	r3,76(r2)
 823b03c:	e0bffd17 	ldw	r2,-12(fp)
 823b040:	10c00b15 	stw	r3,44(r2)

#ifdef IP_V4
      /* make a NetPort UDP connection */
      /* unlock the net resource; UDP will immediatly re-lock it */
      if (so->so_domain  == AF_INET){
 823b044:	e0bffd17 	ldw	r2,-12(fp)
 823b048:	10800517 	ldw	r2,20(r2)
 823b04c:	10800098 	cmpnei	r2,r2,2
 823b050:	10000f1e 	bne	r2,zero,823b090 <udp_usrreq+0x104>
        UNLOCK_NET_RESOURCE(NET_RESID);
 823b054:	0009883a 	mov	r4,zero
 823b058:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
        udpconn = udp_open(0L, 0, udp_socket(), udp_soinput, so);
 823b05c:	82451880 	call	8245188 <udp_socket>
 823b060:	10ffffcc 	andi	r3,r2,65535
 823b064:	e0bffd17 	ldw	r2,-12(fp)
 823b068:	d8800015 	stw	r2,0(sp)
 823b06c:	01c20934 	movhi	r7,2084
 823b070:	39eb7b04 	addi	r7,r7,-21012
 823b074:	180d883a 	mov	r6,r3
 823b078:	000b883a 	mov	r5,zero
 823b07c:	0009883a 	mov	r4,zero
 823b080:	822cfac0 	call	822cfac <udp_open>
 823b084:	e0bffb15 	stw	r2,-20(fp)
        LOCK_NET_RESOURCE(NET_RESID);
 823b088:	0009883a 	mov	r4,zero
 823b08c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
        UNLOCK_NET_RESOURCE(NET_RESID);
        udpconn = udp6_open(0L, 0, udp_socket(), udp6_soinput, so);
        LOCK_NET_RESOURCE(NET_RESID);
      }
#endif
      if (!udpconn)
 823b090:	e0bffb17 	ldw	r2,-20(fp)
 823b094:	1000021e 	bne	r2,zero,823b0a0 <udp_usrreq+0x114>
         return(EINVAL);
 823b098:	00800584 	movi	r2,22
 823b09c:	00004506 	br	823b1b4 <udp_usrreq+0x228>
      return 0;
 823b0a0:	0005883a 	mov	r2,zero
 823b0a4:	00004306 	br	823b1b4 <udp_usrreq+0x228>
   case PRU_DETACH:
      /* delete the NetPort UDP connection */
      udpconn = udp_lookup(so);
 823b0a8:	e13ffd17 	ldw	r4,-12(fp)
 823b0ac:	823ad900 	call	823ad90 <udp_lookup>
 823b0b0:	e0bffb15 	stw	r2,-20(fp)
      if (!udpconn)
 823b0b4:	e0bffb17 	ldw	r2,-20(fp)
 823b0b8:	1000021e 	bne	r2,zero,823b0c4 <udp_usrreq+0x138>
         return(EINVAL);
 823b0bc:	00800584 	movi	r2,22
 823b0c0:	00003c06 	br	823b1b4 <udp_usrreq+0x228>
      /* unlock the net resource; UDP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 823b0c4:	0009883a 	mov	r4,zero
 823b0c8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      udp_close(udpconn);
 823b0cc:	e13ffb17 	ldw	r4,-20(fp)
 823b0d0:	822d1a80 	call	822d1a8 <udp_close>
      LOCK_NET_RESOURCE(NET_RESID);
 823b0d4:	0009883a 	mov	r4,zero
 823b0d8:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      return 0;
 823b0dc:	0005883a 	mov	r2,zero
 823b0e0:	00003406 	br	823b1b4 <udp_usrreq+0x228>
   case PRU_CONNECT:
      /* Install foreign port for UDP, making a virtual connection */
      /* fall to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 823b0e4:	e0bfff17 	ldw	r2,-4(fp)
 823b0e8:	1000021e 	bne	r2,zero,823b0f4 <udp_usrreq+0x168>
         return(EINVAL);
 823b0ec:	00800584 	movi	r2,22
 823b0f0:	00003006 	br	823b1b4 <udp_usrreq+0x228>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 823b0f4:	e0bffd17 	ldw	r2,-12(fp)
 823b0f8:	10800517 	ldw	r2,20(r2)
 823b0fc:	10800098 	cmpnei	r2,r2,2
 823b100:	1000051e 	bne	r2,zero,823b118 <udp_usrreq+0x18c>
        return udp4_sockbind(so, nam, req );
 823b104:	e1bffc17 	ldw	r6,-16(fp)
 823b108:	e17fff17 	ldw	r5,-4(fp)
 823b10c:	e13ffd17 	ldw	r4,-12(fp)
 823b110:	823b1c80 	call	823b1c8 <udp4_sockbind>
 823b114:	00002706 	br	823b1b4 <udp_usrreq+0x228>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockbind(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 823b118:	822d4140 	call	822d414 <dtrap>
      return EINVAL;
 823b11c:	00800584 	movi	r2,22
 823b120:	00002406 	br	823b1b4 <udp_usrreq+0x228>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 823b124:	e0bffe17 	ldw	r2,-8(fp)
 823b128:	1000021e 	bne	r2,zero,823b134 <udp_usrreq+0x1a8>
         return(EINVAL);
 823b12c:	00800584 	movi	r2,22
 823b130:	00002006 	br	823b1b4 <udp_usrreq+0x228>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 823b134:	e0bffd17 	ldw	r2,-12(fp)
 823b138:	10800517 	ldw	r2,20(r2)
 823b13c:	10800098 	cmpnei	r2,r2,2
 823b140:	1000051e 	bne	r2,zero,823b158 <udp_usrreq+0x1cc>
        return udp4_socksend(so, m, nam );
 823b144:	e1bfff17 	ldw	r6,-4(fp)
 823b148:	e17ffe17 	ldw	r5,-8(fp)
 823b14c:	e13ffd17 	ldw	r4,-12(fp)
 823b150:	823b49c0 	call	823b49c <udp4_socksend>
 823b154:	00001706 	br	823b1b4 <udp_usrreq+0x228>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_socksend(so, m, nam);
      }
#endif
      dtrap();   /* invalid address */
 823b158:	822d4140 	call	822d414 <dtrap>
      return EINVAL;
 823b15c:	00800584 	movi	r2,22
 823b160:	00001406 	br	823b1b4 <udp_usrreq+0x228>

   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 823b164:	e0bfff17 	ldw	r2,-4(fp)
 823b168:	1000021e 	bne	r2,zero,823b174 <udp_usrreq+0x1e8>
         return(EINVAL);
 823b16c:	00800584 	movi	r2,22
 823b170:	00001006 	br	823b1b4 <udp_usrreq+0x228>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 823b174:	e0bffd17 	ldw	r2,-12(fp)
 823b178:	10800517 	ldw	r2,20(r2)
 823b17c:	10800098 	cmpnei	r2,r2,2
 823b180:	1000051e 	bne	r2,zero,823b198 <udp_usrreq+0x20c>
        return udp4_sockaddr(so, nam, req );
 823b184:	e1bffc17 	ldw	r6,-16(fp)
 823b188:	e17fff17 	ldw	r5,-4(fp)
 823b18c:	e13ffd17 	ldw	r4,-12(fp)
 823b190:	823b81c0 	call	823b81c <udp4_sockaddr>
 823b194:	00000706 	br	823b1b4 <udp_usrreq+0x228>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockaddr(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 823b198:	822d4140 	call	822d414 <dtrap>
      return EINVAL;
 823b19c:	00800584 	movi	r2,22
 823b1a0:	00000406 	br	823b1b4 <udp_usrreq+0x228>

   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 823b1a4:	822d4140 	call	822d414 <dtrap>
      return 0;
 823b1a8:	0005883a 	mov	r2,zero
 823b1ac:	00000106 	br	823b1b4 <udp_usrreq+0x228>
   case PRU_LISTEN:     /* don't support these for UDP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 823b1b0:	008017c4 	movi	r2,95
   }
}
 823b1b4:	e037883a 	mov	sp,fp
 823b1b8:	dfc00117 	ldw	ra,4(sp)
 823b1bc:	df000017 	ldw	fp,0(sp)
 823b1c0:	dec00204 	addi	sp,sp,8
 823b1c4:	f800283a 	ret

0823b1c8 <udp4_sockbind>:

#ifdef IP_V4
int udp4_sockbind(struct socket *so, struct mbuf *nam, int req ) 
{
 823b1c8:	defff304 	addi	sp,sp,-52
 823b1cc:	dfc00c15 	stw	ra,48(sp)
 823b1d0:	df000b15 	stw	fp,44(sp)
 823b1d4:	df000b04 	addi	fp,sp,44
 823b1d8:	e13ffd15 	stw	r4,-12(fp)
 823b1dc:	e17ffe15 	stw	r5,-8(fp)
 823b1e0:	e1bfff15 	stw	r6,-4(fp)
  u_short  lport;   /* local port (local byte order) */
  ip_addr fhost; /* host to send to/recv from (network byte order) */
  ip_addr lhost; /* local IP address to bind to (network byte order) */
  NET ifp;

  sin = mtod(nam, struct sockaddr_in *);
 823b1e4:	e0bffe17 	ldw	r2,-8(fp)
 823b1e8:	10800317 	ldw	r2,12(r2)
 823b1ec:	e0bffa15 	stw	r2,-24(fp)
  if (sin == NULL)
 823b1f0:	e0bffa17 	ldw	r2,-24(fp)
 823b1f4:	1000021e 	bne	r2,zero,823b200 <udp4_sockbind+0x38>
    return(EINVAL);
 823b1f8:	00800584 	movi	r2,22
 823b1fc:	0000a206 	br	823b488 <udp4_sockbind+0x2c0>
  if (nam->m_len != sizeof (*sin))
 823b200:	e0bffe17 	ldw	r2,-8(fp)
 823b204:	10800217 	ldw	r2,8(r2)
 823b208:	10800420 	cmpeqi	r2,r2,16
 823b20c:	1000021e 	bne	r2,zero,823b218 <udp4_sockbind+0x50>
    return(EINVAL);
 823b210:	00800584 	movi	r2,22
 823b214:	00009c06 	br	823b488 <udp4_sockbind+0x2c0>
  udpconn = udp_lookup(so);
 823b218:	e13ffd17 	ldw	r4,-12(fp)
 823b21c:	823ad900 	call	823ad90 <udp_lookup>
 823b220:	e0bffb15 	stw	r2,-20(fp)
  if (!udpconn)
 823b224:	e0bffb17 	ldw	r2,-20(fp)
 823b228:	1000021e 	bne	r2,zero,823b234 <udp4_sockbind+0x6c>
     return(EINVAL);
 823b22c:	00800584 	movi	r2,22
 823b230:	00009506 	br	823b488 <udp4_sockbind+0x2c0>
  if (req == PRU_BIND)
 823b234:	e0bfff17 	ldw	r2,-4(fp)
 823b238:	10800098 	cmpnei	r2,r2,2
 823b23c:	1000531e 	bne	r2,zero,823b38c <udp4_sockbind+0x1c4>
     * if the caller-supplied port is 0, try to get
     * the port from the UDP endpoint, or pick a new
     * unique port; else, use the caller-supplied
     * port
     */
    if (sin->sin_port == 0)
 823b240:	e0bffa17 	ldw	r2,-24(fp)
 823b244:	1080008b 	ldhu	r2,2(r2)
 823b248:	10bfffcc 	andi	r2,r2,65535
 823b24c:	10000b1e 	bne	r2,zero,823b27c <udp4_sockbind+0xb4>
    {
      if (udpconn->u_lport != 0)
 823b250:	e0bffb17 	ldw	r2,-20(fp)
 823b254:	1080018b 	ldhu	r2,6(r2)
 823b258:	10bfffcc 	andi	r2,r2,65535
 823b25c:	10000426 	beq	r2,zero,823b270 <udp4_sockbind+0xa8>
        lport = udpconn->u_lport;
 823b260:	e0bffb17 	ldw	r2,-20(fp)
 823b264:	1080018b 	ldhu	r2,6(r2)
 823b268:	e0bff60d 	sth	r2,-40(fp)
 823b26c:	00000e06 	br	823b2a8 <udp4_sockbind+0xe0>
      else
        lport = udp_socket();
 823b270:	82451880 	call	8245188 <udp_socket>
 823b274:	e0bff60d 	sth	r2,-40(fp)
 823b278:	00000b06 	br	823b2a8 <udp4_sockbind+0xe0>
    }
    else
    {
      lport = ntohs(sin->sin_port);
 823b27c:	e0bffa17 	ldw	r2,-24(fp)
 823b280:	1080008b 	ldhu	r2,2(r2)
 823b284:	10bfffcc 	andi	r2,r2,65535
 823b288:	1004d23a 	srli	r2,r2,8
 823b28c:	1007883a 	mov	r3,r2
 823b290:	e0bffa17 	ldw	r2,-24(fp)
 823b294:	1080008b 	ldhu	r2,2(r2)
 823b298:	10bfffcc 	andi	r2,r2,65535
 823b29c:	1004923a 	slli	r2,r2,8
 823b2a0:	1884b03a 	or	r2,r3,r2
 823b2a4:	e0bff60d 	sth	r2,-40(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * don't bind to a specific address; else, 
     * make sure the caller-supplied address is
     * an interface IP address and if so, bind to that
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 823b2a8:	e0bffa17 	ldw	r2,-24(fp)
 823b2ac:	10800117 	ldw	r2,4(r2)
 823b2b0:	1000021e 	bne	r2,zero,823b2bc <udp4_sockbind+0xf4>
    {
      lhost = 0L;
 823b2b4:	e03ff815 	stw	zero,-32(fp)
 823b2b8:	00001706 	br	823b318 <udp4_sockbind+0x150>
    }
    else
    {
      lhost = sin->sin_addr.s_addr;
 823b2bc:	e0bffa17 	ldw	r2,-24(fp)
 823b2c0:	10800117 	ldw	r2,4(r2)
 823b2c4:	e0bff815 	stw	r2,-32(fp)
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b2c8:	008209b4 	movhi	r2,2086
 823b2cc:	10ba6504 	addi	r2,r2,-5740
 823b2d0:	10800017 	ldw	r2,0(r2)
 823b2d4:	e0bff915 	stw	r2,-28(fp)
 823b2d8:	00000706 	br	823b2f8 <udp4_sockbind+0x130>
        if (ifp->n_ipaddr == lhost)
 823b2dc:	e0bff917 	ldw	r2,-28(fp)
 823b2e0:	10c00a17 	ldw	r3,40(r2)
 823b2e4:	e0bff817 	ldw	r2,-32(fp)
 823b2e8:	18800626 	beq	r3,r2,823b304 <udp4_sockbind+0x13c>
    else
    {
      lhost = sin->sin_addr.s_addr;
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b2ec:	e0bff917 	ldw	r2,-28(fp)
 823b2f0:	10800017 	ldw	r2,0(r2)
 823b2f4:	e0bff915 	stw	r2,-28(fp)
 823b2f8:	e0bff917 	ldw	r2,-28(fp)
 823b2fc:	103ff71e 	bne	r2,zero,823b2dc <udp4_sockbind+0x114>
 823b300:	00000106 	br	823b308 <udp4_sockbind+0x140>
        if (ifp->n_ipaddr == lhost)
          break;
 823b304:	0001883a 	nop
      if (ifp == NULL)
 823b308:	e0bff917 	ldw	r2,-28(fp)
 823b30c:	1000021e 	bne	r2,zero,823b318 <udp4_sockbind+0x150>
        return(EADDRNOTAVAIL);
 823b310:	00801f44 	movi	r2,125
 823b314:	00005c06 	br	823b488 <udp4_sockbind+0x2c0>
    }

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
 823b318:	e0bffd17 	ldw	r2,-12(fp)
 823b31c:	10800417 	ldw	r2,16(r2)
 823b320:	1080010c 	andi	r2,r2,4
 823b324:	1000121e 	bne	r2,zero,823b370 <udp4_sockbind+0x1a8>
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 823b328:	d0a09c17 	ldw	r2,-32144(gp)
 823b32c:	e0bff515 	stw	r2,-44(fp)
 823b330:	00000d06 	br	823b368 <udp4_sockbind+0x1a0>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
 823b334:	e0bff517 	ldw	r2,-44(fp)
 823b338:	1080018b 	ldhu	r2,6(r2)
 823b33c:	10ffffcc 	andi	r3,r2,65535
 823b340:	e0bff60b 	ldhu	r2,-40(fp)
 823b344:	1880051e 	bne	r3,r2,823b35c <udp4_sockbind+0x194>
 823b348:	e0fff517 	ldw	r3,-44(fp)
 823b34c:	e0bffb17 	ldw	r2,-20(fp)
 823b350:	18800226 	beq	r3,r2,823b35c <udp4_sockbind+0x194>
          return(EADDRINUSE);
 823b354:	00801c04 	movi	r2,112
 823b358:	00004b06 	br	823b488 <udp4_sockbind+0x2c0>

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 823b35c:	e0bff517 	ldw	r2,-44(fp)
 823b360:	10800017 	ldw	r2,0(r2)
 823b364:	e0bff515 	stw	r2,-44(fp)
 823b368:	e0bff517 	ldw	r2,-44(fp)
 823b36c:	103ff11e 	bne	r2,zero,823b334 <udp4_sockbind+0x16c>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
          return(EADDRINUSE);
    /* bind the UDP endpoint */
    udpconn->u_lport = lport;
 823b370:	e0bffb17 	ldw	r2,-20(fp)
 823b374:	e0fff60b 	ldhu	r3,-40(fp)
 823b378:	10c0018d 	sth	r3,6(r2)
    udpconn->u_lhost = lhost;
 823b37c:	e0bffb17 	ldw	r2,-20(fp)
 823b380:	e0fff817 	ldw	r3,-32(fp)
 823b384:	10c00315 	stw	r3,12(r2)
 823b388:	00003e06 	br	823b484 <udp4_sockbind+0x2bc>
  else /* PRU_CONNECT */
  {
    /* connect the socket to a remote IP address and
     * UDP port.
     */
    fport = ntohs(sin->sin_port);
 823b38c:	e0bffa17 	ldw	r2,-24(fp)
 823b390:	1080008b 	ldhu	r2,2(r2)
 823b394:	10bfffcc 	andi	r2,r2,65535
 823b398:	1004d23a 	srli	r2,r2,8
 823b39c:	1007883a 	mov	r3,r2
 823b3a0:	e0bffa17 	ldw	r2,-24(fp)
 823b3a4:	1080008b 	ldhu	r2,2(r2)
 823b3a8:	10bfffcc 	andi	r2,r2,65535
 823b3ac:	1004923a 	slli	r2,r2,8
 823b3b0:	1884b03a 	or	r2,r3,r2
 823b3b4:	e0bffc0d 	sth	r2,-16(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * use the wildcard address; else, use the caller-
     * supplied address
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 823b3b8:	e0bffa17 	ldw	r2,-24(fp)
 823b3bc:	10800117 	ldw	r2,4(r2)
 823b3c0:	1000021e 	bne	r2,zero,823b3cc <udp4_sockbind+0x204>
      fhost = 0L;
 823b3c4:	e03ff715 	stw	zero,-36(fp)
 823b3c8:	00000306 	br	823b3d8 <udp4_sockbind+0x210>
    else
      fhost = sin->sin_addr.s_addr;
 823b3cc:	e0bffa17 	ldw	r2,-24(fp)
 823b3d0:	10800117 	ldw	r2,4(r2)
 823b3d4:	e0bff715 	stw	r2,-36(fp)
    /* prepare to bind the socket to the appropriate 
     * local interface address for the to-be-connected 
     * peer
     */
    lhost = ip_mymach(fhost);
 823b3d8:	e13ff717 	ldw	r4,-36(fp)
 823b3dc:	82408000 	call	8240800 <ip_mymach>
 823b3e0:	e0bff815 	stw	r2,-32(fp)
    if (lhost == 0)
 823b3e4:	e0bff817 	ldw	r2,-32(fp)
 823b3e8:	1000021e 	bne	r2,zero,823b3f4 <udp4_sockbind+0x22c>
      return(ENETUNREACH);
 823b3ec:	00801c84 	movi	r2,114
 823b3f0:	00002506 	br	823b488 <udp4_sockbind+0x2c0>
    /* if the socket hasn't been bound to a local
     * port yet, do so now
     */
    lport = udpconn->u_lport;
 823b3f4:	e0bffb17 	ldw	r2,-20(fp)
 823b3f8:	1080018b 	ldhu	r2,6(r2)
 823b3fc:	e0bff60d 	sth	r2,-40(fp)
    if (lport == 0)
 823b400:	e0bff60b 	ldhu	r2,-40(fp)
 823b404:	1000021e 	bne	r2,zero,823b410 <udp4_sockbind+0x248>
      lport = udp_socket();
 823b408:	82451880 	call	8245188 <udp_socket>
 823b40c:	e0bff60d 	sth	r2,-40(fp)
    /* bind and connect the UDP endpoint */
    udpconn->u_lhost = lhost;
 823b410:	e0bffb17 	ldw	r2,-20(fp)
 823b414:	e0fff817 	ldw	r3,-32(fp)
 823b418:	10c00315 	stw	r3,12(r2)
    udpconn->u_lport = lport;
 823b41c:	e0bffb17 	ldw	r2,-20(fp)
 823b420:	e0fff60b 	ldhu	r3,-40(fp)
 823b424:	10c0018d 	sth	r3,6(r2)
    udpconn->u_fhost = fhost;
 823b428:	e0bffb17 	ldw	r2,-20(fp)
 823b42c:	e0fff717 	ldw	r3,-36(fp)
 823b430:	10c00415 	stw	r3,16(r2)
    udpconn->u_fport = fport;
 823b434:	e0bffb17 	ldw	r2,-20(fp)
 823b438:	e0fffc0b 	ldhu	r3,-16(fp)
 823b43c:	10c0020d 	sth	r3,8(r2)
    /* mark the socket as connected */
    so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 823b440:	e0bffd17 	ldw	r2,-12(fp)
 823b444:	10c0088b 	ldhu	r3,34(r2)
 823b448:	00bffcc4 	movi	r2,-13
 823b44c:	1884703a 	and	r2,r3,r2
 823b450:	1007883a 	mov	r3,r2
 823b454:	e0bffd17 	ldw	r2,-12(fp)
 823b458:	10c0088d 	sth	r3,34(r2)
    so->so_state |= SS_ISCONNECTED;
 823b45c:	e0bffd17 	ldw	r2,-12(fp)
 823b460:	1080088b 	ldhu	r2,34(r2)
 823b464:	10800094 	ori	r2,r2,2
 823b468:	1007883a 	mov	r3,r2
 823b46c:	e0bffd17 	ldw	r2,-12(fp)
 823b470:	10c0088d 	sth	r3,34(r2)
    /* since socket was in listen state, packets may be queued */
    sbflush(&so->so_rcv);   /* dump these now */
 823b474:	e0bffd17 	ldw	r2,-12(fp)
 823b478:	10800a04 	addi	r2,r2,40
 823b47c:	1009883a 	mov	r4,r2
 823b480:	82347a80 	call	82347a8 <sbflush>
  }
  return 0;
 823b484:	0005883a 	mov	r2,zero
}
 823b488:	e037883a 	mov	sp,fp
 823b48c:	dfc00117 	ldw	ra,4(sp)
 823b490:	df000017 	ldw	fp,0(sp)
 823b494:	dec00204 	addi	sp,sp,8
 823b498:	f800283a 	ret

0823b49c <udp4_socksend>:

int udp4_socksend(struct socket *so, struct mbuf *m, 
		struct mbuf *nam ) 
{
 823b49c:	defff304 	addi	sp,sp,-52
 823b4a0:	dfc00c15 	stw	ra,48(sp)
 823b4a4:	df000b15 	stw	fp,44(sp)
 823b4a8:	dc000a15 	stw	r16,40(sp)
 823b4ac:	df000b04 	addi	fp,sp,44
 823b4b0:	e13ffc15 	stw	r4,-16(fp)
 823b4b4:	e17ffd15 	stw	r5,-12(fp)
 823b4b8:	e1bffe15 	stw	r6,-8(fp)
  PACKET pkt;
#ifdef MULTI_HOMED
  NET ifp;
#endif

  udpconn = udp_lookup(so);
 823b4bc:	e13ffc17 	ldw	r4,-16(fp)
 823b4c0:	823ad900 	call	823ad90 <udp_lookup>
 823b4c4:	e0bff815 	stw	r2,-32(fp)
  if (!udpconn)
 823b4c8:	e0bff817 	ldw	r2,-32(fp)
 823b4cc:	1000041e 	bne	r2,zero,823b4e0 <udp4_socksend+0x44>
  {
    m_free(m);
 823b4d0:	e13ffd17 	ldw	r4,-12(fp)
 823b4d4:	822e3b00 	call	822e3b0 <m_free>
    /* may be bogus socket, but more likely the connection may 
       have closed due to ICMP dest unreachable from other side. */
    return(ECONNREFUSED);
 823b4d8:	00801bc4 	movi	r2,111
 823b4dc:	0000c906 	br	823b804 <udp4_socksend+0x368>
  }

  if (nam == NULL)  /* no sendto() info passed, must be send() */
 823b4e0:	e0bffe17 	ldw	r2,-8(fp)
 823b4e4:	10000e1e 	bne	r2,zero,823b520 <udp4_socksend+0x84>
  { 
    if (so->so_state & SS_ISCONNECTED)
 823b4e8:	e0bffc17 	ldw	r2,-16(fp)
 823b4ec:	1080088b 	ldhu	r2,34(r2)
 823b4f0:	10bfffcc 	andi	r2,r2,65535
 823b4f4:	1080008c 	andi	r2,r2,2
 823b4f8:	10000726 	beq	r2,zero,823b518 <udp4_socksend+0x7c>
    {
      fport = udpconn->u_fport;
 823b4fc:	e0bff817 	ldw	r2,-32(fp)
 823b500:	1080020b 	ldhu	r2,8(r2)
 823b504:	e0bff50d 	sth	r2,-44(fp)
      fhost = udpconn->u_fhost;
 823b508:	e0bff817 	ldw	r2,-32(fp)
 823b50c:	10800417 	ldw	r2,16(r2)
 823b510:	e0bff615 	stw	r2,-40(fp)
 823b514:	00002806 	br	823b5b8 <udp4_socksend+0x11c>
    }
    else
      return (EINVAL);
 823b518:	00800584 	movi	r2,22
 823b51c:	0000b906 	br	823b804 <udp4_socksend+0x368>
  }
  else if(nam->m_len != sizeof (*sin))
 823b520:	e0bffe17 	ldw	r2,-8(fp)
 823b524:	10800217 	ldw	r2,8(r2)
 823b528:	10800420 	cmpeqi	r2,r2,16
 823b52c:	1000031e 	bne	r2,zero,823b53c <udp4_socksend+0xa0>
  {
    dtrap();
 823b530:	822d4140 	call	822d414 <dtrap>
    return (EINVAL);
 823b534:	00800584 	movi	r2,22
 823b538:	0000b206 	br	823b804 <udp4_socksend+0x368>
  }
  else
  {
    sin = mtod(nam, struct sockaddr_in *);
 823b53c:	e0bffe17 	ldw	r2,-8(fp)
 823b540:	10800317 	ldw	r2,12(r2)
 823b544:	e0bff915 	stw	r2,-28(fp)
    fhost = sin->sin_addr.s_addr;
 823b548:	e0bff917 	ldw	r2,-28(fp)
 823b54c:	10800117 	ldw	r2,4(r2)
 823b550:	e0bff615 	stw	r2,-40(fp)
    /* use caller's fport if specified, ours may be a wildcard */
    if (sin->sin_port)   /* caller gets to change fport on the fly */
 823b554:	e0bff917 	ldw	r2,-28(fp)
 823b558:	1080008b 	ldhu	r2,2(r2)
 823b55c:	10bfffcc 	andi	r2,r2,65535
 823b560:	10000c26 	beq	r2,zero,823b594 <udp4_socksend+0xf8>
      fport = ntohs(sin->sin_port);
 823b564:	e0bff917 	ldw	r2,-28(fp)
 823b568:	1080008b 	ldhu	r2,2(r2)
 823b56c:	10bfffcc 	andi	r2,r2,65535
 823b570:	1004d23a 	srli	r2,r2,8
 823b574:	1007883a 	mov	r3,r2
 823b578:	e0bff917 	ldw	r2,-28(fp)
 823b57c:	1080008b 	ldhu	r2,2(r2)
 823b580:	10bfffcc 	andi	r2,r2,65535
 823b584:	1004923a 	slli	r2,r2,8
 823b588:	1884b03a 	or	r2,r3,r2
 823b58c:	e0bff50d 	sth	r2,-44(fp)
 823b590:	00000906 	br	823b5b8 <udp4_socksend+0x11c>
    else  /* use port already set in UDP connection */
    {
      if (udpconn->u_fport == 0) /* don't send to port 0 */
 823b594:	e0bff817 	ldw	r2,-32(fp)
 823b598:	1080020b 	ldhu	r2,8(r2)
 823b59c:	10bfffcc 	andi	r2,r2,65535
 823b5a0:	1000021e 	bne	r2,zero,823b5ac <udp4_socksend+0x110>
        return (EINVAL);
 823b5a4:	00800584 	movi	r2,22
 823b5a8:	00009606 	br	823b804 <udp4_socksend+0x368>
      fport = udpconn->u_fport;
 823b5ac:	e0bff817 	ldw	r2,-32(fp)
 823b5b0:	1080020b 	ldhu	r2,8(r2)
 823b5b4:	e0bff50d 	sth	r2,-44(fp)

  /* since our pkt->nb_buff size is tied to max packet size, we 
   * assume our UDP datagrams are always in one mbuf and that the 
   * mbuf 
   */
  if (m->m_len > (unsigned)udp_maxalloc()) /* but check anyway:*/
 823b5b8:	e0bffd17 	ldw	r2,-12(fp)
 823b5bc:	14000217 	ldw	r16,8(r2)
 823b5c0:	82452f40 	call	82452f4 <udp_maxalloc>
 823b5c4:	1400032e 	bgeu	r2,r16,823b5d4 <udp4_socksend+0x138>
  {
    dtrap(); /* should never happen */
 823b5c8:	822d4140 	call	822d414 <dtrap>
    return EMSGSIZE;  /* try to recover */
 823b5cc:	00801e84 	movi	r2,122
 823b5d0:	00008c06 	br	823b804 <udp4_socksend+0x368>
  }
  pkt = udp_alloc(m->m_len, 0);    /* get a NetPort buffer for send */
 823b5d4:	e0bffd17 	ldw	r2,-12(fp)
 823b5d8:	10800217 	ldw	r2,8(r2)
 823b5dc:	000b883a 	mov	r5,zero
 823b5e0:	1009883a 	mov	r4,r2
 823b5e4:	82452380 	call	8245238 <udp_alloc>
 823b5e8:	e0bffa15 	stw	r2,-24(fp)
  if (!pkt)
 823b5ec:	e0bffa17 	ldw	r2,-24(fp)
 823b5f0:	1000041e 	bne	r2,zero,823b604 <udp4_socksend+0x168>
  {
    m_free(m);
 823b5f4:	e13ffd17 	ldw	r4,-12(fp)
 823b5f8:	822e3b00 	call	822e3b0 <m_free>
    return ENOBUFS;   /* report buffer shortages */
 823b5fc:	00801a44 	movi	r2,105
 823b600:	00008006 	br	823b804 <udp4_socksend+0x368>
  }
  MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 823b604:	e0bffa17 	ldw	r2,-24(fp)
 823b608:	10c00317 	ldw	r3,12(r2)
 823b60c:	e0bffd17 	ldw	r2,-12(fp)
 823b610:	11000317 	ldw	r4,12(r2)
 823b614:	e0bffd17 	ldw	r2,-12(fp)
 823b618:	10800217 	ldw	r2,8(r2)
 823b61c:	100d883a 	mov	r6,r2
 823b620:	200b883a 	mov	r5,r4
 823b624:	1809883a 	mov	r4,r3
 823b628:	8202e8c0 	call	8202e8c <memcpy>
  pkt->nb_plen = m->m_len;
 823b62c:	e0bffd17 	ldw	r2,-12(fp)
 823b630:	10c00217 	ldw	r3,8(r2)
 823b634:	e0bffa17 	ldw	r2,-24(fp)
 823b638:	10c00415 	stw	r3,16(r2)
  /* finished with mbuf, free it now */
  m_free(m);
 823b63c:	e13ffd17 	ldw	r4,-12(fp)
 823b640:	822e3b00 	call	822e3b0 <m_free>
  pkt->fhost = fhost;
 823b644:	e0bffa17 	ldw	r2,-24(fp)
 823b648:	e0fff617 	ldw	r3,-40(fp)
 823b64c:	10c00715 	stw	r3,28(r2)
     * is up; if (after all that) we don't have an interface then we
     * fail with error EADDRNOTAVAIL; and finally, if we're built
     * for a single-homed configuration where there's only one
     * interface, we might as well use it, so we do.  
   */
  if (fhost == 0xffffffff)
 823b650:	e0bff617 	ldw	r2,-40(fp)
 823b654:	10bfffd8 	cmpnei	r2,r2,-1
 823b658:	10004a1e 	bne	r2,zero,823b784 <udp4_socksend+0x2e8>
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
 823b65c:	e0bff817 	ldw	r2,-32(fp)
 823b660:	10800317 	ldw	r2,12(r2)
 823b664:	10001026 	beq	r2,zero,823b6a8 <udp4_socksend+0x20c>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b668:	008209b4 	movhi	r2,2086
 823b66c:	10ba6504 	addi	r2,r2,-5740
 823b670:	10800017 	ldw	r2,0(r2)
 823b674:	e0bff715 	stw	r2,-36(fp)
 823b678:	00000806 	br	823b69c <udp4_socksend+0x200>
        if (ifp->n_ipaddr == udpconn->u_lhost)
 823b67c:	e0bff717 	ldw	r2,-36(fp)
 823b680:	10c00a17 	ldw	r3,40(r2)
 823b684:	e0bff817 	ldw	r2,-32(fp)
 823b688:	10800317 	ldw	r2,12(r2)
 823b68c:	18801d26 	beq	r3,r2,823b704 <udp4_socksend+0x268>
  if (fhost == 0xffffffff)
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b690:	e0bff717 	ldw	r2,-36(fp)
 823b694:	10800017 	ldw	r2,0(r2)
 823b698:	e0bff715 	stw	r2,-36(fp)
 823b69c:	e0bff717 	ldw	r2,-36(fp)
 823b6a0:	103ff61e 	bne	r2,zero,823b67c <udp4_socksend+0x1e0>
 823b6a4:	00001a06 	br	823b710 <udp4_socksend+0x274>
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b6a8:	008209b4 	movhi	r2,2086
 823b6ac:	10ba6504 	addi	r2,r2,-5740
 823b6b0:	10800017 	ldw	r2,0(r2)
 823b6b4:	e0bff715 	stw	r2,-36(fp)
 823b6b8:	00000f06 	br	823b6f8 <udp4_socksend+0x25c>
        if ((ifp->n_flags & NF_BCAST) &&
 823b6bc:	e0bff717 	ldw	r2,-36(fp)
 823b6c0:	10802a17 	ldw	r2,168(r2)
 823b6c4:	1080004c 	andi	r2,r2,1
 823b6c8:	10000826 	beq	r2,zero,823b6ec <udp4_socksend+0x250>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 823b6cc:	e0bff717 	ldw	r2,-36(fp)
 823b6d0:	10802717 	ldw	r2,156(r2)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if ((ifp->n_flags & NF_BCAST) &&
 823b6d4:	10000526 	beq	r2,zero,823b6ec <udp4_socksend+0x250>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 823b6d8:	e0bff717 	ldw	r2,-36(fp)
 823b6dc:	10802717 	ldw	r2,156(r2)
 823b6e0:	10800617 	ldw	r2,24(r2)
 823b6e4:	10800058 	cmpnei	r2,r2,1
 823b6e8:	10000826 	beq	r2,zero,823b70c <udp4_socksend+0x270>
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b6ec:	e0bff717 	ldw	r2,-36(fp)
 823b6f0:	10800017 	ldw	r2,0(r2)
 823b6f4:	e0bff715 	stw	r2,-36(fp)
 823b6f8:	e0bff717 	ldw	r2,-36(fp)
 823b6fc:	103fef1e 	bne	r2,zero,823b6bc <udp4_socksend+0x220>
 823b700:	00000306 	br	823b710 <udp4_socksend+0x274>
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
 823b704:	0001883a 	nop
 823b708:	00000106 	br	823b710 <udp4_socksend+0x274>
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if ((ifp->n_flags & NF_BCAST) &&
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
 823b70c:	0001883a 	nop
    }
    if (ifp == NULL)
 823b710:	e0bff717 	ldw	r2,-36(fp)
 823b714:	1000181e 	bne	r2,zero,823b778 <udp4_socksend+0x2dc>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b718:	008209b4 	movhi	r2,2086
 823b71c:	10ba6504 	addi	r2,r2,-5740
 823b720:	10800017 	ldw	r2,0(r2)
 823b724:	e0bff715 	stw	r2,-36(fp)
 823b728:	00000b06 	br	823b758 <udp4_socksend+0x2bc>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 823b72c:	e0bff717 	ldw	r2,-36(fp)
 823b730:	10802717 	ldw	r2,156(r2)
 823b734:	10000526 	beq	r2,zero,823b74c <udp4_socksend+0x2b0>
 823b738:	e0bff717 	ldw	r2,-36(fp)
 823b73c:	10802717 	ldw	r2,156(r2)
 823b740:	10800617 	ldw	r2,24(r2)
 823b744:	10800058 	cmpnei	r2,r2,1
 823b748:	10000626 	beq	r2,zero,823b764 <udp4_socksend+0x2c8>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823b74c:	e0bff717 	ldw	r2,-36(fp)
 823b750:	10800017 	ldw	r2,0(r2)
 823b754:	e0bff715 	stw	r2,-36(fp)
 823b758:	e0bff717 	ldw	r2,-36(fp)
 823b75c:	103ff31e 	bne	r2,zero,823b72c <udp4_socksend+0x290>
 823b760:	00000106 	br	823b768 <udp4_socksend+0x2cc>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
          break;
 823b764:	0001883a 	nop
      if (ifp == NULL)
 823b768:	e0bff717 	ldw	r2,-36(fp)
 823b76c:	1000021e 	bne	r2,zero,823b778 <udp4_socksend+0x2dc>
        return(EADDRNOTAVAIL);
 823b770:	00801f44 	movi	r2,125
 823b774:	00002306 	br	823b804 <udp4_socksend+0x368>
    }
    pkt->net = ifp;
 823b778:	e0bffa17 	ldw	r2,-24(fp)
 823b77c:	e0fff717 	ldw	r3,-36(fp)
 823b780:	10c00615 	stw	r3,24(r2)
#ifdef IP_MULTICAST

  /* If the socket has an IP moptions structure for multicast options,
   * place a pointer to this structure in the PACKET structure.
   */
  if (so->inp_moptions)
 823b784:	e0bffc17 	ldw	r2,-16(fp)
 823b788:	10800317 	ldw	r2,12(r2)
 823b78c:	10000426 	beq	r2,zero,823b7a0 <udp4_socksend+0x304>
     pkt->imo = so->inp_moptions;
 823b790:	e0bffc17 	ldw	r2,-16(fp)
 823b794:	10c00317 	ldw	r3,12(r2)
 823b798:	e0bffa17 	ldw	r2,-24(fp)
 823b79c:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

   /* have we set options? */
   if (so->so_optsPack)
 823b7a0:	e0bffc17 	ldw	r2,-16(fp)
 823b7a4:	10801f17 	ldw	r2,124(r2)
 823b7a8:	10000426 	beq	r2,zero,823b7bc <udp4_socksend+0x320>
	   pkt->soxopts = so->so_optsPack; /* yup - copy to pkt */
 823b7ac:	e0bffc17 	ldw	r2,-16(fp)
 823b7b0:	10c01f17 	ldw	r3,124(r2)
 823b7b4:	e0bffa17 	ldw	r2,-24(fp)
 823b7b8:	10c00c15 	stw	r3,48(r2)

  /* unlock the net resource; UDP will immediately re-lock it */
  UNLOCK_NET_RESOURCE(NET_RESID);
 823b7bc:	0009883a 	mov	r4,zero
 823b7c0:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
  e = udp_send(fport, udpconn->u_lport, pkt);
 823b7c4:	e0fff50b 	ldhu	r3,-44(fp)
 823b7c8:	e0bff817 	ldw	r2,-32(fp)
 823b7cc:	1080018b 	ldhu	r2,6(r2)
 823b7d0:	10bfffcc 	andi	r2,r2,65535
 823b7d4:	e1bffa17 	ldw	r6,-24(fp)
 823b7d8:	100b883a 	mov	r5,r2
 823b7dc:	1809883a 	mov	r4,r3
 823b7e0:	8244dfc0 	call	8244dfc <udp_send>
 823b7e4:	e0bffb15 	stw	r2,-20(fp)
  LOCK_NET_RESOURCE(NET_RESID);
 823b7e8:	0009883a 	mov	r4,zero
 823b7ec:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
  if (e < 0) 
 823b7f0:	e0bffb17 	ldw	r2,-20(fp)
 823b7f4:	1000020e 	bge	r2,zero,823b800 <udp4_socksend+0x364>
     return(e);
 823b7f8:	e0bffb17 	ldw	r2,-20(fp)
 823b7fc:	00000106 	br	823b804 <udp4_socksend+0x368>
  return 0;
 823b800:	0005883a 	mov	r2,zero
}
 823b804:	e6ffff04 	addi	sp,fp,-4
 823b808:	dfc00217 	ldw	ra,8(sp)
 823b80c:	df000117 	ldw	fp,4(sp)
 823b810:	dc000017 	ldw	r16,0(sp)
 823b814:	dec00304 	addi	sp,sp,12
 823b818:	f800283a 	ret

0823b81c <udp4_sockaddr>:

int udp4_sockaddr(struct socket *so, struct mbuf *nam , int req)
{
 823b81c:	defff904 	addi	sp,sp,-28
 823b820:	dfc00615 	stw	ra,24(sp)
 823b824:	df000515 	stw	fp,20(sp)
 823b828:	df000504 	addi	fp,sp,20
 823b82c:	e13ffd15 	stw	r4,-12(fp)
 823b830:	e17ffe15 	stw	r5,-8(fp)
 823b834:	e1bfff15 	stw	r6,-4(fp)
  struct sockaddr_in * sin;
  UDPCONN udpconn;

  sin = mtod(nam, struct sockaddr_in *);
 823b838:	e0bffe17 	ldw	r2,-8(fp)
 823b83c:	10800317 	ldw	r2,12(r2)
 823b840:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 823b844:	e0bffb17 	ldw	r2,-20(fp)
 823b848:	1000021e 	bne	r2,zero,823b854 <udp4_sockaddr+0x38>
     return(EINVAL);
 823b84c:	00800584 	movi	r2,22
 823b850:	00003706 	br	823b930 <udp4_sockaddr+0x114>
  udpconn = udp_lookup(so);
 823b854:	e13ffd17 	ldw	r4,-12(fp)
 823b858:	823ad900 	call	823ad90 <udp_lookup>
 823b85c:	e0bffc15 	stw	r2,-16(fp)
  if (!udpconn)
 823b860:	e0bffc17 	ldw	r2,-16(fp)
 823b864:	1000021e 	bne	r2,zero,823b870 <udp4_sockaddr+0x54>
     return(EINVAL);
 823b868:	00800584 	movi	r2,22
 823b86c:	00003006 	br	823b930 <udp4_sockaddr+0x114>
  nam->m_len = sizeof(*sin);
 823b870:	e0bffe17 	ldw	r2,-8(fp)
 823b874:	00c00404 	movi	r3,16
 823b878:	10c00215 	stw	r3,8(r2)
  if (req == PRU_SOCKADDR)
 823b87c:	e0bfff17 	ldw	r2,-4(fp)
 823b880:	108003d8 	cmpnei	r2,r2,15
 823b884:	1000151e 	bne	r2,zero,823b8dc <udp4_sockaddr+0xc0>
  {
     sin->sin_family = AF_INET;
 823b888:	e0bffb17 	ldw	r2,-20(fp)
 823b88c:	00c00084 	movi	r3,2
 823b890:	10c0000d 	sth	r3,0(r2)
     sin->sin_port = htons(udpconn->u_lport);
 823b894:	e0bffc17 	ldw	r2,-16(fp)
 823b898:	1080018b 	ldhu	r2,6(r2)
 823b89c:	10bfffcc 	andi	r2,r2,65535
 823b8a0:	1004d23a 	srli	r2,r2,8
 823b8a4:	1007883a 	mov	r3,r2
 823b8a8:	e0bffc17 	ldw	r2,-16(fp)
 823b8ac:	1080018b 	ldhu	r2,6(r2)
 823b8b0:	10bfffcc 	andi	r2,r2,65535
 823b8b4:	1004923a 	slli	r2,r2,8
 823b8b8:	1884b03a 	or	r2,r3,r2
 823b8bc:	1007883a 	mov	r3,r2
 823b8c0:	e0bffb17 	ldw	r2,-20(fp)
 823b8c4:	10c0008d 	sth	r3,2(r2)
     sin->sin_addr.s_addr = udpconn->u_lhost;
 823b8c8:	e0bffc17 	ldw	r2,-16(fp)
 823b8cc:	10c00317 	ldw	r3,12(r2)
 823b8d0:	e0bffb17 	ldw	r2,-20(fp)
 823b8d4:	10c00115 	stw	r3,4(r2)
 823b8d8:	00001406 	br	823b92c <udp4_sockaddr+0x110>
  }
  else /* PRU_PEERADDR */
  {
    sin->sin_family = AF_INET;
 823b8dc:	e0bffb17 	ldw	r2,-20(fp)
 823b8e0:	00c00084 	movi	r3,2
 823b8e4:	10c0000d 	sth	r3,0(r2)
    sin->sin_port = htons(udpconn->u_fport);
 823b8e8:	e0bffc17 	ldw	r2,-16(fp)
 823b8ec:	1080020b 	ldhu	r2,8(r2)
 823b8f0:	10bfffcc 	andi	r2,r2,65535
 823b8f4:	1004d23a 	srli	r2,r2,8
 823b8f8:	1007883a 	mov	r3,r2
 823b8fc:	e0bffc17 	ldw	r2,-16(fp)
 823b900:	1080020b 	ldhu	r2,8(r2)
 823b904:	10bfffcc 	andi	r2,r2,65535
 823b908:	1004923a 	slli	r2,r2,8
 823b90c:	1884b03a 	or	r2,r3,r2
 823b910:	1007883a 	mov	r3,r2
 823b914:	e0bffb17 	ldw	r2,-20(fp)
 823b918:	10c0008d 	sth	r3,2(r2)
    sin->sin_addr.s_addr = udpconn->u_fhost;
 823b91c:	e0bffc17 	ldw	r2,-16(fp)
 823b920:	10c00417 	ldw	r3,16(r2)
 823b924:	e0bffb17 	ldw	r2,-20(fp)
 823b928:	10c00115 	stw	r3,4(r2)
  }
  return 0;
 823b92c:	0005883a 	mov	r2,zero
}
 823b930:	e037883a 	mov	sp,fp
 823b934:	dfc00117 	ldw	ra,4(sp)
 823b938:	df000017 	ldw	fp,0(sp)
 823b93c:	dec00204 	addi	sp,sp,8
 823b940:	f800283a 	ret

0823b944 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 823b944:	defff504 	addi	sp,sp,-44
 823b948:	df000a15 	stw	fp,40(sp)
 823b94c:	df000a04 	addi	fp,sp,40
 823b950:	e13ffc15 	stw	r4,-16(fp)
 823b954:	e17ffd15 	stw	r5,-12(fp)
 823b958:	e1bffe15 	stw	r6,-8(fp)
 823b95c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 823b960:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 823b964:	d0a0b817 	ldw	r2,-32032(gp)
  
  if (alt_ticks_per_second ())
 823b968:	10003c26 	beq	r2,zero,823ba5c <alt_alarm_start+0x118>
  {
    if (alarm)
 823b96c:	e0bffc17 	ldw	r2,-16(fp)
 823b970:	10003826 	beq	r2,zero,823ba54 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 823b974:	e0bffc17 	ldw	r2,-16(fp)
 823b978:	e0fffe17 	ldw	r3,-8(fp)
 823b97c:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 823b980:	e0bffc17 	ldw	r2,-16(fp)
 823b984:	e0ffff17 	ldw	r3,-4(fp)
 823b988:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823b98c:	0005303a 	rdctl	r2,status
 823b990:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823b994:	e0fff917 	ldw	r3,-28(fp)
 823b998:	00bfff84 	movi	r2,-2
 823b99c:	1884703a 	and	r2,r3,r2
 823b9a0:	1001703a 	wrctl	status,r2
  
  return context;
 823b9a4:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 823b9a8:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 823b9ac:	d0a0b917 	ldw	r2,-32028(gp)
      
      current_nticks = alt_nticks();
 823b9b0:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 823b9b4:	e0fffd17 	ldw	r3,-12(fp)
 823b9b8:	e0bff617 	ldw	r2,-40(fp)
 823b9bc:	1885883a 	add	r2,r3,r2
 823b9c0:	10c00044 	addi	r3,r2,1
 823b9c4:	e0bffc17 	ldw	r2,-16(fp)
 823b9c8:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 823b9cc:	e0bffc17 	ldw	r2,-16(fp)
 823b9d0:	10c00217 	ldw	r3,8(r2)
 823b9d4:	e0bff617 	ldw	r2,-40(fp)
 823b9d8:	1880042e 	bgeu	r3,r2,823b9ec <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 823b9dc:	e0bffc17 	ldw	r2,-16(fp)
 823b9e0:	00c00044 	movi	r3,1
 823b9e4:	10c00405 	stb	r3,16(r2)
 823b9e8:	00000206 	br	823b9f4 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 823b9ec:	e0bffc17 	ldw	r2,-16(fp)
 823b9f0:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 823b9f4:	e0bffc17 	ldw	r2,-16(fp)
 823b9f8:	d0e04904 	addi	r3,gp,-32476
 823b9fc:	e0fffa15 	stw	r3,-24(fp)
 823ba00:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 823ba04:	e0bffb17 	ldw	r2,-20(fp)
 823ba08:	e0fffa17 	ldw	r3,-24(fp)
 823ba0c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 823ba10:	e0bffa17 	ldw	r2,-24(fp)
 823ba14:	10c00017 	ldw	r3,0(r2)
 823ba18:	e0bffb17 	ldw	r2,-20(fp)
 823ba1c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 823ba20:	e0bffa17 	ldw	r2,-24(fp)
 823ba24:	10800017 	ldw	r2,0(r2)
 823ba28:	e0fffb17 	ldw	r3,-20(fp)
 823ba2c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 823ba30:	e0bffa17 	ldw	r2,-24(fp)
 823ba34:	e0fffb17 	ldw	r3,-20(fp)
 823ba38:	10c00015 	stw	r3,0(r2)
 823ba3c:	e0bff817 	ldw	r2,-32(fp)
 823ba40:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823ba44:	e0bff717 	ldw	r2,-36(fp)
 823ba48:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 823ba4c:	0005883a 	mov	r2,zero
 823ba50:	00000306 	br	823ba60 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 823ba54:	00bffa84 	movi	r2,-22
 823ba58:	00000106 	br	823ba60 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 823ba5c:	00bfde84 	movi	r2,-134
  }
}
 823ba60:	e037883a 	mov	sp,fp
 823ba64:	df000017 	ldw	fp,0(sp)
 823ba68:	dec00104 	addi	sp,sp,4
 823ba6c:	f800283a 	ret

0823ba70 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823ba70:	defffe04 	addi	sp,sp,-8
 823ba74:	dfc00115 	stw	ra,4(sp)
 823ba78:	df000015 	stw	fp,0(sp)
 823ba7c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823ba80:	d0a04717 	ldw	r2,-32484(gp)
 823ba84:	10000326 	beq	r2,zero,823ba94 <alt_get_errno+0x24>
 823ba88:	d0a04717 	ldw	r2,-32484(gp)
 823ba8c:	103ee83a 	callr	r2
 823ba90:	00000106 	br	823ba98 <alt_get_errno+0x28>
 823ba94:	d0a06304 	addi	r2,gp,-32372
}
 823ba98:	e037883a 	mov	sp,fp
 823ba9c:	dfc00117 	ldw	ra,4(sp)
 823baa0:	df000017 	ldw	fp,0(sp)
 823baa4:	dec00204 	addi	sp,sp,8
 823baa8:	f800283a 	ret

0823baac <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 823baac:	defffb04 	addi	sp,sp,-20
 823bab0:	dfc00415 	stw	ra,16(sp)
 823bab4:	df000315 	stw	fp,12(sp)
 823bab8:	df000304 	addi	fp,sp,12
 823babc:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 823bac0:	e0bfff17 	ldw	r2,-4(fp)
 823bac4:	10000616 	blt	r2,zero,823bae0 <alt_close+0x34>
 823bac8:	e0bfff17 	ldw	r2,-4(fp)
 823bacc:	10c00324 	muli	r3,r2,12
 823bad0:	00820974 	movhi	r2,2085
 823bad4:	108edc04 	addi	r2,r2,15216
 823bad8:	1885883a 	add	r2,r3,r2
 823badc:	00000106 	br	823bae4 <alt_close+0x38>
 823bae0:	0005883a 	mov	r2,zero
 823bae4:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 823bae8:	e0bffd17 	ldw	r2,-12(fp)
 823baec:	10001926 	beq	r2,zero,823bb54 <alt_close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 823baf0:	e0bffd17 	ldw	r2,-12(fp)
 823baf4:	10800017 	ldw	r2,0(r2)
 823baf8:	10800417 	ldw	r2,16(r2)
 823bafc:	10000626 	beq	r2,zero,823bb18 <alt_close+0x6c>
 823bb00:	e0bffd17 	ldw	r2,-12(fp)
 823bb04:	10800017 	ldw	r2,0(r2)
 823bb08:	10800417 	ldw	r2,16(r2)
 823bb0c:	e13ffd17 	ldw	r4,-12(fp)
 823bb10:	103ee83a 	callr	r2
 823bb14:	00000106 	br	823bb1c <alt_close+0x70>
 823bb18:	0005883a 	mov	r2,zero
 823bb1c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 823bb20:	e13fff17 	ldw	r4,-4(fp)
 823bb24:	823c5bc0 	call	823c5bc <alt_release_fd>
    if (rval < 0)
 823bb28:	e0bffe17 	ldw	r2,-8(fp)
 823bb2c:	1000070e 	bge	r2,zero,823bb4c <alt_close+0xa0>
    {
      ALT_ERRNO = -rval;
 823bb30:	823ba700 	call	823ba70 <alt_get_errno>
 823bb34:	1007883a 	mov	r3,r2
 823bb38:	e0bffe17 	ldw	r2,-8(fp)
 823bb3c:	0085c83a 	sub	r2,zero,r2
 823bb40:	18800015 	stw	r2,0(r3)
      return -1;
 823bb44:	00bfffc4 	movi	r2,-1
 823bb48:	00000706 	br	823bb68 <alt_close+0xbc>
    }
    return 0;
 823bb4c:	0005883a 	mov	r2,zero
 823bb50:	00000506 	br	823bb68 <alt_close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 823bb54:	823ba700 	call	823ba70 <alt_get_errno>
 823bb58:	1007883a 	mov	r3,r2
 823bb5c:	00801444 	movi	r2,81
 823bb60:	18800015 	stw	r2,0(r3)
    return -1;
 823bb64:	00bfffc4 	movi	r2,-1
  }
}
 823bb68:	e037883a 	mov	sp,fp
 823bb6c:	dfc00117 	ldw	ra,4(sp)
 823bb70:	df000017 	ldw	fp,0(sp)
 823bb74:	dec00204 	addi	sp,sp,8
 823bb78:	f800283a 	ret

0823bb7c <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 823bb7c:	defffb04 	addi	sp,sp,-20
 823bb80:	df000415 	stw	fp,16(sp)
 823bb84:	df000404 	addi	fp,sp,16
 823bb88:	e13ffe15 	stw	r4,-8(fp)
 823bb8c:	e17fff15 	stw	r5,-4(fp)
#if NIOS2_DCACHE_SIZE > 0

  char* i;
  char* end = ((char*) start) + len; 
 823bb90:	e0fffe17 	ldw	r3,-8(fp)
 823bb94:	e0bfff17 	ldw	r2,-4(fp)
 823bb98:	1885883a 	add	r2,r3,r2
 823bb9c:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 823bba0:	e0bffe17 	ldw	r2,-8(fp)
 823bba4:	e0bffc15 	stw	r2,-16(fp)
 823bba8:	00000506 	br	823bbc0 <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 823bbac:	e0bffc17 	ldw	r2,-16(fp)
 823bbb0:	1000001b 	flushda	0(r2)
#if NIOS2_DCACHE_SIZE > 0

  char* i;
  char* end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 823bbb4:	e0bffc17 	ldw	r2,-16(fp)
 823bbb8:	10800804 	addi	r2,r2,32
 823bbbc:	e0bffc15 	stw	r2,-16(fp)
 823bbc0:	e0fffc17 	ldw	r3,-16(fp)
 823bbc4:	e0bffd17 	ldw	r2,-12(fp)
 823bbc8:	18bff836 	bltu	r3,r2,823bbac <alt_dcache_flush+0x30>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 823bbcc:	e0bffe17 	ldw	r2,-8(fp)
 823bbd0:	108007cc 	andi	r2,r2,31
 823bbd4:	10000226 	beq	r2,zero,823bbe0 <alt_dcache_flush+0x64>
  {
    ALT_FLUSH_DATA(i);
 823bbd8:	e0bffc17 	ldw	r2,-16(fp)
 823bbdc:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 823bbe0:	0001883a 	nop
 823bbe4:	e037883a 	mov	sp,fp
 823bbe8:	df000017 	ldw	fp,0(sp)
 823bbec:	dec00104 	addi	sp,sp,4
 823bbf0:	f800283a 	ret

0823bbf4 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 823bbf4:	defffc04 	addi	sp,sp,-16
 823bbf8:	df000315 	stw	fp,12(sp)
 823bbfc:	df000304 	addi	fp,sp,12
 823bc00:	e13ffd15 	stw	r4,-12(fp)
 823bc04:	e17ffe15 	stw	r5,-8(fp)
 823bc08:	e1bfff15 	stw	r6,-4(fp)
  return len;
 823bc0c:	e0bfff17 	ldw	r2,-4(fp)
}
 823bc10:	e037883a 	mov	sp,fp
 823bc14:	df000017 	ldw	fp,0(sp)
 823bc18:	dec00104 	addi	sp,sp,4
 823bc1c:	f800283a 	ret

0823bc20 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823bc20:	defffe04 	addi	sp,sp,-8
 823bc24:	dfc00115 	stw	ra,4(sp)
 823bc28:	df000015 	stw	fp,0(sp)
 823bc2c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823bc30:	d0a04717 	ldw	r2,-32484(gp)
 823bc34:	10000326 	beq	r2,zero,823bc44 <alt_get_errno+0x24>
 823bc38:	d0a04717 	ldw	r2,-32484(gp)
 823bc3c:	103ee83a 	callr	r2
 823bc40:	00000106 	br	823bc48 <alt_get_errno+0x28>
 823bc44:	d0a06304 	addi	r2,gp,-32372
}
 823bc48:	e037883a 	mov	sp,fp
 823bc4c:	dfc00117 	ldw	ra,4(sp)
 823bc50:	df000017 	ldw	fp,0(sp)
 823bc54:	dec00204 	addi	sp,sp,8
 823bc58:	f800283a 	ret

0823bc5c <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 823bc5c:	defffa04 	addi	sp,sp,-24
 823bc60:	dfc00515 	stw	ra,20(sp)
 823bc64:	df000415 	stw	fp,16(sp)
 823bc68:	df000404 	addi	fp,sp,16
 823bc6c:	e13ffe15 	stw	r4,-8(fp)
 823bc70:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 823bc74:	e0bffe17 	ldw	r2,-8(fp)
 823bc78:	10000326 	beq	r2,zero,823bc88 <alt_dev_llist_insert+0x2c>
 823bc7c:	e0bffe17 	ldw	r2,-8(fp)
 823bc80:	10800217 	ldw	r2,8(r2)
 823bc84:	1000061e 	bne	r2,zero,823bca0 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 823bc88:	823bc200 	call	823bc20 <alt_get_errno>
 823bc8c:	1007883a 	mov	r3,r2
 823bc90:	00800584 	movi	r2,22
 823bc94:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 823bc98:	00bffa84 	movi	r2,-22
 823bc9c:	00001306 	br	823bcec <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 823bca0:	e0bffe17 	ldw	r2,-8(fp)
 823bca4:	e0ffff17 	ldw	r3,-4(fp)
 823bca8:	e0fffc15 	stw	r3,-16(fp)
 823bcac:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 823bcb0:	e0bffd17 	ldw	r2,-12(fp)
 823bcb4:	e0fffc17 	ldw	r3,-16(fp)
 823bcb8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 823bcbc:	e0bffc17 	ldw	r2,-16(fp)
 823bcc0:	10c00017 	ldw	r3,0(r2)
 823bcc4:	e0bffd17 	ldw	r2,-12(fp)
 823bcc8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 823bccc:	e0bffc17 	ldw	r2,-16(fp)
 823bcd0:	10800017 	ldw	r2,0(r2)
 823bcd4:	e0fffd17 	ldw	r3,-12(fp)
 823bcd8:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 823bcdc:	e0bffc17 	ldw	r2,-16(fp)
 823bce0:	e0fffd17 	ldw	r3,-12(fp)
 823bce4:	10c00015 	stw	r3,0(r2)

  return 0;  
 823bce8:	0005883a 	mov	r2,zero
}
 823bcec:	e037883a 	mov	sp,fp
 823bcf0:	dfc00117 	ldw	ra,4(sp)
 823bcf4:	df000017 	ldw	fp,0(sp)
 823bcf8:	dec00204 	addi	sp,sp,8
 823bcfc:	f800283a 	ret

0823bd00 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 823bd00:	defffd04 	addi	sp,sp,-12
 823bd04:	dfc00215 	stw	ra,8(sp)
 823bd08:	df000115 	stw	fp,4(sp)
 823bd0c:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 823bd10:	00820974 	movhi	r2,2085
 823bd14:	10afb404 	addi	r2,r2,-16688
 823bd18:	e0bfff15 	stw	r2,-4(fp)
 823bd1c:	00000606 	br	823bd38 <_do_ctors+0x38>
        (*ctor) (); 
 823bd20:	e0bfff17 	ldw	r2,-4(fp)
 823bd24:	10800017 	ldw	r2,0(r2)
 823bd28:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 823bd2c:	e0bfff17 	ldw	r2,-4(fp)
 823bd30:	10bfff04 	addi	r2,r2,-4
 823bd34:	e0bfff15 	stw	r2,-4(fp)
 823bd38:	e0ffff17 	ldw	r3,-4(fp)
 823bd3c:	00820974 	movhi	r2,2085
 823bd40:	10afb504 	addi	r2,r2,-16684
 823bd44:	18bff62e 	bgeu	r3,r2,823bd20 <_do_ctors+0x20>
        (*ctor) (); 
}
 823bd48:	0001883a 	nop
 823bd4c:	e037883a 	mov	sp,fp
 823bd50:	dfc00117 	ldw	ra,4(sp)
 823bd54:	df000017 	ldw	fp,0(sp)
 823bd58:	dec00204 	addi	sp,sp,8
 823bd5c:	f800283a 	ret

0823bd60 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 823bd60:	defffd04 	addi	sp,sp,-12
 823bd64:	dfc00215 	stw	ra,8(sp)
 823bd68:	df000115 	stw	fp,4(sp)
 823bd6c:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 823bd70:	00820974 	movhi	r2,2085
 823bd74:	10afb404 	addi	r2,r2,-16688
 823bd78:	e0bfff15 	stw	r2,-4(fp)
 823bd7c:	00000606 	br	823bd98 <_do_dtors+0x38>
        (*dtor) (); 
 823bd80:	e0bfff17 	ldw	r2,-4(fp)
 823bd84:	10800017 	ldw	r2,0(r2)
 823bd88:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 823bd8c:	e0bfff17 	ldw	r2,-4(fp)
 823bd90:	10bfff04 	addi	r2,r2,-4
 823bd94:	e0bfff15 	stw	r2,-4(fp)
 823bd98:	e0ffff17 	ldw	r3,-4(fp)
 823bd9c:	00820974 	movhi	r2,2085
 823bda0:	10afb504 	addi	r2,r2,-16684
 823bda4:	18bff62e 	bgeu	r3,r2,823bd80 <_do_dtors+0x20>
        (*dtor) (); 
}
 823bda8:	0001883a 	nop
 823bdac:	e037883a 	mov	sp,fp
 823bdb0:	dfc00117 	ldw	ra,4(sp)
 823bdb4:	df000017 	ldw	fp,0(sp)
 823bdb8:	dec00204 	addi	sp,sp,8
 823bdbc:	f800283a 	ret

0823bdc0 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 823bdc0:	defffa04 	addi	sp,sp,-24
 823bdc4:	dfc00515 	stw	ra,20(sp)
 823bdc8:	df000415 	stw	fp,16(sp)
 823bdcc:	df000404 	addi	fp,sp,16
 823bdd0:	e13ffe15 	stw	r4,-8(fp)
 823bdd4:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 823bdd8:	e0bfff17 	ldw	r2,-4(fp)
 823bddc:	10800017 	ldw	r2,0(r2)
 823bde0:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 823bde4:	e13ffe17 	ldw	r4,-8(fp)
 823bde8:	8203edc0 	call	8203edc <strlen>
 823bdec:	10800044 	addi	r2,r2,1
 823bdf0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 823bdf4:	00000d06 	br	823be2c <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 823bdf8:	e0bffc17 	ldw	r2,-16(fp)
 823bdfc:	10800217 	ldw	r2,8(r2)
 823be00:	e0fffd17 	ldw	r3,-12(fp)
 823be04:	180d883a 	mov	r6,r3
 823be08:	e17ffe17 	ldw	r5,-8(fp)
 823be0c:	1009883a 	mov	r4,r2
 823be10:	820c5580 	call	820c558 <memcmp>
 823be14:	1000021e 	bne	r2,zero,823be20 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 823be18:	e0bffc17 	ldw	r2,-16(fp)
 823be1c:	00000706 	br	823be3c <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 823be20:	e0bffc17 	ldw	r2,-16(fp)
 823be24:	10800017 	ldw	r2,0(r2)
 823be28:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 823be2c:	e0fffc17 	ldw	r3,-16(fp)
 823be30:	e0bfff17 	ldw	r2,-4(fp)
 823be34:	18bff01e 	bne	r3,r2,823bdf8 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 823be38:	0005883a 	mov	r2,zero
}
 823be3c:	e037883a 	mov	sp,fp
 823be40:	dfc00117 	ldw	ra,4(sp)
 823be44:	df000017 	ldw	fp,0(sp)
 823be48:	dec00204 	addi	sp,sp,8
 823be4c:	f800283a 	ret

0823be50 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 823be50:	defff904 	addi	sp,sp,-28
 823be54:	dfc00615 	stw	ra,24(sp)
 823be58:	df000515 	stw	fp,20(sp)
 823be5c:	df000504 	addi	fp,sp,20
 823be60:	e13ffc15 	stw	r4,-16(fp)
 823be64:	e17ffd15 	stw	r5,-12(fp)
 823be68:	e1bffe15 	stw	r6,-8(fp)
 823be6c:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 823be70:	e0800217 	ldw	r2,8(fp)
 823be74:	d8800015 	stw	r2,0(sp)
 823be78:	e1ffff17 	ldw	r7,-4(fp)
 823be7c:	e1bffe17 	ldw	r6,-8(fp)
 823be80:	e17ffd17 	ldw	r5,-12(fp)
 823be84:	e13ffc17 	ldw	r4,-16(fp)
 823be88:	823c0000 	call	823c000 <alt_iic_isr_register>
}  
 823be8c:	e037883a 	mov	sp,fp
 823be90:	dfc00117 	ldw	ra,4(sp)
 823be94:	df000017 	ldw	fp,0(sp)
 823be98:	dec00204 	addi	sp,sp,8
 823be9c:	f800283a 	ret

0823bea0 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 823bea0:	defff904 	addi	sp,sp,-28
 823bea4:	df000615 	stw	fp,24(sp)
 823bea8:	df000604 	addi	fp,sp,24
 823beac:	e13ffe15 	stw	r4,-8(fp)
 823beb0:	e17fff15 	stw	r5,-4(fp)
 823beb4:	e0bfff17 	ldw	r2,-4(fp)
 823beb8:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823bebc:	0005303a 	rdctl	r2,status
 823bec0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823bec4:	e0fffb17 	ldw	r3,-20(fp)
 823bec8:	00bfff84 	movi	r2,-2
 823becc:	1884703a 	and	r2,r3,r2
 823bed0:	1001703a 	wrctl	status,r2
  
  return context;
 823bed4:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 823bed8:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 823bedc:	00c00044 	movi	r3,1
 823bee0:	e0bffa17 	ldw	r2,-24(fp)
 823bee4:	1884983a 	sll	r2,r3,r2
 823bee8:	1007883a 	mov	r3,r2
 823beec:	d0a0b717 	ldw	r2,-32036(gp)
 823bef0:	1884b03a 	or	r2,r3,r2
 823bef4:	d0a0b715 	stw	r2,-32036(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 823bef8:	d0a0b717 	ldw	r2,-32036(gp)
 823befc:	100170fa 	wrctl	ienable,r2
 823bf00:	e0bffc17 	ldw	r2,-16(fp)
 823bf04:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823bf08:	e0bffd17 	ldw	r2,-12(fp)
 823bf0c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 823bf10:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 823bf14:	0001883a 	nop
}
 823bf18:	e037883a 	mov	sp,fp
 823bf1c:	df000017 	ldw	fp,0(sp)
 823bf20:	dec00104 	addi	sp,sp,4
 823bf24:	f800283a 	ret

0823bf28 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 823bf28:	defff904 	addi	sp,sp,-28
 823bf2c:	df000615 	stw	fp,24(sp)
 823bf30:	df000604 	addi	fp,sp,24
 823bf34:	e13ffe15 	stw	r4,-8(fp)
 823bf38:	e17fff15 	stw	r5,-4(fp)
 823bf3c:	e0bfff17 	ldw	r2,-4(fp)
 823bf40:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823bf44:	0005303a 	rdctl	r2,status
 823bf48:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823bf4c:	e0fffb17 	ldw	r3,-20(fp)
 823bf50:	00bfff84 	movi	r2,-2
 823bf54:	1884703a 	and	r2,r3,r2
 823bf58:	1001703a 	wrctl	status,r2
  
  return context;
 823bf5c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 823bf60:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 823bf64:	00c00044 	movi	r3,1
 823bf68:	e0bffa17 	ldw	r2,-24(fp)
 823bf6c:	1884983a 	sll	r2,r3,r2
 823bf70:	0084303a 	nor	r2,zero,r2
 823bf74:	1007883a 	mov	r3,r2
 823bf78:	d0a0b717 	ldw	r2,-32036(gp)
 823bf7c:	1884703a 	and	r2,r3,r2
 823bf80:	d0a0b715 	stw	r2,-32036(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 823bf84:	d0a0b717 	ldw	r2,-32036(gp)
 823bf88:	100170fa 	wrctl	ienable,r2
 823bf8c:	e0bffc17 	ldw	r2,-16(fp)
 823bf90:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823bf94:	e0bffd17 	ldw	r2,-12(fp)
 823bf98:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 823bf9c:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 823bfa0:	0001883a 	nop
}
 823bfa4:	e037883a 	mov	sp,fp
 823bfa8:	df000017 	ldw	fp,0(sp)
 823bfac:	dec00104 	addi	sp,sp,4
 823bfb0:	f800283a 	ret

0823bfb4 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 823bfb4:	defffc04 	addi	sp,sp,-16
 823bfb8:	df000315 	stw	fp,12(sp)
 823bfbc:	df000304 	addi	fp,sp,12
 823bfc0:	e13ffe15 	stw	r4,-8(fp)
 823bfc4:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 823bfc8:	000530fa 	rdctl	r2,ienable
 823bfcc:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 823bfd0:	00c00044 	movi	r3,1
 823bfd4:	e0bfff17 	ldw	r2,-4(fp)
 823bfd8:	1884983a 	sll	r2,r3,r2
 823bfdc:	1007883a 	mov	r3,r2
 823bfe0:	e0bffd17 	ldw	r2,-12(fp)
 823bfe4:	1884703a 	and	r2,r3,r2
 823bfe8:	1004c03a 	cmpne	r2,r2,zero
 823bfec:	10803fcc 	andi	r2,r2,255
}
 823bff0:	e037883a 	mov	sp,fp
 823bff4:	df000017 	ldw	fp,0(sp)
 823bff8:	dec00104 	addi	sp,sp,4
 823bffc:	f800283a 	ret

0823c000 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 823c000:	defff504 	addi	sp,sp,-44
 823c004:	dfc00a15 	stw	ra,40(sp)
 823c008:	df000915 	stw	fp,36(sp)
 823c00c:	df000904 	addi	fp,sp,36
 823c010:	e13ffc15 	stw	r4,-16(fp)
 823c014:	e17ffd15 	stw	r5,-12(fp)
 823c018:	e1bffe15 	stw	r6,-8(fp)
 823c01c:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
 823c020:	00bffa84 	movi	r2,-22
 823c024:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 823c028:	e0bffd17 	ldw	r2,-12(fp)
 823c02c:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 823c030:	e0bff817 	ldw	r2,-32(fp)
 823c034:	10800808 	cmpgei	r2,r2,32
 823c038:	1000271e 	bne	r2,zero,823c0d8 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823c03c:	0005303a 	rdctl	r2,status
 823c040:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823c044:	e0fffb17 	ldw	r3,-20(fp)
 823c048:	00bfff84 	movi	r2,-2
 823c04c:	1884703a 	and	r2,r3,r2
 823c050:	1001703a 	wrctl	status,r2
  
  return context;
 823c054:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 823c058:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
 823c05c:	008209b4 	movhi	r2,2086
 823c060:	10b9cc04 	addi	r2,r2,-6352
 823c064:	e0fff817 	ldw	r3,-32(fp)
 823c068:	180690fa 	slli	r3,r3,3
 823c06c:	10c5883a 	add	r2,r2,r3
 823c070:	e0fffe17 	ldw	r3,-8(fp)
 823c074:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 823c078:	008209b4 	movhi	r2,2086
 823c07c:	10b9cc04 	addi	r2,r2,-6352
 823c080:	e0fff817 	ldw	r3,-32(fp)
 823c084:	180690fa 	slli	r3,r3,3
 823c088:	10c5883a 	add	r2,r2,r3
 823c08c:	10800104 	addi	r2,r2,4
 823c090:	e0ffff17 	ldw	r3,-4(fp)
 823c094:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 823c098:	e0bffe17 	ldw	r2,-8(fp)
 823c09c:	10000526 	beq	r2,zero,823c0b4 <alt_iic_isr_register+0xb4>
 823c0a0:	e0bff817 	ldw	r2,-32(fp)
 823c0a4:	100b883a 	mov	r5,r2
 823c0a8:	e13ffc17 	ldw	r4,-16(fp)
 823c0ac:	823bea00 	call	823bea0 <alt_ic_irq_enable>
 823c0b0:	00000406 	br	823c0c4 <alt_iic_isr_register+0xc4>
 823c0b4:	e0bff817 	ldw	r2,-32(fp)
 823c0b8:	100b883a 	mov	r5,r2
 823c0bc:	e13ffc17 	ldw	r4,-16(fp)
 823c0c0:	823bf280 	call	823bf28 <alt_ic_irq_disable>
 823c0c4:	e0bff715 	stw	r2,-36(fp)
 823c0c8:	e0bffa17 	ldw	r2,-24(fp)
 823c0cc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823c0d0:	e0bff917 	ldw	r2,-28(fp)
 823c0d4:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 823c0d8:	e0bff717 	ldw	r2,-36(fp)
}
 823c0dc:	e037883a 	mov	sp,fp
 823c0e0:	dfc00117 	ldw	ra,4(sp)
 823c0e4:	df000017 	ldw	fp,0(sp)
 823c0e8:	dec00204 	addi	sp,sp,8
 823c0ec:	f800283a 	ret

0823c0f0 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 823c0f0:	defff904 	addi	sp,sp,-28
 823c0f4:	dfc00615 	stw	ra,24(sp)
 823c0f8:	df000515 	stw	fp,20(sp)
 823c0fc:	df000504 	addi	fp,sp,20
 823c100:	e13ffc15 	stw	r4,-16(fp)
 823c104:	e17ffd15 	stw	r5,-12(fp)
 823c108:	e1bffe15 	stw	r6,-8(fp)
 823c10c:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 823c110:	e1bfff17 	ldw	r6,-4(fp)
 823c114:	e17ffe17 	ldw	r5,-8(fp)
 823c118:	e13ffd17 	ldw	r4,-12(fp)
 823c11c:	823c3300 	call	823c330 <open>
 823c120:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 823c124:	e0bffb17 	ldw	r2,-20(fp)
 823c128:	10001c16 	blt	r2,zero,823c19c <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
 823c12c:	00820974 	movhi	r2,2085
 823c130:	108edc04 	addi	r2,r2,15216
 823c134:	e0fffb17 	ldw	r3,-20(fp)
 823c138:	18c00324 	muli	r3,r3,12
 823c13c:	10c5883a 	add	r2,r2,r3
 823c140:	10c00017 	ldw	r3,0(r2)
 823c144:	e0bffc17 	ldw	r2,-16(fp)
 823c148:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 823c14c:	00820974 	movhi	r2,2085
 823c150:	108edc04 	addi	r2,r2,15216
 823c154:	e0fffb17 	ldw	r3,-20(fp)
 823c158:	18c00324 	muli	r3,r3,12
 823c15c:	10c5883a 	add	r2,r2,r3
 823c160:	10800104 	addi	r2,r2,4
 823c164:	10c00017 	ldw	r3,0(r2)
 823c168:	e0bffc17 	ldw	r2,-16(fp)
 823c16c:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 823c170:	00820974 	movhi	r2,2085
 823c174:	108edc04 	addi	r2,r2,15216
 823c178:	e0fffb17 	ldw	r3,-20(fp)
 823c17c:	18c00324 	muli	r3,r3,12
 823c180:	10c5883a 	add	r2,r2,r3
 823c184:	10800204 	addi	r2,r2,8
 823c188:	10c00017 	ldw	r3,0(r2)
 823c18c:	e0bffc17 	ldw	r2,-16(fp)
 823c190:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 823c194:	e13ffb17 	ldw	r4,-20(fp)
 823c198:	823c5bc0 	call	823c5bc <alt_release_fd>
  }
} 
 823c19c:	0001883a 	nop
 823c1a0:	e037883a 	mov	sp,fp
 823c1a4:	dfc00117 	ldw	ra,4(sp)
 823c1a8:	df000017 	ldw	fp,0(sp)
 823c1ac:	dec00204 	addi	sp,sp,8
 823c1b0:	f800283a 	ret

0823c1b4 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 823c1b4:	defffb04 	addi	sp,sp,-20
 823c1b8:	dfc00415 	stw	ra,16(sp)
 823c1bc:	df000315 	stw	fp,12(sp)
 823c1c0:	df000304 	addi	fp,sp,12
 823c1c4:	e13ffd15 	stw	r4,-12(fp)
 823c1c8:	e17ffe15 	stw	r5,-8(fp)
 823c1cc:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 823c1d0:	01c07fc4 	movi	r7,511
 823c1d4:	01800044 	movi	r6,1
 823c1d8:	e17ffd17 	ldw	r5,-12(fp)
 823c1dc:	01020974 	movhi	r4,2085
 823c1e0:	210edf04 	addi	r4,r4,15228
 823c1e4:	823c0f00 	call	823c0f0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 823c1e8:	01c07fc4 	movi	r7,511
 823c1ec:	000d883a 	mov	r6,zero
 823c1f0:	e17ffe17 	ldw	r5,-8(fp)
 823c1f4:	01020974 	movhi	r4,2085
 823c1f8:	210edc04 	addi	r4,r4,15216
 823c1fc:	823c0f00 	call	823c0f0 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 823c200:	01c07fc4 	movi	r7,511
 823c204:	01800044 	movi	r6,1
 823c208:	e17fff17 	ldw	r5,-4(fp)
 823c20c:	01020974 	movhi	r4,2085
 823c210:	210ee204 	addi	r4,r4,15240
 823c214:	823c0f00 	call	823c0f0 <alt_open_fd>
}  
 823c218:	0001883a 	nop
 823c21c:	e037883a 	mov	sp,fp
 823c220:	dfc00117 	ldw	ra,4(sp)
 823c224:	df000017 	ldw	fp,0(sp)
 823c228:	dec00204 	addi	sp,sp,8
 823c22c:	f800283a 	ret

0823c230 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823c230:	defffe04 	addi	sp,sp,-8
 823c234:	dfc00115 	stw	ra,4(sp)
 823c238:	df000015 	stw	fp,0(sp)
 823c23c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823c240:	d0a04717 	ldw	r2,-32484(gp)
 823c244:	10000326 	beq	r2,zero,823c254 <alt_get_errno+0x24>
 823c248:	d0a04717 	ldw	r2,-32484(gp)
 823c24c:	103ee83a 	callr	r2
 823c250:	00000106 	br	823c258 <alt_get_errno+0x28>
 823c254:	d0a06304 	addi	r2,gp,-32372
}
 823c258:	e037883a 	mov	sp,fp
 823c25c:	dfc00117 	ldw	ra,4(sp)
 823c260:	df000017 	ldw	fp,0(sp)
 823c264:	dec00204 	addi	sp,sp,8
 823c268:	f800283a 	ret

0823c26c <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 823c26c:	defffd04 	addi	sp,sp,-12
 823c270:	df000215 	stw	fp,8(sp)
 823c274:	df000204 	addi	fp,sp,8
 823c278:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 823c27c:	e0bfff17 	ldw	r2,-4(fp)
 823c280:	10800217 	ldw	r2,8(r2)
 823c284:	10d00034 	orhi	r3,r2,16384
 823c288:	e0bfff17 	ldw	r2,-4(fp)
 823c28c:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 823c290:	e03ffe15 	stw	zero,-8(fp)
 823c294:	00001d06 	br	823c30c <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 823c298:	00820974 	movhi	r2,2085
 823c29c:	108edc04 	addi	r2,r2,15216
 823c2a0:	e0fffe17 	ldw	r3,-8(fp)
 823c2a4:	18c00324 	muli	r3,r3,12
 823c2a8:	10c5883a 	add	r2,r2,r3
 823c2ac:	10c00017 	ldw	r3,0(r2)
 823c2b0:	e0bfff17 	ldw	r2,-4(fp)
 823c2b4:	10800017 	ldw	r2,0(r2)
 823c2b8:	1880111e 	bne	r3,r2,823c300 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 823c2bc:	00820974 	movhi	r2,2085
 823c2c0:	108edc04 	addi	r2,r2,15216
 823c2c4:	e0fffe17 	ldw	r3,-8(fp)
 823c2c8:	18c00324 	muli	r3,r3,12
 823c2cc:	10c5883a 	add	r2,r2,r3
 823c2d0:	10800204 	addi	r2,r2,8
 823c2d4:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 823c2d8:	1000090e 	bge	r2,zero,823c300 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 823c2dc:	e0bffe17 	ldw	r2,-8(fp)
 823c2e0:	10c00324 	muli	r3,r2,12
 823c2e4:	00820974 	movhi	r2,2085
 823c2e8:	108edc04 	addi	r2,r2,15216
 823c2ec:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 823c2f0:	e0bfff17 	ldw	r2,-4(fp)
 823c2f4:	18800226 	beq	r3,r2,823c300 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 823c2f8:	00bffcc4 	movi	r2,-13
 823c2fc:	00000806 	br	823c320 <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 823c300:	e0bffe17 	ldw	r2,-8(fp)
 823c304:	10800044 	addi	r2,r2,1
 823c308:	e0bffe15 	stw	r2,-8(fp)
 823c30c:	d0a04617 	ldw	r2,-32488(gp)
 823c310:	1007883a 	mov	r3,r2
 823c314:	e0bffe17 	ldw	r2,-8(fp)
 823c318:	18bfdf2e 	bgeu	r3,r2,823c298 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 823c31c:	0005883a 	mov	r2,zero
}
 823c320:	e037883a 	mov	sp,fp
 823c324:	df000017 	ldw	fp,0(sp)
 823c328:	dec00104 	addi	sp,sp,4
 823c32c:	f800283a 	ret

0823c330 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 823c330:	defff604 	addi	sp,sp,-40
 823c334:	dfc00915 	stw	ra,36(sp)
 823c338:	df000815 	stw	fp,32(sp)
 823c33c:	df000804 	addi	fp,sp,32
 823c340:	e13ffd15 	stw	r4,-12(fp)
 823c344:	e17ffe15 	stw	r5,-8(fp)
 823c348:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 823c34c:	00bfffc4 	movi	r2,-1
 823c350:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 823c354:	00bffb44 	movi	r2,-19
 823c358:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 823c35c:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 823c360:	d1604404 	addi	r5,gp,-32496
 823c364:	e13ffd17 	ldw	r4,-12(fp)
 823c368:	823bdc00 	call	823bdc0 <alt_find_dev>
 823c36c:	e0bff815 	stw	r2,-32(fp)
 823c370:	e0bff817 	ldw	r2,-32(fp)
 823c374:	1000051e 	bne	r2,zero,823c38c <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 823c378:	e13ffd17 	ldw	r4,-12(fp)
 823c37c:	824a0cc0 	call	824a0cc <alt_find_file>
 823c380:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 823c384:	00800044 	movi	r2,1
 823c388:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 823c38c:	e0bff817 	ldw	r2,-32(fp)
 823c390:	10002926 	beq	r2,zero,823c438 <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
 823c394:	e13ff817 	ldw	r4,-32(fp)
 823c398:	824a1d40 	call	824a1d4 <alt_get_fd>
 823c39c:	e0bff915 	stw	r2,-28(fp)
 823c3a0:	e0bff917 	ldw	r2,-28(fp)
 823c3a4:	1000030e 	bge	r2,zero,823c3b4 <open+0x84>
    {
      status = index;
 823c3a8:	e0bff917 	ldw	r2,-28(fp)
 823c3ac:	e0bffa15 	stw	r2,-24(fp)
 823c3b0:	00002306 	br	823c440 <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
 823c3b4:	e0bff917 	ldw	r2,-28(fp)
 823c3b8:	10c00324 	muli	r3,r2,12
 823c3bc:	00820974 	movhi	r2,2085
 823c3c0:	108edc04 	addi	r2,r2,15216
 823c3c4:	1885883a 	add	r2,r3,r2
 823c3c8:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 823c3cc:	e0fffe17 	ldw	r3,-8(fp)
 823c3d0:	00900034 	movhi	r2,16384
 823c3d4:	10bfffc4 	addi	r2,r2,-1
 823c3d8:	1886703a 	and	r3,r3,r2
 823c3dc:	e0bffc17 	ldw	r2,-16(fp)
 823c3e0:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 823c3e4:	e0bffb17 	ldw	r2,-20(fp)
 823c3e8:	1000051e 	bne	r2,zero,823c400 <open+0xd0>
 823c3ec:	e13ffc17 	ldw	r4,-16(fp)
 823c3f0:	823c26c0 	call	823c26c <alt_file_locked>
 823c3f4:	e0bffa15 	stw	r2,-24(fp)
 823c3f8:	e0bffa17 	ldw	r2,-24(fp)
 823c3fc:	10001016 	blt	r2,zero,823c440 <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 823c400:	e0bff817 	ldw	r2,-32(fp)
 823c404:	10800317 	ldw	r2,12(r2)
 823c408:	10000826 	beq	r2,zero,823c42c <open+0xfc>
 823c40c:	e0bff817 	ldw	r2,-32(fp)
 823c410:	10800317 	ldw	r2,12(r2)
 823c414:	e1ffff17 	ldw	r7,-4(fp)
 823c418:	e1bffe17 	ldw	r6,-8(fp)
 823c41c:	e17ffd17 	ldw	r5,-12(fp)
 823c420:	e13ffc17 	ldw	r4,-16(fp)
 823c424:	103ee83a 	callr	r2
 823c428:	00000106 	br	823c430 <open+0x100>
 823c42c:	0005883a 	mov	r2,zero
 823c430:	e0bffa15 	stw	r2,-24(fp)
 823c434:	00000206 	br	823c440 <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
 823c438:	00bffb44 	movi	r2,-19
 823c43c:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 823c440:	e0bffa17 	ldw	r2,-24(fp)
 823c444:	1000090e 	bge	r2,zero,823c46c <open+0x13c>
  {
    alt_release_fd (index);  
 823c448:	e13ff917 	ldw	r4,-28(fp)
 823c44c:	823c5bc0 	call	823c5bc <alt_release_fd>
    ALT_ERRNO = -status;
 823c450:	823c2300 	call	823c230 <alt_get_errno>
 823c454:	1007883a 	mov	r3,r2
 823c458:	e0bffa17 	ldw	r2,-24(fp)
 823c45c:	0085c83a 	sub	r2,zero,r2
 823c460:	18800015 	stw	r2,0(r3)
    return -1;
 823c464:	00bfffc4 	movi	r2,-1
 823c468:	00000106 	br	823c470 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
 823c46c:	e0bff917 	ldw	r2,-28(fp)
}
 823c470:	e037883a 	mov	sp,fp
 823c474:	dfc00117 	ldw	ra,4(sp)
 823c478:	df000017 	ldw	fp,0(sp)
 823c47c:	dec00204 	addi	sp,sp,8
 823c480:	f800283a 	ret

0823c484 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823c484:	defffe04 	addi	sp,sp,-8
 823c488:	dfc00115 	stw	ra,4(sp)
 823c48c:	df000015 	stw	fp,0(sp)
 823c490:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823c494:	d0a04717 	ldw	r2,-32484(gp)
 823c498:	10000326 	beq	r2,zero,823c4a8 <alt_get_errno+0x24>
 823c49c:	d0a04717 	ldw	r2,-32484(gp)
 823c4a0:	103ee83a 	callr	r2
 823c4a4:	00000106 	br	823c4ac <alt_get_errno+0x28>
 823c4a8:	d0a06304 	addi	r2,gp,-32372
}
 823c4ac:	e037883a 	mov	sp,fp
 823c4b0:	dfc00117 	ldw	ra,4(sp)
 823c4b4:	df000017 	ldw	fp,0(sp)
 823c4b8:	dec00204 	addi	sp,sp,8
 823c4bc:	f800283a 	ret

0823c4c0 <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 823c4c0:	defff904 	addi	sp,sp,-28
 823c4c4:	dfc00615 	stw	ra,24(sp)
 823c4c8:	df000515 	stw	fp,20(sp)
 823c4cc:	df000504 	addi	fp,sp,20
 823c4d0:	e13ffd15 	stw	r4,-12(fp)
 823c4d4:	e17ffe15 	stw	r5,-8(fp)
 823c4d8:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 823c4dc:	e0bffd17 	ldw	r2,-12(fp)
 823c4e0:	10000616 	blt	r2,zero,823c4fc <alt_read+0x3c>
 823c4e4:	e0bffd17 	ldw	r2,-12(fp)
 823c4e8:	10c00324 	muli	r3,r2,12
 823c4ec:	00820974 	movhi	r2,2085
 823c4f0:	108edc04 	addi	r2,r2,15216
 823c4f4:	1885883a 	add	r2,r3,r2
 823c4f8:	00000106 	br	823c500 <alt_read+0x40>
 823c4fc:	0005883a 	mov	r2,zero
 823c500:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 823c504:	e0bffb17 	ldw	r2,-20(fp)
 823c508:	10002226 	beq	r2,zero,823c594 <alt_read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 823c50c:	e0bffb17 	ldw	r2,-20(fp)
 823c510:	10800217 	ldw	r2,8(r2)
 823c514:	108000cc 	andi	r2,r2,3
 823c518:	10800060 	cmpeqi	r2,r2,1
 823c51c:	1000181e 	bne	r2,zero,823c580 <alt_read+0xc0>
        (fd->dev->read))
 823c520:	e0bffb17 	ldw	r2,-20(fp)
 823c524:	10800017 	ldw	r2,0(r2)
 823c528:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 823c52c:	10001426 	beq	r2,zero,823c580 <alt_read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 823c530:	e0bffb17 	ldw	r2,-20(fp)
 823c534:	10800017 	ldw	r2,0(r2)
 823c538:	10800517 	ldw	r2,20(r2)
 823c53c:	e0ffff17 	ldw	r3,-4(fp)
 823c540:	180d883a 	mov	r6,r3
 823c544:	e17ffe17 	ldw	r5,-8(fp)
 823c548:	e13ffb17 	ldw	r4,-20(fp)
 823c54c:	103ee83a 	callr	r2
 823c550:	e0bffc15 	stw	r2,-16(fp)
 823c554:	e0bffc17 	ldw	r2,-16(fp)
 823c558:	1000070e 	bge	r2,zero,823c578 <alt_read+0xb8>
        {
          ALT_ERRNO = -rval;
 823c55c:	823c4840 	call	823c484 <alt_get_errno>
 823c560:	1007883a 	mov	r3,r2
 823c564:	e0bffc17 	ldw	r2,-16(fp)
 823c568:	0085c83a 	sub	r2,zero,r2
 823c56c:	18800015 	stw	r2,0(r3)
          return -1;
 823c570:	00bfffc4 	movi	r2,-1
 823c574:	00000c06 	br	823c5a8 <alt_read+0xe8>
        }
        return rval;
 823c578:	e0bffc17 	ldw	r2,-16(fp)
 823c57c:	00000a06 	br	823c5a8 <alt_read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
 823c580:	823c4840 	call	823c484 <alt_get_errno>
 823c584:	1007883a 	mov	r3,r2
 823c588:	00800344 	movi	r2,13
 823c58c:	18800015 	stw	r2,0(r3)
 823c590:	00000406 	br	823c5a4 <alt_read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 823c594:	823c4840 	call	823c484 <alt_get_errno>
 823c598:	1007883a 	mov	r3,r2
 823c59c:	00801444 	movi	r2,81
 823c5a0:	18800015 	stw	r2,0(r3)
  }
  return -1;
 823c5a4:	00bfffc4 	movi	r2,-1
}
 823c5a8:	e037883a 	mov	sp,fp
 823c5ac:	dfc00117 	ldw	ra,4(sp)
 823c5b0:	df000017 	ldw	fp,0(sp)
 823c5b4:	dec00204 	addi	sp,sp,8
 823c5b8:	f800283a 	ret

0823c5bc <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 823c5bc:	defffe04 	addi	sp,sp,-8
 823c5c0:	df000115 	stw	fp,4(sp)
 823c5c4:	df000104 	addi	fp,sp,4
 823c5c8:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 823c5cc:	e0bfff17 	ldw	r2,-4(fp)
 823c5d0:	108000d0 	cmplti	r2,r2,3
 823c5d4:	10000d1e 	bne	r2,zero,823c60c <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 823c5d8:	00820974 	movhi	r2,2085
 823c5dc:	108edc04 	addi	r2,r2,15216
 823c5e0:	e0ffff17 	ldw	r3,-4(fp)
 823c5e4:	18c00324 	muli	r3,r3,12
 823c5e8:	10c5883a 	add	r2,r2,r3
 823c5ec:	10800204 	addi	r2,r2,8
 823c5f0:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 823c5f4:	00820974 	movhi	r2,2085
 823c5f8:	108edc04 	addi	r2,r2,15216
 823c5fc:	e0ffff17 	ldw	r3,-4(fp)
 823c600:	18c00324 	muli	r3,r3,12
 823c604:	10c5883a 	add	r2,r2,r3
 823c608:	10000015 	stw	zero,0(r2)
  }
}
 823c60c:	0001883a 	nop
 823c610:	e037883a 	mov	sp,fp
 823c614:	df000017 	ldw	fp,0(sp)
 823c618:	dec00104 	addi	sp,sp,4
 823c61c:	f800283a 	ret

0823c620 <alt_remap_cached>:
 * Return a pointer that should be used to access the cached memory.
 */

void* 
alt_remap_cached(volatile void* ptr, alt_u32 len)
{
 823c620:	defffd04 	addi	sp,sp,-12
 823c624:	df000215 	stw	fp,8(sp)
 823c628:	df000204 	addi	fp,sp,8
 823c62c:	e13ffe15 	stw	r4,-8(fp)
 823c630:	e17fff15 	stw	r5,-4(fp)
#if ALT_CPU_DCACHE_SIZE > 0
#ifdef ALT_CPU_DCACHE_BYPASS_MASK
  return (void*) (((alt_u32)ptr) & ~ALT_CPU_DCACHE_BYPASS_MASK);
 823c634:	e0fffe17 	ldw	r3,-8(fp)
 823c638:	00a00034 	movhi	r2,32768
 823c63c:	10bfffc4 	addi	r2,r2,-1
 823c640:	1884703a 	and	r2,r3,r2
#endif /* No address mask option enabled. */
#else /* No data cache */
  /* Nothing needs to be done to the pointer. */
  return (void*) ptr;
#endif /* No data cache */
}
 823c644:	e037883a 	mov	sp,fp
 823c648:	df000017 	ldw	fp,0(sp)
 823c64c:	dec00104 	addi	sp,sp,4
 823c650:	f800283a 	ret

0823c654 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 823c654:	defffa04 	addi	sp,sp,-24
 823c658:	df000515 	stw	fp,20(sp)
 823c65c:	df000504 	addi	fp,sp,20
 823c660:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 823c664:	0005303a 	rdctl	r2,status
 823c668:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 823c66c:	e0fffc17 	ldw	r3,-16(fp)
 823c670:	00bfff84 	movi	r2,-2
 823c674:	1884703a 	and	r2,r3,r2
 823c678:	1001703a 	wrctl	status,r2
  
  return context;
 823c67c:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 823c680:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 823c684:	e0bfff17 	ldw	r2,-4(fp)
 823c688:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 823c68c:	e0bffd17 	ldw	r2,-12(fp)
 823c690:	10800017 	ldw	r2,0(r2)
 823c694:	e0fffd17 	ldw	r3,-12(fp)
 823c698:	18c00117 	ldw	r3,4(r3)
 823c69c:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 823c6a0:	e0bffd17 	ldw	r2,-12(fp)
 823c6a4:	10800117 	ldw	r2,4(r2)
 823c6a8:	e0fffd17 	ldw	r3,-12(fp)
 823c6ac:	18c00017 	ldw	r3,0(r3)
 823c6b0:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 823c6b4:	e0bffd17 	ldw	r2,-12(fp)
 823c6b8:	e0fffd17 	ldw	r3,-12(fp)
 823c6bc:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 823c6c0:	e0bffd17 	ldw	r2,-12(fp)
 823c6c4:	e0fffd17 	ldw	r3,-12(fp)
 823c6c8:	10c00015 	stw	r3,0(r2)
 823c6cc:	e0bffb17 	ldw	r2,-20(fp)
 823c6d0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 823c6d4:	e0bffe17 	ldw	r2,-8(fp)
 823c6d8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 823c6dc:	0001883a 	nop
 823c6e0:	e037883a 	mov	sp,fp
 823c6e4:	df000017 	ldw	fp,0(sp)
 823c6e8:	dec00104 	addi	sp,sp,4
 823c6ec:	f800283a 	ret

0823c6f0 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 823c6f0:	defffb04 	addi	sp,sp,-20
 823c6f4:	dfc00415 	stw	ra,16(sp)
 823c6f8:	df000315 	stw	fp,12(sp)
 823c6fc:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 823c700:	d0a04917 	ldw	r2,-32476(gp)
 823c704:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 823c708:	d0a0b917 	ldw	r2,-32028(gp)
 823c70c:	10800044 	addi	r2,r2,1
 823c710:	d0a0b915 	stw	r2,-32028(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 823c714:	00002e06 	br	823c7d0 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 823c718:	e0bffd17 	ldw	r2,-12(fp)
 823c71c:	10800017 	ldw	r2,0(r2)
 823c720:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 823c724:	e0bffd17 	ldw	r2,-12(fp)
 823c728:	10800403 	ldbu	r2,16(r2)
 823c72c:	10803fcc 	andi	r2,r2,255
 823c730:	10000426 	beq	r2,zero,823c744 <alt_tick+0x54>
 823c734:	d0a0b917 	ldw	r2,-32028(gp)
 823c738:	1000021e 	bne	r2,zero,823c744 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 823c73c:	e0bffd17 	ldw	r2,-12(fp)
 823c740:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 823c744:	e0bffd17 	ldw	r2,-12(fp)
 823c748:	10800217 	ldw	r2,8(r2)
 823c74c:	d0e0b917 	ldw	r3,-32028(gp)
 823c750:	18801d36 	bltu	r3,r2,823c7c8 <alt_tick+0xd8>
 823c754:	e0bffd17 	ldw	r2,-12(fp)
 823c758:	10800403 	ldbu	r2,16(r2)
 823c75c:	10803fcc 	andi	r2,r2,255
 823c760:	1000191e 	bne	r2,zero,823c7c8 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 823c764:	e0bffd17 	ldw	r2,-12(fp)
 823c768:	10800317 	ldw	r2,12(r2)
 823c76c:	e0fffd17 	ldw	r3,-12(fp)
 823c770:	18c00517 	ldw	r3,20(r3)
 823c774:	1809883a 	mov	r4,r3
 823c778:	103ee83a 	callr	r2
 823c77c:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 823c780:	e0bfff17 	ldw	r2,-4(fp)
 823c784:	1000031e 	bne	r2,zero,823c794 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 823c788:	e13ffd17 	ldw	r4,-12(fp)
 823c78c:	823c6540 	call	823c654 <alt_alarm_stop>
 823c790:	00000d06 	br	823c7c8 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 823c794:	e0bffd17 	ldw	r2,-12(fp)
 823c798:	10c00217 	ldw	r3,8(r2)
 823c79c:	e0bfff17 	ldw	r2,-4(fp)
 823c7a0:	1887883a 	add	r3,r3,r2
 823c7a4:	e0bffd17 	ldw	r2,-12(fp)
 823c7a8:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 823c7ac:	e0bffd17 	ldw	r2,-12(fp)
 823c7b0:	10c00217 	ldw	r3,8(r2)
 823c7b4:	d0a0b917 	ldw	r2,-32028(gp)
 823c7b8:	1880032e 	bgeu	r3,r2,823c7c8 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 823c7bc:	e0bffd17 	ldw	r2,-12(fp)
 823c7c0:	00c00044 	movi	r3,1
 823c7c4:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 823c7c8:	e0bffe17 	ldw	r2,-8(fp)
 823c7cc:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 823c7d0:	e0fffd17 	ldw	r3,-12(fp)
 823c7d4:	d0a04904 	addi	r2,gp,-32476
 823c7d8:	18bfcf1e 	bne	r3,r2,823c718 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 823c7dc:	82157f40 	call	82157f4 <OSTimeTick>
}
 823c7e0:	0001883a 	nop
 823c7e4:	e037883a 	mov	sp,fp
 823c7e8:	dfc00117 	ldw	ra,4(sp)
 823c7ec:	df000017 	ldw	fp,0(sp)
 823c7f0:	dec00204 	addi	sp,sp,8
 823c7f4:	f800283a 	ret

0823c7f8 <alt_uncached_free>:
 * Free a block of uncached memory.
 */

void 
alt_uncached_free(volatile void* ptr)
{
 823c7f8:	defffd04 	addi	sp,sp,-12
 823c7fc:	dfc00215 	stw	ra,8(sp)
 823c800:	df000115 	stw	fp,4(sp)
 823c804:	df000104 	addi	fp,sp,4
 823c808:	e13fff15 	stw	r4,-4(fp)
#if ALT_CPU_DCACHE_SIZE > 0
#ifdef ALT_CPU_DCACHE_BYPASS_MASK
  free((void*) (((alt_u32)ptr) & ~ALT_CPU_DCACHE_BYPASS_MASK));
 823c80c:	e0ffff17 	ldw	r3,-4(fp)
 823c810:	00a00034 	movhi	r2,32768
 823c814:	10bfffc4 	addi	r2,r2,-1
 823c818:	1884703a 	and	r2,r3,r2
 823c81c:	1009883a 	mov	r4,r2
 823c820:	824b6a40 	call	824b6a4 <free>
#endif /* No address mask option enabled. */
#else /* No data cache */
  /* Nothing needs to be done to the pointer. */
  free((void*)ptr);
#endif /* No data cache */
}
 823c824:	0001883a 	nop
 823c828:	e037883a 	mov	sp,fp
 823c82c:	dfc00117 	ldw	ra,4(sp)
 823c830:	df000017 	ldw	fp,0(sp)
 823c834:	dec00204 	addi	sp,sp,8
 823c838:	f800283a 	ret

0823c83c <alt_uncached_malloc>:
 * Return pointer to the block of memory or NULL if can't allocate it.
 */

volatile void* 
alt_uncached_malloc(size_t size)
{
 823c83c:	defffa04 	addi	sp,sp,-24
 823c840:	dfc00515 	stw	ra,20(sp)
 823c844:	df000415 	stw	fp,16(sp)
 823c848:	df000404 	addi	fp,sp,16
 823c84c:	e13fff15 	stw	r4,-4(fp)

  void* ptr;

  /* Round up size to an integer number of data cache lines. Required to guarantee that
   * cacheable and non-cacheable data won't be mixed on the same cache line. */ 
  const size_t num_lines = (size + ALT_CPU_DCACHE_LINE_SIZE - 1) / ALT_CPU_DCACHE_LINE_SIZE;
 823c850:	e0bfff17 	ldw	r2,-4(fp)
 823c854:	108007c4 	addi	r2,r2,31
 823c858:	1004d17a 	srli	r2,r2,5
 823c85c:	e0bffc15 	stw	r2,-16(fp)
  const size_t aligned_size = num_lines * ALT_CPU_DCACHE_LINE_SIZE;
 823c860:	e0bffc17 	ldw	r2,-16(fp)
 823c864:	1004917a 	slli	r2,r2,5
 823c868:	e0bffd15 	stw	r2,-12(fp)

  /* Use memalign() Newlib routine to allocate starting on a data cache aligned address.
   * Required to guarantee that cacheable and non-cacheable data won't be mixed on the
   * same cache line. */ 
  ptr = memalign(ALT_CPU_DCACHE_LINE_SIZE, aligned_size);
 823c86c:	e17ffd17 	ldw	r5,-12(fp)
 823c870:	01000804 	movi	r4,32
 823c874:	824b4e00 	call	824b4e0 <memalign>
 823c878:	e0bffe15 	stw	r2,-8(fp)

  if (ptr == NULL) {
 823c87c:	e0bffe17 	ldw	r2,-8(fp)
 823c880:	1000021e 	bne	r2,zero,823c88c <alt_uncached_malloc+0x50>
    return NULL; /* Out of memory */
 823c884:	0005883a 	mov	r2,zero
 823c888:	00000506 	br	823c8a0 <alt_uncached_malloc+0x64>
  }

  /* Ensure that the memory region isn't in the data cache. */
  alt_dcache_flush(ptr, aligned_size);
 823c88c:	e17ffd17 	ldw	r5,-12(fp)
 823c890:	e13ffe17 	ldw	r4,-8(fp)
 823c894:	823bb7c0 	call	823bb7c <alt_dcache_flush>

  return (volatile void*) (((alt_u32)ptr) | ALT_CPU_DCACHE_BYPASS_MASK);
 823c898:	e0bffe17 	ldw	r2,-8(fp)
 823c89c:	10a00034 	orhi	r2,r2,32768
#endif /* No address mask option enabled. */
#else /* No data cache */
  /* Just use regular malloc. */
  return malloc(size);
#endif /* No data cache */
}
 823c8a0:	e037883a 	mov	sp,fp
 823c8a4:	dfc00117 	ldw	ra,4(sp)
 823c8a8:	df000017 	ldw	fp,0(sp)
 823c8ac:	dec00204 	addi	sp,sp,8
 823c8b0:	f800283a 	ret

0823c8b4 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 823c8b4:	defffa04 	addi	sp,sp,-24
 823c8b8:	dfc00515 	stw	ra,20(sp)
 823c8bc:	df000415 	stw	fp,16(sp)
 823c8c0:	dc000315 	stw	r16,12(sp)
 823c8c4:	df000404 	addi	fp,sp,16
 823c8c8:	e13ffe15 	stw	r4,-8(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
 823c8cc:	d0a06b43 	ldbu	r2,-32339(gp)
 823c8d0:	10803fcc 	andi	r2,r2,255
 823c8d4:	1000031e 	bne	r2,zero,823c8e4 <usleep+0x30>
  {
    return alt_busy_sleep (us);
 823c8d8:	e13ffe17 	ldw	r4,-8(fp)
 823c8dc:	8249e180 	call	8249e18 <alt_busy_sleep>
 823c8e0:	00003306 	br	823c9b0 <usleep+0xfc>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 823c8e4:	d0a0b817 	ldw	r2,-32032(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
 823c8e8:	e0bffd15 	stw	r2,-12(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
 823c8ec:	e0bffe17 	ldw	r2,-8(fp)
 823c8f0:	014003f4 	movhi	r5,15
 823c8f4:	29509004 	addi	r5,r5,16960
 823c8f8:	1009883a 	mov	r4,r2
 823c8fc:	8202b8c0 	call	8202b8c <__udivsi3>
 823c900:	1007883a 	mov	r3,r2
 823c904:	e0bffd17 	ldw	r2,-12(fp)
 823c908:	18a1383a 	mul	r16,r3,r2
 823c90c:	e0bffe17 	ldw	r2,-8(fp)
 823c910:	014003f4 	movhi	r5,15
 823c914:	29509004 	addi	r5,r5,16960
 823c918:	1009883a 	mov	r4,r2
 823c91c:	8202bf00 	call	8202bf0 <__umodsi3>
 823c920:	1007883a 	mov	r3,r2
 823c924:	e0bffd17 	ldw	r2,-12(fp)
 823c928:	1885383a 	mul	r2,r3,r2
 823c92c:	014003f4 	movhi	r5,15
 823c930:	29509004 	addi	r5,r5,16960
 823c934:	1009883a 	mov	r4,r2
 823c938:	8202b8c0 	call	8202b8c <__udivsi3>
 823c93c:	8085883a 	add	r2,r16,r2
 823c940:	e0bffc15 	stw	r2,-16(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 823c944:	00000706 	br	823c964 <usleep+0xb0>
  {
    OSTimeDly(0xffff);
 823c948:	013fffd4 	movui	r4,65535
 823c94c:	821be3c0 	call	821be3c <OSTimeDly>
    ticks -= 0xffff;
 823c950:	e0fffc17 	ldw	r3,-16(fp)
 823c954:	00bffff4 	movhi	r2,65535
 823c958:	10800044 	addi	r2,r2,1
 823c95c:	1885883a 	add	r2,r3,r2
 823c960:	e0bffc15 	stw	r2,-16(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 823c964:	e0bffc17 	ldw	r2,-16(fp)
 823c968:	00ffffd4 	movui	r3,65535
 823c96c:	18bff636 	bltu	r3,r2,823c948 <usleep+0x94>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
 823c970:	e0bffc17 	ldw	r2,-16(fp)
 823c974:	10bfffcc 	andi	r2,r2,65535
 823c978:	1009883a 	mov	r4,r2
 823c97c:	821be3c0 	call	821be3c <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
 823c980:	e17ffd17 	ldw	r5,-12(fp)
 823c984:	010003f4 	movhi	r4,15
 823c988:	21109004 	addi	r4,r4,16960
 823c98c:	8202b8c0 	call	8202b8c <__udivsi3>
 823c990:	1007883a 	mov	r3,r2
 823c994:	e0bffe17 	ldw	r2,-8(fp)
 823c998:	180b883a 	mov	r5,r3
 823c99c:	1009883a 	mov	r4,r2
 823c9a0:	8202bf00 	call	8202bf0 <__umodsi3>
 823c9a4:	1009883a 	mov	r4,r2
 823c9a8:	8249e180 	call	8249e18 <alt_busy_sleep>

  return 0;  
 823c9ac:	0005883a 	mov	r2,zero
}
 823c9b0:	e6ffff04 	addi	sp,fp,-4
 823c9b4:	dfc00217 	ldw	ra,8(sp)
 823c9b8:	df000117 	ldw	fp,4(sp)
 823c9bc:	dc000017 	ldw	r16,0(sp)
 823c9c0:	dec00304 	addi	sp,sp,12
 823c9c4:	f800283a 	ret

0823c9c8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 823c9c8:	defffe04 	addi	sp,sp,-8
 823c9cc:	dfc00115 	stw	ra,4(sp)
 823c9d0:	df000015 	stw	fp,0(sp)
 823c9d4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 823c9d8:	d0a04717 	ldw	r2,-32484(gp)
 823c9dc:	10000326 	beq	r2,zero,823c9ec <alt_get_errno+0x24>
 823c9e0:	d0a04717 	ldw	r2,-32484(gp)
 823c9e4:	103ee83a 	callr	r2
 823c9e8:	00000106 	br	823c9f0 <alt_get_errno+0x28>
 823c9ec:	d0a06304 	addi	r2,gp,-32372
}
 823c9f0:	e037883a 	mov	sp,fp
 823c9f4:	dfc00117 	ldw	ra,4(sp)
 823c9f8:	df000017 	ldw	fp,0(sp)
 823c9fc:	dec00204 	addi	sp,sp,8
 823ca00:	f800283a 	ret

0823ca04 <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 823ca04:	defff904 	addi	sp,sp,-28
 823ca08:	dfc00615 	stw	ra,24(sp)
 823ca0c:	df000515 	stw	fp,20(sp)
 823ca10:	df000504 	addi	fp,sp,20
 823ca14:	e13ffd15 	stw	r4,-12(fp)
 823ca18:	e17ffe15 	stw	r5,-8(fp)
 823ca1c:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 823ca20:	e0bffd17 	ldw	r2,-12(fp)
 823ca24:	10000616 	blt	r2,zero,823ca40 <alt_write+0x3c>
 823ca28:	e0bffd17 	ldw	r2,-12(fp)
 823ca2c:	10c00324 	muli	r3,r2,12
 823ca30:	00820974 	movhi	r2,2085
 823ca34:	108edc04 	addi	r2,r2,15216
 823ca38:	1885883a 	add	r2,r3,r2
 823ca3c:	00000106 	br	823ca44 <alt_write+0x40>
 823ca40:	0005883a 	mov	r2,zero
 823ca44:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 823ca48:	e0bffb17 	ldw	r2,-20(fp)
 823ca4c:	10002126 	beq	r2,zero,823cad4 <alt_write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 823ca50:	e0bffb17 	ldw	r2,-20(fp)
 823ca54:	10800217 	ldw	r2,8(r2)
 823ca58:	108000cc 	andi	r2,r2,3
 823ca5c:	10001826 	beq	r2,zero,823cac0 <alt_write+0xbc>
 823ca60:	e0bffb17 	ldw	r2,-20(fp)
 823ca64:	10800017 	ldw	r2,0(r2)
 823ca68:	10800617 	ldw	r2,24(r2)
 823ca6c:	10001426 	beq	r2,zero,823cac0 <alt_write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 823ca70:	e0bffb17 	ldw	r2,-20(fp)
 823ca74:	10800017 	ldw	r2,0(r2)
 823ca78:	10800617 	ldw	r2,24(r2)
 823ca7c:	e0ffff17 	ldw	r3,-4(fp)
 823ca80:	180d883a 	mov	r6,r3
 823ca84:	e17ffe17 	ldw	r5,-8(fp)
 823ca88:	e13ffb17 	ldw	r4,-20(fp)
 823ca8c:	103ee83a 	callr	r2
 823ca90:	e0bffc15 	stw	r2,-16(fp)
 823ca94:	e0bffc17 	ldw	r2,-16(fp)
 823ca98:	1000070e 	bge	r2,zero,823cab8 <alt_write+0xb4>
      {
        ALT_ERRNO = -rval;
 823ca9c:	823c9c80 	call	823c9c8 <alt_get_errno>
 823caa0:	1007883a 	mov	r3,r2
 823caa4:	e0bffc17 	ldw	r2,-16(fp)
 823caa8:	0085c83a 	sub	r2,zero,r2
 823caac:	18800015 	stw	r2,0(r3)
        return -1;
 823cab0:	00bfffc4 	movi	r2,-1
 823cab4:	00000c06 	br	823cae8 <alt_write+0xe4>
      }
      return rval;
 823cab8:	e0bffc17 	ldw	r2,-16(fp)
 823cabc:	00000a06 	br	823cae8 <alt_write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 823cac0:	823c9c80 	call	823c9c8 <alt_get_errno>
 823cac4:	1007883a 	mov	r3,r2
 823cac8:	00800344 	movi	r2,13
 823cacc:	18800015 	stw	r2,0(r3)
 823cad0:	00000406 	br	823cae4 <alt_write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 823cad4:	823c9c80 	call	823c9c8 <alt_get_errno>
 823cad8:	1007883a 	mov	r3,r2
 823cadc:	00801444 	movi	r2,81
 823cae0:	18800015 	stw	r2,0(r3)
  }
  return -1;
 823cae4:	00bfffc4 	movi	r2,-1
}
 823cae8:	e037883a 	mov	sp,fp
 823caec:	dfc00117 	ldw	ra,4(sp)
 823caf0:	df000017 	ldw	fp,0(sp)
 823caf4:	dec00204 	addi	sp,sp,8
 823caf8:	f800283a 	ret

0823cafc <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 823cafc:	deffff04 	addi	sp,sp,-4
 823cb00:	df000015 	stw	fp,0(sp)
 823cb04:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 823cb08:	000170fa 	wrctl	ienable,zero
}
 823cb0c:	0001883a 	nop
 823cb10:	e037883a 	mov	sp,fp
 823cb14:	df000017 	ldw	fp,0(sp)
 823cb18:	dec00104 	addi	sp,sp,4
 823cb1c:	f800283a 	ret

0823cb20 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
 823cb20:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
 823cb24:	d0e00217 	ldw	r3,-32760(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
 823cb28:	d1207a17 	ldw	r4,-32280(gp)

      stw ra,  0(sp)
 823cb2c:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
 823cb30:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
 823cb34:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
 823cb38:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
 823cb3c:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
 823cb40:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
 823cb44:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
 823cb48:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
 823cb4c:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
 823cb50:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
 823cb54:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
 823cb58:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 823cb5c:	823cd940 	call	823cd94 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
 823cb60:	d1207517 	ldw	r4,-32300(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
 823cb64:	d1606d07 	ldb	r5,-32332(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
 823cb68:	d1207a15 	stw	r4,-32280(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
 823cb6c:	d1606d45 	stb	r5,-32331(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
 823cb70:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
 823cb74:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
 823cb78:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
 823cb7c:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
 823cb80:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
 823cb84:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
 823cb88:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
 823cb8c:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
 823cb90:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
 823cb94:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
 823cb98:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
 823cb9c:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
 823cba0:	d0e00215 	stw	r3,-32760(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
 823cba4:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
 823cba8:	f800283a 	ret

0823cbac <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
 823cbac:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
 823cbb0:	047fff84 	movi	r17,-2
      and   r18, r18, r17
 823cbb4:	9464703a 	and	r18,r18,r17
      wrctl status, r18
 823cbb8:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 823cbbc:	823cd940 	call	823cd94 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
 823cbc0:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
 823cbc4:	d4a06b45 	stb	r18,-32339(gp)

      /*
       * start execution of the new task.
       */

      br 9b
 823cbc8:	003fe506 	br	823cb60 <OSCtxSw+0x40>

0823cbcc <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
 823cbcc:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
 823cbd0:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
 823cbd4:	10800054 	ori	r2,r2,1
      wrctl status, r2
 823cbd8:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
 823cbdc:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
 823cbe0:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
 823cbe4:	dec00204 	addi	sp,sp,8

      callr r2
 823cbe8:	103ee83a 	callr	r2

      nop
 823cbec:	0001883a 	nop

0823cbf0 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
 823cbf0:	defff704 	addi	sp,sp,-36
 823cbf4:	dfc00815 	stw	ra,32(sp)
 823cbf8:	df000715 	stw	fp,28(sp)
 823cbfc:	df000704 	addi	fp,sp,28
 823cc00:	e13ffc15 	stw	r4,-16(fp)
 823cc04:	e17ffd15 	stw	r5,-12(fp)
 823cc08:	e1bffe15 	stw	r6,-8(fp)
 823cc0c:	3805883a 	mov	r2,r7
 823cc10:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
 823cc14:	e0fffe17 	ldw	r3,-8(fp)
 823cc18:	00bfff04 	movi	r2,-4
 823cc1c:	1884703a 	and	r2,r3,r2
 823cc20:	10bef704 	addi	r2,r2,-1060
 823cc24:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
 823cc28:	01810904 	movi	r6,1060
 823cc2c:	000b883a 	mov	r5,zero
 823cc30:	e13ff917 	ldw	r4,-28(fp)
 823cc34:	82031300 	call	8203130 <memset>
 823cc38:	e0bff917 	ldw	r2,-28(fp)
 823cc3c:	10c0bb04 	addi	r3,r2,748
 823cc40:	e0bff917 	ldw	r2,-28(fp)
 823cc44:	10c00115 	stw	r3,4(r2)
 823cc48:	e0bff917 	ldw	r2,-28(fp)
 823cc4c:	10c0d504 	addi	r3,r2,852
 823cc50:	e0bff917 	ldw	r2,-28(fp)
 823cc54:	10c00215 	stw	r3,8(r2)
 823cc58:	e0bff917 	ldw	r2,-28(fp)
 823cc5c:	10c0ef04 	addi	r3,r2,956
 823cc60:	e0bff917 	ldw	r2,-28(fp)
 823cc64:	10c00315 	stw	r3,12(r2)
 823cc68:	e0fff917 	ldw	r3,-28(fp)
 823cc6c:	00820974 	movhi	r2,2085
 823cc70:	1083d204 	addi	r2,r2,3912
 823cc74:	18800d15 	stw	r2,52(r3)
 823cc78:	e0bff917 	ldw	r2,-28(fp)
 823cc7c:	00c00044 	movi	r3,1
 823cc80:	10c02915 	stw	r3,164(r2)
 823cc84:	10002a15 	stw	zero,168(r2)
 823cc88:	e0bff917 	ldw	r2,-28(fp)
 823cc8c:	00ccc384 	movi	r3,13070
 823cc90:	10c02b0d 	sth	r3,172(r2)
 823cc94:	e0bff917 	ldw	r2,-28(fp)
 823cc98:	00eaf344 	movi	r3,-21555
 823cc9c:	10c02b8d 	sth	r3,174(r2)
 823cca0:	e0bff917 	ldw	r2,-28(fp)
 823cca4:	00c48d04 	movi	r3,4660
 823cca8:	10c02c0d 	sth	r3,176(r2)
 823ccac:	e0bff917 	ldw	r2,-28(fp)
 823ccb0:	00f99b44 	movi	r3,-6547
 823ccb4:	10c02c8d 	sth	r3,178(r2)
 823ccb8:	e0bff917 	ldw	r2,-28(fp)
 823ccbc:	00f7bb04 	movi	r3,-8468
 823ccc0:	10c02d0d 	sth	r3,180(r2)
 823ccc4:	e0bff917 	ldw	r2,-28(fp)
 823ccc8:	00c00144 	movi	r3,5
 823cccc:	10c02d8d 	sth	r3,182(r2)
 823ccd0:	e0bff917 	ldw	r2,-28(fp)
 823ccd4:	00c002c4 	movi	r3,11
 823ccd8:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
 823ccdc:	e0bff917 	ldw	r2,-28(fp)
 823cce0:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
 823cce4:	e0bffa17 	ldw	r2,-24(fp)
 823cce8:	10bff304 	addi	r2,r2,-52
 823ccec:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
 823ccf0:	e0bffb17 	ldw	r2,-20(fp)
 823ccf4:	10800c04 	addi	r2,r2,48
 823ccf8:	e0fffc17 	ldw	r3,-16(fp)
 823ccfc:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
 823cd00:	e0bffb17 	ldw	r2,-20(fp)
 823cd04:	10800b04 	addi	r2,r2,44
 823cd08:	e0fffd17 	ldw	r3,-12(fp)
 823cd0c:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
 823cd10:	e0bffb17 	ldw	r2,-20(fp)
 823cd14:	10800a04 	addi	r2,r2,40
 823cd18:	e0fff917 	ldw	r3,-28(fp)
 823cd1c:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
 823cd20:	00820934 	movhi	r2,2084
 823cd24:	10b2f304 	addi	r2,r2,-13364
 823cd28:	10c00104 	addi	r3,r2,4
 823cd2c:	e0bffb17 	ldw	r2,-20(fp)
 823cd30:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
 823cd34:	e0bffb17 	ldw	r2,-20(fp)
}
 823cd38:	e037883a 	mov	sp,fp
 823cd3c:	dfc00117 	ldw	ra,4(sp)
 823cd40:	df000017 	ldw	fp,0(sp)
 823cd44:	dec00204 	addi	sp,sp,8
 823cd48:	f800283a 	ret

0823cd4c <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
 823cd4c:	defffe04 	addi	sp,sp,-8
 823cd50:	df000115 	stw	fp,4(sp)
 823cd54:	df000104 	addi	fp,sp,4
 823cd58:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
 823cd5c:	0001883a 	nop
 823cd60:	e037883a 	mov	sp,fp
 823cd64:	df000017 	ldw	fp,0(sp)
 823cd68:	dec00104 	addi	sp,sp,4
 823cd6c:	f800283a 	ret

0823cd70 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
 823cd70:	defffe04 	addi	sp,sp,-8
 823cd74:	df000115 	stw	fp,4(sp)
 823cd78:	df000104 	addi	fp,sp,4
 823cd7c:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
 823cd80:	0001883a 	nop
 823cd84:	e037883a 	mov	sp,fp
 823cd88:	df000017 	ldw	fp,0(sp)
 823cd8c:	dec00104 	addi	sp,sp,4
 823cd90:	f800283a 	ret

0823cd94 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
 823cd94:	deffff04 	addi	sp,sp,-4
 823cd98:	df000015 	stw	fp,0(sp)
 823cd9c:	d839883a 	mov	fp,sp
}
 823cda0:	0001883a 	nop
 823cda4:	e037883a 	mov	sp,fp
 823cda8:	df000017 	ldw	fp,0(sp)
 823cdac:	dec00104 	addi	sp,sp,4
 823cdb0:	f800283a 	ret

0823cdb4 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
 823cdb4:	deffff04 	addi	sp,sp,-4
 823cdb8:	df000015 	stw	fp,0(sp)
 823cdbc:	d839883a 	mov	fp,sp
}
 823cdc0:	0001883a 	nop
 823cdc4:	e037883a 	mov	sp,fp
 823cdc8:	df000017 	ldw	fp,0(sp)
 823cdcc:	dec00104 	addi	sp,sp,4
 823cdd0:	f800283a 	ret

0823cdd4 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
 823cdd4:	defffe04 	addi	sp,sp,-8
 823cdd8:	dfc00115 	stw	ra,4(sp)
 823cddc:	df000015 	stw	fp,0(sp)
 823cde0:	d839883a 	mov	fp,sp
    }
#endif  
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
 823cde4:	822d5900 	call	822d590 <cticks_hook>
#endif
}
 823cde8:	0001883a 	nop
 823cdec:	e037883a 	mov	sp,fp
 823cdf0:	dfc00117 	ldw	ra,4(sp)
 823cdf4:	df000017 	ldw	fp,0(sp)
 823cdf8:	dec00204 	addi	sp,sp,8
 823cdfc:	f800283a 	ret

0823ce00 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
 823ce00:	deffff04 	addi	sp,sp,-4
 823ce04:	df000015 	stw	fp,0(sp)
 823ce08:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
#endif
}
 823ce0c:	0001883a 	nop
 823ce10:	e037883a 	mov	sp,fp
 823ce14:	df000017 	ldw	fp,0(sp)
 823ce18:	dec00104 	addi	sp,sp,4
 823ce1c:	f800283a 	ret

0823ce20 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
 823ce20:	deffff04 	addi	sp,sp,-4
 823ce24:	df000015 	stw	fp,0(sp)
 823ce28:	d839883a 	mov	fp,sp
}
 823ce2c:	0001883a 	nop
 823ce30:	e037883a 	mov	sp,fp
 823ce34:	df000017 	ldw	fp,0(sp)
 823ce38:	dec00104 	addi	sp,sp,4
 823ce3c:	f800283a 	ret

0823ce40 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
 823ce40:	deffff04 	addi	sp,sp,-4
 823ce44:	df000015 	stw	fp,0(sp)
 823ce48:	d839883a 	mov	fp,sp
}
 823ce4c:	0001883a 	nop
 823ce50:	e037883a 	mov	sp,fp
 823ce54:	df000017 	ldw	fp,0(sp)
 823ce58:	dec00104 	addi	sp,sp,4
 823ce5c:	f800283a 	ret

0823ce60 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
 823ce60:	defffe04 	addi	sp,sp,-8
 823ce64:	df000115 	stw	fp,4(sp)
 823ce68:	df000104 	addi	fp,sp,4
 823ce6c:	e13fff15 	stw	r4,-4(fp)
}
 823ce70:	0001883a 	nop
 823ce74:	e037883a 	mov	sp,fp
 823ce78:	df000017 	ldw	fp,0(sp)
 823ce7c:	dec00104 	addi	sp,sp,4
 823ce80:	f800283a 	ret

0823ce84 <netmain_init>:
 * RETURNS: 
 */

void 
netmain_init(void)
{
 823ce84:	defffb04 	addi	sp,sp,-20
 823ce88:	dfc00415 	stw	ra,16(sp)
 823ce8c:	df000315 	stw	fp,12(sp)
 823ce90:	dc000215 	stw	r16,8(sp)
 823ce94:	df000304 	addi	fp,sp,12
   int   e = 0;
 823ce98:	e03ffd15 	stw	zero,-12(fp)
   char *   msg;
#ifdef IP_V6
   ip6_addr host;
#endif

   printf("%s\n", name);
 823ce9c:	d0a04b17 	ldw	r2,-32468(gp)
 823cea0:	1009883a 	mov	r4,r2
 823cea4:	82035a00 	call	82035a0 <puts>
   printf("Copyright 1996-2008 by InterNiche Technologies. All rights reserved. \n");
 823cea8:	01020974 	movhi	r4,2085
 823ceac:	2103de04 	addi	r4,r4,3960
 823ceb0:	82035a00 	call	82035a0 <puts>
#ifdef IN_MENUS
   install_version("allports3.1");
#endif
#ifndef SUPERLOOP
   /* call this to do pre-task setup including intialization of port_prep */
   msg = pre_task_setup();
 823ceb4:	822dd5c0 	call	822dd5c <pre_task_setup>
 823ceb8:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 823cebc:	e0bffe17 	ldw	r2,-8(fp)
 823cec0:	10000226 	beq	r2,zero,823cecc <netmain_init+0x48>
      panic(msg);
 823cec4:	e13ffe17 	ldw	r4,-8(fp)
 823cec8:	8228aec0 	call	8228aec <panic>
      printf("global_log_create() failed\n");
   }
   glog_with_type(LOG_TYPE_INFO, "INICHE LOG initialized", 1);
#endif

   msg = ip_startup();
 823cecc:	82267c00 	call	82267c0 <ip_startup>
 823ced0:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 823ced4:	e0bffe17 	ldw	r2,-8(fp)
 823ced8:	10000726 	beq	r2,zero,823cef8 <netmain_init+0x74>
   {
      printf("inet startup error: %s\n", msg);
 823cedc:	e17ffe17 	ldw	r5,-8(fp)
 823cee0:	01020974 	movhi	r4,2085
 823cee4:	2103f004 	addi	r4,r4,4032
 823cee8:	820331c0 	call	820331c <printf>
      panic("IP");
 823ceec:	01020974 	movhi	r4,2085
 823cef0:	2103f604 	addi	r4,r4,4056
 823cef4:	8228aec0 	call	8228aec <panic>
   }

#if defined(MEMDEV_SIZE) && defined(VFS_FILES)
   init_memdev(); /* init the mem and null test devices */
 823cef8:	8246fb40 	call	8246fb4 <init_memdev>
#endif

#ifdef IP_MULTICAST
#ifdef INCLUDE_TCP
   /* call the IP multicast test program */
   u_mctest_init();
 823cefc:	82465540 	call	8246554 <u_mctest_init>

   /* clear debugging flags. Port can optionally turn them
    * back on in post_task_setup();
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    
 823cf00:	d0208315 	stw	zero,-32244(gp)

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 823cf04:	008209b4 	movhi	r2,2086
 823cf08:	10ba6504 	addi	r2,r2,-5740
 823cf0c:	10800017 	ldw	r2,0(r2)
 823cf10:	14000104 	addi	r16,r2,4
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 823cf14:	008209b4 	movhi	r2,2086
 823cf18:	10ba6504 	addi	r2,r2,-5740
 823cf1c:	10800017 	ldw	r2,0(r2)
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 823cf20:	10800a17 	ldw	r2,40(r2)
 823cf24:	1009883a 	mov	r4,r2
 823cf28:	82289300 	call	8228930 <print_ipad>
 823cf2c:	100d883a 	mov	r6,r2
 823cf30:	800b883a 	mov	r5,r16
 823cf34:	01020974 	movhi	r4,2085
 823cf38:	2103f704 	addi	r4,r4,4060
 823cf3c:	820331c0 	call	820331c <printf>
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 
#ifndef SUPERLOOP
   /* call this per-target routine after basic tasks & net are up */
   msg = post_task_setup();
 823cf40:	822dda80 	call	822dda8 <post_task_setup>
 823cf44:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 823cf48:	e0bffe17 	ldw	r2,-8(fp)
 823cf4c:	10000226 	beq	r2,zero,823cf58 <netmain_init+0xd4>
      panic(msg);
 823cf50:	e13ffe17 	ldw	r4,-8(fp)
 823cf54:	8228aec0 	call	8228aec <panic>
#ifdef USE_AUTOIP
   Upnp_init();      /* start Auto IP before DHCP client */
#endif   /* USE_AUTOIP */

#ifdef DHCP_CLIENT
   dhc_setup();   /* kick off any DHCP clients */
 823cf58:	8246c3c0 	call	8246c3c <dhc_setup>
      panic("prep_modules");
   }
#endif
   USE_ARG(e);    /* Avoid compiler warnings */

} /* end of netmain_init() */
 823cf5c:	0001883a 	nop
 823cf60:	e6ffff04 	addi	sp,fp,-4
 823cf64:	dfc00217 	ldw	ra,8(sp)
 823cf68:	df000117 	ldw	fp,4(sp)
 823cf6c:	dc000017 	ldw	r16,0(sp)
 823cf70:	dec00304 	addi	sp,sp,12
 823cf74:	f800283a 	ret

0823cf78 <icmp_port_du>:
 * RETURNS: 
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
 823cf78:	defffb04 	addi	sp,sp,-20
 823cf7c:	dfc00415 	stw	ra,16(sp)
 823cf80:	df000315 	stw	fp,12(sp)
 823cf84:	dc000215 	stw	r16,8(sp)
 823cf88:	df000304 	addi	fp,sp,12
 823cf8c:	e13ffd15 	stw	r4,-12(fp)
 823cf90:	e17ffe15 	stw	r5,-8(fp)
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
 823cf94:	e0bffe17 	ldw	r2,-8(fp)
 823cf98:	10800003 	ldbu	r2,0(r2)
 823cf9c:	10c03fcc 	andi	r3,r2,255
 823cfa0:	18c0201c 	xori	r3,r3,128
 823cfa4:	18ffe004 	addi	r3,r3,-128
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
 823cfa8:	00820974 	movhi	r2,2085
 823cfac:	108f3c04 	addi	r2,r2,15600
 823cfb0:	18c7883a 	add	r3,r3,r3
 823cfb4:	18c7883a 	add	r3,r3,r3
 823cfb8:	10c5883a 	add	r2,r2,r3
 823cfbc:	14000017 	ldw	r16,0(r2)
 823cfc0:	e0bffd17 	ldw	r2,-12(fp)
 823cfc4:	10800717 	ldw	r2,28(r2)
 823cfc8:	1009883a 	mov	r4,r2
 823cfcc:	82289300 	call	8228930 <print_ipad>
 823cfd0:	100d883a 	mov	r6,r2
 823cfd4:	800b883a 	mov	r5,r16
 823cfd8:	01020974 	movhi	r4,2085
 823cfdc:	21040704 	addi	r4,r4,4124
 823cfe0:	820331c0 	call	820331c <printf>
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
   dprintf(prompt);
 823cfe4:	d0a04c17 	ldw	r2,-32464(gp)
 823cfe8:	1009883a 	mov	r4,r2
 823cfec:	820331c0 	call	820331c <printf>
}
 823cff0:	0001883a 	nop
 823cff4:	e6ffff04 	addi	sp,fp,-4
 823cff8:	dfc00217 	ldw	ra,8(sp)
 823cffc:	df000117 	ldw	fp,4(sp)
 823d000:	dc000017 	ldw	r16,0(sp)
 823d004:	dec00304 	addi	sp,sp,12
 823d008:	f800283a 	ret

0823d00c <station_state>:
 * RETURNS: 
 */

int
station_state(void * pio)
{
 823d00c:	defff904 	addi	sp,sp,-28
 823d010:	dfc00615 	stw	ra,24(sp)
 823d014:	df000515 	stw	fp,20(sp)
 823d018:	dc000415 	stw	r16,16(sp)
 823d01c:	df000504 	addi	fp,sp,20
 823d020:	e13ffe15 	stw	r4,-8(fp)
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 823d024:	e03ffc15 	stw	zero,-16(fp)
 823d028:	008209b4 	movhi	r2,2086
 823d02c:	10ba6504 	addi	r2,r2,-5740
 823d030:	10800017 	ldw	r2,0(r2)
 823d034:	e0bffd15 	stw	r2,-12(fp)
 823d038:	00002506 	br	823d0d0 <station_state+0xc4>
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
 823d03c:	e0bffd17 	ldw	r2,-12(fp)
 823d040:	14000104 	addi	r16,r2,4
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
 823d044:	e0bffd17 	ldw	r2,-12(fp)
 823d048:	10800a17 	ldw	r2,40(r2)
 823d04c:	1009883a 	mov	r4,r2
 823d050:	82289300 	call	8228930 <print_ipad>
 823d054:	d8800015 	stw	r2,0(sp)
 823d058:	800f883a 	mov	r7,r16
 823d05c:	e1bffc17 	ldw	r6,-16(fp)
 823d060:	01420974 	movhi	r5,2085
 823d064:	29441004 	addi	r5,r5,4160
 823d068:	e13ffe17 	ldw	r4,-8(fp)
 823d06c:	8228d040 	call	8228d04 <ns_printf>
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
 823d070:	e0bffd17 	ldw	r2,-12(fp)
 823d074:	10800c17 	ldw	r2,48(r2)
 823d078:	1009883a 	mov	r4,r2
 823d07c:	82289300 	call	8228930 <print_ipad>
 823d080:	100d883a 	mov	r6,r2
 823d084:	01420974 	movhi	r5,2085
 823d088:	29441704 	addi	r5,r5,4188
 823d08c:	e13ffe17 	ldw	r4,-8(fp)
 823d090:	8228d040 	call	8228d04 <ns_printf>
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
 823d094:	e0bffd17 	ldw	r2,-12(fp)
 823d098:	10800d17 	ldw	r2,52(r2)
 823d09c:	1009883a 	mov	r4,r2
 823d0a0:	82289300 	call	8228930 <print_ipad>
 823d0a4:	100d883a 	mov	r6,r2
 823d0a8:	01420974 	movhi	r5,2085
 823d0ac:	29441a04 	addi	r5,r5,4200
 823d0b0:	e13ffe17 	ldw	r4,-8(fp)
 823d0b4:	8228d040 	call	8228d04 <ns_printf>
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 823d0b8:	e0bffd17 	ldw	r2,-12(fp)
 823d0bc:	10800017 	ldw	r2,0(r2)
 823d0c0:	e0bffd15 	stw	r2,-12(fp)
 823d0c4:	e0bffc17 	ldw	r2,-16(fp)
 823d0c8:	10800044 	addi	r2,r2,1
 823d0cc:	e0bffc15 	stw	r2,-16(fp)
 823d0d0:	e0bffd17 	ldw	r2,-12(fp)
 823d0d4:	103fd91e 	bne	r2,zero,823d03c <station_state+0x30>
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
   }
#endif   /* NO_INET_STACK */

   ns_printf(pio, "current tick count %lu\n", cticks);
 823d0d8:	d0a0a817 	ldw	r2,-32096(gp)
 823d0dc:	100d883a 	mov	r6,r2
 823d0e0:	01420974 	movhi	r5,2085
 823d0e4:	29441d04 	addi	r5,r5,4212
 823d0e8:	e13ffe17 	ldw	r4,-8(fp)
 823d0ec:	8228d040 	call	8228d04 <ns_printf>

   ns_printf(pio, "common delay parameter:  %lu ticks (%lu ms).\n", pingdelay, (pingdelay * TIMEFOR1TICK));
 823d0f0:	d0e04d17 	ldw	r3,-32460(gp)
 823d0f4:	d0a04d17 	ldw	r2,-32460(gp)
 823d0f8:	108002a4 	muli	r2,r2,10
 823d0fc:	100f883a 	mov	r7,r2
 823d100:	180d883a 	mov	r6,r3
 823d104:	01420974 	movhi	r5,2085
 823d108:	29442304 	addi	r5,r5,4236
 823d10c:	e13ffe17 	ldw	r4,-8(fp)
 823d110:	8228d040 	call	8228d04 <ns_printf>
   ns_printf(pio, "common host parameter: %s\n", print_ipad(activehost));
 823d114:	d0a0ba17 	ldw	r2,-32024(gp)
 823d118:	1009883a 	mov	r4,r2
 823d11c:	82289300 	call	8228930 <print_ipad>
 823d120:	100d883a 	mov	r6,r2
 823d124:	01420974 	movhi	r5,2085
 823d128:	29442f04 	addi	r5,r5,4284
 823d12c:	e13ffe17 	ldw	r4,-8(fp)
 823d130:	8228d040 	call	8228d04 <ns_printf>
   ns_printf(pio, "common length parameter: %d\n", deflength);
 823d134:	d0a04e17 	ldw	r2,-32456(gp)
 823d138:	100d883a 	mov	r6,r2
 823d13c:	01420974 	movhi	r5,2085
 823d140:	29443604 	addi	r5,r5,4312
 823d144:	e13ffe17 	ldw	r4,-8(fp)
 823d148:	8228d040 	call	8228d04 <ns_printf>
#ifdef USE_PPP
   ns_printf(pio, "current dial-in user name is %s\n", pppcfg.username);
   ns_printf(pio, "current dial-in password is %s\n", pppcfg.password);
#endif   /* USE_PPP */

   task_stats(pio);
 823d14c:	e13ffe17 	ldw	r4,-8(fp)
 823d150:	823d6a80 	call	823d6a8 <task_stats>

   return 0;
 823d154:	0005883a 	mov	r2,zero
}
 823d158:	e6ffff04 	addi	sp,fp,-4
 823d15c:	dfc00217 	ldw	ra,8(sp)
 823d160:	df000117 	ldw	fp,4(sp)
 823d164:	dc000017 	ldw	r16,0(sp)
 823d168:	dec00304 	addi	sp,sp,12
 823d16c:	f800283a 	ret

0823d170 <sysuptime>:
 * RETURNS: 
 */

unsigned long
sysuptime()
{
 823d170:	defffe04 	addi	sp,sp,-8
 823d174:	dfc00115 	stw	ra,4(sp)
 823d178:	df000015 	stw	fp,0(sp)
 823d17c:	d839883a 	mov	fp,sp
   return ((cticks/TPS)*100);    /* 100ths of a sec since boot time */
 823d180:	d0a0a817 	ldw	r2,-32096(gp)
 823d184:	01401904 	movi	r5,100
 823d188:	1009883a 	mov	r4,r2
 823d18c:	8202b8c0 	call	8202b8c <__udivsi3>
 823d190:	10801924 	muli	r2,r2,100
}
 823d194:	e037883a 	mov	sp,fp
 823d198:	dfc00117 	ldw	ra,4(sp)
 823d19c:	df000017 	ldw	fp,0(sp)
 823d1a0:	dec00204 	addi	sp,sp,8
 823d1a4:	f800283a 	ret

0823d1a8 <packet_check>:

static int inside_pktdemux = 0; 

void
packet_check(void)
{
 823d1a8:	defffe04 	addi	sp,sp,-8
 823d1ac:	dfc00115 	stw	ra,4(sp)
 823d1b0:	df000015 	stw	fp,0(sp)
 823d1b4:	d839883a 	mov	fp,sp
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
 823d1b8:	d0a0bb17 	ldw	r2,-32020(gp)
 823d1bc:	1000081e 	bne	r2,zero,823d1e0 <packet_check+0x38>
      return;           /* do not re-enter pktdemux(), packet will wait... */
   inside_pktdemux++;   /* set re-entrany flag */
 823d1c0:	d0a0bb17 	ldw	r2,-32020(gp)
 823d1c4:	10800044 	addi	r2,r2,1
 823d1c8:	d0a0bb15 	stw	r2,-32020(gp)
   pktdemux();          /* process low level packet input */
 823d1cc:	82262000 	call	8226200 <pktdemux>
   inside_pktdemux--;   /* clear re-entrany flag */
 823d1d0:	d0a0bb17 	ldw	r2,-32020(gp)
 823d1d4:	10bfffc4 	addi	r2,r2,-1
 823d1d8:	d0a0bb15 	stw	r2,-32020(gp)
 823d1dc:	00000106 	br	823d1e4 <packet_check+0x3c>

void
packet_check(void)
{
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
      return;           /* do not re-enter pktdemux(), packet will wait... */
 823d1e0:	0001883a 	nop
   inside_pktdemux++;   /* set re-entrany flag */
   pktdemux();          /* process low level packet input */
   inside_pktdemux--;   /* clear re-entrany flag */
}
 823d1e4:	e037883a 	mov	sp,fp
 823d1e8:	dfc00117 	ldw	ra,4(sp)
 823d1ec:	df000017 	ldw	fp,0(sp)
 823d1f0:	dec00204 	addi	sp,sp,8
 823d1f4:	f800283a 	ret

0823d1f8 <mcastlist>:
 * RETURNS: 
 */

int
mcastlist(struct in_multi * multi_ptr)
{
 823d1f8:	defffe04 	addi	sp,sp,-8
 823d1fc:	df000115 	stw	fp,4(sp)
 823d200:	df000104 	addi	fp,sp,4
 823d204:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(multi_ptr);

   return 0;
 823d208:	0005883a 	mov	r2,zero
}
 823d20c:	e037883a 	mov	sp,fp
 823d210:	df000017 	ldw	fp,0(sp)
 823d214:	dec00104 	addi	sp,sp,4
 823d218:	f800283a 	ret

0823d21c <prep_modules>:
#ifdef USE_MODEM
extern   int   prep_modem(void);
#endif   /* USE_MODEM */

int prep_modules(void)
{
 823d21c:	defffd04 	addi	sp,sp,-12
 823d220:	dfc00215 	stw	ra,8(sp)
 823d224:	df000115 	stw	fp,4(sp)
 823d228:	df000104 	addi	fp,sp,4
#ifdef IP_V6
   ip6_addr host;
   int i;
#endif

int e = 0;
 823d22c:	e03fff15 	stw	zero,-4(fp)
      panic("prep_modules");
   }
#endif   /* SMTP_ALERTS */

#ifdef VFS_FILES
   e = prep_vfs();
 823d230:	8249df40 	call	8249df4 <prep_vfs>
 823d234:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0)
 823d238:	e0bfff17 	ldw	r2,-4(fp)
 823d23c:	10000626 	beq	r2,zero,823d258 <prep_modules+0x3c>
   {
      dprintf("VFS Module prep failed\n");
 823d240:	01020974 	movhi	r4,2085
 823d244:	21043e04 	addi	r4,r4,4344
 823d248:	82035a00 	call	82035a0 <puts>
      panic("prep_modules");
 823d24c:	01020974 	movhi	r4,2085
 823d250:	21044404 	addi	r4,r4,4368
 823d254:	8228aec0 	call	8228aec <panic>
   {
      dprintf("sslapp_init() failed\n");
      panic("prep_modules");
   }
#endif
   return 0;
 823d258:	0005883a 	mov	r2,zero
}
 823d25c:	e037883a 	mov	sp,fp
 823d260:	dfc00117 	ldw	ra,4(sp)
 823d264:	df000017 	ldw	fp,0(sp)
 823d268:	dec00204 	addi	sp,sp,8
 823d26c:	f800283a 	ret

0823d270 <inet_timer>:
 * RETURNS: 
 */

void
inet_timer(void)
{
 823d270:	defffe04 	addi	sp,sp,-8
 823d274:	dfc00115 	stw	ra,4(sp)
 823d278:	df000015 	stw	fp,0(sp)
 823d27c:	d839883a 	mov	fp,sp
#ifdef IP_FRAGMENTS
   /* run thru' the IP reassembly queue (once every second) */
   if (ire_cticks < cticks)
 823d280:	d0e0c917 	ldw	r3,-31964(gp)
 823d284:	d0a0a817 	ldw	r2,-32096(gp)
 823d288:	1880012e 	bgeu	r3,r2,823d290 <inet_timer+0x20>
      ip_reasm_process_timer_tick ();
 823d28c:	82423300 	call	8242330 <ip_reasm_process_timer_tick>
#endif

#ifdef INCLUDE_TCP
   tcp_tick();          /* run TCP timers */
 823d290:	822f8780 	call	822f878 <tcp_tick>
#endif

#ifdef INICHE_TIMERS    /* interval timers? */
   check_interval_timers();
 823d294:	823d2fc0 	call	823d2fc <check_interval_timers>
#endif

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Call igmp timeout routine */
   if (igmp_cticks < cticks)  /* Call igmp timeout routine 5 times per sec */
 823d298:	d0e08717 	ldw	r3,-32228(gp)
 823d29c:	d0a0a817 	ldw	r2,-32096(gp)
 823d2a0:	1880012e 	bgeu	r3,r2,823d2a8 <inet_timer+0x38>
      igmp_fasttimo();
 823d2a4:	8226dac0 	call	8226dac <igmp_fasttimo>
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 823d2a8:	d0e0bc17 	ldw	r3,-32016(gp)
 823d2ac:	d0a0a817 	ldw	r2,-32096(gp)
 823d2b0:	18800436 	bltu	r3,r2,823d2c4 <inet_timer+0x54>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
 823d2b4:	d0a0a817 	ldw	r2,-32096(gp)
 823d2b8:	10c0fa04 	addi	r3,r2,1000
 823d2bc:	d0a0bc17 	ldw	r2,-32016(gp)
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 823d2c0:	1880082e 	bgeu	r3,r2,823d2e4 <inet_timer+0x74>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
   {
      nextppp = cticks + TPS;
 823d2c4:	d0a0a817 	ldw	r2,-32096(gp)
 823d2c8:	10801904 	addi	r2,r2,100
 823d2cc:	d0a0bc15 	stw	r2,-32016(gp)

      if (port_1s_callout != NULL)
 823d2d0:	d0a0bd17 	ldw	r2,-32012(gp)
 823d2d4:	10000226 	beq	r2,zero,823d2e0 <inet_timer+0x70>
         (*port_1s_callout)();
 823d2d8:	d0a0bd17 	ldw	r2,-32012(gp)
 823d2dc:	103ee83a 	callr	r2

#ifdef USE_PPP
      ppp_timeisup();
#endif
#ifdef DHCP_CLIENT
      dhc_second();
 823d2e0:	822bb900 	call	822bb90 <dhc_second>
#endif
#ifdef IPSEC
      IPSecTimer();
#endif
   }
}
 823d2e4:	0001883a 	nop
 823d2e8:	e037883a 	mov	sp,fp
 823d2ec:	dfc00117 	ldw	ra,4(sp)
 823d2f0:	df000017 	ldw	fp,0(sp)
 823d2f4:	dec00204 	addi	sp,sp,8
 823d2f8:	f800283a 	ret

0823d2fc <check_interval_timers>:

static int numtimers = 0;     /* number of active timers */

static void
check_interval_timers(void)
{
 823d2fc:	defffc04 	addi	sp,sp,-16
 823d300:	dfc00315 	stw	ra,12(sp)
 823d304:	df000215 	stw	fp,8(sp)
 823d308:	df000204 	addi	fp,sp,8
   int   i;
   int   found = 0;  /* number of valid timers found */
 823d30c:	e03fff15 	stw	zero,-4(fp)

   /* if no timers, just return */
   if (numtimers > 0)
 823d310:	d0a0be17 	ldw	r2,-32008(gp)
 823d314:	0080560e 	bge	zero,r2,823d470 <check_interval_timers+0x174>
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 823d318:	e03ffe15 	stw	zero,-8(fp)
 823d31c:	00004f06 	br	823d45c <check_interval_timers+0x160>
      {
         if (intimers[i].callback)   /* is this timer active? */
 823d320:	008209b4 	movhi	r2,2086
 823d324:	10ba0c04 	addi	r2,r2,-6096
 823d328:	e0fffe17 	ldw	r3,-8(fp)
 823d32c:	18c00524 	muli	r3,r3,20
 823d330:	10c5883a 	add	r2,r2,r3
 823d334:	10800017 	ldw	r2,0(r2)
 823d338:	10004526 	beq	r2,zero,823d450 <check_interval_timers+0x154>
	 {
            if ((intimers[i].tmo < cticks) && (!intimers[i].inuse))  /* timer ready fire? */
 823d33c:	008209b4 	movhi	r2,2086
 823d340:	10ba0c04 	addi	r2,r2,-6096
 823d344:	e0fffe17 	ldw	r3,-8(fp)
 823d348:	18c00524 	muli	r3,r3,20
 823d34c:	10c5883a 	add	r2,r2,r3
 823d350:	10800304 	addi	r2,r2,12
 823d354:	10c00017 	ldw	r3,0(r2)
 823d358:	d0a0a817 	ldw	r2,-32096(gp)
 823d35c:	1880362e 	bgeu	r3,r2,823d438 <check_interval_timers+0x13c>
 823d360:	008209b4 	movhi	r2,2086
 823d364:	10ba0c04 	addi	r2,r2,-6096
 823d368:	e0fffe17 	ldw	r3,-8(fp)
 823d36c:	18c00524 	muli	r3,r3,20
 823d370:	10c5883a 	add	r2,r2,r3
 823d374:	10800404 	addi	r2,r2,16
 823d378:	10800017 	ldw	r2,0(r2)
 823d37c:	10002e1e 	bne	r2,zero,823d438 <check_interval_timers+0x13c>
            {
               intimers[i].tmo = intimers[i].interval + cticks;   /* set next tmo */
 823d380:	008209b4 	movhi	r2,2086
 823d384:	10ba0c04 	addi	r2,r2,-6096
 823d388:	e0fffe17 	ldw	r3,-8(fp)
 823d38c:	18c00524 	muli	r3,r3,20
 823d390:	10c5883a 	add	r2,r2,r3
 823d394:	10800204 	addi	r2,r2,8
 823d398:	10c00017 	ldw	r3,0(r2)
 823d39c:	d0a0a817 	ldw	r2,-32096(gp)
 823d3a0:	1887883a 	add	r3,r3,r2
 823d3a4:	008209b4 	movhi	r2,2086
 823d3a8:	10ba0c04 	addi	r2,r2,-6096
 823d3ac:	e13ffe17 	ldw	r4,-8(fp)
 823d3b0:	21000524 	muli	r4,r4,20
 823d3b4:	1105883a 	add	r2,r2,r4
 823d3b8:	10800304 	addi	r2,r2,12
 823d3bc:	10c00015 	stw	r3,0(r2)
               intimers[i].inuse = TRUE;
 823d3c0:	008209b4 	movhi	r2,2086
 823d3c4:	10ba0c04 	addi	r2,r2,-6096
 823d3c8:	e0fffe17 	ldw	r3,-8(fp)
 823d3cc:	18c00524 	muli	r3,r3,20
 823d3d0:	10c5883a 	add	r2,r2,r3
 823d3d4:	10800404 	addi	r2,r2,16
 823d3d8:	00c00044 	movi	r3,1
 823d3dc:	10c00015 	stw	r3,0(r2)
               intimers[i].callback(intimers[i].parm);      /* call user routine */
 823d3e0:	008209b4 	movhi	r2,2086
 823d3e4:	10ba0c04 	addi	r2,r2,-6096
 823d3e8:	e0fffe17 	ldw	r3,-8(fp)
 823d3ec:	18c00524 	muli	r3,r3,20
 823d3f0:	10c5883a 	add	r2,r2,r3
 823d3f4:	10c00017 	ldw	r3,0(r2)
 823d3f8:	008209b4 	movhi	r2,2086
 823d3fc:	10ba0c04 	addi	r2,r2,-6096
 823d400:	e13ffe17 	ldw	r4,-8(fp)
 823d404:	21000524 	muli	r4,r4,20
 823d408:	1105883a 	add	r2,r2,r4
 823d40c:	10800104 	addi	r2,r2,4
 823d410:	10800017 	ldw	r2,0(r2)
 823d414:	1009883a 	mov	r4,r2
 823d418:	183ee83a 	callr	r3
               intimers[i].inuse = FALSE;
 823d41c:	008209b4 	movhi	r2,2086
 823d420:	10ba0c04 	addi	r2,r2,-6096
 823d424:	e0fffe17 	ldw	r3,-8(fp)
 823d428:	18c00524 	muli	r3,r3,20
 823d42c:	10c5883a 	add	r2,r2,r3
 823d430:	10800404 	addi	r2,r2,16
 823d434:	10000015 	stw	zero,0(r2)
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
 823d438:	e0bfff17 	ldw	r2,-4(fp)
 823d43c:	10800044 	addi	r2,r2,1
 823d440:	e0bfff15 	stw	r2,-4(fp)
 823d444:	d0a0be17 	ldw	r2,-32008(gp)
 823d448:	e0ffff17 	ldw	r3,-4(fp)
 823d44c:	1880070e 	bge	r3,r2,823d46c <check_interval_timers+0x170>

   /* if no timers, just return */
   if (numtimers > 0)
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 823d450:	e0bffe17 	ldw	r2,-8(fp)
 823d454:	10800044 	addi	r2,r2,1
 823d458:	e0bffe15 	stw	r2,-8(fp)
 823d45c:	e0bffe17 	ldw	r2,-8(fp)
 823d460:	10800150 	cmplti	r2,r2,5
 823d464:	103fae1e 	bne	r2,zero,823d320 <check_interval_timers+0x24>
            if (++found >= numtimers)
               break;
         }
      }
   }
}
 823d468:	00000106 	br	823d470 <check_interval_timers+0x174>
               intimers[i].callback(intimers[i].parm);      /* call user routine */
               intimers[i].inuse = FALSE;
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
               break;
 823d46c:	0001883a 	nop
         }
      }
   }
}
 823d470:	0001883a 	nop
 823d474:	e037883a 	mov	sp,fp
 823d478:	dfc00117 	ldw	ra,4(sp)
 823d47c:	df000017 	ldw	fp,0(sp)
 823d480:	dec00204 	addi	sp,sp,8
 823d484:	f800283a 	ret

0823d488 <in_timerset>:
 * RETURNS: timer ID if OK, else if table is full.
 */

long
in_timerset(void (*callback)(long), long msecs, long parm)
{
 823d488:	defffa04 	addi	sp,sp,-24
 823d48c:	dfc00515 	stw	ra,20(sp)
 823d490:	df000415 	stw	fp,16(sp)
 823d494:	df000404 	addi	fp,sp,16
 823d498:	e13ffd15 	stw	r4,-12(fp)
 823d49c:	e17ffe15 	stw	r5,-8(fp)
 823d4a0:	e1bfff15 	stw	r6,-4(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d4a4:	e03ffc15 	stw	zero,-16(fp)
 823d4a8:	00004606 	br	823d5c4 <in_timerset+0x13c>
   {
      if(intimers[i].callback == NULL)
 823d4ac:	008209b4 	movhi	r2,2086
 823d4b0:	10ba0c04 	addi	r2,r2,-6096
 823d4b4:	e0fffc17 	ldw	r3,-16(fp)
 823d4b8:	18c00524 	muli	r3,r3,20
 823d4bc:	10c5883a 	add	r2,r2,r3
 823d4c0:	10800017 	ldw	r2,0(r2)
 823d4c4:	10003c1e 	bne	r2,zero,823d5b8 <in_timerset+0x130>
      {
         /* found empty table entry, set up new timer */
         intimers[i].callback = callback;
 823d4c8:	008209b4 	movhi	r2,2086
 823d4cc:	10ba0c04 	addi	r2,r2,-6096
 823d4d0:	e0fffc17 	ldw	r3,-16(fp)
 823d4d4:	18c00524 	muli	r3,r3,20
 823d4d8:	10c5883a 	add	r2,r2,r3
 823d4dc:	e0fffd17 	ldw	r3,-12(fp)
 823d4e0:	10c00015 	stw	r3,0(r2)
         intimers[i].parm = parm;
 823d4e4:	008209b4 	movhi	r2,2086
 823d4e8:	10ba0c04 	addi	r2,r2,-6096
 823d4ec:	e0fffc17 	ldw	r3,-16(fp)
 823d4f0:	18c00524 	muli	r3,r3,20
 823d4f4:	10c5883a 	add	r2,r2,r3
 823d4f8:	10800104 	addi	r2,r2,4
 823d4fc:	e0ffff17 	ldw	r3,-4(fp)
 823d500:	10c00015 	stw	r3,0(r2)
         /* set interval, in TPS (cticks) units */
         intimers[i].interval = (msecs * TPS)/1000;
 823d504:	e0bffe17 	ldw	r2,-8(fp)
 823d508:	10801924 	muli	r2,r2,100
 823d50c:	0140fa04 	movi	r5,1000
 823d510:	1009883a 	mov	r4,r2
 823d514:	8202a940 	call	8202a94 <__divsi3>
 823d518:	1009883a 	mov	r4,r2
 823d51c:	008209b4 	movhi	r2,2086
 823d520:	10ba0c04 	addi	r2,r2,-6096
 823d524:	e0fffc17 	ldw	r3,-16(fp)
 823d528:	18c00524 	muli	r3,r3,20
 823d52c:	10c5883a 	add	r2,r2,r3
 823d530:	10800204 	addi	r2,r2,8
 823d534:	11000015 	stw	r4,0(r2)
         intimers[i].tmo = intimers[i].interval + cticks;   /* first tmo */
 823d538:	008209b4 	movhi	r2,2086
 823d53c:	10ba0c04 	addi	r2,r2,-6096
 823d540:	e0fffc17 	ldw	r3,-16(fp)
 823d544:	18c00524 	muli	r3,r3,20
 823d548:	10c5883a 	add	r2,r2,r3
 823d54c:	10800204 	addi	r2,r2,8
 823d550:	10c00017 	ldw	r3,0(r2)
 823d554:	d0a0a817 	ldw	r2,-32096(gp)
 823d558:	1887883a 	add	r3,r3,r2
 823d55c:	008209b4 	movhi	r2,2086
 823d560:	10ba0c04 	addi	r2,r2,-6096
 823d564:	e13ffc17 	ldw	r4,-16(fp)
 823d568:	21000524 	muli	r4,r4,20
 823d56c:	1105883a 	add	r2,r2,r4
 823d570:	10800304 	addi	r2,r2,12
 823d574:	10c00015 	stw	r3,0(r2)
		 intimers[i].inuse = FALSE;
 823d578:	008209b4 	movhi	r2,2086
 823d57c:	10ba0c04 	addi	r2,r2,-6096
 823d580:	e0fffc17 	ldw	r3,-16(fp)
 823d584:	18c00524 	muli	r3,r3,20
 823d588:	10c5883a 	add	r2,r2,r3
 823d58c:	10800404 	addi	r2,r2,16
 823d590:	10000015 	stw	zero,0(r2)
         numtimers++;
 823d594:	d0a0be17 	ldw	r2,-32008(gp)
 823d598:	10800044 	addi	r2,r2,1
 823d59c:	d0a0be15 	stw	r2,-32008(gp)
         return (long)&intimers[i];
 823d5a0:	e0bffc17 	ldw	r2,-16(fp)
 823d5a4:	10c00524 	muli	r3,r2,20
 823d5a8:	008209b4 	movhi	r2,2086
 823d5ac:	10ba0c04 	addi	r2,r2,-6096
 823d5b0:	1885883a 	add	r2,r3,r2
 823d5b4:	00000706 	br	823d5d4 <in_timerset+0x14c>
long
in_timerset(void (*callback)(long), long msecs, long parm)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d5b8:	e0bffc17 	ldw	r2,-16(fp)
 823d5bc:	10800044 	addi	r2,r2,1
 823d5c0:	e0bffc15 	stw	r2,-16(fp)
 823d5c4:	e0bffc17 	ldw	r2,-16(fp)
 823d5c8:	10800150 	cmplti	r2,r2,5
 823d5cc:	103fb71e 	bne	r2,zero,823d4ac <in_timerset+0x24>
		 intimers[i].inuse = FALSE;
         numtimers++;
         return (long)&intimers[i];
      }
   }
   return 0;
 823d5d0:	0005883a 	mov	r2,zero
}
 823d5d4:	e037883a 	mov	sp,fp
 823d5d8:	dfc00117 	ldw	ra,4(sp)
 823d5dc:	df000017 	ldw	fp,0(sp)
 823d5e0:	dec00204 	addi	sp,sp,8
 823d5e4:	f800283a 	ret

0823d5e8 <in_timerkill>:
 */


int
in_timerkill(long timer)
{
 823d5e8:	defffc04 	addi	sp,sp,-16
 823d5ec:	dfc00315 	stw	ra,12(sp)
 823d5f0:	df000215 	stw	fp,8(sp)
 823d5f4:	df000204 	addi	fp,sp,8
 823d5f8:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d5fc:	e03ffe15 	stw	zero,-8(fp)
 823d600:	00001606 	br	823d65c <in_timerkill+0x74>
   {
      if(timer == (long)&intimers[i])
 823d604:	e0bffe17 	ldw	r2,-8(fp)
 823d608:	10c00524 	muli	r3,r2,20
 823d60c:	008209b4 	movhi	r2,2086
 823d610:	10ba0c04 	addi	r2,r2,-6096
 823d614:	1885883a 	add	r2,r3,r2
 823d618:	1007883a 	mov	r3,r2
 823d61c:	e0bfff17 	ldw	r2,-4(fp)
 823d620:	18800b1e 	bne	r3,r2,823d650 <in_timerkill+0x68>
      {
         intimers[i].callback = NULL;
 823d624:	008209b4 	movhi	r2,2086
 823d628:	10ba0c04 	addi	r2,r2,-6096
 823d62c:	e0fffe17 	ldw	r3,-8(fp)
 823d630:	18c00524 	muli	r3,r3,20
 823d634:	10c5883a 	add	r2,r2,r3
 823d638:	10000015 	stw	zero,0(r2)
         numtimers--;
 823d63c:	d0a0be17 	ldw	r2,-32008(gp)
 823d640:	10bfffc4 	addi	r2,r2,-1
 823d644:	d0a0be15 	stw	r2,-32008(gp)
         return 0;      /* OK return */
 823d648:	0005883a 	mov	r2,zero
 823d64c:	00000806 	br	823d670 <in_timerkill+0x88>
int
in_timerkill(long timer)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 823d650:	e0bffe17 	ldw	r2,-8(fp)
 823d654:	10800044 	addi	r2,r2,1
 823d658:	e0bffe15 	stw	r2,-8(fp)
 823d65c:	e0bffe17 	ldw	r2,-8(fp)
 823d660:	10800150 	cmplti	r2,r2,5
 823d664:	103fe71e 	bne	r2,zero,823d604 <in_timerkill+0x1c>
         intimers[i].callback = NULL;
         numtimers--;
         return 0;      /* OK return */
      }
   }
   dtrap();    /* timer to kill not found */
 823d668:	822d4140 	call	822d414 <dtrap>
   return ENP_PARAM;
 823d66c:	00bffd84 	movi	r2,-10
}
 823d670:	e037883a 	mov	sp,fp
 823d674:	dfc00117 	ldw	ra,4(sp)
 823d678:	df000017 	ldw	fp,0(sp)
 823d67c:	dec00204 	addi	sp,sp,8
 823d680:	f800283a 	ret

0823d684 <create_apptasks>:
#endif
/* per-application thread definitions */

int
create_apptasks(void)
{
 823d684:	defffe04 	addi	sp,sp,-8
 823d688:	df000115 	stw	fp,4(sp)
 823d68c:	df000104 	addi	fp,sp,4
int e = 0;
 823d690:	e03fff15 	stw	zero,-4(fp)
#endif
/* 
 * Altera Niche Stack Nios port modification:
 * return error code, if any 
 */
   return e;
 823d694:	e0bfff17 	ldw	r2,-4(fp)
}
 823d698:	e037883a 	mov	sp,fp
 823d69c:	df000017 	ldw	fp,0(sp)
 823d6a0:	dec00104 	addi	sp,sp,4
 823d6a4:	f800283a 	ret

0823d6a8 <task_stats>:
 */


void
task_stats(void * pio)
{
 823d6a8:	defffd04 	addi	sp,sp,-12
 823d6ac:	dfc00215 	stw	ra,8(sp)
 823d6b0:	df000115 	stw	fp,4(sp)
 823d6b4:	df000104 	addi	fp,sp,4
 823d6b8:	e13fff15 	stw	r4,-4(fp)
   ns_printf(pio, "Task wakeups:");
 823d6bc:	01420974 	movhi	r5,2085
 823d6c0:	29444804 	addi	r5,r5,4384
 823d6c4:	e13fff17 	ldw	r4,-4(fp)
 823d6c8:	8228d040 	call	8228d04 <ns_printf>

#ifndef NO_INET_STACK
   ns_printf(pio, "netmain: %lu\n", netmain_wakes);
 823d6cc:	d0a08a17 	ldw	r2,-32216(gp)
 823d6d0:	100d883a 	mov	r6,r2
 823d6d4:	01420974 	movhi	r5,2085
 823d6d8:	29444c04 	addi	r5,r5,4400
 823d6dc:	e13fff17 	ldw	r4,-4(fp)
 823d6e0:	8228d040 	call	8228d04 <ns_printf>
#endif
#ifndef NO_INET_TICK
   ns_printf(pio, "nettick: %lu\n", nettick_wakes);
 823d6e4:	d0a08b17 	ldw	r2,-32212(gp)
 823d6e8:	100d883a 	mov	r6,r2
 823d6ec:	01420974 	movhi	r5,2085
 823d6f0:	29445004 	addi	r5,r5,4416
 823d6f4:	e13fff17 	ldw	r4,-4(fp)
 823d6f8:	8228d040 	call	8228d04 <ns_printf>
   ns_printf(pio, "browtask: %lu  ", browtask_wakes);
#endif
#ifdef INCLUDE_SSLAPP
   ns_printf(pio, "INCLUDE_SSLAPP: %lu  ", sslapp_wakes);
#endif
   ns_printf(pio, "\n");
 823d6fc:	01420974 	movhi	r5,2085
 823d700:	29445404 	addi	r5,r5,4432
 823d704:	e13fff17 	ldw	r4,-4(fp)
 823d708:	8228d040 	call	8228d04 <ns_printf>
}
 823d70c:	0001883a 	nop
 823d710:	e037883a 	mov	sp,fp
 823d714:	dfc00117 	ldw	ra,4(sp)
 823d718:	df000017 	ldw	fp,0(sp)
 823d71c:	dec00204 	addi	sp,sp,8
 823d720:	f800283a 	ret

0823d724 <fcntl>:
 * (for files and device drivers) or calls the InterNiche bsd_ioctl for 
 * sockets.
 */
 
int fcntl (int file, int cmd, ...)
{
 823d724:	defff804 	addi	sp,sp,-32
 823d728:	dfc00515 	stw	ra,20(sp)
 823d72c:	df000415 	stw	fp,16(sp)
 823d730:	df000404 	addi	fp,sp,16
 823d734:	e13ffe15 	stw	r4,-8(fp)
 823d738:	e17fff15 	stw	r5,-4(fp)
 823d73c:	e1800215 	stw	r6,8(fp)
 823d740:	e1c00315 	stw	r7,12(fp)
  long     flags;
  va_list  argp;

  if (file < ALT_MAX_FD)
 823d744:	e0bffe17 	ldw	r2,-8(fp)
 823d748:	10800808 	cmpgei	r2,r2,32
 823d74c:	10000c1e 	bne	r2,zero,823d780 <fcntl+0x5c>
  {
    va_start(argp, cmd);
 823d750:	e0800204 	addi	r2,fp,8
 823d754:	e0bffd15 	stw	r2,-12(fp)
    flags = va_arg(argp, long);
 823d758:	e0bffd17 	ldw	r2,-12(fp)
 823d75c:	10c00104 	addi	r3,r2,4
 823d760:	e0fffd15 	stw	r3,-12(fp)
 823d764:	10800017 	ldw	r2,0(r2)
 823d768:	e0bffc15 	stw	r2,-16(fp)
    va_end(argp);
    return alt_fcntl(file, cmd, flags);
 823d76c:	e1bffc17 	ldw	r6,-16(fp)
 823d770:	e17fff17 	ldw	r5,-4(fp)
 823d774:	e13ffe17 	ldw	r4,-8(fp)
 823d778:	8249fac0 	call	8249fac <alt_fcntl>
 823d77c:	00000c06 	br	823d7b0 <fcntl+0x8c>
  }
  else
  {
    va_start(argp, cmd);
 823d780:	e0800204 	addi	r2,fp,8
 823d784:	e0bffd15 	stw	r2,-12(fp)
    flags = va_arg(argp, long);
 823d788:	e0bffd17 	ldw	r2,-12(fp)
 823d78c:	10c00104 	addi	r3,r2,4
 823d790:	e0fffd15 	stw	r3,-12(fp)
 823d794:	10800017 	ldw	r2,0(r2)
 823d798:	e0bffc15 	stw	r2,-16(fp)
    va_end(argp);
    return bsd_ioctl(file, cmd, flags);
 823d79c:	e0bfff17 	ldw	r2,-4(fp)
 823d7a0:	e1bffc17 	ldw	r6,-16(fp)
 823d7a4:	100b883a 	mov	r5,r2
 823d7a8:	e13ffe17 	ldw	r4,-8(fp)
 823d7ac:	82281780 	call	8228178 <bsd_ioctl>
  }
}
 823d7b0:	e037883a 	mov	sp,fp
 823d7b4:	dfc00117 	ldw	ra,4(sp)
 823d7b8:	df000017 	ldw	fp,0(sp)
 823d7bc:	dec00404 	addi	sp,sp,16
 823d7c0:	f800283a 	ret

0823d7c4 <etainit>:
 * RETURNS: int               0 if OK, else nonzero
 */

int
etainit(void)
{
 823d7c4:	defffe04 	addi	sp,sp,-8
 823d7c8:	dfc00115 	stw	ra,4(sp)
 823d7cc:	df000015 	stw	fp,0(sp)
 823d7d0:	d839883a 	mov	fp,sp
   /* register ARP type with the Net Driver */
   if (reg_type(ET_ARP) != 0)
 823d7d4:	01018204 	movi	r4,1544
 823d7d8:	823ecf00 	call	823ecf0 <reg_type>
 823d7dc:	10000526 	beq	r2,zero,823d7f4 <etainit+0x30>
   {
#ifdef NPDEBUG
      dprintf("ARP: unable to register type with MAC Driver\n");
 823d7e0:	01020974 	movhi	r4,2085
 823d7e4:	21045504 	addi	r4,r4,4436
 823d7e8:	82035a00 	call	82035a0 <puts>
#endif
      return (1);
 823d7ec:	00800044 	movi	r2,1
 823d7f0:	00000106 	br	823d7f8 <etainit+0x34>
   }
   return (0);
 823d7f4:	0005883a 	mov	r2,zero
}
 823d7f8:	e037883a 	mov	sp,fp
 823d7fc:	dfc00117 	ldw	ra,4(sp)
 823d800:	df000017 	ldw	fp,0(sp)
 823d804:	dec00204 	addi	sp,sp,8
 823d808:	f800283a 	ret

0823d80c <et_send>:
 * and MIB info in the packet header. 
 */

int
et_send(PACKET pkt, struct arptabent *tp)
{
 823d80c:	defff904 	addi	sp,sp,-28
 823d810:	dfc00615 	stw	ra,24(sp)
 823d814:	df000515 	stw	fp,20(sp)
 823d818:	df000504 	addi	fp,sp,20
 823d81c:	e13ffe15 	stw	r4,-8(fp)
 823d820:	e17fff15 	stw	r5,-4(fp)
   char *ethhdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 823d824:	e0bffe17 	ldw	r2,-8(fp)
 823d828:	10800617 	ldw	r2,24(r2)
 823d82c:	10802717 	ldw	r2,156(r2)
 823d830:	e0bffc15 	stw	r2,-16(fp)
   int err;

   tp->lasttime = cticks;
 823d834:	d0e0a817 	ldw	r3,-32096(gp)
 823d838:	e0bfff17 	ldw	r2,-4(fp)
 823d83c:	10c00615 	stw	r3,24(r2)
   pkt->nb_prot -= ETHHDR_SIZE;  /* prepare for prepending ethernet header */
 823d840:	e0bffe17 	ldw	r2,-8(fp)
 823d844:	10800317 	ldw	r2,12(r2)
 823d848:	10fffc04 	addi	r3,r2,-16
 823d84c:	e0bffe17 	ldw	r2,-8(fp)
 823d850:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen += ETHHDR_SIZE;
 823d854:	e0bffe17 	ldw	r2,-8(fp)
 823d858:	10800417 	ldw	r2,16(r2)
 823d85c:	10c00404 	addi	r3,r2,16
 823d860:	e0bffe17 	ldw	r2,-8(fp)
 823d864:	10c00415 	stw	r3,16(r2)
   ethhdr = pkt->nb_prot + ETHHDR_BIAS;
 823d868:	e0bffe17 	ldw	r2,-8(fp)
 823d86c:	10800317 	ldw	r2,12(r2)
 823d870:	10800084 	addi	r2,r2,2
 823d874:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(snap, snapdata, 6);
      snap->type = ARPIP;
   }
#endif   /* IEEE_802_3 */

   if (ethhdr < pkt->nb_buff)   /* sanity check pointer */
 823d878:	e0bffe17 	ldw	r2,-8(fp)
 823d87c:	10800117 	ldw	r2,4(r2)
 823d880:	e0fffd17 	ldw	r3,-12(fp)
 823d884:	1880032e 	bgeu	r3,r2,823d894 <et_send+0x88>
      panic("et_send: prepend");
 823d888:	01020974 	movhi	r4,2085
 823d88c:	21046104 	addi	r4,r4,4484
 823d890:	8228aec0 	call	8228aec <panic>

   MEMMOVE(ethhdr + ET_DSTOFF, tp->t_phy_addr, 6);  /* set pkt's MAC dst addr */
 823d894:	e0bfff17 	ldw	r2,-4(fp)
 823d898:	10800104 	addi	r2,r2,4
 823d89c:	01800184 	movi	r6,6
 823d8a0:	100b883a 	mov	r5,r2
 823d8a4:	e13ffd17 	ldw	r4,-12(fp)
 823d8a8:	8202fd40 	call	8202fd4 <memmove>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);  /* MAC src */
 823d8ac:	e0bffd17 	ldw	r2,-12(fp)
 823d8b0:	10c00184 	addi	r3,r2,6
 823d8b4:	e0bffc17 	ldw	r2,-16(fp)
 823d8b8:	10800517 	ldw	r2,20(r2)
 823d8bc:	01800184 	movi	r6,6
 823d8c0:	100b883a 	mov	r5,r2
 823d8c4:	1809883a 	mov	r4,r3
 823d8c8:	8202fd40 	call	8202fd4 <memmove>

   /* nice clean ethernet II header */
   if ((tp->flags & (ET_ETH2|ET_SNAP)) != ET_SNAP)
 823d8cc:	e0bfff17 	ldw	r2,-4(fp)
 823d8d0:	1080070b 	ldhu	r2,28(r2)
 823d8d4:	10bfffcc 	andi	r2,r2,65535
 823d8d8:	108000cc 	andi	r2,r2,3
 823d8dc:	108000a0 	cmpeqi	r2,r2,2
 823d8e0:	1000041e 	bne	r2,zero,823d8f4 <et_send+0xe8>
      ET_TYPE_SET(ethhdr, ntohs(ARPIP));
 823d8e4:	e0bffd17 	ldw	r2,-12(fp)
 823d8e8:	10800304 	addi	r2,r2,12
 823d8ec:	00c00204 	movi	r3,8
 823d8f0:	10c00005 	stb	r3,0(r2)
 823d8f4:	e0bffd17 	ldw	r2,-12(fp)
 823d8f8:	10800344 	addi	r2,r2,13
 823d8fc:	10000005 	stb	zero,0(r2)
      ET_TYPE_SET(ethhdr, len8023);
   }
#endif   /* IEEE_802_3 */

   /* if a packet oriented send exists, use it: */
   if (pkt->net->pkt_send)
 823d900:	e0bffe17 	ldw	r2,-8(fp)
 823d904:	10800617 	ldw	r2,24(r2)
 823d908:	10800417 	ldw	r2,16(r2)
 823d90c:	10000726 	beq	r2,zero,823d92c <et_send+0x120>
      err = pkt->net->pkt_send(pkt);   /* send packet to media */
 823d910:	e0bffe17 	ldw	r2,-8(fp)
 823d914:	10800617 	ldw	r2,24(r2)
 823d918:	10800417 	ldw	r2,16(r2)
 823d91c:	e13ffe17 	ldw	r4,-8(fp)
 823d920:	103ee83a 	callr	r2
 823d924:	e0bffb15 	stw	r2,-20(fp)
 823d928:	00001206 	br	823d974 <et_send+0x168>
   else  /* else use older raw_send routine */
   {
      /* sent to media */
      err = pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 823d92c:	e0bffe17 	ldw	r2,-8(fp)
 823d930:	10800617 	ldw	r2,24(r2)
 823d934:	10800317 	ldw	r2,12(r2)
 823d938:	e0fffe17 	ldw	r3,-8(fp)
 823d93c:	19000617 	ldw	r4,24(r3)
 823d940:	e0fffe17 	ldw	r3,-8(fp)
 823d944:	19400317 	ldw	r5,12(r3)
 823d948:	e0fffe17 	ldw	r3,-8(fp)
 823d94c:	18c00417 	ldw	r3,16(r3)
 823d950:	180d883a 	mov	r6,r3
 823d954:	103ee83a 	callr	r2
 823d958:	e0bffb15 	stw	r2,-20(fp)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823d95c:	01000084 	movi	r4,2
 823d960:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 823d964:	e13ffe17 	ldw	r4,-8(fp)
 823d968:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823d96c:	01000084 	movi	r4,2
 823d970:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   }

   return (err);
 823d974:	e0bffb17 	ldw	r2,-20(fp)
}
 823d978:	e037883a 	mov	sp,fp
 823d97c:	dfc00117 	ldw	ra,4(sp)
 823d980:	df000017 	ldw	fp,0(sp)
 823d984:	dec00204 	addi	sp,sp,8
 823d988:	f800283a 	ret

0823d98c <arp_free_pending>:
 * and mark the entry "unused".
 */

void
arp_free_pending(struct arptabent *entry)
{
 823d98c:	defffb04 	addi	sp,sp,-20
 823d990:	dfc00415 	stw	ra,16(sp)
 823d994:	df000315 	stw	fp,12(sp)
 823d998:	df000304 	addi	fp,sp,12
 823d99c:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt;
   PACKET nextpkt;

   /* entry->pending has the linked list of all pending packets */
   tmppkt = entry->pending;
 823d9a0:	e0bfff17 	ldw	r2,-4(fp)
 823d9a4:	10800417 	ldw	r2,16(r2)
 823d9a8:	e0bffd15 	stw	r2,-12(fp)
   entry->pending = (PACKET)NULL;
 823d9ac:	e0bfff17 	ldw	r2,-4(fp)
 823d9b0:	10000415 	stw	zero,16(r2)

   LOCK_NET_RESOURCE(FREEQ_RESID);
 823d9b4:	01000084 	movi	r4,2
 823d9b8:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>

   /* free all pending packets */
   while (tmppkt)
 823d9bc:	00000906 	br	823d9e4 <arp_free_pending+0x58>
   {
      nextpkt = tmppkt->next;        /* save the next packet in list */
 823d9c0:	e0bffd17 	ldw	r2,-12(fp)
 823d9c4:	10800017 	ldw	r2,0(r2)
 823d9c8:	e0bffe15 	stw	r2,-8(fp)
      tmppkt->next = (PACKET)NULL;
 823d9cc:	e0bffd17 	ldw	r2,-12(fp)
 823d9d0:	10000015 	stw	zero,0(r2)
      pk_free(tmppkt);               /* free current packet */
 823d9d4:	e13ffd17 	ldw	r4,-12(fp)
 823d9d8:	822cbbc0 	call	822cbbc <pk_free>
      tmppkt = nextpkt;              /* process the next packet */
 823d9dc:	e0bffe17 	ldw	r2,-8(fp)
 823d9e0:	e0bffd15 	stw	r2,-12(fp)
   entry->pending = (PACKET)NULL;

   LOCK_NET_RESOURCE(FREEQ_RESID);

   /* free all pending packets */
   while (tmppkt)
 823d9e4:	e0bffd17 	ldw	r2,-12(fp)
 823d9e8:	103ff51e 	bne	r2,zero,823d9c0 <arp_free_pending+0x34>
      tmppkt->next = (PACKET)NULL;
      pk_free(tmppkt);               /* free current packet */
      tmppkt = nextpkt;              /* process the next packet */
   }

   entry->t_pro_addr = 0;     /* mark the entry "unused" */
 823d9ec:	e0bfff17 	ldw	r2,-4(fp)
 823d9f0:	10000015 	stw	zero,0(r2)

   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823d9f4:	01000084 	movi	r4,2
 823d9f8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
}
 823d9fc:	0001883a 	nop
 823da00:	e037883a 	mov	sp,fp
 823da04:	dfc00117 	ldw	ra,4(sp)
 823da08:	df000017 	ldw	fp,0(sp)
 823da0c:	dec00204 	addi	sp,sp,8
 823da10:	f800283a 	ret

0823da14 <arp_send_pending>:
 * Clear the list (entry->pending) after sending the packets.
 */

void
arp_send_pending(struct arptabent *entry)
{
 823da14:	defffc04 	addi	sp,sp,-16
 823da18:	dfc00315 	stw	ra,12(sp)
 823da1c:	df000215 	stw	fp,8(sp)
 823da20:	df000204 	addi	fp,sp,8
 823da24:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt = entry->pending;
 823da28:	e0bfff17 	ldw	r2,-4(fp)
 823da2c:	10800417 	ldw	r2,16(r2)
 823da30:	e0bffe15 	stw	r2,-8(fp)

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 823da34:	00000906 	br	823da5c <arp_send_pending+0x48>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
 823da38:	e0bffe17 	ldw	r2,-8(fp)
 823da3c:	10c00017 	ldw	r3,0(r2)
 823da40:	e0bfff17 	ldw	r2,-4(fp)
 823da44:	10c00415 	stw	r3,16(r2)
      tmppkt->next = (PACKET)NULL;
 823da48:	e0bffe17 	ldw	r2,-8(fp)
 823da4c:	10000015 	stw	zero,0(r2)
      et_send(tmppkt, entry);          /* try send again */
 823da50:	e17fff17 	ldw	r5,-4(fp)
 823da54:	e13ffe17 	ldw	r4,-8(fp)
 823da58:	823d80c0 	call	823d80c <et_send>
   PACKET tmppkt = entry->pending;

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 823da5c:	e0bfff17 	ldw	r2,-4(fp)
 823da60:	10800417 	ldw	r2,16(r2)
 823da64:	e0bffe15 	stw	r2,-8(fp)
 823da68:	e0bffe17 	ldw	r2,-8(fp)
 823da6c:	103ff21e 	bne	r2,zero,823da38 <arp_send_pending+0x24>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
      tmppkt->next = (PACKET)NULL;
      et_send(tmppkt, entry);          /* try send again */
   }
}
 823da70:	0001883a 	nop
 823da74:	e037883a 	mov	sp,fp
 823da78:	dfc00117 	ldw	ra,4(sp)
 823da7c:	df000017 	ldw	fp,0(sp)
 823da80:	dec00204 	addi	sp,sp,8
 823da84:	f800283a 	ret

0823da88 <send_arp>:
 * timeout will eventually free packet. 
 */

int
send_arp(PACKET pkt, ip_addr dest_ip)
{
 823da88:	defff404 	addi	sp,sp,-48
 823da8c:	dfc00b15 	stw	ra,44(sp)
 823da90:	df000a15 	stw	fp,40(sp)
 823da94:	df000a04 	addi	fp,sp,40
 823da98:	e13ffe15 	stw	r4,-8(fp)
 823da9c:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *   oldest;
   char * ethhdr;
   NET net = pkt->net;
 823daa0:	e0bffe17 	ldw	r2,-8(fp)
 823daa4:	10800617 	ldw	r2,24(r2)
 823daa8:	e0bff615 	stw	r2,-40(fp)
   struct arp_hdr *  arphdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 823daac:	e0bffe17 	ldw	r2,-8(fp)
 823dab0:	10800617 	ldw	r2,24(r2)
 823dab4:	10802717 	ldw	r2,156(r2)
 823dab8:	e0bff715 	stw	r2,-36(fp)
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 823dabc:	e0bfff17 	ldw	r2,-4(fp)
 823dac0:	10bfffe0 	cmpeqi	r2,r2,-1
 823dac4:	1000191e 	bne	r2,zero,823db2c <send_arp+0xa4>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask)))
 823dac8:	e0bff617 	ldw	r2,-40(fp)
 823dacc:	10800c17 	ldw	r2,48(r2)
 823dad0:	0086303a 	nor	r3,zero,r2
 823dad4:	e0bfff17 	ldw	r2,-4(fp)
 823dad8:	1886703a 	and	r3,r3,r2
 823dadc:	e0bff617 	ldw	r2,-40(fp)
 823dae0:	10800c17 	ldw	r2,48(r2)
 823dae4:	0084303a 	nor	r2,zero,r2
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 823dae8:	18801026 	beq	r3,r2,823db2c <send_arp+0xa4>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask)))
       || (IN_MULTICAST(ntohl(dest_ip)) ))
 823daec:	e0bfff17 	ldw	r2,-4(fp)
 823daf0:	1006d63a 	srli	r3,r2,24
 823daf4:	e0bfff17 	ldw	r2,-4(fp)
 823daf8:	1004d23a 	srli	r2,r2,8
 823dafc:	10bfc00c 	andi	r2,r2,65280
 823db00:	1886b03a 	or	r3,r3,r2
 823db04:	e0bfff17 	ldw	r2,-4(fp)
 823db08:	10bfc00c 	andi	r2,r2,65280
 823db0c:	1004923a 	slli	r2,r2,8
 823db10:	1886b03a 	or	r3,r3,r2
 823db14:	e0bfff17 	ldw	r2,-4(fp)
 823db18:	1004963a 	slli	r2,r2,24
 823db1c:	1884b03a 	or	r2,r3,r2
 823db20:	10fc002c 	andhi	r3,r2,61440
 823db24:	00b80034 	movhi	r2,57344
 823db28:	1880391e 	bne	r3,r2,823dc10 <send_arp+0x188>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask))))

#endif /* IP_MULTICAST */
   {
      /* get unused or oldest entry in table */
      oldest = make_arp_entry(dest_ip, pkt->net);
 823db2c:	e0bffe17 	ldw	r2,-8(fp)
 823db30:	10800617 	ldw	r2,24(r2)
 823db34:	100b883a 	mov	r5,r2
 823db38:	e13fff17 	ldw	r4,-4(fp)
 823db3c:	823e0480 	call	823e048 <make_arp_entry>
 823db40:	e0bff915 	stw	r2,-28(fp)

      /* set MAC destination to ethernet broadcast (all FFs) */
      MEMSET(oldest->t_phy_addr, 0xFF, 6);
 823db44:	e0bff917 	ldw	r2,-28(fp)
 823db48:	10800104 	addi	r2,r2,4
 823db4c:	01800184 	movi	r6,6
 823db50:	01403fc4 	movi	r5,255
 823db54:	1009883a 	mov	r4,r2
 823db58:	82031300 	call	8203130 <memset>
#ifdef IP_MULTICAST
      /* If n_mcastlist routine is defined in the net structure,
         map IP mcast to Ether multicast  */

#ifdef ETHMCAST
      if ((pkt->net->n_mcastlist) && (IN_MULTICAST(ntohl(dest_ip))))
 823db5c:	e0bffe17 	ldw	r2,-8(fp)
 823db60:	10800617 	ldw	r2,24(r2)
 823db64:	10802b17 	ldw	r2,172(r2)
 823db68:	10002526 	beq	r2,zero,823dc00 <send_arp+0x178>
 823db6c:	e0bfff17 	ldw	r2,-4(fp)
 823db70:	1006d63a 	srli	r3,r2,24
 823db74:	e0bfff17 	ldw	r2,-4(fp)
 823db78:	1004d23a 	srli	r2,r2,8
 823db7c:	10bfc00c 	andi	r2,r2,65280
 823db80:	1886b03a 	or	r3,r3,r2
 823db84:	e0bfff17 	ldw	r2,-4(fp)
 823db88:	10bfc00c 	andi	r2,r2,65280
 823db8c:	1004923a 	slli	r2,r2,8
 823db90:	1886b03a 	or	r3,r3,r2
 823db94:	e0bfff17 	ldw	r2,-4(fp)
 823db98:	1004963a 	slli	r2,r2,24
 823db9c:	1884b03a 	or	r2,r3,r2
 823dba0:	10fc002c 	andhi	r3,r2,61440
 823dba4:	00b80034 	movhi	r2,57344
 823dba8:	1880151e 	bne	r3,r2,823dc00 <send_arp+0x178>
      {
         /* If IP mcast to be mapped to Ethernet multicast */
         dest_ip_ptr.l = dest_ip;
 823dbac:	e0bfff17 	ldw	r2,-4(fp)
 823dbb0:	e0bffd15 	stw	r2,-12(fp)
         oldest->t_phy_addr[0] = 0x01;
 823dbb4:	e0bff917 	ldw	r2,-28(fp)
 823dbb8:	00c00044 	movi	r3,1
 823dbbc:	10c00105 	stb	r3,4(r2)
         oldest->t_phy_addr[1] = 0x00;
 823dbc0:	e0bff917 	ldw	r2,-28(fp)
 823dbc4:	10000145 	stb	zero,5(r2)
         oldest->t_phy_addr[2] = 0x5e;
 823dbc8:	e0bff917 	ldw	r2,-28(fp)
 823dbcc:	00c01784 	movi	r3,94
 823dbd0:	10c00185 	stb	r3,6(r2)
         oldest->t_phy_addr[3] = (u_char )(dest_ip_ptr.c[1] & 0x7f);
 823dbd4:	e0bffd43 	ldbu	r2,-11(fp)
 823dbd8:	10801fcc 	andi	r2,r2,127
 823dbdc:	1007883a 	mov	r3,r2
 823dbe0:	e0bff917 	ldw	r2,-28(fp)
 823dbe4:	10c001c5 	stb	r3,7(r2)
         oldest->t_phy_addr[4] = (u_char )dest_ip_ptr.c[2];
 823dbe8:	e0fffd83 	ldbu	r3,-10(fp)
 823dbec:	e0bff917 	ldw	r2,-28(fp)
 823dbf0:	10c00205 	stb	r3,8(r2)
         oldest->t_phy_addr[5] = (u_char )dest_ip_ptr.c[3];
 823dbf4:	e0fffdc3 	ldbu	r3,-9(fp)
 823dbf8:	e0bff917 	ldw	r2,-28(fp)
 823dbfc:	10c00245 	stb	r3,9(r2)
      }
#endif /* ETHMCAST */
#endif /* IP_MULTICAST */
      return (et_send(pkt, oldest));
 823dc00:	e17ff917 	ldw	r5,-28(fp)
 823dc04:	e13ffe17 	ldw	r4,-8(fp)
 823dc08:	823d80c0 	call	823d80c <et_send>
 823dc0c:	0000ae06 	br	823dec8 <send_arp+0x440>

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 823dc10:	e0bffe17 	ldw	r2,-8(fp)
 823dc14:	10c00717 	ldw	r3,28(r2)
 823dc18:	e0bffe17 	ldw	r2,-8(fp)
 823dc1c:	10800617 	ldw	r2,24(r2)
 823dc20:	10800a17 	ldw	r2,40(r2)
 823dc24:	18800d1e 	bne	r3,r2,823dc5c <send_arp+0x1d4>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
 823dc28:	e0bffe17 	ldw	r2,-8(fp)
 823dc2c:	10800717 	ldw	r2,28(r2)
 823dc30:	10803fcc 	andi	r2,r2,255

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 823dc34:	10801fe0 	cmpeqi	r2,r2,127
 823dc38:	1000081e 	bne	r2,zero,823dc5c <send_arp+0x1d4>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823dc3c:	01000084 	movi	r4,2
 823dc40:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 823dc44:	e13ffe17 	ldw	r4,-8(fp)
 823dc48:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823dc4c:	01000084 	movi	r4,2
 823dc50:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return ENP_NO_ROUTE;
 823dc54:	00bff7c4 	movi	r2,-33
 823dc58:	00009b06 	br	823dec8 <send_arp+0x440>
   }

   /* not broadcasting, so get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 823dc5c:	01000084 	movi	r4,2
 823dc60:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 823dc64:	01000c04 	movi	r4,48
 823dc68:	822c86c0 	call	822c86c <pk_alloc>
 823dc6c:	e0bff815 	stw	r2,-32(fp)
   if (!arppkt)
 823dc70:	e0bff817 	ldw	r2,-32(fp)
 823dc74:	1000061e 	bne	r2,zero,823dc90 <send_arp+0x208>
   {
      pk_free(pkt);
 823dc78:	e13ffe17 	ldw	r4,-8(fp)
 823dc7c:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823dc80:	01000084 	movi	r4,2
 823dc84:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 823dc88:	00bffa84 	movi	r2,-22
 823dc8c:	00008e06 	br	823dec8 <send_arp+0x440>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823dc90:	01000084 	movi	r4,2
 823dc94:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 823dc98:	e0bff817 	ldw	r2,-32(fp)
 823dc9c:	10c00117 	ldw	r3,4(r2)
 823dca0:	e0bff817 	ldw	r2,-32(fp)
 823dca4:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 823dca8:	e0bff817 	ldw	r2,-32(fp)
 823dcac:	00c00c04 	movi	r3,48
 823dcb0:	10c00415 	stw	r3,16(r2)
   arppkt->net = pkt->net;
 823dcb4:	e0bffe17 	ldw	r2,-8(fp)
 823dcb8:	10c00617 	ldw	r3,24(r2)
 823dcbc:	e0bff817 	ldw	r2,-32(fp)
 823dcc0:	10c00615 	stw	r3,24(r2)

   /* get unused or oldest entry in table */
   oldest = make_arp_entry(dest_ip, pkt->net);
 823dcc4:	e0bffe17 	ldw	r2,-8(fp)
 823dcc8:	10800617 	ldw	r2,24(r2)
 823dccc:	100b883a 	mov	r5,r2
 823dcd0:	e13fff17 	ldw	r4,-4(fp)
 823dcd4:	823e0480 	call	823e048 <make_arp_entry>
 823dcd8:	e0bff915 	stw	r2,-28(fp)

   oldest->pending = pkt;           /* packet is "pended", not pk_free()d */
 823dcdc:	e0bff917 	ldw	r2,-28(fp)
 823dce0:	e0fffe17 	ldw	r3,-8(fp)
 823dce4:	10c00415 	stw	r3,16(r2)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 823dce8:	e0bff817 	ldw	r2,-32(fp)
 823dcec:	10800117 	ldw	r2,4(r2)
 823dcf0:	10800084 	addi	r2,r2,2
 823dcf4:	e0bffa15 	stw	r2,-24(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 823dcf8:	e0bff817 	ldw	r2,-32(fp)
 823dcfc:	10800117 	ldw	r2,4(r2)
 823dd00:	10800404 	addi	r2,r2,16
 823dd04:	e0bffb15 	stw	r2,-20(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 823dd08:	e0bffb17 	ldw	r2,-20(fp)
 823dd0c:	00c04004 	movi	r3,256
 823dd10:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 823dd14:	e0bffb17 	ldw	r2,-20(fp)
 823dd18:	00c00204 	movi	r3,8
 823dd1c:	10c0008d 	sth	r3,2(r2)
   arphdr->ar_hln = 6;
 823dd20:	e0bffb17 	ldw	r2,-20(fp)
 823dd24:	00c00184 	movi	r3,6
 823dd28:	10c00105 	stb	r3,4(r2)
   arphdr->ar_pln = 4;
 823dd2c:	e0bffb17 	ldw	r2,-20(fp)
 823dd30:	00c00104 	movi	r3,4
 823dd34:	10c00145 	stb	r3,5(r2)
   arphdr->ar_op = ARREQ;
 823dd38:	e0bffb17 	ldw	r2,-20(fp)
 823dd3c:	00c04004 	movi	r3,256
 823dd40:	10c0018d 	sth	r3,6(r2)
   arphdr->ar_tpa = dest_ip;        /* target's IP address */
 823dd44:	e0bffb17 	ldw	r2,-20(fp)
 823dd48:	e0ffff17 	ldw	r3,-4(fp)
 823dd4c:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = pkt->net->n_ipaddr;   /* my IP address */
 823dd50:	e0bffe17 	ldw	r2,-8(fp)
 823dd54:	10800617 	ldw	r2,24(r2)
 823dd58:	10c00a17 	ldw	r3,40(r2)
 823dd5c:	e0bffb17 	ldw	r2,-20(fp)
 823dd60:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 823dd64:	e0bffb17 	ldw	r2,-20(fp)
 823dd68:	10c00204 	addi	r3,r2,8
 823dd6c:	e0bff717 	ldw	r2,-36(fp)
 823dd70:	10800517 	ldw	r2,20(r2)
 823dd74:	01800184 	movi	r6,6
 823dd78:	100b883a 	mov	r5,r2
 823dd7c:	1809883a 	mov	r4,r3
 823dd80:	8202fd40 	call	8202fd4 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 823dd84:	01800184 	movi	r6,6
 823dd88:	01403fc4 	movi	r5,255
 823dd8c:	e13ffa17 	ldw	r4,-24(fp)
 823dd90:	82031300 	call	8203130 <memset>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 823dd94:	e0bffa17 	ldw	r2,-24(fp)
 823dd98:	10c00184 	addi	r3,r2,6
 823dd9c:	e0bff717 	ldw	r2,-36(fp)
 823dda0:	10800517 	ldw	r2,20(r2)
 823dda4:	01800184 	movi	r6,6
 823dda8:	100b883a 	mov	r5,r2
 823ddac:	1809883a 	mov	r4,r3
 823ddb0:	8202fd40 	call	8202fd4 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 823ddb4:	e0bffa17 	ldw	r2,-24(fp)
 823ddb8:	10800304 	addi	r2,r2,12
 823ddbc:	00c00204 	movi	r3,8
 823ddc0:	10c00005 	stb	r3,0(r2)
 823ddc4:	e0bffa17 	ldw	r2,-24(fp)
 823ddc8:	10800344 	addi	r2,r2,13
 823ddcc:	00c00184 	movi	r3,6
 823ddd0:	10c00005 	stb	r3,0(r2)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 823ddd4:	e0bffb17 	ldw	r2,-20(fp)
 823ddd8:	e0bffc15 	stw	r2,-16(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 823dddc:	e0bffc17 	ldw	r2,-16(fp)
 823dde0:	10c00204 	addi	r3,r2,8
 823dde4:	e0bffb17 	ldw	r2,-20(fp)
 823dde8:	10800204 	addi	r2,r2,8
 823ddec:	01800184 	movi	r6,6
 823ddf0:	100b883a 	mov	r5,r2
 823ddf4:	1809883a 	mov	r4,r3
 823ddf8:	8202fd40 	call	8202fd4 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 823ddfc:	e0bffc17 	ldw	r2,-16(fp)
 823de00:	10c00384 	addi	r3,r2,14
 823de04:	e0bffb17 	ldw	r2,-20(fp)
 823de08:	10800404 	addi	r2,r2,16
 823de0c:	01800104 	movi	r6,4
 823de10:	100b883a 	mov	r5,r2
 823de14:	1809883a 	mov	r4,r3
 823de18:	8202fd40 	call	8202fd4 <memmove>
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 823de1c:	e0bffc17 	ldw	r2,-16(fp)
 823de20:	10c00484 	addi	r3,r2,18
 823de24:	e0bffb17 	ldw	r2,-20(fp)
 823de28:	10800504 	addi	r2,r2,20
 823de2c:	01800184 	movi	r6,6
 823de30:	100b883a 	mov	r5,r2
 823de34:	1809883a 	mov	r4,r3
 823de38:	8202fd40 	call	8202fd4 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 823de3c:	e0bffc17 	ldw	r2,-16(fp)
 823de40:	10c00604 	addi	r3,r2,24
 823de44:	e0bffb17 	ldw	r2,-20(fp)
 823de48:	10800704 	addi	r2,r2,28
 823de4c:	01800104 	movi	r6,4
 823de50:	100b883a 	mov	r5,r2
 823de54:	1809883a 	mov	r4,r3
 823de58:	8202fd40 	call	8202fd4 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 823de5c:	e0bff617 	ldw	r2,-40(fp)
 823de60:	10800417 	ldw	r2,16(r2)
 823de64:	10000526 	beq	r2,zero,823de7c <send_arp+0x3f4>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 823de68:	e0bff617 	ldw	r2,-40(fp)
 823de6c:	10800417 	ldw	r2,16(r2)
 823de70:	e13ff817 	ldw	r4,-32(fp)
 823de74:	103ee83a 	callr	r2
 823de78:	00000f06 	br	823deb8 <send_arp+0x430>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 823de7c:	e0bff617 	ldw	r2,-40(fp)
 823de80:	10800317 	ldw	r2,12(r2)
 823de84:	e0fff817 	ldw	r3,-32(fp)
 823de88:	19000617 	ldw	r4,24(r3)
 823de8c:	e0fff817 	ldw	r3,-32(fp)
 823de90:	18c00117 	ldw	r3,4(r3)
 823de94:	01800c04 	movi	r6,48
 823de98:	180b883a 	mov	r5,r3
 823de9c:	103ee83a 	callr	r2
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823dea0:	01000084 	movi	r4,2
 823dea4:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 823dea8:	e13ff817 	ldw	r4,-32(fp)
 823deac:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823deb0:	01000084 	movi	r4,2
 823deb4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 823deb8:	d0a0c317 	ldw	r2,-31988(gp)
 823debc:	10800044 	addi	r2,r2,1
 823dec0:	d0a0c315 	stw	r2,-31988(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 823dec4:	00800044 	movi	r2,1
}
 823dec8:	e037883a 	mov	sp,fp
 823decc:	dfc00117 	ldw	ra,4(sp)
 823ded0:	df000017 	ldw	fp,0(sp)
 823ded4:	dec00204 	addi	sp,sp,8
 823ded8:	f800283a 	ret

0823dedc <find_oldest_arp>:
 * Old entries are removed from the table.
 */

struct arptabent * 
find_oldest_arp(ip_addr dest_ip)
{
 823dedc:	defff804 	addi	sp,sp,-32
 823dee0:	dfc00715 	stw	ra,28(sp)
 823dee4:	df000615 	stw	fp,24(sp)
 823dee8:	df000604 	addi	fp,sp,24
 823deec:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   struct arptabent *exact  = (struct arptabent *)NULL;
 823def0:	e03ffb15 	stw	zero,-20(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
 823def4:	e03ffc15 	stw	zero,-16(fp)
   struct arptabent *empty  = (struct arptabent *)NULL;
 823def8:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 823defc:	d0a0a817 	ldw	r2,-32096(gp)
 823df00:	e0bffe15 	stw	r2,-8(fp)

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823df04:	008209b4 	movhi	r2,2086
 823df08:	10ba2504 	addi	r2,r2,-5996
 823df0c:	e0bffa15 	stw	r2,-24(fp)
 823df10:	00003b06 	br	823e000 <find_oldest_arp+0x124>
   {
      /* age out old, pending entries */
      if (tp->pending)
 823df14:	e0bffa17 	ldw	r2,-24(fp)
 823df18:	10800417 	ldw	r2,16(r2)
 823df1c:	10000b26 	beq	r2,zero,823df4c <find_oldest_arp+0x70>
      {
         /* purge if pending for more than one second */
         if ((lticks - tp->createtime) > TPS)
 823df20:	e0bffa17 	ldw	r2,-24(fp)
 823df24:	10800517 	ldw	r2,20(r2)
 823df28:	e0fffe17 	ldw	r3,-8(fp)
 823df2c:	1885c83a 	sub	r2,r3,r2
 823df30:	10801970 	cmpltui	r2,r2,101
 823df34:	1000171e 	bne	r2,zero,823df94 <find_oldest_arp+0xb8>
         {
            arp_free_pending(tp);   /* free pending packets */
 823df38:	e13ffa17 	ldw	r4,-24(fp)
 823df3c:	823d98c0 	call	823d98c <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823df40:	e0bffa17 	ldw	r2,-24(fp)
 823df44:	10000015 	stw	zero,0(r2)
 823df48:	00001206 	br	823df94 <find_oldest_arp+0xb8>
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 823df4c:	e0bffa17 	ldw	r2,-24(fp)
 823df50:	10800017 	ldw	r2,0(r2)
 823df54:	10000f26 	beq	r2,zero,823df94 <find_oldest_arp+0xb8>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
 823df58:	e0bffa17 	ldw	r2,-24(fp)
 823df5c:	10800517 	ldw	r2,20(r2)
 823df60:	e0fffe17 	ldw	r3,-8(fp)
 823df64:	1885c83a 	sub	r2,r3,r2
 823df68:	1007883a 	mov	r3,r2
 823df6c:	d0a04f17 	ldw	r2,-32452(gp)
         {
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 823df70:	18800816 	blt	r3,r2,823df94 <find_oldest_arp+0xb8>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
               ((int)(lticks - tp->lasttime)   >= TPS))
 823df74:	e0bffa17 	ldw	r2,-24(fp)
 823df78:	10800617 	ldw	r2,24(r2)
 823df7c:	e0fffe17 	ldw	r3,-8(fp)
 823df80:	1885c83a 	sub	r2,r3,r2
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
      }
      else if ((tp->t_pro_addr != 0) &&
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
 823df84:	10801910 	cmplti	r2,r2,100
 823df88:	1000021e 	bne	r2,zero,823df94 <find_oldest_arp+0xb8>
               ((int)(lticks - tp->lasttime)   >= TPS))
      {
         /* entry has "expired" and has not been reference in 1 sec. */
         tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823df8c:	e0bffa17 	ldw	r2,-24(fp)
 823df90:	10000015 	stw	zero,0(r2)
      }

      if (tp->t_pro_addr == dest_ip)   /* ip addr already has entry */
 823df94:	e0bffa17 	ldw	r2,-24(fp)
 823df98:	10c00017 	ldw	r3,0(r2)
 823df9c:	e0bfff17 	ldw	r2,-4(fp)
 823dfa0:	1880031e 	bne	r3,r2,823dfb0 <find_oldest_arp+0xd4>
      {
         exact = tp;
 823dfa4:	e0bffa17 	ldw	r2,-24(fp)
 823dfa8:	e0bffb15 	stw	r2,-20(fp)
 823dfac:	00001106 	br	823dff4 <find_oldest_arp+0x118>
      }
      else if (tp->t_pro_addr != 0)
 823dfb0:	e0bffa17 	ldw	r2,-24(fp)
 823dfb4:	10800017 	ldw	r2,0(r2)
 823dfb8:	10000a26 	beq	r2,zero,823dfe4 <find_oldest_arp+0x108>
      {
         if (!oldest || (tp->lasttime < oldest->lasttime))
 823dfbc:	e0bffc17 	ldw	r2,-16(fp)
 823dfc0:	10000526 	beq	r2,zero,823dfd8 <find_oldest_arp+0xfc>
 823dfc4:	e0bffa17 	ldw	r2,-24(fp)
 823dfc8:	10c00617 	ldw	r3,24(r2)
 823dfcc:	e0bffc17 	ldw	r2,-16(fp)
 823dfd0:	10800617 	ldw	r2,24(r2)
 823dfd4:	1880072e 	bgeu	r3,r2,823dff4 <find_oldest_arp+0x118>
            oldest = tp;
 823dfd8:	e0bffa17 	ldw	r2,-24(fp)
 823dfdc:	e0bffc15 	stw	r2,-16(fp)
 823dfe0:	00000406 	br	823dff4 <find_oldest_arp+0x118>
      }
      else if (!empty)
 823dfe4:	e0bffd17 	ldw	r2,-12(fp)
 823dfe8:	1000021e 	bne	r2,zero,823dff4 <find_oldest_arp+0x118>
         empty = tp;          /* grab first empty slot */
 823dfec:	e0bffa17 	ldw	r2,-24(fp)
 823dff0:	e0bffd15 	stw	r2,-12(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
   struct arptabent *empty  = (struct arptabent *)NULL;
   unsigned long lticks = cticks;

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823dff4:	e0bffa17 	ldw	r2,-24(fp)
 823dff8:	10800804 	addi	r2,r2,32
 823dffc:	e0bffa15 	stw	r2,-24(fp)
 823e000:	e0fffa17 	ldw	r3,-24(fp)
 823e004:	008209b4 	movhi	r2,2086
 823e008:	10ba6504 	addi	r2,r2,-5740
 823e00c:	18bfc136 	bltu	r3,r2,823df14 <find_oldest_arp+0x38>
      }
      else if (!empty)
         empty = tp;          /* grab first empty slot */
   }

   return ((exact) ? exact : ((empty) ? empty : oldest));
 823e010:	e0bffb17 	ldw	r2,-20(fp)
 823e014:	1000061e 	bne	r2,zero,823e030 <find_oldest_arp+0x154>
 823e018:	e0bffd17 	ldw	r2,-12(fp)
 823e01c:	10000226 	beq	r2,zero,823e028 <find_oldest_arp+0x14c>
 823e020:	e0bffd17 	ldw	r2,-12(fp)
 823e024:	00000306 	br	823e034 <find_oldest_arp+0x158>
 823e028:	e0bffc17 	ldw	r2,-16(fp)
 823e02c:	00000106 	br	823e034 <find_oldest_arp+0x158>
 823e030:	e0bffb17 	ldw	r2,-20(fp)
}
 823e034:	e037883a 	mov	sp,fp
 823e038:	dfc00117 	ldw	ra,4(sp)
 823e03c:	df000017 	ldw	fp,0(sp)
 823e040:	dec00204 	addi	sp,sp,8
 823e044:	f800283a 	ret

0823e048 <make_arp_entry>:
 * active.
 */

struct arptabent *   
make_arp_entry(ip_addr dest_ip, NET net)
{
 823e048:	defffa04 	addi	sp,sp,-24
 823e04c:	dfc00515 	stw	ra,20(sp)
 823e050:	df000415 	stw	fp,16(sp)
 823e054:	df000404 	addi	fp,sp,16
 823e058:	e13ffe15 	stw	r4,-8(fp)
 823e05c:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *oldest;
   unsigned long lticks = cticks;
 823e060:	d0a0a817 	ldw	r2,-32096(gp)
 823e064:	e0bffc15 	stw	r2,-16(fp)

   /* find usable (or existing) ARP table entry */
   oldest = find_oldest_arp(dest_ip);
 823e068:	e13ffe17 	ldw	r4,-8(fp)
 823e06c:	823dedc0 	call	823dedc <find_oldest_arp>
 823e070:	e0bffd15 	stw	r2,-12(fp)

   /* If recycling entry, don't leak packets which may be stuck here */
   if (oldest->pending && (oldest->t_pro_addr != dest_ip))
 823e074:	e0bffd17 	ldw	r2,-12(fp)
 823e078:	10800417 	ldw	r2,16(r2)
 823e07c:	10000626 	beq	r2,zero,823e098 <make_arp_entry+0x50>
 823e080:	e0bffd17 	ldw	r2,-12(fp)
 823e084:	10c00017 	ldw	r3,0(r2)
 823e088:	e0bffe17 	ldw	r2,-8(fp)
 823e08c:	18800226 	beq	r3,r2,823e098 <make_arp_entry+0x50>
   {
      arp_free_pending(oldest);
 823e090:	e13ffd17 	ldw	r4,-12(fp)
 823e094:	823d98c0 	call	823d98c <arp_free_pending>
   }

   /* partially fill in arp entry */
   oldest->t_pro_addr = dest_ip;
 823e098:	e0bffd17 	ldw	r2,-12(fp)
 823e09c:	e0fffe17 	ldw	r3,-8(fp)
 823e0a0:	10c00015 	stw	r3,0(r2)
   oldest->net = net;
 823e0a4:	e0bffd17 	ldw	r2,-12(fp)
 823e0a8:	e0ffff17 	ldw	r3,-4(fp)
 823e0ac:	10c00315 	stw	r3,12(r2)
   oldest->flags = 0;
 823e0b0:	e0bffd17 	ldw	r2,-12(fp)
 823e0b4:	1000070d 	sth	zero,28(r2)
   MEMSET(oldest->t_phy_addr, '\0', 6);   /* clear mac address */
 823e0b8:	e0bffd17 	ldw	r2,-12(fp)
 823e0bc:	10800104 	addi	r2,r2,4
 823e0c0:	01800184 	movi	r6,6
 823e0c4:	000b883a 	mov	r5,zero
 823e0c8:	1009883a 	mov	r4,r2
 823e0cc:	82031300 	call	8203130 <memset>
   oldest->createtime = oldest->lasttime = lticks;
 823e0d0:	e0bffd17 	ldw	r2,-12(fp)
 823e0d4:	e0fffc17 	ldw	r3,-16(fp)
 823e0d8:	10c00615 	stw	r3,24(r2)
 823e0dc:	e0bffd17 	ldw	r2,-12(fp)
 823e0e0:	10c00617 	ldw	r3,24(r2)
 823e0e4:	e0bffd17 	ldw	r2,-12(fp)
 823e0e8:	10c00515 	stw	r3,20(r2)

   /* start a ARP timer if there isn't one already */
   /* update the timeout value if there is a timer */
   /* time is specified in milliseconds */
   if (arp_timer == 0)
 823e0ec:	d0a0bf17 	ldw	r2,-32004(gp)
 823e0f0:	1000071e 	bne	r2,zero,823e110 <make_arp_entry+0xc8>
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
 823e0f4:	000d883a 	mov	r6,zero
 823e0f8:	0149c404 	movi	r5,10000
 823e0fc:	01020934 	movhi	r4,2084
 823e100:	2139fa04 	addi	r4,r4,-6168
 823e104:	823d4880 	call	823d488 <in_timerset>
 823e108:	d0a0bf15 	stw	r2,-32004(gp)
 823e10c:	00000706 	br	823e12c <make_arp_entry+0xe4>
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 823e110:	d0a0bf17 	ldw	r2,-32004(gp)
 823e114:	1009883a 	mov	r4,r2
              ((struct intimer *)arp_timer)->interval + lticks;
 823e118:	d0a0bf17 	ldw	r2,-32004(gp)
 823e11c:	10c00217 	ldw	r3,8(r2)
 823e120:	e0bffc17 	ldw	r2,-16(fp)
 823e124:	1885883a 	add	r2,r3,r2
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 823e128:	20800315 	stw	r2,12(r4)
              ((struct intimer *)arp_timer)->interval + lticks;
   }

   return oldest;
 823e12c:	e0bffd17 	ldw	r2,-12(fp)
}
 823e130:	e037883a 	mov	sp,fp
 823e134:	dfc00117 	ldw	ra,4(sp)
 823e138:	df000017 	ldw	fp,0(sp)
 823e13c:	dec00204 	addi	sp,sp,8
 823e140:	f800283a 	ret

0823e144 <arpReply>:
 * must be freed (or reused) herein. 
 */

void
arpReply(PACKET pkt)
{
 823e144:	defff704 	addi	sp,sp,-36
 823e148:	dfc00815 	stw	ra,32(sp)
 823e14c:	df000715 	stw	fp,28(sp)
 823e150:	df000704 	addi	fp,sp,28
 823e154:	e13fff15 	stw	r4,-4(fp)
   struct arp_hdr *in;
   struct arp_hdr *out;
   char *ethout;
   char *ethin;

   LOCK_NET_RESOURCE(FREEQ_RESID);
 823e158:	01000084 	movi	r4,2
 823e15c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   outpkt = pk_alloc(arpsize);
 823e160:	01000c04 	movi	r4,48
 823e164:	822c86c0 	call	822c86c <pk_alloc>
 823e168:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e16c:	01000084 	movi	r4,2
 823e170:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   if (!outpkt)
 823e174:	e0bff917 	ldw	r2,-28(fp)
 823e178:	1000021e 	bne	r2,zero,823e184 <arpReply+0x40>
   {
      dtrap();
 823e17c:	822d4140 	call	822d414 <dtrap>
      return;
 823e180:	00009b06 	br	823e3f0 <arpReply+0x2ac>
   }

   outpkt->net = pkt->net;    /* send back out the iface it came from */
 823e184:	e0bfff17 	ldw	r2,-4(fp)
 823e188:	10c00617 	ldw	r3,24(r2)
 823e18c:	e0bff917 	ldw	r2,-28(fp)
 823e190:	10c00615 	stw	r3,24(r2)

   ethin = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 823e194:	e0bfff17 	ldw	r2,-4(fp)
 823e198:	10800317 	ldw	r2,12(r2)
 823e19c:	10bffc84 	addi	r2,r2,-14
 823e1a0:	e0bffa15 	stw	r2,-24(fp)
   ethout = outpkt->nb_buff + ETHHDR_BIAS;
 823e1a4:	e0bff917 	ldw	r2,-28(fp)
 823e1a8:	10800117 	ldw	r2,4(r2)
 823e1ac:	10800084 	addi	r2,r2,2
 823e1b0:	e0bffb15 	stw	r2,-20(fp)
      snap->type = ET_ARP;
   }
   else
#endif   /* IEEE_802_3 */
   {
      ET_TYPE_SET(ethout, ntohs(ET_ARP));   /* 0x0806 - ARP type on ethernet */
 823e1b4:	e0bffb17 	ldw	r2,-20(fp)
 823e1b8:	10800304 	addi	r2,r2,12
 823e1bc:	00c00204 	movi	r3,8
 823e1c0:	10c00005 	stb	r3,0(r2)
 823e1c4:	e0bffb17 	ldw	r2,-20(fp)
 823e1c8:	10800344 	addi	r2,r2,13
 823e1cc:	00c00184 	movi	r3,6
 823e1d0:	10c00005 	stb	r3,0(r2)
      in = (struct arp_hdr *)(pkt->nb_prot);
 823e1d4:	e0bfff17 	ldw	r2,-4(fp)
 823e1d8:	10800317 	ldw	r2,12(r2)
 823e1dc:	e0bffc15 	stw	r2,-16(fp)
      out = (struct arp_hdr *)(outpkt->nb_buff + ETHHDR_SIZE);
 823e1e0:	e0bff917 	ldw	r2,-28(fp)
 823e1e4:	10800117 	ldw	r2,4(r2)
 823e1e8:	10800404 	addi	r2,r2,16
 823e1ec:	e0bffd15 	stw	r2,-12(fp)
      outpkt->nb_plen = arpsize;
 823e1f0:	e0bff917 	ldw	r2,-28(fp)
 823e1f4:	00c00c04 	movi	r3,48
 823e1f8:	10c00415 	stw	r3,16(r2)

   /* prepare outgoing arp packet */
#ifdef IEEE_802_3
   out->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   out->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 823e1fc:	e0bffd17 	ldw	r2,-12(fp)
 823e200:	00c04004 	movi	r3,256
 823e204:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   out->ar_pro = ARPIP;
 823e208:	e0bffd17 	ldw	r2,-12(fp)
 823e20c:	00c00204 	movi	r3,8
 823e210:	10c0008d 	sth	r3,2(r2)
   out->ar_hln = 6;
 823e214:	e0bffd17 	ldw	r2,-12(fp)
 823e218:	00c00184 	movi	r3,6
 823e21c:	10c00105 	stb	r3,4(r2)
   out->ar_pln = 4;
 823e220:	e0bffd17 	ldw	r2,-12(fp)
 823e224:	00c00104 	movi	r3,4
 823e228:	10c00145 	stb	r3,5(r2)
   out->ar_op = ARREP;
 823e22c:	e0bffd17 	ldw	r2,-12(fp)
 823e230:	00c08004 	movi	r3,512
 823e234:	10c0018d 	sth	r3,6(r2)
   out->ar_tpa = in->ar_spa;     /* swap IP addresses */
 823e238:	e0bffc17 	ldw	r2,-16(fp)
 823e23c:	10c00417 	ldw	r3,16(r2)
 823e240:	e0bffd17 	ldw	r2,-12(fp)
 823e244:	10c00715 	stw	r3,28(r2)
   out->ar_spa = in->ar_tpa;
 823e248:	e0bffc17 	ldw	r2,-16(fp)
 823e24c:	10c00717 	ldw	r3,28(r2)
 823e250:	e0bffd17 	ldw	r2,-12(fp)
 823e254:	10c00415 	stw	r3,16(r2)
   MEMMOVE(out->ar_tha, in->ar_sha, 6);    /* move his MAC address */
 823e258:	e0bffd17 	ldw	r2,-12(fp)
 823e25c:	10c00504 	addi	r3,r2,20
 823e260:	e0bffc17 	ldw	r2,-16(fp)
 823e264:	10800204 	addi	r2,r2,8
 823e268:	01800184 	movi	r6,6
 823e26c:	100b883a 	mov	r5,r2
 823e270:	1809883a 	mov	r4,r3
 823e274:	8202fd40 	call	8202fd4 <memmove>
   MEMMOVE(out->ar_sha, outpkt->net->n_mib->ifPhysAddress, 6);  /* fill in our mac address */
 823e278:	e0bffd17 	ldw	r2,-12(fp)
 823e27c:	10c00204 	addi	r3,r2,8
 823e280:	e0bff917 	ldw	r2,-28(fp)
 823e284:	10800617 	ldw	r2,24(r2)
 823e288:	10802717 	ldw	r2,156(r2)
 823e28c:	10800517 	ldw	r2,20(r2)
 823e290:	01800184 	movi	r6,6
 823e294:	100b883a 	mov	r5,r2
 823e298:	1809883a 	mov	r4,r3
 823e29c:	8202fd40 	call	8202fd4 <memmove>

   /* prepend ethernet unicast header to arp reply */
   MEMMOVE(ethout + ET_DSTOFF, ethin + ET_SRCOFF, 6);
 823e2a0:	e0bffa17 	ldw	r2,-24(fp)
 823e2a4:	10800184 	addi	r2,r2,6
 823e2a8:	01800184 	movi	r6,6
 823e2ac:	100b883a 	mov	r5,r2
 823e2b0:	e13ffb17 	ldw	r4,-20(fp)
 823e2b4:	8202fd40 	call	8202fd4 <memmove>
   MEMMOVE(ethout + ET_SRCOFF, outpkt->net->n_mib->ifPhysAddress, 6);
 823e2b8:	e0bffb17 	ldw	r2,-20(fp)
 823e2bc:	10c00184 	addi	r3,r2,6
 823e2c0:	e0bff917 	ldw	r2,-28(fp)
 823e2c4:	10800617 	ldw	r2,24(r2)
 823e2c8:	10802717 	ldw	r2,156(r2)
 823e2cc:	10800517 	ldw	r2,20(r2)
 823e2d0:	01800184 	movi	r6,6
 823e2d4:	100b883a 	mov	r5,r2
 823e2d8:	1809883a 	mov	r4,r3
 823e2dc:	8202fd40 	call	8202fd4 <memmove>

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)out;
 823e2e0:	e0bffd17 	ldw	r2,-12(fp)
 823e2e4:	e0bffe15 	stw	r2,-8(fp)
      MEMMOVE(&arwp->data[AR_SHA], out->ar_sha, 6);
 823e2e8:	e0bffe17 	ldw	r2,-8(fp)
 823e2ec:	10c00204 	addi	r3,r2,8
 823e2f0:	e0bffd17 	ldw	r2,-12(fp)
 823e2f4:	10800204 	addi	r2,r2,8
 823e2f8:	01800184 	movi	r6,6
 823e2fc:	100b883a 	mov	r5,r2
 823e300:	1809883a 	mov	r4,r3
 823e304:	8202fd40 	call	8202fd4 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &out->ar_spa, 4);
 823e308:	e0bffe17 	ldw	r2,-8(fp)
 823e30c:	10c00384 	addi	r3,r2,14
 823e310:	e0bffd17 	ldw	r2,-12(fp)
 823e314:	10800404 	addi	r2,r2,16
 823e318:	01800104 	movi	r6,4
 823e31c:	100b883a 	mov	r5,r2
 823e320:	1809883a 	mov	r4,r3
 823e324:	8202fd40 	call	8202fd4 <memmove>
      MEMMOVE(&arwp->data[AR_THA], out->ar_tha, 6);
 823e328:	e0bffe17 	ldw	r2,-8(fp)
 823e32c:	10c00484 	addi	r3,r2,18
 823e330:	e0bffd17 	ldw	r2,-12(fp)
 823e334:	10800504 	addi	r2,r2,20
 823e338:	01800184 	movi	r6,6
 823e33c:	100b883a 	mov	r5,r2
 823e340:	1809883a 	mov	r4,r3
 823e344:	8202fd40 	call	8202fd4 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &out->ar_tpa, 4);
 823e348:	e0bffe17 	ldw	r2,-8(fp)
 823e34c:	10c00604 	addi	r3,r2,24
 823e350:	e0bffd17 	ldw	r2,-12(fp)
 823e354:	10800704 	addi	r2,r2,28
 823e358:	01800104 	movi	r6,4
 823e35c:	100b883a 	mov	r5,r2
 823e360:	1809883a 	mov	r4,r3
 823e364:	8202fd40 	call	8202fd4 <memmove>
   }
#endif   /* NO_CC_PACKING */

   /* if a packet oriented send exists, use it: */
   if (outpkt->net->pkt_send)
 823e368:	e0bff917 	ldw	r2,-28(fp)
 823e36c:	10800617 	ldw	r2,24(r2)
 823e370:	10800417 	ldw	r2,16(r2)
 823e374:	10000a26 	beq	r2,zero,823e3a0 <arpReply+0x25c>
   {
      outpkt->nb_prot = outpkt->nb_buff;
 823e378:	e0bff917 	ldw	r2,-28(fp)
 823e37c:	10c00117 	ldw	r3,4(r2)
 823e380:	e0bff917 	ldw	r2,-28(fp)
 823e384:	10c00315 	stw	r3,12(r2)
      outpkt->net->pkt_send(outpkt);
 823e388:	e0bff917 	ldw	r2,-28(fp)
 823e38c:	10800617 	ldw	r2,24(r2)
 823e390:	10800417 	ldw	r2,16(r2)
 823e394:	e13ff917 	ldw	r4,-28(fp)
 823e398:	103ee83a 	callr	r2
 823e39c:	00001106 	br	823e3e4 <arpReply+0x2a0>
   }
   else
   {
      outpkt->net->raw_send(pkt->net, outpkt->nb_buff, outpkt->nb_plen);
 823e3a0:	e0bff917 	ldw	r2,-28(fp)
 823e3a4:	10800617 	ldw	r2,24(r2)
 823e3a8:	10800317 	ldw	r2,12(r2)
 823e3ac:	e0ffff17 	ldw	r3,-4(fp)
 823e3b0:	19000617 	ldw	r4,24(r3)
 823e3b4:	e0fff917 	ldw	r3,-28(fp)
 823e3b8:	19400117 	ldw	r5,4(r3)
 823e3bc:	e0fff917 	ldw	r3,-28(fp)
 823e3c0:	18c00417 	ldw	r3,16(r3)
 823e3c4:	180d883a 	mov	r6,r3
 823e3c8:	103ee83a 	callr	r2
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e3cc:	01000084 	movi	r4,2
 823e3d0:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(outpkt);
 823e3d4:	e13ff917 	ldw	r4,-28(fp)
 823e3d8:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e3dc:	01000084 	movi	r4,2
 823e3e0:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   }
   /* input 'pkt' will be freed by caller */
   arpRepsOut++;
 823e3e4:	d0a0c517 	ldw	r2,-31980(gp)
 823e3e8:	10800044 	addi	r2,r2,1
 823e3ec:	d0a0c515 	stw	r2,-31980(gp)
}
 823e3f0:	e037883a 	mov	sp,fp
 823e3f4:	dfc00117 	ldw	ra,4(sp)
 823e3f8:	df000017 	ldw	fp,0(sp)
 823e3fc:	dec00204 	addi	sp,sp,8
 823e400:	f800283a 	ret

0823e404 <arprcv>:
 *                            else a negative error code. 
 */

int
arprcv(PACKET pkt)
{
 823e404:	defff904 	addi	sp,sp,-28
 823e408:	dfc00615 	stw	ra,24(sp)
 823e40c:	df000515 	stw	fp,20(sp)
 823e410:	df000504 	addi	fp,sp,20
 823e414:	e13fff15 	stw	r4,-4(fp)
   char *eth;
#ifdef IEEE_802_3
   int      ieee = FALSE;     /* TRUE if received packet is 802.3 */
#endif

   eth = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 823e418:	e0bfff17 	ldw	r2,-4(fp)
 823e41c:	10800317 	ldw	r2,12(r2)
 823e420:	10bffc84 	addi	r2,r2,-14
 823e424:	e0bffc15 	stw	r2,-16(fp)
   arphdr = (struct arp_hdr *)(pkt->nb_prot);
 823e428:	e0bfff17 	ldw	r2,-4(fp)
 823e42c:	10800317 	ldw	r2,12(r2)
 823e430:	e0bffd15 	stw	r2,-12(fp)
#endif   /* IEEE_802_3_ONLY */
#endif   /* IEEE_802_3 */

#ifdef NO_CC_PACKING    /* force ARP fields to local CPU valid boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 823e434:	e0bffd17 	ldw	r2,-12(fp)
 823e438:	e0bffe15 	stw	r2,-8(fp)
      MEMMOVE(&arphdr->ar_tpa, &arwp->data[AR_TPA], 4);
 823e43c:	e0bffd17 	ldw	r2,-12(fp)
 823e440:	10c00704 	addi	r3,r2,28
 823e444:	e0bffe17 	ldw	r2,-8(fp)
 823e448:	10800604 	addi	r2,r2,24
 823e44c:	01800104 	movi	r6,4
 823e450:	100b883a 	mov	r5,r2
 823e454:	1809883a 	mov	r4,r3
 823e458:	8202fd40 	call	8202fd4 <memmove>
      MEMMOVE(arphdr->ar_tha, &arwp->data[AR_THA], 6);
 823e45c:	e0bffd17 	ldw	r2,-12(fp)
 823e460:	10c00504 	addi	r3,r2,20
 823e464:	e0bffe17 	ldw	r2,-8(fp)
 823e468:	10800484 	addi	r2,r2,18
 823e46c:	01800184 	movi	r6,6
 823e470:	100b883a 	mov	r5,r2
 823e474:	1809883a 	mov	r4,r3
 823e478:	8202fd40 	call	8202fd4 <memmove>
      MEMMOVE(&arphdr->ar_spa, &arwp->data[AR_SPA], 4);
 823e47c:	e0bffd17 	ldw	r2,-12(fp)
 823e480:	10c00404 	addi	r3,r2,16
 823e484:	e0bffe17 	ldw	r2,-8(fp)
 823e488:	10800384 	addi	r2,r2,14
 823e48c:	01800104 	movi	r6,4
 823e490:	100b883a 	mov	r5,r2
 823e494:	1809883a 	mov	r4,r3
 823e498:	8202fd40 	call	8202fd4 <memmove>
      MEMMOVE(arphdr->ar_sha, &arwp->data[AR_SHA], 6);
 823e49c:	e0bffd17 	ldw	r2,-12(fp)
 823e4a0:	10c00204 	addi	r3,r2,8
 823e4a4:	e0bffe17 	ldw	r2,-8(fp)
 823e4a8:	10800204 	addi	r2,r2,8
 823e4ac:	01800184 	movi	r6,6
 823e4b0:	100b883a 	mov	r5,r2
 823e4b4:	1809883a 	mov	r4,r3
 823e4b8:	8202fd40 	call	8202fd4 <memmove>
#endif
   USE_ARG(eth);

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 823e4bc:	e0bffd17 	ldw	r2,-12(fp)
 823e4c0:	10c00717 	ldw	r3,28(r2)
 823e4c4:	e0bfff17 	ldw	r2,-4(fp)
 823e4c8:	10800617 	ldw	r2,24(r2)
 823e4cc:	10800a17 	ldw	r2,40(r2)
 823e4d0:	18801c26 	beq	r3,r2,823e544 <arprcv+0x140>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
 823e4d4:	e0bffd17 	ldw	r2,-12(fp)
 823e4d8:	10800717 	ldw	r2,28(r2)
 823e4dc:	1006d63a 	srli	r3,r2,24
 823e4e0:	e0bffd17 	ldw	r2,-12(fp)
 823e4e4:	10800717 	ldw	r2,28(r2)
 823e4e8:	1004d23a 	srli	r2,r2,8
 823e4ec:	10bfc00c 	andi	r2,r2,65280
 823e4f0:	1886b03a 	or	r3,r3,r2
 823e4f4:	e0bffd17 	ldw	r2,-12(fp)
 823e4f8:	10800717 	ldw	r2,28(r2)
 823e4fc:	10bfc00c 	andi	r2,r2,65280
 823e500:	1004923a 	slli	r2,r2,8
 823e504:	1886b03a 	or	r3,r3,r2
 823e508:	e0bffd17 	ldw	r2,-12(fp)
 823e50c:	10800717 	ldw	r2,28(r2)
 823e510:	1004963a 	slli	r2,r2,24
 823e514:	1884b03a 	or	r2,r3,r2
 823e518:	10fc002c 	andhi	r3,r2,61440
#endif
   USE_ARG(eth);

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 823e51c:	00b80034 	movhi	r2,57344
 823e520:	18800826 	beq	r3,r2,823e544 <arprcv+0x140>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
#else
   if (arphdr->ar_tpa != pkt->net->n_ipaddr)
#endif /* IP_MULTICAST */
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e524:	01000084 	movi	r4,2
 823e528:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(pkt);     /* not for us, dump & ret (proxy here later?) */
 823e52c:	e13fff17 	ldw	r4,-4(fp)
 823e530:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e534:	01000084 	movi	r4,2
 823e538:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return (ENP_NOT_MINE);
 823e53c:	00800084 	movi	r2,2
 823e540:	00004406 	br	823e654 <arprcv+0x250>
   }

   if (arphdr->ar_op == ARREQ)   /* is it an arp request? */
 823e544:	e0bffd17 	ldw	r2,-12(fp)
 823e548:	1080018b 	ldhu	r2,6(r2)
 823e54c:	10bfffcc 	andi	r2,r2,65535
 823e550:	10804018 	cmpnei	r2,r2,256
 823e554:	10000d1e 	bne	r2,zero,823e58c <arprcv+0x188>
   {
      arpReqsIn++;   /* count these */
 823e558:	d0a0c217 	ldw	r2,-31992(gp)
 823e55c:	10800044 	addi	r2,r2,1
 823e560:	d0a0c215 	stw	r2,-31992(gp)
      arpReply(pkt); /* send arp reply */
 823e564:	e13fff17 	ldw	r4,-4(fp)
 823e568:	823e1440 	call	823e144 <arpReply>
      /* make partial ARP table entry */
      make_arp_entry(arphdr->ar_spa, pkt->net);
 823e56c:	e0bffd17 	ldw	r2,-12(fp)
 823e570:	10c00417 	ldw	r3,16(r2)
 823e574:	e0bfff17 	ldw	r2,-4(fp)
 823e578:	10800617 	ldw	r2,24(r2)
 823e57c:	100b883a 	mov	r5,r2
 823e580:	1809883a 	mov	r4,r3
 823e584:	823e0480 	call	823e048 <make_arp_entry>
 823e588:	00000306 	br	823e598 <arprcv+0x194>
      /* fall thru to arp reply logic to finish our table entry */
   }
   else     /* ARP reply, count and fall thru to logic to update table */
   {
      arpRepsIn++;
 823e58c:	d0a0c417 	ldw	r2,-31984(gp)
 823e590:	10800044 	addi	r2,r2,1
 823e594:	d0a0c415 	stw	r2,-31984(gp)
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e598:	008209b4 	movhi	r2,2086
 823e59c:	10ba2504 	addi	r2,r2,-5996
 823e5a0:	e0bffb15 	stw	r2,-20(fp)
 823e5a4:	00002006 	br	823e628 <arprcv+0x224>
   {
      if (tp->t_pro_addr == arphdr->ar_spa)     /* we found IP address, update entry */
 823e5a8:	e0bffb17 	ldw	r2,-20(fp)
 823e5ac:	10c00017 	ldw	r3,0(r2)
 823e5b0:	e0bffd17 	ldw	r2,-12(fp)
 823e5b4:	10800417 	ldw	r2,16(r2)
 823e5b8:	1880181e 	bne	r3,r2,823e61c <arprcv+0x218>
            tp->flags |= ET_SNAP;
         else
            tp->flags |= ET_ETH2;      /* else it's ethernet II */
#endif   /* IEEE_802_3 */

         MEMMOVE(tp->t_phy_addr, arphdr->ar_sha, 6);   /* update MAC adddress */
 823e5bc:	e0bffb17 	ldw	r2,-20(fp)
 823e5c0:	10c00104 	addi	r3,r2,4
 823e5c4:	e0bffd17 	ldw	r2,-12(fp)
 823e5c8:	10800204 	addi	r2,r2,8
 823e5cc:	01800184 	movi	r6,6
 823e5d0:	100b883a 	mov	r5,r2
 823e5d4:	1809883a 	mov	r4,r3
 823e5d8:	8202fd40 	call	8202fd4 <memmove>
         tp->lasttime = cticks;
 823e5dc:	d0e0a817 	ldw	r3,-32096(gp)
 823e5e0:	e0bffb17 	ldw	r2,-20(fp)
 823e5e4:	10c00615 	stw	r3,24(r2)
         if (tp->pending)     /* packet waiting for this IP entry? */
 823e5e8:	e0bffb17 	ldw	r2,-20(fp)
 823e5ec:	10800417 	ldw	r2,16(r2)
 823e5f0:	10000226 	beq	r2,zero,823e5fc <arprcv+0x1f8>
         {
            arp_send_pending(tp);
 823e5f4:	e13ffb17 	ldw	r4,-20(fp)
 823e5f8:	823da140 	call	823da14 <arp_send_pending>
         }
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823e5fc:	01000084 	movi	r4,2
 823e600:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 823e604:	e13fff17 	ldw	r4,-4(fp)
 823e608:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e60c:	01000084 	movi	r4,2
 823e610:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

         return (0);
 823e614:	0005883a 	mov	r2,zero
 823e618:	00000e06 	br	823e654 <arprcv+0x250>
      arpRepsIn++;
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e61c:	e0bffb17 	ldw	r2,-20(fp)
 823e620:	10800804 	addi	r2,r2,32
 823e624:	e0bffb15 	stw	r2,-20(fp)
 823e628:	e0fffb17 	ldw	r3,-20(fp)
 823e62c:	008209b4 	movhi	r2,2086
 823e630:	10ba6504 	addi	r2,r2,-5740
 823e634:	18bfdc36 	bltu	r3,r2,823e5a8 <arprcv+0x1a4>

#ifdef IEEE_802_3_ONLY
drop:
#endif /* IEEE_802_3_ONLY */
   /* fall to here if packet is not in table */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 823e638:	01000084 	movi	r4,2
 823e63c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   pk_free(pkt);
 823e640:	e13fff17 	ldw	r4,-4(fp)
 823e644:	822cbbc0 	call	822cbbc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e648:	01000084 	movi	r4,2
 823e64c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   return ENP_NOT_MINE;
 823e650:	00800084 	movi	r2,2
}
 823e654:	e037883a 	mov	sp,fp
 823e658:	dfc00117 	ldw	ra,4(sp)
 823e65c:	df000017 	ldw	fp,0(sp)
 823e660:	dec00204 	addi	sp,sp,8
 823e664:	f800283a 	ret

0823e668 <send_via_arp>:
 * change the PC's IP address. 
 */

int
send_via_arp(PACKET pkt, ip_addr dest_ip)
{
 823e668:	defff804 	addi	sp,sp,-32
 823e66c:	dfc00715 	stw	ra,28(sp)
 823e670:	df000615 	stw	fp,24(sp)
 823e674:	df000604 	addi	fp,sp,24
 823e678:	e13ffe15 	stw	r4,-8(fp)
 823e67c:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *tp;
   unsigned long lticks = cticks;
 823e680:	d0a0a817 	ldw	r2,-32096(gp)
 823e684:	e0bffd15 	stw	r2,-12(fp)
   int err;

   /* don't allow zero dest */
   if (dest_ip == 0)
 823e688:	e0bfff17 	ldw	r2,-4(fp)
 823e68c:	1000081e 	bne	r2,zero,823e6b0 <send_via_arp+0x48>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823e690:	01000084 	movi	r4,2
 823e694:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 823e698:	e13ffe17 	ldw	r4,-8(fp)
 823e69c:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e6a0:	01000084 	movi	r4,2
 823e6a4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return SEND_DROPPED; 
 823e6a8:	00bffa84 	movi	r2,-22
 823e6ac:	00004906 	br	823e7d4 <send_via_arp+0x16c>
   }

   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
 823e6b0:	d0a0c117 	ldw	r2,-31996(gp)
 823e6b4:	e0fffd17 	ldw	r3,-12(fp)
 823e6b8:	1885c83a 	sub	r2,r3,r2
 823e6bc:	10801970 	cmpltui	r2,r2,101
 823e6c0:	1000011e 	bne	r2,zero,823e6c8 <send_via_arp+0x60>
      arpcache = (struct arptabent *)NULL;
 823e6c4:	d020c015 	stw	zero,-32000(gp)

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 823e6c8:	d0a0c017 	ldw	r2,-32000(gp)
 823e6cc:	10000726 	beq	r2,zero,823e6ec <send_via_arp+0x84>
 823e6d0:	d0a0c017 	ldw	r2,-32000(gp)
 823e6d4:	10c00017 	ldw	r3,0(r2)
 823e6d8:	e0bfff17 	ldw	r2,-4(fp)
 823e6dc:	1880031e 	bne	r3,r2,823e6ec <send_via_arp+0x84>
      tp = arpcache;
 823e6e0:	d0a0c017 	ldw	r2,-32000(gp)
 823e6e4:	e0bffa15 	stw	r2,-24(fp)
 823e6e8:	00000306 	br	823e6f8 <send_via_arp+0x90>
   else
   {
      /* scan arp table for an existing entry */
      tp = find_oldest_arp(dest_ip);
 823e6ec:	e13fff17 	ldw	r4,-4(fp)
 823e6f0:	823dedc0 	call	823dedc <find_oldest_arp>
 823e6f4:	e0bffa15 	stw	r2,-24(fp)
   }

   if (tp->t_pro_addr == dest_ip)   /* we found our entry */
 823e6f8:	e0bffa17 	ldw	r2,-24(fp)
 823e6fc:	10c00017 	ldw	r3,0(r2)
 823e700:	e0bfff17 	ldw	r2,-4(fp)
 823e704:	18802e1e 	bne	r3,r2,823e7c0 <send_via_arp+0x158>
   {
      if (tp->pending)  /* arp already pending for this IP? */
 823e708:	e0bffa17 	ldw	r2,-24(fp)
 823e70c:	10800417 	ldw	r2,16(r2)
 823e710:	10002226 	beq	r2,zero,823e79c <send_via_arp+0x134>
      {
         if (lilfreeq.q_len < 2)
 823e714:	008209b4 	movhi	r2,2086
 823e718:	10b88604 	addi	r2,r2,-7656
 823e71c:	10800217 	ldw	r2,8(r2)
 823e720:	10800088 	cmpgei	r2,r2,2
 823e724:	1000091e 	bne	r2,zero,823e74c <send_via_arp+0xe4>
         {
            /* system is depleted of resources - free the
             * pkt instead of queueing it - so that we are in a
             * position to receive an arp reply 
             */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823e728:	01000084 	movi	r4,2
 823e72c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
            pk_free(pkt);  /* sorry, we have to dump this one.. */
 823e730:	e13ffe17 	ldw	r4,-8(fp)
 823e734:	822cbbc0 	call	822cbbc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e738:	01000084 	movi	r4,2
 823e73c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
            err = SEND_DROPPED;    /* pkts already waiting for this IP entry */
 823e740:	00bffa84 	movi	r2,-22
 823e744:	e0bffb15 	stw	r2,-20(fp)
 823e748:	00002106 	br	823e7d0 <send_via_arp+0x168>
         }
         else
         {
            PACKET tmppkt=tp->pending;
 823e74c:	e0bffa17 	ldw	r2,-24(fp)
 823e750:	10800417 	ldw	r2,16(r2)
 823e754:	e0bffc15 	stw	r2,-16(fp)

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 823e758:	00000306 	br	823e768 <send_via_arp+0x100>
               tmppkt = tmppkt->next;
 823e75c:	e0bffc17 	ldw	r2,-16(fp)
 823e760:	10800017 	ldw	r2,0(r2)
 823e764:	e0bffc15 	stw	r2,-16(fp)
         else
         {
            PACKET tmppkt=tp->pending;

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 823e768:	e0bffc17 	ldw	r2,-16(fp)
 823e76c:	10800017 	ldw	r2,0(r2)
 823e770:	103ffa1e 	bne	r2,zero,823e75c <send_via_arp+0xf4>
               tmppkt = tmppkt->next;
            tmppkt->next = pkt;      /* add new pkt to end of list */
 823e774:	e0bffc17 	ldw	r2,-16(fp)
 823e778:	e0fffe17 	ldw	r3,-8(fp)
 823e77c:	10c00015 	stw	r3,0(r2)
            if (pkt->next)
 823e780:	e0bffe17 	ldw	r2,-8(fp)
 823e784:	10800017 	ldw	r2,0(r2)
 823e788:	10000126 	beq	r2,zero,823e790 <send_via_arp+0x128>
            {
               dtrap();              /* chain of pkts to be sent ??? */
 823e78c:	822d4140 	call	822d414 <dtrap>
            }
            err = ENP_SEND_PENDING; /* packet queued pending ARP reply */
 823e790:	00800044 	movi	r2,1
 823e794:	e0bffb15 	stw	r2,-20(fp)
 823e798:	00000d06 	br	823e7d0 <send_via_arp+0x168>
         }
      }
      else  /* just send it */
      {
         arpcache = tp;       /* cache this entry */
 823e79c:	e0bffa17 	ldw	r2,-24(fp)
 823e7a0:	d0a0c015 	stw	r2,-32000(gp)
         cachetime = lticks;  /* mark time we cached */
 823e7a4:	e0bffd17 	ldw	r2,-12(fp)
 823e7a8:	d0a0c115 	stw	r2,-31996(gp)
         err = et_send(pkt, tp);
 823e7ac:	e17ffa17 	ldw	r5,-24(fp)
 823e7b0:	e13ffe17 	ldw	r4,-8(fp)
 823e7b4:	823d80c0 	call	823d80c <et_send>
 823e7b8:	e0bffb15 	stw	r2,-20(fp)
 823e7bc:	00000406 	br	823e7d0 <send_via_arp+0x168>
      }
   }
   else
      /* start the ARP process for this IP address */
      err = send_arp(pkt, dest_ip);
 823e7c0:	e17fff17 	ldw	r5,-4(fp)
 823e7c4:	e13ffe17 	ldw	r4,-8(fp)
 823e7c8:	823da880 	call	823da88 <send_arp>
 823e7cc:	e0bffb15 	stw	r2,-20(fp)

   return (err);
 823e7d0:	e0bffb17 	ldw	r2,-20(fp)
}
 823e7d4:	e037883a 	mov	sp,fp
 823e7d8:	dfc00117 	ldw	ra,4(sp)
 823e7dc:	df000017 	ldw	fp,0(sp)
 823e7e0:	dec00204 	addi	sp,sp,8
 823e7e4:	f800283a 	ret

0823e7e8 <cb_arpent_tmo>:
 *
 * If there are no more unresolved entries, cancel the timer.
 */
void
cb_arpent_tmo(long arg)
{
 823e7e8:	defffa04 	addi	sp,sp,-24
 823e7ec:	dfc00515 	stw	ra,20(sp)
 823e7f0:	df000415 	stw	fp,16(sp)
 823e7f4:	df000404 	addi	fp,sp,16
 823e7f8:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   int arp_count = 0;
 823e7fc:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 823e800:	d0a0a817 	ldw	r2,-32096(gp)
 823e804:	e0bffe15 	stw	r2,-8(fp)

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e808:	008209b4 	movhi	r2,2086
 823e80c:	10ba2504 	addi	r2,r2,-5996
 823e810:	e0bffc15 	stw	r2,-16(fp)
 823e814:	00002706 	br	823e8b4 <cb_arpent_tmo+0xcc>
   {
      if (tp->t_pro_addr != 0)
 823e818:	e0bffc17 	ldw	r2,-16(fp)
 823e81c:	10800017 	ldw	r2,0(r2)
 823e820:	10002126 	beq	r2,zero,823e8a8 <cb_arpent_tmo+0xc0>
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 823e824:	e0bffc17 	ldw	r2,-16(fp)
 823e828:	10800417 	ldw	r2,16(r2)
 823e82c:	10000b26 	beq	r2,zero,823e85c <cb_arpent_tmo+0x74>
 823e830:	e0bffc17 	ldw	r2,-16(fp)
 823e834:	10800517 	ldw	r2,20(r2)
 823e838:	e0fffe17 	ldw	r3,-8(fp)
 823e83c:	1885c83a 	sub	r2,r3,r2
 823e840:	10801970 	cmpltui	r2,r2,101
 823e844:	1000051e 	bne	r2,zero,823e85c <cb_arpent_tmo+0x74>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
 823e848:	e13ffc17 	ldw	r4,-16(fp)
 823e84c:	823d98c0 	call	823d98c <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823e850:	e0bffc17 	ldw	r2,-16(fp)
 823e854:	10000015 	stw	zero,0(r2)
 823e858:	00001306 	br	823e8a8 <cb_arpent_tmo+0xc0>
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 823e85c:	e0bffc17 	ldw	r2,-16(fp)
 823e860:	10800517 	ldw	r2,20(r2)
 823e864:	e0fffe17 	ldw	r3,-8(fp)
 823e868:	1885c83a 	sub	r2,r3,r2
 823e86c:	1007883a 	mov	r3,r2
 823e870:	d0a04f17 	ldw	r2,-32452(gp)
 823e874:	18800916 	blt	r3,r2,823e89c <cb_arpent_tmo+0xb4>
                  ((int)(lticks - tp->lasttime)   >= TPS))
 823e878:	e0bffc17 	ldw	r2,-16(fp)
 823e87c:	10800617 	ldw	r2,24(r2)
 823e880:	e0fffe17 	ldw	r3,-8(fp)
 823e884:	1885c83a 	sub	r2,r3,r2
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 823e888:	10801910 	cmplti	r2,r2,100
 823e88c:	1000031e 	bne	r2,zero,823e89c <cb_arpent_tmo+0xb4>
                  ((int)(lticks - tp->lasttime)   >= TPS))
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 823e890:	e0bffc17 	ldw	r2,-16(fp)
 823e894:	10000015 	stw	zero,0(r2)
 823e898:	00000306 	br	823e8a8 <cb_arpent_tmo+0xc0>
         }
         else
            arp_count++;
 823e89c:	e0bffd17 	ldw	r2,-12(fp)
 823e8a0:	10800044 	addi	r2,r2,1
 823e8a4:	e0bffd15 	stw	r2,-12(fp)
{
   struct arptabent *tp;
   int arp_count = 0;
   unsigned long lticks = cticks;

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 823e8a8:	e0bffc17 	ldw	r2,-16(fp)
 823e8ac:	10800804 	addi	r2,r2,32
 823e8b0:	e0bffc15 	stw	r2,-16(fp)
 823e8b4:	e0fffc17 	ldw	r3,-16(fp)
 823e8b8:	008209b4 	movhi	r2,2086
 823e8bc:	10ba6504 	addi	r2,r2,-5740
 823e8c0:	18bfd536 	bltu	r3,r2,823e818 <cb_arpent_tmo+0x30>
            arp_count++;
      }
   }

   /* if there are no more "pending" entries, kill the timer */
   if (arp_count == 0)
 823e8c4:	e0bffd17 	ldw	r2,-12(fp)
 823e8c8:	1000041e 	bne	r2,zero,823e8dc <cb_arpent_tmo+0xf4>
   {
      in_timerkill(arp_timer);
 823e8cc:	d0a0bf17 	ldw	r2,-32004(gp)
 823e8d0:	1009883a 	mov	r4,r2
 823e8d4:	823d5e80 	call	823d5e8 <in_timerkill>
      arp_timer = 0;
 823e8d8:	d020bf15 	stw	zero,-32004(gp)
   }
      
   USE_ARG(arg);
}
 823e8dc:	0001883a 	nop
 823e8e0:	e037883a 	mov	sp,fp
 823e8e4:	dfc00117 	ldw	ra,4(sp)
 823e8e8:	df000017 	ldw	fp,0(sp)
 823e8ec:	dec00204 	addi	sp,sp,8
 823e8f0:	f800283a 	ret

0823e8f4 <grat_arp>:
 * RETURNS: Returns 0 if OK, or the usual ENP_ errors 
 */

int
grat_arp(NET net, int flag)
{
 823e8f4:	defff704 	addi	sp,sp,-36
 823e8f8:	dfc00815 	stw	ra,32(sp)
 823e8fc:	df000715 	stw	fp,28(sp)
 823e900:	df000704 	addi	fp,sp,28
 823e904:	e13ffe15 	stw	r4,-8(fp)
 823e908:	e17fff15 	stw	r5,-4(fp)
   char * ethhdr;
   struct arp_hdr *  arphdr;
   IFMIB etif = net->n_mib;    /* mib info for this ethernet interface */
 823e90c:	e0bffe17 	ldw	r2,-8(fp)
 823e910:	10802717 	ldw	r2,156(r2)
 823e914:	e0bff915 	stw	r2,-28(fp)
   PACKET arppkt;

   /* get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 823e918:	01000084 	movi	r4,2
 823e91c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 823e920:	01000c04 	movi	r4,48
 823e924:	822c86c0 	call	822c86c <pk_alloc>
 823e928:	e0bffa15 	stw	r2,-24(fp)
   if (!arppkt)
 823e92c:	e0bffa17 	ldw	r2,-24(fp)
 823e930:	1000041e 	bne	r2,zero,823e944 <grat_arp+0x50>
   {
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e934:	01000084 	movi	r4,2
 823e938:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 823e93c:	00bffa84 	movi	r2,-22
 823e940:	00009506 	br	823eb98 <grat_arp+0x2a4>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823e944:	01000084 	movi	r4,2
 823e948:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 823e94c:	e0bffa17 	ldw	r2,-24(fp)
 823e950:	10c00117 	ldw	r3,4(r2)
 823e954:	e0bffa17 	ldw	r2,-24(fp)
 823e958:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 823e95c:	e0bffa17 	ldw	r2,-24(fp)
 823e960:	00c00c04 	movi	r3,48
 823e964:	10c00415 	stw	r3,16(r2)
   arppkt->net = net;
 823e968:	e0bffa17 	ldw	r2,-24(fp)
 823e96c:	e0fffe17 	ldw	r3,-8(fp)
 823e970:	10c00615 	stw	r3,24(r2)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 823e974:	e0bffa17 	ldw	r2,-24(fp)
 823e978:	10800117 	ldw	r2,4(r2)
 823e97c:	10800084 	addi	r2,r2,2
 823e980:	e0bffb15 	stw	r2,-20(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 823e984:	e0bffa17 	ldw	r2,-24(fp)
 823e988:	10800117 	ldw	r2,4(r2)
 823e98c:	10800404 	addi	r2,r2,16
 823e990:	e0bffc15 	stw	r2,-16(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 823e994:	e0bffc17 	ldw	r2,-16(fp)
 823e998:	00c04004 	movi	r3,256
 823e99c:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 823e9a0:	e0bffc17 	ldw	r2,-16(fp)
 823e9a4:	00c00204 	movi	r3,8
 823e9a8:	10c0008d 	sth	r3,2(r2)
   arphdr->ar_hln = 6;
 823e9ac:	e0bffc17 	ldw	r2,-16(fp)
 823e9b0:	00c00184 	movi	r3,6
 823e9b4:	10c00105 	stb	r3,4(r2)
   arphdr->ar_pln = 4;
 823e9b8:	e0bffc17 	ldw	r2,-16(fp)
 823e9bc:	00c00104 	movi	r3,4
 823e9c0:	10c00145 	stb	r3,5(r2)
   
   /* ARP req? */
   if (flag == 0)
 823e9c4:	e0bfff17 	ldw	r2,-4(fp)
 823e9c8:	1000041e 	bne	r2,zero,823e9dc <grat_arp+0xe8>
      /* yup */
      arphdr->ar_op = ARREQ;
 823e9cc:	e0bffc17 	ldw	r2,-16(fp)
 823e9d0:	00c04004 	movi	r3,256
 823e9d4:	10c0018d 	sth	r3,6(r2)
 823e9d8:	00000306 	br	823e9e8 <grat_arp+0xf4>
   else
     /* nope */
      arphdr->ar_op = ARREP;
 823e9dc:	e0bffc17 	ldw	r2,-16(fp)
 823e9e0:	00c08004 	movi	r3,512
 823e9e4:	10c0018d 	sth	r3,6(r2)
      
   arphdr->ar_tpa = net->n_ipaddr;        /* target's IP address */
 823e9e8:	e0bffe17 	ldw	r2,-8(fp)
 823e9ec:	10c00a17 	ldw	r3,40(r2)
 823e9f0:	e0bffc17 	ldw	r2,-16(fp)
 823e9f4:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = net->n_ipaddr;   /* my IP address */
 823e9f8:	e0bffe17 	ldw	r2,-8(fp)
 823e9fc:	10c00a17 	ldw	r3,40(r2)
 823ea00:	e0bffc17 	ldw	r2,-16(fp)
 823ea04:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 823ea08:	e0bffc17 	ldw	r2,-16(fp)
 823ea0c:	10c00204 	addi	r3,r2,8
 823ea10:	e0bff917 	ldw	r2,-28(fp)
 823ea14:	10800517 	ldw	r2,20(r2)
 823ea18:	01800184 	movi	r6,6
 823ea1c:	100b883a 	mov	r5,r2
 823ea20:	1809883a 	mov	r4,r3
 823ea24:	8202fd40 	call	8202fd4 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 823ea28:	01800184 	movi	r6,6
 823ea2c:	01403fc4 	movi	r5,255
 823ea30:	e13ffb17 	ldw	r4,-20(fp)
 823ea34:	82031300 	call	8203130 <memset>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 823ea38:	e0bffb17 	ldw	r2,-20(fp)
 823ea3c:	10c00184 	addi	r3,r2,6
 823ea40:	e0bff917 	ldw	r2,-28(fp)
 823ea44:	10800517 	ldw	r2,20(r2)
 823ea48:	01800184 	movi	r6,6
 823ea4c:	100b883a 	mov	r5,r2
 823ea50:	1809883a 	mov	r4,r3
 823ea54:	8202fd40 	call	8202fd4 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 823ea58:	e0bffb17 	ldw	r2,-20(fp)
 823ea5c:	10800304 	addi	r2,r2,12
 823ea60:	00c00204 	movi	r3,8
 823ea64:	10c00005 	stb	r3,0(r2)
 823ea68:	e0bffb17 	ldw	r2,-20(fp)
 823ea6c:	10800344 	addi	r2,r2,13
 823ea70:	00c00184 	movi	r3,6
 823ea74:	10c00005 	stb	r3,0(r2)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 823ea78:	e0bffc17 	ldw	r2,-16(fp)
 823ea7c:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 823ea80:	e0bffd17 	ldw	r2,-12(fp)
 823ea84:	10c00204 	addi	r3,r2,8
 823ea88:	e0bffc17 	ldw	r2,-16(fp)
 823ea8c:	10800204 	addi	r2,r2,8
 823ea90:	01800184 	movi	r6,6
 823ea94:	100b883a 	mov	r5,r2
 823ea98:	1809883a 	mov	r4,r3
 823ea9c:	8202fd40 	call	8202fd4 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 823eaa0:	e0bffd17 	ldw	r2,-12(fp)
 823eaa4:	10c00384 	addi	r3,r2,14
 823eaa8:	e0bffc17 	ldw	r2,-16(fp)
 823eaac:	10800404 	addi	r2,r2,16
 823eab0:	01800104 	movi	r6,4
 823eab4:	100b883a 	mov	r5,r2
 823eab8:	1809883a 	mov	r4,r3
 823eabc:	8202fd40 	call	8202fd4 <memmove>

   /* ARP req? */
   if (flag == 0)
 823eac0:	e0bfff17 	ldw	r2,-4(fp)
 823eac4:	1000091e 	bne	r2,zero,823eaec <grat_arp+0x1f8>
      /* yup */      
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 823eac8:	e0bffd17 	ldw	r2,-12(fp)
 823eacc:	10c00484 	addi	r3,r2,18
 823ead0:	e0bffc17 	ldw	r2,-16(fp)
 823ead4:	10800504 	addi	r2,r2,20
 823ead8:	01800184 	movi	r6,6
 823eadc:	100b883a 	mov	r5,r2
 823eae0:	1809883a 	mov	r4,r3
 823eae4:	8202fd40 	call	8202fd4 <memmove>
 823eae8:	00000806 	br	823eb0c <grat_arp+0x218>
   else
      /* nope */
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_sha, 6);
 823eaec:	e0bffd17 	ldw	r2,-12(fp)
 823eaf0:	10c00484 	addi	r3,r2,18
 823eaf4:	e0bffc17 	ldw	r2,-16(fp)
 823eaf8:	10800204 	addi	r2,r2,8
 823eafc:	01800184 	movi	r6,6
 823eb00:	100b883a 	mov	r5,r2
 823eb04:	1809883a 	mov	r4,r3
 823eb08:	8202fd40 	call	8202fd4 <memmove>
      
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 823eb0c:	e0bffd17 	ldw	r2,-12(fp)
 823eb10:	10c00604 	addi	r3,r2,24
 823eb14:	e0bffc17 	ldw	r2,-16(fp)
 823eb18:	10800704 	addi	r2,r2,28
 823eb1c:	01800104 	movi	r6,4
 823eb20:	100b883a 	mov	r5,r2
 823eb24:	1809883a 	mov	r4,r3
 823eb28:	8202fd40 	call	8202fd4 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 823eb2c:	e0bffe17 	ldw	r2,-8(fp)
 823eb30:	10800417 	ldw	r2,16(r2)
 823eb34:	10000526 	beq	r2,zero,823eb4c <grat_arp+0x258>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 823eb38:	e0bffe17 	ldw	r2,-8(fp)
 823eb3c:	10800417 	ldw	r2,16(r2)
 823eb40:	e13ffa17 	ldw	r4,-24(fp)
 823eb44:	103ee83a 	callr	r2
 823eb48:	00000f06 	br	823eb88 <grat_arp+0x294>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 823eb4c:	e0bffe17 	ldw	r2,-8(fp)
 823eb50:	10800317 	ldw	r2,12(r2)
 823eb54:	e0fffa17 	ldw	r3,-24(fp)
 823eb58:	19000617 	ldw	r4,24(r3)
 823eb5c:	e0fffa17 	ldw	r3,-24(fp)
 823eb60:	18c00117 	ldw	r3,4(r3)
 823eb64:	01800c04 	movi	r6,48
 823eb68:	180b883a 	mov	r5,r3
 823eb6c:	103ee83a 	callr	r2
      LOCK_NET_RESOURCE(FREEQ_RESID);
 823eb70:	01000084 	movi	r4,2
 823eb74:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 823eb78:	e13ffa17 	ldw	r4,-24(fp)
 823eb7c:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823eb80:	01000084 	movi	r4,2
 823eb84:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 823eb88:	d0a0c317 	ldw	r2,-31988(gp)
 823eb8c:	10800044 	addi	r2,r2,1
 823eb90:	d0a0c315 	stw	r2,-31988(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 823eb94:	00800044 	movi	r2,1
}
 823eb98:	e037883a 	mov	sp,fp
 823eb9c:	dfc00117 	ldw	ra,4(sp)
 823eba0:	df000017 	ldw	fp,0(sp)
 823eba4:	dec00204 	addi	sp,sp,8
 823eba8:	f800283a 	ret

0823ebac <if_getbynum>:
 * RETURNS: Returns NET pointer, or NULL if out of range
 */

NET
if_getbynum(int ifnum)
{
 823ebac:	defffc04 	addi	sp,sp,-16
 823ebb0:	dfc00315 	stw	ra,12(sp)
 823ebb4:	df000215 	stw	fp,8(sp)
 823ebb8:	df000204 	addi	fp,sp,8
 823ebbc:	e13fff15 	stw	r4,-4(fp)
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823ebc0:	008209b4 	movhi	r2,2086
 823ebc4:	10ba6504 	addi	r2,r2,-5740
 823ebc8:	10800017 	ldw	r2,0(r2)
 823ebcc:	e0bffe15 	stw	r2,-8(fp)
 823ebd0:	00000906 	br	823ebf8 <if_getbynum+0x4c>
   {
      if(ifnum-- == 0)
 823ebd4:	e0bfff17 	ldw	r2,-4(fp)
 823ebd8:	10ffffc4 	addi	r3,r2,-1
 823ebdc:	e0ffff15 	stw	r3,-4(fp)
 823ebe0:	1000021e 	bne	r2,zero,823ebec <if_getbynum+0x40>
         return ifp;
 823ebe4:	e0bffe17 	ldw	r2,-8(fp)
 823ebe8:	00000706 	br	823ec08 <if_getbynum+0x5c>

NET
if_getbynum(int ifnum)
{
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823ebec:	e0bffe17 	ldw	r2,-8(fp)
 823ebf0:	10800017 	ldw	r2,0(r2)
 823ebf4:	e0bffe15 	stw	r2,-8(fp)
 823ebf8:	e0bffe17 	ldw	r2,-8(fp)
 823ebfc:	103ff51e 	bne	r2,zero,823ebd4 <if_getbynum+0x28>
   {
      if(ifnum-- == 0)
         return ifp;
   }
   dtrap();
 823ec00:	822d4140 	call	822d414 <dtrap>
   return NULL;   /* list is not long enough */
 823ec04:	0005883a 	mov	r2,zero
}
 823ec08:	e037883a 	mov	sp,fp
 823ec0c:	dfc00117 	ldw	ra,4(sp)
 823ec10:	df000017 	ldw	fp,0(sp)
 823ec14:	dec00204 	addi	sp,sp,8
 823ec18:	f800283a 	ret

0823ec1c <isbcast>:
 * RETURNS:  Returns TRUE if broadcast, else false. 
 */

int
isbcast(NET ifc, unsigned char * addr)
{
 823ec1c:	defffd04 	addi	sp,sp,-12
 823ec20:	df000215 	stw	fp,8(sp)
 823ec24:	df000204 	addi	fp,sp,8
 823ec28:	e13ffe15 	stw	r4,-8(fp)
 823ec2c:	e17fff15 	stw	r5,-4(fp)
#if (ALIGN_TYPE > 2)
   /* On systems with 32bit alignment requirements we have to make
    * sure our tests are aligned. Specifically, this results in "data
    * abort" errors on the Samsung/ARM port. 
    */
   if((u_long)addr & (ALIGN_TYPE - 1))
 823ec30:	e0bfff17 	ldw	r2,-4(fp)
 823ec34:	108000cc 	andi	r2,r2,3
 823ec38:	10000e26 	beq	r2,zero,823ec74 <isbcast+0x58>
   {
      /* check first two bytes */
      if ((u_short)*(u_short*)(addr) != 0xFFFF)
 823ec3c:	e0bfff17 	ldw	r2,-4(fp)
 823ec40:	1080000b 	ldhu	r2,0(r2)
 823ec44:	10ffffcc 	andi	r3,r2,65535
 823ec48:	00bfffd4 	movui	r2,65535
 823ec4c:	18800226 	beq	r3,r2,823ec58 <isbcast+0x3c>
         return(FALSE);
 823ec50:	0005883a 	mov	r2,zero
 823ec54:	00002206 	br	823ece0 <isbcast+0xc4>
      if ((u_long)(*(u_long*)(addr + 2)) != 0xFFFFFFFF)
 823ec58:	e0bfff17 	ldw	r2,-4(fp)
 823ec5c:	10800084 	addi	r2,r2,2
 823ec60:	10800017 	ldw	r2,0(r2)
 823ec64:	10bfffe0 	cmpeqi	r2,r2,-1
 823ec68:	1000101e 	bne	r2,zero,823ecac <isbcast+0x90>
         return FALSE;
 823ec6c:	0005883a 	mov	r2,zero
 823ec70:	00001b06 	br	823ece0 <isbcast+0xc4>
#endif /* ALIGN_TYPE > 4 */
   {
      /* check first four bytes for all ones. Since this is the fastest
       * test, do it first
       */
      if ((u_long)(*(u_long*)addr) != 0xFFFFFFFF)
 823ec74:	e0bfff17 	ldw	r2,-4(fp)
 823ec78:	10800017 	ldw	r2,0(r2)
 823ec7c:	10bfffe0 	cmpeqi	r2,r2,-1
 823ec80:	1000021e 	bne	r2,zero,823ec8c <isbcast+0x70>
         return FALSE;
 823ec84:	0005883a 	mov	r2,zero
 823ec88:	00001506 	br	823ece0 <isbcast+0xc4>

      /* check last two bytes */
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
 823ec8c:	e0bfff17 	ldw	r2,-4(fp)
 823ec90:	10800104 	addi	r2,r2,4
 823ec94:	1080000b 	ldhu	r2,0(r2)
 823ec98:	10ffffcc 	andi	r3,r2,65535
 823ec9c:	00bfffd4 	movui	r2,65535
 823eca0:	18800226 	beq	r3,r2,823ecac <isbcast+0x90>
         return(FALSE);
 823eca4:	0005883a 	mov	r2,zero
 823eca8:	00000d06 	br	823ece0 <isbcast+0xc4>
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 823ecac:	e0bffe17 	ldw	r2,-8(fp)
 823ecb0:	10802717 	ldw	r2,156(r2)
 823ecb4:	10800217 	ldw	r2,8(r2)
 823ecb8:	108005e0 	cmpeqi	r2,r2,23
 823ecbc:	1000051e 	bne	r2,zero,823ecd4 <isbcast+0xb8>
       (ifc->n_mib->ifType == SLIP))
 823ecc0:	e0bffe17 	ldw	r2,-8(fp)
 823ecc4:	10802717 	ldw	r2,156(r2)
 823ecc8:	10800217 	ldw	r2,8(r2)
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
         return(FALSE);
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 823eccc:	10800718 	cmpnei	r2,r2,28
 823ecd0:	1000021e 	bne	r2,zero,823ecdc <isbcast+0xc0>
       (ifc->n_mib->ifType == SLIP))
   {
      return FALSE;
 823ecd4:	0005883a 	mov	r2,zero
 823ecd8:	00000106 	br	823ece0 <isbcast+0xc4>
   }

   /* passed all tests, must be broadcast */
   return(TRUE);
 823ecdc:	00800044 	movi	r2,1
}
 823ece0:	e037883a 	mov	sp,fp
 823ece4:	df000017 	ldw	fp,0(sp)
 823ece8:	dec00104 	addi	sp,sp,4
 823ecec:	f800283a 	ret

0823ecf0 <reg_type>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
reg_type(unshort type)
{
 823ecf0:	defffb04 	addi	sp,sp,-20
 823ecf4:	dfc00415 	stw	ra,16(sp)
 823ecf8:	df000315 	stw	fp,12(sp)
 823ecfc:	df000304 	addi	fp,sp,12
 823ed00:	2005883a 	mov	r2,r4
 823ed04:	e0bfff0d 	sth	r2,-4(fp)
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823ed08:	008209b4 	movhi	r2,2086
 823ed0c:	10ba6504 	addi	r2,r2,-5740
 823ed10:	10800017 	ldw	r2,0(r2)
 823ed14:	e0bffd15 	stw	r2,-12(fp)
 823ed18:	00001106 	br	823ed60 <reg_type+0x70>
   {
      if (ifp->n_reg_type)    /* make sure call exists */
 823ed1c:	e0bffd17 	ldw	r2,-12(fp)
 823ed20:	10800617 	ldw	r2,24(r2)
 823ed24:	10000b26 	beq	r2,zero,823ed54 <reg_type+0x64>
      {
         e = (ifp->n_reg_type)(type, ifp);
 823ed28:	e0bffd17 	ldw	r2,-12(fp)
 823ed2c:	10800617 	ldw	r2,24(r2)
 823ed30:	e0ffff0b 	ldhu	r3,-4(fp)
 823ed34:	e17ffd17 	ldw	r5,-12(fp)
 823ed38:	1809883a 	mov	r4,r3
 823ed3c:	103ee83a 	callr	r2
 823ed40:	e0bffe15 	stw	r2,-8(fp)
         if (e)
 823ed44:	e0bffe17 	ldw	r2,-8(fp)
 823ed48:	10000226 	beq	r2,zero,823ed54 <reg_type+0x64>
            return e;   /* bails out if error */
 823ed4c:	e0bffe17 	ldw	r2,-8(fp)
 823ed50:	00000606 	br	823ed6c <reg_type+0x7c>
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 823ed54:	e0bffd17 	ldw	r2,-12(fp)
 823ed58:	10800017 	ldw	r2,0(r2)
 823ed5c:	e0bffd15 	stw	r2,-12(fp)
 823ed60:	e0bffd17 	ldw	r2,-12(fp)
 823ed64:	103fed1e 	bne	r2,zero,823ed1c <reg_type+0x2c>
         e = (ifp->n_reg_type)(type, ifp);
         if (e)
            return e;   /* bails out if error */
      }
   }
   return 0;   /* OK code */
 823ed68:	0005883a 	mov	r2,zero
}
 823ed6c:	e037883a 	mov	sp,fp
 823ed70:	dfc00117 	ldw	ra,4(sp)
 823ed74:	df000017 	ldw	fp,0(sp)
 823ed78:	dec00204 	addi	sp,sp,8
 823ed7c:	f800283a 	ret

0823ed80 <if_killsocks>:
 */

      /* kill this NETs sockets */
void
if_killsocks(NET ifp)
{
 823ed80:	defffa04 	addi	sp,sp,-24
 823ed84:	dfc00515 	stw	ra,20(sp)
 823ed88:	df000415 	stw	fp,16(sp)
 823ed8c:	df000404 	addi	fp,sp,16
 823ed90:	e13fff15 	stw	r4,-4(fp)
   struct socket * so;
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
 823ed94:	008209b4 	movhi	r2,2086
 823ed98:	10b96104 	addi	r2,r2,-6780
 823ed9c:	10800017 	ldw	r2,0(r2)
 823eda0:	e0bffc15 	stw	r2,-16(fp)
   while(so)
 823eda4:	00001306 	br	823edf4 <if_killsocks+0x74>
   {
      if(so->so_pcb)
 823eda8:	e0bffc17 	ldw	r2,-16(fp)
 823edac:	10800117 	ldw	r2,4(r2)
 823edb0:	10000526 	beq	r2,zero,823edc8 <if_killsocks+0x48>
         so_ifp = so->so_pcb->ifp;
 823edb4:	e0bffc17 	ldw	r2,-16(fp)
 823edb8:	10800117 	ldw	r2,4(r2)
 823edbc:	10800a17 	ldw	r2,40(r2)
 823edc0:	e0bffd15 	stw	r2,-12(fp)
 823edc4:	00000106 	br	823edcc <if_killsocks+0x4c>
      else
         so_ifp = NULL;
 823edc8:	e03ffd15 	stw	zero,-12(fp)
      next = (struct socket *)so->next;
 823edcc:	e0bffc17 	ldw	r2,-16(fp)
 823edd0:	10800017 	ldw	r2,0(r2)
 823edd4:	e0bffe15 	stw	r2,-8(fp)
      if (so_ifp == ifp)
 823edd8:	e0fffd17 	ldw	r3,-12(fp)
 823eddc:	e0bfff17 	ldw	r2,-4(fp)
 823ede0:	1880021e 	bne	r3,r2,823edec <if_killsocks+0x6c>
      {
         /* this is a direct heavy-handed close. A reset is sent
          * and all data is lost. The user should really have closed
          * all the sockets gracfully first.... 
          */
         soabort(so);
 823ede4:	e13ffc17 	ldw	r4,-16(fp)
 823ede8:	8231f540 	call	8231f54 <soabort>
      }
      so = next;
 823edec:	e0bffe17 	ldw	r2,-8(fp)
 823edf0:	e0bffc15 	stw	r2,-16(fp)
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
   while(so)
 823edf4:	e0bffc17 	ldw	r2,-16(fp)
 823edf8:	103feb1e 	bne	r2,zero,823eda8 <if_killsocks+0x28>
          */
         soabort(so);
      }
      so = next;
   }
}
 823edfc:	0001883a 	nop
 823ee00:	e037883a 	mov	sp,fp
 823ee04:	dfc00117 	ldw	ra,4(sp)
 823ee08:	df000017 	ldw	fp,0(sp)
 823ee0c:	dec00204 	addi	sp,sp,8
 823ee10:	f800283a 	ret

0823ee14 <ip_init>:
 * OK, else returns a non-zero error code. 
 */

int
ip_init(void)
{
 823ee14:	defffe04 	addi	sp,sp,-8
 823ee18:	dfc00115 	stw	ra,4(sp)
 823ee1c:	df000015 	stw	fp,0(sp)
 823ee20:	d839883a 	mov	fp,sp

   /* register IP type with link layer drivers */
   if (reg_type(IP_TYPE) != 0)
 823ee24:	01000204 	movi	r4,8
 823ee28:	823ecf00 	call	823ecf0 <reg_type>
 823ee2c:	10000526 	beq	r2,zero,823ee44 <ip_init+0x30>
   {   
#ifdef NPDEBUG
      dprintf("IP_INIT: unable to register type with MAC driver\n");
 823ee30:	01020974 	movhi	r4,2085
 823ee34:	21046604 	addi	r4,r4,4504
 823ee38:	82035a00 	call	82035a0 <puts>
#endif
      return(1);
 823ee3c:	00800044 	movi	r2,1
 823ee40:	00002906 	br	823eee8 <ip_init+0xd4>
   }

   /* initialize the IP mib */
   MEMSET(&ip_mib, 0, sizeof(ip_mib));
 823ee44:	01801404 	movi	r6,80
 823ee48:	000b883a 	mov	r5,zero
 823ee4c:	010209b4 	movhi	r4,2086
 823ee50:	213a6a04 	addi	r4,r4,-5720
 823ee54:	82031300 	call	8203130 <memset>
   ip_mib.ipForwarding = 2;   /* default to host, not gateway (router) */
 823ee58:	008209b4 	movhi	r2,2086
 823ee5c:	10ba6a04 	addi	r2,r2,-5720
 823ee60:	00c00084 	movi	r3,2
 823ee64:	10c00015 	stw	r3,0(r2)
   ip_mib.ipDefaultTTL = IP_TTL;
 823ee68:	008209b4 	movhi	r2,2086
 823ee6c:	10ba6a04 	addi	r2,r2,-5720
 823ee70:	00c01004 	movi	r3,64
 823ee74:	10c00115 	stw	r3,4(r2)

#ifdef IP_ROUTING
   /* alloc space for the route table */
   rt_mib = (struct RtMib*)RT_ALLOC(ipRoutes * sizeof(struct RtMib));
 823ee78:	d0a05117 	ldw	r2,-32444(gp)
 823ee7c:	10800f24 	muli	r2,r2,60
 823ee80:	1009883a 	mov	r4,r2
 823ee84:	822dfec0 	call	822dfec <npalloc>
 823ee88:	d0a0c615 	stw	r2,-31976(gp)
   if (!rt_mib)
 823ee8c:	d0a0c617 	ldw	r2,-31976(gp)
 823ee90:	1000051e 	bne	r2,zero,823eea8 <ip_init+0x94>
   {
#ifdef NPDEBUG
      dprintf("IP_INIT ERROR: can't alloc route table\n");
 823ee94:	01020974 	movhi	r4,2085
 823ee98:	21047304 	addi	r4,r4,4556
 823ee9c:	82035a00 	call	82035a0 <puts>
#endif   /* NPDEBUG */
      return(ENP_NOMEM);
 823eea0:	00bffb04 	movi	r2,-20
 823eea4:	00001006 	br	823eee8 <ip_init+0xd4>
   }

  MEMSET(rt_mib,0, ipRoutes * sizeof(struct RtMib)) ;
 823eea8:	d0e0c617 	ldw	r3,-31976(gp)
 823eeac:	d0a05117 	ldw	r2,-32444(gp)
 823eeb0:	10800f24 	muli	r2,r2,60
 823eeb4:	100d883a 	mov	r6,r2
 823eeb8:	000b883a 	mov	r5,zero
 823eebc:	1809883a 	mov	r4,r3
 823eec0:	82031300 	call	8203130 <memset>
  ip_mib.ipForwarding = 1;   /* override default, be gateway (router) */
 823eec4:	008209b4 	movhi	r2,2086
 823eec8:	10ba6a04 	addi	r2,r2,-5720
 823eecc:	00c00044 	movi	r3,1
 823eed0:	10c00015 	stw	r3,0(r2)
#endif   /* IP_ROUTING */

   /* set IP reassembly timeout */
   ip_mib.ipReasmTimeout = IRE_TMO;
 823eed4:	008209b4 	movhi	r2,2086
 823eed8:	10ba6a04 	addi	r2,r2,-5720
 823eedc:	00c01e04 	movi	r3,120
 823eee0:	10c00c15 	stw	r3,48(r2)
      return(1);
   }
#endif   /* IPSEC */

   /* everything opened OK return 0 */
   return(SUCCESS);
 823eee4:	0005883a 	mov	r2,zero
}
 823eee8:	e037883a 	mov	sp,fp
 823eeec:	dfc00117 	ldw	ra,4(sp)
 823eef0:	df000017 	ldw	fp,0(sp)
 823eef4:	dec00204 	addi	sp,sp,8
 823eef8:	f800283a 	ret

0823eefc <ip_bldhead>:
 * RETURNS: void
 */

void
ip_bldhead(PACKET p, unsigned pid, u_char prot, unshort fragword)
{
 823eefc:	defff804 	addi	sp,sp,-32
 823ef00:	dfc00715 	stw	ra,28(sp)
 823ef04:	df000615 	stw	fp,24(sp)
 823ef08:	df000604 	addi	fp,sp,24
 823ef0c:	e13ffc15 	stw	r4,-16(fp)
 823ef10:	e17ffd15 	stw	r5,-12(fp)
 823ef14:	3007883a 	mov	r3,r6
 823ef18:	3805883a 	mov	r2,r7
 823ef1c:	e0fffe05 	stb	r3,-8(fp)
 823ef20:	e0bfff0d 	sth	r2,-4(fp)
   struct ip * pip;
   struct ip_socopts *sopts;

   /* prepend IP header to packet data */
   p->nb_prot -= sizeof(struct ip);       /* this assumes no send options! */
 823ef24:	e0bffc17 	ldw	r2,-16(fp)
 823ef28:	10800317 	ldw	r2,12(r2)
 823ef2c:	10fffb04 	addi	r3,r2,-20
 823ef30:	e0bffc17 	ldw	r2,-16(fp)
 823ef34:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 823ef38:	e0bffc17 	ldw	r2,-16(fp)
 823ef3c:	10800417 	ldw	r2,16(r2)
 823ef40:	10c00504 	addi	r3,r2,20
 823ef44:	e0bffc17 	ldw	r2,-16(fp)
 823ef48:	10c00415 	stw	r3,16(r2)

   pip = (struct ip*)p->nb_prot;
 823ef4c:	e0bffc17 	ldw	r2,-16(fp)
 823ef50:	10800317 	ldw	r2,12(r2)
 823ef54:	e0bffa15 	stw	r2,-24(fp)

   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 823ef58:	e0bffa17 	ldw	r2,-24(fp)
 823ef5c:	00c01144 	movi	r3,69
 823ef60:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = fragword; /* fragment flags and offset */
 823ef64:	e0bffa17 	ldw	r2,-24(fp)
 823ef68:	e0ffff0b 	ldhu	r3,-4(fp)
 823ef6c:	10c0018d 	sth	r3,6(r2)
   pip->ip_id = htons((unshort)pid);   /* IP datagram ID */
 823ef70:	e0bffd17 	ldw	r2,-12(fp)
 823ef74:	10bfffcc 	andi	r2,r2,65535
 823ef78:	1005d23a 	srai	r2,r2,8
 823ef7c:	10803fcc 	andi	r2,r2,255
 823ef80:	1007883a 	mov	r3,r2
 823ef84:	e0bffd17 	ldw	r2,-12(fp)
 823ef88:	10bfffcc 	andi	r2,r2,65535
 823ef8c:	1004923a 	slli	r2,r2,8
 823ef90:	1884b03a 	or	r2,r3,r2
 823ef94:	1007883a 	mov	r3,r2
 823ef98:	e0bffa17 	ldw	r2,-24(fp)
 823ef9c:	10c0010d 	sth	r3,4(r2)
   pip->ip_len = htons((unshort)p->nb_plen);
 823efa0:	e0bffc17 	ldw	r2,-16(fp)
 823efa4:	10800417 	ldw	r2,16(r2)
 823efa8:	10bfffcc 	andi	r2,r2,65535
 823efac:	1005d23a 	srai	r2,r2,8
 823efb0:	10803fcc 	andi	r2,r2,255
 823efb4:	1007883a 	mov	r3,r2
 823efb8:	e0bffc17 	ldw	r2,-16(fp)
 823efbc:	10800417 	ldw	r2,16(r2)
 823efc0:	10bfffcc 	andi	r2,r2,65535
 823efc4:	1004923a 	slli	r2,r2,8
 823efc8:	1884b03a 	or	r2,r3,r2
 823efcc:	1007883a 	mov	r3,r2
 823efd0:	e0bffa17 	ldw	r2,-24(fp)
 823efd4:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;          /* install protocol ID (TCP, UDP, etc) */
 823efd8:	e0bffa17 	ldw	r2,-24(fp)
 823efdc:	e0fffe03 	ldbu	r3,-8(fp)
 823efe0:	10c00245 	stb	r3,9(r2)

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 823efe4:	e0bffc17 	ldw	r2,-16(fp)
 823efe8:	10800c17 	ldw	r2,48(r2)
 823efec:	e0bffb15 	stw	r2,-20(fp)
 823eff0:	e0bffb17 	ldw	r2,-20(fp)
 823eff4:	10001126 	beq	r2,zero,823f03c <ip_bldhead+0x140>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 823eff8:	e0bffb17 	ldw	r2,-20(fp)
 823effc:	10800043 	ldbu	r2,1(r2)
 823f000:	10803fcc 	andi	r2,r2,255
 823f004:	10000526 	beq	r2,zero,823f01c <ip_bldhead+0x120>
         pip->ip_time = sopts->ip_ttl;
 823f008:	e0bffb17 	ldw	r2,-20(fp)
 823f00c:	10c00043 	ldbu	r3,1(r2)
 823f010:	e0bffa17 	ldw	r2,-24(fp)
 823f014:	10c00205 	stb	r3,8(r2)
 823f018:	00000306 	br	823f028 <ip_bldhead+0x12c>
	  else
         pip->ip_time = (u_char)IP_TTL;     /* default number of hops, really */
 823f01c:	e0bffa17 	ldw	r2,-24(fp)
 823f020:	00c01004 	movi	r3,64
 823f024:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 823f028:	e0bffb17 	ldw	r2,-20(fp)
 823f02c:	10c00003 	ldbu	r3,0(r2)
 823f030:	e0bffa17 	ldw	r2,-24(fp)
 823f034:	10c00045 	stb	r3,1(r2)
 823f038:	00000506 	br	823f050 <ip_bldhead+0x154>
   }
   else
   {
	  /* nope */
      pip->ip_time = (u_char)IP_TTL;       /* default number of hops, really */
 823f03c:	e0bffa17 	ldw	r2,-24(fp)
 823f040:	00c01004 	movi	r3,64
 823f044:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 823f048:	e0bffa17 	ldw	r2,-24(fp)
 823f04c:	10000045 	stb	zero,1(r2)
   }
   
   pip->ip_chksum = IPXSUM;      /* clear checksum field for summing */
 823f050:	e0bffa17 	ldw	r2,-24(fp)
 823f054:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 823f058:	01400284 	movi	r5,10
 823f05c:	e13ffa17 	ldw	r4,-24(fp)
 823f060:	82286f00 	call	82286f0 <cksum>
 823f064:	0084303a 	nor	r2,zero,r2
 823f068:	1007883a 	mov	r3,r2
 823f06c:	e0bffa17 	ldw	r2,-24(fp)
 823f070:	10c0028d 	sth	r3,10(r2)
}
 823f074:	0001883a 	nop
 823f078:	e037883a 	mov	sp,fp
 823f07c:	dfc00117 	ldw	ra,4(sp)
 823f080:	df000017 	ldw	fp,0(sp)
 823f084:	dec00204 	addi	sp,sp,8
 823f088:	f800283a 	ret

0823f08c <ip_write_internal>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_write_internal(PACKET p)
{
 823f08c:	defff004 	addi	sp,sp,-64
 823f090:	dfc00f15 	stw	ra,60(sp)
 823f094:	df000e15 	stw	fp,56(sp)
 823f098:	df000e04 	addi	fp,sp,56
 823f09c:	e13fff15 	stw	r4,-4(fp)
   PACKET newpkt;
   unsigned maxbuflen;

#ifdef IP_MULTICAST
   /* If destination address is multicast, process multicast options */
   if (IN_MULTICAST(ntohl(p->fhost)))
 823f0a0:	e0bfff17 	ldw	r2,-4(fp)
 823f0a4:	10800717 	ldw	r2,28(r2)
 823f0a8:	1006d63a 	srli	r3,r2,24
 823f0ac:	e0bfff17 	ldw	r2,-4(fp)
 823f0b0:	10800717 	ldw	r2,28(r2)
 823f0b4:	1004d23a 	srli	r2,r2,8
 823f0b8:	10bfc00c 	andi	r2,r2,65280
 823f0bc:	1886b03a 	or	r3,r3,r2
 823f0c0:	e0bfff17 	ldw	r2,-4(fp)
 823f0c4:	10800717 	ldw	r2,28(r2)
 823f0c8:	10bfc00c 	andi	r2,r2,65280
 823f0cc:	1004923a 	slli	r2,r2,8
 823f0d0:	1886b03a 	or	r3,r3,r2
 823f0d4:	e0bfff17 	ldw	r2,-4(fp)
 823f0d8:	10800717 	ldw	r2,28(r2)
 823f0dc:	1004963a 	slli	r2,r2,24
 823f0e0:	1884b03a 	or	r2,r3,r2
 823f0e4:	10fc002c 	andhi	r3,r2,61440
 823f0e8:	00b80034 	movhi	r2,57344
 823f0ec:	1880a81e 	bne	r3,r2,823f390 <ip_write_internal+0x304>
   {
      if (p->imo != NULL)
 823f0f0:	e0bfff17 	ldw	r2,-4(fp)
 823f0f4:	10800b17 	ldw	r2,44(r2)
 823f0f8:	10001426 	beq	r2,zero,823f14c <ip_write_internal+0xc0>
         if (p->imo->imo_multicast_netp)
 823f0fc:	e0bfff17 	ldw	r2,-4(fp)
 823f100:	10800b17 	ldw	r2,44(r2)
 823f104:	10800017 	ldw	r2,0(r2)
 823f108:	10000626 	beq	r2,zero,823f124 <ip_write_internal+0x98>
            p->net = p->imo->imo_multicast_netp;
 823f10c:	e0bfff17 	ldw	r2,-4(fp)
 823f110:	10800b17 	ldw	r2,44(r2)
 823f114:	10c00017 	ldw	r3,0(r2)
 823f118:	e0bfff17 	ldw	r2,-4(fp)
 823f11c:	10c00615 	stw	r3,24(r2)
 823f120:	00002506 	br	823f1b8 <ip_write_internal+0x12c>
         else
            p->net = iproute(p->fhost, &firsthop);
 823f124:	e0bfff17 	ldw	r2,-4(fp)
 823f128:	10800717 	ldw	r2,28(r2)
 823f12c:	e0fffe04 	addi	r3,fp,-8
 823f130:	180b883a 	mov	r5,r3
 823f134:	1009883a 	mov	r4,r2
 823f138:	8240b4c0 	call	8240b4c <iproute>
 823f13c:	1007883a 	mov	r3,r2
 823f140:	e0bfff17 	ldw	r2,-4(fp)
 823f144:	10c00615 	stw	r3,24(r2)
 823f148:	00001b06 	br	823f1b8 <ip_write_internal+0x12c>
      else
      {
         for (i = 0; i < ifNumber; i++)
 823f14c:	e03ff515 	stw	zero,-44(fp)
 823f150:	00001606 	br	823f1ac <ip_write_internal+0x120>
            if (nets[i]->n_mcastlist)
 823f154:	008209b4 	movhi	r2,2086
 823f158:	10b82404 	addi	r2,r2,-8048
 823f15c:	e0fff517 	ldw	r3,-44(fp)
 823f160:	18c7883a 	add	r3,r3,r3
 823f164:	18c7883a 	add	r3,r3,r3
 823f168:	10c5883a 	add	r2,r2,r3
 823f16c:	10800017 	ldw	r2,0(r2)
 823f170:	10802b17 	ldw	r2,172(r2)
 823f174:	10000a26 	beq	r2,zero,823f1a0 <ip_write_internal+0x114>
            {
               p->net = nets[i];
 823f178:	008209b4 	movhi	r2,2086
 823f17c:	10b82404 	addi	r2,r2,-8048
 823f180:	e0fff517 	ldw	r3,-44(fp)
 823f184:	18c7883a 	add	r3,r3,r3
 823f188:	18c7883a 	add	r3,r3,r3
 823f18c:	10c5883a 	add	r2,r2,r3
 823f190:	10c00017 	ldw	r3,0(r2)
 823f194:	e0bfff17 	ldw	r2,-4(fp)
 823f198:	10c00615 	stw	r3,24(r2)
               break;
 823f19c:	00000606 	br	823f1b8 <ip_write_internal+0x12c>
            p->net = p->imo->imo_multicast_netp;
         else
            p->net = iproute(p->fhost, &firsthop);
      else
      {
         for (i = 0; i < ifNumber; i++)
 823f1a0:	e0bff517 	ldw	r2,-44(fp)
 823f1a4:	10800044 	addi	r2,r2,1
 823f1a8:	e0bff515 	stw	r2,-44(fp)
 823f1ac:	d0a08417 	ldw	r2,-32240(gp)
 823f1b0:	e0fff517 	ldw	r3,-44(fp)
 823f1b4:	18bfe736 	bltu	r3,r2,823f154 <ip_write_internal+0xc8>
               break;
            }
      }

      /* Confirm that the outgoing interface supports multicast. */
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
 823f1b8:	e0bfff17 	ldw	r2,-4(fp)
 823f1bc:	10800617 	ldw	r2,24(r2)
 823f1c0:	10000426 	beq	r2,zero,823f1d4 <ip_write_internal+0x148>
 823f1c4:	e0bfff17 	ldw	r2,-4(fp)
 823f1c8:	10800617 	ldw	r2,24(r2)
 823f1cc:	10802b17 	ldw	r2,172(r2)
 823f1d0:	10002c1e 	bne	r2,zero,823f284 <ip_write_internal+0x1f8>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 823f1d4:	d0a08317 	ldw	r2,-32244(gp)
 823f1d8:	1080840c 	andi	r2,r2,528
 823f1dc:	10001a26 	beq	r2,zero,823f248 <ip_write_internal+0x1bc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f1e0:	e0bfff17 	ldw	r2,-4(fp)
 823f1e4:	11400417 	ldw	r5,16(r2)
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f1e8:	e0bfff17 	ldw	r2,-4(fp)
 823f1ec:	10800717 	ldw	r2,28(r2)
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f1f0:	11803fcc 	andi	r6,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f1f4:	e0bfff17 	ldw	r2,-4(fp)
 823f1f8:	10800717 	ldw	r2,28(r2)
 823f1fc:	1004d23a 	srli	r2,r2,8
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f200:	10803fcc 	andi	r2,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f204:	e0ffff17 	ldw	r3,-4(fp)
 823f208:	18c00717 	ldw	r3,28(r3)
 823f20c:	1806d43a 	srli	r3,r3,16
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f210:	18c03fcc 	andi	r3,r3,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f214:	e13fff17 	ldw	r4,-4(fp)
 823f218:	21000717 	ldw	r4,28(r4)
 823f21c:	2008d63a 	srli	r4,r4,24
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f220:	d9000215 	stw	r4,8(sp)
 823f224:	d8c00115 	stw	r3,4(sp)
 823f228:	d8800015 	stw	r2,0(sp)
 823f22c:	300f883a 	mov	r7,r6
 823f230:	280d883a 	mov	r6,r5
 823f234:	e17fff17 	ldw	r5,-4(fp)
 823f238:	01020974 	movhi	r4,2085
 823f23c:	21047d04 	addi	r4,r4,4596
 823f240:	820331c0 	call	820331c <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 823f244:	822d4140 	call	822d414 <dtrap>
         }
#endif
         ip_mib.ipOutNoRoutes++;
 823f248:	008209b4 	movhi	r2,2086
 823f24c:	10ba6a04 	addi	r2,r2,-5720
 823f250:	10800b17 	ldw	r2,44(r2)
 823f254:	10c00044 	addi	r3,r2,1
 823f258:	008209b4 	movhi	r2,2086
 823f25c:	10ba6a04 	addi	r2,r2,-5720
 823f260:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f264:	01000084 	movi	r4,2
 823f268:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free(p);
 823f26c:	e13fff17 	ldw	r4,-4(fp)
 823f270:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f274:	01000084 	movi	r4,2
 823f278:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 823f27c:	00bff7c4 	movi	r2,-33
 823f280:	00014606 	br	823f79c <ip_write_internal+0x710>
       * If we belong to the destination multicast group
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
 823f284:	e0bfff17 	ldw	r2,-4(fp)
 823f288:	10c00717 	ldw	r3,28(r2)
 823f28c:	e0bfff17 	ldw	r2,-4(fp)
 823f290:	10800617 	ldw	r2,24(r2)
 823f294:	100b883a 	mov	r5,r2
 823f298:	1809883a 	mov	r4,r3
 823f29c:	82439f80 	call	82439f8 <lookup_mcast>
 823f2a0:	e0bff715 	stw	r2,-36(fp)
      if ((inm != NULL) &&
 823f2a4:	e0bff717 	ldw	r2,-36(fp)
 823f2a8:	10001b26 	beq	r2,zero,823f318 <ip_write_internal+0x28c>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
 823f2ac:	e0bfff17 	ldw	r2,-4(fp)
 823f2b0:	10800b17 	ldw	r2,44(r2)
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
      if ((inm != NULL) &&
 823f2b4:	10000526 	beq	r2,zero,823f2cc <ip_write_internal+0x240>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
 823f2b8:	e0bfff17 	ldw	r2,-4(fp)
 823f2bc:	10800b17 	ldw	r2,44(r2)
 823f2c0:	10800143 	ldbu	r2,5(r2)
 823f2c4:	10803fcc 	andi	r2,r2,255
 823f2c8:	10001326 	beq	r2,zero,823f318 <ip_write_internal+0x28c>
      {
         p->type = IPTP;
 823f2cc:	e0bfff17 	ldw	r2,-4(fp)
 823f2d0:	00c00204 	movi	r3,8
 823f2d4:	10c0080d 	sth	r3,32(r2)
         pkt2 = ip_copypkt(p);
 823f2d8:	e13fff17 	ldw	r4,-4(fp)
 823f2dc:	8240d240 	call	8240d24 <ip_copypkt>
 823f2e0:	e0bff815 	stw	r2,-32(fp)
         if (pkt2)
 823f2e4:	e0bff817 	ldw	r2,-32(fp)
 823f2e8:	10000b26 	beq	r2,zero,823f318 <ip_write_internal+0x28c>
         {
            LOCK_NET_RESOURCE(RXQ_RESID);
 823f2ec:	01000044 	movi	r4,1
 823f2f0:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
            putq(&rcvdq, (q_elt)pkt2);
 823f2f4:	e17ff817 	ldw	r5,-32(fp)
 823f2f8:	010209b4 	movhi	r4,2086
 823f2fc:	21375f04 	addi	r4,r4,-8836
 823f300:	822cdfc0 	call	822cdfc <putq>
            UNLOCK_NET_RESOURCE(RXQ_RESID);
 823f304:	01000044 	movi	r4,1
 823f308:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
            SignalPktDemux();
 823f30c:	d0a0ab17 	ldw	r2,-32084(gp)
 823f310:	1009883a 	mov	r4,r2
 823f314:	821a3b00 	call	821a3b0 <OSSemPost>
       * Also, multicasts addressed to the loopback interface
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
 823f318:	e0bfff17 	ldw	r2,-4(fp)
 823f31c:	10800317 	ldw	r2,12(r2)
 823f320:	e0bff915 	stw	r2,-28(fp)
      if ((pip->ip_time == 0) || 
 823f324:	e0bff917 	ldw	r2,-28(fp)
 823f328:	10800203 	ldbu	r2,8(r2)
 823f32c:	10803fcc 	andi	r2,r2,255
 823f330:	10000b26 	beq	r2,zero,823f360 <ip_write_internal+0x2d4>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
 823f334:	e0bfff17 	ldw	r2,-4(fp)
 823f338:	10800717 	ldw	r2,28(r2)
 823f33c:	10803fcc 	andi	r2,r2,255
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
      if ((pip->ip_time == 0) || 
 823f340:	10801fe0 	cmpeqi	r2,r2,127
 823f344:	1000061e 	bne	r2,zero,823f360 <ip_write_internal+0x2d4>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
          (p->fhost == p->net->n_ipaddr))
 823f348:	e0bfff17 	ldw	r2,-4(fp)
 823f34c:	10c00717 	ldw	r3,28(r2)
 823f350:	e0bfff17 	ldw	r2,-4(fp)
 823f354:	10800617 	ldw	r2,24(r2)
 823f358:	10800a17 	ldw	r2,40(r2)
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
      if ((pip->ip_time == 0) || 
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
 823f35c:	1880081e 	bne	r3,r2,823f380 <ip_write_internal+0x2f4>
          (p->fhost == p->net->n_ipaddr))
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f360:	01000084 	movi	r4,2
 823f364:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free(p);
 823f368:	e13fff17 	ldw	r4,-4(fp)
 823f36c:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f370:	01000084 	movi	r4,2
 823f374:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return(SUCCESS);
 823f378:	0005883a 	mov	r2,zero
 823f37c:	00010706 	br	823f79c <ip_write_internal+0x710>
      }

      firsthop = p->fhost;
 823f380:	e0bfff17 	ldw	r2,-4(fp)
 823f384:	10800717 	ldw	r2,28(r2)
 823f388:	e0bffe15 	stw	r2,-8(fp)

      goto sendit;
 823f38c:	00004006 	br	823f490 <ip_write_internal+0x404>
   }

#endif /* IP_MULTICAST */

   /* if this is a broadcast packet, use the caller-selected network */
   if (p->fhost == 0xFFFFFFFF)
 823f390:	e0bfff17 	ldw	r2,-4(fp)
 823f394:	10800717 	ldw	r2,28(r2)
 823f398:	10bfffd8 	cmpnei	r2,r2,-1
 823f39c:	1000041e 	bne	r2,zero,823f3b0 <ip_write_internal+0x324>
   {
      firsthop = p->fhost;
 823f3a0:	e0bfff17 	ldw	r2,-4(fp)
 823f3a4:	10800717 	ldw	r2,28(r2)
 823f3a8:	e0bffe15 	stw	r2,-8(fp)
 823f3ac:	00003806 	br	823f490 <ip_write_internal+0x404>
   }
   else
   {
      p->net = iproute(p->fhost, &firsthop);
 823f3b0:	e0bfff17 	ldw	r2,-4(fp)
 823f3b4:	10800717 	ldw	r2,28(r2)
 823f3b8:	e0fffe04 	addi	r3,fp,-8
 823f3bc:	180b883a 	mov	r5,r3
 823f3c0:	1009883a 	mov	r4,r2
 823f3c4:	8240b4c0 	call	8240b4c <iproute>
 823f3c8:	1007883a 	mov	r3,r2
 823f3cc:	e0bfff17 	ldw	r2,-4(fp)
 823f3d0:	10c00615 	stw	r3,24(r2)
      if (p->net == NULL)
 823f3d4:	e0bfff17 	ldw	r2,-4(fp)
 823f3d8:	10800617 	ldw	r2,24(r2)
 823f3dc:	10002c1e 	bne	r2,zero,823f490 <ip_write_internal+0x404>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 823f3e0:	d0a08317 	ldw	r2,-32244(gp)
 823f3e4:	1080840c 	andi	r2,r2,528
 823f3e8:	10001a26 	beq	r2,zero,823f454 <ip_write_internal+0x3c8>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f3ec:	e0bfff17 	ldw	r2,-4(fp)
 823f3f0:	11400417 	ldw	r5,16(r2)
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f3f4:	e0bfff17 	ldw	r2,-4(fp)
 823f3f8:	10800717 	ldw	r2,28(r2)
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f3fc:	11803fcc 	andi	r6,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f400:	e0bfff17 	ldw	r2,-4(fp)
 823f404:	10800717 	ldw	r2,28(r2)
 823f408:	1004d23a 	srli	r2,r2,8
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f40c:	10803fcc 	andi	r2,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f410:	e0ffff17 	ldw	r3,-4(fp)
 823f414:	18c00717 	ldw	r3,28(r3)
 823f418:	1806d43a 	srli	r3,r3,16
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f41c:	18c03fcc 	andi	r3,r3,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 823f420:	e13fff17 	ldw	r4,-4(fp)
 823f424:	21000717 	ldw	r4,28(r4)
 823f428:	2008d63a 	srli	r4,r4,24
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 823f42c:	d9000215 	stw	r4,8(sp)
 823f430:	d8c00115 	stw	r3,4(sp)
 823f434:	d8800015 	stw	r2,0(sp)
 823f438:	300f883a 	mov	r7,r6
 823f43c:	280d883a 	mov	r6,r5
 823f440:	e17fff17 	ldw	r5,-4(fp)
 823f444:	01020974 	movhi	r4,2085
 823f448:	21047d04 	addi	r4,r4,4596
 823f44c:	820331c0 	call	820331c <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 823f450:	822d4140 	call	822d414 <dtrap>
         }
#endif   /* NPDEBUG */
         ip_mib.ipOutNoRoutes++;
 823f454:	008209b4 	movhi	r2,2086
 823f458:	10ba6a04 	addi	r2,r2,-5720
 823f45c:	10800b17 	ldw	r2,44(r2)
 823f460:	10c00044 	addi	r3,r2,1
 823f464:	008209b4 	movhi	r2,2086
 823f468:	10ba6a04 	addi	r2,r2,-5720
 823f46c:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f470:	01000084 	movi	r4,2
 823f474:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free(p);
 823f478:	e13fff17 	ldw	r4,-4(fp)
 823f47c:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f480:	01000084 	movi	r4,2
 823f484:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 823f488:	00bff7c4 	movi	r2,-33
 823f48c:	0000c306 	br	823f79c <ip_write_internal+0x710>
#ifdef   IP_MULTICAST
sendit:  /* label used for multicast packets to skip routing logic */
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
 823f490:	d0a08317 	ldw	r2,-32244(gp)
 823f494:	1080800c 	andi	r2,r2,512
 823f498:	10002926 	beq	r2,zero,823f540 <ip_write_internal+0x4b4>
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f49c:	e0bfff17 	ldw	r2,-4(fp)
 823f4a0:	11000417 	ldw	r4,16(r2)
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f4a4:	e0bfff17 	ldw	r2,-4(fp)
 823f4a8:	10800717 	ldw	r2,28(r2)
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f4ac:	11403fcc 	andi	r5,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f4b0:	e0bfff17 	ldw	r2,-4(fp)
 823f4b4:	10800717 	ldw	r2,28(r2)
 823f4b8:	1004d23a 	srli	r2,r2,8
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f4bc:	11803fcc 	andi	r6,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f4c0:	e0bfff17 	ldw	r2,-4(fp)
 823f4c4:	10800717 	ldw	r2,28(r2)
 823f4c8:	1004d43a 	srli	r2,r2,16
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f4cc:	10803fcc 	andi	r2,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 823f4d0:	e0ffff17 	ldw	r3,-4(fp)
 823f4d4:	18c00717 	ldw	r3,28(r3)
 823f4d8:	1806d63a 	srli	r3,r3,24
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 823f4dc:	d8c00115 	stw	r3,4(sp)
 823f4e0:	d8800015 	stw	r2,0(sp)
 823f4e4:	300f883a 	mov	r7,r6
 823f4e8:	280d883a 	mov	r6,r5
 823f4ec:	200b883a 	mov	r5,r4
 823f4f0:	01020974 	movhi	r4,2085
 823f4f4:	21048d04 	addi	r4,r4,4660
 823f4f8:	820331c0 	call	820331c <printf>
       p->nb_plen, PUSH_IPADDR(p->fhost));
      dprintf(" route %u.%u.%u.%u\n", PUSH_IPADDR(firsthop));
 823f4fc:	e0bffe17 	ldw	r2,-8(fp)
 823f500:	10c03fcc 	andi	r3,r2,255
 823f504:	e0bffe17 	ldw	r2,-8(fp)
 823f508:	1004d23a 	srli	r2,r2,8
 823f50c:	11003fcc 	andi	r4,r2,255
 823f510:	e0bffe17 	ldw	r2,-8(fp)
 823f514:	1004d43a 	srli	r2,r2,16
 823f518:	11403fcc 	andi	r5,r2,255
 823f51c:	e0bffe17 	ldw	r2,-8(fp)
 823f520:	1004d63a 	srli	r2,r2,24
 823f524:	d8800015 	stw	r2,0(sp)
 823f528:	280f883a 	mov	r7,r5
 823f52c:	200d883a 	mov	r6,r4
 823f530:	180b883a 	mov	r5,r3
 823f534:	01020974 	movhi	r4,2085
 823f538:	21049604 	addi	r4,r4,4696
 823f53c:	820331c0 	call	820331c <printf>
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 823f540:	e0bfff17 	ldw	r2,-4(fp)
 823f544:	10800617 	ldw	r2,24(r2)
 823f548:	10c00a17 	ldw	r3,40(r2)
 823f54c:	e0bfff17 	ldw	r2,-4(fp)
 823f550:	10800717 	ldw	r2,28(r2)
 823f554:	1880271e 	bne	r3,r2,823f5f4 <ip_write_internal+0x568>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
 823f558:	e0bfff17 	ldw	r2,-4(fp)
 823f55c:	10800717 	ldw	r2,28(r2)
 823f560:	10803fcc 	andi	r2,r2,255
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 823f564:	10801fe0 	cmpeqi	r2,r2,127
 823f568:	1000221e 	bne	r2,zero,823f5f4 <ip_write_internal+0x568>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
   {
      if (!(p->net->n_flags & NF_NBPROT))
 823f56c:	e0bfff17 	ldw	r2,-4(fp)
 823f570:	10800617 	ldw	r2,24(r2)
 823f574:	10802a17 	ldw	r2,168(r2)
 823f578:	1080020c 	andi	r2,r2,8
 823f57c:	1000091e 	bne	r2,zero,823f5a4 <ip_write_internal+0x518>
          * IP or ARP protocol header) and nb_type to the protocol
          * type, and set the NF_NBPROT flag in its interfaces'
          * n_flags fields.
          */
#ifdef NPDEBUG
         dtrap();
 823f580:	822d4140 	call	822d414 <dtrap>
#endif
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f584:	01000084 	movi	r4,2
 823f588:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free(p);
 823f58c:	e13fff17 	ldw	r4,-4(fp)
 823f590:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f594:	01000084 	movi	r4,2
 823f598:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_LOGIC;
 823f59c:	00bffd44 	movi	r2,-11
 823f5a0:	00007e06 	br	823f79c <ip_write_internal+0x710>
      }
      p->type = IPTP;
 823f5a4:	e0bfff17 	ldw	r2,-4(fp)
 823f5a8:	00c00204 	movi	r3,8
 823f5ac:	10c0080d 	sth	r3,32(r2)
      UNLOCK_NET_RESOURCE(NET_RESID);
 823f5b0:	0009883a 	mov	r4,zero
 823f5b4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(RXQ_RESID);
 823f5b8:	01000044 	movi	r4,1
 823f5bc:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      putq(&rcvdq, (q_elt)p);
 823f5c0:	e17fff17 	ldw	r5,-4(fp)
 823f5c4:	010209b4 	movhi	r4,2086
 823f5c8:	21375f04 	addi	r4,r4,-8836
 823f5cc:	822cdfc0 	call	822cdfc <putq>
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 823f5d0:	01000044 	movi	r4,1
 823f5d4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(NET_RESID);
 823f5d8:	0009883a 	mov	r4,zero
 823f5dc:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);

      SignalPktDemux();
 823f5e0:	d0a0ab17 	ldw	r2,-32084(gp)
 823f5e4:	1009883a 	mov	r4,r2
 823f5e8:	821a3b00 	call	821a3b0 <OSSemPost>

      return SUCCESS;
 823f5ec:	0005883a 	mov	r2,zero
 823f5f0:	00006a06 	br	823f79c <ip_write_internal+0x710>
   }

   /* determine if the buffer that needs to be transmitted is interrupt-safe */
   intrsafe_buf = ((p->flags & PKF_INTRUNSAFE) ? 0 : 1);
 823f5f4:	e0bfff17 	ldw	r2,-4(fp)
 823f5f8:	10800a17 	ldw	r2,40(r2)
 823f5fc:	1080040c 	andi	r2,r2,16
 823f600:	1005003a 	cmpeq	r2,r2,zero
 823f604:	e0bffa05 	stb	r2,-24(fp)
   /* obtain the length of the largest interrupt-safe buffer that can be 
    * allocated via pk_alloc () */
   maxbuflen = pk_get_max_intrsafe_buf_len ();
 823f608:	822cc680 	call	822cc68 <pk_get_max_intrsafe_buf_len>
 823f60c:	e0bffb15 	stw	r2,-20(fp)
    * the original buffer is interrupt-safe, we just need to consider the
    * MTU of the egress interface.  If the original buffer is interrupt-
    * unsafe, we compute the MIN of the largest interrupt-safe buffer that
    * we can use and the MTU of the egress interface (since we must satisfy
    * both constraints) */
   if (!intrsafe_buf)
 823f610:	e0bffa03 	ldbu	r2,-24(fp)
 823f614:	1000081e 	bne	r2,zero,823f638 <ip_write_internal+0x5ac>
       limit = MIN(maxbuflen,p->net->n_mtu);
 823f618:	e0bfff17 	ldw	r2,-4(fp)
 823f61c:	10800617 	ldw	r2,24(r2)
 823f620:	10800917 	ldw	r2,36(r2)
 823f624:	e0fffb17 	ldw	r3,-20(fp)
 823f628:	1880012e 	bgeu	r3,r2,823f630 <ip_write_internal+0x5a4>
 823f62c:	1805883a 	mov	r2,r3
 823f630:	e0bff615 	stw	r2,-40(fp)
 823f634:	00000406 	br	823f648 <ip_write_internal+0x5bc>
   else
       limit = p->net->n_mtu;
 823f638:	e0bfff17 	ldw	r2,-4(fp)
 823f63c:	10800617 	ldw	r2,24(r2)
 823f640:	10800917 	ldw	r2,36(r2)
 823f644:	e0bff615 	stw	r2,-40(fp)

   if ((p->nb_plen + p->net->n_lnh) > limit)
 823f648:	e0bfff17 	ldw	r2,-4(fp)
 823f64c:	10800417 	ldw	r2,16(r2)
 823f650:	e0ffff17 	ldw	r3,-4(fp)
 823f654:	18c00617 	ldw	r3,24(r3)
 823f658:	18c00817 	ldw	r3,32(r3)
 823f65c:	10c5883a 	add	r2,r2,r3
 823f660:	e0fff617 	ldw	r3,-40(fp)
 823f664:	1880072e 	bgeu	r3,r2,823f684 <ip_write_internal+0x5f8>
   {
#ifdef IP_FRAGMENTS
      int err;
      err = ip_fragment(p, firsthop);
 823f668:	e0bffe17 	ldw	r2,-8(fp)
 823f66c:	100b883a 	mov	r5,r2
 823f670:	e13fff17 	ldw	r4,-4(fp)
 823f674:	824023c0 	call	824023c <ip_fragment>
 823f678:	e0bffc15 	stw	r2,-16(fp)
      IN_PROFILER(PF_IP, PF_EXIT);
      return(err);
 823f67c:	e0bffc17 	ldw	r2,-16(fp)
 823f680:	00004606 	br	823f79c <ip_write_internal+0x710>
   }
   else
   {
      /* fragmentation is not required; check to see if we need to copy out of
       * an interrupt-unsafe buffer */ 
      if (!intrsafe_buf)
 823f684:	e0bffa03 	ldbu	r2,-24(fp)
 823f688:	1000401e 	bne	r2,zero,823f78c <ip_write_internal+0x700>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 823f68c:	01000084 	movi	r4,2
 823f690:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         newpkt = pk_alloc(p->nb_plen + p->net->n_lnh);
 823f694:	e0bfff17 	ldw	r2,-4(fp)
 823f698:	10800417 	ldw	r2,16(r2)
 823f69c:	e0ffff17 	ldw	r3,-4(fp)
 823f6a0:	18c00617 	ldw	r3,24(r3)
 823f6a4:	18c00817 	ldw	r3,32(r3)
 823f6a8:	10c5883a 	add	r2,r2,r3
 823f6ac:	1009883a 	mov	r4,r2
 823f6b0:	822c86c0 	call	822c86c <pk_alloc>
 823f6b4:	e0bffd15 	stw	r2,-12(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f6b8:	01000084 	movi	r4,2
 823f6bc:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         if (newpkt == 0)
 823f6c0:	e0bffd17 	ldw	r2,-12(fp)
 823f6c4:	1000081e 	bne	r2,zero,823f6e8 <ip_write_internal+0x65c>
         {
            /* can't allocate interrupt-safe buffer, so free the packet that 
             * we are working with */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823f6c8:	01000084 	movi	r4,2
 823f6cc:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
            pk_free(p);
 823f6d0:	e13fff17 	ldw	r4,-4(fp)
 823f6d4:	822cbbc0 	call	822cbbc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f6d8:	01000084 	movi	r4,2
 823f6dc:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NOBUFFER;
 823f6e0:	00bffac4 	movi	r2,-21
 823f6e4:	00002d06 	br	823f79c <ip_write_internal+0x710>
         }
         else
         {
            /* copy from interrupt-unsafe buffer into interrupt-safe buffer */
            newpkt->nb_prot = newpkt->nb_buff + p->net->n_lnh;
 823f6e8:	e0bffd17 	ldw	r2,-12(fp)
 823f6ec:	10800117 	ldw	r2,4(r2)
 823f6f0:	e0ffff17 	ldw	r3,-4(fp)
 823f6f4:	18c00617 	ldw	r3,24(r3)
 823f6f8:	18c00817 	ldw	r3,32(r3)
 823f6fc:	10c7883a 	add	r3,r2,r3
 823f700:	e0bffd17 	ldw	r2,-12(fp)
 823f704:	10c00315 	stw	r3,12(r2)
            MEMCPY(newpkt->nb_prot, p->nb_prot, p->nb_plen);
 823f708:	e0bffd17 	ldw	r2,-12(fp)
 823f70c:	10c00317 	ldw	r3,12(r2)
 823f710:	e0bfff17 	ldw	r2,-4(fp)
 823f714:	11000317 	ldw	r4,12(r2)
 823f718:	e0bfff17 	ldw	r2,-4(fp)
 823f71c:	10800417 	ldw	r2,16(r2)
 823f720:	100d883a 	mov	r6,r2
 823f724:	200b883a 	mov	r5,r4
 823f728:	1809883a 	mov	r4,r3
 823f72c:	8202e8c0 	call	8202e8c <memcpy>
            /* setup various fields in the newly allocated PACKET structure */
            newpkt->nb_plen = p->nb_plen;
 823f730:	e0bfff17 	ldw	r2,-4(fp)
 823f734:	10c00417 	ldw	r3,16(r2)
 823f738:	e0bffd17 	ldw	r2,-12(fp)
 823f73c:	10c00415 	stw	r3,16(r2)
            newpkt->net = p->net;
 823f740:	e0bfff17 	ldw	r2,-4(fp)
 823f744:	10c00617 	ldw	r3,24(r2)
 823f748:	e0bffd17 	ldw	r2,-12(fp)
 823f74c:	10c00615 	stw	r3,24(r2)
            newpkt->fhost = p->fhost;
 823f750:	e0bfff17 	ldw	r2,-4(fp)
 823f754:	10c00717 	ldw	r3,28(r2)
 823f758:	e0bffd17 	ldw	r2,-12(fp)
 823f75c:	10c00715 	stw	r3,28(r2)
            /* free the original packet since it is no longer needed */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 823f760:	01000084 	movi	r4,2
 823f764:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
            pk_free(p);
 823f768:	e13fff17 	ldw	r4,-4(fp)
 823f76c:	822cbbc0 	call	822cbbc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 823f770:	01000084 	movi	r4,2
 823f774:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            /* send packet to MAC layer. This will try to resolve MAC layer addressing 
             * and send packet. ip2mac() can return SUCCESS, PENDING, or error codes. 
             */
            return(ip2mac(newpkt, firsthop));
 823f778:	e0bffe17 	ldw	r2,-8(fp)
 823f77c:	100b883a 	mov	r5,r2
 823f780:	e13ffd17 	ldw	r4,-12(fp)
 823f784:	82266340 	call	8226634 <ip2mac>
 823f788:	00000406 	br	823f79c <ip_write_internal+0x710>
      else
      {
         /* since the packet is in an interrupt-safe buffer, it can be passed to 
          * ip2mac () without any additional work. */
         IN_PROFILER(PF_IP, PF_EXIT);
         return(ip2mac(p, firsthop));
 823f78c:	e0bffe17 	ldw	r2,-8(fp)
 823f790:	100b883a 	mov	r5,r2
 823f794:	e13fff17 	ldw	r4,-4(fp)
 823f798:	82266340 	call	8226634 <ip2mac>
      }
   }
}
 823f79c:	e037883a 	mov	sp,fp
 823f7a0:	dfc00117 	ldw	ra,4(sp)
 823f7a4:	df000017 	ldw	fp,0(sp)
 823f7a8:	dec00204 	addi	sp,sp,8
 823f7ac:	f800283a 	ret

0823f7b0 <ip_write>:

int
ip_write(
   u_char   prot,
   PACKET   p)
{
 823f7b0:	defff904 	addi	sp,sp,-28
 823f7b4:	dfc00615 	stw	ra,24(sp)
 823f7b8:	df000515 	stw	fp,20(sp)
 823f7bc:	df000504 	addi	fp,sp,20
 823f7c0:	2005883a 	mov	r2,r4
 823f7c4:	e17fff15 	stw	r5,-4(fp)
 823f7c8:	e0bffe05 	stb	r2,-8(fp)
   u_char ttl;
   struct ip_socopts *sopts;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 823f7cc:	008209b4 	movhi	r2,2086
 823f7d0:	10ba6a04 	addi	r2,r2,-5720
 823f7d4:	10800917 	ldw	r2,36(r2)
 823f7d8:	10c00044 	addi	r3,r2,1
 823f7dc:	008209b4 	movhi	r2,2086
 823f7e0:	10ba6a04 	addi	r2,r2,-5720
 823f7e4:	10c00915 	stw	r3,36(r2)

   /* make room for IP header, and form a pointer to it (pip) */
   p->nb_prot -= sizeof(struct ip);
 823f7e8:	e0bfff17 	ldw	r2,-4(fp)
 823f7ec:	10800317 	ldw	r2,12(r2)
 823f7f0:	10fffb04 	addi	r3,r2,-20
 823f7f4:	e0bfff17 	ldw	r2,-4(fp)
 823f7f8:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 823f7fc:	e0bfff17 	ldw	r2,-4(fp)
 823f800:	10800417 	ldw	r2,16(r2)
 823f804:	10c00504 	addi	r3,r2,20
 823f808:	e0bfff17 	ldw	r2,-4(fp)
 823f80c:	10c00415 	stw	r3,16(r2)
   pip = (struct ip*)(p->nb_prot);
 823f810:	e0bfff17 	ldw	r2,-4(fp)
 823f814:	10800317 	ldw	r2,12(r2)
 823f818:	e0bffc15 	stw	r2,-16(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 823f81c:	e0bffc17 	ldw	r2,-16(fp)
 823f820:	00c01144 	movi	r3,69
 823f824:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0;        /* clear fragmentation info field */
 823f828:	e0bffc17 	ldw	r2,-16(fp)
 823f82c:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 823f830:	d0a05017 	ldw	r2,-32448(gp)
 823f834:	10bfffcc 	andi	r2,r2,65535
 823f838:	1005d23a 	srai	r2,r2,8
 823f83c:	10803fcc 	andi	r2,r2,255
 823f840:	1007883a 	mov	r3,r2
 823f844:	d0a05017 	ldw	r2,-32448(gp)
 823f848:	10bfffcc 	andi	r2,r2,65535
 823f84c:	1004923a 	slli	r2,r2,8
 823f850:	1884b03a 	or	r2,r3,r2
 823f854:	1007883a 	mov	r3,r2
 823f858:	e0bffc17 	ldw	r2,-16(fp)
 823f85c:	10c0010d 	sth	r3,4(r2)
   uid++;
 823f860:	d0a05017 	ldw	r2,-32448(gp)
 823f864:	10800044 	addi	r2,r2,1
 823f868:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 823f86c:	e0bfff17 	ldw	r2,-4(fp)
 823f870:	10800417 	ldw	r2,16(r2)
 823f874:	10bfffcc 	andi	r2,r2,65535
 823f878:	1005d23a 	srai	r2,r2,8
 823f87c:	10803fcc 	andi	r2,r2,255
 823f880:	1007883a 	mov	r3,r2
 823f884:	e0bfff17 	ldw	r2,-4(fp)
 823f888:	10800417 	ldw	r2,16(r2)
 823f88c:	10bfffcc 	andi	r2,r2,65535
 823f890:	1004923a 	slli	r2,r2,8
 823f894:	1884b03a 	or	r2,r3,r2
 823f898:	1007883a 	mov	r3,r2
 823f89c:	e0bffc17 	ldw	r2,-16(fp)
 823f8a0:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 823f8a4:	e0bffc17 	ldw	r2,-16(fp)
 823f8a8:	e0fffe03 	ldbu	r3,-8(fp)
 823f8ac:	10c00245 	stb	r3,9(r2)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 823f8b0:	e0bffc17 	ldw	r2,-16(fp)
 823f8b4:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 823f8b8:	00801004 	movi	r2,64
 823f8bc:	e0bffb05 	stb	r2,-20(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 823f8c0:	e0bfff17 	ldw	r2,-4(fp)
 823f8c4:	10800717 	ldw	r2,28(r2)
 823f8c8:	1006d63a 	srli	r3,r2,24
 823f8cc:	e0bfff17 	ldw	r2,-4(fp)
 823f8d0:	10800717 	ldw	r2,28(r2)
 823f8d4:	1004d23a 	srli	r2,r2,8
 823f8d8:	10bfc00c 	andi	r2,r2,65280
 823f8dc:	1886b03a 	or	r3,r3,r2
 823f8e0:	e0bfff17 	ldw	r2,-4(fp)
 823f8e4:	10800717 	ldw	r2,28(r2)
 823f8e8:	10bfc00c 	andi	r2,r2,65280
 823f8ec:	1004923a 	slli	r2,r2,8
 823f8f0:	1886b03a 	or	r3,r3,r2
 823f8f4:	e0bfff17 	ldw	r2,-4(fp)
 823f8f8:	10800717 	ldw	r2,28(r2)
 823f8fc:	1004963a 	slli	r2,r2,24
 823f900:	1884b03a 	or	r2,r3,r2
 823f904:	10fc002c 	andhi	r3,r2,61440
 823f908:	00b80034 	movhi	r2,57344
 823f90c:	1880071e 	bne	r3,r2,823f92c <ip_write+0x17c>
 823f910:	e0bfff17 	ldw	r2,-4(fp)
 823f914:	10800b17 	ldw	r2,44(r2)
 823f918:	10000426 	beq	r2,zero,823f92c <ip_write+0x17c>
      ttl = p->imo->imo_multicast_ttl;
 823f91c:	e0bfff17 	ldw	r2,-4(fp)
 823f920:	10800b17 	ldw	r2,44(r2)
 823f924:	10800103 	ldbu	r2,4(r2)
 823f928:	e0bffb05 	stb	r2,-20(fp)
#endif /* IP_MULTICAST */

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 823f92c:	e0bfff17 	ldw	r2,-4(fp)
 823f930:	10800c17 	ldw	r2,48(r2)
 823f934:	e0bffd15 	stw	r2,-12(fp)
 823f938:	e0bffd17 	ldw	r2,-12(fp)
 823f93c:	10001126 	beq	r2,zero,823f984 <ip_write+0x1d4>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 823f940:	e0bffd17 	ldw	r2,-12(fp)
 823f944:	10800043 	ldbu	r2,1(r2)
 823f948:	10803fcc 	andi	r2,r2,255
 823f94c:	10000526 	beq	r2,zero,823f964 <ip_write+0x1b4>
         pip->ip_time = sopts->ip_ttl;
 823f950:	e0bffd17 	ldw	r2,-12(fp)
 823f954:	10c00043 	ldbu	r3,1(r2)
 823f958:	e0bffc17 	ldw	r2,-16(fp)
 823f95c:	10c00205 	stb	r3,8(r2)
 823f960:	00000306 	br	823f970 <ip_write+0x1c0>
	  else
         pip->ip_time = ttl;
 823f964:	e0bffc17 	ldw	r2,-16(fp)
 823f968:	e0fffb03 	ldbu	r3,-20(fp)
 823f96c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 823f970:	e0bffd17 	ldw	r2,-12(fp)
 823f974:	10c00003 	ldbu	r3,0(r2)
 823f978:	e0bffc17 	ldw	r2,-16(fp)
 823f97c:	10c00045 	stb	r3,1(r2)
 823f980:	00000506 	br	823f998 <ip_write+0x1e8>
   }
   else
   {
	  /* nope */
      pip->ip_time = ttl;
 823f984:	e0bffc17 	ldw	r2,-16(fp)
 823f988:	e0fffb03 	ldbu	r3,-20(fp)
 823f98c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 823f990:	e0bffc17 	ldw	r2,-16(fp)
 823f994:	10000045 	stb	zero,1(r2)
   }
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum(pip, 10);
 823f998:	01400284 	movi	r5,10
 823f99c:	e13ffc17 	ldw	r4,-16(fp)
 823f9a0:	82286f00 	call	82286f0 <cksum>
 823f9a4:	0084303a 	nor	r2,zero,r2
 823f9a8:	1007883a 	mov	r3,r2
 823f9ac:	e0bffc17 	ldw	r2,-16(fp)
 823f9b0:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 823f9b4:	e13fff17 	ldw	r4,-4(fp)
 823f9b8:	823f08c0 	call	823f08c <ip_write_internal>
}
 823f9bc:	e037883a 	mov	sp,fp
 823f9c0:	dfc00117 	ldw	ra,4(sp)
 823f9c4:	df000017 	ldw	fp,0(sp)
 823f9c8:	dec00204 	addi	sp,sp,8
 823f9cc:	f800283a 	ret

0823f9d0 <ip_write2>:
 * OUTPUT: This function returns the return code from 
 *         ip_write_internal ().
 */

int ip_write2 (u_char prot, PACKET p, u_char * optp)
{
 823f9d0:	defff604 	addi	sp,sp,-40
 823f9d4:	dfc00915 	stw	ra,36(sp)
 823f9d8:	df000815 	stw	fp,32(sp)
 823f9dc:	df000804 	addi	fp,sp,32
 823f9e0:	2005883a 	mov	r2,r4
 823f9e4:	e17ffe15 	stw	r5,-8(fp)
 823f9e8:	e1bfff15 	stw	r6,-4(fp)
 823f9ec:	e0bffd05 	stb	r2,-12(fp)
   struct ip * pip;
   u_char ttl;
   struct ip_socopts * sopts;
   u_char iphlen = sizeof (struct ip);
 823f9f0:	00800504 	movi	r2,20
 823f9f4:	e0bff845 	stb	r2,-31(fp)
   u_char iphlen_pad;
   u_char i;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 823f9f8:	008209b4 	movhi	r2,2086
 823f9fc:	10ba6a04 	addi	r2,r2,-5720
 823fa00:	10800917 	ldw	r2,36(r2)
 823fa04:	10c00044 	addi	r3,r2,1
 823fa08:	008209b4 	movhi	r2,2086
 823fa0c:	10ba6a04 	addi	r2,r2,-5720
 823fa10:	10c00915 	stw	r3,36(r2)

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 823fa14:	e0bfff17 	ldw	r2,-4(fp)
 823fa18:	e0bff915 	stw	r2,-28(fp)
 823fa1c:	00000d06 	br	823fa54 <ip_write2+0x84>
   {
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
 823fa20:	e0bff917 	ldw	r2,-28(fp)
 823fa24:	10800003 	ldbu	r2,0(r2)
 823fa28:	10803fcc 	andi	r2,r2,255
 823fa2c:	10800520 	cmpeqi	r2,r2,20
 823fa30:	1000011e 	bne	r2,zero,823fa38 <ip_write2+0x68>
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
            break;
         default:
            break;
 823fa34:	00000406 	br	823fa48 <ip_write2+0x78>
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
 823fa38:	e0bff843 	ldbu	r2,-31(fp)
 823fa3c:	10800104 	addi	r2,r2,4
 823fa40:	e0bff845 	stb	r2,-31(fp)
            break;
 823fa44:	0001883a 	nop
   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 823fa48:	e0bff917 	ldw	r2,-28(fp)
 823fa4c:	10800044 	addi	r2,r2,1
 823fa50:	e0bff915 	stw	r2,-28(fp)
 823fa54:	e0bff917 	ldw	r2,-28(fp)
 823fa58:	10800003 	ldbu	r2,0(r2)
 823fa5c:	10803fcc 	andi	r2,r2,255
 823fa60:	103fef1e 	bne	r2,zero,823fa20 <ip_write2+0x50>
   }

   /* compute the amount of padding required, if any (to ensure
    * that the IP header (including options) ends on a dword
    * (four byte) boundary */
   if (iphlen & 0x3)
 823fa64:	e0bff843 	ldbu	r2,-31(fp)
 823fa68:	108000cc 	andi	r2,r2,3
 823fa6c:	10000726 	beq	r2,zero,823fa8c <ip_write2+0xbc>
      iphlen_pad = 4 - (iphlen & 0x3);
 823fa70:	e0bff843 	ldbu	r2,-31(fp)
 823fa74:	108000cc 	andi	r2,r2,3
 823fa78:	1007883a 	mov	r3,r2
 823fa7c:	00800104 	movi	r2,4
 823fa80:	10c5c83a 	sub	r2,r2,r3
 823fa84:	e0bffa05 	stb	r2,-24(fp)
 823fa88:	00000106 	br	823fa90 <ip_write2+0xc0>
   else iphlen_pad = 0; /* no header padding required */
 823fa8c:	e03ffa05 	stb	zero,-24(fp)
   /* the packet passed to ip_write2 () has its nb_prot set to
    * point to start of the protocol's (e.g., IGMP) data, and 
    * nb_plen set to the length of that data.  locate start of 
    * the IP header (account for IP options), and form a pointer 
    * to it (pip) */
   p->nb_prot -= (iphlen + iphlen_pad);
 823fa90:	e0bffe17 	ldw	r2,-8(fp)
 823fa94:	10c00317 	ldw	r3,12(r2)
 823fa98:	e13ff843 	ldbu	r4,-31(fp)
 823fa9c:	e0bffa03 	ldbu	r2,-24(fp)
 823faa0:	2085883a 	add	r2,r4,r2
 823faa4:	0085c83a 	sub	r2,zero,r2
 823faa8:	1887883a 	add	r3,r3,r2
 823faac:	e0bffe17 	ldw	r2,-8(fp)
 823fab0:	10c00315 	stw	r3,12(r2)
   /* add padding length to the total length of the IP datagram */
   p->nb_plen += (iphlen + iphlen_pad);
 823fab4:	e0bffe17 	ldw	r2,-8(fp)
 823fab8:	10800417 	ldw	r2,16(r2)
 823fabc:	e13ff843 	ldbu	r4,-31(fp)
 823fac0:	e0fffa03 	ldbu	r3,-24(fp)
 823fac4:	20c7883a 	add	r3,r4,r3
 823fac8:	10c7883a 	add	r3,r2,r3
 823facc:	e0bffe17 	ldw	r2,-8(fp)
 823fad0:	10c00415 	stw	r3,16(r2)
   pip = (struct ip *) (p->nb_prot);
 823fad4:	e0bffe17 	ldw	r2,-8(fp)
 823fad8:	10800317 	ldw	r2,12(r2)
 823fadc:	e0bffb15 	stw	r2,-20(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = ((IP_VER << 4) | ((iphlen + iphlen_pad) >> 2));
 823fae0:	e0fff843 	ldbu	r3,-31(fp)
 823fae4:	e0bffa03 	ldbu	r2,-24(fp)
 823fae8:	1885883a 	add	r2,r3,r2
 823faec:	1005d0ba 	srai	r2,r2,2
 823faf0:	10801014 	ori	r2,r2,64
 823faf4:	1007883a 	mov	r3,r2
 823faf8:	e0bffb17 	ldw	r2,-20(fp)
 823fafc:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0; /* clear fragmentation info field */
 823fb00:	e0bffb17 	ldw	r2,-20(fp)
 823fb04:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 823fb08:	d0a05017 	ldw	r2,-32448(gp)
 823fb0c:	10bfffcc 	andi	r2,r2,65535
 823fb10:	1005d23a 	srai	r2,r2,8
 823fb14:	10803fcc 	andi	r2,r2,255
 823fb18:	1007883a 	mov	r3,r2
 823fb1c:	d0a05017 	ldw	r2,-32448(gp)
 823fb20:	10bfffcc 	andi	r2,r2,65535
 823fb24:	1004923a 	slli	r2,r2,8
 823fb28:	1884b03a 	or	r2,r3,r2
 823fb2c:	1007883a 	mov	r3,r2
 823fb30:	e0bffb17 	ldw	r2,-20(fp)
 823fb34:	10c0010d 	sth	r3,4(r2)
   uid++;
 823fb38:	d0a05017 	ldw	r2,-32448(gp)
 823fb3c:	10800044 	addi	r2,r2,1
 823fb40:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 823fb44:	e0bffe17 	ldw	r2,-8(fp)
 823fb48:	10800417 	ldw	r2,16(r2)
 823fb4c:	10bfffcc 	andi	r2,r2,65535
 823fb50:	1005d23a 	srai	r2,r2,8
 823fb54:	10803fcc 	andi	r2,r2,255
 823fb58:	1007883a 	mov	r3,r2
 823fb5c:	e0bffe17 	ldw	r2,-8(fp)
 823fb60:	10800417 	ldw	r2,16(r2)
 823fb64:	10bfffcc 	andi	r2,r2,65535
 823fb68:	1004923a 	slli	r2,r2,8
 823fb6c:	1884b03a 	or	r2,r3,r2
 823fb70:	1007883a 	mov	r3,r2
 823fb74:	e0bffb17 	ldw	r2,-20(fp)
 823fb78:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 823fb7c:	e0bffb17 	ldw	r2,-20(fp)
 823fb80:	e0fffd03 	ldbu	r3,-12(fp)
 823fb84:	10c00245 	stb	r3,9(r2)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 823fb88:	e0bffb17 	ldw	r2,-20(fp)
 823fb8c:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 823fb90:	00801004 	movi	r2,64
 823fb94:	e0bff805 	stb	r2,-32(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 823fb98:	e0bffe17 	ldw	r2,-8(fp)
 823fb9c:	10800717 	ldw	r2,28(r2)
 823fba0:	1006d63a 	srli	r3,r2,24
 823fba4:	e0bffe17 	ldw	r2,-8(fp)
 823fba8:	10800717 	ldw	r2,28(r2)
 823fbac:	1004d23a 	srli	r2,r2,8
 823fbb0:	10bfc00c 	andi	r2,r2,65280
 823fbb4:	1886b03a 	or	r3,r3,r2
 823fbb8:	e0bffe17 	ldw	r2,-8(fp)
 823fbbc:	10800717 	ldw	r2,28(r2)
 823fbc0:	10bfc00c 	andi	r2,r2,65280
 823fbc4:	1004923a 	slli	r2,r2,8
 823fbc8:	1886b03a 	or	r3,r3,r2
 823fbcc:	e0bffe17 	ldw	r2,-8(fp)
 823fbd0:	10800717 	ldw	r2,28(r2)
 823fbd4:	1004963a 	slli	r2,r2,24
 823fbd8:	1884b03a 	or	r2,r3,r2
 823fbdc:	10fc002c 	andhi	r3,r2,61440
 823fbe0:	00b80034 	movhi	r2,57344
 823fbe4:	1880071e 	bne	r3,r2,823fc04 <ip_write2+0x234>
 823fbe8:	e0bffe17 	ldw	r2,-8(fp)
 823fbec:	10800b17 	ldw	r2,44(r2)
 823fbf0:	10000426 	beq	r2,zero,823fc04 <ip_write2+0x234>
      ttl = p->imo->imo_multicast_ttl;
 823fbf4:	e0bffe17 	ldw	r2,-8(fp)
 823fbf8:	10800b17 	ldw	r2,44(r2)
 823fbfc:	10800103 	ldbu	r2,4(r2)
 823fc00:	e0bff805 	stb	r2,-32(fp)
#endif /* IP_MULTICAST */

   /* have TOS or TTL been set (via socket options)? */
   if ((sopts = p->soxopts))
 823fc04:	e0bffe17 	ldw	r2,-8(fp)
 823fc08:	10800c17 	ldw	r2,48(r2)
 823fc0c:	e0bffc15 	stw	r2,-16(fp)
 823fc10:	e0bffc17 	ldw	r2,-16(fp)
 823fc14:	10001126 	beq	r2,zero,823fc5c <ip_write2+0x28c>
   {
      if (sopts->ip_ttl)
 823fc18:	e0bffc17 	ldw	r2,-16(fp)
 823fc1c:	10800043 	ldbu	r2,1(r2)
 823fc20:	10803fcc 	andi	r2,r2,255
 823fc24:	10000526 	beq	r2,zero,823fc3c <ip_write2+0x26c>
         pip->ip_time = sopts->ip_ttl;
 823fc28:	e0bffc17 	ldw	r2,-16(fp)
 823fc2c:	10c00043 	ldbu	r3,1(r2)
 823fc30:	e0bffb17 	ldw	r2,-20(fp)
 823fc34:	10c00205 	stb	r3,8(r2)
 823fc38:	00000306 	br	823fc48 <ip_write2+0x278>
      else
         pip->ip_time = ttl;
 823fc3c:	e0bffb17 	ldw	r2,-20(fp)
 823fc40:	e0fff803 	ldbu	r3,-32(fp)
 823fc44:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 823fc48:	e0bffc17 	ldw	r2,-16(fp)
 823fc4c:	10c00003 	ldbu	r3,0(r2)
 823fc50:	e0bffb17 	ldw	r2,-20(fp)
 823fc54:	10c00045 	stb	r3,1(r2)
 823fc58:	00000506 	br	823fc70 <ip_write2+0x2a0>
   }
   else
   {
      pip->ip_time = ttl;
 823fc5c:	e0bffb17 	ldw	r2,-20(fp)
 823fc60:	e0fff803 	ldbu	r3,-32(fp)
 823fc64:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 823fc68:	e0bffb17 	ldw	r2,-20(fp)
 823fc6c:	10000045 	stb	zero,1(r2)
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 823fc70:	e0bffe17 	ldw	r2,-8(fp)
 823fc74:	10800317 	ldw	r2,12(r2)
 823fc78:	10800504 	addi	r2,r2,20
 823fc7c:	e0bff915 	stw	r2,-28(fp)
 823fc80:	00001006 	br	823fcc4 <ip_write2+0x2f4>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
 823fc84:	e0bfff17 	ldw	r2,-4(fp)
 823fc88:	10800003 	ldbu	r2,0(r2)
 823fc8c:	10803fcc 	andi	r2,r2,255
 823fc90:	10800520 	cmpeqi	r2,r2,20
 823fc94:	1000011e 	bne	r2,zero,823fc9c <ip_write2+0x2cc>
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
            break;
         default:
            break;
 823fc98:	00000706 	br	823fcb8 <ip_write2+0x2e8>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
      {
         case IP_RTR_ALERT_OPT:
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
 823fc9c:	e0bff917 	ldw	r2,-28(fp)
 823fca0:	00c12504 	movi	r3,1172
 823fca4:	10c00015 	stw	r3,0(r2)
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
 823fca8:	e0bff917 	ldw	r2,-28(fp)
 823fcac:	10800104 	addi	r2,r2,4
 823fcb0:	e0bff915 	stw	r2,-28(fp)
            break;
 823fcb4:	0001883a 	nop
      pip->ip_time = ttl;
      pip->ip_tos = IP_TOS_DEFVAL;
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 823fcb8:	e0bfff17 	ldw	r2,-4(fp)
 823fcbc:	10800044 	addi	r2,r2,1
 823fcc0:	e0bfff15 	stw	r2,-4(fp)
 823fcc4:	e0bfff17 	ldw	r2,-4(fp)
 823fcc8:	10800003 	ldbu	r2,0(r2)
 823fccc:	10803fcc 	andi	r2,r2,255
 823fcd0:	103fec1e 	bne	r2,zero,823fc84 <ip_write2+0x2b4>
            break;
      }
   }

   /* add one (or more) one-byte long End of Option options (if required) */
   for (i = 0; i < iphlen_pad; ++i) *(tmpp + i) = 0;
 823fcd4:	e03ffa45 	stb	zero,-23(fp)
 823fcd8:	00000706 	br	823fcf8 <ip_write2+0x328>
 823fcdc:	e0bffa43 	ldbu	r2,-23(fp)
 823fce0:	e0fff917 	ldw	r3,-28(fp)
 823fce4:	1885883a 	add	r2,r3,r2
 823fce8:	10000005 	stb	zero,0(r2)
 823fcec:	e0bffa43 	ldbu	r2,-23(fp)
 823fcf0:	10800044 	addi	r2,r2,1
 823fcf4:	e0bffa45 	stb	r2,-23(fp)
 823fcf8:	e0fffa43 	ldbu	r3,-23(fp)
 823fcfc:	e0bffa03 	ldbu	r2,-24(fp)
 823fd00:	18bff636 	bltu	r3,r2,823fcdc <ip_write2+0x30c>
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum (pip, ((iphlen + iphlen_pad)/2));
 823fd04:	e0fff843 	ldbu	r3,-31(fp)
 823fd08:	e0bffa03 	ldbu	r2,-24(fp)
 823fd0c:	1885883a 	add	r2,r3,r2
 823fd10:	1006d7fa 	srli	r3,r2,31
 823fd14:	1885883a 	add	r2,r3,r2
 823fd18:	1005d07a 	srai	r2,r2,1
 823fd1c:	100b883a 	mov	r5,r2
 823fd20:	e13ffb17 	ldw	r4,-20(fp)
 823fd24:	82286f00 	call	82286f0 <cksum>
 823fd28:	0084303a 	nor	r2,zero,r2
 823fd2c:	1007883a 	mov	r3,r2
 823fd30:	e0bffb17 	ldw	r2,-20(fp)
 823fd34:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal (p));
 823fd38:	e13ffe17 	ldw	r4,-8(fp)
 823fd3c:	823f08c0 	call	823f08c <ip_write_internal>
}
 823fd40:	e037883a 	mov	sp,fp
 823fd44:	dfc00117 	ldw	ra,4(sp)
 823fd48:	df000017 	ldw	fp,0(sp)
 823fd4c:	dec00204 	addi	sp,sp,8
 823fd50:	f800283a 	ret

0823fd54 <ip_raw_write>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_raw_write(PACKET p)
{
 823fd54:	defffc04 	addi	sp,sp,-16
 823fd58:	dfc00315 	stw	ra,12(sp)
 823fd5c:	df000215 	stw	fp,8(sp)
 823fd60:	df000204 	addi	fp,sp,8
 823fd64:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 823fd68:	008209b4 	movhi	r2,2086
 823fd6c:	10ba6a04 	addi	r2,r2,-5720
 823fd70:	10800917 	ldw	r2,36(r2)
 823fd74:	10c00044 	addi	r3,r2,1
 823fd78:	008209b4 	movhi	r2,2086
 823fd7c:	10ba6a04 	addi	r2,r2,-5720
 823fd80:	10c00915 	stw	r3,36(r2)

   /* form a pointer to IP header (pip) */
   pip = (struct ip*)(p->nb_prot);
 823fd84:	e0bfff17 	ldw	r2,-4(fp)
 823fd88:	10800317 	ldw	r2,12(r2)
 823fd8c:	e0bffe15 	stw	r2,-8(fp)
   
   /* if there's no IP id, give it one */
   if (pip->ip_id == 0)
 823fd90:	e0bffe17 	ldw	r2,-8(fp)
 823fd94:	1080010b 	ldhu	r2,4(r2)
 823fd98:	10bfffcc 	andi	r2,r2,65535
 823fd9c:	10000f1e 	bne	r2,zero,823fddc <ip_raw_write+0x88>
   {
      pip->ip_id = htons((unshort)uid);
 823fda0:	d0a05017 	ldw	r2,-32448(gp)
 823fda4:	10bfffcc 	andi	r2,r2,65535
 823fda8:	1005d23a 	srai	r2,r2,8
 823fdac:	10803fcc 	andi	r2,r2,255
 823fdb0:	1007883a 	mov	r3,r2
 823fdb4:	d0a05017 	ldw	r2,-32448(gp)
 823fdb8:	10bfffcc 	andi	r2,r2,65535
 823fdbc:	1004923a 	slli	r2,r2,8
 823fdc0:	1884b03a 	or	r2,r3,r2
 823fdc4:	1007883a 	mov	r3,r2
 823fdc8:	e0bffe17 	ldw	r2,-8(fp)
 823fdcc:	10c0010d 	sth	r3,4(r2)
      uid++;
 823fdd0:	d0a05017 	ldw	r2,-32448(gp)
 823fdd4:	10800044 	addi	r2,r2,1
 823fdd8:	d0a05015 	stw	r2,-32448(gp)
   }

   /* checksum the IP header */
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 823fddc:	e0bffe17 	ldw	r2,-8(fp)
 823fde0:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 823fde4:	01400284 	movi	r5,10
 823fde8:	e13ffe17 	ldw	r4,-8(fp)
 823fdec:	82286f00 	call	82286f0 <cksum>
 823fdf0:	0084303a 	nor	r2,zero,r2
 823fdf4:	1007883a 	mov	r3,r2
 823fdf8:	e0bffe17 	ldw	r2,-8(fp)
 823fdfc:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 823fe00:	e13fff17 	ldw	r4,-4(fp)
 823fe04:	823f08c0 	call	823f08c <ip_write_internal>
}
 823fe08:	e037883a 	mov	sp,fp
 823fe0c:	dfc00117 	ldw	ra,4(sp)
 823fe10:	df000017 	ldw	fp,0(sp)
 823fe14:	dec00204 	addi	sp,sp,8
 823fe18:	f800283a 	ret

0823fe1c <ip_fragment_lc>:
 *              invocation of ip2mac () for the last generated fragment
 */

int
ip_fragment_lc(PACKET p, ip_addr firsthop)
{
 823fe1c:	defff104 	addi	sp,sp,-60
 823fe20:	dfc00e15 	stw	ra,56(sp)
 823fe24:	df000d15 	stw	fp,52(sp)
 823fe28:	df000d04 	addi	fp,sp,52
 823fe2c:	e13ffe15 	stw	r4,-8(fp)
 823fe30:	e17fff15 	stw	r5,-4(fp)
   int      e;
   struct ip * pip;
   int      iphlen;     /* IP header length */
   unshort  tmp_fraginfo   ;

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 823fe34:	008209b4 	movhi	r2,2086
 823fe38:	10ba6a04 	addi	r2,r2,-5720
 823fe3c:	10801017 	ldw	r2,64(r2)
 823fe40:	10c00044 	addi	r3,r2,1
 823fe44:	008209b4 	movhi	r2,2086
 823fe48:	10ba6a04 	addi	r2,r2,-5720
 823fe4c:	10c01015 	stw	r3,64(r2)
   pip = (struct ip *)(p->nb_prot);          /* get ptr to IP header */
 823fe50:	e0bffe17 	ldw	r2,-8(fp)
 823fe54:	10800317 	ldw	r2,12(r2)
 823fe58:	e0bff815 	stw	r2,-32(fp)
   iphlen = (pip->ip_ver_ihl & 0xf) << 2;    /* and its length */
 823fe5c:	e0bff817 	ldw	r2,-32(fp)
 823fe60:	10800003 	ldbu	r2,0(r2)
 823fe64:	10803fcc 	andi	r2,r2,255
 823fe68:	108003cc 	andi	r2,r2,15
 823fe6c:	1085883a 	add	r2,r2,r2
 823fe70:	1085883a 	add	r2,r2,r2
 823fe74:	e0bff915 	stw	r2,-28(fp)
   left = (int)p->nb_plen - iphlen; /* bytes left to send in datagram */
 823fe78:	e0bffe17 	ldw	r2,-8(fp)
 823fe7c:	10800417 	ldw	r2,16(r2)
 823fe80:	1007883a 	mov	r3,r2
 823fe84:	e0bff917 	ldw	r2,-28(fp)
 823fe88:	1885c83a 	sub	r2,r3,r2
 823fe8c:	e0bff515 	stw	r2,-44(fp)
    * of fragments to get a fragment length that will result
    * in similarly-sized segments (remembering to round this
    * length up to a multiple of 8 because that's how the IP 
    * Fragment Offset field is scaled).
    */
   maxipsize = p->net->n_mtu - (iphlen + p->net->n_lnh + 8);   /* 8 == for rounding up */
 823fe90:	e0bffe17 	ldw	r2,-8(fp)
 823fe94:	10800617 	ldw	r2,24(r2)
 823fe98:	10c00917 	ldw	r3,36(r2)
 823fe9c:	e0bffe17 	ldw	r2,-8(fp)
 823fea0:	10800617 	ldw	r2,24(r2)
 823fea4:	11000817 	ldw	r4,32(r2)
 823fea8:	e0bff917 	ldw	r2,-28(fp)
 823feac:	2085883a 	add	r2,r4,r2
 823feb0:	10800204 	addi	r2,r2,8
 823feb4:	1885c83a 	sub	r2,r3,r2
 823feb8:	e0bffa15 	stw	r2,-24(fp)
   if (maxipsize < 64)  /* to small to use */
 823febc:	e0bffa17 	ldw	r2,-24(fp)
 823fec0:	10801028 	cmpgeui	r2,r2,64
 823fec4:	1000031e 	bne	r2,zero,823fed4 <ip_fragment_lc+0xb8>
   {
      dtrap();    /* probably bad programming */
 823fec8:	822d4140 	call	822d414 <dtrap>
      return ENP_LOGIC;
 823fecc:	00bffd44 	movi	r2,-11
 823fed0:	0000d506 	br	8240228 <ip_fragment_lc+0x40c>
   }
   numfrags = (p->nb_plen/maxipsize) + 1;    /* number of fragments */
 823fed4:	e0bffe17 	ldw	r2,-8(fp)
 823fed8:	10800417 	ldw	r2,16(r2)
 823fedc:	e17ffa17 	ldw	r5,-24(fp)
 823fee0:	1009883a 	mov	r4,r2
 823fee4:	8202b8c0 	call	8202b8c <__udivsi3>
 823fee8:	10800044 	addi	r2,r2,1
 823feec:	e0bffb15 	stw	r2,-20(fp)
   fragsize = (((p->nb_plen + (numfrags - 1)) / numfrags) + 7) & ~7; 
 823fef0:	e0bffe17 	ldw	r2,-8(fp)
 823fef4:	10c00417 	ldw	r3,16(r2)
 823fef8:	e0bffb17 	ldw	r2,-20(fp)
 823fefc:	1885883a 	add	r2,r3,r2
 823ff00:	10bfffc4 	addi	r2,r2,-1
 823ff04:	e17ffb17 	ldw	r5,-20(fp)
 823ff08:	1009883a 	mov	r4,r2
 823ff0c:	8202b8c0 	call	8202b8c <__udivsi3>
 823ff10:	10c001c4 	addi	r3,r2,7
 823ff14:	00bffe04 	movi	r2,-8
 823ff18:	1884703a 	and	r2,r3,r2
 823ff1c:	e0bffc15 	stw	r2,-16(fp)
   foffset = 0;
 823ff20:	e03ff315 	stw	zero,-52(fp)

   /* Now update from any previous info */
   tmp_fraginfo = ntohs(pip->ip_flgs_foff);     /* get current frag info*/
 823ff24:	e0bff817 	ldw	r2,-32(fp)
 823ff28:	1080018b 	ldhu	r2,6(r2)
 823ff2c:	10bfffcc 	andi	r2,r2,65535
 823ff30:	1004d23a 	srli	r2,r2,8
 823ff34:	1007883a 	mov	r3,r2
 823ff38:	e0bff817 	ldw	r2,-32(fp)
 823ff3c:	1080018b 	ldhu	r2,6(r2)
 823ff40:	10bfffcc 	andi	r2,r2,65535
 823ff44:	1004923a 	slli	r2,r2,8
 823ff48:	1884b03a 	or	r2,r3,r2
 823ff4c:	e0bffd0d 	sth	r2,-12(fp)
   if ( tmp_fraginfo & (~IP_FLG_MASK) )
 823ff50:	e0fffd0b 	ldhu	r3,-12(fp)
 823ff54:	00bffff4 	movhi	r2,65535
 823ff58:	1087ffc4 	addi	r2,r2,8191
 823ff5c:	1884703a 	and	r2,r3,r2
 823ff60:	10000826 	beq	r2,zero,823ff84 <ip_fragment_lc+0x168>
   {
      /* When fragmenting an already fragmented packet, we need to
         add the initial offset */
      foffset = (tmp_fraginfo & (~IP_FLG_MASK))  ;
 823ff64:	e0fffd0b 	ldhu	r3,-12(fp)
 823ff68:	00bffff4 	movhi	r2,65535
 823ff6c:	1087ffc4 	addi	r2,r2,8191
 823ff70:	1884703a 	and	r2,r3,r2
 823ff74:	e0bff315 	stw	r2,-52(fp)
      foffset <<= 3;    /* Multiply by 8 to get "offset in num of bytes" */
 823ff78:	e0bff317 	ldw	r2,-52(fp)
 823ff7c:	100490fa 	slli	r2,r2,3
 823ff80:	e0bff315 	stw	r2,-52(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
 823ff84:	e0bffe17 	ldw	r2,-8(fp)
 823ff88:	e0bff615 	stw	r2,-40(fp)
   e = 0;
 823ff8c:	e03ff715 	stw	zero,-36(fp)
   while (left > 1)  /* more data left to send? */
 823ff90:	0000a106 	br	8240218 <ip_fragment_lc+0x3fc>
   {
      p = pkt2;  /* move next fragment up */
 823ff94:	e0bff617 	ldw	r2,-40(fp)
 823ff98:	e0bffe15 	stw	r2,-8(fp)
      pip = (struct ip *)(p->nb_prot);
 823ff9c:	e0bffe17 	ldw	r2,-8(fp)
 823ffa0:	10800317 	ldw	r2,12(r2)
 823ffa4:	e0bff815 	stw	r2,-32(fp)
      p->nb_plen = min((int)fragsize, left) + iphlen; /* set size of fragment */
 823ffa8:	e0bffc17 	ldw	r2,-16(fp)
 823ffac:	e0fff517 	ldw	r3,-44(fp)
 823ffb0:	1880010e 	bge	r3,r2,823ffb8 <ip_fragment_lc+0x19c>
 823ffb4:	1805883a 	mov	r2,r3
 823ffb8:	e0fff917 	ldw	r3,-28(fp)
 823ffbc:	10c5883a 	add	r2,r2,r3
 823ffc0:	1007883a 	mov	r3,r2
 823ffc4:	e0bffe17 	ldw	r2,-8(fp)
 823ffc8:	10c00415 	stw	r3,16(r2)
      left -= fragsize; /* decrement count of bytes left to send */
 823ffcc:	e0fff517 	ldw	r3,-44(fp)
 823ffd0:	e0bffc17 	ldw	r2,-16(fp)
 823ffd4:	1885c83a 	sub	r2,r3,r2
 823ffd8:	e0bff515 	stw	r2,-44(fp)

      /* set the IP datagram length */
      pip->ip_len = htons((unshort)p->nb_plen);
 823ffdc:	e0bffe17 	ldw	r2,-8(fp)
 823ffe0:	10800417 	ldw	r2,16(r2)
 823ffe4:	10bfffcc 	andi	r2,r2,65535
 823ffe8:	1005d23a 	srai	r2,r2,8
 823ffec:	10803fcc 	andi	r2,r2,255
 823fff0:	1007883a 	mov	r3,r2
 823fff4:	e0bffe17 	ldw	r2,-8(fp)
 823fff8:	10800417 	ldw	r2,16(r2)
 823fffc:	10bfffcc 	andi	r2,r2,65535
 8240000:	1004923a 	slli	r2,r2,8
 8240004:	1884b03a 	or	r2,r3,r2
 8240008:	1007883a 	mov	r3,r2
 824000c:	e0bff817 	ldw	r2,-32(fp)
 8240010:	10c0008d 	sth	r3,2(r2)

      /* build 16bit IP header field value for fragment flags & offset */
      fraginfo = (unshort)(foffset >> 3);    /* offset, in 8 byte chunks */
 8240014:	e0bff317 	ldw	r2,-52(fp)
 8240018:	1004d0fa 	srli	r2,r2,3
 824001c:	e0bff40d 	sth	r2,-48(fp)
      fraginfo |= ((left>1)?IP_FLG_MF:0);    /* OR in MoreFrags flag */
 8240020:	e0bff517 	ldw	r2,-44(fp)
 8240024:	10800090 	cmplti	r2,r2,2
 8240028:	1000021e 	bne	r2,zero,8240034 <ip_fragment_lc+0x218>
 824002c:	00880004 	movi	r2,8192
 8240030:	00000106 	br	8240038 <ip_fragment_lc+0x21c>
 8240034:	0005883a 	mov	r2,zero
 8240038:	e0fff40b 	ldhu	r3,-48(fp)
 824003c:	10c4b03a 	or	r2,r2,r3
 8240040:	e0bff40d 	sth	r2,-48(fp)

      if ( tmp_fraginfo & IP_FLG_MF )             
 8240044:	e0bffd0b 	ldhu	r2,-12(fp)
 8240048:	1088000c 	andi	r2,r2,8192
 824004c:	10000326 	beq	r2,zero,824005c <ip_fragment_lc+0x240>
      {
         /* As flag is set in main packet, it should be set in all
          * fragmented packets also 
          */
         fraginfo |= IP_FLG_MF;
 8240050:	e0bff40b 	ldhu	r2,-48(fp)
 8240054:	10880014 	ori	r2,r2,8192
 8240058:	e0bff40d 	sth	r2,-48(fp)
      }

      pip->ip_flgs_foff = htons(fraginfo);   /* do htons macro on separate line */
 824005c:	e0bff40b 	ldhu	r2,-48(fp)
 8240060:	1004d23a 	srli	r2,r2,8
 8240064:	1007883a 	mov	r3,r2
 8240068:	e0bff40b 	ldhu	r2,-48(fp)
 824006c:	1004923a 	slli	r2,r2,8
 8240070:	1884b03a 	or	r2,r3,r2
 8240074:	1007883a 	mov	r3,r2
 8240078:	e0bff817 	ldw	r2,-32(fp)
 824007c:	10c0018d 	sth	r3,6(r2)
      /* set up & save next fragment (pkt2) since ip2mac() will delete p */
      if (left > 1)
 8240080:	e0bff517 	ldw	r2,-44(fp)
 8240084:	10800090 	cmplti	r2,r2,2
 8240088:	10003e1e 	bne	r2,zero,8240184 <ip_fragment_lc+0x368>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 824008c:	01000084 	movi	r4,2
 8240090:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pkt2 = pk_alloc(left + iphlen + MaxLnh);
 8240094:	e0fff517 	ldw	r3,-44(fp)
 8240098:	e0bff917 	ldw	r2,-28(fp)
 824009c:	1887883a 	add	r3,r3,r2
 82400a0:	d0a08117 	ldw	r2,-32252(gp)
 82400a4:	1885883a 	add	r2,r3,r2
 82400a8:	1009883a 	mov	r4,r2
 82400ac:	822c86c0 	call	822c86c <pk_alloc>
 82400b0:	e0bff615 	stw	r2,-40(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82400b4:	01000084 	movi	r4,2
 82400b8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         if (!pkt2)
 82400bc:	e0bff617 	ldw	r2,-40(fp)
 82400c0:	1000101e 	bne	r2,zero,8240104 <ip_fragment_lc+0x2e8>
         {
            dtrap();
 82400c4:	822d4140 	call	822d414 <dtrap>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 82400c8:	01000084 	movi	r4,2
 82400cc:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
            pk_free(p);
 82400d0:	e13ffe17 	ldw	r4,-8(fp)
 82400d4:	822cbbc0 	call	822cbbc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82400d8:	01000084 	movi	r4,2
 82400dc:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 82400e0:	008209b4 	movhi	r2,2086
 82400e4:	10ba6a04 	addi	r2,r2,-5720
 82400e8:	10801117 	ldw	r2,68(r2)
 82400ec:	10c00044 	addi	r3,r2,1
 82400f0:	008209b4 	movhi	r2,2086
 82400f4:	10ba6a04 	addi	r2,r2,-5720
 82400f8:	10c01115 	stw	r3,68(r2)
            return ENP_RESOURCE;
 82400fc:	00bffa84 	movi	r2,-22
 8240100:	00004906 	br	8240228 <ip_fragment_lc+0x40c>
         }

         pkt2->net = p->net;       /* copy critical parms to new packet */
 8240104:	e0bffe17 	ldw	r2,-8(fp)
 8240108:	10c00617 	ldw	r3,24(r2)
 824010c:	e0bff617 	ldw	r2,-40(fp)
 8240110:	10c00615 	stw	r3,24(r2)
         pkt2->fhost = p->fhost;
 8240114:	e0bffe17 	ldw	r2,-8(fp)
 8240118:	10c00717 	ldw	r3,28(r2)
 824011c:	e0bff617 	ldw	r2,-40(fp)
 8240120:	10c00715 	stw	r3,28(r2)
         /* Duplicate the IPHeader */
         MEMCPY(pkt2->nb_prot, p->nb_prot, iphlen);
 8240124:	e0bff617 	ldw	r2,-40(fp)
 8240128:	10c00317 	ldw	r3,12(r2)
 824012c:	e0bffe17 	ldw	r2,-8(fp)
 8240130:	10800317 	ldw	r2,12(r2)
 8240134:	e13ff917 	ldw	r4,-28(fp)
 8240138:	200d883a 	mov	r6,r4
 824013c:	100b883a 	mov	r5,r2
 8240140:	1809883a 	mov	r4,r3
 8240144:	8202e8c0 	call	8202e8c <memcpy>
         /* copy data for NEXT fragment from p to pkt2 */
         MEMCPY(pkt2->nb_prot + iphlen, p->nb_prot + iphlen + fragsize, left);
 8240148:	e0bff617 	ldw	r2,-40(fp)
 824014c:	10c00317 	ldw	r3,12(r2)
 8240150:	e0bff917 	ldw	r2,-28(fp)
 8240154:	188f883a 	add	r7,r3,r2
 8240158:	e0bffe17 	ldw	r2,-8(fp)
 824015c:	10c00317 	ldw	r3,12(r2)
 8240160:	e13ff917 	ldw	r4,-28(fp)
 8240164:	e0bffc17 	ldw	r2,-16(fp)
 8240168:	2085883a 	add	r2,r4,r2
 824016c:	1885883a 	add	r2,r3,r2
 8240170:	e0fff517 	ldw	r3,-44(fp)
 8240174:	180d883a 	mov	r6,r3
 8240178:	100b883a 	mov	r5,r2
 824017c:	3809883a 	mov	r4,r7
 8240180:	8202e8c0 	call	8202e8c <memcpy>
      }

      /* we've changed the IP header, so recalculate the checksum */
      pip->ip_chksum = IPXSUM;
 8240184:	e0bff817 	ldw	r2,-32(fp)
 8240188:	1000028d 	sth	zero,10(r2)
      pip->ip_chksum = ~cksum(pip, 10);
 824018c:	01400284 	movi	r5,10
 8240190:	e13ff817 	ldw	r4,-32(fp)
 8240194:	82286f00 	call	82286f0 <cksum>
 8240198:	0084303a 	nor	r2,zero,r2
 824019c:	1007883a 	mov	r3,r2
 82401a0:	e0bff817 	ldw	r2,-32(fp)
 82401a4:	10c0028d 	sth	r3,10(r2)

      /* ip_dump(p); */

      e = ip2mac(p, firsthop);   /* send fragment in p */
 82401a8:	e17fff17 	ldw	r5,-4(fp)
 82401ac:	e13ffe17 	ldw	r4,-8(fp)
 82401b0:	82266340 	call	8226634 <ip2mac>
 82401b4:	e0bff715 	stw	r2,-36(fp)
      ip_mib.ipFragCreates++;
 82401b8:	008209b4 	movhi	r2,2086
 82401bc:	10ba6a04 	addi	r2,r2,-5720
 82401c0:	10801217 	ldw	r2,72(r2)
 82401c4:	10c00044 	addi	r3,r2,1
 82401c8:	008209b4 	movhi	r2,2086
 82401cc:	10ba6a04 	addi	r2,r2,-5720
 82401d0:	10c01215 	stw	r3,72(r2)
      if (e < 0)
 82401d4:	e0bff717 	ldw	r2,-36(fp)
 82401d8:	10000b0e 	bge	r2,zero,8240208 <ip_fragment_lc+0x3ec>
      {
         if (left > 1) 
 82401dc:	e0bff517 	ldw	r2,-44(fp)
 82401e0:	10800090 	cmplti	r2,r2,2
 82401e4:	1000061e 	bne	r2,zero,8240200 <ip_fragment_lc+0x3e4>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 82401e8:	01000084 	movi	r4,2
 82401ec:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
            pk_free(pkt2);
 82401f0:	e13ff617 	ldw	r4,-40(fp)
 82401f4:	822cbbc0 	call	822cbbc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82401f8:	01000084 	movi	r4,2
 82401fc:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         }
         return e;
 8240200:	e0bff717 	ldw	r2,-36(fp)
 8240204:	00000806 	br	8240228 <ip_fragment_lc+0x40c>
      }
      foffset += fragsize;    /* offset for next fragment */
 8240208:	e0fff317 	ldw	r3,-52(fp)
 824020c:	e0bffc17 	ldw	r2,-16(fp)
 8240210:	1885883a 	add	r2,r3,r2
 8240214:	e0bff315 	stw	r2,-52(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
   e = 0;
   while (left > 1)  /* more data left to send? */
 8240218:	e0bff517 	ldw	r2,-44(fp)
 824021c:	10800088 	cmpgei	r2,r2,2
 8240220:	103f5c1e 	bne	r2,zero,823ff94 <ip_fragment_lc+0x178>
         }
         return e;
      }
      foffset += fragsize;    /* offset for next fragment */
   }
   return e;
 8240224:	e0bff717 	ldw	r2,-36(fp)
}
 8240228:	e037883a 	mov	sp,fp
 824022c:	dfc00117 	ldw	ra,4(sp)
 8240230:	df000017 	ldw	fp,0(sp)
 8240234:	dec00204 	addi	sp,sp,8
 8240238:	f800283a 	ret

0824023c <ip_fragment>:
 *              generated fragment, if less than zero
 *          (5) 0, if everything went okay
 */

int ip_fragment(PACKET p, ip_addr firsthop)
{
 824023c:	defff004 	addi	sp,sp,-64
 8240240:	dfc00f15 	stw	ra,60(sp)
 8240244:	df000e15 	stw	fp,56(sp)
 8240248:	df000e04 	addi	fp,sp,56
 824024c:	e13ffe15 	stw	r4,-8(fp)
 8240250:	e17fff15 	stw	r5,-4(fp)
   u_short parent_mf;
   PACKET newpkt;
   struct ip * newpip;
   int e;

   pip = ip_head(p);
 8240254:	e0bffe17 	ldw	r2,-8(fp)
 8240258:	10800317 	ldw	r2,12(r2)
 824025c:	e0bff515 	stw	r2,-44(fp)
   if ((ntohs(pip->ip_flgs_foff)) & IP_FLG_DF)
 8240260:	e0bff517 	ldw	r2,-44(fp)
 8240264:	1080018b 	ldhu	r2,6(r2)
 8240268:	10bfffcc 	andi	r2,r2,65535
 824026c:	1004d23a 	srli	r2,r2,8
 8240270:	10bfffcc 	andi	r2,r2,65535
 8240274:	10c03fcc 	andi	r3,r2,255
 8240278:	e0bff517 	ldw	r2,-44(fp)
 824027c:	1080018b 	ldhu	r2,6(r2)
 8240280:	10bfffcc 	andi	r2,r2,65535
 8240284:	1004923a 	slli	r2,r2,8
 8240288:	10bfffcc 	andi	r2,r2,65535
 824028c:	1884b03a 	or	r2,r3,r2
 8240290:	1090000c 	andi	r2,r2,16384
 8240294:	10001c26 	beq	r2,zero,8240308 <ip_fragment+0xcc>
   {
      /* can't fragment a packet with the DF bit set */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8240298:	01000084 	movi	r4,2
 824029c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(p);
 82402a0:	e13ffe17 	ldw	r4,-8(fp)
 82402a4:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82402a8:	01000084 	movi	r4,2
 82402ac:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      ip_mib.ipFragFails++;
 82402b0:	008209b4 	movhi	r2,2086
 82402b4:	10ba6a04 	addi	r2,r2,-5720
 82402b8:	10801117 	ldw	r2,68(r2)
 82402bc:	10c00044 	addi	r3,r2,1
 82402c0:	008209b4 	movhi	r2,2086
 82402c4:	10ba6a04 	addi	r2,r2,-5720
 82402c8:	10c01115 	stw	r3,68(r2)
#ifdef FULL_ICMP
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 82402cc:	e0bff517 	ldw	r2,-44(fp)
 82402d0:	10c00317 	ldw	r3,12(r2)
 82402d4:	e0bffe17 	ldw	r2,-8(fp)
 82402d8:	10800617 	ldw	r2,24(r2)
 82402dc:	11000a17 	ldw	r4,40(r2)
 82402e0:	e0bffe17 	ldw	r2,-8(fp)
 82402e4:	10800617 	ldw	r2,24(r2)
 82402e8:	d8800015 	stw	r2,0(sp)
 82402ec:	01c00104 	movi	r7,4
 82402f0:	e1bff517 	ldw	r6,-44(fp)
 82402f4:	200b883a 	mov	r5,r4
 82402f8:	1809883a 	mov	r4,r3
 82402fc:	824ae140 	call	824ae14 <icmp_destun>
#endif   /* FULL_ICMP */
      return 0;
 8240300:	0005883a 	mov	r2,zero
 8240304:	00013906 	br	82407ec <ip_fragment+0x5b0>
   }

   maxbuflen = pk_get_max_intrsafe_buf_len ();
 8240308:	822cc680 	call	822cc68 <pk_get_max_intrsafe_buf_len>
 824030c:	e0bff615 	stw	r2,-40(fp)

   /* the maximum amount of data that will be sent to ip2mac ().  Please note that
    * our definition of MTU is different from the traditional definition of that
    * parameter (which excludes the data link layer header). */
   maxl3_len = (unsigned short int) (MIN(maxbuflen, ((unsigned) p->net->n_mtu)));
 8240310:	e0bffe17 	ldw	r2,-8(fp)
 8240314:	10800617 	ldw	r2,24(r2)
 8240318:	10800917 	ldw	r2,36(r2)
 824031c:	1007883a 	mov	r3,r2
 8240320:	e0bff617 	ldw	r2,-40(fp)
 8240324:	10c0022e 	bgeu	r2,r3,8240330 <ip_fragment+0xf4>
 8240328:	e0bff617 	ldw	r2,-40(fp)
 824032c:	00000306 	br	824033c <ip_fragment+0x100>
 8240330:	e0bffe17 	ldw	r2,-8(fp)
 8240334:	10800617 	ldw	r2,24(r2)
 8240338:	10800917 	ldw	r2,36(r2)
 824033c:	e0bff70d 	sth	r2,-36(fp)

   /* get the length of the IP header of the original, unfragmented datagram */
   iphlen = ip_hlen(pip);
 8240340:	e0bff517 	ldw	r2,-44(fp)
 8240344:	10800003 	ldbu	r2,0(r2)
 8240348:	108003cc 	andi	r2,r2,15
 824034c:	1085883a 	add	r2,r2,r2
 8240350:	1085883a 	add	r2,r2,r2
 8240354:	e0bff785 	stb	r2,-34(fp)

   /* obtain the useable payload length in an IP datagram (after accounting for the 
    * length of the IP and data link layer headers) */
   l2hdr_len = (u_char) p->net->n_lnh;
 8240358:	e0bffe17 	ldw	r2,-8(fp)
 824035c:	10800617 	ldw	r2,24(r2)
 8240360:	10800817 	ldw	r2,32(r2)
 8240364:	e0bff7c5 	stb	r2,-33(fp)
   useable_payload_len = maxl3_len - iphlen - l2hdr_len;
 8240368:	e0bff783 	ldbu	r2,-34(fp)
 824036c:	e0fff70b 	ldhu	r3,-36(fp)
 8240370:	1885c83a 	sub	r2,r3,r2
 8240374:	1007883a 	mov	r3,r2
 8240378:	e0bff7c3 	ldbu	r2,-33(fp)
 824037c:	1885c83a 	sub	r2,r3,r2
 8240380:	e0bff80d 	sth	r2,-32(fp)

   /* IP fragments must always have a length that is a multiple of 8 bytes, so we
    * need to round 'payload_len' down to the nearest multiple of 8 bytes. */
   useable_payload_len &= (~((unsigned short int) 0x07));
 8240384:	e0fff80b 	ldhu	r3,-32(fp)
 8240388:	00bffe04 	movi	r2,-8
 824038c:	1884703a 	and	r2,r3,r2
 8240390:	e0bff80d 	sth	r2,-32(fp)

   /* compute the number of packets that we need to send.  First compute the total
    * payload length of the "original" datagram (which could itself be a fragment). 
    */
   total_payload_len = (ntohs(pip->ip_len)) - iphlen;
 8240394:	e0bff517 	ldw	r2,-44(fp)
 8240398:	1080008b 	ldhu	r2,2(r2)
 824039c:	10bfffcc 	andi	r2,r2,65535
 82403a0:	1004d23a 	srli	r2,r2,8
 82403a4:	1007883a 	mov	r3,r2
 82403a8:	e0bff517 	ldw	r2,-44(fp)
 82403ac:	1080008b 	ldhu	r2,2(r2)
 82403b0:	10bfffcc 	andi	r2,r2,65535
 82403b4:	1004923a 	slli	r2,r2,8
 82403b8:	1884b03a 	or	r2,r3,r2
 82403bc:	1007883a 	mov	r3,r2
 82403c0:	e0bff783 	ldbu	r2,-34(fp)
 82403c4:	1885c83a 	sub	r2,r3,r2
 82403c8:	e0bff88d 	sth	r2,-30(fp)
   num_frags = (total_payload_len / useable_payload_len);
 82403cc:	e0bff88b 	ldhu	r2,-30(fp)
 82403d0:	e0fff80b 	ldhu	r3,-32(fp)
 82403d4:	180b883a 	mov	r5,r3
 82403d8:	1009883a 	mov	r4,r2
 82403dc:	8202b8c0 	call	8202b8c <__udivsi3>
 82403e0:	e0bff30d 	sth	r2,-52(fp)
   if ((last_payload_len = (total_payload_len % useable_payload_len)) != 0)
 82403e4:	e0bff88b 	ldhu	r2,-30(fp)
 82403e8:	e0fff80b 	ldhu	r3,-32(fp)
 82403ec:	180b883a 	mov	r5,r3
 82403f0:	1009883a 	mov	r4,r2
 82403f4:	8202bf00 	call	8202bf0 <__umodsi3>
 82403f8:	e0bff90d 	sth	r2,-28(fp)
 82403fc:	e0bff90b 	ldhu	r2,-28(fp)
 8240400:	10000326 	beq	r2,zero,8240410 <ip_fragment+0x1d4>
   {
      /* we will have one additional (also last) fragment that is smaller than the 
       * other fragments */
      ++num_frags;
 8240404:	e0bff30b 	ldhu	r2,-52(fp)
 8240408:	10800044 	addi	r2,r2,1
 824040c:	e0bff30d 	sth	r2,-52(fp)
    * the one passed to this function) is interrupt-safe, then we use 
    * ip_fragment_lc () for creating the child fragments.  This decreases the 
    * amount of copying that needs to be done in those cases (as compared to this 
    * function); however, for larger packets, ip_fragment () becomes more efficient 
    * (than ip_fragment_lc ()). */
   if ((num_frags <= FRAG_SCHEME_SWITCH_THRESHOLD) && (!(p->flags & PKF_INTRUNSAFE)))
 8240410:	e0bff30b 	ldhu	r2,-52(fp)
 8240414:	10800128 	cmpgeui	r2,r2,4
 8240418:	1000081e 	bne	r2,zero,824043c <ip_fragment+0x200>
 824041c:	e0bffe17 	ldw	r2,-8(fp)
 8240420:	10800a17 	ldw	r2,40(r2)
 8240424:	1080040c 	andi	r2,r2,16
 8240428:	1000041e 	bne	r2,zero,824043c <ip_fragment+0x200>
   {
      return (ip_fragment_lc (p, firsthop));
 824042c:	e17fff17 	ldw	r5,-4(fp)
 8240430:	e13ffe17 	ldw	r4,-8(fp)
 8240434:	823fe1c0 	call	823fe1c <ip_fragment_lc>
 8240438:	0000ec06 	br	82407ec <ip_fragment+0x5b0>
   }

   parent_frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 824043c:	e0bff517 	ldw	r2,-44(fp)
 8240440:	1080018b 	ldhu	r2,6(r2)
 8240444:	10bfffcc 	andi	r2,r2,65535
 8240448:	1004d23a 	srli	r2,r2,8
 824044c:	10bfffcc 	andi	r2,r2,65535
 8240450:	10c03fcc 	andi	r3,r2,255
 8240454:	e0bff517 	ldw	r2,-44(fp)
 8240458:	1080018b 	ldhu	r2,6(r2)
 824045c:	10bfffcc 	andi	r2,r2,65535
 8240460:	1004923a 	slli	r2,r2,8
 8240464:	10bfffcc 	andi	r2,r2,65535
 8240468:	1884b03a 	or	r2,r3,r2
 824046c:	100490fa 	slli	r2,r2,3
 8240470:	e0bff98d 	sth	r2,-26(fp)
   parent_mf = ((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF);
 8240474:	e0bff517 	ldw	r2,-44(fp)
 8240478:	1080018b 	ldhu	r2,6(r2)
 824047c:	10bfffcc 	andi	r2,r2,65535
 8240480:	1004d23a 	srli	r2,r2,8
 8240484:	1007883a 	mov	r3,r2
 8240488:	e0bff517 	ldw	r2,-44(fp)
 824048c:	1080018b 	ldhu	r2,6(r2)
 8240490:	10bfffcc 	andi	r2,r2,65535
 8240494:	1004923a 	slli	r2,r2,8
 8240498:	1884b03a 	or	r2,r3,r2
 824049c:	1088000c 	andi	r2,r2,8192
 82404a0:	e0bffa0d 	sth	r2,-24(fp)
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 82404a4:	e03ff38d 	sth	zero,-50(fp)
 82404a8:	0000bf06 	br	82407a8 <ip_fragment+0x56c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 82404ac:	01000084 	movi	r4,2
 82404b0:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      newpkt = pk_alloc (useable_payload_len + iphlen + l2hdr_len); 
 82404b4:	e0fff80b 	ldhu	r3,-32(fp)
 82404b8:	e0bff783 	ldbu	r2,-34(fp)
 82404bc:	1887883a 	add	r3,r3,r2
 82404c0:	e0bff7c3 	ldbu	r2,-33(fp)
 82404c4:	1885883a 	add	r2,r3,r2
 82404c8:	1009883a 	mov	r4,r2
 82404cc:	822c86c0 	call	822c86c <pk_alloc>
 82404d0:	e0bffb15 	stw	r2,-20(fp)
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82404d4:	01000084 	movi	r4,2
 82404d8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

      if (newpkt == 0)
 82404dc:	e0bffb17 	ldw	r2,-20(fp)
 82404e0:	10000f1e 	bne	r2,zero,8240520 <ip_fragment+0x2e4>
      {
         /* free the packet that we are working with */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 82404e4:	01000084 	movi	r4,2
 82404e8:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free(p);
 82404ec:	e13ffe17 	ldw	r4,-8(fp)
 82404f0:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82404f4:	01000084 	movi	r4,2
 82404f8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         ip_mib.ipFragFails++;
 82404fc:	008209b4 	movhi	r2,2086
 8240500:	10ba6a04 	addi	r2,r2,-5720
 8240504:	10801117 	ldw	r2,68(r2)
 8240508:	10c00044 	addi	r3,r2,1
 824050c:	008209b4 	movhi	r2,2086
 8240510:	10ba6a04 	addi	r2,r2,-5720
 8240514:	10c01115 	stw	r3,68(r2)
         return ENP_NOBUFFER;
 8240518:	00bffac4 	movi	r2,-21
 824051c:	0000b306 	br	82407ec <ip_fragment+0x5b0>
      }
      else
      {
         /* copy the IP header from the original datagram into the fragment */
         MEMCPY((newpkt->nb_buff + l2hdr_len), p->nb_prot, iphlen);
 8240520:	e0bffb17 	ldw	r2,-20(fp)
 8240524:	10c00117 	ldw	r3,4(r2)
 8240528:	e0bff7c3 	ldbu	r2,-33(fp)
 824052c:	1887883a 	add	r3,r3,r2
 8240530:	e0bffe17 	ldw	r2,-8(fp)
 8240534:	10800317 	ldw	r2,12(r2)
 8240538:	e13ff783 	ldbu	r4,-34(fp)
 824053c:	200d883a 	mov	r6,r4
 8240540:	100b883a 	mov	r5,r2
 8240544:	1809883a 	mov	r4,r3
 8240548:	8202e8c0 	call	8202e8c <memcpy>

         /* compute the amount of payload that needs to be copied into each 
          * child fragment */
         if (i < (num_frags - 1))
 824054c:	e0fff38b 	ldhu	r3,-50(fp)
 8240550:	e0bff30b 	ldhu	r2,-52(fp)
 8240554:	10bfffc4 	addi	r2,r2,-1
 8240558:	1880030e 	bge	r3,r2,8240568 <ip_fragment+0x32c>
         {
            amt_to_copy = useable_payload_len;
 824055c:	e0bff80b 	ldhu	r2,-32(fp)
 8240560:	e0bff40d 	sth	r2,-48(fp)
 8240564:	00000606 	br	8240580 <ip_fragment+0x344>
         }
         else
         {
            amt_to_copy = ((last_payload_len == 0) ? useable_payload_len : last_payload_len);
 8240568:	e0bff90b 	ldhu	r2,-28(fp)
 824056c:	1000021e 	bne	r2,zero,8240578 <ip_fragment+0x33c>
 8240570:	e0bff80b 	ldhu	r2,-32(fp)
 8240574:	00000106 	br	824057c <ip_fragment+0x340>
 8240578:	e0bff90b 	ldhu	r2,-28(fp)
 824057c:	e0bff40d 	sth	r2,-48(fp)
         }
         MEMCPY((newpkt->nb_buff + l2hdr_len + iphlen), p->nb_prot + iphlen + (useable_payload_len * i), amt_to_copy);
 8240580:	e0bffb17 	ldw	r2,-20(fp)
 8240584:	10c00117 	ldw	r3,4(r2)
 8240588:	e13ff7c3 	ldbu	r4,-33(fp)
 824058c:	e0bff783 	ldbu	r2,-34(fp)
 8240590:	2085883a 	add	r2,r4,r2
 8240594:	188f883a 	add	r7,r3,r2
 8240598:	e0bffe17 	ldw	r2,-8(fp)
 824059c:	10c00317 	ldw	r3,12(r2)
 82405a0:	e0bff783 	ldbu	r2,-34(fp)
 82405a4:	e17ff80b 	ldhu	r5,-32(fp)
 82405a8:	e13ff38b 	ldhu	r4,-50(fp)
 82405ac:	2909383a 	mul	r4,r5,r4
 82405b0:	1105883a 	add	r2,r2,r4
 82405b4:	1885883a 	add	r2,r3,r2
 82405b8:	e0fff40b 	ldhu	r3,-48(fp)
 82405bc:	180d883a 	mov	r6,r3
 82405c0:	100b883a 	mov	r5,r2
 82405c4:	3809883a 	mov	r4,r7
 82405c8:	8202e8c0 	call	8202e8c <memcpy>

         /* set up the various netbuf fields for the fragment */
         newpkt->nb_prot = newpkt->nb_buff + l2hdr_len;
 82405cc:	e0bffb17 	ldw	r2,-20(fp)
 82405d0:	10c00117 	ldw	r3,4(r2)
 82405d4:	e0bff7c3 	ldbu	r2,-33(fp)
 82405d8:	1887883a 	add	r3,r3,r2
 82405dc:	e0bffb17 	ldw	r2,-20(fp)
 82405e0:	10c00315 	stw	r3,12(r2)
         newpkt->nb_plen = iphlen + amt_to_copy;
 82405e4:	e0fff783 	ldbu	r3,-34(fp)
 82405e8:	e0bff40b 	ldhu	r2,-48(fp)
 82405ec:	1885883a 	add	r2,r3,r2
 82405f0:	1007883a 	mov	r3,r2
 82405f4:	e0bffb17 	ldw	r2,-20(fp)
 82405f8:	10c00415 	stw	r3,16(r2)
         newpkt->net = p->net;
 82405fc:	e0bffe17 	ldw	r2,-8(fp)
 8240600:	10c00617 	ldw	r3,24(r2)
 8240604:	e0bffb17 	ldw	r2,-20(fp)
 8240608:	10c00615 	stw	r3,24(r2)
         newpkt->fhost = p->fhost;
 824060c:	e0bffe17 	ldw	r2,-8(fp)
 8240610:	10c00717 	ldw	r3,28(r2)
 8240614:	e0bffb17 	ldw	r2,-20(fp)
 8240618:	10c00715 	stw	r3,28(r2)
         /* type and nb_tstamp fields are not used in the egress direction, but we set 'type' anyway */
         newpkt->type = htons(IPTP);
 824061c:	e0bffb17 	ldw	r2,-20(fp)
 8240620:	00c20004 	movi	r3,2048
 8240624:	10c0080d 	sth	r3,32(r2)

         /* now set the Total Length, Fragment Offset, and More Fragments fields */
         newpip = ip_head(newpkt);
 8240628:	e0bffb17 	ldw	r2,-20(fp)
 824062c:	10800317 	ldw	r2,12(r2)
 8240630:	e0bffc15 	stw	r2,-16(fp)
         newpip->ip_len = htons(newpkt->nb_plen);
 8240634:	e0bffb17 	ldw	r2,-20(fp)
 8240638:	10800417 	ldw	r2,16(r2)
 824063c:	1004d23a 	srli	r2,r2,8
 8240640:	10803fcc 	andi	r2,r2,255
 8240644:	1007883a 	mov	r3,r2
 8240648:	e0bffb17 	ldw	r2,-20(fp)
 824064c:	10800417 	ldw	r2,16(r2)
 8240650:	1004923a 	slli	r2,r2,8
 8240654:	1884b03a 	or	r2,r3,r2
 8240658:	1007883a 	mov	r3,r2
 824065c:	e0bffc17 	ldw	r2,-16(fp)
 8240660:	10c0008d 	sth	r3,2(r2)
         /* the following statement will reset DF and MF bits */
         newpip->ip_flgs_foff = htons((parent_frag_offset + (useable_payload_len * i)) >> 3);
 8240664:	e0fff98b 	ldhu	r3,-26(fp)
 8240668:	e13ff80b 	ldhu	r4,-32(fp)
 824066c:	e0bff38b 	ldhu	r2,-50(fp)
 8240670:	2085383a 	mul	r2,r4,r2
 8240674:	1885883a 	add	r2,r3,r2
 8240678:	1005d2fa 	srai	r2,r2,11
 824067c:	10803fcc 	andi	r2,r2,255
 8240680:	100b883a 	mov	r5,r2
 8240684:	e0fff98b 	ldhu	r3,-26(fp)
 8240688:	e13ff80b 	ldhu	r4,-32(fp)
 824068c:	e0bff38b 	ldhu	r2,-50(fp)
 8240690:	2085383a 	mul	r2,r4,r2
 8240694:	1885883a 	add	r2,r3,r2
 8240698:	1005d0fa 	srai	r2,r2,3
 824069c:	1004923a 	slli	r2,r2,8
 82406a0:	2884b03a 	or	r2,r5,r2
 82406a4:	1007883a 	mov	r3,r2
 82406a8:	e0bffc17 	ldw	r2,-16(fp)
 82406ac:	10c0018d 	sth	r3,6(r2)
          *     child fragments but the last will have the MF bit set)
          * (2) Parent fragment offset = x, MF = 1: first or middle fragment (FF or MF)
          *     (all child fragments will have the MF bit set)
          * (3) Parent fragment offset > 0, MF = 0: last fragment (LF) (all child fragments
          *     except the last will have the MF bit set) */
         if (i < (num_frags - 1))
 82406b0:	e0fff38b 	ldhu	r3,-50(fp)
 82406b4:	e0bff30b 	ldhu	r2,-52(fp)
 82406b8:	10bfffc4 	addi	r2,r2,-1
 82406bc:	1880070e 	bge	r3,r2,82406dc <ip_fragment+0x4a0>
         {
            newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 82406c0:	e0bffc17 	ldw	r2,-16(fp)
 82406c4:	1080018b 	ldhu	r2,6(r2)
 82406c8:	10800814 	ori	r2,r2,32
 82406cc:	1007883a 	mov	r3,r2
 82406d0:	e0bffc17 	ldw	r2,-16(fp)
 82406d4:	10c0018d 	sth	r3,6(r2)
 82406d8:	00000806 	br	82406fc <ip_fragment+0x4c0>
         }
         else
         {
            if (parent_mf)
 82406dc:	e0bffa0b 	ldhu	r2,-24(fp)
 82406e0:	10000626 	beq	r2,zero,82406fc <ip_fragment+0x4c0>
            {
               newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 82406e4:	e0bffc17 	ldw	r2,-16(fp)
 82406e8:	1080018b 	ldhu	r2,6(r2)
 82406ec:	10800814 	ori	r2,r2,32
 82406f0:	1007883a 	mov	r3,r2
 82406f4:	e0bffc17 	ldw	r2,-16(fp)
 82406f8:	10c0018d 	sth	r3,6(r2)
            }
         }

         /* finally, update the checksum */
         newpip->ip_chksum = IPXSUM;
 82406fc:	e0bffc17 	ldw	r2,-16(fp)
 8240700:	1000028d 	sth	zero,10(r2)
         newpip->ip_chksum = ~cksum(newpip, (iphlen/2));
 8240704:	e0bff783 	ldbu	r2,-34(fp)
 8240708:	1004d07a 	srli	r2,r2,1
 824070c:	10803fcc 	andi	r2,r2,255
 8240710:	100b883a 	mov	r5,r2
 8240714:	e13ffc17 	ldw	r4,-16(fp)
 8240718:	82286f00 	call	82286f0 <cksum>
 824071c:	0084303a 	nor	r2,zero,r2
 8240720:	1007883a 	mov	r3,r2
 8240724:	e0bffc17 	ldw	r2,-16(fp)
 8240728:	10c0028d 	sth	r3,10(r2)

         ip_mib.ipFragCreates++;
 824072c:	008209b4 	movhi	r2,2086
 8240730:	10ba6a04 	addi	r2,r2,-5720
 8240734:	10801217 	ldw	r2,72(r2)
 8240738:	10c00044 	addi	r3,r2,1
 824073c:	008209b4 	movhi	r2,2086
 8240740:	10ba6a04 	addi	r2,r2,-5720
 8240744:	10c01215 	stw	r3,72(r2)

         /* we're done; hand the packet off to ip2mac () */
         e = ip2mac (newpkt, firsthop);
 8240748:	e17fff17 	ldw	r5,-4(fp)
 824074c:	e13ffb17 	ldw	r4,-20(fp)
 8240750:	82266340 	call	8226634 <ip2mac>
 8240754:	e0bffd15 	stw	r2,-12(fp)
         if (e < 0)
 8240758:	e0bffd17 	ldw	r2,-12(fp)
 824075c:	10000f0e 	bge	r2,zero,824079c <ip_fragment+0x560>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8240760:	01000084 	movi	r4,2
 8240764:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
            pk_free(p);
 8240768:	e13ffe17 	ldw	r4,-8(fp)
 824076c:	822cbbc0 	call	822cbbc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240770:	01000084 	movi	r4,2
 8240774:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 8240778:	008209b4 	movhi	r2,2086
 824077c:	10ba6a04 	addi	r2,r2,-5720
 8240780:	10801117 	ldw	r2,68(r2)
 8240784:	10c00044 	addi	r3,r2,1
 8240788:	008209b4 	movhi	r2,2086
 824078c:	10ba6a04 	addi	r2,r2,-5720
 8240790:	10c01115 	stw	r3,68(r2)
            return e;
 8240794:	e0bffd17 	ldw	r2,-12(fp)
 8240798:	00001406 	br	82407ec <ip_fragment+0x5b0>
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 824079c:	e0bff38b 	ldhu	r2,-50(fp)
 82407a0:	10800044 	addi	r2,r2,1
 82407a4:	e0bff38d 	sth	r2,-50(fp)
 82407a8:	e0fff38b 	ldhu	r3,-50(fp)
 82407ac:	e0bff30b 	ldhu	r2,-52(fp)
 82407b0:	18bf3e36 	bltu	r3,r2,82404ac <ip_fragment+0x270>

   } /* end FOR (all child fragments) */

   /* free the parent buffer since all of the data from it have been copied 
    * out into the child fragments */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 82407b4:	01000084 	movi	r4,2
 82407b8:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   pk_free(p);
 82407bc:	e13ffe17 	ldw	r4,-8(fp)
 82407c0:	822cbbc0 	call	822cbbc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82407c4:	01000084 	movi	r4,2
 82407c8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 82407cc:	008209b4 	movhi	r2,2086
 82407d0:	10ba6a04 	addi	r2,r2,-5720
 82407d4:	10801017 	ldw	r2,64(r2)
 82407d8:	10c00044 	addi	r3,r2,1
 82407dc:	008209b4 	movhi	r2,2086
 82407e0:	10ba6a04 	addi	r2,r2,-5720
 82407e4:	10c01015 	stw	r3,64(r2)

   return 0;
 82407e8:	0005883a 	mov	r2,zero
}
 82407ec:	e037883a 	mov	sp,fp
 82407f0:	dfc00117 	ldw	ra,4(sp)
 82407f4:	df000017 	ldw	fp,0(sp)
 82407f8:	dec00204 	addi	sp,sp,8
 82407fc:	f800283a 	ret

08240800 <ip_mymach>:
 * certain foreign host. 
 */

ip_addr
ip_mymach(ip_addr host)
{
 8240800:	defffa04 	addi	sp,sp,-24
 8240804:	dfc00515 	stw	ra,20(sp)
 8240808:	df000415 	stw	fp,16(sp)
 824080c:	df000404 	addi	fp,sp,16
 8240810:	e13fff15 	stw	r4,-4(fp)

#ifndef MULTI_HOMED /* single static interface */
   USE_ARG(host);
   return(nets[0]->n_ipaddr);   /* always use address from only net */
#else   /* MULTI_HOMED */
   tnet = iproute(host, &temp);
 8240814:	e0bffe04 	addi	r2,fp,-8
 8240818:	100b883a 	mov	r5,r2
 824081c:	e13fff17 	ldw	r4,-4(fp)
 8240820:	8240b4c0 	call	8240b4c <iproute>
 8240824:	e0bffd15 	stw	r2,-12(fp)
   if (tnet == 0)
 8240828:	e0bffd17 	ldw	r2,-12(fp)
 824082c:	1000161e 	bne	r2,zero,8240888 <ip_mymach+0x88>
   {
#ifdef   NPDEBUG
      if (NDEBUG & (PROTERR|INFOMSG))
 8240830:	d0a08317 	ldw	r2,-32244(gp)
 8240834:	1080050c 	andi	r2,r2,20
 8240838:	10001126 	beq	r2,zero,8240880 <ip_mymach+0x80>
         dprintf("IP: Couldn't route to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824083c:	e0bfff17 	ldw	r2,-4(fp)
 8240840:	10c03fcc 	andi	r3,r2,255
 8240844:	e0bfff17 	ldw	r2,-4(fp)
 8240848:	1004d23a 	srli	r2,r2,8
 824084c:	11003fcc 	andi	r4,r2,255
 8240850:	e0bfff17 	ldw	r2,-4(fp)
 8240854:	1004d43a 	srli	r2,r2,16
 8240858:	11403fcc 	andi	r5,r2,255
 824085c:	e0bfff17 	ldw	r2,-4(fp)
 8240860:	1004d63a 	srli	r2,r2,24
 8240864:	d8800015 	stw	r2,0(sp)
 8240868:	280f883a 	mov	r7,r5
 824086c:	200d883a 	mov	r6,r4
 8240870:	180b883a 	mov	r5,r3
 8240874:	01020974 	movhi	r4,2085
 8240878:	21049b04 	addi	r4,r4,4716
 824087c:	820331c0 	call	820331c <printf>
#endif   /* NPDEBUG */
      return 0L;
 8240880:	0005883a 	mov	r2,zero
 8240884:	00000206 	br	8240890 <ip_mymach+0x90>
   }
   return tnet->n_ipaddr;
 8240888:	e0bffd17 	ldw	r2,-12(fp)
 824088c:	10800a17 	ldw	r2,40(r2)
#endif /* MULTI_HOMED */
}
 8240890:	e037883a 	mov	sp,fp
 8240894:	dfc00117 	ldw	ra,4(sp)
 8240898:	df000017 	ldw	fp,0(sp)
 824089c:	dec00204 	addi	sp,sp,8
 82408a0:	f800283a 	ret

082408a4 <ip_dump>:
 * RETURNS: void
 */

void
ip_dump(PACKET p)
{
 82408a4:	defff704 	addi	sp,sp,-36
 82408a8:	dfc00815 	stw	ra,32(sp)
 82408ac:	df000715 	stw	fp,28(sp)
 82408b0:	df000704 	addi	fp,sp,28
 82408b4:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;
   unsigned char * cp;
   unsigned short xsum, osum;

   pip = ip_head(p);
 82408b8:	e0bfff17 	ldw	r2,-4(fp)
 82408bc:	10800317 	ldw	r2,12(r2)
 82408c0:	e0bffc15 	stw	r2,-16(fp)
   osum = pip->ip_chksum;
 82408c4:	e0bffc17 	ldw	r2,-16(fp)
 82408c8:	1080028b 	ldhu	r2,10(r2)
 82408cc:	e0bffd0d 	sth	r2,-12(fp)
   pip->ip_chksum = 0;
 82408d0:	e0bffc17 	ldw	r2,-16(fp)
 82408d4:	1000028d 	sth	zero,10(r2)
   xsum = ~cksum(pip, ip_hlen(pip) >> 1);
 82408d8:	e0bffc17 	ldw	r2,-16(fp)
 82408dc:	10800003 	ldbu	r2,0(r2)
 82408e0:	10803fcc 	andi	r2,r2,255
 82408e4:	108003cc 	andi	r2,r2,15
 82408e8:	1085883a 	add	r2,r2,r2
 82408ec:	1085883a 	add	r2,r2,r2
 82408f0:	1005d07a 	srai	r2,r2,1
 82408f4:	100b883a 	mov	r5,r2
 82408f8:	e13ffc17 	ldw	r4,-16(fp)
 82408fc:	82286f00 	call	82286f0 <cksum>
 8240900:	0084303a 	nor	r2,zero,r2
 8240904:	e0bffd8d 	sth	r2,-10(fp)

   if (osum != xsum)          /* trap here if checksum is wrong */
 8240908:	e0fffd0b 	ldhu	r3,-12(fp)
 824090c:	e0bffd8b 	ldhu	r2,-10(fp)
 8240910:	18800126 	beq	r3,r2,8240918 <ip_dump+0x74>
   {
      dtrap();
 8240914:	822d4140 	call	822d414 <dtrap>
   /* dtrap() is fatal in the default Windows implementation, so
    * we comment it out */
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
 8240918:	01420974 	movhi	r5,2085
 824091c:	2944a404 	addi	r5,r5,4752
 8240920:	0009883a 	mov	r4,zero
 8240924:	8228d040 	call	8228d04 <ns_printf>
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
 8240928:	e0bffc17 	ldw	r2,-16(fp)
 824092c:	e0bffe15 	stw	r2,-8(fp)
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 8240930:	e0bffe17 	ldw	r2,-8(fp)
 8240934:	10800003 	ldbu	r2,0(r2)
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240938:	11403fcc 	andi	r5,r2,255
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 824093c:	e0bffe17 	ldw	r2,-8(fp)
 8240940:	10800044 	addi	r2,r2,1
 8240944:	10800003 	ldbu	r2,0(r2)
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240948:	11803fcc 	andi	r6,r2,255
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 824094c:	e0bffc17 	ldw	r2,-16(fp)
 8240950:	1080008b 	ldhu	r2,2(r2)
 8240954:	10bfffcc 	andi	r2,r2,65535
 8240958:	1004d23a 	srli	r2,r2,8
 824095c:	10bfffcc 	andi	r2,r2,65535
 8240960:	10c03fcc 	andi	r3,r2,255
 8240964:	e0bffc17 	ldw	r2,-16(fp)
 8240968:	1080008b 	ldhu	r2,2(r2)
 824096c:	10bfffcc 	andi	r2,r2,65535
 8240970:	1004923a 	slli	r2,r2,8
 8240974:	10bfffcc 	andi	r2,r2,65535
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 8240978:	1884b03a 	or	r2,r3,r2
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 824097c:	e0fffc17 	ldw	r3,-16(fp)
 8240980:	18c0010b 	ldhu	r3,4(r3)
 8240984:	18ffffcc 	andi	r3,r3,65535
 8240988:	1806d23a 	srli	r3,r3,8
 824098c:	18ffffcc 	andi	r3,r3,65535
 8240990:	19003fcc 	andi	r4,r3,255
 8240994:	e0fffc17 	ldw	r3,-16(fp)
 8240998:	18c0010b 	ldhu	r3,4(r3)
 824099c:	18ffffcc 	andi	r3,r3,65535
 82409a0:	1806923a 	slli	r3,r3,8
 82409a4:	18ffffcc 	andi	r3,r3,65535
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 82409a8:	20c6b03a 	or	r3,r4,r3
 82409ac:	d8c00115 	stw	r3,4(sp)
 82409b0:	d8800015 	stw	r2,0(sp)
 82409b4:	300f883a 	mov	r7,r6
 82409b8:	280d883a 	mov	r6,r5
 82409bc:	01420974 	movhi	r5,2085
 82409c0:	2944a904 	addi	r5,r5,4772
 82409c4:	0009883a 	mov	r4,zero
 82409c8:	8228d040 	call	8228d04 <ns_printf>
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 82409cc:	e0bffe17 	ldw	r2,-8(fp)
 82409d0:	10800184 	addi	r2,r2,6
 82409d4:	1080000b 	ldhu	r2,0(r2)
 82409d8:	10bfffcc 	andi	r2,r2,65535
 82409dc:	1004d23a 	srli	r2,r2,8
 82409e0:	10bfffcc 	andi	r2,r2,65535
 82409e4:	10c03fcc 	andi	r3,r2,255
 82409e8:	e0bffe17 	ldw	r2,-8(fp)
 82409ec:	10800184 	addi	r2,r2,6
 82409f0:	1080000b 	ldhu	r2,0(r2)
 82409f4:	10bfffcc 	andi	r2,r2,65535
 82409f8:	1004923a 	slli	r2,r2,8
 82409fc:	10bfffcc 	andi	r2,r2,65535

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240a00:	188cb03a 	or	r6,r3,r2
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 8240a04:	e0bffc17 	ldw	r2,-16(fp)
 8240a08:	10800203 	ldbu	r2,8(r2)

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240a0c:	11c03fcc 	andi	r7,r2,255
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 8240a10:	e0bffc17 	ldw	r2,-16(fp)
 8240a14:	10800243 	ldbu	r2,9(r2)

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240a18:	10c03fcc 	andi	r3,r2,255
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
 8240a1c:	e0bffd0b 	ldhu	r2,-12(fp)
 8240a20:	1004d23a 	srli	r2,r2,8
 8240a24:	10bfffcc 	andi	r2,r2,65535
 8240a28:	11003fcc 	andi	r4,r2,255
 8240a2c:	e0bffd0b 	ldhu	r2,-12(fp)
 8240a30:	1004923a 	slli	r2,r2,8
 8240a34:	10bfffcc 	andi	r2,r2,65535

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 8240a38:	2088b03a 	or	r4,r4,r2
 8240a3c:	e17ffd0b 	ldhu	r5,-12(fp)
 8240a40:	e0bffd8b 	ldhu	r2,-10(fp)
 8240a44:	2880031e 	bne	r5,r2,8240a54 <ip_dump+0x1b0>
 8240a48:	00820974 	movhi	r2,2085
 8240a4c:	1084b504 	addi	r2,r2,4820
 8240a50:	00000206 	br	8240a5c <ip_dump+0x1b8>
 8240a54:	00820974 	movhi	r2,2085
 8240a58:	1084b604 	addi	r2,r2,4824
 8240a5c:	d8800215 	stw	r2,8(sp)
 8240a60:	d9000115 	stw	r4,4(sp)
 8240a64:	d8c00015 	stw	r3,0(sp)
 8240a68:	01420974 	movhi	r5,2085
 8240a6c:	2944b704 	addi	r5,r5,4828
 8240a70:	0009883a 	mov	r4,zero
 8240a74:	8228d040 	call	8228d04 <ns_printf>
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
   ns_printf(NULL ,"src: %u.%u.%u.%u  ", PUSH_IPADDR(pip->ip_src));
 8240a78:	e0bffc17 	ldw	r2,-16(fp)
 8240a7c:	10800317 	ldw	r2,12(r2)
 8240a80:	11003fcc 	andi	r4,r2,255
 8240a84:	e0bffc17 	ldw	r2,-16(fp)
 8240a88:	10800317 	ldw	r2,12(r2)
 8240a8c:	1004d23a 	srli	r2,r2,8
 8240a90:	11403fcc 	andi	r5,r2,255
 8240a94:	e0bffc17 	ldw	r2,-16(fp)
 8240a98:	10800317 	ldw	r2,12(r2)
 8240a9c:	1004d43a 	srli	r2,r2,16
 8240aa0:	10803fcc 	andi	r2,r2,255
 8240aa4:	e0fffc17 	ldw	r3,-16(fp)
 8240aa8:	18c00317 	ldw	r3,12(r3)
 8240aac:	1806d63a 	srli	r3,r3,24
 8240ab0:	d8c00115 	stw	r3,4(sp)
 8240ab4:	d8800015 	stw	r2,0(sp)
 8240ab8:	280f883a 	mov	r7,r5
 8240abc:	200d883a 	mov	r6,r4
 8240ac0:	01420974 	movhi	r5,2085
 8240ac4:	2944c704 	addi	r5,r5,4892
 8240ac8:	0009883a 	mov	r4,zero
 8240acc:	8228d040 	call	8228d04 <ns_printf>
   ns_printf(NULL ,"dest: %u.%u.%u.%u\n", PUSH_IPADDR(pip->ip_dest));
 8240ad0:	e0bffc17 	ldw	r2,-16(fp)
 8240ad4:	10800417 	ldw	r2,16(r2)
 8240ad8:	11003fcc 	andi	r4,r2,255
 8240adc:	e0bffc17 	ldw	r2,-16(fp)
 8240ae0:	10800417 	ldw	r2,16(r2)
 8240ae4:	1004d23a 	srli	r2,r2,8
 8240ae8:	11403fcc 	andi	r5,r2,255
 8240aec:	e0bffc17 	ldw	r2,-16(fp)
 8240af0:	10800417 	ldw	r2,16(r2)
 8240af4:	1004d43a 	srli	r2,r2,16
 8240af8:	10803fcc 	andi	r2,r2,255
 8240afc:	e0fffc17 	ldw	r3,-16(fp)
 8240b00:	18c00417 	ldw	r3,16(r3)
 8240b04:	1806d63a 	srli	r3,r3,24
 8240b08:	d8c00115 	stw	r3,4(sp)
 8240b0c:	d8800015 	stw	r2,0(sp)
 8240b10:	280f883a 	mov	r7,r5
 8240b14:	200d883a 	mov	r6,r4
 8240b18:	01420974 	movhi	r5,2085
 8240b1c:	2944cc04 	addi	r5,r5,4912
 8240b20:	0009883a 	mov	r4,zero
 8240b24:	8228d040 	call	8228d04 <ns_printf>

   pip->ip_chksum = osum;     /* fix what we clobbered */
 8240b28:	e0bffc17 	ldw	r2,-16(fp)
 8240b2c:	e0fffd0b 	ldhu	r3,-12(fp)
 8240b30:	10c0028d 	sth	r3,10(r2)
}
 8240b34:	0001883a 	nop
 8240b38:	e037883a 	mov	sp,fp
 8240b3c:	dfc00117 	ldw	ra,4(sp)
 8240b40:	df000017 	ldw	fp,0(sp)
 8240b44:	dec00204 	addi	sp,sp,8
 8240b48:	f800283a 	ret

08240b4c <iproute>:
 * RETURNS: Returns NULL when unable to route, else returns a NET pointer.
 */

NET
iproute(ip_addr host, ip_addr * hop1)
{
 8240b4c:	defff804 	addi	sp,sp,-32
 8240b50:	dfc00715 	stw	ra,28(sp)
 8240b54:	df000615 	stw	fp,24(sp)
 8240b58:	df000604 	addi	fp,sp,24
 8240b5c:	e13ffe15 	stw	r4,-8(fp)
 8240b60:	e17fff15 	stw	r5,-4(fp)
   NET      ifp;
#ifdef IP_ROUTING
   RTMIB    rtp;
#endif   /* IP_ROUTING */

   if (host == 0L)      /* Sanity check parameter. */
 8240b64:	e0bffe17 	ldw	r2,-8(fp)
 8240b68:	1000021e 	bne	r2,zero,8240b74 <iproute+0x28>
      return NULL;
 8240b6c:	0005883a 	mov	r2,zero
 8240b70:	00006706 	br	8240d10 <iproute+0x1c4>
    * stack has been initialized (tk_yield() gets called out of the 
    * dialer code as part of PPP initialization), one symptom of 
    * which is the routing table not being present yet. if this 
    * happens, quit. 
    */
   if (rt_mib == NULL)
 8240b74:	d0a0c617 	ldw	r2,-31976(gp)
 8240b78:	1000021e 	bne	r2,zero,8240b84 <iproute+0x38>
      return NULL;
 8240b7c:	0005883a 	mov	r2,zero
 8240b80:	00006306 	br	8240d10 <iproute+0x1c4>
#endif   /* BTREE_ROUTING */

   /* see if the host matches the cached route */
   if (cachedRoute)     /* don't test this if route is null  */
 8240b84:	d0a0d017 	ldw	r2,-31936(gp)
 8240b88:	10000e26 	beq	r2,zero,8240bc4 <iproute+0x78>
   {
      if (cachedRoute->ipRouteDest == host)    /* exact match */
 8240b8c:	d0a0d017 	ldw	r2,-31936(gp)
 8240b90:	10c00017 	ldw	r3,0(r2)
 8240b94:	e0bffe17 	ldw	r2,-8(fp)
 8240b98:	18800a1e 	bne	r3,r2,8240bc4 <iproute+0x78>
      {
         *hop1 = cachedRoute->ipRouteNextHop;   /* fill in nexthop IP addr */
 8240b9c:	d0a0d017 	ldw	r2,-31936(gp)
 8240ba0:	10c00617 	ldw	r3,24(r2)
 8240ba4:	e0bfff17 	ldw	r2,-4(fp)
 8240ba8:	10c00015 	stw	r3,0(r2)
         cachedRoute->ipRouteAge = cticks;      /* timestamp route entry */
 8240bac:	d0a0d017 	ldw	r2,-31936(gp)
 8240bb0:	d0e0a817 	ldw	r3,-32096(gp)
 8240bb4:	10c00915 	stw	r3,36(r2)
         return(cachedRoute->ifp); /* net to send on */
 8240bb8:	d0a0d017 	ldw	r2,-31936(gp)
 8240bbc:	10800e17 	ldw	r2,56(r2)
 8240bc0:	00005306 	br	8240d10 <iproute+0x1c4>
      }
   }

   rtp = rt_lookup(host);
 8240bc4:	e13ffe17 	ldw	r4,-8(fp)
 8240bc8:	824402c0 	call	824402c <rt_lookup>
 8240bcc:	e0bffd15 	stw	r2,-12(fp)
   if(rtp)
 8240bd0:	e0bffd17 	ldw	r2,-12(fp)
 8240bd4:	10000926 	beq	r2,zero,8240bfc <iproute+0xb0>
   {
      cachedRoute = rtp;
 8240bd8:	e0bffd17 	ldw	r2,-12(fp)
 8240bdc:	d0a0d015 	stw	r2,-31936(gp)
      *hop1 = rtp->ipRouteNextHop;  /* fill in IP dest (next hop) */
 8240be0:	e0bffd17 	ldw	r2,-12(fp)
 8240be4:	10c00617 	ldw	r3,24(r2)
 8240be8:	e0bfff17 	ldw	r2,-4(fp)
 8240bec:	10c00015 	stw	r3,0(r2)
      return(rtp->ifp);             /* return pointer to net */
 8240bf0:	e0bffd17 	ldw	r2,-12(fp)
 8240bf4:	10800e17 	ldw	r2,56(r2)
 8240bf8:	00004506 	br	8240d10 <iproute+0x1c4>
    * the initial state for the for loop that iterates through the
    * list), but only build the iterator for multi-homed systems
    * because single-homed systems are often memory-limited systems as
    * well.  
    */
   ifp = (NET)(netlist.q_head);
 8240bfc:	008209b4 	movhi	r2,2086
 8240c00:	10ba6504 	addi	r2,r2,-5740
 8240c04:	10800017 	ldw	r2,0(r2)
 8240c08:	e0bffc15 	stw	r2,-16(fp)
   i = 0;
 8240c0c:	e03ffb15 	stw	zero,-20(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 8240c10:	00002406 	br	8240ca4 <iproute+0x158>
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 8240c14:	e0bffc17 	ldw	r2,-16(fp)
 8240c18:	10800c17 	ldw	r2,48(r2)
 8240c1c:	10001b26 	beq	r2,zero,8240c8c <iproute+0x140>
         (ifp->n_ipaddr != 0) && 
 8240c20:	e0bffc17 	ldw	r2,-16(fp)
 8240c24:	10800a17 	ldw	r2,40(r2)
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 8240c28:	10001826 	beq	r2,zero,8240c8c <iproute+0x140>
         (ifp->n_ipaddr != 0) && 
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
 8240c2c:	e0bffc17 	ldw	r2,-16(fp)
 8240c30:	10c00a17 	ldw	r3,40(r2)
 8240c34:	e0bffe17 	ldw	r2,-8(fp)
 8240c38:	1886f03a 	xor	r3,r3,r2
 8240c3c:	e0bffc17 	ldw	r2,-16(fp)
 8240c40:	10800c17 	ldw	r2,48(r2)
 8240c44:	1884703a 	and	r2,r3,r2
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
         (ifp->n_ipaddr != 0) && 
 8240c48:	1000101e 	bne	r2,zero,8240c8c <iproute+0x140>
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
      {
#ifdef IP_ROUTING
         /* make a cached Route entry for next time */
         cachedRoute = add_route(host, 0xFFFFFFFF, host, i, IPRP_OTHER);
 8240c4c:	00800044 	movi	r2,1
 8240c50:	d8800015 	stw	r2,0(sp)
 8240c54:	e1fffb17 	ldw	r7,-20(fp)
 8240c58:	e1bffe17 	ldw	r6,-8(fp)
 8240c5c:	017fffc4 	movi	r5,-1
 8240c60:	e13ffe17 	ldw	r4,-8(fp)
 8240c64:	82441800 	call	8244180 <add_route>
 8240c68:	d0a0d015 	stw	r2,-31936(gp)
#ifdef NPDEBUG
         if (cachedRoute == NULL)
 8240c6c:	d0a0d017 	ldw	r2,-31936(gp)
 8240c70:	1000011e 	bne	r2,zero,8240c78 <iproute+0x12c>
            dtrap();
 8240c74:	822d4140 	call	822d414 <dtrap>
#endif   /* NPDEBUG */
#endif   /* IP_ROUTING */
         *hop1 = host;
 8240c78:	e0bfff17 	ldw	r2,-4(fp)
 8240c7c:	e0fffe17 	ldw	r3,-8(fp)
 8240c80:	10c00015 	stw	r3,0(r2)
         return ifp;
 8240c84:	e0bffc17 	ldw	r2,-16(fp)
 8240c88:	00002106 	br	8240d10 <iproute+0x1c4>
    * well.  
    */
   ifp = (NET)(netlist.q_head);
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 8240c8c:	e0bffc17 	ldw	r2,-16(fp)
 8240c90:	10800017 	ldw	r2,0(r2)
 8240c94:	e0bffc15 	stw	r2,-16(fp)
 8240c98:	e0bffb17 	ldw	r2,-20(fp)
 8240c9c:	10800044 	addi	r2,r2,1
 8240ca0:	e0bffb15 	stw	r2,-20(fp)
 8240ca4:	e0bffc17 	ldw	r2,-16(fp)
 8240ca8:	103fda1e 	bne	r2,zero,8240c14 <iproute+0xc8>
#endif   /* IP_LOOPBACK */

   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
 8240cac:	008209b4 	movhi	r2,2086
 8240cb0:	10ba6504 	addi	r2,r2,-5740
 8240cb4:	10800017 	ldw	r2,0(r2)
 8240cb8:	e0bffc15 	stw	r2,-16(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 8240cbc:	00000c06 	br	8240cf0 <iproute+0x1a4>
#endif   /* MULTI_HOMED */
   {
      /* Check if this net has a gateway */
      if(ifp->n_defgw)
 8240cc0:	e0bffc17 	ldw	r2,-16(fp)
 8240cc4:	10800d17 	ldw	r2,52(r2)
 8240cc8:	10000626 	beq	r2,zero,8240ce4 <iproute+0x198>
      {
         *hop1 = ifp->n_defgw;
 8240ccc:	e0bffc17 	ldw	r2,-16(fp)
 8240cd0:	10c00d17 	ldw	r3,52(r2)
 8240cd4:	e0bfff17 	ldw	r2,-4(fp)
 8240cd8:	10c00015 	stw	r3,0(r2)
         return ifp;
 8240cdc:	e0bffc17 	ldw	r2,-16(fp)
 8240ce0:	00000b06 	br	8240d10 <iproute+0x1c4>
   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 8240ce4:	e0bffc17 	ldw	r2,-16(fp)
 8240ce8:	10800017 	ldw	r2,0(r2)
 8240cec:	e0bffc15 	stw	r2,-16(fp)
 8240cf0:	e0bffc17 	ldw	r2,-16(fp)
 8240cf4:	103ff21e 	bne	r2,zero,8240cc0 <iproute+0x174>
   /* if no gateway is set, then change the first hop address to the 
    * host we're trying to route to. this is just a kluge to make 
    * this work with arp routing. otherwise, we would try to return 
    * some sort of error indication. 
    */
   *hop1 = host;
 8240cf8:	e0bfff17 	ldw	r2,-4(fp)
 8240cfc:	e0fffe17 	ldw	r3,-8(fp)
 8240d00:	10c00015 	stw	r3,0(r2)
   return((NET)(netlist.q_head));
 8240d04:	008209b4 	movhi	r2,2086
 8240d08:	10ba6504 	addi	r2,r2,-5740
 8240d0c:	10800017 	ldw	r2,0(r2)
#endif   /* STRICT_SUBNETTING */
}
 8240d10:	e037883a 	mov	sp,fp
 8240d14:	dfc00117 	ldw	ra,4(sp)
 8240d18:	df000017 	ldw	fp,0(sp)
 8240d1c:	dec00204 	addi	sp,sp,8
 8240d20:	f800283a 	ret

08240d24 <ip_copypkt>:
 * RETURNS: a pointer to the new copy of the packet,
 *          or NULL if no packet buffer could be allocated
 */
PACKET
ip_copypkt(PACKET p)
{
 8240d24:	defffb04 	addi	sp,sp,-20
 8240d28:	dfc00415 	stw	ra,16(sp)
 8240d2c:	df000315 	stw	fp,12(sp)
 8240d30:	df000304 	addi	fp,sp,12
 8240d34:	e13fff15 	stw	r4,-4(fp)
   int len;

   /* figure out how much we need to copy from the packet, 
    * and allocate a new buffer to hold it 
    */
   len = p->nb_plen + (p->nb_prot - p->nb_buff);
 8240d38:	e0bfff17 	ldw	r2,-4(fp)
 8240d3c:	10800417 	ldw	r2,16(r2)
 8240d40:	e0ffff17 	ldw	r3,-4(fp)
 8240d44:	18c00317 	ldw	r3,12(r3)
 8240d48:	1809883a 	mov	r4,r3
 8240d4c:	e0ffff17 	ldw	r3,-4(fp)
 8240d50:	18c00117 	ldw	r3,4(r3)
 8240d54:	20c7c83a 	sub	r3,r4,r3
 8240d58:	10c5883a 	add	r2,r2,r3
 8240d5c:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8240d60:	01000084 	movi	r4,2
 8240d64:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   np = pk_alloc(len);
 8240d68:	e0bffd17 	ldw	r2,-12(fp)
 8240d6c:	1009883a 	mov	r4,r2
 8240d70:	822c86c0 	call	822c86c <pk_alloc>
 8240d74:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8240d78:	01000084 	movi	r4,2
 8240d7c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   if (np == NULL)
 8240d80:	e0bffe17 	ldw	r2,-8(fp)
 8240d84:	1000061e 	bne	r2,zero,8240da0 <ip_copypkt+0x7c>
   {
#ifdef NPDEBUG
      dprintf("ip_copypkt(): unable to obtain packet (len %d)\n", len);
 8240d88:	e17ffd17 	ldw	r5,-12(fp)
 8240d8c:	01020974 	movhi	r4,2085
 8240d90:	2104d104 	addi	r4,r4,4932
 8240d94:	820331c0 	call	820331c <printf>
#endif
      return NULL;
 8240d98:	0005883a 	mov	r2,zero
 8240d9c:	00002906 	br	8240e44 <ip_copypkt+0x120>
   }

   /* copy packet data into new buffer */
   MEMCPY(np->nb_buff, p->nb_buff, len);
 8240da0:	e0bffe17 	ldw	r2,-8(fp)
 8240da4:	10c00117 	ldw	r3,4(r2)
 8240da8:	e0bfff17 	ldw	r2,-4(fp)
 8240dac:	10800117 	ldw	r2,4(r2)
 8240db0:	e13ffd17 	ldw	r4,-12(fp)
 8240db4:	200d883a 	mov	r6,r4
 8240db8:	100b883a 	mov	r5,r2
 8240dbc:	1809883a 	mov	r4,r3
 8240dc0:	8202e8c0 	call	8202e8c <memcpy>

   /* copy relevant packet fields */
   np->nb_prot = np->nb_buff + (p->nb_prot - p->nb_buff);
 8240dc4:	e0bffe17 	ldw	r2,-8(fp)
 8240dc8:	10800117 	ldw	r2,4(r2)
 8240dcc:	e0ffff17 	ldw	r3,-4(fp)
 8240dd0:	18c00317 	ldw	r3,12(r3)
 8240dd4:	1809883a 	mov	r4,r3
 8240dd8:	e0ffff17 	ldw	r3,-4(fp)
 8240ddc:	18c00117 	ldw	r3,4(r3)
 8240de0:	20c7c83a 	sub	r3,r4,r3
 8240de4:	10c7883a 	add	r3,r2,r3
 8240de8:	e0bffe17 	ldw	r2,-8(fp)
 8240dec:	10c00315 	stw	r3,12(r2)
   np->nb_plen = p->nb_plen;
 8240df0:	e0bfff17 	ldw	r2,-4(fp)
 8240df4:	10c00417 	ldw	r3,16(r2)
 8240df8:	e0bffe17 	ldw	r2,-8(fp)
 8240dfc:	10c00415 	stw	r3,16(r2)
   np->net = p->net;
 8240e00:	e0bfff17 	ldw	r2,-4(fp)
 8240e04:	10c00617 	ldw	r3,24(r2)
 8240e08:	e0bffe17 	ldw	r2,-8(fp)
 8240e0c:	10c00615 	stw	r3,24(r2)
   np->fhost = p->fhost;
 8240e10:	e0bfff17 	ldw	r2,-4(fp)
 8240e14:	10c00717 	ldw	r3,28(r2)
 8240e18:	e0bffe17 	ldw	r2,-8(fp)
 8240e1c:	10c00715 	stw	r3,28(r2)
   np->type = p->type;
 8240e20:	e0bfff17 	ldw	r2,-4(fp)
 8240e24:	10c0080b 	ldhu	r3,32(r2)
 8240e28:	e0bffe17 	ldw	r2,-8(fp)
 8240e2c:	10c0080d 	sth	r3,32(r2)
   np->nb_tstamp = p->nb_tstamp;
 8240e30:	e0bfff17 	ldw	r2,-4(fp)
 8240e34:	10c00517 	ldw	r3,20(r2)
 8240e38:	e0bffe17 	ldw	r2,-8(fp)
 8240e3c:	10c00515 	stw	r3,20(r2)

   /* return pointer to the copy */
   return np;
 8240e40:	e0bffe17 	ldw	r2,-8(fp)
}
 8240e44:	e037883a 	mov	sp,fp
 8240e48:	dfc00117 	ldw	ra,4(sp)
 8240e4c:	df000017 	ldw	fp,0(sp)
 8240e50:	dec00204 	addi	sp,sp,8
 8240e54:	f800283a 	ret

08240e58 <ip_reasm_match_frag_with_ire>:
packet being processed.  If no such entry is found, this function returns 
NULL.
*/

IREP ip_reasm_match_frag_with_ire (struct ip * pip)
{
 8240e58:	defffa04 	addi	sp,sp,-24
 8240e5c:	df000515 	stw	fp,20(sp)
 8240e60:	df000504 	addi	fp,sp,20
 8240e64:	e13fff15 	stw	r4,-4(fp)
   ip_addr dest;
   u_char prot;
   u_short id;
   IREP tmpp;
 
   src = pip->ip_src;
 8240e68:	e0bfff17 	ldw	r2,-4(fp)
 8240e6c:	10800317 	ldw	r2,12(r2)
 8240e70:	e0bffc15 	stw	r2,-16(fp)
   dest = pip->ip_dest;
 8240e74:	e0bfff17 	ldw	r2,-4(fp)
 8240e78:	10800417 	ldw	r2,16(r2)
 8240e7c:	e0bffd15 	stw	r2,-12(fp)
   prot = pip->ip_prot;
 8240e80:	e0bfff17 	ldw	r2,-4(fp)
 8240e84:	10800243 	ldbu	r2,9(r2)
 8240e88:	e0bffe05 	stb	r2,-8(fp)
   id = pip->ip_id;
 8240e8c:	e0bfff17 	ldw	r2,-4(fp)
 8240e90:	1080010b 	ldhu	r2,4(r2)
 8240e94:	e0bffe8d 	sth	r2,-6(fp)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8240e98:	d0a0c817 	ldw	r2,-31968(gp)
 8240e9c:	e0bffb15 	stw	r2,-20(fp)
 8240ea0:	00001706 	br	8240f00 <ip_reasm_match_frag_with_ire+0xa8>
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 8240ea4:	e0bffb17 	ldw	r2,-20(fp)
 8240ea8:	10c00117 	ldw	r3,4(r2)
 8240eac:	e0bffc17 	ldw	r2,-16(fp)
 8240eb0:	1880101e 	bne	r3,r2,8240ef4 <ip_reasm_match_frag_with_ire+0x9c>
 8240eb4:	e0bffb17 	ldw	r2,-20(fp)
 8240eb8:	10c00217 	ldw	r3,8(r2)
 8240ebc:	e0bffd17 	ldw	r2,-12(fp)
 8240ec0:	18800c1e 	bne	r3,r2,8240ef4 <ip_reasm_match_frag_with_ire+0x9c>
          (tmpp->prot == prot) && (tmpp->id == id))
 8240ec4:	e0bffb17 	ldw	r2,-20(fp)
 8240ec8:	10800383 	ldbu	r2,14(r2)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 8240ecc:	10c03fcc 	andi	r3,r2,255
 8240ed0:	e0bffe03 	ldbu	r2,-8(fp)
 8240ed4:	1880071e 	bne	r3,r2,8240ef4 <ip_reasm_match_frag_with_ire+0x9c>
          (tmpp->prot == prot) && (tmpp->id == id))
 8240ed8:	e0bffb17 	ldw	r2,-20(fp)
 8240edc:	1080030b 	ldhu	r2,12(r2)
 8240ee0:	10ffffcc 	andi	r3,r2,65535
 8240ee4:	e0bffe8b 	ldhu	r2,-6(fp)
 8240ee8:	1880021e 	bne	r3,r2,8240ef4 <ip_reasm_match_frag_with_ire+0x9c>
         {
         return tmpp; /* we've found a match */
 8240eec:	e0bffb17 	ldw	r2,-20(fp)
 8240ef0:	00000606 	br	8240f0c <ip_reasm_match_frag_with_ire+0xb4>
   prot = pip->ip_prot;
   id = pip->ip_id;

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8240ef4:	e0bffb17 	ldw	r2,-20(fp)
 8240ef8:	10800017 	ldw	r2,0(r2)
 8240efc:	e0bffb15 	stw	r2,-20(fp)
 8240f00:	e0bffb17 	ldw	r2,-20(fp)
 8240f04:	103fe71e 	bne	r2,zero,8240ea4 <ip_reasm_match_frag_with_ire+0x4c>
         return tmpp; /* we've found a match */
         }
      }

   /* no match found */
   return NULL;
 8240f08:	0005883a 	mov	r2,zero
}
 8240f0c:	e037883a 	mov	sp,fp
 8240f10:	df000017 	ldw	fp,0(sp)
 8240f14:	dec00104 	addi	sp,sp,4
 8240f18:	f800283a 	ret

08240f1c <ip_reasm_determine_type_of_frag>:
OUTPUT: One of the various IP_FRAGTYPE values (IP_CP, IP_FF, IP_MF, 
or IP_LF)
*/

IP_FRAGTYPE ip_reasm_determine_type_of_frag (struct ip * pip)
{
 8240f1c:	defffc04 	addi	sp,sp,-16
 8240f20:	df000315 	stw	fp,12(sp)
 8240f24:	df000304 	addi	fp,sp,12
 8240f28:	e13fff15 	stw	r4,-4(fp)
  u_short mf;
  u_short foff;
  IP_FRAGTYPE rc;

  mf = (((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF) >> 13);
 8240f2c:	e0bfff17 	ldw	r2,-4(fp)
 8240f30:	1080018b 	ldhu	r2,6(r2)
 8240f34:	10bfffcc 	andi	r2,r2,65535
 8240f38:	1004d23a 	srli	r2,r2,8
 8240f3c:	10bfffcc 	andi	r2,r2,65535
 8240f40:	10c03fcc 	andi	r3,r2,255
 8240f44:	e0bfff17 	ldw	r2,-4(fp)
 8240f48:	1080018b 	ldhu	r2,6(r2)
 8240f4c:	10bfffcc 	andi	r2,r2,65535
 8240f50:	1004923a 	slli	r2,r2,8
 8240f54:	10bfffcc 	andi	r2,r2,65535
 8240f58:	1884b03a 	or	r2,r3,r2
 8240f5c:	1088000c 	andi	r2,r2,8192
 8240f60:	1005d37a 	srai	r2,r2,13
 8240f64:	e0bffe0d 	sth	r2,-8(fp)
  foff = ((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF);
 8240f68:	e0bfff17 	ldw	r2,-4(fp)
 8240f6c:	1080018b 	ldhu	r2,6(r2)
 8240f70:	10bfffcc 	andi	r2,r2,65535
 8240f74:	1004d23a 	srli	r2,r2,8
 8240f78:	1007883a 	mov	r3,r2
 8240f7c:	e0bfff17 	ldw	r2,-4(fp)
 8240f80:	1080018b 	ldhu	r2,6(r2)
 8240f84:	10bfffcc 	andi	r2,r2,65535
 8240f88:	1004923a 	slli	r2,r2,8
 8240f8c:	1884b03a 	or	r2,r3,r2
 8240f90:	1087ffcc 	andi	r2,r2,8191
 8240f94:	e0bffe8d 	sth	r2,-6(fp)

  if (mf == 0)
 8240f98:	e0bffe0b 	ldhu	r2,-8(fp)
 8240f9c:	1000071e 	bne	r2,zero,8240fbc <ip_reasm_determine_type_of_frag+0xa0>
     {
     if (foff == 0) {rc = IP_CP;}
 8240fa0:	e0bffe8b 	ldhu	r2,-6(fp)
 8240fa4:	1000021e 	bne	r2,zero,8240fb0 <ip_reasm_determine_type_of_frag+0x94>
 8240fa8:	e03ffd15 	stw	zero,-12(fp)
 8240fac:	00000a06 	br	8240fd8 <ip_reasm_determine_type_of_frag+0xbc>
     else {rc = IP_LF;}
 8240fb0:	00800144 	movi	r2,5
 8240fb4:	e0bffd15 	stw	r2,-12(fp)
 8240fb8:	00000706 	br	8240fd8 <ip_reasm_determine_type_of_frag+0xbc>
     }
  else
     {
     if (foff == 0) {rc = IP_FF;}
 8240fbc:	e0bffe8b 	ldhu	r2,-6(fp)
 8240fc0:	1000031e 	bne	r2,zero,8240fd0 <ip_reasm_determine_type_of_frag+0xb4>
 8240fc4:	00800044 	movi	r2,1
 8240fc8:	e0bffd15 	stw	r2,-12(fp)
 8240fcc:	00000206 	br	8240fd8 <ip_reasm_determine_type_of_frag+0xbc>
     else {rc = IP_MF;}
 8240fd0:	008000c4 	movi	r2,3
 8240fd4:	e0bffd15 	stw	r2,-12(fp)
     }

  return rc;
 8240fd8:	e0bffd17 	ldw	r2,-12(fp)
}
 8240fdc:	e037883a 	mov	sp,fp
 8240fe0:	df000017 	ldw	fp,0(sp)
 8240fe4:	dec00104 	addi	sp,sp,4
 8240fe8:	f800283a 	ret

08240fec <ip_reasm_check_mem_useage>:
OUTPUT: ENP_RESOURCE, if the increment request can't be allowed; 
otherwise it returns IPREASM_OK.
*/

int ip_reasm_check_mem_useage (u_short increment)
{
 8240fec:	defffe04 	addi	sp,sp,-8
 8240ff0:	df000115 	stw	fp,4(sp)
 8240ff4:	df000104 	addi	fp,sp,4
 8240ff8:	2005883a 	mov	r2,r4
 8240ffc:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity check */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 8241000:	d0a0c717 	ldw	r2,-31972(gp)
 8241004:	00c001b4 	movhi	r3,6
 8241008:	1880072e 	bgeu	r3,r2,8241028 <ip_reasm_check_mem_useage+0x3c>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 824100c:	008209b4 	movhi	r2,2086
 8241010:	10ba7e04 	addi	r2,r2,-5640
 8241014:	10800217 	ldw	r2,8(r2)
 8241018:	10c00044 	addi	r3,r2,1
 824101c:	008209b4 	movhi	r2,2086
 8241020:	10ba7e04 	addi	r2,r2,-5640
 8241024:	10c00215 	stw	r3,8(r2)
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 8241028:	d0e0c717 	ldw	r3,-31972(gp)
 824102c:	008001b4 	movhi	r2,6
 8241030:	18800526 	beq	r3,r2,8241048 <ip_reasm_check_mem_useage+0x5c>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
 8241034:	e0ffff0b 	ldhu	r3,-4(fp)
 8241038:	d0a0c717 	ldw	r2,-31972(gp)
 824103c:	1885883a 	add	r2,r3,r2
      ++ire_stats.bad_max_mem;
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 8241040:	00c001b4 	movhi	r3,6
 8241044:	1880092e 	bgeu	r3,r2,824106c <ip_reasm_check_mem_useage+0x80>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
   {
      /* return an error indication */
      ++ire_stats.mem_check_fail;
 8241048:	008209b4 	movhi	r2,2086
 824104c:	10ba7e04 	addi	r2,r2,-5640
 8241050:	10800317 	ldw	r2,12(r2)
 8241054:	10c00044 	addi	r3,r2,1
 8241058:	008209b4 	movhi	r2,2086
 824105c:	10ba7e04 	addi	r2,r2,-5640
 8241060:	10c00315 	stw	r3,12(r2)
      return ENP_RESOURCE;
 8241064:	00bffa84 	movi	r2,-22
 8241068:	00000106 	br	8241070 <ip_reasm_check_mem_useage+0x84>
   }

   /* memory limits will not be exceeded with this increment */
   return IPREASM_OK;
 824106c:	0005883a 	mov	r2,zero
}
 8241070:	e037883a 	mov	sp,fp
 8241074:	df000017 	ldw	fp,0(sp)
 8241078:	dec00104 	addi	sp,sp,4
 824107c:	f800283a 	ret

08241080 <ip_reasm_incr_mem_useage>:
system exceeding the maximum limit or if the system has already exceeded 
the prespecified limit for memory useage; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_incr_mem_useage (u_short increment)
{
 8241080:	defffe04 	addi	sp,sp,-8
 8241084:	df000115 	stw	fp,4(sp)
 8241088:	df000104 	addi	fp,sp,4
 824108c:	2005883a 	mov	r2,r4
 8241090:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 8241094:	d0a0c717 	ldw	r2,-31972(gp)
 8241098:	00c001b4 	movhi	r3,6
 824109c:	1880092e 	bgeu	r3,r2,82410c4 <ip_reasm_incr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 82410a0:	008209b4 	movhi	r2,2086
 82410a4:	10ba7e04 	addi	r2,r2,-5640
 82410a8:	10800217 	ldw	r2,8(r2)
 82410ac:	10c00044 	addi	r3,r2,1
 82410b0:	008209b4 	movhi	r2,2086
 82410b4:	10ba7e04 	addi	r2,r2,-5640
 82410b8:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 82410bc:	00bffa84 	movi	r2,-22
 82410c0:	00001306 	br	8241110 <ip_reasm_incr_mem_useage+0x90>
   }
   if (ipr_curr_mem + increment > IP_REASM_MAX_MEM)
 82410c4:	e0ffff0b 	ldhu	r3,-4(fp)
 82410c8:	d0a0c717 	ldw	r2,-31972(gp)
 82410cc:	1885883a 	add	r2,r3,r2
 82410d0:	00c001b4 	movhi	r3,6
 82410d4:	1880092e 	bgeu	r3,r2,82410fc <ip_reasm_incr_mem_useage+0x7c>
   {
      /* this should never happen since caller should have 
       * checked prior to asking for the increment */
      ++ire_stats.mem_incr_fail;
 82410d8:	008209b4 	movhi	r2,2086
 82410dc:	10ba7e04 	addi	r2,r2,-5640
 82410e0:	10800417 	ldw	r2,16(r2)
 82410e4:	10c00044 	addi	r3,r2,1
 82410e8:	008209b4 	movhi	r2,2086
 82410ec:	10ba7e04 	addi	r2,r2,-5640
 82410f0:	10c00415 	stw	r3,16(r2)
      return ENP_RESOURCE;
 82410f4:	00bffa84 	movi	r2,-22
 82410f8:	00000506 	br	8241110 <ip_reasm_incr_mem_useage+0x90>
   }

   ipr_curr_mem += increment;
 82410fc:	e0ffff0b 	ldhu	r3,-4(fp)
 8241100:	d0a0c717 	ldw	r2,-31972(gp)
 8241104:	1885883a 	add	r2,r3,r2
 8241108:	d0a0c715 	stw	r2,-31972(gp)

   /* successfully incremented memory useage counter */
   return IPREASM_OK;
 824110c:	0005883a 	mov	r2,zero
}
 8241110:	e037883a 	mov	sp,fp
 8241114:	df000017 	ldw	fp,0(sp)
 8241118:	dec00104 	addi	sp,sp,4
 824111c:	f800283a 	ret

08241120 <ip_reasm_decr_mem_useage>:
exceeded the prespecified limit for memory useage; otherwise, it returns 
IPREASM_OK.
*/

int ip_reasm_decr_mem_useage (u_short decrement)
{
 8241120:	defffe04 	addi	sp,sp,-8
 8241124:	df000115 	stw	fp,4(sp)
 8241128:	df000104 	addi	fp,sp,4
 824112c:	2005883a 	mov	r2,r4
 8241130:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 8241134:	d0a0c717 	ldw	r2,-31972(gp)
 8241138:	00c001b4 	movhi	r3,6
 824113c:	1880092e 	bgeu	r3,r2,8241164 <ip_reasm_decr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 8241140:	008209b4 	movhi	r2,2086
 8241144:	10ba7e04 	addi	r2,r2,-5640
 8241148:	10800217 	ldw	r2,8(r2)
 824114c:	10c00044 	addi	r3,r2,1
 8241150:	008209b4 	movhi	r2,2086
 8241154:	10ba7e04 	addi	r2,r2,-5640
 8241158:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 824115c:	00bffa84 	movi	r2,-22
 8241160:	00001106 	br	82411a8 <ip_reasm_decr_mem_useage+0x88>
   }
   if (ipr_curr_mem < decrement)
 8241164:	e0bfff0b 	ldhu	r2,-4(fp)
 8241168:	d0e0c717 	ldw	r3,-31972(gp)
 824116c:	1880092e 	bgeu	r3,r2,8241194 <ip_reasm_decr_mem_useage+0x74>
   {
      /* this should never happen since the current memory useage
       * counter must always be greater than or at least equal to
       * the allocation that is being "returned" */
      ++ire_stats.mem_decr_fail;
 8241170:	008209b4 	movhi	r2,2086
 8241174:	10ba7e04 	addi	r2,r2,-5640
 8241178:	10800517 	ldw	r2,20(r2)
 824117c:	10c00044 	addi	r3,r2,1
 8241180:	008209b4 	movhi	r2,2086
 8241184:	10ba7e04 	addi	r2,r2,-5640
 8241188:	10c00515 	stw	r3,20(r2)
      return ENP_RESOURCE;
 824118c:	00bffa84 	movi	r2,-22
 8241190:	00000506 	br	82411a8 <ip_reasm_decr_mem_useage+0x88>
   }

   ipr_curr_mem -= decrement;
 8241194:	d0e0c717 	ldw	r3,-31972(gp)
 8241198:	e0bfff0b 	ldhu	r2,-4(fp)
 824119c:	1885c83a 	sub	r2,r3,r2
 82411a0:	d0a0c715 	stw	r2,-31972(gp)

   /* successfully decremented memory useage counter */
   return IPREASM_OK;
 82411a4:	0005883a 	mov	r2,zero
}
 82411a8:	e037883a 	mov	sp,fp
 82411ac:	df000017 	ldw	fp,0(sp)
 82411b0:	dec00104 	addi	sp,sp,4
 82411b4:	f800283a 	ret

082411b8 <ip_reasm_process_first_fragment>:
OUTPUT: ENP_RESOURCE if the memory check (in ip_reasm_check_mem_useage ()) 
or the allocation for an IRE fails; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_process_first_fragment (PACKET p)
{
 82411b8:	defff704 	addi	sp,sp,-36
 82411bc:	dfc00815 	stw	ra,32(sp)
 82411c0:	df000715 	stw	fp,28(sp)
 82411c4:	df000704 	addi	fp,sp,28
 82411c8:	e13fff15 	stw	r4,-4(fp)
   u_short total_len;
   int rc;

   /* this is a fragment from a hitherto unknown fragment stream; 
    * check for resource limits before accepting it */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (IRE)))) != IPREASM_OK)
 82411cc:	e0bfff17 	ldw	r2,-4(fp)
 82411d0:	10800217 	ldw	r2,8(r2)
 82411d4:	10802204 	addi	r2,r2,136
 82411d8:	10bfffcc 	andi	r2,r2,65535
 82411dc:	1009883a 	mov	r4,r2
 82411e0:	8240fec0 	call	8240fec <ip_reasm_check_mem_useage>
 82411e4:	e0bff915 	stw	r2,-28(fp)
 82411e8:	e0bff917 	ldw	r2,-28(fp)
 82411ec:	10000f26 	beq	r2,zero,824122c <ip_reasm_process_first_fragment+0x74>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 82411f0:	01000084 	movi	r4,2
 82411f4:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free (p);
 82411f8:	e13fff17 	ldw	r4,-4(fp)
 82411fc:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241200:	01000084 	movi	r4,2
 8241204:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 8241208:	008209b4 	movhi	r2,2086
 824120c:	10ba6a04 	addi	r2,r2,-5720
 8241210:	10800f17 	ldw	r2,60(r2)
 8241214:	10c00044 	addi	r3,r2,1
 8241218:	008209b4 	movhi	r2,2086
 824121c:	10ba6a04 	addi	r2,r2,-5720
 8241220:	10c00f15 	stw	r3,60(r2)
      return rc;
 8241224:	e0bff917 	ldw	r2,-28(fp)
 8241228:	00008c06 	br	824145c <ip_reasm_process_first_fragment+0x2a4>
   }

   /* we are ok wrt memory limits; since this is the first fragment, we need 
    * to create an IRE entry */
   irep = (IREP) IPR_ALLOC(sizeof(IRE));
 824122c:	01002204 	movi	r4,136
 8241230:	822dfec0 	call	822dfec <npalloc>
 8241234:	e0bffa15 	stw	r2,-24(fp)
   if (irep == 0) 
 8241238:	e0bffa17 	ldw	r2,-24(fp)
 824123c:	10000f1e 	bne	r2,zero,824127c <ip_reasm_process_first_fragment+0xc4>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241240:	01000084 	movi	r4,2
 8241244:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free (p);
 8241248:	e13fff17 	ldw	r4,-4(fp)
 824124c:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241250:	01000084 	movi	r4,2
 8241254:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 8241258:	008209b4 	movhi	r2,2086
 824125c:	10ba6a04 	addi	r2,r2,-5720
 8241260:	10800f17 	ldw	r2,60(r2)
 8241264:	10c00044 	addi	r3,r2,1
 8241268:	008209b4 	movhi	r2,2086
 824126c:	10ba6a04 	addi	r2,r2,-5720
 8241270:	10c00f15 	stw	r3,60(r2)
      return ENP_RESOURCE;
 8241274:	00bffa84 	movi	r2,-22
 8241278:	00007806 	br	824145c <ip_reasm_process_first_fragment+0x2a4>
   }

   pip = ip_head(p);
 824127c:	e0bfff17 	ldw	r2,-4(fp)
 8241280:	10800317 	ldw	r2,12(r2)
 8241284:	e0bffb15 	stw	r2,-20(fp)
   iphlen = ip_hlen(pip);
 8241288:	e0bffb17 	ldw	r2,-20(fp)
 824128c:	10800003 	ldbu	r2,0(r2)
 8241290:	108003cc 	andi	r2,r2,15
 8241294:	1085883a 	add	r2,r2,r2
 8241298:	1085883a 	add	r2,r2,r2
 824129c:	e0bffc05 	stb	r2,-16(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 82412a0:	e13ffb17 	ldw	r4,-20(fp)
 82412a4:	8240f1c0 	call	8240f1c <ip_reasm_determine_type_of_frag>
 82412a8:	e0bffd15 	stw	r2,-12(fp)
   frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 82412ac:	e0bffb17 	ldw	r2,-20(fp)
 82412b0:	1080018b 	ldhu	r2,6(r2)
 82412b4:	10bfffcc 	andi	r2,r2,65535
 82412b8:	1004d23a 	srli	r2,r2,8
 82412bc:	10bfffcc 	andi	r2,r2,65535
 82412c0:	10c03fcc 	andi	r3,r2,255
 82412c4:	e0bffb17 	ldw	r2,-20(fp)
 82412c8:	1080018b 	ldhu	r2,6(r2)
 82412cc:	10bfffcc 	andi	r2,r2,65535
 82412d0:	1004923a 	slli	r2,r2,8
 82412d4:	10bfffcc 	andi	r2,r2,65535
 82412d8:	1884b03a 	or	r2,r3,r2
 82412dc:	100490fa 	slli	r2,r2,3
 82412e0:	e0bffe0d 	sth	r2,-8(fp)
   total_len = ntohs(pip->ip_len);
 82412e4:	e0bffb17 	ldw	r2,-20(fp)
 82412e8:	1080008b 	ldhu	r2,2(r2)
 82412ec:	10bfffcc 	andi	r2,r2,65535
 82412f0:	1004d23a 	srli	r2,r2,8
 82412f4:	1007883a 	mov	r3,r2
 82412f8:	e0bffb17 	ldw	r2,-20(fp)
 82412fc:	1080008b 	ldhu	r2,2(r2)
 8241300:	10bfffcc 	andi	r2,r2,65535
 8241304:	1004923a 	slli	r2,r2,8
 8241308:	1884b03a 	or	r2,r3,r2
 824130c:	e0bffe8d 	sth	r2,-6(fp)

   /* now setup various fields in the IRE entry (multi-byte fields stored in network 
    * byte order) */
   irep->src = pip->ip_src;
 8241310:	e0bffb17 	ldw	r2,-20(fp)
 8241314:	10c00317 	ldw	r3,12(r2)
 8241318:	e0bffa17 	ldw	r2,-24(fp)
 824131c:	10c00115 	stw	r3,4(r2)
   irep->dest = pip->ip_dest;
 8241320:	e0bffb17 	ldw	r2,-20(fp)
 8241324:	10c00417 	ldw	r3,16(r2)
 8241328:	e0bffa17 	ldw	r2,-24(fp)
 824132c:	10c00215 	stw	r3,8(r2)
   irep->prot = pip->ip_prot;
 8241330:	e0bffb17 	ldw	r2,-20(fp)
 8241334:	10c00243 	ldbu	r3,9(r2)
 8241338:	e0bffa17 	ldw	r2,-24(fp)
 824133c:	10c00385 	stb	r3,14(r2)
   irep->id = pip->ip_id;
 8241340:	e0bffb17 	ldw	r2,-20(fp)
 8241344:	10c0010b 	ldhu	r3,4(r2)
 8241348:	e0bffa17 	ldw	r2,-24(fp)
 824134c:	10c0030d 	sth	r3,12(r2)
   if (ftype == IP_LF)
 8241350:	e0bffd17 	ldw	r2,-12(fp)
 8241354:	10800158 	cmpnei	r2,r2,5
 8241358:	10000a1e 	bne	r2,zero,8241384 <ip_reasm_process_first_fragment+0x1cc>
      {
      irep->length = frag_offset + (total_len - iphlen);
 824135c:	e0bffc03 	ldbu	r2,-16(fp)
 8241360:	e0fffe8b 	ldhu	r3,-6(fp)
 8241364:	1885c83a 	sub	r2,r3,r2
 8241368:	1007883a 	mov	r3,r2
 824136c:	e0bffe0b 	ldhu	r2,-8(fp)
 8241370:	1885883a 	add	r2,r3,r2
 8241374:	1007883a 	mov	r3,r2
 8241378:	e0bffa17 	ldw	r2,-24(fp)
 824137c:	10c0040d 	sth	r3,16(r2)
 8241380:	00000a06 	br	82413ac <ip_reasm_process_first_fragment+0x1f4>
      }
   else if (ftype == IP_FF)
 8241384:	e0bffd17 	ldw	r2,-12(fp)
 8241388:	10800058 	cmpnei	r2,r2,1
 824138c:	1000071e 	bne	r2,zero,82413ac <ip_reasm_process_first_fragment+0x1f4>
       * out, and results in the transmission of an ICMP Time Exceeded message (with the
       * code set to "fragment reassembly time exceeded").  Please note that the 'l2_hdr' 
       * as set below may not be the start address for the L2 header (but it is adequate 
       * for our use).  If the FF is never received, these fields stay at their initial
       * value of 0. */
      irep->l2_hdr = p->nb_buff;
 8241390:	e0bfff17 	ldw	r2,-4(fp)
 8241394:	10c00117 	ldw	r3,4(r2)
 8241398:	e0bffa17 	ldw	r2,-24(fp)
 824139c:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 82413a0:	e0bffa17 	ldw	r2,-24(fp)
 82413a4:	e0fffb17 	ldw	r3,-20(fp)
 82413a8:	10c02015 	stw	r3,128(r2)
      }

   /* note that the 'rcvd' and 'length' counters only keep track of the data part of 
    * the IP datagram */
   irep->rcvd = total_len - iphlen;
 82413ac:	e0bffc03 	ldbu	r2,-16(fp)
 82413b0:	e0fffe8b 	ldhu	r3,-6(fp)
 82413b4:	1885c83a 	sub	r2,r3,r2
 82413b8:	1007883a 	mov	r3,r2
 82413bc:	e0bffa17 	ldw	r2,-24(fp)
 82413c0:	10c0048d 	sth	r3,18(r2)
   irep->age = 0;
 82413c4:	e0bffa17 	ldw	r2,-24(fp)
 82413c8:	10000515 	stw	zero,20(r2)

   /* all RFQs are compact when created */
   irep->flags |= IPR_RFQ_COMPACT;
 82413cc:	e0bffa17 	ldw	r2,-24(fp)
 82413d0:	10802103 	ldbu	r2,132(r2)
 82413d4:	10800054 	ori	r2,r2,1
 82413d8:	1007883a 	mov	r3,r2
 82413dc:	e0bffa17 	ldw	r2,-24(fp)
 82413e0:	10c02105 	stb	r3,132(r2)

   /* store PACKET pointer in the first location of the first RFQ */
   irep->rfq.bufp[0] = p;
 82413e4:	e0bffa17 	ldw	r2,-24(fp)
 82413e8:	e0ffff17 	ldw	r3,-4(fp)
 82413ec:	10c00715 	stw	r3,28(r2)
   irep->rfq.frag_offset[0] = frag_offset;
 82413f0:	e0bffa17 	ldw	r2,-24(fp)
 82413f4:	e0fffe0b 	ldhu	r3,-8(fp)
 82413f8:	10c0170d 	sth	r3,92(r2)
   /* the next pointer in the RFQ is already 0 */

   p->nb_prot += iphlen;
 82413fc:	e0bfff17 	ldw	r2,-4(fp)
 8241400:	10c00317 	ldw	r3,12(r2)
 8241404:	e0bffc03 	ldbu	r2,-16(fp)
 8241408:	1887883a 	add	r3,r3,r2
 824140c:	e0bfff17 	ldw	r2,-4(fp)
 8241410:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 8241414:	e0bfff17 	ldw	r2,-4(fp)
 8241418:	10c00417 	ldw	r3,16(r2)
 824141c:	e0bffc03 	ldbu	r2,-16(fp)
 8241420:	1887c83a 	sub	r3,r3,r2
 8241424:	e0bfff17 	ldw	r2,-4(fp)
 8241428:	10c00415 	stw	r3,16(r2)

   /* insert at start of global IRE list */
   irep->next = h_ireq;
 824142c:	d0e0c817 	ldw	r3,-31968(gp)
 8241430:	e0bffa17 	ldw	r2,-24(fp)
 8241434:	10c00015 	stw	r3,0(r2)
   h_ireq = irep;
 8241438:	e0bffa17 	ldw	r2,-24(fp)
 824143c:	d0a0c815 	stw	r2,-31968(gp)

   /* increment the memory useage */
   ip_reasm_incr_mem_useage (p->nb_blen + (sizeof (IRE)));
 8241440:	e0bfff17 	ldw	r2,-4(fp)
 8241444:	10800217 	ldw	r2,8(r2)
 8241448:	10802204 	addi	r2,r2,136
 824144c:	10bfffcc 	andi	r2,r2,65535
 8241450:	1009883a 	mov	r4,r2
 8241454:	82410800 	call	8241080 <ip_reasm_incr_mem_useage>

   return IPREASM_OK;
 8241458:	0005883a 	mov	r2,zero
}
 824145c:	e037883a 	mov	sp,fp
 8241460:	dfc00117 	ldw	ra,4(sp)
 8241464:	df000017 	ldw	fp,0(sp)
 8241468:	dec00204 	addi	sp,sp,8
 824146c:	f800283a 	ret

08241470 <ip_reassm>:
merely passes their return code back to its caller.  Otherwise, it returns
IPREASM_OK indicating that the fragment was successfully processed.
*/

int ip_reassm (PACKET p)
{
 8241470:	defff904 	addi	sp,sp,-28
 8241474:	dfc00615 	stw	ra,24(sp)
 8241478:	df000515 	stw	fp,20(sp)
 824147c:	df000504 	addi	fp,sp,20
 8241480:	e13fff15 	stw	r4,-4(fp)
   IREP irep;
   struct ip * pip;
   int rc1, rc2;

   pip = ip_head(p);
 8241484:	e0bfff17 	ldw	r2,-4(fp)
 8241488:	10800317 	ldw	r2,12(r2)
 824148c:	e0bffb15 	stw	r2,-20(fp)

   /* we have just received a fragment, so let's start processing it.  First
    * check for a matching IRE entry. */
   irep = ip_reasm_match_frag_with_ire (pip);
 8241490:	e13ffb17 	ldw	r4,-20(fp)
 8241494:	8240e580 	call	8240e58 <ip_reasm_match_frag_with_ire>
 8241498:	e0bffc15 	stw	r2,-16(fp)

   if (!irep)
 824149c:	e0bffc17 	ldw	r2,-16(fp)
 82414a0:	1000071e 	bne	r2,zero,82414c0 <ip_reassm+0x50>
   {
      /* this is the first packet for a "new" fragment stream */
      if ((rc1 = ip_reasm_process_first_fragment (p)) != IPREASM_OK)
 82414a4:	e13fff17 	ldw	r4,-4(fp)
 82414a8:	82411b80 	call	82411b8 <ip_reasm_process_first_fragment>
 82414ac:	e0bffd15 	stw	r2,-12(fp)
 82414b0:	e0bffd17 	ldw	r2,-12(fp)
 82414b4:	10000a26 	beq	r2,zero,82414e0 <ip_reassm+0x70>
      {
         /* ip_reasm_process_first_fragment () will free the packet */
         return rc1;
 82414b8:	e0bffd17 	ldw	r2,-12(fp)
 82414bc:	00000906 	br	82414e4 <ip_reassm+0x74>
      }
   }
   else
   {
      /* a matching IRE already exists for this fragment */
      if ((rc2 = ip_reasm_process_subsequent_fragments (p, irep)) != IPREASM_OK)
 82414c0:	e17ffc17 	ldw	r5,-16(fp)
 82414c4:	e13fff17 	ldw	r4,-4(fp)
 82414c8:	8241a5c0 	call	8241a5c <ip_reasm_process_subsequent_fragments>
 82414cc:	e0bffe15 	stw	r2,-8(fp)
 82414d0:	e0bffe17 	ldw	r2,-8(fp)
 82414d4:	10000226 	beq	r2,zero,82414e0 <ip_reassm+0x70>
      {
         /* ip_reasm_process_subsequent_fragments () has already deleted the IRE entry */
         return rc2;
 82414d8:	e0bffe17 	ldw	r2,-8(fp)
 82414dc:	00000106 	br	82414e4 <ip_reassm+0x74>
      }
   }

   return IPREASM_OK;
 82414e0:	0005883a 	mov	r2,zero
}
 82414e4:	e037883a 	mov	sp,fp
 82414e8:	dfc00117 	ldw	ra,4(sp)
 82414ec:	df000017 	ldw	fp,0(sp)
 82414f0:	dec00204 	addi	sp,sp,8
 82414f4:	f800283a 	ret

082414f8 <ip_reasm_compute_overlap>:
            (i.e., contains "unique" data).
*/

IPREASM_RC ip_reasm_compute_overlap (PACKET p, IREP irep, u_short * indexp, 
 RFQP * last_rfqpp, u_short * frag_offsetp, u_char * hole_createdp)
{
 82414f8:	defff204 	addi	sp,sp,-56
 82414fc:	dfc00d15 	stw	ra,52(sp)
 8241500:	df000c15 	stw	fp,48(sp)
 8241504:	df000c04 	addi	fp,sp,48
 8241508:	e13ffc15 	stw	r4,-16(fp)
 824150c:	e17ffd15 	stw	r5,-12(fp)
 8241510:	e1bffe15 	stw	r6,-8(fp)
 8241514:	e1ffff15 	stw	r7,-4(fp)
   u_short currend;
   u_short drop_len;
   u_char iphlen;
   u_short i;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 8241518:	e13ffd17 	ldw	r4,-12(fp)
 824151c:	8241f8c0 	call	8241f8c <ip_reasm_find_ire>
 8241520:	10803fcc 	andi	r2,r2,255
 8241524:	10800060 	cmpeqi	r2,r2,1
 8241528:	10000f1e 	bne	r2,zero,8241568 <ip_reasm_compute_overlap+0x70>
      {
      ++ire_stats.bad_irep;
 824152c:	008209b4 	movhi	r2,2086
 8241530:	10ba7e04 	addi	r2,r2,-5640
 8241534:	10800017 	ldw	r2,0(r2)
 8241538:	10c00044 	addi	r3,r2,1
 824153c:	008209b4 	movhi	r2,2086
 8241540:	10ba7e04 	addi	r2,r2,-5640
 8241544:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241548:	01000084 	movi	r4,2
 824154c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free (p);
 8241550:	e13ffc17 	ldw	r4,-16(fp)
 8241554:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241558:	01000084 	movi	r4,2
 824155c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return IPREASM_DROP_FRAG_BAD_PARAM;
 8241560:	00800044 	movi	r2,1
 8241564:	00013806 	br	8241a48 <ip_reasm_compute_overlap+0x550>
      }

   jrip = ip_head(p);
 8241568:	e0bffc17 	ldw	r2,-16(fp)
 824156c:	10800317 	ldw	r2,12(r2)
 8241570:	e0bff715 	stw	r2,-36(fp)
   iphlen = ip_hlen (jrip);
 8241574:	e0bff717 	ldw	r2,-36(fp)
 8241578:	10800003 	ldbu	r2,0(r2)
 824157c:	108003cc 	andi	r2,r2,15
 8241580:	1085883a 	add	r2,r2,r2
 8241584:	1085883a 	add	r2,r2,r2
 8241588:	e0bff805 	stb	r2,-32(fp)
   jrstart = (((ntohs(jrip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 824158c:	e0bff717 	ldw	r2,-36(fp)
 8241590:	1080018b 	ldhu	r2,6(r2)
 8241594:	10bfffcc 	andi	r2,r2,65535
 8241598:	1004d23a 	srli	r2,r2,8
 824159c:	10bfffcc 	andi	r2,r2,65535
 82415a0:	10c03fcc 	andi	r3,r2,255
 82415a4:	e0bff717 	ldw	r2,-36(fp)
 82415a8:	1080018b 	ldhu	r2,6(r2)
 82415ac:	10bfffcc 	andi	r2,r2,65535
 82415b0:	1004923a 	slli	r2,r2,8
 82415b4:	10bfffcc 	andi	r2,r2,65535
 82415b8:	1884b03a 	or	r2,r3,r2
 82415bc:	100490fa 	slli	r2,r2,3
 82415c0:	e0bff50d 	sth	r2,-44(fp)
   jrend =   jrstart + ((ntohs(jrip->ip_len)) - iphlen) - 1;
 82415c4:	e0bff717 	ldw	r2,-36(fp)
 82415c8:	1080008b 	ldhu	r2,2(r2)
 82415cc:	10bfffcc 	andi	r2,r2,65535
 82415d0:	1004d23a 	srli	r2,r2,8
 82415d4:	1007883a 	mov	r3,r2
 82415d8:	e0bff717 	ldw	r2,-36(fp)
 82415dc:	1080008b 	ldhu	r2,2(r2)
 82415e0:	10bfffcc 	andi	r2,r2,65535
 82415e4:	1004923a 	slli	r2,r2,8
 82415e8:	1884b03a 	or	r2,r3,r2
 82415ec:	1007883a 	mov	r3,r2
 82415f0:	e0bff803 	ldbu	r2,-32(fp)
 82415f4:	1885c83a 	sub	r2,r3,r2
 82415f8:	1007883a 	mov	r3,r2
 82415fc:	e0bff50b 	ldhu	r2,-44(fp)
 8241600:	1885883a 	add	r2,r3,r2
 8241604:	10bfffc4 	addi	r2,r2,-1
 8241608:	e0bff58d 	sth	r2,-42(fp)
   /* skip past the IP header of the just received fragment as we get ready 
    * to compare for overlap between the just received fragment and the 
    * fragments that are currently queued in the IRE entry for this fragment 
    * chain */
   p->nb_prot += iphlen;
 824160c:	e0bffc17 	ldw	r2,-16(fp)
 8241610:	10c00317 	ldw	r3,12(r2)
 8241614:	e0bff803 	ldbu	r2,-32(fp)
 8241618:	1887883a 	add	r3,r3,r2
 824161c:	e0bffc17 	ldw	r2,-16(fp)
 8241620:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 8241624:	e0bffc17 	ldw	r2,-16(fp)
 8241628:	10c00417 	ldw	r3,16(r2)
 824162c:	e0bff803 	ldbu	r2,-32(fp)
 8241630:	1887c83a 	sub	r3,r3,r2
 8241634:	e0bffc17 	ldw	r2,-16(fp)
 8241638:	10c00415 	stw	r3,16(r2)

   *frag_offsetp = jrstart;
 824163c:	e0800217 	ldw	r2,8(fp)
 8241640:	e0fff50b 	ldhu	r3,-44(fp)
 8241644:	10c0000d 	sth	r3,0(r2)
   *indexp = INVALID_FRAG_INDEX;
 8241648:	e0bffe17 	ldw	r2,-8(fp)
 824164c:	00c00404 	movi	r3,16
 8241650:	10c0000d 	sth	r3,0(r2)
   *last_rfqpp = 0;
 8241654:	e0bfff17 	ldw	r2,-4(fp)
 8241658:	10000015 	stw	zero,0(r2)
   *hole_createdp = IPREASM_FALSE;
 824165c:	e0800317 	ldw	r2,12(fp)
 8241660:	10000005 	stb	zero,0(r2)

   rfqp = &(irep->rfq);
 8241664:	e0bffd17 	ldw	r2,-12(fp)
 8241668:	10800604 	addi	r2,r2,24
 824166c:	e0bff415 	stw	r2,-48(fp)

   while (rfqp)
 8241670:	0000ef06 	br	8241a30 <ip_reasm_compute_overlap+0x538>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8241674:	e03ff60d 	sth	zero,-40(fp)
 8241678:	0000dd06 	br	82419f0 <ip_reasm_compute_overlap+0x4f8>
         {
         if ((currpkt = rfqp->bufp[i]) != 0)
 824167c:	e0bff60b 	ldhu	r2,-40(fp)
 8241680:	e0fff417 	ldw	r3,-48(fp)
 8241684:	10800044 	addi	r2,r2,1
 8241688:	1085883a 	add	r2,r2,r2
 824168c:	1085883a 	add	r2,r2,r2
 8241690:	1885883a 	add	r2,r3,r2
 8241694:	10800017 	ldw	r2,0(r2)
 8241698:	e0bff915 	stw	r2,-28(fp)
 824169c:	e0bff917 	ldw	r2,-28(fp)
 82416a0:	1000c026 	beq	r2,zero,82419a4 <ip_reasm_compute_overlap+0x4ac>
            {
            currstart = rfqp->frag_offset[i];
 82416a4:	e0bff60b 	ldhu	r2,-40(fp)
 82416a8:	e0fff417 	ldw	r3,-48(fp)
 82416ac:	10800884 	addi	r2,r2,34
 82416b0:	1085883a 	add	r2,r2,r2
 82416b4:	1885883a 	add	r2,r3,r2
 82416b8:	1080000b 	ldhu	r2,0(r2)
 82416bc:	e0bffa0d 	sth	r2,-24(fp)
            currend = currstart + currpkt->nb_plen - 1;
 82416c0:	e0bff917 	ldw	r2,-28(fp)
 82416c4:	10800417 	ldw	r2,16(r2)
 82416c8:	1007883a 	mov	r3,r2
 82416cc:	e0bffa0b 	ldhu	r2,-24(fp)
 82416d0:	1885883a 	add	r2,r3,r2
 82416d4:	10bfffc4 	addi	r2,r2,-1
 82416d8:	e0bffa8d 	sth	r2,-22(fp)

            if (currstart < jrstart)
 82416dc:	e0fffa0b 	ldhu	r3,-24(fp)
 82416e0:	e0bff50b 	ldhu	r2,-44(fp)
 82416e4:	18802b2e 	bgeu	r3,r2,8241794 <ip_reasm_compute_overlap+0x29c>
               {
               if (currend < jrend) /* cases A1 and A2 */
 82416e8:	e0fffa8b 	ldhu	r3,-22(fp)
 82416ec:	e0bff58b 	ldhu	r2,-42(fp)
 82416f0:	1880202e 	bgeu	r3,r2,8241774 <ip_reasm_compute_overlap+0x27c>
                  {
                  if (currend < jrstart) /* A1 */
 82416f4:	e0fffa8b 	ldhu	r3,-22(fp)
 82416f8:	e0bff50b 	ldhu	r2,-44(fp)
 82416fc:	1880b936 	bltu	r3,r2,82419e4 <ip_reasm_compute_overlap+0x4ec>
                     {
                     /* the just received fragment partially overlaps current 
                      * fragment on the latter's right; increment start 
                      * pointer and decrement length of just received fragment.
                      * Move on to the next fragment in the RFQ. */
                     drop_len = (currend - jrstart) + 1;
 8241700:	e0fffa8b 	ldhu	r3,-22(fp)
 8241704:	e0bff50b 	ldhu	r2,-44(fp)
 8241708:	1885c83a 	sub	r2,r3,r2
 824170c:	10800044 	addi	r2,r2,1
 8241710:	e0bffb0d 	sth	r2,-20(fp)
                     p->nb_prot += drop_len;
 8241714:	e0bffc17 	ldw	r2,-16(fp)
 8241718:	10c00317 	ldw	r3,12(r2)
 824171c:	e0bffb0b 	ldhu	r2,-20(fp)
 8241720:	1887883a 	add	r3,r3,r2
 8241724:	e0bffc17 	ldw	r2,-16(fp)
 8241728:	10c00315 	stw	r3,12(r2)
                     p->nb_plen -= drop_len;
 824172c:	e0bffc17 	ldw	r2,-16(fp)
 8241730:	10c00417 	ldw	r3,16(r2)
 8241734:	e0bffb0b 	ldhu	r2,-20(fp)
 8241738:	1887c83a 	sub	r3,r3,r2
 824173c:	e0bffc17 	ldw	r2,-16(fp)
 8241740:	10c00415 	stw	r3,16(r2)
                     jrstart += drop_len;
 8241744:	e0fff50b 	ldhu	r3,-44(fp)
 8241748:	e0bffb0b 	ldhu	r2,-20(fp)
 824174c:	1885883a 	add	r2,r3,r2
 8241750:	e0bff50d 	sth	r2,-44(fp)
                     jrend = jrstart + p->nb_plen - 1;
 8241754:	e0bffc17 	ldw	r2,-16(fp)
 8241758:	10800417 	ldw	r2,16(r2)
 824175c:	1007883a 	mov	r3,r2
 8241760:	e0bff50b 	ldhu	r2,-44(fp)
 8241764:	1885883a 	add	r2,r3,r2
 8241768:	10bfffc4 	addi	r2,r2,-1
 824176c:	e0bff58d 	sth	r2,-42(fp)
 8241770:	00009c06 	br	82419e4 <ip_reasm_compute_overlap+0x4ec>
               else
                  {
                  /* currend is greater than or equal to jrend (cases E1 and E2).
                   * The current fragment is a superset of the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 8241774:	01000084 	movi	r4,2
 8241778:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
                  pk_free (p);
 824177c:	e13ffc17 	ldw	r4,-16(fp)
 8241780:	822cbbc0 	call	822cbbc <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241784:	01000084 	movi	r4,2
 8241788:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 824178c:	0005883a 	mov	r2,zero
 8241790:	0000ad06 	br	8241a48 <ip_reasm_compute_overlap+0x550>
                  }
               }
            else if (currstart > jrstart)
 8241794:	e0bffa0b 	ldhu	r2,-24(fp)
 8241798:	e0fff50b 	ldhu	r3,-44(fp)
 824179c:	18804e2e 	bgeu	r3,r2,82418d8 <ip_reasm_compute_overlap+0x3e0>
               {
               if (currend > jrend) /* cases B1 and B2 */
 82417a0:	e0bffa8b 	ldhu	r2,-22(fp)
 82417a4:	e0fff58b 	ldhu	r3,-42(fp)
 82417a8:	1880112e 	bgeu	r3,r2,82417f0 <ip_reasm_compute_overlap+0x2f8>
                  {
                  if (currstart > jrend) /* B1 */
 82417ac:	e0bffa0b 	ldhu	r2,-24(fp)
 82417b0:	e0fff58b 	ldhu	r3,-42(fp)
 82417b4:	18808b36 	bltu	r3,r2,82419e4 <ip_reasm_compute_overlap+0x4ec>
                     {
                     /* just received fragment partially overlaps current 
                      * fragment on the latter's left; decrement length of 
                      * just received fragment.  Move on to the next fragment 
                      * in the RFQ. */
                     p->nb_plen = currstart - jrstart;
 82417b8:	e0fffa0b 	ldhu	r3,-24(fp)
 82417bc:	e0bff50b 	ldhu	r2,-44(fp)
 82417c0:	1885c83a 	sub	r2,r3,r2
 82417c4:	1007883a 	mov	r3,r2
 82417c8:	e0bffc17 	ldw	r2,-16(fp)
 82417cc:	10c00415 	stw	r3,16(r2)
                     /* start offset remains unchanged, but jrend must be updated */
                     jrend = jrstart + p->nb_plen - 1;
 82417d0:	e0bffc17 	ldw	r2,-16(fp)
 82417d4:	10800417 	ldw	r2,16(r2)
 82417d8:	1007883a 	mov	r3,r2
 82417dc:	e0bff50b 	ldhu	r2,-44(fp)
 82417e0:	1885883a 	add	r2,r3,r2
 82417e4:	10bfffc4 	addi	r2,r2,-1
 82417e8:	e0bff58d 	sth	r2,-42(fp)
 82417ec:	00007d06 	br	82419e4 <ip_reasm_compute_overlap+0x4ec>
                     }
                  }
               else if (currend == jrend) /* F1 */
 82417f0:	e0fffa8b 	ldhu	r3,-22(fp)
 82417f4:	e0bff58b 	ldhu	r2,-42(fp)
 82417f8:	18800e1e 	bne	r3,r2,8241834 <ip_reasm_compute_overlap+0x33c>
                  {
                  /* current fragment is a subset of the just received fragment.  
                   * Decrement the length of the just received fragment.  Move
                   * on to the next fragment in the RFQ. */
                  p->nb_plen = currstart - jrstart;
 82417fc:	e0fffa0b 	ldhu	r3,-24(fp)
 8241800:	e0bff50b 	ldhu	r2,-44(fp)
 8241804:	1885c83a 	sub	r2,r3,r2
 8241808:	1007883a 	mov	r3,r2
 824180c:	e0bffc17 	ldw	r2,-16(fp)
 8241810:	10c00415 	stw	r3,16(r2)
                  jrend = jrstart + p->nb_plen - 1;
 8241814:	e0bffc17 	ldw	r2,-16(fp)
 8241818:	10800417 	ldw	r2,16(r2)
 824181c:	1007883a 	mov	r3,r2
 8241820:	e0bff50b 	ldhu	r2,-44(fp)
 8241824:	1885883a 	add	r2,r3,r2
 8241828:	10bfffc4 	addi	r2,r2,-1
 824182c:	e0bff58d 	sth	r2,-42(fp)
 8241830:	00006c06 	br	82419e4 <ip_reasm_compute_overlap+0x4ec>
                  {
                  /* currend is less than jrend (case F2).  current fragment is 
                   * a subset of the just received fragment.  Drop current
                   * fragment.  Move on to the next fragment in the RFQ.  Decrement
                   * the amount of memory currently in use. */
                  ip_reasm_decr_mem_useage (currpkt->nb_blen);
 8241834:	e0bff917 	ldw	r2,-28(fp)
 8241838:	10800217 	ldw	r2,8(r2)
 824183c:	10bfffcc 	andi	r2,r2,65535
 8241840:	1009883a 	mov	r4,r2
 8241844:	82411200 	call	8241120 <ip_reasm_decr_mem_useage>
                  irep->rcvd -= currpkt->nb_plen;
 8241848:	e0bffd17 	ldw	r2,-12(fp)
 824184c:	1080048b 	ldhu	r2,18(r2)
 8241850:	e0fff917 	ldw	r3,-28(fp)
 8241854:	18c00417 	ldw	r3,16(r3)
 8241858:	10c5c83a 	sub	r2,r2,r3
 824185c:	1007883a 	mov	r3,r2
 8241860:	e0bffd17 	ldw	r2,-12(fp)
 8241864:	10c0048d 	sth	r3,18(r2)
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 8241868:	01000084 	movi	r4,2
 824186c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
                  pk_free (currpkt);
 8241870:	e13ff917 	ldw	r4,-28(fp)
 8241874:	822cbbc0 	call	822cbbc <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241878:	01000084 	movi	r4,2
 824187c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
                  rfqp->bufp[i] = 0; /* mark slot as unused */
 8241880:	e0bff60b 	ldhu	r2,-40(fp)
 8241884:	e0fff417 	ldw	r3,-48(fp)
 8241888:	10800044 	addi	r2,r2,1
 824188c:	1085883a 	add	r2,r2,r2
 8241890:	1085883a 	add	r2,r2,r2
 8241894:	1885883a 	add	r2,r3,r2
 8241898:	10000015 	stw	zero,0(r2)
                  /* save the location of the empty slot */
                  if ((*indexp) == INVALID_FRAG_INDEX) 
 824189c:	e0bffe17 	ldw	r2,-8(fp)
 82418a0:	1080000b 	ldhu	r2,0(r2)
 82418a4:	10bfffcc 	andi	r2,r2,65535
 82418a8:	10800418 	cmpnei	r2,r2,16
 82418ac:	1000061e 	bne	r2,zero,82418c8 <ip_reasm_compute_overlap+0x3d0>
                     {
                     *indexp = i;
 82418b0:	e0bffe17 	ldw	r2,-8(fp)
 82418b4:	e0fff60b 	ldhu	r3,-40(fp)
 82418b8:	10c0000d 	sth	r3,0(r2)
                     *last_rfqpp = rfqp;
 82418bc:	e0bfff17 	ldw	r2,-4(fp)
 82418c0:	e0fff417 	ldw	r3,-48(fp)
 82418c4:	10c00015 	stw	r3,0(r2)
                     }
                  /* we've just created a hole; the array may no longer be "compact" */
                  *hole_createdp = IPREASM_TRUE;
 82418c8:	e0800317 	ldw	r2,12(fp)
 82418cc:	00c00044 	movi	r3,1
 82418d0:	10c00005 	stb	r3,0(r2)
 82418d4:	00004306 	br	82419e4 <ip_reasm_compute_overlap+0x4ec>
                  }
               }
            else
               {
               /* currstart and jrstart are equal */
               if (currend == jrend) /* case C */
 82418d8:	e0fffa8b 	ldhu	r3,-22(fp)
 82418dc:	e0bff58b 	ldhu	r2,-42(fp)
 82418e0:	1880081e 	bne	r3,r2,8241904 <ip_reasm_compute_overlap+0x40c>
                  {
                  /* the current fragment is identical to the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 82418e4:	01000084 	movi	r4,2
 82418e8:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
                  pk_free (p);
 82418ec:	e13ffc17 	ldw	r4,-16(fp)
 82418f0:	822cbbc0 	call	822cbbc <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 82418f4:	01000084 	movi	r4,2
 82418f8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 82418fc:	0005883a 	mov	r2,zero
 8241900:	00005106 	br	8241a48 <ip_reasm_compute_overlap+0x550>
                  }
               else if (currend > jrend) /* case D1 */
 8241904:	e0bffa8b 	ldhu	r2,-22(fp)
 8241908:	e0fff58b 	ldhu	r3,-42(fp)
 824190c:	1880082e 	bgeu	r3,r2,8241930 <ip_reasm_compute_overlap+0x438>
                  {
                  /* current fragment is a superset of just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 8241910:	01000084 	movi	r4,2
 8241914:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
                  pk_free (p);
 8241918:	e13ffc17 	ldw	r4,-16(fp)
 824191c:	822cbbc0 	call	822cbbc <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241920:	01000084 	movi	r4,2
 8241924:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 8241928:	0005883a 	mov	r2,zero
 824192c:	00004606 	br	8241a48 <ip_reasm_compute_overlap+0x550>
                  /* currend is less than jrend (case D2).  current fragment 
                   * is a subset of the just received fragment.  Increment 
                   * the start pointer and decrement the length of the just
                   * received fragment.  Move on to the next fragment in 
                   * the RFQ. */
                  drop_len = (currend - jrstart) + 1;
 8241930:	e0fffa8b 	ldhu	r3,-22(fp)
 8241934:	e0bff50b 	ldhu	r2,-44(fp)
 8241938:	1885c83a 	sub	r2,r3,r2
 824193c:	10800044 	addi	r2,r2,1
 8241940:	e0bffb0d 	sth	r2,-20(fp)
                  p->nb_prot += drop_len;
 8241944:	e0bffc17 	ldw	r2,-16(fp)
 8241948:	10c00317 	ldw	r3,12(r2)
 824194c:	e0bffb0b 	ldhu	r2,-20(fp)
 8241950:	1887883a 	add	r3,r3,r2
 8241954:	e0bffc17 	ldw	r2,-16(fp)
 8241958:	10c00315 	stw	r3,12(r2)
                  p->nb_plen -= drop_len;
 824195c:	e0bffc17 	ldw	r2,-16(fp)
 8241960:	10c00417 	ldw	r3,16(r2)
 8241964:	e0bffb0b 	ldhu	r2,-20(fp)
 8241968:	1887c83a 	sub	r3,r3,r2
 824196c:	e0bffc17 	ldw	r2,-16(fp)
 8241970:	10c00415 	stw	r3,16(r2)
                  jrstart += drop_len;
 8241974:	e0fff50b 	ldhu	r3,-44(fp)
 8241978:	e0bffb0b 	ldhu	r2,-20(fp)
 824197c:	1885883a 	add	r2,r3,r2
 8241980:	e0bff50d 	sth	r2,-44(fp)
                  jrend = jrstart + p->nb_plen - 1;
 8241984:	e0bffc17 	ldw	r2,-16(fp)
 8241988:	10800417 	ldw	r2,16(r2)
 824198c:	1007883a 	mov	r3,r2
 8241990:	e0bff50b 	ldhu	r2,-44(fp)
 8241994:	1885883a 	add	r2,r3,r2
 8241998:	10bfffc4 	addi	r2,r2,-1
 824199c:	e0bff58d 	sth	r2,-42(fp)
 82419a0:	00001006 	br	82419e4 <ip_reasm_compute_overlap+0x4ec>
                  }
               }
            } /* end if (PACKET buffer exists at this slot) */
         else
            {
            if ((*indexp) == INVALID_FRAG_INDEX)
 82419a4:	e0bffe17 	ldw	r2,-8(fp)
 82419a8:	1080000b 	ldhu	r2,0(r2)
 82419ac:	10bfffcc 	andi	r2,r2,65535
 82419b0:	10800418 	cmpnei	r2,r2,16
 82419b4:	1000061e 	bne	r2,zero,82419d0 <ip_reasm_compute_overlap+0x4d8>
               {
               *indexp = i;
 82419b8:	e0bffe17 	ldw	r2,-8(fp)
 82419bc:	e0fff60b 	ldhu	r3,-40(fp)
 82419c0:	10c0000d 	sth	r3,0(r2)
               *last_rfqpp = rfqp;               
 82419c4:	e0bfff17 	ldw	r2,-4(fp)
 82419c8:	e0fff417 	ldw	r3,-48(fp)
 82419cc:	10c00015 	stw	r3,0(r2)
               }
            if (irep->flags & IPR_RFQ_COMPACT)
 82419d0:	e0bffd17 	ldw	r2,-12(fp)
 82419d4:	10802103 	ldbu	r2,132(r2)
 82419d8:	10803fcc 	andi	r2,r2,255
 82419dc:	1080004c 	andi	r2,r2,1
 82419e0:	1000071e 	bne	r2,zero,8241a00 <ip_reasm_compute_overlap+0x508>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 82419e4:	e0bff60b 	ldhu	r2,-40(fp)
 82419e8:	10800044 	addi	r2,r2,1
 82419ec:	e0bff60d 	sth	r2,-40(fp)
 82419f0:	e0bff60b 	ldhu	r2,-40(fp)
 82419f4:	10800430 	cmpltui	r2,r2,16
 82419f8:	103f201e 	bne	r2,zero,824167c <ip_reasm_compute_overlap+0x184>
 82419fc:	00000106 	br	8241a04 <ip_reasm_compute_overlap+0x50c>
               *indexp = i;
               *last_rfqpp = rfqp;               
               }
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 8241a00:	0001883a 	nop
               }
            }
         } /* end FOR (0...(IPR_MAX_FRAGS - 1)) */

      /* skip saving RFQ pointer if we've already found an empty slot */
      if ((*indexp) == INVALID_FRAG_INDEX) 
 8241a04:	e0bffe17 	ldw	r2,-8(fp)
 8241a08:	1080000b 	ldhu	r2,0(r2)
 8241a0c:	10bfffcc 	andi	r2,r2,65535
 8241a10:	10800418 	cmpnei	r2,r2,16
 8241a14:	1000031e 	bne	r2,zero,8241a24 <ip_reasm_compute_overlap+0x52c>
         {
         *last_rfqpp = rfqp;
 8241a18:	e0bfff17 	ldw	r2,-4(fp)
 8241a1c:	e0fff417 	ldw	r3,-48(fp)
 8241a20:	10c00015 	stw	r3,0(r2)
         }
      rfqp = rfqp->next;
 8241a24:	e0bff417 	ldw	r2,-48(fp)
 8241a28:	10800017 	ldw	r2,0(r2)
 8241a2c:	e0bff415 	stw	r2,-48(fp)
   *last_rfqpp = 0;
   *hole_createdp = IPREASM_FALSE;

   rfqp = &(irep->rfq);

   while (rfqp)
 8241a30:	e0bff417 	ldw	r2,-48(fp)
 8241a34:	103f0f1e 	bne	r2,zero,8241674 <ip_reasm_compute_overlap+0x17c>
      } /* end while (rfqp) */

   /* if no empty slots were found, (*last_rfqpp) will contain a pointer 
    * to the last RFQ that we were working with */

   *frag_offsetp = jrstart; /* stored in host byte order */
 8241a38:	e0800217 	ldw	r2,8(fp)
 8241a3c:	e0fff50b 	ldhu	r3,-44(fp)
 8241a40:	10c0000d 	sth	r3,0(r2)

   return IPREASM_ACCEPT_FRAG;
 8241a44:	00800084 	movi	r2,2
}
 8241a48:	e037883a 	mov	sp,fp
 8241a4c:	dfc00117 	ldw	ra,4(sp)
 8241a50:	df000017 	ldw	fp,0(sp)
 8241a54:	dec00204 	addi	sp,sp,8
 8241a58:	f800283a 	ret

08241a5c <ip_reasm_process_subsequent_fragments>:
            queued fragments (and hence has been dropped), or if the fragment
            has been processed successfully.
*/

int ip_reasm_process_subsequent_fragments (PACKET p, IREP irep)
{
 8241a5c:	defff104 	addi	sp,sp,-60
 8241a60:	dfc00e15 	stw	ra,56(sp)
 8241a64:	df000d15 	stw	fp,52(sp)
 8241a68:	df000d04 	addi	fp,sp,52
 8241a6c:	e13ffe15 	stw	r4,-8(fp)
 8241a70:	e17fff15 	stw	r5,-4(fp)
   PACKET reassy_pkt;
   struct ip * pip;
   RFQP new_rfqp = 0;
 8241a74:	e03ff515 	stw	zero,-44(fp)
   u_short index;
   RFQP rfqp;
   u_short frag_offset;
   u_char hole_created;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 8241a78:	e13fff17 	ldw	r4,-4(fp)
 8241a7c:	8241f8c0 	call	8241f8c <ip_reasm_find_ire>
 8241a80:	10803fcc 	andi	r2,r2,255
 8241a84:	10800060 	cmpeqi	r2,r2,1
 8241a88:	1000161e 	bne	r2,zero,8241ae4 <ip_reasm_process_subsequent_fragments+0x88>
      {
      ++ire_stats.bad_irep;
 8241a8c:	008209b4 	movhi	r2,2086
 8241a90:	10ba7e04 	addi	r2,r2,-5640
 8241a94:	10800017 	ldw	r2,0(r2)
 8241a98:	10c00044 	addi	r3,r2,1
 8241a9c:	008209b4 	movhi	r2,2086
 8241aa0:	10ba7e04 	addi	r2,r2,-5640
 8241aa4:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241aa8:	01000084 	movi	r4,2
 8241aac:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free (p);
 8241ab0:	e13ffe17 	ldw	r4,-8(fp)
 8241ab4:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241ab8:	01000084 	movi	r4,2
 8241abc:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 8241ac0:	008209b4 	movhi	r2,2086
 8241ac4:	10ba6a04 	addi	r2,r2,-5720
 8241ac8:	10800f17 	ldw	r2,60(r2)
 8241acc:	10c00044 	addi	r3,r2,1
 8241ad0:	008209b4 	movhi	r2,2086
 8241ad4:	10ba6a04 	addi	r2,r2,-5720
 8241ad8:	10c00f15 	stw	r3,60(r2)
      return ENP_PARAM;
 8241adc:	00bffd84 	movi	r2,-10
 8241ae0:	00012506 	br	8241f78 <ip_reasm_process_subsequent_fragments+0x51c>
      }

   pip = ip_head(p);
 8241ae4:	e0bffe17 	ldw	r2,-8(fp)
 8241ae8:	10800317 	ldw	r2,12(r2)
 8241aec:	e0bff615 	stw	r2,-40(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 8241af0:	e13ff617 	ldw	r4,-40(fp)
 8241af4:	8240f1c0 	call	8240f1c <ip_reasm_determine_type_of_frag>
 8241af8:	e0bff715 	stw	r2,-36(fp)
   /* this fragment is a destined for an already queued fragment stream.
    * we update the 'length' field for LFs here because ip_reasm_compute_overlap ()
    * modifies the received fragment's nb_prot pointer (thereby making its IP header 
    * inaccessible) */
   if (ftype == IP_LF)
 8241afc:	e0bff717 	ldw	r2,-36(fp)
 8241b00:	10800158 	cmpnei	r2,r2,5
 8241b04:	1000251e 	bne	r2,zero,8241b9c <ip_reasm_process_subsequent_fragments+0x140>
      {
      irep->length = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3) + ((ntohs(pip->ip_len)) - ip_hlen(pip));
 8241b08:	e0bff617 	ldw	r2,-40(fp)
 8241b0c:	1080018b 	ldhu	r2,6(r2)
 8241b10:	10bfffcc 	andi	r2,r2,65535
 8241b14:	1004d23a 	srli	r2,r2,8
 8241b18:	10bfffcc 	andi	r2,r2,65535
 8241b1c:	10c03fcc 	andi	r3,r2,255
 8241b20:	e0bff617 	ldw	r2,-40(fp)
 8241b24:	1080018b 	ldhu	r2,6(r2)
 8241b28:	10bfffcc 	andi	r2,r2,65535
 8241b2c:	1004923a 	slli	r2,r2,8
 8241b30:	10bfffcc 	andi	r2,r2,65535
 8241b34:	1884b03a 	or	r2,r3,r2
 8241b38:	100490fa 	slli	r2,r2,3
 8241b3c:	1007883a 	mov	r3,r2
 8241b40:	e0bff617 	ldw	r2,-40(fp)
 8241b44:	1080008b 	ldhu	r2,2(r2)
 8241b48:	10bfffcc 	andi	r2,r2,65535
 8241b4c:	1004d23a 	srli	r2,r2,8
 8241b50:	1009883a 	mov	r4,r2
 8241b54:	e0bff617 	ldw	r2,-40(fp)
 8241b58:	1080008b 	ldhu	r2,2(r2)
 8241b5c:	10bfffcc 	andi	r2,r2,65535
 8241b60:	1004923a 	slli	r2,r2,8
 8241b64:	2084b03a 	or	r2,r4,r2
 8241b68:	1009883a 	mov	r4,r2
 8241b6c:	e0bff617 	ldw	r2,-40(fp)
 8241b70:	10800003 	ldbu	r2,0(r2)
 8241b74:	10803fcc 	andi	r2,r2,255
 8241b78:	108003cc 	andi	r2,r2,15
 8241b7c:	1085883a 	add	r2,r2,r2
 8241b80:	1085883a 	add	r2,r2,r2
 8241b84:	2085c83a 	sub	r2,r4,r2
 8241b88:	1885883a 	add	r2,r3,r2
 8241b8c:	1007883a 	mov	r3,r2
 8241b90:	e0bfff17 	ldw	r2,-4(fp)
 8241b94:	10c0040d 	sth	r3,16(r2)
 8241b98:	00000a06 	br	8241bc4 <ip_reasm_process_subsequent_fragments+0x168>
      }
   else if (ftype == IP_FF)
 8241b9c:	e0bff717 	ldw	r2,-36(fp)
 8241ba0:	10800058 	cmpnei	r2,r2,1
 8241ba4:	1000071e 	bne	r2,zero,8241bc4 <ip_reasm_process_subsequent_fragments+0x168>
      {
      irep->l2_hdr = p->nb_buff;
 8241ba8:	e0bffe17 	ldw	r2,-8(fp)
 8241bac:	10c00117 	ldw	r3,4(r2)
 8241bb0:	e0bfff17 	ldw	r2,-4(fp)
 8241bb4:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 8241bb8:	e0bfff17 	ldw	r2,-4(fp)
 8241bbc:	e0fff617 	ldw	r3,-40(fp)
 8241bc0:	10c02015 	stw	r3,128(r2)
      }

   /* Check for overlap, and determine the increase in memory resource 
    * requirements from the newly arrived fragment */
   if ((rc2 = ip_reasm_compute_overlap (p, irep, &index, &rfqp, &frag_offset, &hole_created)) != IPREASM_ACCEPT_FRAG)
 8241bc4:	e13ffc04 	addi	r4,fp,-16
 8241bc8:	e0fffb04 	addi	r3,fp,-20
 8241bcc:	e0bffd84 	addi	r2,fp,-10
 8241bd0:	d8800115 	stw	r2,4(sp)
 8241bd4:	e0bffd04 	addi	r2,fp,-12
 8241bd8:	d8800015 	stw	r2,0(sp)
 8241bdc:	200f883a 	mov	r7,r4
 8241be0:	180d883a 	mov	r6,r3
 8241be4:	e17fff17 	ldw	r5,-4(fp)
 8241be8:	e13ffe17 	ldw	r4,-8(fp)
 8241bec:	82414f80 	call	82414f8 <ip_reasm_compute_overlap>
 8241bf0:	e0bff815 	stw	r2,-32(fp)
 8241bf4:	e0bff817 	ldw	r2,-32(fp)
 8241bf8:	108000a0 	cmpeqi	r2,r2,2
 8241bfc:	1000091e 	bne	r2,zero,8241c24 <ip_reasm_process_subsequent_fragments+0x1c8>
      {
      switch (rc2)
 8241c00:	e0bff817 	ldw	r2,-32(fp)
 8241c04:	10c00060 	cmpeqi	r3,r2,1
 8241c08:	1800031e 	bne	r3,zero,8241c18 <ip_reasm_process_subsequent_fragments+0x1bc>
 8241c0c:	00800436 	bltu	zero,r2,8241c20 <ip_reasm_process_subsequent_fragments+0x1c4>
         {
         case IPREASM_DROP_FRAG_DUPLICATE:
            /* this isn't really an error, since it indicates that the received 
             * fragment's information is a duplicate of what is present in the 
             * already queued fragments */
            return IPREASM_OK;
 8241c10:	0005883a 	mov	r2,zero
 8241c14:	0000d806 	br	8241f78 <ip_reasm_process_subsequent_fragments+0x51c>
         case IPREASM_DROP_FRAG_BAD_PARAM:
            /* this is a real error */
            return ENP_PARAM;
 8241c18:	00bffd84 	movi	r2,-10
 8241c1c:	0000d606 	br	8241f78 <ip_reasm_process_subsequent_fragments+0x51c>
          * Altera Niche Stack Nios port modification:
          * Handle IPREASM_ACCEPT_FRAG case (will never
          * get here per if() above) to remove build warning.
          */
         case IPREASM_ACCEPT_FRAG:
            while(0);
 8241c20:	0001883a 	nop
      }

   /* this is a fragment from an existing fragment stream; 
    * check for resource limits before accepting it.  For now
    * assume that an extra RFQ is not required. */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen)) != IPREASM_OK)
 8241c24:	e0bffe17 	ldw	r2,-8(fp)
 8241c28:	10800217 	ldw	r2,8(r2)
 8241c2c:	10bfffcc 	andi	r2,r2,65535
 8241c30:	1009883a 	mov	r4,r2
 8241c34:	8240fec0 	call	8240fec <ip_reasm_check_mem_useage>
 8241c38:	e0bff915 	stw	r2,-28(fp)
 8241c3c:	e0bff917 	ldw	r2,-28(fp)
 8241c40:	10001126 	beq	r2,zero,8241c88 <ip_reasm_process_subsequent_fragments+0x22c>
      {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 8241c44:	01000084 	movi	r4,2
 8241c48:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free (p);
 8241c4c:	e13ffe17 	ldw	r4,-8(fp)
 8241c50:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241c54:	01000084 	movi	r4,2
 8241c58:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      ip_reasm_delete_ire (irep);
 8241c5c:	e13fff17 	ldw	r4,-4(fp)
 8241c60:	82424080 	call	8242408 <ip_reasm_delete_ire>
      ++ip_mib.ipReasmFails;
 8241c64:	008209b4 	movhi	r2,2086
 8241c68:	10ba6a04 	addi	r2,r2,-5720
 8241c6c:	10800f17 	ldw	r2,60(r2)
 8241c70:	10c00044 	addi	r3,r2,1
 8241c74:	008209b4 	movhi	r2,2086
 8241c78:	10ba6a04 	addi	r2,r2,-5720
 8241c7c:	10c00f15 	stw	r3,60(r2)
      return rc;
 8241c80:	e0bff917 	ldw	r2,-28(fp)
 8241c84:	0000bc06 	br	8241f78 <ip_reasm_process_subsequent_fragments+0x51c>

   /* the two combinations of index and rfqp are as follows:
    * (1) index = INVALID_FRAG_INDEX, rfqp = non-zero: no empty slot found in RFQ(s),
    *     and rfqp points to the last RFQ that was processed
    * (2) index != INVALID_FRAG_INDEX, rfqp = non-zero: empty slot found in RFQ(s) */
   if (index != INVALID_FRAG_INDEX)
 8241c88:	e0bffb0b 	ldhu	r2,-20(fp)
 8241c8c:	10bfffcc 	andi	r2,r2,65535
 8241c90:	10800420 	cmpeqi	r2,r2,16
 8241c94:	1000121e 	bne	r2,zero,8241ce0 <ip_reasm_process_subsequent_fragments+0x284>
      {
      /* we have an empty slot in the PACKET array into which we can place 
       * the just received fragment */
      rfqp->bufp[index] = p;
 8241c98:	e0fffc17 	ldw	r3,-16(fp)
 8241c9c:	e0bffb0b 	ldhu	r2,-20(fp)
 8241ca0:	10bfffcc 	andi	r2,r2,65535
 8241ca4:	10800044 	addi	r2,r2,1
 8241ca8:	1085883a 	add	r2,r2,r2
 8241cac:	1085883a 	add	r2,r2,r2
 8241cb0:	1885883a 	add	r2,r3,r2
 8241cb4:	e0fffe17 	ldw	r3,-8(fp)
 8241cb8:	10c00015 	stw	r3,0(r2)
      rfqp->frag_offset[index] = frag_offset;
 8241cbc:	e13ffc17 	ldw	r4,-16(fp)
 8241cc0:	e0bffb0b 	ldhu	r2,-20(fp)
 8241cc4:	10bfffcc 	andi	r2,r2,65535
 8241cc8:	e0fffd0b 	ldhu	r3,-12(fp)
 8241ccc:	10800884 	addi	r2,r2,34
 8241cd0:	1085883a 	add	r2,r2,r2
 8241cd4:	2085883a 	add	r2,r4,r2
 8241cd8:	10c0000d 	sth	r3,0(r2)
 8241cdc:	00003906 	br	8241dc4 <ip_reasm_process_subsequent_fragments+0x368>
      }
   else
      {
      /* since we need to allocate an extra RFQ, check for memory useage again... */
      if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (RFQ)))) != IPREASM_OK)
 8241ce0:	e0bffe17 	ldw	r2,-8(fp)
 8241ce4:	10800217 	ldw	r2,8(r2)
 8241ce8:	10801904 	addi	r2,r2,100
 8241cec:	10bfffcc 	andi	r2,r2,65535
 8241cf0:	1009883a 	mov	r4,r2
 8241cf4:	8240fec0 	call	8240fec <ip_reasm_check_mem_useage>
 8241cf8:	e0bff915 	stw	r2,-28(fp)
 8241cfc:	e0bff917 	ldw	r2,-28(fp)
 8241d00:	10001126 	beq	r2,zero,8241d48 <ip_reasm_process_subsequent_fragments+0x2ec>
         {
         LOCK_NET_RESOURCE (FREEQ_RESID);
 8241d04:	01000084 	movi	r4,2
 8241d08:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free (p);
 8241d0c:	e13ffe17 	ldw	r4,-8(fp)
 8241d10:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241d14:	01000084 	movi	r4,2
 8241d18:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 8241d1c:	e13fff17 	ldw	r4,-4(fp)
 8241d20:	82424080 	call	8242408 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 8241d24:	008209b4 	movhi	r2,2086
 8241d28:	10ba6a04 	addi	r2,r2,-5720
 8241d2c:	10800f17 	ldw	r2,60(r2)
 8241d30:	10c00044 	addi	r3,r2,1
 8241d34:	008209b4 	movhi	r2,2086
 8241d38:	10ba6a04 	addi	r2,r2,-5720
 8241d3c:	10c00f15 	stw	r3,60(r2)
         return rc;
 8241d40:	e0bff917 	ldw	r2,-28(fp)
 8241d44:	00008c06 	br	8241f78 <ip_reasm_process_subsequent_fragments+0x51c>
         }

      /* no slots are available in the one (or more) existing RFQs; we 
       * need to create a new RFQ to store the just received fragment */
      new_rfqp = (RFQP) IPR_ALLOC (sizeof(RFQ));
 8241d48:	01001904 	movi	r4,100
 8241d4c:	822dfec0 	call	822dfec <npalloc>
 8241d50:	e0bff515 	stw	r2,-44(fp)
      if (new_rfqp == 0)
 8241d54:	e0bff517 	ldw	r2,-44(fp)
 8241d58:	1000111e 	bne	r2,zero,8241da0 <ip_reasm_process_subsequent_fragments+0x344>
         {
         /* can't store the existing fragment, so we'll drop it */
         LOCK_NET_RESOURCE (FREEQ_RESID);
 8241d5c:	01000084 	movi	r4,2
 8241d60:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free (p);
 8241d64:	e13ffe17 	ldw	r4,-8(fp)
 8241d68:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241d6c:	01000084 	movi	r4,2
 8241d70:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 8241d74:	e13fff17 	ldw	r4,-4(fp)
 8241d78:	82424080 	call	8242408 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 8241d7c:	008209b4 	movhi	r2,2086
 8241d80:	10ba6a04 	addi	r2,r2,-5720
 8241d84:	10800f17 	ldw	r2,60(r2)
 8241d88:	10c00044 	addi	r3,r2,1
 8241d8c:	008209b4 	movhi	r2,2086
 8241d90:	10ba6a04 	addi	r2,r2,-5720
 8241d94:	10c00f15 	stw	r3,60(r2)
         return ENP_RESOURCE;
 8241d98:	00bffa84 	movi	r2,-22
 8241d9c:	00007606 	br	8241f78 <ip_reasm_process_subsequent_fragments+0x51c>
         }
      else
         {
         new_rfqp->bufp[0] = p;
 8241da0:	e0bff517 	ldw	r2,-44(fp)
 8241da4:	e0fffe17 	ldw	r3,-8(fp)
 8241da8:	10c00115 	stw	r3,4(r2)
         new_rfqp->frag_offset[0] = frag_offset;
 8241dac:	e0fffd0b 	ldhu	r3,-12(fp)
 8241db0:	e0bff517 	ldw	r2,-44(fp)
 8241db4:	10c0110d 	sth	r3,68(r2)
         rfqp->next = new_rfqp;
 8241db8:	e0bffc17 	ldw	r2,-16(fp)
 8241dbc:	e0fff517 	ldw	r3,-44(fp)
 8241dc0:	10c00015 	stw	r3,0(r2)
         }
      }
      
      /* check to see if the RFQ is still compact, but only if hole(s) were created 
       * in ip_reasm_compute_overlap () */
      if (hole_created)
 8241dc4:	e0bffd83 	ldbu	r2,-10(fp)
 8241dc8:	10803fcc 	andi	r2,r2,255
 8241dcc:	10001426 	beq	r2,zero,8241e20 <ip_reasm_process_subsequent_fragments+0x3c4>
         {
         if ((rc = ip_reasm_mark_compact_rfq (irep)) != IPREASM_OK)
 8241dd0:	e13fff17 	ldw	r4,-4(fp)
 8241dd4:	82425bc0 	call	82425bc <ip_reasm_mark_compact_rfq>
 8241dd8:	e0bff915 	stw	r2,-28(fp)
 8241ddc:	e0bff917 	ldw	r2,-28(fp)
 8241de0:	10000f26 	beq	r2,zero,8241e20 <ip_reasm_process_subsequent_fragments+0x3c4>
            {
            /* an error return is due to a bad IRE pointer, which ip_reasm_mark_compact_rfq () logs */
            LOCK_NET_RESOURCE (FREEQ_RESID);
 8241de4:	01000084 	movi	r4,2
 8241de8:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
            pk_free (p);
 8241dec:	e13ffe17 	ldw	r4,-8(fp)
 8241df0:	822cbbc0 	call	822cbbc <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241df4:	01000084 	movi	r4,2
 8241df8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
            ++ip_mib.ipReasmFails;
 8241dfc:	008209b4 	movhi	r2,2086
 8241e00:	10ba6a04 	addi	r2,r2,-5720
 8241e04:	10800f17 	ldw	r2,60(r2)
 8241e08:	10c00044 	addi	r3,r2,1
 8241e0c:	008209b4 	movhi	r2,2086
 8241e10:	10ba6a04 	addi	r2,r2,-5720
 8241e14:	10c00f15 	stw	r3,60(r2)
            return rc;
 8241e18:	e0bff917 	ldw	r2,-28(fp)
 8241e1c:	00005606 	br	8241f78 <ip_reasm_process_subsequent_fragments+0x51c>

   /* compute the total number of bytes queued in this IRE.  Note 
    * that the RHS has been updated to reflect the amount of "unique"
    * data in the just received fragment (the IP header has been dropped,
    * and perhaps additional duplicate data too (if present)) */
   irep->rcvd += (u_short) (p->nb_plen);
 8241e20:	e0bfff17 	ldw	r2,-4(fp)
 8241e24:	1080048b 	ldhu	r2,18(r2)
 8241e28:	e0fffe17 	ldw	r3,-8(fp)
 8241e2c:	18c00417 	ldw	r3,16(r3)
 8241e30:	10c5883a 	add	r2,r2,r3
 8241e34:	1007883a 	mov	r3,r2
 8241e38:	e0bfff17 	ldw	r2,-4(fp)
 8241e3c:	10c0048d 	sth	r3,18(r2)
   ip_reasm_incr_mem_useage (p->nb_blen + ((new_rfqp == 0) ? 0 : (sizeof(RFQ))));
 8241e40:	e0bffe17 	ldw	r2,-8(fp)
 8241e44:	10800217 	ldw	r2,8(r2)
 8241e48:	1007883a 	mov	r3,r2
 8241e4c:	e0bff517 	ldw	r2,-44(fp)
 8241e50:	1000021e 	bne	r2,zero,8241e5c <ip_reasm_process_subsequent_fragments+0x400>
 8241e54:	0005883a 	mov	r2,zero
 8241e58:	00000106 	br	8241e60 <ip_reasm_process_subsequent_fragments+0x404>
 8241e5c:	00801904 	movi	r2,100
 8241e60:	1885883a 	add	r2,r3,r2
 8241e64:	10bfffcc 	andi	r2,r2,65535
 8241e68:	1009883a 	mov	r4,r2
 8241e6c:	82410800 	call	8241080 <ip_reasm_incr_mem_useage>

   if (irep->length != 0)
 8241e70:	e0bfff17 	ldw	r2,-4(fp)
 8241e74:	1080040b 	ldhu	r2,16(r2)
 8241e78:	10bfffcc 	andi	r2,r2,65535
 8241e7c:	10003d26 	beq	r2,zero,8241f74 <ip_reasm_process_subsequent_fragments+0x518>
      {
      /* we know the total length of the original unfragmented datagram; 
       * let's check to see if we have all of the bytes... */
      if (irep->rcvd == irep->length)
 8241e80:	e0bfff17 	ldw	r2,-4(fp)
 8241e84:	10c0048b 	ldhu	r3,18(r2)
 8241e88:	e0bfff17 	ldw	r2,-4(fp)
 8241e8c:	1080040b 	ldhu	r2,16(r2)
 8241e90:	18ffffcc 	andi	r3,r3,65535
 8241e94:	10bfffcc 	andi	r2,r2,65535
 8241e98:	1880361e 	bne	r3,r2,8241f74 <ip_reasm_process_subsequent_fragments+0x518>
          * Ensure that we allocate space for the data link header, IP header, 
          * and the payload of the original, unfragmented datagram.  We pick 
          * the data link layer and IP headers from the First Fragment (FF), 
          * but we need to adjust some of the fields in the IP header after 
          * reassembly is complete. */
         pip = (struct ip *) irep->l3_hdr;
 8241e9c:	e0bfff17 	ldw	r2,-4(fp)
 8241ea0:	10802017 	ldw	r2,128(r2)
 8241ea4:	e0bff615 	stw	r2,-40(fp)
         LOCK_NET_RESOURCE (FREEQ_RESID);
 8241ea8:	01000084 	movi	r4,2
 8241eac:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         reassy_pkt = pk_alloc (irep->length + (irep->l3_hdr - irep->l2_hdr) + ip_hlen (pip));
 8241eb0:	e0bfff17 	ldw	r2,-4(fp)
 8241eb4:	1080040b 	ldhu	r2,16(r2)
 8241eb8:	10ffffcc 	andi	r3,r2,65535
 8241ebc:	e0bfff17 	ldw	r2,-4(fp)
 8241ec0:	10802017 	ldw	r2,128(r2)
 8241ec4:	1009883a 	mov	r4,r2
 8241ec8:	e0bfff17 	ldw	r2,-4(fp)
 8241ecc:	10801f17 	ldw	r2,124(r2)
 8241ed0:	2085c83a 	sub	r2,r4,r2
 8241ed4:	1887883a 	add	r3,r3,r2
 8241ed8:	e0bff617 	ldw	r2,-40(fp)
 8241edc:	10800003 	ldbu	r2,0(r2)
 8241ee0:	10803fcc 	andi	r2,r2,255
 8241ee4:	108003cc 	andi	r2,r2,15
 8241ee8:	1085883a 	add	r2,r2,r2
 8241eec:	1085883a 	add	r2,r2,r2
 8241ef0:	1885883a 	add	r2,r3,r2
 8241ef4:	1009883a 	mov	r4,r2
 8241ef8:	822c86c0 	call	822c86c <pk_alloc>
 8241efc:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8241f00:	01000084 	movi	r4,2
 8241f04:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         if (reassy_pkt == 0)
 8241f08:	e0bffa17 	ldw	r2,-24(fp)
 8241f0c:	10000b1e 	bne	r2,zero,8241f3c <ip_reasm_process_subsequent_fragments+0x4e0>
            {
            /* the following call will delete all queued fragments, including
             * the currently received one */
            ip_reasm_delete_ire (irep);
 8241f10:	e13fff17 	ldw	r4,-4(fp)
 8241f14:	82424080 	call	8242408 <ip_reasm_delete_ire>
            ++ip_mib.ipReasmFails;
 8241f18:	008209b4 	movhi	r2,2086
 8241f1c:	10ba6a04 	addi	r2,r2,-5720
 8241f20:	10800f17 	ldw	r2,60(r2)
 8241f24:	10c00044 	addi	r3,r2,1
 8241f28:	008209b4 	movhi	r2,2086
 8241f2c:	10ba6a04 	addi	r2,r2,-5720
 8241f30:	10c00f15 	stw	r3,60(r2)
            return ENP_NOBUFFER;
 8241f34:	00bffac4 	movi	r2,-21
 8241f38:	00000f06 	br	8241f78 <ip_reasm_process_subsequent_fragments+0x51c>
            }
         else
            {
            ip_reasm_copy_queued_fragments_into_reassy_buffer (reassy_pkt, irep);
 8241f3c:	e17fff17 	ldw	r5,-4(fp)
 8241f40:	e13ffa17 	ldw	r4,-24(fp)
 8241f44:	8241fe40 	call	8241fe4 <ip_reasm_copy_queued_fragments_into_reassy_buffer>
            /* free the IRE structure (and its constituent elements) */
            ip_reasm_delete_ire (irep);
 8241f48:	e13fff17 	ldw	r4,-4(fp)
 8241f4c:	82424080 	call	8242408 <ip_reasm_delete_ire>
            /* at this point, 'irep' is no longer a valid pointer, and so should 
             * not be referenced.  We're done, and we now pass the packet for 
             * demux'ing to the appropriate entity (e.g., UDP, TCP, etc.).  Note
             * that ip_demux () expects 'nb_prot' to point to the beginning of 
             * the IP header. */
            ++ip_mib.ipReasmOKs;
 8241f50:	008209b4 	movhi	r2,2086
 8241f54:	10ba6a04 	addi	r2,r2,-5720
 8241f58:	10800e17 	ldw	r2,56(r2)
 8241f5c:	10c00044 	addi	r3,r2,1
 8241f60:	008209b4 	movhi	r2,2086
 8241f64:	10ba6a04 	addi	r2,r2,-5720
 8241f68:	10c00e15 	stw	r3,56(r2)
            ip_demux (reassy_pkt);
 8241f6c:	e13ffa17 	ldw	r4,-24(fp)
 8241f70:	82433cc0 	call	82433cc <ip_demux>
      {
      /* we haven't received the LF (so we don't know the total amount of data in 
       * the original, unfragmented datagram), and therefore reassembly can't complete yet */
      }

   return IPREASM_OK;
 8241f74:	0005883a 	mov	r2,zero
}
 8241f78:	e037883a 	mov	sp,fp
 8241f7c:	dfc00117 	ldw	ra,4(sp)
 8241f80:	df000017 	ldw	fp,0(sp)
 8241f84:	dec00204 	addi	sp,sp,8
 8241f88:	f800283a 	ret

08241f8c <ip_reasm_find_ire>:
OUTPUT: This function returns a IPREASM_TRUE if the IRE exists in the master 
IRE list; otherwise, it returns a IPREASM_FALSE.
*/

u_char ip_reasm_find_ire (IREP irep)
{
 8241f8c:	defffd04 	addi	sp,sp,-12
 8241f90:	df000215 	stw	fp,8(sp)
 8241f94:	df000204 	addi	fp,sp,8
 8241f98:	e13fff15 	stw	r4,-4(fp)
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8241f9c:	d0a0c817 	ldw	r2,-31968(gp)
 8241fa0:	e0bffe15 	stw	r2,-8(fp)
 8241fa4:	00000806 	br	8241fc8 <ip_reasm_find_ire+0x3c>
      {
      if (tmpp == irep) 
 8241fa8:	e0fffe17 	ldw	r3,-8(fp)
 8241fac:	e0bfff17 	ldw	r2,-4(fp)
 8241fb0:	1880021e 	bne	r3,r2,8241fbc <ip_reasm_find_ire+0x30>
         {
         return IPREASM_TRUE;
 8241fb4:	00800044 	movi	r2,1
 8241fb8:	00000606 	br	8241fd4 <ip_reasm_find_ire+0x48>
u_char ip_reasm_find_ire (IREP irep)
{
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8241fbc:	e0bffe17 	ldw	r2,-8(fp)
 8241fc0:	10800017 	ldw	r2,0(r2)
 8241fc4:	e0bffe15 	stw	r2,-8(fp)
 8241fc8:	e0bffe17 	ldw	r2,-8(fp)
 8241fcc:	103ff61e 	bne	r2,zero,8241fa8 <ip_reasm_find_ire+0x1c>
         {
         return IPREASM_TRUE;
         }
      }

   return IPREASM_FALSE;
 8241fd0:	0005883a 	mov	r2,zero
}
 8241fd4:	e037883a 	mov	sp,fp
 8241fd8:	df000017 	ldw	fp,0(sp)
 8241fdc:	dec00104 	addi	sp,sp,4
 8241fe0:	f800283a 	ret

08241fe4 <ip_reasm_copy_queued_fragments_into_reassy_buffer>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_copy_queued_fragments_into_reassy_buffer (PACKET reassy_pkt, IREP irep)
{
 8241fe4:	defff504 	addi	sp,sp,-44
 8241fe8:	dfc00a15 	stw	ra,40(sp)
 8241fec:	df000915 	stw	fp,36(sp)
 8241ff0:	df000904 	addi	fp,sp,36
 8241ff4:	e13ffe15 	stw	r4,-8(fp)
 8241ff8:	e17fff15 	stw	r5,-4(fp)
   RFQP rfqp;
   u_short i;
   PACKET p;
   u_char iphlen;
   char * writep;
   PACKET sav_pkt = 0;
 8241ffc:	e03ff915 	stw	zero,-28(fp)

   pip = (struct ip *) irep->l3_hdr;
 8242000:	e0bfff17 	ldw	r2,-4(fp)
 8242004:	10802017 	ldw	r2,128(r2)
 8242008:	e0bffa15 	stw	r2,-24(fp)
   iphlen = ip_hlen (pip);
 824200c:	e0bffa17 	ldw	r2,-24(fp)
 8242010:	10800003 	ldbu	r2,0(r2)
 8242014:	108003cc 	andi	r2,r2,15
 8242018:	1085883a 	add	r2,r2,r2
 824201c:	1085883a 	add	r2,r2,r2
 8242020:	e0bffb05 	stb	r2,-20(fp)

   /* copy the data link and IP layer headers into place.  These headers are 
    * from the First Fragment (FF). */
   offset = (u_char) ((irep->l3_hdr - irep->l2_hdr) + iphlen);
 8242024:	e0bfff17 	ldw	r2,-4(fp)
 8242028:	10802017 	ldw	r2,128(r2)
 824202c:	1007883a 	mov	r3,r2
 8242030:	e0bfff17 	ldw	r2,-4(fp)
 8242034:	10801f17 	ldw	r2,124(r2)
 8242038:	1885c83a 	sub	r2,r3,r2
 824203c:	1007883a 	mov	r3,r2
 8242040:	e0bffb03 	ldbu	r2,-20(fp)
 8242044:	1885883a 	add	r2,r3,r2
 8242048:	e0bffb45 	stb	r2,-19(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);
 824204c:	e0bffe17 	ldw	r2,-8(fp)
 8242050:	10c00117 	ldw	r3,4(r2)
 8242054:	e0bfff17 	ldw	r2,-4(fp)
 8242058:	10801f17 	ldw	r2,124(r2)
 824205c:	e13ffb43 	ldbu	r4,-19(fp)
 8242060:	200d883a 	mov	r6,r4
 8242064:	100b883a 	mov	r5,r2
 8242068:	1809883a 	mov	r4,r3
 824206c:	8202e8c0 	call	8202e8c <memcpy>

   rfqp = &(irep->rfq);
 8242070:	e0bfff17 	ldw	r2,-4(fp)
 8242074:	10800604 	addi	r2,r2,24
 8242078:	e0bff715 	stw	r2,-36(fp)
   writep = reassy_pkt->nb_buff + offset;
 824207c:	e0bffe17 	ldw	r2,-8(fp)
 8242080:	10c00117 	ldw	r3,4(r2)
 8242084:	e0bffb43 	ldbu	r2,-19(fp)
 8242088:	1885883a 	add	r2,r3,r2
 824208c:	e0bffc15 	stw	r2,-16(fp)

   while (rfqp)
 8242090:	00004506 	br	82421a8 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1c4>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242094:	e03ff80d 	sth	zero,-32(fp)
 8242098:	00003b06 	br	8242188 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1a4>
         {
         if ((p = rfqp->bufp [i]) != 0)
 824209c:	e0bff80b 	ldhu	r2,-32(fp)
 82420a0:	e0fff717 	ldw	r3,-36(fp)
 82420a4:	10800044 	addi	r2,r2,1
 82420a8:	1085883a 	add	r2,r2,r2
 82420ac:	1085883a 	add	r2,r2,r2
 82420b0:	1885883a 	add	r2,r3,r2
 82420b4:	10800017 	ldw	r2,0(r2)
 82420b8:	e0bffd15 	stw	r2,-12(fp)
 82420bc:	e0bffd17 	ldw	r2,-12(fp)
 82420c0:	10002926 	beq	r2,zero,8242168 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x184>
            {
            /* note that rfqp->frag_offset[i] is the true value of the offset field, 
             * and does not require any scaling (like the Fragment Offset field in 
             * the IP header) */
            MEMCPY((writep + rfqp->frag_offset[i]), p->nb_prot, p->nb_plen);
 82420c4:	e0bff80b 	ldhu	r2,-32(fp)
 82420c8:	e0fff717 	ldw	r3,-36(fp)
 82420cc:	10800884 	addi	r2,r2,34
 82420d0:	1085883a 	add	r2,r2,r2
 82420d4:	1885883a 	add	r2,r3,r2
 82420d8:	1080000b 	ldhu	r2,0(r2)
 82420dc:	10bfffcc 	andi	r2,r2,65535
 82420e0:	e0fffc17 	ldw	r3,-16(fp)
 82420e4:	1887883a 	add	r3,r3,r2
 82420e8:	e0bffd17 	ldw	r2,-12(fp)
 82420ec:	11000317 	ldw	r4,12(r2)
 82420f0:	e0bffd17 	ldw	r2,-12(fp)
 82420f4:	10800417 	ldw	r2,16(r2)
 82420f8:	100d883a 	mov	r6,r2
 82420fc:	200b883a 	mov	r5,r4
 8242100:	1809883a 	mov	r4,r3
 8242104:	8202e8c0 	call	8202e8c <memcpy>
            /* free fragment after we've copied data out from it (unless we need to
             * save it so that we can copy some fields from it later (after exiting 
             * from the loop)) */
            if (!sav_pkt) sav_pkt = p;
 8242108:	e0bff917 	ldw	r2,-28(fp)
 824210c:	1000031e 	bne	r2,zero,824211c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x138>
 8242110:	e0bffd17 	ldw	r2,-12(fp)
 8242114:	e0bff915 	stw	r2,-28(fp)
 8242118:	00000b06 	br	8242148 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x164>
            else
               {
               ip_reasm_decr_mem_useage (p->nb_blen);
 824211c:	e0bffd17 	ldw	r2,-12(fp)
 8242120:	10800217 	ldw	r2,8(r2)
 8242124:	10bfffcc 	andi	r2,r2,65535
 8242128:	1009883a 	mov	r4,r2
 824212c:	82411200 	call	8241120 <ip_reasm_decr_mem_useage>
               LOCK_NET_RESOURCE (FREEQ_RESID);
 8242130:	01000084 	movi	r4,2
 8242134:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
               pk_free (p);
 8242138:	e13ffd17 	ldw	r4,-12(fp)
 824213c:	822cbbc0 	call	822cbbc <pk_free>
               UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8242140:	01000084 	movi	r4,2
 8242144:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
               }
            /* since we're done with the packet, mark slot as unused */
            rfqp->bufp [i] = 0;
 8242148:	e0bff80b 	ldhu	r2,-32(fp)
 824214c:	e0fff717 	ldw	r3,-36(fp)
 8242150:	10800044 	addi	r2,r2,1
 8242154:	1085883a 	add	r2,r2,r2
 8242158:	1085883a 	add	r2,r2,r2
 824215c:	1885883a 	add	r2,r3,r2
 8242160:	10000015 	stw	zero,0(r2)
 8242164:	00000506 	br	824217c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x198>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 8242168:	e0bfff17 	ldw	r2,-4(fp)
 824216c:	10802103 	ldbu	r2,132(r2)
 8242170:	10803fcc 	andi	r2,r2,255
 8242174:	1080004c 	andi	r2,r2,1
 8242178:	1000071e 	bne	r2,zero,8242198 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b4>
   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 824217c:	e0bff80b 	ldhu	r2,-32(fp)
 8242180:	10800044 	addi	r2,r2,1
 8242184:	e0bff80d 	sth	r2,-32(fp)
 8242188:	e0bff80b 	ldhu	r2,-32(fp)
 824218c:	10800430 	cmpltui	r2,r2,16
 8242190:	103fc21e 	bne	r2,zero,824209c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb8>
 8242194:	00000106 	br	824219c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b8>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 8242198:	0001883a 	nop
               }
            }
          }

      rfqp = rfqp->next;
 824219c:	e0bff717 	ldw	r2,-36(fp)
 82421a0:	10800017 	ldw	r2,0(r2)
 82421a4:	e0bff715 	stw	r2,-36(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);

   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
 82421a8:	e0bff717 	ldw	r2,-36(fp)
 82421ac:	103fb91e 	bne	r2,zero,8242094 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb0>
      }

   /* update various fields in the reassembled packet.  Some fields will be 
    * picked from one of the constituent fragments (sav_pkt) which hasn't
    * been deleted yet. */
   reassy_pkt->nb_prot = reassy_pkt->nb_buff + (irep->l3_hdr - irep->l2_hdr);
 82421b0:	e0bffe17 	ldw	r2,-8(fp)
 82421b4:	10800117 	ldw	r2,4(r2)
 82421b8:	e0ffff17 	ldw	r3,-4(fp)
 82421bc:	18c02017 	ldw	r3,128(r3)
 82421c0:	1809883a 	mov	r4,r3
 82421c4:	e0ffff17 	ldw	r3,-4(fp)
 82421c8:	18c01f17 	ldw	r3,124(r3)
 82421cc:	20c7c83a 	sub	r3,r4,r3
 82421d0:	10c7883a 	add	r3,r2,r3
 82421d4:	e0bffe17 	ldw	r2,-8(fp)
 82421d8:	10c00315 	stw	r3,12(r2)
   reassy_pkt->nb_plen = irep->length + iphlen;
 82421dc:	e0bfff17 	ldw	r2,-4(fp)
 82421e0:	1080040b 	ldhu	r2,16(r2)
 82421e4:	10ffffcc 	andi	r3,r2,65535
 82421e8:	e0bffb03 	ldbu	r2,-20(fp)
 82421ec:	1885883a 	add	r2,r3,r2
 82421f0:	1007883a 	mov	r3,r2
 82421f4:	e0bffe17 	ldw	r2,-8(fp)
 82421f8:	10c00415 	stw	r3,16(r2)
   reassy_pkt->nb_tstamp = cticks;
 82421fc:	d0a0a817 	ldw	r2,-32096(gp)
 8242200:	1007883a 	mov	r3,r2
 8242204:	e0bffe17 	ldw	r2,-8(fp)
 8242208:	10c00515 	stw	r3,20(r2)
   reassy_pkt->flags |= ((sav_pkt->flags) & (PKF_BCAST | PKF_MCAST));
 824220c:	e0bffe17 	ldw	r2,-8(fp)
 8242210:	10c00a17 	ldw	r3,40(r2)
 8242214:	e0bff917 	ldw	r2,-28(fp)
 8242218:	10800a17 	ldw	r2,40(r2)
 824221c:	108000cc 	andi	r2,r2,3
 8242220:	1886b03a 	or	r3,r3,r2
 8242224:	e0bffe17 	ldw	r2,-8(fp)
 8242228:	10c00a15 	stw	r3,40(r2)
   reassy_pkt->net = sav_pkt->net;
 824222c:	e0bff917 	ldw	r2,-28(fp)
 8242230:	10c00617 	ldw	r3,24(r2)
 8242234:	e0bffe17 	ldw	r2,-8(fp)
 8242238:	10c00615 	stw	r3,24(r2)
   reassy_pkt->type = sav_pkt->type;
 824223c:	e0bff917 	ldw	r2,-28(fp)
 8242240:	10c0080b 	ldhu	r3,32(r2)
 8242244:	e0bffe17 	ldw	r2,-8(fp)
 8242248:	10c0080d 	sth	r3,32(r2)
   /* fhost is set by ip_demux () before handing off to the packet to its 
    * intended destination (protocol) */

   /* free the saved packet too, since we don't need it anymore */
   ip_reasm_decr_mem_useage (sav_pkt->nb_blen);
 824224c:	e0bff917 	ldw	r2,-28(fp)
 8242250:	10800217 	ldw	r2,8(r2)
 8242254:	10bfffcc 	andi	r2,r2,65535
 8242258:	1009883a 	mov	r4,r2
 824225c:	82411200 	call	8241120 <ip_reasm_decr_mem_useage>
   LOCK_NET_RESOURCE (FREEQ_RESID);
 8242260:	01000084 	movi	r4,2
 8242264:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   pk_free (sav_pkt);
 8242268:	e13ff917 	ldw	r4,-28(fp)
 824226c:	822cbbc0 	call	822cbbc <pk_free>
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 8242270:	01000084 	movi	r4,2
 8242274:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   /* after the reassembly is complete, we update the following fields in
    * the IP header: Total Length, Flags/Fragment Offset, header checksum */
   pip = ip_head(reassy_pkt);
 8242278:	e0bffe17 	ldw	r2,-8(fp)
 824227c:	10800317 	ldw	r2,12(r2)
 8242280:	e0bffa15 	stw	r2,-24(fp)
   pip->ip_len = htons(reassy_pkt->nb_plen);
 8242284:	e0bffe17 	ldw	r2,-8(fp)
 8242288:	10800417 	ldw	r2,16(r2)
 824228c:	1004d23a 	srli	r2,r2,8
 8242290:	10803fcc 	andi	r2,r2,255
 8242294:	1007883a 	mov	r3,r2
 8242298:	e0bffe17 	ldw	r2,-8(fp)
 824229c:	10800417 	ldw	r2,16(r2)
 82422a0:	1004923a 	slli	r2,r2,8
 82422a4:	1884b03a 	or	r2,r3,r2
 82422a8:	1007883a 	mov	r3,r2
 82422ac:	e0bffa17 	ldw	r2,-24(fp)
 82422b0:	10c0008d 	sth	r3,2(r2)
   /* turn off More Fragments (MF) bit; the DF bit stays unchanged */
   pip->ip_flgs_foff &= htons(~((u_short) IP_FLG_MF));
 82422b4:	e0bffa17 	ldw	r2,-24(fp)
 82422b8:	10c0018b 	ldhu	r3,6(r2)
 82422bc:	00bff7c4 	movi	r2,-33
 82422c0:	1884703a 	and	r2,r3,r2
 82422c4:	1007883a 	mov	r3,r2
 82422c8:	e0bffa17 	ldw	r2,-24(fp)
 82422cc:	10c0018d 	sth	r3,6(r2)
   /* clear the Fragment Offset bits */
   pip->ip_flgs_foff &= htons(~((u_short) IP_EXTRACT_FOFF)); 
 82422d0:	e0bffa17 	ldw	r2,-24(fp)
 82422d4:	1080018b 	ldhu	r2,6(r2)
 82422d8:	1080380c 	andi	r2,r2,224
 82422dc:	1007883a 	mov	r3,r2
 82422e0:	e0bffa17 	ldw	r2,-24(fp)
 82422e4:	10c0018d 	sth	r3,6(r2)
   /* the following isn't really required, and can be removed */
   pip->ip_chksum = IPXSUM;
 82422e8:	e0bffa17 	ldw	r2,-24(fp)
 82422ec:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum (pip, (iphlen/2));
 82422f0:	e0bffb03 	ldbu	r2,-20(fp)
 82422f4:	1004d07a 	srli	r2,r2,1
 82422f8:	10803fcc 	andi	r2,r2,255
 82422fc:	100b883a 	mov	r5,r2
 8242300:	e13ffa17 	ldw	r4,-24(fp)
 8242304:	82286f00 	call	82286f0 <cksum>
 8242308:	0084303a 	nor	r2,zero,r2
 824230c:	1007883a 	mov	r3,r2
 8242310:	e0bffa17 	ldw	r2,-24(fp)
 8242314:	10c0028d 	sth	r3,10(r2)

   return IPREASM_OK;
 8242318:	0005883a 	mov	r2,zero
}
 824231c:	e037883a 	mov	sp,fp
 8242320:	dfc00117 	ldw	ra,4(sp)
 8242324:	df000017 	ldw	fp,0(sp)
 8242328:	dec00204 	addi	sp,sp,8
 824232c:	f800283a 	ret

08242330 <ip_reasm_process_timer_tick>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_process_timer_tick (void)
{
 8242330:	defffc04 	addi	sp,sp,-16
 8242334:	dfc00315 	stw	ra,12(sp)
 8242338:	df000215 	stw	fp,8(sp)
 824233c:	df000204 	addi	fp,sp,8
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 8242340:	0009883a 	mov	r4,zero
 8242344:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 8242348:	d0a0c817 	ldw	r2,-31968(gp)
 824234c:	e0bffe15 	stw	r2,-8(fp)
 8242350:	00002006 	br	82423d4 <ip_reasm_process_timer_tick+0xa4>
      {
      /* save the next pointer for the IRE that may be deleted */
      nxt_tmpp = tmpp->next;
 8242354:	e0bffe17 	ldw	r2,-8(fp)
 8242358:	10800017 	ldw	r2,0(r2)
 824235c:	e0bfff15 	stw	r2,-4(fp)
      ++tmpp->age;
 8242360:	e0bffe17 	ldw	r2,-8(fp)
 8242364:	10800517 	ldw	r2,20(r2)
 8242368:	10c00044 	addi	r3,r2,1
 824236c:	e0bffe17 	ldw	r2,-8(fp)
 8242370:	10c00515 	stw	r3,20(r2)
      /* check to see if this entry has reached its max age (expired)? */
      if (tmpp->age == IRE_TMO)
 8242374:	e0bffe17 	ldw	r2,-8(fp)
 8242378:	10800517 	ldw	r2,20(r2)
 824237c:	10801e18 	cmpnei	r2,r2,120
 8242380:	1000121e 	bne	r2,zero,82423cc <ip_reasm_process_timer_tick+0x9c>
         {
         /* it has...and therefore must be deleted. */
         ++ire_stats.ire_timed_out;
 8242384:	008209b4 	movhi	r2,2086
 8242388:	10ba7e04 	addi	r2,r2,-5640
 824238c:	10800117 	ldw	r2,4(r2)
 8242390:	10c00044 	addi	r3,r2,1
 8242394:	008209b4 	movhi	r2,2086
 8242398:	10ba7e04 	addi	r2,r2,-5640
 824239c:	10c00115 	stw	r3,4(r2)
#ifdef FULL_ICMP
         /* send ICMP Time Exceeded message with code 1 ("fragment reassembly time exceeded") */
         ip_reasm_send_icmp_timex (tmpp);
 82423a0:	e13ffe17 	ldw	r4,-8(fp)
 82423a4:	8242a300 	call	8242a30 <ip_reasm_send_icmp_timex>
#endif
         ip_reasm_delete_ire (tmpp);
 82423a8:	e13ffe17 	ldw	r4,-8(fp)
 82423ac:	82424080 	call	8242408 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 82423b0:	008209b4 	movhi	r2,2086
 82423b4:	10ba6a04 	addi	r2,r2,-5720
 82423b8:	10800f17 	ldw	r2,60(r2)
 82423bc:	10c00044 	addi	r3,r2,1
 82423c0:	008209b4 	movhi	r2,2086
 82423c4:	10ba6a04 	addi	r2,r2,-5720
 82423c8:	10c00f15 	stw	r3,60(r2)
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 82423cc:	e0bfff17 	ldw	r2,-4(fp)
 82423d0:	e0bffe15 	stw	r2,-8(fp)
 82423d4:	e0bffe17 	ldw	r2,-8(fp)
 82423d8:	103fde1e 	bne	r2,zero,8242354 <ip_reasm_process_timer_tick+0x24>
         ++ip_mib.ipReasmFails;
         }
      }

   /* set the time for the next invocation of this routine (one second later) */
   ire_cticks = cticks + TPS;
 82423dc:	d0a0a817 	ldw	r2,-32096(gp)
 82423e0:	10801904 	addi	r2,r2,100
 82423e4:	d0a0c915 	stw	r2,-31964(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 82423e8:	0009883a 	mov	r4,zero
 82423ec:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   return IPREASM_OK;
 82423f0:	0005883a 	mov	r2,zero
}
 82423f4:	e037883a 	mov	sp,fp
 82423f8:	dfc00117 	ldw	ra,4(sp)
 82423fc:	df000017 	ldw	fp,0(sp)
 8242400:	dec00204 	addi	sp,sp,8
 8242404:	f800283a 	ret

08242408 <ip_reasm_delete_ire>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in the 
master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_delete_ire (IREP irep)
{
 8242408:	defff604 	addi	sp,sp,-40
 824240c:	dfc00915 	stw	ra,36(sp)
 8242410:	df000815 	stw	fp,32(sp)
 8242414:	df000804 	addi	fp,sp,32
 8242418:	e13fff15 	stw	r4,-4(fp)
   RFQP rfqp, first_rfqp, prev_rfqp;
   u_short i;
   PACKET p;
   IREP tmpp;
   IREP prev_tmpp = 0;
 824241c:	e03ffb15 	stw	zero,-20(fp)

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8242420:	d0a0c817 	ldw	r2,-31968(gp)
 8242424:	e0bffa15 	stw	r2,-24(fp)
 8242428:	00001406 	br	824247c <ip_reasm_delete_ire+0x74>
      {
      if (tmpp == irep) 
 824242c:	e0fffa17 	ldw	r3,-24(fp)
 8242430:	e0bfff17 	ldw	r2,-4(fp)
 8242434:	18800c1e 	bne	r3,r2,8242468 <ip_reasm_delete_ire+0x60>
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
 8242438:	d0a0c817 	ldw	r2,-31968(gp)
 824243c:	e0fffa17 	ldw	r3,-24(fp)
 8242440:	1880041e 	bne	r3,r2,8242454 <ip_reasm_delete_ire+0x4c>
 8242444:	e0bfff17 	ldw	r2,-4(fp)
 8242448:	10800017 	ldw	r2,0(r2)
 824244c:	d0a0c815 	stw	r2,-31968(gp)
         else prev_tmpp->next = irep->next;
         break;
 8242450:	00000c06 	br	8242484 <ip_reasm_delete_ire+0x7c>
      {
      if (tmpp == irep) 
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
         else prev_tmpp->next = irep->next;
 8242454:	e0bfff17 	ldw	r2,-4(fp)
 8242458:	10c00017 	ldw	r3,0(r2)
 824245c:	e0bffb17 	ldw	r2,-20(fp)
 8242460:	10c00015 	stw	r3,0(r2)
         break;
 8242464:	00000706 	br	8242484 <ip_reasm_delete_ire+0x7c>
         }
      prev_tmpp = tmpp;
 8242468:	e0bffa17 	ldw	r2,-24(fp)
 824246c:	e0bffb15 	stw	r2,-20(fp)
   IREP tmpp;
   IREP prev_tmpp = 0;

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 8242470:	e0bffa17 	ldw	r2,-24(fp)
 8242474:	10800017 	ldw	r2,0(r2)
 8242478:	e0bffa15 	stw	r2,-24(fp)
 824247c:	e0bffa17 	ldw	r2,-24(fp)
 8242480:	103fea1e 	bne	r2,zero,824242c <ip_reasm_delete_ire+0x24>
      prev_tmpp = tmpp;
      }

   /* if the IRE entry does not exist in the master table, return an error 
    * to the caller */
   if (!tmpp)
 8242484:	e0bffa17 	ldw	r2,-24(fp)
 8242488:	1000091e 	bne	r2,zero,82424b0 <ip_reasm_delete_ire+0xa8>
      {
      ++ire_stats.bad_irep;
 824248c:	008209b4 	movhi	r2,2086
 8242490:	10ba7e04 	addi	r2,r2,-5640
 8242494:	10800017 	ldw	r2,0(r2)
 8242498:	10c00044 	addi	r3,r2,1
 824249c:	008209b4 	movhi	r2,2086
 82424a0:	10ba7e04 	addi	r2,r2,-5640
 82424a4:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 82424a8:	00bffd84 	movi	r2,-10
 82424ac:	00003e06 	br	82425a8 <ip_reasm_delete_ire+0x1a0>
      }

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);
 82424b0:	e0bfff17 	ldw	r2,-4(fp)
 82424b4:	10800604 	addi	r2,r2,24
 82424b8:	e0bffc15 	stw	r2,-16(fp)
 82424bc:	e0bffc17 	ldw	r2,-16(fp)
 82424c0:	e0bff815 	stw	r2,-32(fp)

   while (rfqp)
 82424c4:	00003106 	br	824258c <ip_reasm_delete_ire+0x184>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 82424c8:	e03ff90d 	sth	zero,-28(fp)
 82424cc:	00001e06 	br	8242548 <ip_reasm_delete_ire+0x140>
         {
         if ((p = rfqp->bufp [i]) != 0)
 82424d0:	e0bff90b 	ldhu	r2,-28(fp)
 82424d4:	e0fff817 	ldw	r3,-32(fp)
 82424d8:	10800044 	addi	r2,r2,1
 82424dc:	1085883a 	add	r2,r2,r2
 82424e0:	1085883a 	add	r2,r2,r2
 82424e4:	1885883a 	add	r2,r3,r2
 82424e8:	10800017 	ldw	r2,0(r2)
 82424ec:	e0bffd15 	stw	r2,-12(fp)
 82424f0:	e0bffd17 	ldw	r2,-12(fp)
 82424f4:	10000c26 	beq	r2,zero,8242528 <ip_reasm_delete_ire+0x120>
            {
            ip_reasm_decr_mem_useage (p->nb_blen);
 82424f8:	e0bffd17 	ldw	r2,-12(fp)
 82424fc:	10800217 	ldw	r2,8(r2)
 8242500:	10bfffcc 	andi	r2,r2,65535
 8242504:	1009883a 	mov	r4,r2
 8242508:	82411200 	call	8241120 <ip_reasm_decr_mem_useage>
            LOCK_NET_RESOURCE (FREEQ_RESID);
 824250c:	01000084 	movi	r4,2
 8242510:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
            pk_free (p);
 8242514:	e13ffd17 	ldw	r4,-12(fp)
 8242518:	822cbbc0 	call	822cbbc <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);               
 824251c:	01000084 	movi	r4,2
 8242520:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
 8242524:	00000506 	br	824253c <ip_reasm_delete_ire+0x134>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 8242528:	e0bfff17 	ldw	r2,-4(fp)
 824252c:	10802103 	ldbu	r2,132(r2)
 8242530:	10803fcc 	andi	r2,r2,255
 8242534:	1080004c 	andi	r2,r2,1
 8242538:	1000071e 	bne	r2,zero,8242558 <ip_reasm_delete_ire+0x150>
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 824253c:	e0bff90b 	ldhu	r2,-28(fp)
 8242540:	10800044 	addi	r2,r2,1
 8242544:	e0bff90d 	sth	r2,-28(fp)
 8242548:	e0bff90b 	ldhu	r2,-28(fp)
 824254c:	10800430 	cmpltui	r2,r2,16
 8242550:	103fdf1e 	bne	r2,zero,82424d0 <ip_reasm_delete_ire+0xc8>
 8242554:	00000106 	br	824255c <ip_reasm_delete_ire+0x154>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 8242558:	0001883a 	nop
               }
            }
          }

       prev_rfqp = rfqp;
 824255c:	e0bff817 	ldw	r2,-32(fp)
 8242560:	e0bffe15 	stw	r2,-8(fp)
       rfqp = rfqp->next;
 8242564:	e0bff817 	ldw	r2,-32(fp)
 8242568:	10800017 	ldw	r2,0(r2)
 824256c:	e0bff815 	stw	r2,-32(fp)
       /* the first RFQ is statically allocated, and cannot be freed */
       if (prev_rfqp != first_rfqp)
 8242570:	e0fffe17 	ldw	r3,-8(fp)
 8242574:	e0bffc17 	ldw	r2,-16(fp)
 8242578:	18800426 	beq	r3,r2,824258c <ip_reasm_delete_ire+0x184>
          {
          ip_reasm_decr_mem_useage (sizeof(RFQ));
 824257c:	01001904 	movi	r4,100
 8242580:	82411200 	call	8241120 <ip_reasm_decr_mem_useage>
          IPR_FREE (prev_rfqp);
 8242584:	e13ffe17 	ldw	r4,-8(fp)
 8242588:	822e0200 	call	822e020 <npfree>

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
 824258c:	e0bff817 	ldw	r2,-32(fp)
 8242590:	103fcd1e 	bne	r2,zero,82424c8 <ip_reasm_delete_ire+0xc0>
          IPR_FREE (prev_rfqp);
          }
      }

   /* now free the parent entity */
   ip_reasm_decr_mem_useage (sizeof(IRE));
 8242594:	01002204 	movi	r4,136
 8242598:	82411200 	call	8241120 <ip_reasm_decr_mem_useage>
   IPR_FREE (irep);
 824259c:	e13fff17 	ldw	r4,-4(fp)
 82425a0:	822e0200 	call	822e020 <npfree>

   return IPREASM_OK;
 82425a4:	0005883a 	mov	r2,zero
}
 82425a8:	e037883a 	mov	sp,fp
 82425ac:	dfc00117 	ldw	ra,4(sp)
 82425b0:	df000017 	ldw	fp,0(sp)
 82425b4:	dec00204 	addi	sp,sp,8
 82425b8:	f800283a 	ret

082425bc <ip_reasm_mark_compact_rfq>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in 
the master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_mark_compact_rfq (IREP irep)
{
 82425bc:	defffb04 	addi	sp,sp,-20
 82425c0:	dfc00415 	stw	ra,16(sp)
 82425c4:	df000315 	stw	fp,12(sp)
 82425c8:	df000304 	addi	fp,sp,12
 82425cc:	e13fff15 	stw	r4,-4(fp)
   RFQP rfqp;
   u_short i;
   u_char empty_slot_discovered = IPREASM_FALSE;
 82425d0:	e03ffe85 	stb	zero,-6(fp)
   u_char compact = IPREASM_TRUE;
 82425d4:	00800044 	movi	r2,1
 82425d8:	e0bffec5 	stb	r2,-5(fp)

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 82425dc:	e13fff17 	ldw	r4,-4(fp)
 82425e0:	8241f8c0 	call	8241f8c <ip_reasm_find_ire>
 82425e4:	10803fcc 	andi	r2,r2,255
 82425e8:	10800060 	cmpeqi	r2,r2,1
 82425ec:	1000091e 	bne	r2,zero,8242614 <ip_reasm_mark_compact_rfq+0x58>
   {
      ++ire_stats.bad_irep;
 82425f0:	008209b4 	movhi	r2,2086
 82425f4:	10ba7e04 	addi	r2,r2,-5640
 82425f8:	10800017 	ldw	r2,0(r2)
 82425fc:	10c00044 	addi	r3,r2,1
 8242600:	008209b4 	movhi	r2,2086
 8242604:	10ba7e04 	addi	r2,r2,-5640
 8242608:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 824260c:	00bffd84 	movi	r2,-10
 8242610:	00003106 	br	82426d8 <ip_reasm_mark_compact_rfq+0x11c>
   }

   rfqp = &(irep->rfq);
 8242614:	e0bfff17 	ldw	r2,-4(fp)
 8242618:	10800604 	addi	r2,r2,24
 824261c:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 8242620:	00001a06 	br	824268c <ip_reasm_mark_compact_rfq+0xd0>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242624:	e03ffe0d 	sth	zero,-8(fp)
 8242628:	00001206 	br	8242674 <ip_reasm_mark_compact_rfq+0xb8>
         {
         if (rfqp->bufp [i] == 0)
 824262c:	e0bffe0b 	ldhu	r2,-8(fp)
 8242630:	e0fffd17 	ldw	r3,-12(fp)
 8242634:	10800044 	addi	r2,r2,1
 8242638:	1085883a 	add	r2,r2,r2
 824263c:	1085883a 	add	r2,r2,r2
 8242640:	1885883a 	add	r2,r3,r2
 8242644:	10800017 	ldw	r2,0(r2)
 8242648:	1000031e 	bne	r2,zero,8242658 <ip_reasm_mark_compact_rfq+0x9c>
            {            
            empty_slot_discovered = IPREASM_TRUE;
 824264c:	00800044 	movi	r2,1
 8242650:	e0bffe85 	stb	r2,-6(fp)
 8242654:	00000406 	br	8242668 <ip_reasm_mark_compact_rfq+0xac>
            }
         else
            {
            if (empty_slot_discovered) 
 8242658:	e0bffe83 	ldbu	r2,-6(fp)
 824265c:	10000226 	beq	r2,zero,8242668 <ip_reasm_mark_compact_rfq+0xac>
               {
               compact = IPREASM_FALSE;
 8242660:	e03ffec5 	stb	zero,-5(fp)
               break;
 8242664:	00000606 	br	8242680 <ip_reasm_mark_compact_rfq+0xc4>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242668:	e0bffe0b 	ldhu	r2,-8(fp)
 824266c:	10800044 	addi	r2,r2,1
 8242670:	e0bffe0d 	sth	r2,-8(fp)
 8242674:	e0bffe0b 	ldhu	r2,-8(fp)
 8242678:	10800430 	cmpltui	r2,r2,16
 824267c:	103feb1e 	bne	r2,zero,824262c <ip_reasm_mark_compact_rfq+0x70>
               compact = IPREASM_FALSE;
               break;
               }
            }
          }
       rfqp = rfqp->next;
 8242680:	e0bffd17 	ldw	r2,-12(fp)
 8242684:	10800017 	ldw	r2,0(r2)
 8242688:	e0bffd15 	stw	r2,-12(fp)
      return ENP_PARAM;
   }

   rfqp = &(irep->rfq);

   while (rfqp)
 824268c:	e0bffd17 	ldw	r2,-12(fp)
 8242690:	103fe41e 	bne	r2,zero,8242624 <ip_reasm_mark_compact_rfq+0x68>
            }
          }
       rfqp = rfqp->next;
      }

   if (compact) 
 8242694:	e0bffec3 	ldbu	r2,-5(fp)
 8242698:	10000726 	beq	r2,zero,82426b8 <ip_reasm_mark_compact_rfq+0xfc>
      {
      irep->flags |= IPR_RFQ_COMPACT;
 824269c:	e0bfff17 	ldw	r2,-4(fp)
 82426a0:	10802103 	ldbu	r2,132(r2)
 82426a4:	10800054 	ori	r2,r2,1
 82426a8:	1007883a 	mov	r3,r2
 82426ac:	e0bfff17 	ldw	r2,-4(fp)
 82426b0:	10c02105 	stb	r3,132(r2)
 82426b4:	00000706 	br	82426d4 <ip_reasm_mark_compact_rfq+0x118>
      }
   else 
      {
      irep->flags &= ~IPR_RFQ_COMPACT;
 82426b8:	e0bfff17 	ldw	r2,-4(fp)
 82426bc:	10c02103 	ldbu	r3,132(r2)
 82426c0:	00bfff84 	movi	r2,-2
 82426c4:	1884703a 	and	r2,r3,r2
 82426c8:	1007883a 	mov	r3,r2
 82426cc:	e0bfff17 	ldw	r2,-4(fp)
 82426d0:	10c02105 	stb	r3,132(r2)
      }

   return IPREASM_OK;
 82426d4:	0005883a 	mov	r2,zero
}
 82426d8:	e037883a 	mov	sp,fp
 82426dc:	dfc00117 	ldw	ra,4(sp)
 82426e0:	df000017 	ldw	fp,0(sp)
 82426e4:	dec00204 	addi	sp,sp,8
 82426e8:	f800283a 	ret

082426ec <ipr_stats>:

OUTPUT: This function always returns IPREASM_OK.
*/

int ipr_stats(void * pio)
{
 82426ec:	deffec04 	addi	sp,sp,-80
 82426f0:	dfc01315 	stw	ra,76(sp)
 82426f4:	df001215 	stw	fp,72(sp)
 82426f8:	dc001115 	stw	r16,68(sp)
 82426fc:	df001204 	addi	fp,sp,72
 8242700:	e13ffe15 	stw	r4,-8(fp)
   unsigned long ticks_elapsed = cticks;
 8242704:	d0a0a817 	ldw	r2,-32096(gp)
 8242708:	e0bffc15 	stw	r2,-16(fp)
   u_short size_ire = sizeof(IRE);
 824270c:	00802204 	movi	r2,136
 8242710:	e0bffd0d 	sth	r2,-12(fp)
   u_short size_rfq = sizeof(RFQ);
 8242714:	00801904 	movi	r2,100
 8242718:	e0bffd8d 	sth	r2,-10(fp)
   IREP tmpp;
   u_short count = 0;
 824271c:	e03ff90d 	sth	zero,-28(fp)
   RFQP rfqp;
   u_short frag_count = 0;
 8242720:	e03ffb0d 	sth	zero,-20(fp)
   u_short i;

   ns_printf(pio,"IP reassembly statistics:\n");
 8242724:	01420974 	movhi	r5,2085
 8242728:	2944dd04 	addi	r5,r5,4980
 824272c:	e13ffe17 	ldw	r4,-8(fp)
 8242730:	8228d040 	call	8228d04 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
 8242734:	d420c717 	ldw	r16,-31972(gp)
 8242738:	e0bffc17 	ldw	r2,-16(fp)
 824273c:	01401904 	movi	r5,100
 8242740:	1009883a 	mov	r4,r2
 8242744:	8202b8c0 	call	8202b8c <__udivsi3>
 8242748:	1009883a 	mov	r4,r2
 824274c:	e0bffd0b 	ldhu	r2,-12(fp)
 8242750:	e0fffd8b 	ldhu	r3,-10(fp)
 8242754:	d8c00215 	stw	r3,8(sp)
 8242758:	d8800115 	stw	r2,4(sp)
 824275c:	d9000015 	stw	r4,0(sp)
 8242760:	e1fffc17 	ldw	r7,-16(fp)
 8242764:	800d883a 	mov	r6,r16
 8242768:	01420974 	movhi	r5,2085
 824276c:	2944e404 	addi	r5,r5,5008
 8242770:	e13ffe17 	ldw	r4,-8(fp)
 8242774:	8228d040 	call	8228d04 <ns_printf>
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
 8242778:	008209b4 	movhi	r2,2086
 824277c:	10ba7e04 	addi	r2,r2,-5640
 8242780:	11800117 	ldw	r6,4(r2)
 8242784:	008209b4 	movhi	r2,2086
 8242788:	10ba7e04 	addi	r2,r2,-5640
 824278c:	11c00017 	ldw	r7,0(r2)
 8242790:	008209b4 	movhi	r2,2086
 8242794:	10ba7e04 	addi	r2,r2,-5640
 8242798:	10c00217 	ldw	r3,8(r2)
 824279c:	008209b4 	movhi	r2,2086
 82427a0:	10ba7e04 	addi	r2,r2,-5640
 82427a4:	11000317 	ldw	r4,12(r2)
 82427a8:	008209b4 	movhi	r2,2086
 82427ac:	10ba7e04 	addi	r2,r2,-5640
 82427b0:	11400417 	ldw	r5,16(r2)
 82427b4:	008209b4 	movhi	r2,2086
 82427b8:	10ba7e04 	addi	r2,r2,-5640
 82427bc:	10800517 	ldw	r2,20(r2)
 82427c0:	d8800315 	stw	r2,12(sp)
 82427c4:	d9400215 	stw	r5,8(sp)
 82427c8:	d9000115 	stw	r4,4(sp)
 82427cc:	d8c00015 	stw	r3,0(sp)
 82427d0:	01420974 	movhi	r5,2085
 82427d4:	2944f404 	addi	r5,r5,5072
 82427d8:	e13ffe17 	ldw	r4,-8(fp)
 82427dc:	8228d040 	call	8228d04 <ns_printf>
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
 82427e0:	d0a0c817 	ldw	r2,-31968(gp)
 82427e4:	100d883a 	mov	r6,r2
 82427e8:	01420974 	movhi	r5,2085
 82427ec:	29450904 	addi	r5,r5,5156
 82427f0:	e13ffe17 	ldw	r4,-8(fp)
 82427f4:	8228d040 	call	8228d04 <ns_printf>
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 82427f8:	d0a0c817 	ldw	r2,-31968(gp)
 82427fc:	e0bff815 	stw	r2,-32(fp)
 8242800:	00007c06 	br	82429f4 <ipr_stats+0x308>
      {
      ++count;
 8242804:	e0bff90b 	ldhu	r2,-28(fp)
 8242808:	10800044 	addi	r2,r2,1
 824280c:	e0bff90d 	sth	r2,-28(fp)
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
 8242810:	e0bff817 	ldw	r2,-32(fp)
 8242814:	10800604 	addi	r2,r2,24
 8242818:	e0bffa15 	stw	r2,-24(fp)
      while (rfqp)
 824281c:	00001e06 	br	8242898 <ipr_stats+0x1ac>
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 8242820:	e03ffb8d 	sth	zero,-18(fp)
 8242824:	00001406 	br	8242878 <ipr_stats+0x18c>
            {
            if (rfqp->bufp [i] != 0)
 8242828:	e0bffb8b 	ldhu	r2,-18(fp)
 824282c:	e0fffa17 	ldw	r3,-24(fp)
 8242830:	10800044 	addi	r2,r2,1
 8242834:	1085883a 	add	r2,r2,r2
 8242838:	1085883a 	add	r2,r2,r2
 824283c:	1885883a 	add	r2,r3,r2
 8242840:	10800017 	ldw	r2,0(r2)
 8242844:	10000426 	beq	r2,zero,8242858 <ipr_stats+0x16c>
               {
               ++frag_count;            
 8242848:	e0bffb0b 	ldhu	r2,-20(fp)
 824284c:	10800044 	addi	r2,r2,1
 8242850:	e0bffb0d 	sth	r2,-20(fp)
 8242854:	00000506 	br	824286c <ipr_stats+0x180>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
 8242858:	e0bff817 	ldw	r2,-32(fp)
 824285c:	10802103 	ldbu	r2,132(r2)
 8242860:	10803fcc 	andi	r2,r2,255
 8242864:	1080004c 	andi	r2,r2,1
 8242868:	1000071e 	bne	r2,zero,8242888 <ipr_stats+0x19c>
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 824286c:	e0bffb8b 	ldhu	r2,-18(fp)
 8242870:	10800044 	addi	r2,r2,1
 8242874:	e0bffb8d 	sth	r2,-18(fp)
 8242878:	e0bffb8b 	ldhu	r2,-18(fp)
 824287c:	10800430 	cmpltui	r2,r2,16
 8242880:	103fe91e 	bne	r2,zero,8242828 <ipr_stats+0x13c>
 8242884:	00000106 	br	824288c <ipr_stats+0x1a0>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
                  {
                  break;
 8242888:	0001883a 	nop
                  }
               }
            }
         rfqp = rfqp->next;
 824288c:	e0bffa17 	ldw	r2,-24(fp)
 8242890:	10800017 	ldw	r2,0(r2)
 8242894:	e0bffa15 	stw	r2,-24(fp)
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
 8242898:	e0bffa17 	ldw	r2,-24(fp)
 824289c:	103fe01e 	bne	r2,zero,8242820 <ipr_stats+0x134>
                  }
               }
            }
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
 82428a0:	e33ffb0b 	ldhu	r12,-20(fp)
 82428a4:	e0bff817 	ldw	r2,-32(fp)
 82428a8:	10800117 	ldw	r2,4(r2)
 82428ac:	1006d63a 	srli	r3,r2,24
 82428b0:	e0bff817 	ldw	r2,-32(fp)
 82428b4:	10800117 	ldw	r2,4(r2)
 82428b8:	1004d23a 	srli	r2,r2,8
 82428bc:	10bfc00c 	andi	r2,r2,65280
 82428c0:	1886b03a 	or	r3,r3,r2
 82428c4:	e0bff817 	ldw	r2,-32(fp)
 82428c8:	10800117 	ldw	r2,4(r2)
 82428cc:	10bfc00c 	andi	r2,r2,65280
 82428d0:	1004923a 	slli	r2,r2,8
 82428d4:	1886b03a 	or	r3,r3,r2
 82428d8:	e0bff817 	ldw	r2,-32(fp)
 82428dc:	10800117 	ldw	r2,4(r2)
 82428e0:	1004963a 	slli	r2,r2,24
 82428e4:	1884b03a 	or	r2,r3,r2
 82428e8:	e0fff817 	ldw	r3,-32(fp)
 82428ec:	18c00217 	ldw	r3,8(r3)
 82428f0:	1808d63a 	srli	r4,r3,24
 82428f4:	e0fff817 	ldw	r3,-32(fp)
 82428f8:	18c00217 	ldw	r3,8(r3)
 82428fc:	1806d23a 	srli	r3,r3,8
 8242900:	18ffc00c 	andi	r3,r3,65280
 8242904:	20c8b03a 	or	r4,r4,r3
 8242908:	e0fff817 	ldw	r3,-32(fp)
 824290c:	18c00217 	ldw	r3,8(r3)
 8242910:	18ffc00c 	andi	r3,r3,65280
 8242914:	1806923a 	slli	r3,r3,8
 8242918:	20c8b03a 	or	r4,r4,r3
 824291c:	e0fff817 	ldw	r3,-32(fp)
 8242920:	18c00217 	ldw	r3,8(r3)
 8242924:	1806963a 	slli	r3,r3,24
 8242928:	20c6b03a 	or	r3,r4,r3
 824292c:	e13ff817 	ldw	r4,-32(fp)
 8242930:	21000383 	ldbu	r4,14(r4)
 8242934:	21003fcc 	andi	r4,r4,255
 8242938:	e17ff817 	ldw	r5,-32(fp)
 824293c:	2940030b 	ldhu	r5,12(r5)
 8242940:	297fffcc 	andi	r5,r5,65535
 8242944:	280ad23a 	srli	r5,r5,8
 8242948:	297fffcc 	andi	r5,r5,65535
 824294c:	29803fcc 	andi	r6,r5,255
 8242950:	e17ff817 	ldw	r5,-32(fp)
 8242954:	2940030b 	ldhu	r5,12(r5)
 8242958:	297fffcc 	andi	r5,r5,65535
 824295c:	280a923a 	slli	r5,r5,8
 8242960:	297fffcc 	andi	r5,r5,65535
 8242964:	314ab03a 	or	r5,r6,r5
 8242968:	e1bff817 	ldw	r6,-32(fp)
 824296c:	3180040b 	ldhu	r6,16(r6)
 8242970:	31bfffcc 	andi	r6,r6,65535
 8242974:	e1fff817 	ldw	r7,-32(fp)
 8242978:	39c0048b 	ldhu	r7,18(r7)
 824297c:	39ffffcc 	andi	r7,r7,65535
 8242980:	e23ff817 	ldw	r8,-32(fp)
 8242984:	42000517 	ldw	r8,20(r8)
 8242988:	e27ff817 	ldw	r9,-32(fp)
 824298c:	4a401f17 	ldw	r9,124(r9)
 8242990:	e2bff817 	ldw	r10,-32(fp)
 8242994:	52802017 	ldw	r10,128(r10)
 8242998:	e2fff817 	ldw	r11,-32(fp)
 824299c:	5ac02103 	ldbu	r11,132(r11)
 82429a0:	5ac03fcc 	andi	r11,r11,255
 82429a4:	5ac0004c 	andi	r11,r11,1
 82429a8:	dac00915 	stw	r11,36(sp)
 82429ac:	da800815 	stw	r10,32(sp)
 82429b0:	da400715 	stw	r9,28(sp)
 82429b4:	da000615 	stw	r8,24(sp)
 82429b8:	d9c00515 	stw	r7,20(sp)
 82429bc:	d9800415 	stw	r6,16(sp)
 82429c0:	d9400315 	stw	r5,12(sp)
 82429c4:	d9000215 	stw	r4,8(sp)
 82429c8:	d8c00115 	stw	r3,4(sp)
 82429cc:	d8800015 	stw	r2,0(sp)
 82429d0:	600f883a 	mov	r7,r12
 82429d4:	e1bff817 	ldw	r6,-32(fp)
 82429d8:	01420974 	movhi	r5,2085
 82429dc:	29450f04 	addi	r5,r5,5180
 82429e0:	e13ffe17 	ldw	r4,-8(fp)
 82429e4:	8228d040 	call	8228d04 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 82429e8:	e0bff817 	ldw	r2,-32(fp)
 82429ec:	10800017 	ldw	r2,0(r2)
 82429f0:	e0bff815 	stw	r2,-32(fp)
 82429f4:	e0bff817 	ldw	r2,-32(fp)
 82429f8:	103f821e 	bne	r2,zero,8242804 <ipr_stats+0x118>
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
      } /* end FOR (IRE linked list) */

   ns_printf(pio,"Found a total of %u IRE entries\n",count);
 82429fc:	e0bff90b 	ldhu	r2,-28(fp)
 8242a00:	100d883a 	mov	r6,r2
 8242a04:	01420974 	movhi	r5,2085
 8242a08:	29452a04 	addi	r5,r5,5288
 8242a0c:	e13ffe17 	ldw	r4,-8(fp)
 8242a10:	8228d040 	call	8228d04 <ns_printf>

   return IPREASM_OK;
 8242a14:	0005883a 	mov	r2,zero
}
 8242a18:	e6ffff04 	addi	sp,fp,-4
 8242a1c:	dfc00217 	ldw	ra,8(sp)
 8242a20:	df000117 	ldw	fp,4(sp)
 8242a24:	dc000017 	ldw	r16,0(sp)
 8242a28:	dec00304 	addi	sp,sp,12
 8242a2c:	f800283a 	ret

08242a30 <ip_reasm_send_icmp_timex>:
OUTPUT: This function always returns IPREASM_OK.
*/

#ifdef FULL_ICMP
u_long ip_reasm_send_icmp_timex (IREP irep)
{
 8242a30:	defffc04 	addi	sp,sp,-16
 8242a34:	dfc00315 	stw	ra,12(sp)
 8242a38:	df000215 	stw	fp,8(sp)
 8242a3c:	df000204 	addi	fp,sp,8
 8242a40:	e13fff15 	stw	r4,-4(fp)

   /* we can only send an ICMP Time Exceeded message with code 1 ("fragment reassembly 
    * time exceeded") if we have received the First Fragment (FF) of the original, 
    * unfragmented datagram.  This is indicated by a non-zero value for the l2_hdr and
    * l3_hdr fields in the IRE data structure. */
   if (irep->l2_hdr)
 8242a44:	e0bfff17 	ldw	r2,-4(fp)
 8242a48:	10801f17 	ldw	r2,124(r2)
 8242a4c:	10000626 	beq	r2,zero,8242a68 <ip_reasm_send_icmp_timex+0x38>
      {
      pip = (struct ip *) irep->l3_hdr;
 8242a50:	e0bfff17 	ldw	r2,-4(fp)
 8242a54:	10802017 	ldw	r2,128(r2)
 8242a58:	e0bffe15 	stw	r2,-8(fp)
      icmp_timex (pip, TIMEX_REASSY_FAILED);
 8242a5c:	01400044 	movi	r5,1
 8242a60:	e13ffe17 	ldw	r4,-8(fp)
 8242a64:	824b1140 	call	824b114 <icmp_timex>
      }

   return IPREASM_OK;
 8242a68:	0005883a 	mov	r2,zero
}
 8242a6c:	e037883a 	mov	sp,fp
 8242a70:	dfc00117 	ldw	ra,4(sp)
 8242a74:	df000017 	ldw	fp,0(sp)
 8242a78:	dec00204 	addi	sp,sp,8
 8242a7c:	f800283a 	ret

08242a80 <ip_rcv>:
 * RETURNS: 
 */

int
ip_rcv(PACKET p)
{
 8242a80:	defff404 	addi	sp,sp,-48
 8242a84:	dfc00b15 	stw	ra,44(sp)
 8242a88:	df000a15 	stw	fp,40(sp)
 8242a8c:	dc000915 	stw	r16,36(sp)
 8242a90:	df000a04 	addi	fp,sp,40
 8242a94:	e13ffe15 	stw	r4,-8(fp)
   unsigned hdrlen;  /* length of IP header including options */
   unsigned len;     /* total length including IP header */
   unsigned short int num_pkts;
   PACKET * pktp;
   unsigned char i;
   int rcvrc = -1;
 8242a98:	00bfffc4 	movi	r2,-1
 8242a9c:	e0bff715 	stw	r2,-36(fp)
   unsigned char rc_ret;
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242aa0:	d0a08317 	ldw	r2,-32244(gp)
 8242aa4:	1081000c 	andi	r2,r2,1024
 8242aa8:	10000e26 	beq	r2,zero,8242ae4 <ip_rcv+0x64>
 8242aac:	d0a08317 	ldw	r2,-32244(gp)
 8242ab0:	1080800c 	andi	r2,r2,512
 8242ab4:	10000b26 	beq	r2,zero,8242ae4 <ip_rcv+0x64>
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
         p->nb_plen, net_num(p->net));
 8242ab8:	e0bffe17 	ldw	r2,-8(fp)
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 8242abc:	14000417 	ldw	r16,16(r2)
         p->nb_plen, net_num(p->net));
 8242ac0:	e0bffe17 	ldw	r2,-8(fp)
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 8242ac4:	10800617 	ldw	r2,24(r2)
 8242ac8:	1009883a 	mov	r4,r2
 8242acc:	8226ba40 	call	8226ba4 <if_netnumber>
 8242ad0:	100d883a 	mov	r6,r2
 8242ad4:	800b883a 	mov	r5,r16
 8242ad8:	01020974 	movhi	r4,2085
 8242adc:	21053304 	addi	r4,r4,5324
 8242ae0:	820331c0 	call	820331c <printf>
         p->nb_plen, net_num(p->net));
#endif

   IN_PROFILER(PF_IP, PF_ENTRY);

   ip_mib.ipInReceives++;
 8242ae4:	008209b4 	movhi	r2,2086
 8242ae8:	10ba6a04 	addi	r2,r2,-5720
 8242aec:	10800217 	ldw	r2,8(r2)
 8242af0:	10c00044 	addi	r3,r2,1
 8242af4:	008209b4 	movhi	r2,2086
 8242af8:	10ba6a04 	addi	r2,r2,-5720
 8242afc:	10c00215 	stw	r3,8(r2)
   pip = ip_head(p);
 8242b00:	e0bffe17 	ldw	r2,-8(fp)
 8242b04:	10800317 	ldw	r2,12(r2)
 8242b08:	e0bff815 	stw	r2,-32(fp)

   /* test received MAC len against IP header len */
   if (p->nb_plen < (unsigned)htons(pip->ip_len))
 8242b0c:	e0bffe17 	ldw	r2,-8(fp)
 8242b10:	10800417 	ldw	r2,16(r2)
 8242b14:	e0fff817 	ldw	r3,-32(fp)
 8242b18:	18c0008b 	ldhu	r3,2(r3)
 8242b1c:	18ffffcc 	andi	r3,r3,65535
 8242b20:	1806d23a 	srli	r3,r3,8
 8242b24:	18ffffcc 	andi	r3,r3,65535
 8242b28:	19003fcc 	andi	r4,r3,255
 8242b2c:	e0fff817 	ldw	r3,-32(fp)
 8242b30:	18c0008b 	ldhu	r3,2(r3)
 8242b34:	18ffffcc 	andi	r3,r3,65535
 8242b38:	1806923a 	slli	r3,r3,8
 8242b3c:	18ffffcc 	andi	r3,r3,65535
 8242b40:	20c6b03a 	or	r3,r4,r3
 8242b44:	10c01f2e 	bgeu	r2,r3,8242bc4 <ip_rcv+0x144>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242b48:	d0a08317 	ldw	r2,-32244(gp)
 8242b4c:	1081000c 	andi	r2,r2,1024
 8242b50:	10000c26 	beq	r2,zero,8242b84 <ip_rcv+0x104>
 8242b54:	d0a08317 	ldw	r2,-32244(gp)
 8242b58:	1080800c 	andi	r2,r2,512
 8242b5c:	10000926 	beq	r2,zero,8242b84 <ip_rcv+0x104>
      {
         dprintf("ip_rcv: bad pkt len\n");
 8242b60:	01020974 	movhi	r4,2085
 8242b64:	21053c04 	addi	r4,r4,5360
 8242b68:	82035a00 	call	82035a0 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 8242b6c:	d0a08317 	ldw	r2,-32244(gp)
 8242b70:	1080008c 	andi	r2,r2,2
 8242b74:	10000326 	beq	r2,zero,8242b84 <ip_rcv+0x104>
 8242b78:	e0bffe17 	ldw	r2,-8(fp)
 8242b7c:	1009883a 	mov	r4,r2
 8242b80:	82408a40 	call	82408a4 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 8242b84:	008209b4 	movhi	r2,2086
 8242b88:	10ba6a04 	addi	r2,r2,-5720
 8242b8c:	10800317 	ldw	r2,12(r2)
 8242b90:	10c00044 	addi	r3,r2,1
 8242b94:	008209b4 	movhi	r2,2086
 8242b98:	10ba6a04 	addi	r2,r2,-5720
 8242b9c:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8242ba0:	01000084 	movi	r4,2
 8242ba4:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(p);
 8242ba8:	e0bffe17 	ldw	r2,-8(fp)
 8242bac:	1009883a 	mov	r4,r2
 8242bb0:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242bb4:	01000084 	movi	r4,2
 8242bb8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 8242bbc:	00bff804 	movi	r2,-32
 8242bc0:	00008906 	br	8242de8 <ip_rcv+0x368>
   }

   /* use length from IP header; MAC value may be padded */
   len = htons(pip->ip_len);
 8242bc4:	e0bff817 	ldw	r2,-32(fp)
 8242bc8:	1080008b 	ldhu	r2,2(r2)
 8242bcc:	10bfffcc 	andi	r2,r2,65535
 8242bd0:	1004d23a 	srli	r2,r2,8
 8242bd4:	10bfffcc 	andi	r2,r2,65535
 8242bd8:	10c03fcc 	andi	r3,r2,255
 8242bdc:	e0bff817 	ldw	r2,-32(fp)
 8242be0:	1080008b 	ldhu	r2,2(r2)
 8242be4:	10bfffcc 	andi	r2,r2,65535
 8242be8:	1004923a 	slli	r2,r2,8
 8242bec:	10bfffcc 	andi	r2,r2,65535
 8242bf0:	1884b03a 	or	r2,r3,r2
 8242bf4:	e0bff915 	stw	r2,-28(fp)
   p->nb_plen = len;       /* fix pkt len */
 8242bf8:	e0bffe17 	ldw	r2,-8(fp)
 8242bfc:	e0fff917 	ldw	r3,-28(fp)
 8242c00:	10c00415 	stw	r3,16(r2)

   if ( ((pip->ip_ver_ihl & 0xf0) >> 4) != IP_VER)
 8242c04:	e0bff817 	ldw	r2,-32(fp)
 8242c08:	10800003 	ldbu	r2,0(r2)
 8242c0c:	10803fcc 	andi	r2,r2,255
 8242c10:	1004d13a 	srli	r2,r2,4
 8242c14:	10803fcc 	andi	r2,r2,255
 8242c18:	10800120 	cmpeqi	r2,r2,4
 8242c1c:	10001f1e 	bne	r2,zero,8242c9c <ip_rcv+0x21c>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242c20:	d0a08317 	ldw	r2,-32244(gp)
 8242c24:	1081000c 	andi	r2,r2,1024
 8242c28:	10000c26 	beq	r2,zero,8242c5c <ip_rcv+0x1dc>
 8242c2c:	d0a08317 	ldw	r2,-32244(gp)
 8242c30:	1080800c 	andi	r2,r2,512
 8242c34:	10000926 	beq	r2,zero,8242c5c <ip_rcv+0x1dc>
      {
         dprintf("ip_rcv: bad version number\n");
 8242c38:	01020974 	movhi	r4,2085
 8242c3c:	21054104 	addi	r4,r4,5380
 8242c40:	82035a00 	call	82035a0 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 8242c44:	d0a08317 	ldw	r2,-32244(gp)
 8242c48:	1080008c 	andi	r2,r2,2
 8242c4c:	10000326 	beq	r2,zero,8242c5c <ip_rcv+0x1dc>
 8242c50:	e0bffe17 	ldw	r2,-8(fp)
 8242c54:	1009883a 	mov	r4,r2
 8242c58:	82408a40 	call	82408a4 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 8242c5c:	008209b4 	movhi	r2,2086
 8242c60:	10ba6a04 	addi	r2,r2,-5720
 8242c64:	10800317 	ldw	r2,12(r2)
 8242c68:	10c00044 	addi	r3,r2,1
 8242c6c:	008209b4 	movhi	r2,2086
 8242c70:	10ba6a04 	addi	r2,r2,-5720
 8242c74:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8242c78:	01000084 	movi	r4,2
 8242c7c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(p);
 8242c80:	e0bffe17 	ldw	r2,-8(fp)
 8242c84:	1009883a 	mov	r4,r2
 8242c88:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242c8c:	01000084 	movi	r4,2
 8242c90:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 8242c94:	00bff804 	movi	r2,-32
 8242c98:	00005306 	br	8242de8 <ip_rcv+0x368>
   }

   csum = pip->ip_chksum;
 8242c9c:	e0bff817 	ldw	r2,-32(fp)
 8242ca0:	1080028b 	ldhu	r2,10(r2)
 8242ca4:	e0bffa0d 	sth	r2,-24(fp)
   pip->ip_chksum = 0;
 8242ca8:	e0bff817 	ldw	r2,-32(fp)
 8242cac:	1000028d 	sth	zero,10(r2)
   hdrlen = ip_hlen(pip);
 8242cb0:	e0bff817 	ldw	r2,-32(fp)
 8242cb4:	10800003 	ldbu	r2,0(r2)
 8242cb8:	10803fcc 	andi	r2,r2,255
 8242cbc:	108003cc 	andi	r2,r2,15
 8242cc0:	1085883a 	add	r2,r2,r2
 8242cc4:	1085883a 	add	r2,r2,r2
 8242cc8:	e0bffb15 	stw	r2,-20(fp)
   tempsum = ~cksum(pip, hdrlen >> 1);
 8242ccc:	e0bffb17 	ldw	r2,-20(fp)
 8242cd0:	1004d07a 	srli	r2,r2,1
 8242cd4:	100b883a 	mov	r5,r2
 8242cd8:	e13ff817 	ldw	r4,-32(fp)
 8242cdc:	82286f00 	call	82286f0 <cksum>
 8242ce0:	0084303a 	nor	r2,zero,r2
 8242ce4:	e0bffc0d 	sth	r2,-16(fp)

   if (csum != tempsum)
 8242ce8:	e0fffa0b 	ldhu	r3,-24(fp)
 8242cec:	e0bffc0b 	ldhu	r2,-16(fp)
 8242cf0:	18802226 	beq	r3,r2,8242d7c <ip_rcv+0x2fc>
   {
      pip->ip_chksum = csum;
 8242cf4:	e0bff817 	ldw	r2,-32(fp)
 8242cf8:	e0fffa0b 	ldhu	r3,-24(fp)
 8242cfc:	10c0028d 	sth	r3,10(r2)
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242d00:	d0a08317 	ldw	r2,-32244(gp)
 8242d04:	1081000c 	andi	r2,r2,1024
 8242d08:	10000c26 	beq	r2,zero,8242d3c <ip_rcv+0x2bc>
 8242d0c:	d0a08317 	ldw	r2,-32244(gp)
 8242d10:	1080800c 	andi	r2,r2,512
 8242d14:	10000926 	beq	r2,zero,8242d3c <ip_rcv+0x2bc>
      {
         dprintf("ip_rcv: bad xsum\n");
 8242d18:	01020974 	movhi	r4,2085
 8242d1c:	21054804 	addi	r4,r4,5408
 8242d20:	82035a00 	call	82035a0 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 8242d24:	d0a08317 	ldw	r2,-32244(gp)
 8242d28:	1080008c 	andi	r2,r2,2
 8242d2c:	10000326 	beq	r2,zero,8242d3c <ip_rcv+0x2bc>
 8242d30:	e0bffe17 	ldw	r2,-8(fp)
 8242d34:	1009883a 	mov	r4,r2
 8242d38:	82408a40 	call	82408a4 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 8242d3c:	008209b4 	movhi	r2,2086
 8242d40:	10ba6a04 	addi	r2,r2,-5720
 8242d44:	10800317 	ldw	r2,12(r2)
 8242d48:	10c00044 	addi	r3,r2,1
 8242d4c:	008209b4 	movhi	r2,2086
 8242d50:	10ba6a04 	addi	r2,r2,-5720
 8242d54:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 8242d58:	01000084 	movi	r4,2
 8242d5c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(p);
 8242d60:	e0bffe17 	ldw	r2,-8(fp)
 8242d64:	1009883a 	mov	r4,r2
 8242d68:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242d6c:	01000084 	movi	r4,2
 8242d70:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 8242d74:	00bff804 	movi	r2,-32
 8242d78:	00001b06 	br	8242de8 <ip_rcv+0x368>
   }

   pip->ip_chksum = csum;
 8242d7c:	e0bff817 	ldw	r2,-32(fp)
 8242d80:	e0fffa0b 	ldhu	r3,-24(fp)
 8242d84:	10c0028d 	sth	r3,10(r2)
#endif

    /* start off by assuming that we will only process the "current" packet;
     * these values may get overwritten by the NAT module if it returns
     * more than one packet back to this function (ip_rcv ()) */
    num_pkts = 1;
 8242d88:	00800044 	movi	r2,1
 8242d8c:	e0bffc8d 	sth	r2,-14(fp)
    pktp = &p;
 8242d90:	e0bffe04 	addi	r2,fp,-8
 8242d94:	e0bffd15 	stw	r2,-12(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 8242d98:	e03ff605 	stb	zero,-40(fp)
 8242d9c:	00000d06 	br	8242dd4 <ip_rcv+0x354>
   {
      rcvrc = ip_rcv_phase2 (*(pktp + i));
 8242da0:	e0bff603 	ldbu	r2,-40(fp)
 8242da4:	1085883a 	add	r2,r2,r2
 8242da8:	1085883a 	add	r2,r2,r2
 8242dac:	1007883a 	mov	r3,r2
 8242db0:	e0bffd17 	ldw	r2,-12(fp)
 8242db4:	10c5883a 	add	r2,r2,r3
 8242db8:	10800017 	ldw	r2,0(r2)
 8242dbc:	1009883a 	mov	r4,r2
 8242dc0:	8242e000 	call	8242e00 <ip_rcv_phase2>
 8242dc4:	e0bff715 	stw	r2,-36(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 8242dc8:	e0bff603 	ldbu	r2,-40(fp)
 8242dcc:	10800044 	addi	r2,r2,1
 8242dd0:	e0bff605 	stb	r2,-40(fp)
 8242dd4:	e0bff603 	ldbu	r2,-40(fp)
 8242dd8:	10ffffcc 	andi	r3,r2,65535
 8242ddc:	e0bffc8b 	ldhu	r2,-14(fp)
 8242de0:	18bfef36 	bltu	r3,r2,8242da0 <ip_rcv+0x320>
   if (pktp != &p) nat_free (pktp);
#endif /* NATRT */

   /* when multiple packets are processed in the loop above, the return code
    * contains the return code for the last packet */
   return rcvrc;
 8242de4:	e0bff717 	ldw	r2,-36(fp)
}
 8242de8:	e6ffff04 	addi	sp,fp,-4
 8242dec:	dfc00217 	ldw	ra,8(sp)
 8242df0:	df000117 	ldw	fp,4(sp)
 8242df4:	dc000017 	ldw	r16,0(sp)
 8242df8:	dec00304 	addi	sp,sp,12
 8242dfc:	f800283a 	ret

08242e00 <ip_rcv_phase2>:


int ip_rcv_phase2 (PACKET p)
{
 8242e00:	defff504 	addi	sp,sp,-44
 8242e04:	dfc00a15 	stw	ra,40(sp)
 8242e08:	df000915 	stw	fp,36(sp)
 8242e0c:	df000904 	addi	fp,sp,36
 8242e10:	e13fff15 	stw	r4,-4(fp)

   struct ip * pip;     /* the internet header */
   NET nt;
   unsigned short tempsum;

   pip = ip_head(p);
 8242e14:	e0bfff17 	ldw	r2,-4(fp)
 8242e18:	10800317 	ldw	r2,12(r2)
 8242e1c:	e0bff815 	stw	r2,-32(fp)
   nt = p->net;      /* which interface it came in on */
 8242e20:	e0bfff17 	ldw	r2,-4(fp)
 8242e24:	10800617 	ldw	r2,24(r2)
 8242e28:	e0bff915 	stw	r2,-28(fp)

#ifdef IP_MULTICAST

   if (IN_MULTICAST(ntohl(pip->ip_dest))) 
 8242e2c:	e0bff817 	ldw	r2,-32(fp)
 8242e30:	10800417 	ldw	r2,16(r2)
 8242e34:	1006d63a 	srli	r3,r2,24
 8242e38:	e0bff817 	ldw	r2,-32(fp)
 8242e3c:	10800417 	ldw	r2,16(r2)
 8242e40:	1004d23a 	srli	r2,r2,8
 8242e44:	10bfc00c 	andi	r2,r2,65280
 8242e48:	1886b03a 	or	r3,r3,r2
 8242e4c:	e0bff817 	ldw	r2,-32(fp)
 8242e50:	10800417 	ldw	r2,16(r2)
 8242e54:	10bfc00c 	andi	r2,r2,65280
 8242e58:	1004923a 	slli	r2,r2,8
 8242e5c:	1886b03a 	or	r3,r3,r2
 8242e60:	e0bff817 	ldw	r2,-32(fp)
 8242e64:	10800417 	ldw	r2,16(r2)
 8242e68:	1004963a 	slli	r2,r2,24
 8242e6c:	1884b03a 	or	r2,r3,r2
 8242e70:	10fc002c 	andhi	r3,r2,61440
 8242e74:	00b80034 	movhi	r2,57344
 8242e78:	1880171e 	bne	r3,r2,8242ed8 <ip_rcv_phase2+0xd8>
      struct in_multi * inm;
      /*
       * See if we belong to the destination multicast group on the
       * arrival interface.
       */
      inm = lookup_mcast(pip->ip_dest, nt);
 8242e7c:	e0bff817 	ldw	r2,-32(fp)
 8242e80:	10800417 	ldw	r2,16(r2)
 8242e84:	e17ff917 	ldw	r5,-28(fp)
 8242e88:	1009883a 	mov	r4,r2
 8242e8c:	82439f80 	call	82439f8 <lookup_mcast>
 8242e90:	e0bffa15 	stw	r2,-24(fp)
      if (inm == NULL) 
 8242e94:	e0bffa17 	ldw	r2,-24(fp)
 8242e98:	1001081e 	bne	r2,zero,82432bc <ip_rcv_phase2+0x4bc>
      {
         ip_mib.ipOutNoRoutes++;
 8242e9c:	008209b4 	movhi	r2,2086
 8242ea0:	10ba6a04 	addi	r2,r2,-5720
 8242ea4:	10800b17 	ldw	r2,44(r2)
 8242ea8:	10c00044 	addi	r3,r2,1
 8242eac:	008209b4 	movhi	r2,2086
 8242eb0:	10ba6a04 	addi	r2,r2,-5720
 8242eb4:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8242eb8:	01000084 	movi	r4,2
 8242ebc:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free(p);
 8242ec0:	e13fff17 	ldw	r4,-4(fp)
 8242ec4:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8242ec8:	01000084 	movi	r4,2
 8242ecc:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
 8242ed0:	00800084 	movi	r2,2
 8242ed4:	00013806 	br	82433b8 <ip_rcv_phase2+0x5b8>
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 8242ed8:	e0bff817 	ldw	r2,-32(fp)
 8242edc:	10c00417 	ldw	r3,16(r2)
 8242ee0:	e0bff917 	ldw	r2,-28(fp)
 8242ee4:	10800a17 	ldw	r2,40(r2)
 8242ee8:	1880f726 	beq	r3,r2,82432c8 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 8242eec:	e0bff817 	ldw	r2,-32(fp)
 8242ef0:	10800417 	ldw	r2,16(r2)
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 8242ef4:	10bfffe0 	cmpeqi	r2,r2,-1
 8242ef8:	1000f31e 	bne	r2,zero,82432c8 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
 8242efc:	e0bff817 	ldw	r2,-32(fp)
 8242f00:	10c00417 	ldw	r3,16(r2)
 8242f04:	e0bff917 	ldw	r2,-28(fp)
 8242f08:	10800e17 	ldw	r2,56(r2)
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 8242f0c:	1880ee26 	beq	r3,r2,82432c8 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
 8242f10:	e0bff817 	ldw	r2,-32(fp)
 8242f14:	10c00417 	ldw	r3,16(r2)
 8242f18:	e0bff917 	ldw	r2,-28(fp)
 8242f1c:	10800f17 	ldw	r2,60(r2)
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
 8242f20:	1880e926 	beq	r3,r2,82432c8 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
 8242f24:	e0bff817 	ldw	r2,-32(fp)
 8242f28:	10c00417 	ldw	r3,16(r2)
 8242f2c:	e0bff917 	ldw	r2,-28(fp)
 8242f30:	10801017 	ldw	r2,64(r2)
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
 8242f34:	1880e426 	beq	r3,r2,82432c8 <ip_rcv_phase2+0x4c8>
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
 8242f38:	e0bff917 	ldw	r2,-28(fp)
 8242f3c:	10c00a17 	ldw	r3,40(r2)
 8242f40:	e0bff917 	ldw	r2,-28(fp)
 8242f44:	10800c17 	ldw	r2,48(r2)
 8242f48:	0084303a 	nor	r2,zero,r2
 8242f4c:	1884703a 	and	r2,r3,r2

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
 8242f50:	1000dd26 	beq	r2,zero,82432c8 <ip_rcv_phase2+0x4c8>
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8242f54:	d0a08317 	ldw	r2,-32244(gp)
 8242f58:	1081000c 	andi	r2,r2,1024
 8242f5c:	10001826 	beq	r2,zero,8242fc0 <ip_rcv_phase2+0x1c0>
 8242f60:	d0a08317 	ldw	r2,-32244(gp)
 8242f64:	1080800c 	andi	r2,r2,512
 8242f68:	10001526 	beq	r2,zero,8242fc0 <ip_rcv_phase2+0x1c0>
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
       PUSH_IPADDR(pip->ip_dest));
 8242f6c:	e0bff817 	ldw	r2,-32(fp)
 8242f70:	10800417 	ldw	r2,16(r2)
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8242f74:	10c03fcc 	andi	r3,r2,255
       PUSH_IPADDR(pip->ip_dest));
 8242f78:	e0bff817 	ldw	r2,-32(fp)
 8242f7c:	10800417 	ldw	r2,16(r2)
 8242f80:	1004d23a 	srli	r2,r2,8
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8242f84:	11003fcc 	andi	r4,r2,255
       PUSH_IPADDR(pip->ip_dest));
 8242f88:	e0bff817 	ldw	r2,-32(fp)
 8242f8c:	10800417 	ldw	r2,16(r2)
 8242f90:	1004d43a 	srli	r2,r2,16
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8242f94:	11403fcc 	andi	r5,r2,255
       PUSH_IPADDR(pip->ip_dest));
 8242f98:	e0bff817 	ldw	r2,-32(fp)
 8242f9c:	10800417 	ldw	r2,16(r2)
 8242fa0:	1004d63a 	srli	r2,r2,24
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 8242fa4:	d8800015 	stw	r2,0(sp)
 8242fa8:	280f883a 	mov	r7,r5
 8242fac:	200d883a 	mov	r6,r4
 8242fb0:	180b883a 	mov	r5,r3
 8242fb4:	01020974 	movhi	r4,2085
 8242fb8:	21054d04 	addi	r4,r4,5428
 8242fbc:	820331c0 	call	820331c <printf>

#ifdef IP_ROUTING    /* if multi-homed router, try to route */
      /* Do routing only if ipForwarding is enabled in the IP MIB. This
       * is the switch for routing whether SNMP is used or not.
       */
      if (ip_mib.ipForwarding == 2)
 8242fc0:	008209b4 	movhi	r2,2086
 8242fc4:	10ba6a04 	addi	r2,r2,-5720
 8242fc8:	10800017 	ldw	r2,0(r2)
 8242fcc:	10800098 	cmpnei	r2,r2,2
 8242fd0:	10000f1e 	bne	r2,zero,8243010 <ip_rcv_phase2+0x210>
      {
         ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 8242fd4:	008209b4 	movhi	r2,2086
 8242fd8:	10ba6a04 	addi	r2,r2,-5720
 8242fdc:	10800a17 	ldw	r2,40(r2)
 8242fe0:	10c00044 	addi	r3,r2,1
 8242fe4:	008209b4 	movhi	r2,2086
 8242fe8:	10ba6a04 	addi	r2,r2,-5720
 8242fec:	10c00a15 	stw	r3,40(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 8242ff0:	01000084 	movi	r4,2
 8242ff4:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
         pk_free(p);
 8242ff8:	e13fff17 	ldw	r4,-4(fp)
 8242ffc:	822cbbc0 	call	822cbbc <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243000:	01000084 	movi	r4,2
 8243004:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_NO_ROUTE;
 8243008:	00bff7c4 	movi	r2,-33
 824300c:	0000ea06 	br	82433b8 <ip_rcv_phase2+0x5b8>
         NET outnet;
#ifdef IP_FRAGMENTS
         int err;
#endif

         ip_mib.ipForwDatagrams++;  /* Count MIB-2 route attempts here */
 8243010:	008209b4 	movhi	r2,2086
 8243014:	10ba6a04 	addi	r2,r2,-5720
 8243018:	10800517 	ldw	r2,20(r2)
 824301c:	10c00044 	addi	r3,r2,1
 8243020:	008209b4 	movhi	r2,2086
 8243024:	10ba6a04 	addi	r2,r2,-5720
 8243028:	10c00515 	stw	r3,20(r2)
         if (pip->ip_time <= 1)     /* Time to Live (hopcount) expired? */
 824302c:	e0bff817 	ldw	r2,-32(fp)
 8243030:	10800203 	ldbu	r2,8(r2)
 8243034:	10803fcc 	andi	r2,r2,255
 8243038:	108000a8 	cmpgeui	r2,r2,2
 824303c:	10001c1e 	bne	r2,zero,82430b0 <ip_rcv_phase2+0x2b0>
         {
            ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 8243040:	008209b4 	movhi	r2,2086
 8243044:	10ba6a04 	addi	r2,r2,-5720
 8243048:	10800a17 	ldw	r2,40(r2)
 824304c:	10c00044 	addi	r3,r2,1
 8243050:	008209b4 	movhi	r2,2086
 8243054:	10ba6a04 	addi	r2,r2,-5720
 8243058:	10c00a15 	stw	r3,40(r2)
#ifdef FULL_ICMP
            icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, (TIMEX <<8), p->net);
 824305c:	e0bff817 	ldw	r2,-32(fp)
 8243060:	10c00317 	ldw	r3,12(r2)
 8243064:	e0bfff17 	ldw	r2,-4(fp)
 8243068:	10800617 	ldw	r2,24(r2)
 824306c:	11000a17 	ldw	r4,40(r2)
 8243070:	e0bfff17 	ldw	r2,-4(fp)
 8243074:	10800617 	ldw	r2,24(r2)
 8243078:	d8800015 	stw	r2,0(sp)
 824307c:	01c2c004 	movi	r7,2816
 8243080:	e1bff817 	ldw	r6,-32(fp)
 8243084:	200b883a 	mov	r5,r4
 8243088:	1809883a 	mov	r4,r3
 824308c:	824ae140 	call	824ae14 <icmp_destun>
#endif   /* FULL_ICMP */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8243090:	01000084 	movi	r4,2
 8243094:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
            pk_free(p);
 8243098:	e13fff17 	ldw	r4,-4(fp)
 824309c:	822cbbc0 	call	822cbbc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82430a0:	01000084 	movi	r4,2
 82430a4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 82430a8:	00bff7c4 	movi	r2,-33
 82430ac:	0000c206 	br	82433b8 <ip_rcv_phase2+0x5b8>
         }

         p->fhost = pip->ip_dest;   /* set packet's target IP in net endian */
 82430b0:	e0bff817 	ldw	r2,-32(fp)
 82430b4:	10c00417 	ldw	r3,16(r2)
 82430b8:	e0bfff17 	ldw	r2,-4(fp)
 82430bc:	10c00715 	stw	r3,28(r2)
         if ((outnet = iproute(p->fhost, &firsthop)) == NULL)  /* find route */
 82430c0:	e0bfff17 	ldw	r2,-4(fp)
 82430c4:	10800717 	ldw	r2,28(r2)
 82430c8:	e0fffe04 	addi	r3,fp,-8
 82430cc:	180b883a 	mov	r5,r3
 82430d0:	1009883a 	mov	r4,r2
 82430d4:	8240b4c0 	call	8240b4c <iproute>
 82430d8:	e0bffb15 	stw	r2,-20(fp)
 82430dc:	e0bffb17 	ldw	r2,-20(fp)
 82430e0:	10000f1e 	bne	r2,zero,8243120 <ip_rcv_phase2+0x320>
         {
            ip_mib.ipOutNoRoutes++; /* count unroutable pkts */
 82430e4:	008209b4 	movhi	r2,2086
 82430e8:	10ba6a04 	addi	r2,r2,-5720
 82430ec:	10800b17 	ldw	r2,44(r2)
 82430f0:	10c00044 	addi	r3,r2,1
 82430f4:	008209b4 	movhi	r2,2086
 82430f8:	10ba6a04 	addi	r2,r2,-5720
 82430fc:	10c00b15 	stw	r3,44(r2)
            LOCK_NET_RESOURCE(FREEQ_RESID);
 8243100:	01000084 	movi	r4,2
 8243104:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
            pk_free(p);
 8243108:	e13fff17 	ldw	r4,-4(fp)
 824310c:	822cbbc0 	call	822cbbc <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243110:	01000084 	movi	r4,2
 8243114:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 8243118:	00bff7c4 	movi	r2,-33
 824311c:	0000a606 	br	82433b8 <ip_rcv_phase2+0x5b8>
         /* Check to see if the packet was is addressed to one of our IP
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
 8243120:	e0bff817 	ldw	r2,-32(fp)
 8243124:	10c00417 	ldw	r3,16(r2)
 8243128:	e0bffb17 	ldw	r2,-20(fp)
 824312c:	10800a17 	ldw	r2,40(r2)
 8243130:	18806426 	beq	r3,r2,82432c4 <ip_rcv_phase2+0x4c4>
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 8243134:	e0bff817 	ldw	r2,-32(fp)
 8243138:	10c00417 	ldw	r3,16(r2)
 824313c:	e0bffb17 	ldw	r2,-20(fp)
 8243140:	10800e17 	ldw	r2,56(r2)
 8243144:	18806026 	beq	r3,r2,82432c8 <ip_rcv_phase2+0x4c8>
            (pip->ip_dest == p->net->n_netbr))
 8243148:	e0bff817 	ldw	r2,-32(fp)
 824314c:	10c00417 	ldw	r3,16(r2)
 8243150:	e0bfff17 	ldw	r2,-4(fp)
 8243154:	10800617 	ldw	r2,24(r2)
 8243158:	10800e17 	ldw	r2,56(r2)
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 824315c:	18805a26 	beq	r3,r2,82432c8 <ip_rcv_phase2+0x4c8>
         {
            goto ours;            
         }

         /* Routed OK, prepare to send */
         p->net = outnet;           /* set iface to send on */
 8243160:	e0bfff17 	ldw	r2,-4(fp)
 8243164:	e0fffb17 	ldw	r3,-20(fp)
 8243168:	10c00615 	stw	r3,24(r2)
            }
         }
#endif   /* IPSEC */

         /* see if packet is too big for media of dest net */
         if ((p->nb_plen + p->net->n_lnh) > (unsigned)outnet->n_mtu)
 824316c:	e0bfff17 	ldw	r2,-4(fp)
 8243170:	10800417 	ldw	r2,16(r2)
 8243174:	e0ffff17 	ldw	r3,-4(fp)
 8243178:	18c00617 	ldw	r3,24(r3)
 824317c:	18c00817 	ldw	r3,32(r3)
 8243180:	10c5883a 	add	r2,r2,r3
 8243184:	e0fffb17 	ldw	r3,-20(fp)
 8243188:	18c00917 	ldw	r3,36(r3)
 824318c:	1880372e 	bgeu	r3,r2,824326c <ip_rcv_phase2+0x46c>
         {
#ifdef IP_FRAGMENTS
            /* see if we're not supposed to fragment it */
            if (ntohs(pip->ip_flgs_foff) & IP_FLG_DF)
 8243190:	e0bff817 	ldw	r2,-32(fp)
 8243194:	1080018b 	ldhu	r2,6(r2)
 8243198:	10bfffcc 	andi	r2,r2,65535
 824319c:	1004d23a 	srli	r2,r2,8
 82431a0:	10bfffcc 	andi	r2,r2,65535
 82431a4:	10c03fcc 	andi	r3,r2,255
 82431a8:	e0bff817 	ldw	r2,-32(fp)
 82431ac:	1080018b 	ldhu	r2,6(r2)
 82431b0:	10bfffcc 	andi	r2,r2,65535
 82431b4:	1004923a 	slli	r2,r2,8
 82431b8:	10bfffcc 	andi	r2,r2,65535
 82431bc:	1884b03a 	or	r2,r3,r2
 82431c0:	1090000c 	andi	r2,r2,16384
 82431c4:	10001c26 	beq	r2,zero,8243238 <ip_rcv_phase2+0x438>
            {
#ifdef FULL_ICMP
               icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 82431c8:	e0bff817 	ldw	r2,-32(fp)
 82431cc:	10c00317 	ldw	r3,12(r2)
 82431d0:	e0bfff17 	ldw	r2,-4(fp)
 82431d4:	10800617 	ldw	r2,24(r2)
 82431d8:	11000a17 	ldw	r4,40(r2)
 82431dc:	e0bfff17 	ldw	r2,-4(fp)
 82431e0:	10800617 	ldw	r2,24(r2)
 82431e4:	d8800015 	stw	r2,0(sp)
 82431e8:	01c00104 	movi	r7,4
 82431ec:	e1bff817 	ldw	r6,-32(fp)
 82431f0:	200b883a 	mov	r5,r4
 82431f4:	1809883a 	mov	r4,r3
 82431f8:	824ae140 	call	824ae14 <icmp_destun>
#endif   /* FULL_ICMP */
               ip_mib.ipFragFails++;
 82431fc:	008209b4 	movhi	r2,2086
 8243200:	10ba6a04 	addi	r2,r2,-5720
 8243204:	10801117 	ldw	r2,68(r2)
 8243208:	10c00044 	addi	r3,r2,1
 824320c:	008209b4 	movhi	r2,2086
 8243210:	10ba6a04 	addi	r2,r2,-5720
 8243214:	10c01115 	stw	r3,68(r2)
               LOCK_NET_RESOURCE(FREEQ_RESID);
 8243218:	01000084 	movi	r4,2
 824321c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
               pk_free(p);
 8243220:	e13fff17 	ldw	r4,-4(fp)
 8243224:	822cbbc0 	call	822cbbc <pk_free>
               UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243228:	01000084 	movi	r4,2
 824322c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
               IN_PROFILER(PF_IP, PF_EXIT);
               return ENP_LOGIC;
 8243230:	00bffd44 	movi	r2,-11
 8243234:	00006006 	br	82433b8 <ip_rcv_phase2+0x5b8>
            }

            /* fall to here if we're going to fragment it. */
            pip->ip_time--;            /* datagram's hop count */
 8243238:	e0bff817 	ldw	r2,-32(fp)
 824323c:	10800203 	ldbu	r2,8(r2)
 8243240:	10bfffc4 	addi	r2,r2,-1
 8243244:	1007883a 	mov	r3,r2
 8243248:	e0bff817 	ldw	r2,-32(fp)
 824324c:	10c00205 	stb	r3,8(r2)
            err = ip_fragment(p, firsthop);
 8243250:	e0bffe17 	ldw	r2,-8(fp)
 8243254:	100b883a 	mov	r5,r2
 8243258:	e13fff17 	ldw	r4,-4(fp)
 824325c:	824023c0 	call	824023c <ip_fragment>
 8243260:	e0bffc15 	stw	r2,-16(fp)
            IN_PROFILER(PF_IP, PF_EXIT);
            return(err);
 8243264:	e0bffc17 	ldw	r2,-16(fp)
 8243268:	00005306 	br	82433b8 <ip_rcv_phase2+0x5b8>
            pk_free(p);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
            return ENP_LOGIC;
#endif   /* IP_FRAGMENTS */
         }
         pip->ip_time--;            /* datagram's hop count */
 824326c:	e0bff817 	ldw	r2,-32(fp)
 8243270:	10800203 	ldbu	r2,8(r2)
 8243274:	10bfffc4 	addi	r2,r2,-1
 8243278:	1007883a 	mov	r3,r2
 824327c:	e0bff817 	ldw	r2,-32(fp)
 8243280:	10c00205 	stb	r3,8(r2)
         pip->ip_chksum = IPXSUM;   /* clear checksum field for summing */
 8243284:	e0bff817 	ldw	r2,-32(fp)
 8243288:	1000028d 	sth	zero,10(r2)
         pip->ip_chksum = ~cksum(pip, 10);   /* new xsum */
 824328c:	01400284 	movi	r5,10
 8243290:	e13ff817 	ldw	r4,-32(fp)
 8243294:	82286f00 	call	82286f0 <cksum>
 8243298:	0084303a 	nor	r2,zero,r2
 824329c:	1007883a 	mov	r3,r2
 82432a0:	e0bff817 	ldw	r2,-32(fp)
 82432a4:	10c0028d 	sth	r3,10(r2)
         IN_PROFILER(PF_IP, PF_EXIT);
#ifdef RF_SIMULATION
         if(rfsim_routing)
            return(rfsim_send(p, firsthop));
#endif   /* RF_SIMULATION */
         return(ip2mac(p, firsthop));
 82432a8:	e0bffe17 	ldw	r2,-8(fp)
 82432ac:	100b883a 	mov	r5,r2
 82432b0:	e13fff17 	ldw	r4,-4(fp)
 82432b4:	82266340 	call	8226634 <ip2mac>
 82432b8:	00003f06 	br	82433b8 <ip_rcv_phase2+0x5b8>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
      }
      else
         goto ours;
 82432bc:	0001883a 	nop
 82432c0:	00000106 	br	82432c8 <ip_rcv_phase2+0x4c8>
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
            goto ours;
 82432c4:	0001883a 	nop
#if defined (IP_MULTICAST) || defined (IP_ROUTING)
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
 82432c8:	e0bff817 	ldw	r2,-32(fp)
 82432cc:	1080018b 	ldhu	r2,6(r2)
 82432d0:	10bfffcc 	andi	r2,r2,65535
 82432d4:	1004d23a 	srli	r2,r2,8
 82432d8:	1007883a 	mov	r3,r2
 82432dc:	e0bff817 	ldw	r2,-32(fp)
 82432e0:	1080018b 	ldhu	r2,6(r2)
 82432e4:	10bfffcc 	andi	r2,r2,65535
 82432e8:	1004923a 	slli	r2,r2,8
 82432ec:	1884b03a 	or	r2,r3,r2
 82432f0:	e0bffd0d 	sth	r2,-12(fp)
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 82432f4:	e0bffd0b 	ldhu	r2,-12(fp)
 82432f8:	1088000c 	andi	r2,r2,8192
 82432fc:	1000051e 	bne	r2,zero,8243314 <ip_rcv_phase2+0x514>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
 8243300:	e0fffd0b 	ldhu	r3,-12(fp)
 8243304:	00bffff4 	movhi	r2,65535
 8243308:	1087ffc4 	addi	r2,r2,8191
 824330c:	1884703a 	and	r2,r3,r2
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 8243310:	10002726 	beq	r2,zero,82433b0 <ip_rcv_phase2+0x5b0>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 8243314:	d0a08317 	ldw	r2,-32244(gp)
 8243318:	1081000c 	andi	r2,r2,1024
 824331c:	10001a26 	beq	r2,zero,8243388 <ip_rcv_phase2+0x588>
 8243320:	d0a08317 	ldw	r2,-32244(gp)
 8243324:	1080800c 	andi	r2,r2,512
 8243328:	10001726 	beq	r2,zero,8243388 <ip_rcv_phase2+0x588>
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
          PUSH_IPADDR(pip->ip_src));
 824332c:	e0bff817 	ldw	r2,-32(fp)
 8243330:	10800317 	ldw	r2,12(r2)
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243334:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(pip->ip_src));
 8243338:	e0bff817 	ldw	r2,-32(fp)
 824333c:	10800317 	ldw	r2,12(r2)
 8243340:	1004d23a 	srli	r2,r2,8
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243344:	11003fcc 	andi	r4,r2,255
          PUSH_IPADDR(pip->ip_src));
 8243348:	e0bff817 	ldw	r2,-32(fp)
 824334c:	10800317 	ldw	r2,12(r2)
 8243350:	1004d43a 	srli	r2,r2,16
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243354:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(pip->ip_src));
 8243358:	e0bff817 	ldw	r2,-32(fp)
 824335c:	10800317 	ldw	r2,12(r2)
 8243360:	1004d63a 	srli	r2,r2,24
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 8243364:	d8800015 	stw	r2,0(sp)
 8243368:	280f883a 	mov	r7,r5
 824336c:	200d883a 	mov	r6,r4
 8243370:	180b883a 	mov	r5,r3
 8243374:	01020974 	movhi	r4,2085
 8243378:	21055904 	addi	r4,r4,5476
 824337c:	820331c0 	call	820331c <printf>
          PUSH_IPADDR(pip->ip_src));
         ip_dump(p);
 8243380:	e13fff17 	ldw	r4,-4(fp)
 8243384:	82408a40 	call	82408a4 <ip_dump>
      }
#endif
      ip_mib.ipReasmReqds++;     /* got a reassemble request; ie a frag */
 8243388:	008209b4 	movhi	r2,2086
 824338c:	10ba6a04 	addi	r2,r2,-5720
 8243390:	10800d17 	ldw	r2,52(r2)
 8243394:	10c00044 	addi	r3,r2,1
 8243398:	008209b4 	movhi	r2,2086
 824339c:	10ba6a04 	addi	r2,r2,-5720
 82433a0:	10c00d15 	stw	r3,52(r2)
#ifdef IP_FRAGMENTS
      return(ip_reassm(p));
 82433a4:	e13fff17 	ldw	r4,-4(fp)
 82433a8:	82414700 	call	8241470 <ip_reassm>
 82433ac:	00000206 	br	82433b8 <ip_rcv_phase2+0x5b8>
   {
      return ENP_LOGIC;
   }
#endif /* IPSEC */

   return(ip_demux(p));    /* demux to correct to upper layer */
 82433b0:	e13fff17 	ldw	r4,-4(fp)
 82433b4:	82433cc0 	call	82433cc <ip_demux>
}
 82433b8:	e037883a 	mov	sp,fp
 82433bc:	dfc00117 	ldw	ra,4(sp)
 82433c0:	df000017 	ldw	fp,0(sp)
 82433c4:	dec00204 	addi	sp,sp,8
 82433c8:	f800283a 	ret

082433cc <ip_demux>:
 * RETURNS: Same return values as ip_rcv(). 
 */

int
ip_demux(PACKET p)
{
 82433cc:	defff904 	addi	sp,sp,-28
 82433d0:	dfc00615 	stw	ra,24(sp)
 82433d4:	df000515 	stw	fp,20(sp)
 82433d8:	df000504 	addi	fp,sp,20
 82433dc:	e13fff15 	stw	r4,-4(fp)
   int   err;

   /* The packet is verified; the header is correct. Now we have
    * to demultiplex it among our internet connections.
    */
   pip = (struct ip *)(p->nb_prot);
 82433e0:	e0bfff17 	ldw	r2,-4(fp)
 82433e4:	10800317 	ldw	r2,12(r2)
 82433e8:	e0bffe15 	stw	r2,-8(fp)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
 82433ec:	e0bffe17 	ldw	r2,-8(fp)
 82433f0:	10800003 	ldbu	r2,0(r2)
 82433f4:	10803fcc 	andi	r2,r2,255
 82433f8:	10801160 	cmpeqi	r2,r2,69
 82433fc:	1000131e 	bne	r2,zero,824344c <ip_demux+0x80>
   {
      if((pip->ip_ver_ihl < 0x45) ||
 8243400:	e0bffe17 	ldw	r2,-8(fp)
 8243404:	10800003 	ldbu	r2,0(r2)
 8243408:	10803fcc 	andi	r2,r2,255
 824340c:	10801170 	cmpltui	r2,r2,69
 8243410:	1000051e 	bne	r2,zero,8243428 <ip_demux+0x5c>
         (pip->ip_ver_ihl > 0x47))
 8243414:	e0bffe17 	ldw	r2,-8(fp)
 8243418:	10800003 	ldbu	r2,0(r2)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
   {
      if((pip->ip_ver_ihl < 0x45) ||
 824341c:	10803fcc 	andi	r2,r2,255
 8243420:	10801230 	cmpltui	r2,r2,72
 8243424:	1000091e 	bne	r2,zero,824344c <ip_demux+0x80>
         (pip->ip_ver_ihl > 0x47))
      {
         dprintf("ip_demux: bad IP type 0x%x\n", pip->ip_ver_ihl);
 8243428:	e0bffe17 	ldw	r2,-8(fp)
 824342c:	10800003 	ldbu	r2,0(r2)
 8243430:	10803fcc 	andi	r2,r2,255
 8243434:	100b883a 	mov	r5,r2
 8243438:	01020974 	movhi	r4,2085
 824343c:	21056204 	addi	r4,r4,5512
 8243440:	820331c0 	call	820331c <printf>
         return ENP_LOGIC;
 8243444:	00bffd44 	movi	r2,-11
 8243448:	0000d006 	br	824378c <ip_demux+0x3c0>

   /* for profiling purposes count the upper layers (UDP, ICMP) in the IP
    * profile bucket. TCP will insert it's own nested profile calls 
    */
   IN_PROFILER(PF_IP, PF_ENTRY);
   p->fhost = pip->ip_src;
 824344c:	e0bffe17 	ldw	r2,-8(fp)
 8243450:	10c00317 	ldw	r3,12(r2)
 8243454:	e0bfff17 	ldw	r2,-4(fp)
 8243458:	10c00715 	stw	r3,28(r2)

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824345c:	d0a08317 	ldw	r2,-32244(gp)
 8243460:	1081000c 	andi	r2,r2,1024
 8243464:	10002126 	beq	r2,zero,82434ec <ip_demux+0x120>
 8243468:	d0a08317 	ldw	r2,-32244(gp)
 824346c:	1080800c 	andi	r2,r2,512
 8243470:	10001e26 	beq	r2,zero,82434ec <ip_demux+0x120>
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 8243474:	e0bffe17 	ldw	r2,-8(fp)
 8243478:	10800243 	ldbu	r2,9(r2)
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 824347c:	11003fcc 	andi	r4,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 8243480:	e0bffe17 	ldw	r2,-8(fp)
 8243484:	10800317 	ldw	r2,12(r2)
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 8243488:	11403fcc 	andi	r5,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 824348c:	e0bffe17 	ldw	r2,-8(fp)
 8243490:	10800317 	ldw	r2,12(r2)
 8243494:	1004d23a 	srli	r2,r2,8
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 8243498:	11803fcc 	andi	r6,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 824349c:	e0bffe17 	ldw	r2,-8(fp)
 82434a0:	10800317 	ldw	r2,12(r2)
 82434a4:	1004d43a 	srli	r2,r2,16
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 82434a8:	10803fcc 	andi	r2,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 82434ac:	e0fffe17 	ldw	r3,-8(fp)
 82434b0:	18c00317 	ldw	r3,12(r3)
 82434b4:	1806d63a 	srli	r3,r3,24
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 82434b8:	d8c00115 	stw	r3,4(sp)
 82434bc:	d8800015 	stw	r2,0(sp)
 82434c0:	300f883a 	mov	r7,r6
 82434c4:	280d883a 	mov	r6,r5
 82434c8:	200b883a 	mov	r5,r4
 82434cc:	01020974 	movhi	r4,2085
 82434d0:	21056904 	addi	r4,r4,5540
 82434d4:	820331c0 	call	820331c <printf>
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
      if (NDEBUG & DUMP) ip_dump(p);
 82434d8:	d0a08317 	ldw	r2,-32244(gp)
 82434dc:	1080008c 	andi	r2,r2,2
 82434e0:	10000226 	beq	r2,zero,82434ec <ip_demux+0x120>
 82434e4:	e13fff17 	ldw	r4,-4(fp)
 82434e8:	82408a40 	call	82408a4 <ip_dump>
   }
#endif

   switch (pip->ip_prot)
 82434ec:	e0bffe17 	ldw	r2,-8(fp)
 82434f0:	10800243 	ldbu	r2,9(r2)
 82434f4:	10803fcc 	andi	r2,r2,255
 82434f8:	10c000a0 	cmpeqi	r3,r2,2
 82434fc:	18001f1e 	bne	r3,zero,824357c <ip_demux+0x1b0>
 8243500:	10c000c8 	cmpgei	r3,r2,3
 8243504:	1800031e 	bne	r3,zero,8243514 <ip_demux+0x148>
 8243508:	10800060 	cmpeqi	r2,r2,1
 824350c:	1000101e 	bne	r2,zero,8243550 <ip_demux+0x184>
 8243510:	00003006 	br	82435d4 <ip_demux+0x208>
 8243514:	10c001a0 	cmpeqi	r3,r2,6
 8243518:	1800231e 	bne	r3,zero,82435a8 <ip_demux+0x1dc>
 824351c:	10800460 	cmpeqi	r2,r2,17
 8243520:	10002c26 	beq	r2,zero,82435d4 <ip_demux+0x208>
   {
   case UDP_PROT:
      ip_mib.ipInDelivers++;
 8243524:	008209b4 	movhi	r2,2086
 8243528:	10ba6a04 	addi	r2,r2,-5720
 824352c:	10800817 	ldw	r2,32(r2)
 8243530:	10c00044 	addi	r3,r2,1
 8243534:	008209b4 	movhi	r2,2086
 8243538:	10ba6a04 	addi	r2,r2,-5720
 824353c:	10c00815 	stw	r3,32(r2)
      err = udpdemux(p);
 8243540:	e13fff17 	ldw	r4,-4(fp)
 8243544:	82446540 	call	8244654 <udpdemux>
 8243548:	e0bffd15 	stw	r2,-12(fp)
      break;
 824354c:	00002c06 	br	8243600 <ip_demux+0x234>
   case ICMP_PROT:
      ip_mib.ipInDelivers++;
 8243550:	008209b4 	movhi	r2,2086
 8243554:	10ba6a04 	addi	r2,r2,-5720
 8243558:	10800817 	ldw	r2,32(r2)
 824355c:	10c00044 	addi	r3,r2,1
 8243560:	008209b4 	movhi	r2,2086
 8243564:	10ba6a04 	addi	r2,r2,-5720
 8243568:	10c00815 	stw	r3,32(r2)
      err = icmprcv(p);
 824356c:	e13fff17 	ldw	r4,-4(fp)
 8243570:	824a2b00 	call	824a2b0 <icmprcv>
 8243574:	e0bffd15 	stw	r2,-12(fp)
      break;
 8243578:	00002106 	br	8243600 <ip_demux+0x234>
#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   case IGMP_PROT:
      ip_mib.ipInDelivers++;
 824357c:	008209b4 	movhi	r2,2086
 8243580:	10ba6a04 	addi	r2,r2,-5720
 8243584:	10800817 	ldw	r2,32(r2)
 8243588:	10c00044 	addi	r3,r2,1
 824358c:	008209b4 	movhi	r2,2086
 8243590:	10ba6a04 	addi	r2,r2,-5720
 8243594:	10c00815 	stw	r3,32(r2)
      err = igmp_input(p);
 8243598:	e13fff17 	ldw	r4,-4(fp)
 824359c:	8226ccc0 	call	8226ccc <igmp_input>
 82435a0:	e0bffd15 	stw	r2,-12(fp)
      break;
 82435a4:	00001606 	br	8243600 <ip_demux+0x234>
#endif   /* IP_MULTICAST and (IGMPv1 or IGMPv2) */
#ifdef INCLUDE_TCP
   case TCP_PROT:
      ip_mib.ipInDelivers++;
 82435a8:	008209b4 	movhi	r2,2086
 82435ac:	10ba6a04 	addi	r2,r2,-5720
 82435b0:	10800817 	ldw	r2,32(r2)
 82435b4:	10c00044 	addi	r3,r2,1
 82435b8:	008209b4 	movhi	r2,2086
 82435bc:	10ba6a04 	addi	r2,r2,-5720
 82435c0:	10c00815 	stw	r3,32(r2)
      err = tcp_rcv(p);
 82435c4:	e13fff17 	ldw	r4,-4(fp)
 82435c8:	822ec840 	call	822ec84 <tcp_rcv>
 82435cc:	e0bffd15 	stw	r2,-12(fp)
      break;
 82435d0:	00000b06 	br	8243600 <ip_demux+0x234>
      err = v6t_rcv(p);
      break;
#endif /* IPV6_TUNNEL */
   default: /* unknown upper protocol */
#ifdef IP_RAW
      ip_mib.ipInDelivers++;
 82435d4:	008209b4 	movhi	r2,2086
 82435d8:	10ba6a04 	addi	r2,r2,-5720
 82435dc:	10800817 	ldw	r2,32(r2)
 82435e0:	10c00044 	addi	r3,r2,1
 82435e4:	008209b4 	movhi	r2,2086
 82435e8:	10ba6a04 	addi	r2,r2,-5720
 82435ec:	10c00815 	stw	r3,32(r2)
      err = ip_raw_input(p);
 82435f0:	e13fff17 	ldw	r4,-4(fp)
 82435f4:	8243cc40 	call	8243cc4 <ip_raw_input>
 82435f8:	e0bffd15 	stw	r2,-12(fp)
      break;
 82435fc:	0001883a 	nop
#endif /* IP_RAW */
   }

   IN_PROFILER(PF_IP, PF_EXIT);

   if(err != ENP_PARAM)
 8243600:	e0bffd17 	ldw	r2,-12(fp)
 8243604:	10bffda0 	cmpeqi	r2,r2,-10
 8243608:	1000021e 	bne	r2,zero,8243614 <ip_demux+0x248>
   {
      return err;
 824360c:	e0bffd17 	ldw	r2,-12(fp)
 8243610:	00005e06 	br	824378c <ip_demux+0x3c0>

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 8243614:	e0bffe17 	ldw	r2,-8(fp)
 8243618:	10800417 	ldw	r2,16(r2)
 824361c:	10bfffe0 	cmpeqi	r2,r2,-1
 8243620:	10004c1e 	bne	r2,zero,8243754 <ip_demux+0x388>
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
 8243624:	e0bffe17 	ldw	r2,-8(fp)
 8243628:	10800417 	ldw	r2,16(r2)
 824362c:	1006d63a 	srli	r3,r2,24
 8243630:	e0bffe17 	ldw	r2,-8(fp)
 8243634:	10800417 	ldw	r2,16(r2)
 8243638:	1004d23a 	srli	r2,r2,8
 824363c:	10bfc00c 	andi	r2,r2,65280
 8243640:	1886b03a 	or	r3,r3,r2
 8243644:	e0bffe17 	ldw	r2,-8(fp)
 8243648:	10800417 	ldw	r2,16(r2)
 824364c:	10bfc00c 	andi	r2,r2,65280
 8243650:	1004923a 	slli	r2,r2,8
 8243654:	1886b03a 	or	r3,r3,r2
 8243658:	e0bffe17 	ldw	r2,-8(fp)
 824365c:	10800417 	ldw	r2,16(r2)
 8243660:	1004963a 	slli	r2,r2,24
 8243664:	1884b03a 	or	r2,r3,r2
 8243668:	10fc002c 	andhi	r3,r2,61440

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 824366c:	00b80034 	movhi	r2,57344
 8243670:	18803826 	beq	r3,r2,8243754 <ip_demux+0x388>
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
 8243674:	e0bffe17 	ldw	r2,-8(fp)
 8243678:	10c00417 	ldw	r3,16(r2)
 824367c:	e0bfff17 	ldw	r2,-4(fp)
 8243680:	10800617 	ldw	r2,24(r2)
 8243684:	10800e17 	ldw	r2,56(r2)
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
 8243688:	18803226 	beq	r3,r2,8243754 <ip_demux+0x388>
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
 824368c:	e0bffe17 	ldw	r2,-8(fp)
 8243690:	10c00417 	ldw	r3,16(r2)
 8243694:	e0bfff17 	ldw	r2,-4(fp)
 8243698:	10800617 	ldw	r2,24(r2)
 824369c:	10800f17 	ldw	r2,60(r2)
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
 82436a0:	18802c26 	beq	r3,r2,8243754 <ip_demux+0x388>
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
 82436a4:	e0bffe17 	ldw	r2,-8(fp)
 82436a8:	10c00417 	ldw	r3,16(r2)
 82436ac:	e0bfff17 	ldw	r2,-4(fp)
 82436b0:	10800617 	ldw	r2,24(r2)
 82436b4:	10801017 	ldw	r2,64(r2)
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
 82436b8:	18802626 	beq	r3,r2,8243754 <ip_demux+0x388>
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
 82436bc:	e0bfff17 	ldw	r2,-4(fp)
 82436c0:	10800617 	ldw	r2,24(r2)
 82436c4:	10c00a17 	ldw	r3,40(r2)
 82436c8:	e0bfff17 	ldw	r2,-4(fp)
 82436cc:	10800617 	ldw	r2,24(r2)
 82436d0:	10801017 	ldw	r2,64(r2)
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
 82436d4:	18801f26 	beq	r3,r2,8243754 <ip_demux+0x388>
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
   {

#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 82436d8:	d0a08317 	ldw	r2,-32244(gp)
 82436dc:	1081000c 	andi	r2,r2,1024
 82436e0:	10000f26 	beq	r2,zero,8243720 <ip_demux+0x354>
 82436e4:	d0a08317 	ldw	r2,-32244(gp)
 82436e8:	1080800c 	andi	r2,r2,512
 82436ec:	10000c26 	beq	r2,zero,8243720 <ip_demux+0x354>
      {
         dprintf("ip_demux: unhandled prot %u\n", pip->ip_prot);
 82436f0:	e0bffe17 	ldw	r2,-8(fp)
 82436f4:	10800243 	ldbu	r2,9(r2)
 82436f8:	10803fcc 	andi	r2,r2,255
 82436fc:	100b883a 	mov	r5,r2
 8243700:	01020974 	movhi	r4,2085
 8243704:	21057304 	addi	r4,r4,5580
 8243708:	820331c0 	call	820331c <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824370c:	d0a08317 	ldw	r2,-32244(gp)
 8243710:	1080008c 	andi	r2,r2,2
 8243714:	10000226 	beq	r2,zero,8243720 <ip_demux+0x354>
 8243718:	e13fff17 	ldw	r4,-4(fp)
 824371c:	82408a40 	call	82408a4 <ip_dump>
      }
#endif   /* NPDEBUG */
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTPROT, p->net);
 8243720:	e0bffe17 	ldw	r2,-8(fp)
 8243724:	10c00317 	ldw	r3,12(r2)
 8243728:	e0bfff17 	ldw	r2,-4(fp)
 824372c:	10800617 	ldw	r2,24(r2)
 8243730:	11000a17 	ldw	r4,40(r2)
 8243734:	e0bfff17 	ldw	r2,-4(fp)
 8243738:	10800617 	ldw	r2,24(r2)
 824373c:	d8800015 	stw	r2,0(sp)
 8243740:	01c00084 	movi	r7,2
 8243744:	e1bffe17 	ldw	r6,-8(fp)
 8243748:	200b883a 	mov	r5,r4
 824374c:	1809883a 	mov	r4,r3
 8243750:	824ae140 	call	824ae14 <icmp_destun>
   }
#endif   /* FULL_ICMP */

   ip_mib.ipUnknownProtos++;
 8243754:	008209b4 	movhi	r2,2086
 8243758:	10ba6a04 	addi	r2,r2,-5720
 824375c:	10800617 	ldw	r2,24(r2)
 8243760:	10c00044 	addi	r3,r2,1
 8243764:	008209b4 	movhi	r2,2086
 8243768:	10ba6a04 	addi	r2,r2,-5720
 824376c:	10c00615 	stw	r3,24(r2)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8243770:	01000084 	movi	r4,2
 8243774:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   pk_free(p);
 8243778:	e13fff17 	ldw	r4,-4(fp)
 824377c:	822cbbc0 	call	822cbbc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243780:	01000084 	movi	r4,2
 8243784:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   return ENP_NOT_MINE;
 8243788:	00800084 	movi	r2,2
}
 824378c:	e037883a 	mov	sp,fp
 8243790:	dfc00117 	ldw	ra,4(sp)
 8243794:	df000017 	ldw	fp,0(sp)
 8243798:	dec00204 	addi	sp,sp,8
 824379c:	f800283a 	ret

082437a0 <in_addmulti>:
 * RETURNS: 
 */

struct in_multi * 
in_addmulti(ip_addr *ap, struct net *netp, int addrtype)
{
 82437a0:	defff904 	addi	sp,sp,-28
 82437a4:	dfc00615 	stw	ra,24(sp)
 82437a8:	df000515 	stw	fp,20(sp)
 82437ac:	df000504 	addi	fp,sp,20
 82437b0:	e13ffd15 	stw	r4,-12(fp)
 82437b4:	e17ffe15 	stw	r5,-8(fp)
 82437b8:	e1bfff15 	stw	r6,-4(fp)
   struct in_multi *inm = (struct in_multi *)NULL;
 82437bc:	e03ffb15 	stw	zero,-20(fp)
   int error;

   /* check for good addr. */
   if ((ap == (ip_addr *)NULL) || (*ap == 0))
 82437c0:	e0bffd17 	ldw	r2,-12(fp)
 82437c4:	10000326 	beq	r2,zero,82437d4 <in_addmulti+0x34>
 82437c8:	e0bffd17 	ldw	r2,-12(fp)
 82437cc:	10800017 	ldw	r2,0(r2)
 82437d0:	1000021e 	bne	r2,zero,82437dc <in_addmulti+0x3c>
      return ((struct in_multi *)NULL);  
 82437d4:	0005883a 	mov	r2,zero
 82437d8:	00003f06 	br	82438d8 <in_addmulti+0x138>

   ENTER_CRIT_SECTION(netp);
 82437dc:	822d5ec0 	call	822d5ec <irq_Mask>
#ifdef IP_V6
   if(addrtype == 6)
      inm = v6_lookup_mcast((ip6_addr*)ap, netp);
#endif
#ifdef IP_V4
   if(addrtype != 6)
 82437e0:	e0bfff17 	ldw	r2,-4(fp)
 82437e4:	108001a0 	cmpeqi	r2,r2,6
 82437e8:	1000061e 	bne	r2,zero,8243804 <in_addmulti+0x64>
      inm = lookup_mcast(*ap, netp);
 82437ec:	e0bffd17 	ldw	r2,-12(fp)
 82437f0:	10800017 	ldw	r2,0(r2)
 82437f4:	e17ffe17 	ldw	r5,-8(fp)
 82437f8:	1009883a 	mov	r4,r2
 82437fc:	82439f80 	call	82439f8 <lookup_mcast>
 8243800:	e0bffb15 	stw	r2,-20(fp)
#endif

   if (inm != (struct in_multi *)NULL) 
 8243804:	e0bffb17 	ldw	r2,-20(fp)
 8243808:	10000626 	beq	r2,zero,8243824 <in_addmulti+0x84>
   {
      /* Found it; just increment the reference count. */
      ++inm->inm_refcount;
 824380c:	e0bffb17 	ldw	r2,-20(fp)
 8243810:	10800217 	ldw	r2,8(r2)
 8243814:	10c00044 	addi	r3,r2,1
 8243818:	e0bffb17 	ldw	r2,-20(fp)
 824381c:	10c00215 	stw	r3,8(r2)
 8243820:	00002b06 	br	82438d0 <in_addmulti+0x130>
   {
      /*
       * New address; allocate a new multicast record
       * and link it into the interface's multicast list.
       */
      inm = (struct in_multi *)INM_ALLOC(sizeof(*inm));
 8243824:	01000604 	movi	r4,24
 8243828:	822dfec0 	call	822dfec <npalloc>
 824382c:	e0bffb15 	stw	r2,-20(fp)

      if (inm == (struct in_multi *)NULL) 
 8243830:	e0bffb17 	ldw	r2,-20(fp)
 8243834:	1000031e 	bne	r2,zero,8243844 <in_addmulti+0xa4>
      {
         EXIT_CRIT_SECTION(netp);
 8243838:	822d64c0 	call	822d64c <irq_Unmask>
         return ((struct in_multi *)NULL);
 824383c:	0005883a 	mov	r2,zero
 8243840:	00002506 	br	82438d8 <in_addmulti+0x138>
#ifdef IP_V6
      if(addrtype == 6)
         IP6CPY(&inm->ip6addr, (struct in6_addr *)ap);
#endif
#ifdef IP_V4
      if(addrtype != 6)
 8243844:	e0bfff17 	ldw	r2,-4(fp)
 8243848:	108001a0 	cmpeqi	r2,r2,6
 824384c:	1000041e 	bne	r2,zero,8243860 <in_addmulti+0xc0>
         inm->inm_addr = *ap;
 8243850:	e0bffd17 	ldw	r2,-12(fp)
 8243854:	10c00017 	ldw	r3,0(r2)
 8243858:	e0bffb17 	ldw	r2,-20(fp)
 824385c:	10c00015 	stw	r3,0(r2)
#endif
      inm->inm_netp = netp;
 8243860:	e0bffb17 	ldw	r2,-20(fp)
 8243864:	e0fffe17 	ldw	r3,-8(fp)
 8243868:	10c00115 	stw	r3,4(r2)
      inm->inm_refcount = 1;
 824386c:	e0bffb17 	ldw	r2,-20(fp)
 8243870:	00c00044 	movi	r3,1
 8243874:	10c00215 	stw	r3,8(r2)
      inm->inm_next = netp->mc_list;
 8243878:	e0bffe17 	ldw	r2,-8(fp)
 824387c:	10c02c17 	ldw	r3,176(r2)
 8243880:	e0bffb17 	ldw	r2,-20(fp)
 8243884:	10c00515 	stw	r3,20(r2)
      netp->mc_list = inm;
 8243888:	e0bffe17 	ldw	r2,-8(fp)
 824388c:	e0fffb17 	ldw	r3,-20(fp)
 8243890:	10c02c15 	stw	r3,176(r2)
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the new address.
       */
      if(netp->n_mcastlist)
 8243894:	e0bffe17 	ldw	r2,-8(fp)
 8243898:	10802b17 	ldw	r2,172(r2)
 824389c:	10000626 	beq	r2,zero,82438b8 <in_addmulti+0x118>
         error = netp->n_mcastlist(inm);
 82438a0:	e0bffe17 	ldw	r2,-8(fp)
 82438a4:	10802b17 	ldw	r2,172(r2)
 82438a8:	e13ffb17 	ldw	r4,-20(fp)
 82438ac:	103ee83a 	callr	r2
 82438b0:	e0bffc15 	stw	r2,-16(fp)
 82438b4:	00000106 	br	82438bc <in_addmulti+0x11c>
      else
         error = 0;
 82438b8:	e03ffc15 	stw	zero,-16(fp)
#if defined (IGMP_V1) || defined (IGMP_V2)
      /*
       * Let IGMP know that we have joined a new IP multicast group.
       */
      if (inm->inm_addr) igmp_joingroup(inm);
 82438bc:	e0bffb17 	ldw	r2,-20(fp)
 82438c0:	10800017 	ldw	r2,0(r2)
 82438c4:	10000226 	beq	r2,zero,82438d0 <in_addmulti+0x130>
 82438c8:	e13ffb17 	ldw	r4,-20(fp)
 82438cc:	82271bc0 	call	82271bc <igmp_joingroup>
#endif      
   }

   EXIT_CRIT_SECTION(netp);
 82438d0:	822d64c0 	call	822d64c <irq_Unmask>
   USE_ARG(error);

   return (inm);
 82438d4:	e0bffb17 	ldw	r2,-20(fp)
}
 82438d8:	e037883a 	mov	sp,fp
 82438dc:	dfc00117 	ldw	ra,4(sp)
 82438e0:	df000017 	ldw	fp,0(sp)
 82438e4:	dec00204 	addi	sp,sp,8
 82438e8:	f800283a 	ret

082438ec <in_delmulti>:
 * RETURNS: 
 */

void
in_delmulti(struct in_multi * inm)
{
 82438ec:	defffa04 	addi	sp,sp,-24
 82438f0:	dfc00515 	stw	ra,20(sp)
 82438f4:	df000415 	stw	fp,16(sp)
 82438f8:	df000404 	addi	fp,sp,16
 82438fc:	e13fff15 	stw	r4,-4(fp)
   struct in_multi * p;
   NET         netp = inm->inm_netp;
 8243900:	e0bfff17 	ldw	r2,-4(fp)
 8243904:	10800117 	ldw	r2,4(r2)
 8243908:	e0bffe15 	stw	r2,-8(fp)
   int error;

   ENTER_CRIT_SECTION(inm);
 824390c:	822d5ec0 	call	822d5ec <irq_Mask>
   if (--inm->inm_refcount == 0) 
 8243910:	e0bfff17 	ldw	r2,-4(fp)
 8243914:	10800217 	ldw	r2,8(r2)
 8243918:	10ffffc4 	addi	r3,r2,-1
 824391c:	e0bfff17 	ldw	r2,-4(fp)
 8243920:	10c00215 	stw	r3,8(r2)
 8243924:	e0bfff17 	ldw	r2,-4(fp)
 8243928:	10800217 	ldw	r2,8(r2)
 824392c:	10002b1e 	bne	r2,zero,82439dc <in_delmulti+0xf0>
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 8243930:	e0bffe17 	ldw	r2,-8(fp)
 8243934:	10802c17 	ldw	r2,176(r2)
 8243938:	e0bffc15 	stw	r2,-16(fp)
 824393c:	00001406 	br	8243990 <in_delmulti+0xa4>
      {
         if(p == inm)   /* inm is first in mc_list */
 8243940:	e0fffc17 	ldw	r3,-16(fp)
 8243944:	e0bfff17 	ldw	r2,-4(fp)
 8243948:	1880051e 	bne	r3,r2,8243960 <in_delmulti+0x74>
         {
            netp->mc_list = p->inm_next;  /* unlink */
 824394c:	e0bffc17 	ldw	r2,-16(fp)
 8243950:	10c00517 	ldw	r3,20(r2)
 8243954:	e0bffe17 	ldw	r2,-8(fp)
 8243958:	10c02c15 	stw	r3,176(r2)
            break;
 824395c:	00000e06 	br	8243998 <in_delmulti+0xac>
         }
         else if(p->inm_next == inm)   /* inm is next */
 8243960:	e0bffc17 	ldw	r2,-16(fp)
 8243964:	10c00517 	ldw	r3,20(r2)
 8243968:	e0bfff17 	ldw	r2,-4(fp)
 824396c:	1880051e 	bne	r3,r2,8243984 <in_delmulti+0x98>
         {
            p->inm_next = inm->inm_next;  /* unlink */
 8243970:	e0bfff17 	ldw	r2,-4(fp)
 8243974:	10c00517 	ldw	r3,20(r2)
 8243978:	e0bffc17 	ldw	r2,-16(fp)
 824397c:	10c00515 	stw	r3,20(r2)
            break;
 8243980:	00000506 	br	8243998 <in_delmulti+0xac>

   ENTER_CRIT_SECTION(inm);
   if (--inm->inm_refcount == 0) 
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 8243984:	e0bffc17 	ldw	r2,-16(fp)
 8243988:	10800517 	ldw	r2,20(r2)
 824398c:	e0bffc15 	stw	r2,-16(fp)
 8243990:	e0bffc17 	ldw	r2,-16(fp)
 8243994:	103fea1e 	bne	r2,zero,8243940 <in_delmulti+0x54>
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the deleted address.
       */
      if(netp->n_mcastlist)
 8243998:	e0bffe17 	ldw	r2,-8(fp)
 824399c:	10802b17 	ldw	r2,172(r2)
 82439a0:	10000626 	beq	r2,zero,82439bc <in_delmulti+0xd0>
         error = netp->n_mcastlist(inm);
 82439a4:	e0bffe17 	ldw	r2,-8(fp)
 82439a8:	10802b17 	ldw	r2,172(r2)
 82439ac:	e13fff17 	ldw	r4,-4(fp)
 82439b0:	103ee83a 	callr	r2
 82439b4:	e0bffd15 	stw	r2,-12(fp)
 82439b8:	00000106 	br	82439c0 <in_delmulti+0xd4>
      else
         error = 0;
 82439bc:	e03ffd15 	stw	zero,-12(fp)
#if defined (IGMP_V2)
      /*
       * No remaining claims to this record; let IGMP know that
       * we are leaving the multicast group.
       */
      if (inm->inm_addr) igmp_leavegroup(inm);
 82439c0:	e0bfff17 	ldw	r2,-4(fp)
 82439c4:	10800017 	ldw	r2,0(r2)
 82439c8:	10000226 	beq	r2,zero,82439d4 <in_delmulti+0xe8>
 82439cc:	e13fff17 	ldw	r4,-4(fp)
 82439d0:	82274100 	call	8227410 <igmp_leavegroup>
#endif      

      IM_FREE(inm);
 82439d4:	e13fff17 	ldw	r4,-4(fp)
 82439d8:	822e0200 	call	822e020 <npfree>
   }

   EXIT_CRIT_SECTION(inm);
 82439dc:	822d64c0 	call	822d64c <irq_Unmask>
   USE_ARG(error);
}
 82439e0:	0001883a 	nop
 82439e4:	e037883a 	mov	sp,fp
 82439e8:	dfc00117 	ldw	ra,4(sp)
 82439ec:	df000017 	ldw	fp,0(sp)
 82439f0:	dec00204 	addi	sp,sp,8
 82439f4:	f800283a 	ret

082439f8 <lookup_mcast>:
 * RETURNS: pointer to mcast addr structure, or NULL if not found.
 */

struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
 82439f8:	defffc04 	addi	sp,sp,-16
 82439fc:	df000315 	stw	fp,12(sp)
 8243a00:	df000304 	addi	fp,sp,12
 8243a04:	e13ffe15 	stw	r4,-8(fp)
 8243a08:	e17fff15 	stw	r5,-4(fp)
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 8243a0c:	e0bfff17 	ldw	r2,-4(fp)
 8243a10:	10802c17 	ldw	r2,176(r2)
 8243a14:	e0bffd15 	stw	r2,-12(fp)
 8243a18:	00000906 	br	8243a40 <lookup_mcast+0x48>
   {
      if(imp->inm_addr == addr)
 8243a1c:	e0bffd17 	ldw	r2,-12(fp)
 8243a20:	10c00017 	ldw	r3,0(r2)
 8243a24:	e0bffe17 	ldw	r2,-8(fp)
 8243a28:	1880021e 	bne	r3,r2,8243a34 <lookup_mcast+0x3c>
         return imp;
 8243a2c:	e0bffd17 	ldw	r2,-12(fp)
 8243a30:	00000606 	br	8243a4c <lookup_mcast+0x54>
struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 8243a34:	e0bffd17 	ldw	r2,-12(fp)
 8243a38:	10800517 	ldw	r2,20(r2)
 8243a3c:	e0bffd15 	stw	r2,-12(fp)
 8243a40:	e0bffd17 	ldw	r2,-12(fp)
 8243a44:	103ff51e 	bne	r2,zero,8243a1c <lookup_mcast+0x24>
   {
      if(imp->inm_addr == addr)
         return imp;
   }
   return NULL;   /* addr not found in mcast list */
 8243a48:	0005883a 	mov	r2,zero
}
 8243a4c:	e037883a 	mov	sp,fp
 8243a50:	df000017 	ldw	fp,0(sp)
 8243a54:	dec00104 	addi	sp,sp,4
 8243a58:	f800283a 	ret

08243a5c <prep_ifaces>:
 * passed value. 
 */

int
prep_ifaces(int ifaces_found)
{
 8243a5c:	defffd04 	addi	sp,sp,-12
 8243a60:	dfc00215 	stw	ra,8(sp)
 8243a64:	df000115 	stw	fp,4(sp)
 8243a68:	df000104 	addi	fp,sp,4
 8243a6c:	e13fff15 	stw	r4,-4(fp)
   if (port_prep)
 8243a70:	d0a0ca17 	ldw	r2,-31960(gp)
 8243a74:	10000426 	beq	r2,zero,8243a88 <prep_ifaces+0x2c>
      ifaces_found = port_prep(ifaces_found);
 8243a78:	d0a0ca17 	ldw	r2,-31960(gp)
 8243a7c:	e13fff17 	ldw	r4,-4(fp)
 8243a80:	103ee83a 	callr	r2
 8243a84:	e0bfff15 	stw	r2,-4(fp)

#ifdef MAC_LOOPBACK
   ifaces_found = prep_lb(ifaces_found);
#endif   /* MAC_LOOPBACK */

   ifNumber = ifaces_found;   /* set global interface counter */
 8243a88:	e0bfff17 	ldw	r2,-4(fp)
 8243a8c:	d0a08415 	stw	r2,-32240(gp)

   initmsg("prepped %u interface%s, initializing...\n", 
 8243a90:	e0bfff17 	ldw	r2,-4(fp)
 8243a94:	10800058 	cmpnei	r2,r2,1
 8243a98:	1000031e 	bne	r2,zero,8243aa8 <prep_ifaces+0x4c>
 8243a9c:	00820974 	movhi	r2,2085
 8243aa0:	10857b04 	addi	r2,r2,5612
 8243aa4:	00000206 	br	8243ab0 <prep_ifaces+0x54>
 8243aa8:	00820974 	movhi	r2,2085
 8243aac:	10857c04 	addi	r2,r2,5616
 8243ab0:	100d883a 	mov	r6,r2
 8243ab4:	e17fff17 	ldw	r5,-4(fp)
 8243ab8:	01020974 	movhi	r4,2085
 8243abc:	21057d04 	addi	r4,r4,5620
 8243ac0:	820331c0 	call	820331c <printf>
      ifaces_found, ifaces_found==1?"":"s");

   return ifaces_found;
 8243ac4:	e0bfff17 	ldw	r2,-4(fp)
}
 8243ac8:	e037883a 	mov	sp,fp
 8243acc:	dfc00117 	ldw	ra,4(sp)
 8243ad0:	df000017 	ldw	fp,0(sp)
 8243ad4:	dec00204 	addi	sp,sp,8
 8243ad8:	f800283a 	ret

08243adc <netexit>:
 * RETURNS: SHould not return
 */

void
netexit(int err)      /* exit error level */
{
 8243adc:	defffd04 	addi	sp,sp,-12
 8243ae0:	dfc00215 	stw	ra,8(sp)
 8243ae4:	df000115 	stw	fp,4(sp)
 8243ae8:	df000104 	addi	fp,sp,4
 8243aec:	e13fff15 	stw	r4,-4(fp)
   net_system_exit = TRUE; /* set flag for shutting down */
 8243af0:	00800044 	movi	r2,1
 8243af4:	d0a0cb15 	stw	r2,-31956(gp)
   ip_exit();  /* do the exit_hook()ed stuff */
 8243af8:	8226ad40 	call	8226ad4 <ip_exit>

   PORT_EXIT_FUNC(err);    /* should not return! */
 8243afc:	e13fff17 	ldw	r4,-4(fp)
 8243b00:	824b4a80 	call	824b4a8 <exit>

08243b04 <evtmap_setup>:
 * INPUT: None.
 * OUTPUT: None
 */
 
void evtmap_setup (void)
{
 8243b04:	deffff04 	addi	sp,sp,-4
 8243b08:	df000015 	stw	fp,0(sp)
 8243b0c:	d839883a 	mov	fp,sp
#ifdef SOCK_MAP_EVENTS
   so_evtmap = TRUE;
   so_evtmap_create = evtmap_create;
   so_evtmap_delete = evtmap_delete;
#else
   so_evtmap = FALSE;
 8243b10:	d020ce05 	stb	zero,-31944(gp)
   so_evtmap_create = 0;
 8243b14:	d020cc15 	stw	zero,-31952(gp)
   so_evtmap_delete = 0;
 8243b18:	d020cd15 	stw	zero,-31948(gp)
#endif   /* SOCK_MAP_EVENTS */ 

}
 8243b1c:	0001883a 	nop
 8243b20:	e037883a 	mov	sp,fp
 8243b24:	df000017 	ldw	fp,0(sp)
 8243b28:	dec00104 	addi	sp,sp,4
 8243b2c:	f800283a 	ret

08243b30 <ip_raw_open>:
ip_raw_open(u_char prot,
            ip_addr laddr,
            ip_addr faddr,
            int (*handler)(PACKET, void *),
            void * data)
{
 8243b30:	defff904 	addi	sp,sp,-28
 8243b34:	dfc00615 	stw	ra,24(sp)
 8243b38:	df000515 	stw	fp,20(sp)
 8243b3c:	df000504 	addi	fp,sp,20
 8243b40:	2005883a 	mov	r2,r4
 8243b44:	e17ffd15 	stw	r5,-12(fp)
 8243b48:	e1bffe15 	stw	r6,-8(fp)
 8243b4c:	e1ffff15 	stw	r7,-4(fp)
 8243b50:	e0bffc05 	stb	r2,-16(fp)
   struct ipraw_ep * ep;

   LOCK_NET_RESOURCE(NET_RESID);
 8243b54:	0009883a 	mov	r4,zero
 8243b58:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>

   /* allocate a structure for the endpoint */
   ep = (struct ipraw_ep *)IEP_ALLOC(sizeof(struct ipraw_ep));
 8243b5c:	01000604 	movi	r4,24
 8243b60:	822dfec0 	call	822dfec <npalloc>
 8243b64:	e0bffb15 	stw	r2,-20(fp)
   if (ep == NULL)
 8243b68:	e0bffb17 	ldw	r2,-20(fp)
 8243b6c:	10000a1e 	bne	r2,zero,8243b98 <ip_raw_open+0x68>
   {
#ifdef NPDEBUG
      if (NDEBUG & INFOMSG)
 8243b70:	d0a08317 	ldw	r2,-32244(gp)
 8243b74:	1080010c 	andi	r2,r2,4
 8243b78:	10000326 	beq	r2,zero,8243b88 <ip_raw_open+0x58>
         dprintf("IP: Couldn't allocate ep storage.\n");
 8243b7c:	01020974 	movhi	r4,2085
 8243b80:	21058804 	addi	r4,r4,5664
 8243b84:	82035a00 	call	82035a0 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 8243b88:	0009883a 	mov	r4,zero
 8243b8c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return ep;
 8243b90:	e0bffb17 	ldw	r2,-20(fp)
 8243b94:	00001706 	br	8243bf4 <ip_raw_open+0xc4>
   }

   /* fill it in with the caller's requested binding */
   ep->ipr_laddr = laddr;
 8243b98:	e0bffb17 	ldw	r2,-20(fp)
 8243b9c:	e0fffd17 	ldw	r3,-12(fp)
 8243ba0:	10c00115 	stw	r3,4(r2)
   ep->ipr_faddr = faddr;
 8243ba4:	e0bffb17 	ldw	r2,-20(fp)
 8243ba8:	e0fffe17 	ldw	r3,-8(fp)
 8243bac:	10c00215 	stw	r3,8(r2)
   ep->ipr_prot = prot;
 8243bb0:	e0bffb17 	ldw	r2,-20(fp)
 8243bb4:	e0fffc03 	ldbu	r3,-16(fp)
 8243bb8:	10c00505 	stb	r3,20(r2)
   ep->ipr_rcv = handler;
 8243bbc:	e0bffb17 	ldw	r2,-20(fp)
 8243bc0:	e0ffff17 	ldw	r3,-4(fp)
 8243bc4:	10c00315 	stw	r3,12(r2)
   ep->ipr_data = data;
 8243bc8:	e0bffb17 	ldw	r2,-20(fp)
 8243bcc:	e0c00217 	ldw	r3,8(fp)
 8243bd0:	10c00415 	stw	r3,16(r2)

   /* link it into the list 
    * (at the head, because that's simple and fast) 
    */
   ep->ipr_next = ipraw_eps;
 8243bd4:	d0e0cf17 	ldw	r3,-31940(gp)
 8243bd8:	e0bffb17 	ldw	r2,-20(fp)
 8243bdc:	10c00015 	stw	r3,0(r2)
   ipraw_eps = ep;
 8243be0:	e0bffb17 	ldw	r2,-20(fp)
 8243be4:	d0a0cf15 	stw	r2,-31940(gp)

   /* and return the pointer to the endpoint */
   UNLOCK_NET_RESOURCE(NET_RESID);
 8243be8:	0009883a 	mov	r4,zero
 8243bec:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   return ep;
 8243bf0:	e0bffb17 	ldw	r2,-20(fp)
}
 8243bf4:	e037883a 	mov	sp,fp
 8243bf8:	dfc00117 	ldw	ra,4(sp)
 8243bfc:	df000017 	ldw	fp,0(sp)
 8243c00:	dec00204 	addi	sp,sp,8
 8243c04:	f800283a 	ret

08243c08 <ip_raw_close>:
 *                               that is to be closed
 * RETURNS: void
 */
void
ip_raw_close(struct ipraw_ep * ep)
{
 8243c08:	defffb04 	addi	sp,sp,-20
 8243c0c:	dfc00415 	stw	ra,16(sp)
 8243c10:	df000315 	stw	fp,12(sp)
 8243c14:	df000304 	addi	fp,sp,12
 8243c18:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * prev_ep;
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);
 8243c1c:	0009883a 	mov	r4,zero
 8243c20:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 8243c24:	e03ffd15 	stw	zero,-12(fp)
 8243c28:	d0a0cf17 	ldw	r2,-31940(gp)
 8243c2c:	e0bffe15 	stw	r2,-8(fp)
 8243c30:	00000806 	br	8243c54 <ip_raw_close+0x4c>
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
 8243c34:	e0fffe17 	ldw	r3,-8(fp)
 8243c38:	e0bfff17 	ldw	r2,-4(fp)
 8243c3c:	18800826 	beq	r3,r2,8243c60 <ip_raw_close+0x58>
         break;
      prev_ep = curr_ep;
 8243c40:	e0bffe17 	ldw	r2,-8(fp)
 8243c44:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
 8243c48:	e0bffe17 	ldw	r2,-8(fp)
 8243c4c:	10800017 	ldw	r2,0(r2)
 8243c50:	e0bffe15 	stw	r2,-8(fp)
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 8243c54:	e0bffe17 	ldw	r2,-8(fp)
 8243c58:	103ff61e 	bne	r2,zero,8243c34 <ip_raw_close+0x2c>
 8243c5c:	00000106 	br	8243c64 <ip_raw_close+0x5c>
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
         break;
 8243c60:	0001883a 	nop
      prev_ep = curr_ep;
   }

   /* if we didn't find it, we can't close it, so just return */
   if (curr_ep == NULL)
 8243c64:	e0bffe17 	ldw	r2,-8(fp)
 8243c68:	1000041e 	bne	r2,zero,8243c7c <ip_raw_close+0x74>
   {
#ifdef NPDEBUG
      /* caller passed pointer to endpoint not in list 
       * -- not fatal, but may be programming error
       */
      dtrap();
 8243c6c:	822d4140 	call	822d414 <dtrap>
#endif /* NPDEBUG */
      UNLOCK_NET_RESOURCE(NET_RESID);
 8243c70:	0009883a 	mov	r4,zero
 8243c74:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return;
 8243c78:	00000d06 	br	8243cb0 <ip_raw_close+0xa8>
   }

   /* unlink it from the list */
   if (prev_ep)
 8243c7c:	e0bffd17 	ldw	r2,-12(fp)
 8243c80:	10000426 	beq	r2,zero,8243c94 <ip_raw_close+0x8c>
      prev_ep = curr_ep->ipr_next;
 8243c84:	e0bffe17 	ldw	r2,-8(fp)
 8243c88:	10800017 	ldw	r2,0(r2)
 8243c8c:	e0bffd15 	stw	r2,-12(fp)
 8243c90:	00000306 	br	8243ca0 <ip_raw_close+0x98>
   else
      ipraw_eps = curr_ep->ipr_next;
 8243c94:	e0bffe17 	ldw	r2,-8(fp)
 8243c98:	10800017 	ldw	r2,0(r2)
 8243c9c:	d0a0cf15 	stw	r2,-31940(gp)

   /* free its storage */
   IEP_FREE(curr_ep);
 8243ca0:	e13ffe17 	ldw	r4,-8(fp)
 8243ca4:	822e0200 	call	822e020 <npfree>

   /* and return */
   UNLOCK_NET_RESOURCE(NET_RESID);
 8243ca8:	0009883a 	mov	r4,zero
 8243cac:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
}
 8243cb0:	e037883a 	mov	sp,fp
 8243cb4:	dfc00117 	ldw	ra,4(sp)
 8243cb8:	df000017 	ldw	fp,0(sp)
 8243cbc:	dec00204 	addi	sp,sp,8
 8243cc0:	f800283a 	ret

08243cc4 <ip_raw_input>:
 *          freed); else an error code indicating that the
 *          received packet was not accepted/processed
 */
int
ip_raw_input(PACKET p)
{
 8243cc4:	defff604 	addi	sp,sp,-40
 8243cc8:	dfc00915 	stw	ra,36(sp)
 8243ccc:	df000815 	stw	fp,32(sp)
 8243cd0:	df000804 	addi	fp,sp,32
 8243cd4:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;              /* the internet header */
   struct ipraw_ep * ep;
   struct ipraw_ep * next_ep;
   struct ipraw_ep * matched_ep = NULL;
 8243cd8:	e03ff915 	stw	zero,-28(fp)
   int err;
   int delivered;

   /* start out expecting to not deliver the packet */
   delivered = 0;
 8243cdc:	e03ffb15 	stw	zero,-20(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);
 8243ce0:	e0bfff17 	ldw	r2,-4(fp)
 8243ce4:	10800317 	ldw	r2,12(r2)
 8243ce8:	e0bffc15 	stw	r2,-16(fp)

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 8243cec:	d0a0cf17 	ldw	r2,-31940(gp)
 8243cf0:	e0bff815 	stw	r2,-32(fp)
 8243cf4:	00004c06 	br	8243e28 <ip_raw_input+0x164>
   {
      /* keep track of next endpoint -- defense against upcall
       * function closing its own endpoint
       */
      next_ep = ep->ipr_next;
 8243cf8:	e0bff817 	ldw	r2,-32(fp)
 8243cfc:	10800017 	ldw	r2,0(r2)
 8243d00:	e0bffd15 	stw	r2,-12(fp)

      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
 8243d04:	e0bff817 	ldw	r2,-32(fp)
 8243d08:	10800503 	ldbu	r2,20(r2)
 8243d0c:	10803fcc 	andi	r2,r2,255
 8243d10:	10000726 	beq	r2,zero,8243d30 <ip_raw_input+0x6c>
 8243d14:	e0bff817 	ldw	r2,-32(fp)
 8243d18:	10c00503 	ldbu	r3,20(r2)
 8243d1c:	e0bffc17 	ldw	r2,-16(fp)
 8243d20:	10800243 	ldbu	r2,9(r2)
 8243d24:	18c03fcc 	andi	r3,r3,255
 8243d28:	10803fcc 	andi	r2,r2,255
 8243d2c:	1880371e 	bne	r3,r2,8243e0c <ip_raw_input+0x148>
         continue;
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
 8243d30:	e0bff817 	ldw	r2,-32(fp)
 8243d34:	10800117 	ldw	r2,4(r2)
 8243d38:	10000526 	beq	r2,zero,8243d50 <ip_raw_input+0x8c>
 8243d3c:	e0bff817 	ldw	r2,-32(fp)
 8243d40:	10c00117 	ldw	r3,4(r2)
 8243d44:	e0bffc17 	ldw	r2,-16(fp)
 8243d48:	10800417 	ldw	r2,16(r2)
 8243d4c:	1880311e 	bne	r3,r2,8243e14 <ip_raw_input+0x150>
         continue;
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
 8243d50:	e0bff817 	ldw	r2,-32(fp)
 8243d54:	10800217 	ldw	r2,8(r2)
 8243d58:	10000526 	beq	r2,zero,8243d70 <ip_raw_input+0xac>
 8243d5c:	e0bff817 	ldw	r2,-32(fp)
 8243d60:	10c00217 	ldw	r3,8(r2)
 8243d64:	e0bffc17 	ldw	r2,-16(fp)
 8243d68:	10800317 	ldw	r2,12(r2)
 8243d6c:	18802b1e 	bne	r3,r2,8243e1c <ip_raw_input+0x158>
         continue;

      /* if the endpoint has a receive upcall function, 
       * keep track of the endpoint
       */
      if (ep->ipr_rcv != NULL)
 8243d70:	e0bff817 	ldw	r2,-32(fp)
 8243d74:	10800317 	ldw	r2,12(r2)
 8243d78:	10002926 	beq	r2,zero,8243e20 <ip_raw_input+0x15c>
          * copy the packet into a new buffer,
          * and pass the new copy to the previously matched 
          * endpoint's upcall function 
          * before we forget the previous endpoint
          */
         if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 8243d7c:	e0bff917 	ldw	r2,-28(fp)
 8243d80:	10001f26 	beq	r2,zero,8243e00 <ip_raw_input+0x13c>
 8243d84:	e0bff917 	ldw	r2,-28(fp)
 8243d88:	10800317 	ldw	r2,12(r2)
 8243d8c:	10001c26 	beq	r2,zero,8243e00 <ip_raw_input+0x13c>
         {
            PACKET p2;

            p2 = ip_copypkt(p);
 8243d90:	e13fff17 	ldw	r4,-4(fp)
 8243d94:	8240d240 	call	8240d24 <ip_copypkt>
 8243d98:	e0bffe15 	stw	r2,-8(fp)
            if (p2)
 8243d9c:	e0bffe17 	ldw	r2,-8(fp)
 8243da0:	10001726 	beq	r2,zero,8243e00 <ip_raw_input+0x13c>
            {
               UNLOCK_NET_RESOURCE(NET_RESID);
 8243da4:	0009883a 	mov	r4,zero
 8243da8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
               err = ((*matched_ep->ipr_rcv)(p2, matched_ep->ipr_data));
 8243dac:	e0bff917 	ldw	r2,-28(fp)
 8243db0:	10800317 	ldw	r2,12(r2)
 8243db4:	e0fff917 	ldw	r3,-28(fp)
 8243db8:	18c00417 	ldw	r3,16(r3)
 8243dbc:	180b883a 	mov	r5,r3
 8243dc0:	e13ffe17 	ldw	r4,-8(fp)
 8243dc4:	103ee83a 	callr	r2
 8243dc8:	e0bffa15 	stw	r2,-24(fp)
               LOCK_NET_RESOURCE(NET_RESID);
 8243dcc:	0009883a 	mov	r4,zero
 8243dd0:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
               if (err)
 8243dd4:	e0bffa17 	ldw	r2,-24(fp)
 8243dd8:	10000726 	beq	r2,zero,8243df8 <ip_raw_input+0x134>
               {
                  LOCK_NET_RESOURCE(FREEQ_RESID);
 8243ddc:	01000084 	movi	r4,2
 8243de0:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
                  pk_free(p2);
 8243de4:	e13ffe17 	ldw	r4,-8(fp)
 8243de8:	822cbbc0 	call	822cbbc <pk_free>
                  UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243dec:	01000084 	movi	r4,2
 8243df0:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
 8243df4:	00000206 	br	8243e00 <ip_raw_input+0x13c>
               }
               else
                  delivered = 1;
 8243df8:	00800044 	movi	r2,1
 8243dfc:	e0bffb15 	stw	r2,-20(fp)
            }
         }
         matched_ep = ep;
 8243e00:	e0bff817 	ldw	r2,-32(fp)
 8243e04:	e0bff915 	stw	r2,-28(fp)
 8243e08:	00000506 	br	8243e20 <ip_raw_input+0x15c>
      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
         continue;
 8243e0c:	0001883a 	nop
 8243e10:	00000306 	br	8243e20 <ip_raw_input+0x15c>
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
         continue;
 8243e14:	0001883a 	nop
 8243e18:	00000106 	br	8243e20 <ip_raw_input+0x15c>
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
         continue;
 8243e1c:	0001883a 	nop

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 8243e20:	e0bffd17 	ldw	r2,-12(fp)
 8243e24:	e0bff815 	stw	r2,-32(fp)
 8243e28:	e0bff817 	ldw	r2,-32(fp)
 8243e2c:	103fb21e 	bne	r2,zero,8243cf8 <ip_raw_input+0x34>
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 8243e30:	e0bff917 	ldw	r2,-28(fp)
 8243e34:	10001426 	beq	r2,zero,8243e88 <ip_raw_input+0x1c4>
 8243e38:	e0bff917 	ldw	r2,-28(fp)
 8243e3c:	10800317 	ldw	r2,12(r2)
 8243e40:	10001126 	beq	r2,zero,8243e88 <ip_raw_input+0x1c4>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 8243e44:	0009883a 	mov	r4,zero
 8243e48:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
 8243e4c:	e0bff917 	ldw	r2,-28(fp)
 8243e50:	10800317 	ldw	r2,12(r2)
 8243e54:	e0fff917 	ldw	r3,-28(fp)
 8243e58:	18c00417 	ldw	r3,16(r3)
 8243e5c:	180b883a 	mov	r5,r3
 8243e60:	e13fff17 	ldw	r4,-4(fp)
 8243e64:	103ee83a 	callr	r2
 8243e68:	e0bffa15 	stw	r2,-24(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 8243e6c:	0009883a 	mov	r4,zero
 8243e70:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      if (err == 0)
 8243e74:	e0bffa17 	ldw	r2,-24(fp)
 8243e78:	10000c1e 	bne	r2,zero,8243eac <ip_raw_input+0x1e8>
         delivered = 1;
 8243e7c:	00800044 	movi	r2,1
 8243e80:	e0bffb15 	stw	r2,-20(fp)
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
      LOCK_NET_RESOURCE(NET_RESID);
      if (err == 0)
 8243e84:	00000906 	br	8243eac <ip_raw_input+0x1e8>
         delivered = 1;
   }
   else
   {
      err = ENP_PARAM;
 8243e88:	00bffd84 	movi	r2,-10
 8243e8c:	e0bffa15 	stw	r2,-24(fp)
      ip_mib.ipUnknownProtos++;
 8243e90:	008209b4 	movhi	r2,2086
 8243e94:	10ba6a04 	addi	r2,r2,-5720
 8243e98:	10800617 	ldw	r2,24(r2)
 8243e9c:	10c00044 	addi	r3,r2,1
 8243ea0:	008209b4 	movhi	r2,2086
 8243ea4:	10ba6a04 	addi	r2,r2,-5720
 8243ea8:	10c00615 	stw	r3,24(r2)
   }

   if (!delivered)
 8243eac:	e0bffb17 	ldw	r2,-20(fp)
 8243eb0:	1000071e 	bne	r2,zero,8243ed0 <ip_raw_input+0x20c>
      ip_mib.ipInDelivers--;
 8243eb4:	008209b4 	movhi	r2,2086
 8243eb8:	10ba6a04 	addi	r2,r2,-5720
 8243ebc:	10800817 	ldw	r2,32(r2)
 8243ec0:	10ffffc4 	addi	r3,r2,-1
 8243ec4:	008209b4 	movhi	r2,2086
 8243ec8:	10ba6a04 	addi	r2,r2,-5720
 8243ecc:	10c00815 	stw	r3,32(r2)

   return err;
 8243ed0:	e0bffa17 	ldw	r2,-24(fp)
}
 8243ed4:	e037883a 	mov	sp,fp
 8243ed8:	dfc00117 	ldw	ra,4(sp)
 8243edc:	df000017 	ldw	fp,0(sp)
 8243ee0:	dec00204 	addi	sp,sp,8
 8243ee4:	f800283a 	ret

08243ee8 <ip_raw_alloc>:
 *          inclhdr is zero.
 */

PACKET
ip_raw_alloc(int reqlen, int hdrincl)
{
 8243ee8:	defffa04 	addi	sp,sp,-24
 8243eec:	dfc00515 	stw	ra,20(sp)
 8243ef0:	df000415 	stw	fp,16(sp)
 8243ef4:	df000404 	addi	fp,sp,16
 8243ef8:	e13ffe15 	stw	r4,-8(fp)
 8243efc:	e17fff15 	stw	r5,-4(fp)
   int len;
   PACKET p;

   len = (reqlen + 1) & ~1;
 8243f00:	e0bffe17 	ldw	r2,-8(fp)
 8243f04:	10c00044 	addi	r3,r2,1
 8243f08:	00bfff84 	movi	r2,-2
 8243f0c:	1884703a 	and	r2,r3,r2
 8243f10:	e0bffc15 	stw	r2,-16(fp)
   if (!hdrincl)
 8243f14:	e0bfff17 	ldw	r2,-4(fp)
 8243f18:	1000031e 	bne	r2,zero,8243f28 <ip_raw_alloc+0x40>
      len += IPHSIZ;
 8243f1c:	e0bffc17 	ldw	r2,-16(fp)
 8243f20:	10800504 	addi	r2,r2,20
 8243f24:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8243f28:	01000084 	movi	r4,2
 8243f2c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + MaxLnh);
 8243f30:	d0e08117 	ldw	r3,-32252(gp)
 8243f34:	e0bffc17 	ldw	r2,-16(fp)
 8243f38:	1885883a 	add	r2,r3,r2
 8243f3c:	1009883a 	mov	r4,r2
 8243f40:	822c86c0 	call	822c86c <pk_alloc>
 8243f44:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243f48:	01000084 	movi	r4,2
 8243f4c:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   if (p)
 8243f50:	e0bffd17 	ldw	r2,-12(fp)
 8243f54:	10000c26 	beq	r2,zero,8243f88 <ip_raw_alloc+0xa0>
   {
      if (!hdrincl)
 8243f58:	e0bfff17 	ldw	r2,-4(fp)
 8243f5c:	10000a1e 	bne	r2,zero,8243f88 <ip_raw_alloc+0xa0>
      {
         p->nb_prot += IPHSIZ;
 8243f60:	e0bffd17 	ldw	r2,-12(fp)
 8243f64:	10800317 	ldw	r2,12(r2)
 8243f68:	10c00504 	addi	r3,r2,20
 8243f6c:	e0bffd17 	ldw	r2,-12(fp)
 8243f70:	10c00315 	stw	r3,12(r2)
         p->nb_plen -= IPHSIZ;
 8243f74:	e0bffd17 	ldw	r2,-12(fp)
 8243f78:	10800417 	ldw	r2,16(r2)
 8243f7c:	10fffb04 	addi	r3,r2,-20
 8243f80:	e0bffd17 	ldw	r2,-12(fp)
 8243f84:	10c00415 	stw	r3,16(r2)
      }
   }
   return p;
 8243f88:	e0bffd17 	ldw	r2,-12(fp)
}
 8243f8c:	e037883a 	mov	sp,fp
 8243f90:	dfc00117 	ldw	ra,4(sp)
 8243f94:	df000017 	ldw	fp,0(sp)
 8243f98:	dec00204 	addi	sp,sp,8
 8243f9c:	f800283a 	ret

08243fa0 <ip_raw_free>:
 * RETURNS: void
 */

void
ip_raw_free(PACKET p)
{
 8243fa0:	defffd04 	addi	sp,sp,-12
 8243fa4:	dfc00215 	stw	ra,8(sp)
 8243fa8:	df000115 	stw	fp,4(sp)
 8243fac:	df000104 	addi	fp,sp,4
 8243fb0:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8243fb4:	01000084 	movi	r4,2
 8243fb8:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   pk_free(p);
 8243fbc:	e13fff17 	ldw	r4,-4(fp)
 8243fc0:	822cbbc0 	call	822cbbc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8243fc4:	01000084 	movi	r4,2
 8243fc8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
}
 8243fcc:	0001883a 	nop
 8243fd0:	e037883a 	mov	sp,fp
 8243fd4:	dfc00117 	ldw	ra,4(sp)
 8243fd8:	df000017 	ldw	fp,0(sp)
 8243fdc:	dec00204 	addi	sp,sp,8
 8243fe0:	f800283a 	ret

08243fe4 <ip_raw_maxalloc>:
 *          for 
 */

int
ip_raw_maxalloc(int hdrincl)
{
 8243fe4:	defffd04 	addi	sp,sp,-12
 8243fe8:	df000215 	stw	fp,8(sp)
 8243fec:	df000204 	addi	fp,sp,8
 8243ff0:	e13fff15 	stw	r4,-4(fp)
   int len;

   len = bigbufsiz - MaxLnh;
 8243ff4:	d0a03917 	ldw	r2,-32540(gp)
 8243ff8:	d0e08117 	ldw	r3,-32252(gp)
 8243ffc:	10c5c83a 	sub	r2,r2,r3
 8244000:	e0bffe15 	stw	r2,-8(fp)
   if (!hdrincl)
 8244004:	e0bfff17 	ldw	r2,-4(fp)
 8244008:	1000031e 	bne	r2,zero,8244018 <ip_raw_maxalloc+0x34>
      len -= IPHSIZ;
 824400c:	e0bffe17 	ldw	r2,-8(fp)
 8244010:	10bffb04 	addi	r2,r2,-20
 8244014:	e0bffe15 	stw	r2,-8(fp)
   return len;
 8244018:	e0bffe17 	ldw	r2,-8(fp)
}
 824401c:	e037883a 	mov	sp,fp
 8244020:	df000017 	ldw	fp,0(sp)
 8244024:	dec00104 	addi	sp,sp,4
 8244028:	f800283a 	ret

0824402c <rt_lookup>:
 * entry was found.
 */

RTMIB
rt_lookup(ip_addr host)
{
 824402c:	defff804 	addi	sp,sp,-32
 8244030:	df000715 	stw	fp,28(sp)
 8244034:	df000704 	addi	fp,sp,28
 8244038:	e13fff15 	stw	r4,-4(fp)
   RTMIB    rtp;
   RTMIB    netmatch;
   unsigned char max_bits_matched = 0;
 824403c:	e03ffb05 	stb	zero,-20(fp)
   unsigned char curr_bits_matched;
   ip_addr  entry_mask;
   unsigned long int bitcount_mask;
   unsigned long int extracted_bit;

   netmatch = NULL;
 8244040:	e03ffa15 	stw	zero,-24(fp)

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244044:	d0a0c617 	ldw	r2,-31976(gp)
 8244048:	e0bff915 	stw	r2,-28(fp)
 824404c:	00003a06 	br	8244138 <rt_lookup+0x10c>
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
 8244050:	e0bff917 	ldw	r2,-28(fp)
 8244054:	10800617 	ldw	r2,24(r2)
 8244058:	10003326 	beq	r2,zero,8244128 <rt_lookup+0xfc>
#ifdef RIP_SUPPORT
      /* skip RIP private entries */
      if (rtp->ipRouteFlags & RIP_PRIVATE)
         continue;
#endif
      entry_mask = rtp->ipRouteMask;
 824405c:	e0bff917 	ldw	r2,-28(fp)
 8244060:	10800a17 	ldw	r2,40(r2)
 8244064:	e0bffd15 	stw	r2,-12(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
 8244068:	e0bff917 	ldw	r2,-28(fp)
 824406c:	10c00017 	ldw	r3,0(r2)
 8244070:	e0bfff17 	ldw	r2,-4(fp)
 8244074:	1886f03a 	xor	r3,r3,r2
 8244078:	e0bffd17 	ldw	r2,-12(fp)
 824407c:	1884703a 	and	r2,r3,r2
 8244080:	10002a1e 	bne	r2,zero,824412c <rt_lookup+0x100>
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 8244084:	e03ffb45 	stb	zero,-19(fp)
 8244088:	00a00034 	movhi	r2,32768
 824408c:	e0bffc15 	stw	r2,-16(fp)
 8244090:	00001806 	br	82440f4 <rt_lookup+0xc8>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
 8244094:	e0bffd17 	ldw	r2,-12(fp)
 8244098:	1006d63a 	srli	r3,r2,24
 824409c:	e0bffd17 	ldw	r2,-12(fp)
 82440a0:	1004d23a 	srli	r2,r2,8
 82440a4:	10bfc00c 	andi	r2,r2,65280
 82440a8:	1886b03a 	or	r3,r3,r2
 82440ac:	e0bffd17 	ldw	r2,-12(fp)
 82440b0:	10bfc00c 	andi	r2,r2,65280
 82440b4:	1004923a 	slli	r2,r2,8
 82440b8:	1886b03a 	or	r3,r3,r2
 82440bc:	e0bffd17 	ldw	r2,-12(fp)
 82440c0:	1004963a 	slli	r2,r2,24
 82440c4:	1886b03a 	or	r3,r3,r2
 82440c8:	e0bffc17 	ldw	r2,-16(fp)
 82440cc:	1884703a 	and	r2,r3,r2
 82440d0:	e0bffe15 	stw	r2,-8(fp)
            if (extracted_bit) ++curr_bits_matched;
 82440d4:	e0bffe17 	ldw	r2,-8(fp)
 82440d8:	10000326 	beq	r2,zero,82440e8 <rt_lookup+0xbc>
 82440dc:	e0bffb43 	ldbu	r2,-19(fp)
 82440e0:	10800044 	addi	r2,r2,1
 82440e4:	e0bffb45 	stb	r2,-19(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 82440e8:	e0bffc17 	ldw	r2,-16(fp)
 82440ec:	1004d07a 	srli	r2,r2,1
 82440f0:	e0bffc15 	stw	r2,-16(fp)
 82440f4:	e0bffc17 	ldw	r2,-16(fp)
 82440f8:	103fe61e 	bne	r2,zero,8244094 <rt_lookup+0x68>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
            if (extracted_bit) ++curr_bits_matched;
         }
         if (curr_bits_matched > max_bits_matched)
 82440fc:	e0bffb43 	ldbu	r2,-19(fp)
 8244100:	e0fffb03 	ldbu	r3,-20(fp)
 8244104:	1880092e 	bgeu	r3,r2,824412c <rt_lookup+0x100>
         {
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
 8244108:	e0bffb43 	ldbu	r2,-19(fp)
 824410c:	e0bffb05 	stb	r2,-20(fp)
            netmatch = rtp;
 8244110:	e0bff917 	ldw	r2,-28(fp)
 8244114:	e0bffa15 	stw	r2,-24(fp)
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
 8244118:	e0bffb03 	ldbu	r2,-20(fp)
 824411c:	10800818 	cmpnei	r2,r2,32
 8244120:	10000c26 	beq	r2,zero,8244154 <rt_lookup+0x128>
 8244124:	00000106 	br	824412c <rt_lookup+0x100>

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
         continue;
 8244128:	0001883a 	nop
   unsigned long int extracted_bit;

   netmatch = NULL;

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 824412c:	e0bff917 	ldw	r2,-28(fp)
 8244130:	10800f04 	addi	r2,r2,60
 8244134:	e0bff915 	stw	r2,-28(fp)
 8244138:	d0e0c617 	ldw	r3,-31976(gp)
 824413c:	d0a05117 	ldw	r2,-32444(gp)
 8244140:	10800f24 	muli	r2,r2,60
 8244144:	1885883a 	add	r2,r3,r2
 8244148:	e0fff917 	ldw	r3,-28(fp)
 824414c:	18bfc036 	bltu	r3,r2,8244050 <rt_lookup+0x24>
 8244150:	00000106 	br	8244158 <rt_lookup+0x12c>
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
            netmatch = rtp;
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
               break;
 8244154:	0001883a 	nop
         }
      }
   }

   if (netmatch)
 8244158:	e0bffa17 	ldw	r2,-24(fp)
 824415c:	10000326 	beq	r2,zero,824416c <rt_lookup+0x140>
      netmatch->ipRouteAge = cticks;   /* timestamp entry we used */
 8244160:	d0e0a817 	ldw	r3,-32096(gp)
 8244164:	e0bffa17 	ldw	r2,-24(fp)
 8244168:	10c00915 	stw	r3,36(r2)

   return netmatch;
 824416c:	e0bffa17 	ldw	r2,-24(fp)
}
 8244170:	e037883a 	mov	sp,fp
 8244174:	df000017 	ldw	fp,0(sp)
 8244178:	dec00104 	addi	sp,sp,4
 824417c:	f800283a 	ret

08244180 <add_route>:
   ip_addr  dest,       /* ultimate destination */
   ip_addr  mask,       /* net mask, 0xFFFFFFFF if dest is host address */
   ip_addr  nexthop,    /* where to forward to */
   int      iface,      /* interface (net) for nexthop */
   int      prot)       /* how we know it: icmp, table, etc */
{
 8244180:	defff704 	addi	sp,sp,-36
 8244184:	dfc00815 	stw	ra,32(sp)
 8244188:	df000715 	stw	fp,28(sp)
 824418c:	df000704 	addi	fp,sp,28
 8244190:	e13ffc15 	stw	r4,-16(fp)
 8244194:	e17ffd15 	stw	r5,-12(fp)
 8244198:	e1bffe15 	stw	r6,-8(fp)
 824419c:	e1ffff15 	stw	r7,-4(fp)
   RTMIB rtp;           /* scratch route table entrry pointer */
   RTMIB newrt;         /* best entry for new route */
   struct net * ifp;    /* interface (net) for nexthop */

   newrt = NULL;     /* may be replaced with empty or more expendable entry */
 82441a0:	e03ffa15 	stw	zero,-24(fp)
					 
   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   ifp = if_getbynum(iface);
 82441a4:	e13fff17 	ldw	r4,-4(fp)
 82441a8:	823ebac0 	call	823ebac <if_getbynum>
 82441ac:	e0bffb15 	stw	r2,-20(fp)
   if(!ifp)
 82441b0:	e0bffb17 	ldw	r2,-20(fp)
 82441b4:	1000021e 	bne	r2,zero,82441c0 <add_route+0x40>
      return NULL;
 82441b8:	0005883a 	mov	r2,zero
 82441bc:	0000db06 	br	824452c <add_route+0x3ac>

   if (rt_mib == NULL)
 82441c0:	d0a0c617 	ldw	r2,-31976(gp)
 82441c4:	1000021e 	bne	r2,zero,82441d0 <add_route+0x50>
      return NULL;
 82441c8:	0005883a 	mov	r2,zero
 82441cc:	0000d706 	br	824452c <add_route+0x3ac>

   /* Don't add null masks or IP addresses - they give false positives on
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
 82441d0:	e0bffc17 	ldw	r2,-16(fp)
 82441d4:	10000226 	beq	r2,zero,82441e0 <add_route+0x60>
 82441d8:	e0bffd17 	ldw	r2,-12(fp)
 82441dc:	1000221e 	bne	r2,zero,8244268 <add_route+0xe8>
   {
      dtrap();    /* bad configuration? */
 82441e0:	822d4140 	call	822d414 <dtrap>
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
	      htonl(dest), htonl(mask) );
 82441e4:	e0bffc17 	ldw	r2,-16(fp)
 82441e8:	1006d63a 	srli	r3,r2,24
 82441ec:	e0bffc17 	ldw	r2,-16(fp)
 82441f0:	1004d23a 	srli	r2,r2,8
 82441f4:	10bfc00c 	andi	r2,r2,65280
 82441f8:	1886b03a 	or	r3,r3,r2
 82441fc:	e0bffc17 	ldw	r2,-16(fp)
 8244200:	10bfc00c 	andi	r2,r2,65280
 8244204:	1004923a 	slli	r2,r2,8
 8244208:	1886b03a 	or	r3,r3,r2
 824420c:	e0bffc17 	ldw	r2,-16(fp)
 8244210:	1004963a 	slli	r2,r2,24
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
   {
      dtrap();    /* bad configuration? */
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 8244214:	1888b03a 	or	r4,r3,r2
	      htonl(dest), htonl(mask) );
 8244218:	e0bffd17 	ldw	r2,-12(fp)
 824421c:	1006d63a 	srli	r3,r2,24
 8244220:	e0bffd17 	ldw	r2,-12(fp)
 8244224:	1004d23a 	srli	r2,r2,8
 8244228:	10bfc00c 	andi	r2,r2,65280
 824422c:	1886b03a 	or	r3,r3,r2
 8244230:	e0bffd17 	ldw	r2,-12(fp)
 8244234:	10bfc00c 	andi	r2,r2,65280
 8244238:	1004923a 	slli	r2,r2,8
 824423c:	1886b03a 	or	r3,r3,r2
 8244240:	e0bffd17 	ldw	r2,-12(fp)
 8244244:	1004963a 	slli	r2,r2,24
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
   {
      dtrap();    /* bad configuration? */
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 8244248:	1884b03a 	or	r2,r3,r2
 824424c:	100d883a 	mov	r6,r2
 8244250:	200b883a 	mov	r5,r4
 8244254:	01020974 	movhi	r4,2085
 8244258:	21059104 	addi	r4,r4,5700
 824425c:	820331c0 	call	820331c <printf>
	      htonl(dest), htonl(mask) );
      return NULL;
 8244260:	0005883a 	mov	r2,zero
 8244264:	0000b106 	br	824452c <add_route+0x3ac>
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244268:	d0a0c617 	ldw	r2,-31976(gp)
 824426c:	e0bff915 	stw	r2,-28(fp)
 8244270:	00006a06 	br	824441c <add_route+0x29c>
   {
      if (rtp->ipRouteDest == dest) /* found existing entry for target */
 8244274:	e0bff917 	ldw	r2,-28(fp)
 8244278:	10c00017 	ldw	r3,0(r2)
 824427c:	e0bffc17 	ldw	r2,-16(fp)
 8244280:	1880151e 	bne	r3,r2,82442d8 <add_route+0x158>
      {
         rtp->ipRouteNextHop = nexthop;      /* fix entry */
 8244284:	e0bff917 	ldw	r2,-28(fp)
 8244288:	e0fffe17 	ldw	r3,-8(fp)
 824428c:	10c00615 	stw	r3,24(r2)
         rtp->ipRouteAge = cticks;           /* timestamp it */
 8244290:	d0e0a817 	ldw	r3,-32096(gp)
 8244294:	e0bff917 	ldw	r2,-28(fp)
 8244298:	10c00915 	stw	r3,36(r2)
         /* set the rfc1213 1-based SNMP-ish interface index */
         rtp->ipRouteIfIndex = (long)(iface) + 1;
 824429c:	e0bfff17 	ldw	r2,-4(fp)
 82442a0:	10c00044 	addi	r3,r2,1
 82442a4:	e0bff917 	ldw	r2,-28(fp)
 82442a8:	10c00115 	stw	r3,4(r2)
         rtp->ipRouteProto = prot;           /* icmp, or whatever */
 82442ac:	e0bff917 	ldw	r2,-28(fp)
 82442b0:	e0c00217 	ldw	r3,8(fp)
 82442b4:	10c00815 	stw	r3,32(r2)
         rtp->ipRouteMask = mask;
 82442b8:	e0bff917 	ldw	r2,-28(fp)
 82442bc:	e0fffd17 	ldw	r3,-12(fp)
 82442c0:	10c00a15 	stw	r3,40(r2)
         rtp->ifp = ifp;
 82442c4:	e0bff917 	ldw	r2,-28(fp)
 82442c8:	e0fffb17 	ldw	r3,-20(fp)
 82442cc:	10c00e15 	stw	r3,56(r2)
         return(rtp);   /* just update and exit */
 82442d0:	e0bff917 	ldw	r2,-28(fp)
 82442d4:	00009506 	br	824452c <add_route+0x3ac>
      }
      /* if we didn't find empty slot yet, look for good slot to recycle */
      if (!newrt || (newrt->ipRouteProto != 0))
 82442d8:	e0bffa17 	ldw	r2,-24(fp)
 82442dc:	10000326 	beq	r2,zero,82442ec <add_route+0x16c>
 82442e0:	e0bffa17 	ldw	r2,-24(fp)
 82442e4:	10800817 	ldw	r2,32(r2)
 82442e8:	10004926 	beq	r2,zero,8244410 <add_route+0x290>
      {
         if (!rtp->ipRouteNextHop)  /* found empty slot for use */
 82442ec:	e0bff917 	ldw	r2,-28(fp)
 82442f0:	10800617 	ldw	r2,24(r2)
 82442f4:	1000051e 	bne	r2,zero,824430c <add_route+0x18c>
         {
            newrt = rtp;   /* record empty route for use */
 82442f8:	e0bff917 	ldw	r2,-28(fp)
 82442fc:	e0bffa15 	stw	r2,-24(fp)
            newrt->ipRouteProto = 0;
 8244300:	e0bffa17 	ldw	r2,-24(fp)
 8244304:	10000815 	stw	zero,32(r2)
            continue;
 8244308:	00004106 	br	8244410 <add_route+0x290>
         }
         /* else see if the new route has higher priority than this slot: */
         if (rtp_priority[prot] >= rtp_priority[rtp->ipRouteProto])
 824430c:	00820974 	movhi	r2,2085
 8244310:	108f4204 	addi	r2,r2,15624
 8244314:	e0c00217 	ldw	r3,8(fp)
 8244318:	10c5883a 	add	r2,r2,r3
 824431c:	11000003 	ldbu	r4,0(r2)
 8244320:	e0bff917 	ldw	r2,-28(fp)
 8244324:	10c00817 	ldw	r3,32(r2)
 8244328:	00820974 	movhi	r2,2085
 824432c:	108f4204 	addi	r2,r2,15624
 8244330:	10c5883a 	add	r2,r2,r3
 8244334:	10800003 	ldbu	r2,0(r2)
 8244338:	20c03fcc 	andi	r3,r4,255
 824433c:	10803fcc 	andi	r2,r2,255
 8244340:	18803336 	bltu	r3,r2,8244410 <add_route+0x290>
         {
            if (!newrt)
 8244344:	e0bffa17 	ldw	r2,-24(fp)
 8244348:	1000031e 	bne	r2,zero,8244358 <add_route+0x1d8>
            {
               newrt = rtp;
 824434c:	e0bff917 	ldw	r2,-28(fp)
 8244350:	e0bffa15 	stw	r2,-24(fp)
               continue;
 8244354:	00002e06 	br	8244410 <add_route+0x290>
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 8244358:	e0bff917 	ldw	r2,-28(fp)
 824435c:	10c00817 	ldw	r3,32(r2)
 8244360:	00820974 	movhi	r2,2085
 8244364:	108f4204 	addi	r2,r2,15624
 8244368:	10c5883a 	add	r2,r2,r3
 824436c:	11000003 	ldbu	r4,0(r2)
                rtp_priority[newrt->ipRouteProto])
 8244370:	e0bffa17 	ldw	r2,-24(fp)
 8244374:	10c00817 	ldw	r3,32(r2)
 8244378:	00820974 	movhi	r2,2085
 824437c:	108f4204 	addi	r2,r2,15624
 8244380:	10c5883a 	add	r2,r2,r3
 8244384:	10800003 	ldbu	r2,0(r2)
               newrt = rtp;
               continue;
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 8244388:	20c03fcc 	andi	r3,r4,255
 824438c:	10803fcc 	andi	r2,r2,255
 8244390:	1880032e 	bgeu	r3,r2,82443a0 <add_route+0x220>
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
 8244394:	e0bff917 	ldw	r2,-28(fp)
 8244398:	e0bffa15 	stw	r2,-24(fp)
 824439c:	00001c06 	br	8244410 <add_route+0x290>
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 82443a0:	e0bff917 	ldw	r2,-28(fp)
 82443a4:	10c00817 	ldw	r3,32(r2)
 82443a8:	00820974 	movhi	r2,2085
 82443ac:	108f4204 	addi	r2,r2,15624
 82443b0:	10c5883a 	add	r2,r2,r3
 82443b4:	11000003 	ldbu	r4,0(r2)
                rtp_priority[newrt->ipRouteProto])
 82443b8:	e0bffa17 	ldw	r2,-24(fp)
 82443bc:	10c00817 	ldw	r3,32(r2)
 82443c0:	00820974 	movhi	r2,2085
 82443c4:	108f4204 	addi	r2,r2,15624
 82443c8:	10c5883a 	add	r2,r2,r3
 82443cc:	10800003 	ldbu	r2,0(r2)
            if (rtp_priority[rtp->ipRouteProto] < 
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 82443d0:	20c03fcc 	andi	r3,r4,255
 82443d4:	10803fcc 	andi	r2,r2,255
 82443d8:	18800d1e 	bne	r3,r2,8244410 <add_route+0x290>
                rtp_priority[newrt->ipRouteProto])
            {
               /* if equal priority, keep the older entry for deletion */
               if (c_older(rtp->ipRouteAge, newrt->ipRouteAge) == rtp->ipRouteAge)
 82443dc:	e0bff917 	ldw	r2,-28(fp)
 82443e0:	10c00917 	ldw	r3,36(r2)
 82443e4:	e0bffa17 	ldw	r2,-24(fp)
 82443e8:	10800917 	ldw	r2,36(r2)
 82443ec:	100b883a 	mov	r5,r2
 82443f0:	1809883a 	mov	r4,r3
 82443f4:	82265a40 	call	82265a4 <c_older>
 82443f8:	1007883a 	mov	r3,r2
 82443fc:	e0bff917 	ldw	r2,-28(fp)
 8244400:	10800917 	ldw	r2,36(r2)
 8244404:	1880021e 	bne	r3,r2,8244410 <add_route+0x290>
                  newrt = rtp;   /* got an older one */
 8244408:	e0bff917 	ldw	r2,-28(fp)
 824440c:	e0bffa15 	stw	r2,-24(fp)
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244410:	e0bff917 	ldw	r2,-28(fp)
 8244414:	10800f04 	addi	r2,r2,60
 8244418:	e0bff915 	stw	r2,-28(fp)
 824441c:	d0e0c617 	ldw	r3,-31976(gp)
 8244420:	d0a05117 	ldw	r2,-32444(gp)
 8244424:	10800f24 	muli	r2,r2,60
 8244428:	1885883a 	add	r2,r3,r2
 824442c:	e0fff917 	ldw	r3,-28(fp)
 8244430:	18bf9036 	bltu	r3,r2,8244274 <add_route+0xf4>
         }
      }
   }

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
 8244434:	e0bffa17 	ldw	r2,-24(fp)
 8244438:	10002926 	beq	r2,zero,82444e0 <add_route+0x360>
      rtp = newrt;   /* create new entry in lowest priority slot */
 824443c:	e0bffa17 	ldw	r2,-24(fp)
 8244440:	e0bff915 	stw	r2,-28(fp)
   else  /* all slots have higher priority, new entry looses */
      return NULL;

   /* set default value in new route entry, caller can modiy further. */
   rtp->ifp = ifp;
 8244444:	e0bff917 	ldw	r2,-28(fp)
 8244448:	e0fffb17 	ldw	r3,-20(fp)
 824444c:	10c00e15 	stw	r3,56(r2)
   rtp->ipRouteDest = dest;
 8244450:	e0bff917 	ldw	r2,-28(fp)
 8244454:	e0fffc17 	ldw	r3,-16(fp)
 8244458:	10c00015 	stw	r3,0(r2)
   rtp->ipRouteIfIndex = (long)(if_netnumber(ifp)) + 1; /* set interface number */
 824445c:	e13ffb17 	ldw	r4,-20(fp)
 8244460:	8226ba40 	call	8226ba4 <if_netnumber>
 8244464:	10c00044 	addi	r3,r2,1
 8244468:	e0bff917 	ldw	r2,-28(fp)
 824446c:	10c00115 	stw	r3,4(r2)
   rtp->ipRouteMetric1 = ip_mib.ipDefaultTTL;
 8244470:	008209b4 	movhi	r2,2086
 8244474:	10ba6a04 	addi	r2,r2,-5720
 8244478:	10800117 	ldw	r2,4(r2)
 824447c:	1007883a 	mov	r3,r2
 8244480:	e0bff917 	ldw	r2,-28(fp)
 8244484:	10c00215 	stw	r3,8(r2)
   rtp->ipRouteMetric2 = -1;
 8244488:	e0bff917 	ldw	r2,-28(fp)
 824448c:	00ffffc4 	movi	r3,-1
 8244490:	10c00315 	stw	r3,12(r2)
   rtp->ipRouteMetric3 = -1;
 8244494:	e0bff917 	ldw	r2,-28(fp)
 8244498:	00ffffc4 	movi	r3,-1
 824449c:	10c00415 	stw	r3,16(r2)
   rtp->ipRouteMetric4 = -1;
 82444a0:	e0bff917 	ldw	r2,-28(fp)
 82444a4:	00ffffc4 	movi	r3,-1
 82444a8:	10c00515 	stw	r3,20(r2)
   rtp->ipRouteNextHop = nexthop;
 82444ac:	e0bff917 	ldw	r2,-28(fp)
 82444b0:	e0fffe17 	ldw	r3,-8(fp)
 82444b4:	10c00615 	stw	r3,24(r2)
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */
 82444b8:	e0bff917 	ldw	r2,-28(fp)
 82444bc:	e0c00217 	ldw	r3,8(fp)
 82444c0:	10c00815 	stw	r3,32(r2)

   if ((dest & mask) == (nexthop & mask))
 82444c4:	e0fffc17 	ldw	r3,-16(fp)
 82444c8:	e0bffe17 	ldw	r2,-8(fp)
 82444cc:	1886f03a 	xor	r3,r3,r2
 82444d0:	e0bffd17 	ldw	r2,-12(fp)
 82444d4:	1884703a 	and	r2,r3,r2
 82444d8:	1000071e 	bne	r2,zero,82444f8 <add_route+0x378>
 82444dc:	00000206 	br	82444e8 <add_route+0x368>

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
      rtp = newrt;   /* create new entry in lowest priority slot */
   else  /* all slots have higher priority, new entry looses */
      return NULL;
 82444e0:	0005883a 	mov	r2,zero
 82444e4:	00001106 	br	824452c <add_route+0x3ac>
   rtp->ipRouteMetric4 = -1;
   rtp->ipRouteNextHop = nexthop;
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */

   if ((dest & mask) == (nexthop & mask))
      rtp->ipRouteType = IPRT_DIRECT;
 82444e8:	e0bff917 	ldw	r2,-28(fp)
 82444ec:	00c000c4 	movi	r3,3
 82444f0:	10c00715 	stw	r3,28(r2)
 82444f4:	00000306 	br	8244504 <add_route+0x384>
   else
      rtp->ipRouteType = IPRT_INDIRECT;
 82444f8:	e0bff917 	ldw	r2,-28(fp)
 82444fc:	00c00104 	movi	r3,4
 8244500:	10c00715 	stw	r3,28(r2)

   rtp->ipRouteAge = cticks;        /* timestamp it */
 8244504:	d0e0a817 	ldw	r3,-32096(gp)
 8244508:	e0bff917 	ldw	r2,-28(fp)
 824450c:	10c00915 	stw	r3,36(r2)
   rtp->ipRouteMask = mask;
 8244510:	e0bff917 	ldw	r2,-28(fp)
 8244514:	e0fffd17 	ldw	r3,-12(fp)
 8244518:	10c00a15 	stw	r3,40(r2)
   rtp->ipRouteMetric5 = -1;
 824451c:	e0bff917 	ldw	r2,-28(fp)
 8244520:	00ffffc4 	movi	r3,-1
 8244524:	10c00b15 	stw	r3,44(r2)
   return(rtp);
 8244528:	e0bff917 	ldw	r2,-28(fp)
}
 824452c:	e037883a 	mov	sp,fp
 8244530:	dfc00117 	ldw	ra,4(sp)
 8244534:	df000017 	ldw	fp,0(sp)
 8244538:	dec00204 	addi	sp,sp,8
 824453c:	f800283a 	ret

08244540 <del_route>:
 * RETURNS: Returns number of route table entries deleted. 
 */

int
del_route(ip_addr dest, ip_addr mask, int iface)
{
 8244540:	defff804 	addi	sp,sp,-32
 8244544:	dfc00715 	stw	ra,28(sp)
 8244548:	df000615 	stw	fp,24(sp)
 824454c:	df000604 	addi	fp,sp,24
 8244550:	e13ffd15 	stw	r4,-12(fp)
 8244554:	e17ffe15 	stw	r5,-8(fp)
 8244558:	e1bfff15 	stw	r6,-4(fp)
   RTMIB rtp;
   int   retval   =  0;
 824455c:	e03ffb15 	stw	zero,-20(fp)

   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   if(iface == -1)
 8244560:	e0bfff17 	ldw	r2,-4(fp)
 8244564:	10bfffd8 	cmpnei	r2,r2,-1
 8244568:	1000021e 	bne	r2,zero,8244574 <del_route+0x34>
      ifp = NULL;    /* wildcard */
 824456c:	e03ffc15 	stw	zero,-16(fp)
 8244570:	00000306 	br	8244580 <del_route+0x40>
   else
      ifp = if_getbynum(iface);
 8244574:	e13fff17 	ldw	r4,-4(fp)
 8244578:	823ebac0 	call	823ebac <if_getbynum>
 824457c:	e0bffc15 	stw	r2,-16(fp)

   if (rt_mib == NULL)     /* Make sure we're up */
 8244580:	d0a0c617 	ldw	r2,-31976(gp)
 8244584:	1000021e 	bne	r2,zero,8244590 <del_route+0x50>
      return 0;
 8244588:	0005883a 	mov	r2,zero
 824458c:	00002c06 	br	8244640 <del_route+0x100>

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244590:	d0a0c617 	ldw	r2,-31976(gp)
 8244594:	e0bffa15 	stw	r2,-24(fp)
 8244598:	00002206 	br	8244624 <del_route+0xe4>
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
 824459c:	e0bffa17 	ldw	r2,-24(fp)
 82445a0:	10800617 	ldw	r2,24(r2)
 82445a4:	10001926 	beq	r2,zero,824460c <del_route+0xcc>
         continue;
      if(ifp != NULL && ifp != rtp->ifp)
 82445a8:	e0bffc17 	ldw	r2,-16(fp)
 82445ac:	10000426 	beq	r2,zero,82445c0 <del_route+0x80>
 82445b0:	e0bffa17 	ldw	r2,-24(fp)
 82445b4:	10c00e17 	ldw	r3,56(r2)
 82445b8:	e0bffc17 	ldw	r2,-16(fp)
 82445bc:	1880151e 	bne	r3,r2,8244614 <del_route+0xd4>
         continue;   /* interface didn't match */
      if ((rtp->ipRouteDest & mask) == (dest & mask))
 82445c0:	e0bffa17 	ldw	r2,-24(fp)
 82445c4:	10c00017 	ldw	r3,0(r2)
 82445c8:	e0bffd17 	ldw	r2,-12(fp)
 82445cc:	1886f03a 	xor	r3,r3,r2
 82445d0:	e0bffe17 	ldw	r2,-8(fp)
 82445d4:	1884703a 	and	r2,r3,r2
 82445d8:	1000071e 	bne	r2,zero,82445f8 <del_route+0xb8>
      {
         MEMSET(rtp, 0, sizeof(*rtp)); /* clear entry */
 82445dc:	01800f04 	movi	r6,60
 82445e0:	000b883a 	mov	r5,zero
 82445e4:	e13ffa17 	ldw	r4,-24(fp)
 82445e8:	82031300 	call	8203130 <memset>
         retval++;
 82445ec:	e0bffb17 	ldw	r2,-20(fp)
 82445f0:	10800044 	addi	r2,r2,1
 82445f4:	e0bffb15 	stw	r2,-20(fp)
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
 82445f8:	d0e0d017 	ldw	r3,-31936(gp)
 82445fc:	e0bffa17 	ldw	r2,-24(fp)
 8244600:	1880051e 	bne	r3,r2,8244618 <del_route+0xd8>
         cachedRoute = NULL;
 8244604:	d020d015 	stw	zero,-31936(gp)
 8244608:	00000306 	br	8244618 <del_route+0xd8>
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
         continue;
 824460c:	0001883a 	nop
 8244610:	00000106 	br	8244618 <del_route+0xd8>
      if(ifp != NULL && ifp != rtp->ifp)
         continue;   /* interface didn't match */
 8244614:	0001883a 	nop
      ifp = if_getbynum(iface);

   if (rt_mib == NULL)     /* Make sure we're up */
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 8244618:	e0bffa17 	ldw	r2,-24(fp)
 824461c:	10800f04 	addi	r2,r2,60
 8244620:	e0bffa15 	stw	r2,-24(fp)
 8244624:	d0e0c617 	ldw	r3,-31976(gp)
 8244628:	d0a05117 	ldw	r2,-32444(gp)
 824462c:	10800f24 	muli	r2,r2,60
 8244630:	1885883a 	add	r2,r3,r2
 8244634:	e0fffa17 	ldw	r3,-24(fp)
 8244638:	18bfd836 	bltu	r3,r2,824459c <del_route+0x5c>
         retval++;
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
         cachedRoute = NULL;
   }
   return retval;
 824463c:	e0bffb17 	ldw	r2,-20(fp)
}
 8244640:	e037883a 	mov	sp,fp
 8244644:	dfc00117 	ldw	ra,4(sp)
 8244648:	df000017 	ldw	fp,0(sp)
 824464c:	dec00204 	addi	sp,sp,8
 8244650:	f800283a 	ret

08244654 <udpdemux>:
 * RETURNS: 0 if OK or ENP error code
 */

int
udpdemux(PACKET p)
{
 8244654:	deffec04 	addi	sp,sp,-80
 8244658:	dfc01315 	stw	ra,76(sp)
 824465c:	df001215 	stw	fp,72(sp)
 8244660:	df001204 	addi	fp,sp,72
 8244664:	e13fff15 	stw	r4,-4(fp)
   unsigned short osum, xsum; /* scratch checksum holders */
   unsigned plen; /* packet length */
   int   e;    /* general error holder */

   /* First let's verify that it's a valid UDP packet. */
   pip = ip_head(p);       /* we'll need IP header info */
 8244668:	e0bfff17 	ldw	r2,-4(fp)
 824466c:	10800317 	ldw	r2,12(r2)
 8244670:	e0bff615 	stw	r2,-40(fp)
   pup = (struct udp*)ip_data(pip);   /*  also need UDP header */
 8244674:	e0bff617 	ldw	r2,-40(fp)
 8244678:	10800003 	ldbu	r2,0(r2)
 824467c:	10803fcc 	andi	r2,r2,255
 8244680:	108003cc 	andi	r2,r2,15
 8244684:	1085883a 	add	r2,r2,r2
 8244688:	1085883a 	add	r2,r2,r2
 824468c:	1007883a 	mov	r3,r2
 8244690:	e0bff617 	ldw	r2,-40(fp)
 8244694:	10c5883a 	add	r2,r2,r3
 8244698:	e0bff715 	stw	r2,-36(fp)
   plen = htons(pup->ud_len);
 824469c:	e0bff717 	ldw	r2,-36(fp)
 82446a0:	1080010b 	ldhu	r2,4(r2)
 82446a4:	10bfffcc 	andi	r2,r2,65535
 82446a8:	1004d23a 	srli	r2,r2,8
 82446ac:	10bfffcc 	andi	r2,r2,65535
 82446b0:	10c03fcc 	andi	r3,r2,255
 82446b4:	e0bff717 	ldw	r2,-36(fp)
 82446b8:	1080010b 	ldhu	r2,4(r2)
 82446bc:	10bfffcc 	andi	r2,r2,65535
 82446c0:	1004923a 	slli	r2,r2,8
 82446c4:	10bfffcc 	andi	r2,r2,65535
 82446c8:	1884b03a 	or	r2,r3,r2
 82446cc:	e0bff815 	stw	r2,-32(fp)

   if (plen > p->nb_plen)
 82446d0:	e0bfff17 	ldw	r2,-4(fp)
 82446d4:	10c00417 	ldw	r3,16(r2)
 82446d8:	e0bff817 	ldw	r2,-32(fp)
 82446dc:	1880252e 	bgeu	r3,r2,8244774 <udpdemux+0x120>
#ifdef   NPDEBUG
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 82446e0:	d0a08317 	ldw	r2,-32244(gp)
 82446e4:	1081000c 	andi	r2,r2,1024
 82446e8:	10001726 	beq	r2,zero,8244748 <udpdemux+0xf4>
 82446ec:	d0a08317 	ldw	r2,-32244(gp)
 82446f0:	1080400c 	andi	r2,r2,256
 82446f4:	10001426 	beq	r2,zero,8244748 <udpdemux+0xf4>
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 82446f8:	e0bfff17 	ldw	r2,-4(fp)
 82446fc:	11000417 	ldw	r4,16(r2)
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
 8244700:	e0bff717 	ldw	r2,-36(fp)
 8244704:	1080010b 	ldhu	r2,4(r2)
 8244708:	10bfffcc 	andi	r2,r2,65535
 824470c:	1004d23a 	srli	r2,r2,8
 8244710:	10bfffcc 	andi	r2,r2,65535
 8244714:	10c03fcc 	andi	r3,r2,255
 8244718:	e0bff717 	ldw	r2,-36(fp)
 824471c:	1080010b 	ldhu	r2,4(r2)
 8244720:	10bfffcc 	andi	r2,r2,65535
 8244724:	1004923a 	slli	r2,r2,8
 8244728:	10bfffcc 	andi	r2,r2,65535
 824472c:	1884b03a 	or	r2,r3,r2
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 8244730:	10800204 	addi	r2,r2,8
 8244734:	100d883a 	mov	r6,r2
 8244738:	200b883a 	mov	r5,r4
 824473c:	01020974 	movhi	r4,2085
 8244740:	21059f04 	addi	r4,r4,5756
 8244744:	820331c0 	call	820331c <printf>
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
#endif
      udp_mib.udpInErrors++;
 8244748:	008209b4 	movhi	r2,2086
 824474c:	10ba8404 	addi	r2,r2,-5616
 8244750:	10800217 	ldw	r2,8(r2)
 8244754:	10c00044 	addi	r3,r2,1
 8244758:	008209b4 	movhi	r2,2086
 824475c:	10ba8404 	addi	r2,r2,-5616
 8244760:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 8244764:	e13fff17 	ldw	r4,-4(fp)
 8244768:	82453180 	call	8245318 <udp_free>
      return ENP_BAD_HEADER;
 824476c:	00bff804 	movi	r2,-32
 8244770:	00019d06 	br	8244de8 <udpdemux+0x794>
   }

   osum = pup->ud_cksum;
 8244774:	e0bff717 	ldw	r2,-36(fp)
 8244778:	1080018b 	ldhu	r2,6(r2)
 824477c:	e0bff90d 	sth	r2,-28(fp)
   /* did other guy use checksumming? */
   if (osum)
 8244780:	e0bff90b 	ldhu	r2,-28(fp)
 8244784:	10005826 	beq	r2,zero,82448e8 <udpdemux+0x294>
   {
      if (plen & 1) ((char *)pup)[plen] = 0;
 8244788:	e0bff817 	ldw	r2,-32(fp)
 824478c:	1080004c 	andi	r2,r2,1
 8244790:	10000426 	beq	r2,zero,82447a4 <udpdemux+0x150>
 8244794:	e0fff717 	ldw	r3,-36(fp)
 8244798:	e0bff817 	ldw	r2,-32(fp)
 824479c:	1885883a 	add	r2,r3,r2
 82447a0:	10000005 	stb	zero,0(r2)
         php.ph_src = p->fhost;
 82447a4:	e0bfff17 	ldw	r2,-4(fp)
 82447a8:	10800717 	ldw	r2,28(r2)
 82447ac:	e0bffc15 	stw	r2,-16(fp)
      php.ph_dest = pip->ip_dest;
 82447b0:	e0bff617 	ldw	r2,-40(fp)
 82447b4:	10800417 	ldw	r2,16(r2)
 82447b8:	e0bffd15 	stw	r2,-12(fp)
      php.ph_zero = 0;
 82447bc:	e03ffe05 	stb	zero,-8(fp)
      php.ph_prot = UDP_PROT;
 82447c0:	00800444 	movi	r2,17
 82447c4:	e0bffe45 	stb	r2,-7(fp)
      php.ph_len  = pup->ud_len;
 82447c8:	e0bff717 	ldw	r2,-36(fp)
 82447cc:	1080010b 	ldhu	r2,4(r2)
 82447d0:	e0bffe8d 	sth	r2,-6(fp)

      pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 82447d4:	e0bffc04 	addi	r2,fp,-16
 82447d8:	01400184 	movi	r5,6
 82447dc:	1009883a 	mov	r4,r2
 82447e0:	82286f00 	call	82286f0 <cksum>
 82447e4:	1007883a 	mov	r3,r2
 82447e8:	e0bff717 	ldw	r2,-36(fp)
 82447ec:	10c0018d 	sth	r3,6(r2)
      xsum = ~cksum(pup, (plen+1)>>1);
 82447f0:	e0bff817 	ldw	r2,-32(fp)
 82447f4:	10800044 	addi	r2,r2,1
 82447f8:	1004d07a 	srli	r2,r2,1
 82447fc:	100b883a 	mov	r5,r2
 8244800:	e13ff717 	ldw	r4,-36(fp)
 8244804:	82286f00 	call	82286f0 <cksum>
 8244808:	0084303a 	nor	r2,zero,r2
 824480c:	e0bff30d 	sth	r2,-52(fp)
      if (!xsum)
 8244810:	e0bff30b 	ldhu	r2,-52(fp)
 8244814:	1000021e 	bne	r2,zero,8244820 <udpdemux+0x1cc>
         xsum = 0xffff;
 8244818:	00bfffc4 	movi	r2,-1
 824481c:	e0bff30d 	sth	r2,-52(fp)
      pup->ud_cksum = osum;
 8244820:	e0bff717 	ldw	r2,-36(fp)
 8244824:	e0fff90b 	ldhu	r3,-28(fp)
 8244828:	10c0018d 	sth	r3,6(r2)
      if (xsum != osum)
 824482c:	e0fff30b 	ldhu	r3,-52(fp)
 8244830:	e0bff90b 	ldhu	r2,-28(fp)
 8244834:	18802c26 	beq	r3,r2,82448e8 <udpdemux+0x294>
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244838:	d0a08317 	ldw	r2,-32244(gp)
 824483c:	1081000c 	andi	r2,r2,1024
 8244840:	10001e26 	beq	r2,zero,82448bc <udpdemux+0x268>
 8244844:	d0a08317 	ldw	r2,-32244(gp)
 8244848:	1080400c 	andi	r2,r2,256
 824484c:	10001b26 	beq	r2,zero,82448bc <udpdemux+0x268>
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244850:	e17ff90b 	ldhu	r5,-28(fp)
 8244854:	e1bff30b 	ldhu	r6,-52(fp)
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244858:	e0bfff17 	ldw	r2,-4(fp)
 824485c:	10800717 	ldw	r2,28(r2)
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244860:	11c03fcc 	andi	r7,r2,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244864:	e0bfff17 	ldw	r2,-4(fp)
 8244868:	10800717 	ldw	r2,28(r2)
 824486c:	1004d23a 	srli	r2,r2,8
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244870:	10803fcc 	andi	r2,r2,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244874:	e0ffff17 	ldw	r3,-4(fp)
 8244878:	18c00717 	ldw	r3,28(r3)
 824487c:	1806d43a 	srli	r3,r3,16
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244880:	18c03fcc 	andi	r3,r3,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 8244884:	e13fff17 	ldw	r4,-4(fp)
 8244888:	21000717 	ldw	r4,28(r4)
 824488c:	2008d63a 	srli	r4,r4,24
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 8244890:	d9000215 	stw	r4,8(sp)
 8244894:	d8c00115 	stw	r3,4(sp)
 8244898:	d8800015 	stw	r2,0(sp)
 824489c:	01020974 	movhi	r4,2085
 82448a0:	2105a904 	addi	r4,r4,5796
 82448a4:	820331c0 	call	820331c <printf>
                    osum, xsum, PUSH_IPADDR(p->fhost));
            if (NDEBUG & DUMP)
 82448a8:	d0a08317 	ldw	r2,-32244(gp)
 82448ac:	1080008c 	andi	r2,r2,2
 82448b0:	10000226 	beq	r2,zero,82448bc <udpdemux+0x268>
               ip_dump(p);
 82448b4:	e13fff17 	ldw	r4,-4(fp)
 82448b8:	82408a40 	call	82408a4 <ip_dump>
         }
#endif
         udp_mib.udpInErrors++;
 82448bc:	008209b4 	movhi	r2,2086
 82448c0:	10ba8404 	addi	r2,r2,-5616
 82448c4:	10800217 	ldw	r2,8(r2)
 82448c8:	10c00044 	addi	r3,r2,1
 82448cc:	008209b4 	movhi	r2,2086
 82448d0:	10ba8404 	addi	r2,r2,-5616
 82448d4:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 82448d8:	e13fff17 	ldw	r4,-4(fp)
 82448dc:	82453180 	call	8245318 <udp_free>
         return ENP_BAD_HEADER;
 82448e0:	00bff804 	movi	r2,-32
 82448e4:	00014006 	br	8244de8 <udpdemux+0x794>
      }
   }

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 82448e8:	e13ff717 	ldw	r4,-36(fp)
 82448ec:	82450940 	call	8245094 <udpswap>
#endif

   /* Prior to upcall, adjust nb_prot for size of IP and UDP headers */
   e = (sizeof(struct udp) + ip_hlen(pip));
 82448f0:	e0bff617 	ldw	r2,-40(fp)
 82448f4:	10800003 	ldbu	r2,0(r2)
 82448f8:	10803fcc 	andi	r2,r2,255
 82448fc:	108003cc 	andi	r2,r2,15
 8244900:	1085883a 	add	r2,r2,r2
 8244904:	1085883a 	add	r2,r2,r2
 8244908:	10800204 	addi	r2,r2,8
 824490c:	e0bff415 	stw	r2,-48(fp)
   p->nb_plen -= e;
 8244910:	e0bfff17 	ldw	r2,-4(fp)
 8244914:	10c00417 	ldw	r3,16(r2)
 8244918:	e0bff417 	ldw	r2,-48(fp)
 824491c:	1887c83a 	sub	r3,r3,r2
 8244920:	e0bfff17 	ldw	r2,-4(fp)
 8244924:	10c00415 	stw	r3,16(r2)
   p->nb_prot += e;
 8244928:	e0bfff17 	ldw	r2,-4(fp)
 824492c:	10c00317 	ldw	r3,12(r2)
 8244930:	e0bff417 	ldw	r2,-48(fp)
 8244934:	1887883a 	add	r3,r3,r2
 8244938:	e0bfff17 	ldw	r2,-4(fp)
 824493c:	10c00315 	stw	r3,12(r2)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244940:	d0a08317 	ldw	r2,-32244(gp)
 8244944:	1081000c 	andi	r2,r2,1024
 8244948:	10001f26 	beq	r2,zero,82449c8 <udpdemux+0x374>
 824494c:	d0a08317 	ldw	r2,-32244(gp)
 8244950:	1080400c 	andi	r2,r2,256
 8244954:	10001c26 	beq	r2,zero,82449c8 <udpdemux+0x374>
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244958:	e0bfff17 	ldw	r2,-4(fp)
 824495c:	10800717 	ldw	r2,28(r2)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244960:	11803fcc 	andi	r6,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244964:	e0bfff17 	ldw	r2,-4(fp)
 8244968:	10800717 	ldw	r2,28(r2)
 824496c:	1004d23a 	srli	r2,r2,8
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244970:	11c03fcc 	andi	r7,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244974:	e0bfff17 	ldw	r2,-4(fp)
 8244978:	10800717 	ldw	r2,28(r2)
 824497c:	1004d43a 	srli	r2,r2,16
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244980:	10803fcc 	andi	r2,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 8244984:	e0ffff17 	ldw	r3,-4(fp)
 8244988:	18c00717 	ldw	r3,28(r3)
 824498c:	1806d63a 	srli	r3,r3,24
 8244990:	e13ff717 	ldw	r4,-36(fp)
 8244994:	2100000b 	ldhu	r4,0(r4)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 8244998:	213fffcc 	andi	r4,r4,65535
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 824499c:	e17ff717 	ldw	r5,-36(fp)
 82449a0:	2940008b 	ldhu	r5,2(r5)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 82449a4:	297fffcc 	andi	r5,r5,65535
 82449a8:	d9400315 	stw	r5,12(sp)
 82449ac:	d9000215 	stw	r4,8(sp)
 82449b0:	d8c00115 	stw	r3,4(sp)
 82449b4:	d8800015 	stw	r2,0(sp)
 82449b8:	e17ff817 	ldw	r5,-32(fp)
 82449bc:	01020974 	movhi	r4,2085
 82449c0:	2105b704 	addi	r4,r4,5852
 82449c4:	820331c0 	call	820331c <printf>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 82449c8:	d0a09c17 	ldw	r2,-32144(gp)
 82449cc:	e0bff215 	stw	r2,-56(fp)
 82449d0:	0000ae06 	br	8244c8c <udpdemux+0x638>
         continue;
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
 82449d4:	e0bff217 	ldw	r2,-56(fp)
 82449d8:	1080018b 	ldhu	r2,6(r2)
 82449dc:	10bfffcc 	andi	r2,r2,65535
 82449e0:	10000726 	beq	r2,zero,8244a00 <udpdemux+0x3ac>
 82449e4:	e0bff217 	ldw	r2,-56(fp)
 82449e8:	10c0018b 	ldhu	r3,6(r2)
 82449ec:	e0bff717 	ldw	r2,-36(fp)
 82449f0:	1080008b 	ldhu	r2,2(r2)
 82449f4:	18ffffcc 	andi	r3,r3,65535
 82449f8:	10bfffcc 	andi	r2,r2,65535
 82449fc:	1880991e 	bne	r3,r2,8244c64 <udpdemux+0x610>
         continue;
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
 8244a00:	e0bff217 	ldw	r2,-56(fp)
 8244a04:	1080020b 	ldhu	r2,8(r2)
 8244a08:	10bfffcc 	andi	r2,r2,65535
 8244a0c:	10000726 	beq	r2,zero,8244a2c <udpdemux+0x3d8>
 8244a10:	e0bff217 	ldw	r2,-56(fp)
 8244a14:	10c0020b 	ldhu	r3,8(r2)
 8244a18:	e0bff717 	ldw	r2,-36(fp)
 8244a1c:	1080000b 	ldhu	r2,0(r2)
 8244a20:	18ffffcc 	andi	r3,r3,65535
 8244a24:	10bfffcc 	andi	r2,r2,65535
 8244a28:	1880901e 	bne	r3,r2,8244c6c <udpdemux+0x618>
         continue;
      if (con->u_fhost && (con->u_fhost != p->fhost))
 8244a2c:	e0bff217 	ldw	r2,-56(fp)
 8244a30:	10800417 	ldw	r2,16(r2)
 8244a34:	10000526 	beq	r2,zero,8244a4c <udpdemux+0x3f8>
 8244a38:	e0bff217 	ldw	r2,-56(fp)
 8244a3c:	10c00417 	ldw	r3,16(r2)
 8244a40:	e0bfff17 	ldw	r2,-4(fp)
 8244a44:	10800717 	ldw	r2,28(r2)
 8244a48:	18808a1e 	bne	r3,r2,8244c74 <udpdemux+0x620>
#ifdef IP_MULTICAST
      /* In the case of multicast, check if there is multicast membership
       * attached to this socket and if so, is the incoming packet
       * addressed to the multicast address
       */
      if (IN_MULTICAST(ntohl(pip->ip_dest)))
 8244a4c:	e0bff617 	ldw	r2,-40(fp)
 8244a50:	10800417 	ldw	r2,16(r2)
 8244a54:	1006d63a 	srli	r3,r2,24
 8244a58:	e0bff617 	ldw	r2,-40(fp)
 8244a5c:	10800417 	ldw	r2,16(r2)
 8244a60:	1004d23a 	srli	r2,r2,8
 8244a64:	10bfc00c 	andi	r2,r2,65280
 8244a68:	1886b03a 	or	r3,r3,r2
 8244a6c:	e0bff617 	ldw	r2,-40(fp)
 8244a70:	10800417 	ldw	r2,16(r2)
 8244a74:	10bfc00c 	andi	r2,r2,65280
 8244a78:	1004923a 	slli	r2,r2,8
 8244a7c:	1886b03a 	or	r3,r3,r2
 8244a80:	e0bff617 	ldw	r2,-40(fp)
 8244a84:	10800417 	ldw	r2,16(r2)
 8244a88:	1004963a 	slli	r2,r2,24
 8244a8c:	1884b03a 	or	r2,r3,r2
 8244a90:	10fc002c 	andhi	r3,r2,61440
 8244a94:	00b80034 	movhi	r2,57344
 8244a98:	1880301e 	bne	r3,r2,8244b5c <udpdemux+0x508>
      {
         struct socket *soptr = (struct socket *)con->u_data;
 8244a9c:	e0bff217 	ldw	r2,-56(fp)
 8244aa0:	10800617 	ldw	r2,24(r2)
 8244aa4:	e0bffa15 	stw	r2,-24(fp)

         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
 8244aa8:	e0bff217 	ldw	r2,-56(fp)
 8244aac:	10c00517 	ldw	r3,20(r2)
 8244ab0:	00820934 	movhi	r2,2084
 8244ab4:	10ab7b04 	addi	r2,r2,-21012
 8244ab8:	1880281e 	bne	r3,r2,8244b5c <udpdemux+0x508>
 8244abc:	e0bffa17 	ldw	r2,-24(fp)
 8244ac0:	10800317 	ldw	r2,12(r2)
 8244ac4:	10002526 	beq	r2,zero,8244b5c <udpdemux+0x508>
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;
 8244ac8:	e0bffa17 	ldw	r2,-24(fp)
 8244acc:	10800317 	ldw	r2,12(r2)
 8244ad0:	e0bffb15 	stw	r2,-20(fp)

            for (i = 0; i < imo->imo_num_memberships; ++i)
 8244ad4:	e03ff50d 	sth	zero,-44(fp)
 8244ad8:	00001906 	br	8244b40 <udpdemux+0x4ec>
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 8244adc:	e0bff50b 	ldhu	r2,-44(fp)
 8244ae0:	e0fffb17 	ldw	r3,-20(fp)
 8244ae4:	10800084 	addi	r2,r2,2
 8244ae8:	1085883a 	add	r2,r2,r2
 8244aec:	1085883a 	add	r2,r2,r2
 8244af0:	1885883a 	add	r2,r3,r2
 8244af4:	10800017 	ldw	r2,0(r2)
 8244af8:	10c00117 	ldw	r3,4(r2)
 8244afc:	e0bfff17 	ldw	r2,-4(fp)
 8244b00:	10800617 	ldw	r2,24(r2)
 8244b04:	18800b1e 	bne	r3,r2,8244b34 <udpdemux+0x4e0>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
 8244b08:	e0bff50b 	ldhu	r2,-44(fp)
 8244b0c:	e0fffb17 	ldw	r3,-20(fp)
 8244b10:	10800084 	addi	r2,r2,2
 8244b14:	1085883a 	add	r2,r2,r2
 8244b18:	1085883a 	add	r2,r2,r2
 8244b1c:	1885883a 	add	r2,r3,r2
 8244b20:	10800017 	ldw	r2,0(r2)
 8244b24:	10c00017 	ldw	r3,0(r2)
 8244b28:	e0bff617 	ldw	r2,-40(fp)
 8244b2c:	10800417 	ldw	r2,16(r2)
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 8244b30:	18800926 	beq	r3,r2,8244b58 <udpdemux+0x504>
         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
 8244b34:	e0bff50b 	ldhu	r2,-44(fp)
 8244b38:	10800044 	addi	r2,r2,1
 8244b3c:	e0bff50d 	sth	r2,-44(fp)
 8244b40:	e0bffb17 	ldw	r2,-20(fp)
 8244b44:	1080018b 	ldhu	r2,6(r2)
 8244b48:	10bfffcc 	andi	r2,r2,65535
 8244b4c:	e0fff50b 	ldhu	r3,-44(fp)
 8244b50:	18bfe236 	bltu	r3,r2,8244adc <udpdemux+0x488>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
               }
            }
            continue;
 8244b54:	00004a06 	br	8244c80 <udpdemux+0x62c>
            for (i = 0; i < imo->imo_num_memberships; ++i)
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
 8244b58:	0001883a 	nop
#endif /* INCLUDE_TCP */

      /* if this endpoint has been bound to a local interface address,
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
 8244b5c:	e0bff617 	ldw	r2,-40(fp)
 8244b60:	10800417 	ldw	r2,16(r2)
 8244b64:	1006d63a 	srli	r3,r2,24
 8244b68:	e0bff617 	ldw	r2,-40(fp)
 8244b6c:	10800417 	ldw	r2,16(r2)
 8244b70:	1004d23a 	srli	r2,r2,8
 8244b74:	10bfc00c 	andi	r2,r2,65280
 8244b78:	1886b03a 	or	r3,r3,r2
 8244b7c:	e0bff617 	ldw	r2,-40(fp)
 8244b80:	10800417 	ldw	r2,16(r2)
 8244b84:	10bfc00c 	andi	r2,r2,65280
 8244b88:	1004923a 	slli	r2,r2,8
 8244b8c:	1886b03a 	or	r3,r3,r2
 8244b90:	e0bff617 	ldw	r2,-40(fp)
 8244b94:	10800417 	ldw	r2,16(r2)
 8244b98:	1004963a 	slli	r2,r2,24
 8244b9c:	1884b03a 	or	r2,r3,r2
 8244ba0:	10fc002c 	andhi	r3,r2,61440
 8244ba4:	00b80034 	movhi	r2,57344
 8244ba8:	18800826 	beq	r3,r2,8244bcc <udpdemux+0x578>
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
 8244bac:	e0bff217 	ldw	r2,-56(fp)
 8244bb0:	10800317 	ldw	r2,12(r2)
 8244bb4:	10000526 	beq	r2,zero,8244bcc <udpdemux+0x578>
 8244bb8:	e0bff217 	ldw	r2,-56(fp)
 8244bbc:	10c00317 	ldw	r3,12(r2)
 8244bc0:	e0bff617 	ldw	r2,-40(fp)
 8244bc4:	10800417 	ldw	r2,16(r2)
 8244bc8:	18802c1e 	bne	r3,r2,8244c7c <udpdemux+0x628>
            continue;
      }

      /* fall to here if we found it */
      udp_mib.udpInDatagrams++;
 8244bcc:	008209b4 	movhi	r2,2086
 8244bd0:	10ba8404 	addi	r2,r2,-5616
 8244bd4:	10800017 	ldw	r2,0(r2)
 8244bd8:	10c00044 	addi	r3,r2,1
 8244bdc:	008209b4 	movhi	r2,2086
 8244be0:	10ba8404 	addi	r2,r2,-5616
 8244be4:	10c00015 	stw	r3,0(r2)
      if (con->u_rcv)         /* if upcall address is set... */
 8244be8:	e0bff217 	ldw	r2,-56(fp)
 8244bec:	10800517 	ldw	r2,20(r2)
 8244bf0:	10000d26 	beq	r2,zero,8244c28 <udpdemux+0x5d4>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 8244bf4:	0009883a 	mov	r4,zero
 8244bf8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         e = ((*con->u_rcv)(p, con->u_data));   /* upcall it */
 8244bfc:	e0bff217 	ldw	r2,-56(fp)
 8244c00:	10800517 	ldw	r2,20(r2)
 8244c04:	e0fff217 	ldw	r3,-56(fp)
 8244c08:	18c00617 	ldw	r3,24(r3)
 8244c0c:	180b883a 	mov	r5,r3
 8244c10:	e13fff17 	ldw	r4,-4(fp)
 8244c14:	103ee83a 	callr	r2
 8244c18:	e0bff415 	stw	r2,-48(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 8244c1c:	0009883a 	mov	r4,zero
 8244c20:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
 8244c24:	00000206 	br	8244c30 <udpdemux+0x5dc>
      }
      else
         e = ENP_LOGIC;
 8244c28:	00bffd44 	movi	r2,-11
 8244c2c:	e0bff415 	stw	r2,-48(fp)

      /* if error occurred in upcall or there was no upcall hander
         its up to this routine to free the packet buffer */
      if (e)
 8244c30:	e0bff417 	ldw	r2,-48(fp)
 8244c34:	10000926 	beq	r2,zero,8244c5c <udpdemux+0x608>
      {
         udp_mib.udpInErrors++;
 8244c38:	008209b4 	movhi	r2,2086
 8244c3c:	10ba8404 	addi	r2,r2,-5616
 8244c40:	10800217 	ldw	r2,8(r2)
 8244c44:	10c00044 	addi	r3,r2,1
 8244c48:	008209b4 	movhi	r2,2086
 8244c4c:	10ba8404 	addi	r2,r2,-5616
 8244c50:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 8244c54:	e13fff17 	ldw	r4,-4(fp)
 8244c58:	82453180 	call	8245318 <udp_free>
      }

      return(e);
 8244c5c:	e0bff417 	ldw	r2,-48(fp)
 8244c60:	00006106 	br	8244de8 <udpdemux+0x794>
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
         continue;
 8244c64:	0001883a 	nop
 8244c68:	00000506 	br	8244c80 <udpdemux+0x62c>
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
         continue;
 8244c6c:	0001883a 	nop
 8244c70:	00000306 	br	8244c80 <udpdemux+0x62c>
      if (con->u_fhost && (con->u_fhost != p->fhost))
         continue;
 8244c74:	0001883a 	nop
 8244c78:	00000106 	br	8244c80 <udpdemux+0x62c>
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
            continue;
 8244c7c:	0001883a 	nop
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 8244c80:	e0bff217 	ldw	r2,-56(fp)
 8244c84:	10800017 	ldw	r2,0(r2)
 8244c88:	e0bff215 	stw	r2,-56(fp)
 8244c8c:	e0bff217 	ldw	r2,-56(fp)
 8244c90:	103f501e 	bne	r2,zero,82449d4 <udpdemux+0x380>

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 8244c94:	e0bff617 	ldw	r2,-40(fp)
 8244c98:	10800417 	ldw	r2,16(r2)
 8244c9c:	10bfffe0 	cmpeqi	r2,r2,-1
 8244ca0:	1000121e 	bne	r2,zero,8244cec <udpdemux+0x698>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
 8244ca4:	e0bff617 	ldw	r2,-40(fp)
 8244ca8:	10c00417 	ldw	r3,16(r2)
 8244cac:	e0bfff17 	ldw	r2,-4(fp)
 8244cb0:	10800617 	ldw	r2,24(r2)
 8244cb4:	10800e17 	ldw	r2,56(r2)

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 8244cb8:	18800c26 	beq	r3,r2,8244cec <udpdemux+0x698>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
 8244cbc:	e0bff617 	ldw	r2,-40(fp)
 8244cc0:	10c00417 	ldw	r3,16(r2)
 8244cc4:	e0bfff17 	ldw	r2,-4(fp)
 8244cc8:	10800617 	ldw	r2,24(r2)
 8244ccc:	10800f17 	ldw	r2,60(r2)
   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
 8244cd0:	18800626 	beq	r3,r2,8244cec <udpdemux+0x698>
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
 8244cd4:	e0bff617 	ldw	r2,-40(fp)
 8244cd8:	10c00417 	ldw	r3,16(r2)
 8244cdc:	e0bfff17 	ldw	r2,-4(fp)
 8244ce0:	10800617 	ldw	r2,24(r2)
 8244ce4:	10801017 	ldw	r2,64(r2)
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
 8244ce8:	1880141e 	bne	r3,r2,8244d3c <udpdemux+0x6e8>
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
   {
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244cec:	d0a08317 	ldw	r2,-32244(gp)
 8244cf0:	1081000c 	andi	r2,r2,1024
 8244cf4:	10000626 	beq	r2,zero,8244d10 <udpdemux+0x6bc>
 8244cf8:	d0a08317 	ldw	r2,-32244(gp)
 8244cfc:	1080400c 	andi	r2,r2,256
 8244d00:	10000326 	beq	r2,zero,8244d10 <udpdemux+0x6bc>
         dprintf("UDP: ignoring ip broadcast\n");
 8244d04:	01020974 	movhi	r4,2085
 8244d08:	2105c104 	addi	r4,r4,5892
 8244d0c:	82035a00 	call	82035a0 <puts>
#endif
      udp_mib.udpInErrors++;
 8244d10:	008209b4 	movhi	r2,2086
 8244d14:	10ba8404 	addi	r2,r2,-5616
 8244d18:	10800217 	ldw	r2,8(r2)
 8244d1c:	10c00044 	addi	r3,r2,1
 8244d20:	008209b4 	movhi	r2,2086
 8244d24:	10ba8404 	addi	r2,r2,-5616
 8244d28:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 8244d2c:	e13fff17 	ldw	r4,-4(fp)
 8244d30:	82453180 	call	8245318 <udp_free>
      return ENP_NOT_MINE;
 8244d34:	00800084 	movi	r2,2
 8244d38:	00002b06 	br	8244de8 <udpdemux+0x794>
   }

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 8244d3c:	d0a08317 	ldw	r2,-32244(gp)
 8244d40:	1081000c 	andi	r2,r2,1024
 8244d44:	10000f26 	beq	r2,zero,8244d84 <udpdemux+0x730>
 8244d48:	d0a08317 	ldw	r2,-32244(gp)
 8244d4c:	1080400c 	andi	r2,r2,256
 8244d50:	10000c26 	beq	r2,zero,8244d84 <udpdemux+0x730>
   {
      dprintf("UDP: unexpected port %04x\n", pup->ud_dstp);
 8244d54:	e0bff717 	ldw	r2,-36(fp)
 8244d58:	1080008b 	ldhu	r2,2(r2)
 8244d5c:	10bfffcc 	andi	r2,r2,65535
 8244d60:	100b883a 	mov	r5,r2
 8244d64:	01020974 	movhi	r4,2085
 8244d68:	2105c804 	addi	r4,r4,5920
 8244d6c:	820331c0 	call	820331c <printf>
      if (NDEBUG & DUMP) 
 8244d70:	d0a08317 	ldw	r2,-32244(gp)
 8244d74:	1080008c 	andi	r2,r2,2
 8244d78:	10000226 	beq	r2,zero,8244d84 <udpdemux+0x730>
         ip_dump(p);
 8244d7c:	e13fff17 	ldw	r4,-4(fp)
 8244d80:	82408a40 	call	82408a4 <ip_dump>
#ifdef FULL_ICMP
   /* send destination unreachable.  Swap back all the swapped information */
   /* so that the destun packet format is correct */

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 8244d84:	e13ff717 	ldw	r4,-36(fp)
 8244d88:	82450940 	call	8245094 <udpswap>
#endif   /* BYTE_ORDER */
   
   icmp_destun(p->fhost, p->net->n_ipaddr, pip, DSTPORT, p->net);
 8244d8c:	e0bfff17 	ldw	r2,-4(fp)
 8244d90:	10c00717 	ldw	r3,28(r2)
 8244d94:	e0bfff17 	ldw	r2,-4(fp)
 8244d98:	10800617 	ldw	r2,24(r2)
 8244d9c:	11000a17 	ldw	r4,40(r2)
 8244da0:	e0bfff17 	ldw	r2,-4(fp)
 8244da4:	10800617 	ldw	r2,24(r2)
 8244da8:	d8800015 	stw	r2,0(sp)
 8244dac:	01c000c4 	movi	r7,3
 8244db0:	e1bff617 	ldw	r6,-40(fp)
 8244db4:	200b883a 	mov	r5,r4
 8244db8:	1809883a 	mov	r4,r3
 8244dbc:	824ae140 	call	824ae14 <icmp_destun>
#endif   /* FULL_ICMP */

   udp_mib.udpNoPorts++;
 8244dc0:	008209b4 	movhi	r2,2086
 8244dc4:	10ba8404 	addi	r2,r2,-5616
 8244dc8:	10800117 	ldw	r2,4(r2)
 8244dcc:	10c00044 	addi	r3,r2,1
 8244dd0:	008209b4 	movhi	r2,2086
 8244dd4:	10ba8404 	addi	r2,r2,-5616
 8244dd8:	10c00115 	stw	r3,4(r2)
   udp_free(p);
 8244ddc:	e13fff17 	ldw	r4,-4(fp)
 8244de0:	82453180 	call	8245318 <udp_free>
   return ENP_NOT_MINE;
 8244de4:	00800084 	movi	r2,2
}
 8244de8:	e037883a 	mov	sp,fp
 8244dec:	dfc00117 	ldw	ra,4(sp)
 8244df0:	df000017 	ldw	fp,0(sp)
 8244df4:	dec00204 	addi	sp,sp,8
 8244df8:	f800283a 	ret

08244dfc <udp_send>:
 * detected. 
 */

int
udp_send(unshort fport, unshort lport, PACKET p)
{
 8244dfc:	deffef04 	addi	sp,sp,-68
 8244e00:	dfc01015 	stw	ra,64(sp)
 8244e04:	df000f15 	stw	fp,60(sp)
 8244e08:	df000f04 	addi	fp,sp,60
 8244e0c:	2007883a 	mov	r3,r4
 8244e10:	2805883a 	mov	r2,r5
 8244e14:	e1bfff15 	stw	r6,-4(fp)
 8244e18:	e0fffd0d 	sth	r3,-12(fp)
 8244e1c:	e0bffe0d 	sth	r2,-8(fp)
   int         udplen;
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
 8244e20:	d0a08317 	ldw	r2,-32244(gp)
 8244e24:	1080410c 	andi	r2,r2,260
 8244e28:	10001a26 	beq	r2,zero,8244e94 <udp_send+0x98>
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244e2c:	e0bfff17 	ldw	r2,-4(fp)
 8244e30:	12000417 	ldw	r8,16(r2)
 8244e34:	e1bffe0b 	ldhu	r6,-8(fp)
    PUSH_IPADDR(p->fhost), fport);
 8244e38:	e0bfff17 	ldw	r2,-4(fp)
 8244e3c:	10800717 	ldw	r2,28(r2)
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244e40:	11c03fcc 	andi	r7,r2,255
    PUSH_IPADDR(p->fhost), fport);
 8244e44:	e0bfff17 	ldw	r2,-4(fp)
 8244e48:	10800717 	ldw	r2,28(r2)
 8244e4c:	1004d23a 	srli	r2,r2,8
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244e50:	10803fcc 	andi	r2,r2,255
    PUSH_IPADDR(p->fhost), fport);
 8244e54:	e0ffff17 	ldw	r3,-4(fp)
 8244e58:	18c00717 	ldw	r3,28(r3)
 8244e5c:	1806d43a 	srli	r3,r3,16
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244e60:	18c03fcc 	andi	r3,r3,255
    PUSH_IPADDR(p->fhost), fport);
 8244e64:	e13fff17 	ldw	r4,-4(fp)
 8244e68:	21000717 	ldw	r4,28(r4)
 8244e6c:	2008d63a 	srli	r4,r4,24
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 8244e70:	e17ffd0b 	ldhu	r5,-12(fp)
 8244e74:	d9400315 	stw	r5,12(sp)
 8244e78:	d9000215 	stw	r4,8(sp)
 8244e7c:	d8c00115 	stw	r3,4(sp)
 8244e80:	d8800015 	stw	r2,0(sp)
 8244e84:	400b883a 	mov	r5,r8
 8244e88:	01020974 	movhi	r4,2085
 8244e8c:	2105cf04 	addi	r4,r4,5948
 8244e90:	820331c0 	call	820331c <printf>
    PUSH_IPADDR(p->fhost), fport);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 8244e94:	0009883a 	mov	r4,zero
 8244e98:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   /* prepend UDP header to upper layer's data */
   p->nb_prot -= sizeof(struct udp);
 8244e9c:	e0bfff17 	ldw	r2,-4(fp)
 8244ea0:	10800317 	ldw	r2,12(r2)
 8244ea4:	10fffe04 	addi	r3,r2,-8
 8244ea8:	e0bfff17 	ldw	r2,-4(fp)
 8244eac:	10c00315 	stw	r3,12(r2)
   pup = (struct udp*)p->nb_prot;
 8244eb0:	e0bfff17 	ldw	r2,-4(fp)
 8244eb4:	10800317 	ldw	r2,12(r2)
 8244eb8:	e0bff615 	stw	r2,-40(fp)
   udplen = p->nb_plen + sizeof(struct udp);
 8244ebc:	e0bfff17 	ldw	r2,-4(fp)
 8244ec0:	10800417 	ldw	r2,16(r2)
 8244ec4:	10800204 	addi	r2,r2,8
 8244ec8:	e0bff715 	stw	r2,-36(fp)
   p->nb_plen = udplen;
 8244ecc:	e0fff717 	ldw	r3,-36(fp)
 8244ed0:	e0bfff17 	ldw	r2,-4(fp)
 8244ed4:	10c00415 	stw	r3,16(r2)
   if (udplen & 1) ((char *)pup)[udplen] = 0;
 8244ed8:	e0bff717 	ldw	r2,-36(fp)
 8244edc:	1080004c 	andi	r2,r2,1
 8244ee0:	10000426 	beq	r2,zero,8244ef4 <udp_send+0xf8>
 8244ee4:	e0bff717 	ldw	r2,-36(fp)
 8244ee8:	e0fff617 	ldw	r3,-40(fp)
 8244eec:	1885883a 	add	r2,r3,r2
 8244ef0:	10000005 	stb	zero,0(r2)

      pup->ud_len = (unshort)udplen;   /* fill in the UDP header */
 8244ef4:	e0bff717 	ldw	r2,-36(fp)
 8244ef8:	1007883a 	mov	r3,r2
 8244efc:	e0bff617 	ldw	r2,-40(fp)
 8244f00:	10c0010d 	sth	r3,4(r2)
   pup->ud_srcp = lport;
 8244f04:	e0bff617 	ldw	r2,-40(fp)
 8244f08:	e0fffe0b 	ldhu	r3,-8(fp)
 8244f0c:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = fport;
 8244f10:	e0bff617 	ldw	r2,-40(fp)
 8244f14:	e0fffd0b 	ldhu	r3,-12(fp)
 8244f18:	10c0008d 	sth	r3,2(r2)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 8244f1c:	e13ff617 	ldw	r4,-40(fp)
 8244f20:	82450940 	call	8245094 <udpswap>
#endif   /* BYTE_ORDER */
   
#ifdef MULTI_HOMED
   /* getting the source IP address for a broadcast is a bit tricky: */
   if (p->fhost == 0xffffffff)
 8244f24:	e0bfff17 	ldw	r2,-4(fp)
 8244f28:	10800717 	ldw	r2,28(r2)
 8244f2c:	10bfffd8 	cmpnei	r2,r2,-1
 8244f30:	10000f1e 	bne	r2,zero,8244f70 <udp_send+0x174>
   {
      if (!p->net)
 8244f34:	e0bfff17 	ldw	r2,-4(fp)
 8244f38:	10800617 	ldw	r2,24(r2)
 8244f3c:	1000071e 	bne	r2,zero,8244f5c <udp_send+0x160>
      {
         dtrap();    /* programmer forgot to select iface */
 8244f40:	822d4140 	call	822d414 <dtrap>
         /* it would appear that the callers of udp_send() expect it
            to do cleanup on failure, so free the packet buffer here */
         udp_free(p);
 8244f44:	e13fff17 	ldw	r4,-4(fp)
 8244f48:	82453180 	call	8245318 <udp_free>
         UNLOCK_NET_RESOURCE(NET_RESID);
 8244f4c:	0009883a 	mov	r4,zero
 8244f50:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
         return ENP_NO_IFACE;
 8244f54:	00bff784 	movi	r2,-34
 8244f58:	00004906 	br	8245080 <udp_send+0x284>
      }
      src_ip = p->net->n_ipaddr;
 8244f5c:	e0bfff17 	ldw	r2,-4(fp)
 8244f60:	10800617 	ldw	r2,24(r2)
 8244f64:	10800a17 	ldw	r2,40(r2)
 8244f68:	e0bff515 	stw	r2,-44(fp)
 8244f6c:	00000506 	br	8244f84 <udp_send+0x188>
   /* set the IP addresses in the IP header. The pseudo header used for
    * checksumming overlays the addresses on the IP header area in the
    * buffer, so setting them there (which we need to do for cksum
    * anyway) sets up for IP too.
    */
   src_ip = ip_mymach(p->fhost);
 8244f70:	e0bfff17 	ldw	r2,-4(fp)
 8244f74:	10800717 	ldw	r2,28(r2)
 8244f78:	1009883a 	mov	r4,r2
 8244f7c:	82408000 	call	8240800 <ip_mymach>
 8244f80:	e0bff515 	stw	r2,-44(fp)
   php.ph_src = src_ip;
 8244f84:	e0bff517 	ldw	r2,-44(fp)
 8244f88:	e0bffa15 	stw	r2,-24(fp)
   php.ph_dest = p->fhost;
 8244f8c:	e0bfff17 	ldw	r2,-4(fp)
 8244f90:	10800717 	ldw	r2,28(r2)
 8244f94:	e0bffb15 	stw	r2,-20(fp)
#ifdef NO_UDP_CKSUM
   /* If no UDP checksum support, just zero the checksum field */
   pup->ud_cksum = 0;
#else
   /* finish filling in the pseudo header required for checksumming */
   php.ph_zero = 0;
 8244f98:	e03ffc05 	stb	zero,-16(fp)
   php.ph_prot = UDP_PROT;
 8244f9c:	00800444 	movi	r2,17
 8244fa0:	e0bffc45 	stb	r2,-15(fp)
   php.ph_len = pup->ud_len;
 8244fa4:	e0bff617 	ldw	r2,-40(fp)
 8244fa8:	1080010b 	ldhu	r2,4(r2)
 8244fac:	e0bffc8d 	sth	r2,-14(fp)
   pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 8244fb0:	e0bffa04 	addi	r2,fp,-24
 8244fb4:	01400184 	movi	r5,6
 8244fb8:	1009883a 	mov	r4,r2
 8244fbc:	82286f00 	call	82286f0 <cksum>
 8244fc0:	1007883a 	mov	r3,r2
 8244fc4:	e0bff617 	ldw	r2,-40(fp)
 8244fc8:	10c0018d 	sth	r3,6(r2)
   pup->ud_cksum = ~cksum(pup, (udplen+1)>>1);
 8244fcc:	e0bff717 	ldw	r2,-36(fp)
 8244fd0:	10800044 	addi	r2,r2,1
 8244fd4:	1005d07a 	srai	r2,r2,1
 8244fd8:	100b883a 	mov	r5,r2
 8244fdc:	e13ff617 	ldw	r4,-40(fp)
 8244fe0:	82286f00 	call	82286f0 <cksum>
 8244fe4:	0084303a 	nor	r2,zero,r2
 8244fe8:	1007883a 	mov	r3,r2
 8244fec:	e0bff617 	ldw	r2,-40(fp)
 8244ff0:	10c0018d 	sth	r3,6(r2)
   if (pup->ud_cksum == 0)
 8244ff4:	e0bff617 	ldw	r2,-40(fp)
 8244ff8:	1080018b 	ldhu	r2,6(r2)
 8244ffc:	10bfffcc 	andi	r2,r2,65535
 8245000:	1000031e 	bne	r2,zero,8245010 <udp_send+0x214>
      pup->ud_cksum = 0xffff;
 8245004:	e0bff617 	ldw	r2,-40(fp)
 8245008:	00ffffc4 	movi	r3,-1
 824500c:	10c0018d 	sth	r3,6(r2)
#endif

   /* need to fill in IP addresses at this layer too */
   pip = (struct ip *)(p->nb_prot - sizeof(struct ip));
 8245010:	e0bfff17 	ldw	r2,-4(fp)
 8245014:	10800317 	ldw	r2,12(r2)
 8245018:	10bffb04 	addi	r2,r2,-20
 824501c:	e0bff815 	stw	r2,-32(fp)
   pip->ip_src = src_ip;
 8245020:	e0bff817 	ldw	r2,-32(fp)
 8245024:	e0fff517 	ldw	r3,-44(fp)
 8245028:	10c00315 	stw	r3,12(r2)
   pip->ip_dest = p->fhost;
 824502c:	e0bfff17 	ldw	r2,-4(fp)
 8245030:	10c00717 	ldw	r3,28(r2)
 8245034:	e0bff817 	ldw	r2,-32(fp)
 8245038:	10c00415 	stw	r3,16(r2)

   udp_mib.udpOutDatagrams++;
 824503c:	008209b4 	movhi	r2,2086
 8245040:	10ba8404 	addi	r2,r2,-5616
 8245044:	10800317 	ldw	r2,12(r2)
 8245048:	10c00044 	addi	r3,r2,1
 824504c:	008209b4 	movhi	r2,2086
 8245050:	10ba8404 	addi	r2,r2,-5616
 8245054:	10c00315 	stw	r3,12(r2)

   p->nb_plen = udplen;       /* nb_prot was adjusted above */
 8245058:	e0fff717 	ldw	r3,-36(fp)
 824505c:	e0bfff17 	ldw	r2,-4(fp)
 8245060:	10c00415 	stw	r3,16(r2)
   e = ip_write(UDP_PROT, p);
 8245064:	e17fff17 	ldw	r5,-4(fp)
 8245068:	01000444 	movi	r4,17
 824506c:	823f7b00 	call	823f7b0 <ip_write>
 8245070:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 8245074:	0009883a 	mov	r4,zero
 8245078:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   return e;
 824507c:	e0bff917 	ldw	r2,-28(fp)
}
 8245080:	e037883a 	mov	sp,fp
 8245084:	dfc00117 	ldw	ra,4(sp)
 8245088:	df000017 	ldw	fp,0(sp)
 824508c:	dec00204 	addi	sp,sp,8
 8245090:	f800283a 	ret

08245094 <udpswap>:
 */

#if (BYTE_ORDER == LITTLE_ENDIAN)
void
udpswap(struct udp *pup)
{
 8245094:	defffe04 	addi	sp,sp,-8
 8245098:	df000115 	stw	fp,4(sp)
 824509c:	df000104 	addi	fp,sp,4
 82450a0:	e13fff15 	stw	r4,-4(fp)

   pup->ud_srcp = htons(pup->ud_srcp);
 82450a4:	e0bfff17 	ldw	r2,-4(fp)
 82450a8:	1080000b 	ldhu	r2,0(r2)
 82450ac:	10bfffcc 	andi	r2,r2,65535
 82450b0:	1004d23a 	srli	r2,r2,8
 82450b4:	1007883a 	mov	r3,r2
 82450b8:	e0bfff17 	ldw	r2,-4(fp)
 82450bc:	1080000b 	ldhu	r2,0(r2)
 82450c0:	10bfffcc 	andi	r2,r2,65535
 82450c4:	1004923a 	slli	r2,r2,8
 82450c8:	1884b03a 	or	r2,r3,r2
 82450cc:	1007883a 	mov	r3,r2
 82450d0:	e0bfff17 	ldw	r2,-4(fp)
 82450d4:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = htons(pup->ud_dstp);
 82450d8:	e0bfff17 	ldw	r2,-4(fp)
 82450dc:	1080008b 	ldhu	r2,2(r2)
 82450e0:	10bfffcc 	andi	r2,r2,65535
 82450e4:	1004d23a 	srli	r2,r2,8
 82450e8:	1007883a 	mov	r3,r2
 82450ec:	e0bfff17 	ldw	r2,-4(fp)
 82450f0:	1080008b 	ldhu	r2,2(r2)
 82450f4:	10bfffcc 	andi	r2,r2,65535
 82450f8:	1004923a 	slli	r2,r2,8
 82450fc:	1884b03a 	or	r2,r3,r2
 8245100:	1007883a 	mov	r3,r2
 8245104:	e0bfff17 	ldw	r2,-4(fp)
 8245108:	10c0008d 	sth	r3,2(r2)
   pup->ud_len = htons(pup->ud_len);
 824510c:	e0bfff17 	ldw	r2,-4(fp)
 8245110:	1080010b 	ldhu	r2,4(r2)
 8245114:	10bfffcc 	andi	r2,r2,65535
 8245118:	1004d23a 	srli	r2,r2,8
 824511c:	1007883a 	mov	r3,r2
 8245120:	e0bfff17 	ldw	r2,-4(fp)
 8245124:	1080010b 	ldhu	r2,4(r2)
 8245128:	10bfffcc 	andi	r2,r2,65535
 824512c:	1004923a 	slli	r2,r2,8
 8245130:	1884b03a 	or	r2,r3,r2
 8245134:	1007883a 	mov	r3,r2
 8245138:	e0bfff17 	ldw	r2,-4(fp)
 824513c:	10c0010d 	sth	r3,4(r2)
   pup->ud_cksum = htons(pup->ud_cksum);
 8245140:	e0bfff17 	ldw	r2,-4(fp)
 8245144:	1080018b 	ldhu	r2,6(r2)
 8245148:	10bfffcc 	andi	r2,r2,65535
 824514c:	1004d23a 	srli	r2,r2,8
 8245150:	1007883a 	mov	r3,r2
 8245154:	e0bfff17 	ldw	r2,-4(fp)
 8245158:	1080018b 	ldhu	r2,6(r2)
 824515c:	10bfffcc 	andi	r2,r2,65535
 8245160:	1004923a 	slli	r2,r2,8
 8245164:	1884b03a 	or	r2,r3,r2
 8245168:	1007883a 	mov	r3,r2
 824516c:	e0bfff17 	ldw	r2,-4(fp)
 8245170:	10c0018d 	sth	r3,6(r2)
}
 8245174:	0001883a 	nop
 8245178:	e037883a 	mov	sp,fp
 824517c:	df000017 	ldw	fp,0(sp)
 8245180:	dec00104 	addi	sp,sp,4
 8245184:	f800283a 	ret

08245188 <udp_socket>:
#define  MINSOCKET   1200
static unshort usocket = 0;   /* next socket to grab */

unshort
udp_socket(void)
{
 8245188:	defffe04 	addi	sp,sp,-8
 824518c:	df000115 	stw	fp,4(sp)
 8245190:	df000104 	addi	fp,sp,4
   UDPCONN tmp;

   if (usocket < MINSOCKET)
 8245194:	d0a0d10b 	ldhu	r2,-31932(gp)
 8245198:	10bfffcc 	andi	r2,r2,65535
 824519c:	10812c28 	cmpgeui	r2,r2,1200
 82451a0:	10000a1e 	bne	r2,zero,82451cc <udp_socket+0x44>
   {
      /* logic for for init and after wraps */
      usocket = (unshort)(cticks & 0x7fff);
 82451a4:	d0a0a817 	ldw	r2,-32096(gp)
 82451a8:	109fffcc 	andi	r2,r2,32767
 82451ac:	d0a0d10d 	sth	r2,-31932(gp)
      if (usocket < MINSOCKET)
 82451b0:	d0a0d10b 	ldhu	r2,-31932(gp)
 82451b4:	10bfffcc 	andi	r2,r2,65535
 82451b8:	10812c28 	cmpgeui	r2,r2,1200
 82451bc:	1000031e 	bne	r2,zero,82451cc <udp_socket+0x44>
         usocket += MINSOCKET;
 82451c0:	d0a0d10b 	ldhu	r2,-31932(gp)
 82451c4:	10812c04 	addi	r2,r2,1200
 82451c8:	d0a0d10d 	sth	r2,-31932(gp)
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 82451cc:	d0a09c17 	ldw	r2,-32144(gp)
 82451d0:	e0bfff15 	stw	r2,-4(fp)
 82451d4:	00000f06 	br	8245214 <udp_socket+0x8c>
   {
      if (tmp->u_lport == usocket)
 82451d8:	e0bfff17 	ldw	r2,-4(fp)
 82451dc:	10c0018b 	ldhu	r3,6(r2)
 82451e0:	d0a0d10b 	ldhu	r2,-31932(gp)
 82451e4:	18ffffcc 	andi	r3,r3,65535
 82451e8:	10bfffcc 	andi	r2,r2,65535
 82451ec:	1880061e 	bne	r3,r2,8245208 <udp_socket+0x80>
      {
         usocket++;     /* bump socket number */
 82451f0:	d0a0d10b 	ldhu	r2,-31932(gp)
 82451f4:	10800044 	addi	r2,r2,1
 82451f8:	d0a0d10d 	sth	r2,-31932(gp)
         tmp = firstudp;   /* restart scan */
 82451fc:	d0a09c17 	ldw	r2,-32144(gp)
 8245200:	e0bfff15 	stw	r2,-4(fp)
         continue;
 8245204:	0001883a 	nop
      usocket = (unshort)(cticks & 0x7fff);
      if (usocket < MINSOCKET)
         usocket += MINSOCKET;
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 8245208:	e0bfff17 	ldw	r2,-4(fp)
 824520c:	10800017 	ldw	r2,0(r2)
 8245210:	e0bfff15 	stw	r2,-4(fp)
 8245214:	e0bfff17 	ldw	r2,-4(fp)
 8245218:	103fef1e 	bne	r2,zero,82451d8 <udp_socket+0x50>
         usocket++;     /* bump socket number */
         tmp = firstudp;   /* restart scan */
         continue;
      }
   }
   return usocket++;
 824521c:	d0a0d10b 	ldhu	r2,-31932(gp)
 8245220:	10c00044 	addi	r3,r2,1
 8245224:	d0e0d10d 	sth	r3,-31932(gp)
}
 8245228:	e037883a 	mov	sp,fp
 824522c:	df000017 	ldw	fp,0(sp)
 8245230:	dec00104 	addi	sp,sp,4
 8245234:	f800283a 	ret

08245238 <udp_alloc>:
 * RETURNS:  Returns buffer, or NULL in no buffer was available. 
 */

PACKET
udp_alloc(int datalen, int optlen)
{
 8245238:	defffa04 	addi	sp,sp,-24
 824523c:	dfc00515 	stw	ra,20(sp)
 8245240:	df000415 	stw	fp,16(sp)
 8245244:	df000404 	addi	fp,sp,16
 8245248:	e13ffe15 	stw	r4,-8(fp)
 824524c:	e17fff15 	stw	r5,-4(fp)
   int   len;
   PACKET p;

   len = (datalen + sizeof(struct udp) + 1) & ~1;
 8245250:	e0bffe17 	ldw	r2,-8(fp)
 8245254:	10800244 	addi	r2,r2,9
 8245258:	1007883a 	mov	r3,r2
 824525c:	00bfff84 	movi	r2,-2
 8245260:	1884703a 	and	r2,r3,r2
 8245264:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 8245268:	01000084 	movi	r4,2
 824526c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + UDPHDRSLEN + optlen);
 8245270:	e0bffc17 	ldw	r2,-16(fp)
 8245274:	10c00904 	addi	r3,r2,36
 8245278:	e0bfff17 	ldw	r2,-4(fp)
 824527c:	1885883a 	add	r2,r3,r2
 8245280:	1009883a 	mov	r4,r2
 8245284:	822c86c0 	call	822c86c <pk_alloc>
 8245288:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824528c:	01000084 	movi	r4,2
 8245290:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   if (p != (PACKET)NULL)
 8245294:	e0bffd17 	ldw	r2,-12(fp)
 8245298:	10001026 	beq	r2,zero,82452dc <udp_alloc+0xa4>
   {
      /* set prot pointers past end of UDP header  */
      len = sizeof(struct ip) + (optlen >> 2) + sizeof(struct udp);
 824529c:	e0bfff17 	ldw	r2,-4(fp)
 82452a0:	1005d0ba 	srai	r2,r2,2
 82452a4:	10800704 	addi	r2,r2,28
 82452a8:	e0bffc15 	stw	r2,-16(fp)
      p->nb_prot += len;
 82452ac:	e0bffd17 	ldw	r2,-12(fp)
 82452b0:	10c00317 	ldw	r3,12(r2)
 82452b4:	e0bffc17 	ldw	r2,-16(fp)
 82452b8:	1887883a 	add	r3,r3,r2
 82452bc:	e0bffd17 	ldw	r2,-12(fp)
 82452c0:	10c00315 	stw	r3,12(r2)
      p->nb_plen -= len;
 82452c4:	e0bffd17 	ldw	r2,-12(fp)
 82452c8:	10c00417 	ldw	r3,16(r2)
 82452cc:	e0bffc17 	ldw	r2,-16(fp)
 82452d0:	1887c83a 	sub	r3,r3,r2
 82452d4:	e0bffd17 	ldw	r2,-12(fp)
 82452d8:	10c00415 	stw	r3,16(r2)
   }

   return (p);
 82452dc:	e0bffd17 	ldw	r2,-12(fp)
}
 82452e0:	e037883a 	mov	sp,fp
 82452e4:	dfc00117 	ldw	ra,4(sp)
 82452e8:	df000017 	ldw	fp,0(sp)
 82452ec:	dec00204 	addi	sp,sp,8
 82452f0:	f800283a 	ret

082452f4 <udp_maxalloc>:
 *          returned value, the allocation will fail
 */

int
udp_maxalloc(void)
{
 82452f4:	deffff04 	addi	sp,sp,-4
 82452f8:	df000015 	stw	fp,0(sp)
 82452fc:	d839883a 	mov	fp,sp
    * created is ((2^16 - 1) - (size of IP and UDP headers)) */
   return (0xFFFF - (sizeof (struct ip) + sizeof (struct udp)));
#else
   /* if heap buffers are not available, the largest size of a UDP datagram
    * is constrained by what will fit inside a big buffer */
   return (bigbufsiz - UDPHDRSLEN);
 8245300:	d0a03917 	ldw	r2,-32540(gp)
 8245304:	10bff704 	addi	r2,r2,-36
#endif
}
 8245308:	e037883a 	mov	sp,fp
 824530c:	df000017 	ldw	fp,0(sp)
 8245310:	dec00104 	addi	sp,sp,4
 8245314:	f800283a 	ret

08245318 <udp_free>:
 * RETURNS: void
 */

void
udp_free(PACKET p)
{
 8245318:	defffd04 	addi	sp,sp,-12
 824531c:	dfc00215 	stw	ra,8(sp)
 8245320:	df000115 	stw	fp,4(sp)
 8245324:	df000104 	addi	fp,sp,4
 8245328:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 824532c:	01000084 	movi	r4,2
 8245330:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   pk_free(p);
 8245334:	e13fff17 	ldw	r4,-4(fp)
 8245338:	822cbbc0 	call	822cbbc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824533c:	01000084 	movi	r4,2
 8245340:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
}
 8245344:	0001883a 	nop
 8245348:	e037883a 	mov	sp,fp
 824534c:	dfc00117 	ldw	ra,4(sp)
 8245350:	df000017 	ldw	fp,0(sp)
 8245354:	dec00204 	addi	sp,sp,8
 8245358:	f800283a 	ret

0824535c <igmpv1_input>:
 * OUTPUT: This function returns IGMP_ERR if it is passed an "unknown"
 * packet type.  Otherwise, it returns IGMP_OK.
 */

int igmpv1_input(PACKET p)
{
 824535c:	defff804 	addi	sp,sp,-32
 8245360:	dfc00715 	stw	ra,28(sp)
 8245364:	df000615 	stw	fp,24(sp)
 8245368:	df000604 	addi	fp,sp,24
 824536c:	e13fff15 	stw	r4,-4(fp)
   struct igmp *  igmp;
   struct ip *    pip;
   struct in_multi * inm;
   NET netp  = p->net;
 8245370:	e0bfff17 	ldw	r2,-4(fp)
 8245374:	10800617 	ldw	r2,24(r2)
 8245378:	e0bffc15 	stw	r2,-16(fp)
   int rc;
         
   pip = ip_head (p);
 824537c:	e0bfff17 	ldw	r2,-4(fp)
 8245380:	10800317 	ldw	r2,12(r2)
 8245384:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 8245388:	e0bffd17 	ldw	r2,-12(fp)
 824538c:	10800003 	ldbu	r2,0(r2)
 8245390:	10803fcc 	andi	r2,r2,255
 8245394:	108003cc 	andi	r2,r2,15
 8245398:	1085883a 	add	r2,r2,r2
 824539c:	1085883a 	add	r2,r2,r2
 82453a0:	1007883a 	mov	r3,r2
 82453a4:	e0bffd17 	ldw	r2,-12(fp)
 82453a8:	10c5883a 	add	r2,r2,r3
 82453ac:	e0bffe15 	stw	r2,-8(fp)

   switch (igmp->igmp_type) 
 82453b0:	e0bffe17 	ldw	r2,-8(fp)
 82453b4:	10800003 	ldbu	r2,0(r2)
 82453b8:	10803fcc 	andi	r2,r2,255
 82453bc:	10c00460 	cmpeqi	r3,r2,17
 82453c0:	1800031e 	bne	r3,zero,82453d0 <igmpv1_input+0x74>
 82453c4:	108004a0 	cmpeqi	r2,r2,18
 82453c8:	1000571e 	bne	r2,zero,8245528 <igmpv1_input+0x1cc>
 82453cc:	00007606 	br	82455a8 <igmpv1_input+0x24c>
   {
   case IGMP_HOST_MEMBERSHIP_QUERY:
      ++igmpstats.igmpv1mode_v1_queries_rcvd;
 82453d0:	008209b4 	movhi	r2,2086
 82453d4:	10b82804 	addi	r2,r2,-8032
 82453d8:	10800117 	ldw	r2,4(r2)
 82453dc:	10c00044 	addi	r3,r2,1
 82453e0:	008209b4 	movhi	r2,2086
 82453e4:	10b82804 	addi	r2,r2,-8032
 82453e8:	10c00115 	stw	r3,4(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 82453ec:	e0bffc17 	ldw	r2,-16(fp)
 82453f0:	10802c17 	ldw	r2,176(r2)
 82453f4:	e0bffa15 	stw	r2,-24(fp)
 82453f8:	00004706 	br	8245518 <igmpv1_input+0x1bc>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
 82453fc:	e0bffa17 	ldw	r2,-24(fp)
 8245400:	10800017 	ldw	r2,0(r2)
 8245404:	10004026 	beq	r2,zero,8245508 <igmpv1_input+0x1ac>
            continue;
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 8245408:	e0bffa17 	ldw	r2,-24(fp)
 824540c:	10c00017 	ldw	r3,0(r2)
 8245410:	d0a08817 	ldw	r2,-32224(gp)
 8245414:	18803d26 	beq	r3,r2,824550c <igmpv1_input+0x1b0>
         {
            if (inm->inm_timer == 0)
 8245418:	e0bffa17 	ldw	r2,-24(fp)
 824541c:	10800317 	ldw	r2,12(r2)
 8245420:	10003a1e 	bne	r2,zero,824550c <igmpv1_input+0x1b0>
            {
               inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 8245424:	008209b4 	movhi	r2,2086
 8245428:	10ba6a04 	addi	r2,r2,-5720
 824542c:	10c00217 	ldw	r3,8(r2)
 8245430:	008209b4 	movhi	r2,2086
 8245434:	10b82404 	addi	r2,r2,-8048
 8245438:	10800017 	ldw	r2,0(r2)
 824543c:	10800a17 	ldw	r2,40(r2)
 8245440:	1008d63a 	srli	r4,r2,24
 8245444:	008209b4 	movhi	r2,2086
 8245448:	10b82404 	addi	r2,r2,-8048
 824544c:	10800017 	ldw	r2,0(r2)
 8245450:	10800a17 	ldw	r2,40(r2)
 8245454:	1004d23a 	srli	r2,r2,8
 8245458:	10bfc00c 	andi	r2,r2,65280
 824545c:	2088b03a 	or	r4,r4,r2
 8245460:	008209b4 	movhi	r2,2086
 8245464:	10b82404 	addi	r2,r2,-8048
 8245468:	10800017 	ldw	r2,0(r2)
 824546c:	10800a17 	ldw	r2,40(r2)
 8245470:	10bfc00c 	andi	r2,r2,65280
 8245474:	1004923a 	slli	r2,r2,8
 8245478:	2088b03a 	or	r4,r4,r2
 824547c:	008209b4 	movhi	r2,2086
 8245480:	10b82404 	addi	r2,r2,-8048
 8245484:	10800017 	ldw	r2,0(r2)
 8245488:	10800a17 	ldw	r2,40(r2)
 824548c:	1004963a 	slli	r2,r2,24
 8245490:	2084b03a 	or	r2,r4,r2
 8245494:	1887883a 	add	r3,r3,r2
 8245498:	e0bffa17 	ldw	r2,-24(fp)
 824549c:	10800017 	ldw	r2,0(r2)
 82454a0:	1008d63a 	srli	r4,r2,24
 82454a4:	e0bffa17 	ldw	r2,-24(fp)
 82454a8:	10800017 	ldw	r2,0(r2)
 82454ac:	1004d23a 	srli	r2,r2,8
 82454b0:	10bfc00c 	andi	r2,r2,65280
 82454b4:	2088b03a 	or	r4,r4,r2
 82454b8:	e0bffa17 	ldw	r2,-24(fp)
 82454bc:	10800017 	ldw	r2,0(r2)
 82454c0:	10bfc00c 	andi	r2,r2,65280
 82454c4:	1004923a 	slli	r2,r2,8
 82454c8:	2088b03a 	or	r4,r4,r2
 82454cc:	e0bffa17 	ldw	r2,-24(fp)
 82454d0:	10800017 	ldw	r2,0(r2)
 82454d4:	1004963a 	slli	r2,r2,24
 82454d8:	2084b03a 	or	r2,r4,r2
 82454dc:	1885883a 	add	r2,r3,r2
 82454e0:	01400c84 	movi	r5,50
 82454e4:	1009883a 	mov	r4,r2
 82454e8:	8202bf00 	call	8202bf0 <__umodsi3>
 82454ec:	10c00044 	addi	r3,r2,1
 82454f0:	e0bffa17 	ldw	r2,-24(fp)
 82454f4:	10c00315 	stw	r3,12(r2)
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
 82454f8:	d0a08617 	ldw	r2,-32232(gp)
 82454fc:	10800044 	addi	r2,r2,1
 8245500:	d0a08615 	stw	r2,-32232(gp)
 8245504:	00000106 	br	824550c <igmpv1_input+0x1b0>
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
            continue;
 8245508:	0001883a 	nop
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 824550c:	e0bffa17 	ldw	r2,-24(fp)
 8245510:	10800517 	ldw	r2,20(r2)
 8245514:	e0bffa15 	stw	r2,-24(fp)
 8245518:	e0bffa17 	ldw	r2,-24(fp)
 824551c:	103fb71e 	bne	r2,zero,82453fc <igmpv1_input+0xa0>
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
            }   
         }
      }
      rc = IGMP_OK;
 8245520:	e03ffb15 	stw	zero,-20(fp)
      break;
 8245524:	00002a06 	br	82455d0 <igmpv1_input+0x274>

   case IGMP_HOST_MEMBERSHIP_REPORT:
      ++igmpstats.igmpv1mode_v1_reports_rcvd;
 8245528:	008209b4 	movhi	r2,2086
 824552c:	10b82804 	addi	r2,r2,-8032
 8245530:	10800217 	ldw	r2,8(r2)
 8245534:	10c00044 	addi	r3,r2,1
 8245538:	008209b4 	movhi	r2,2086
 824553c:	10b82804 	addi	r2,r2,-8032
 8245540:	10c00215 	stw	r3,8(r2)
      /*
       * If we belong to the group being reported and have a 
       * running timer for that group, stop our timer for that 
       * group.
       */
      inm = lookup_mcast(igmp->igmp_group, netp);
 8245544:	e0bffe17 	ldw	r2,-8(fp)
 8245548:	10800117 	ldw	r2,4(r2)
 824554c:	e17ffc17 	ldw	r5,-16(fp)
 8245550:	1009883a 	mov	r4,r2
 8245554:	82439f80 	call	82439f8 <lookup_mcast>
 8245558:	e0bffa15 	stw	r2,-24(fp)
      if (inm != NULL) 
 824555c:	e0bffa17 	ldw	r2,-24(fp)
 8245560:	10000f26 	beq	r2,zero,82455a0 <igmpv1_input+0x244>
      {
         if (inm->inm_timer > 0)
 8245564:	e0bffa17 	ldw	r2,-24(fp)
 8245568:	10800317 	ldw	r2,12(r2)
 824556c:	10000c26 	beq	r2,zero,82455a0 <igmpv1_input+0x244>
         {
            inm->inm_timer = 0;
 8245570:	e0bffa17 	ldw	r2,-24(fp)
 8245574:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 8245578:	d0a08617 	ldw	r2,-32232(gp)
 824557c:	10bfffc4 	addi	r2,r2,-1
 8245580:	d0a08615 	stw	r2,-32232(gp)
            ++igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer;
 8245584:	008209b4 	movhi	r2,2086
 8245588:	10b82804 	addi	r2,r2,-8032
 824558c:	10800317 	ldw	r2,12(r2)
 8245590:	10c00044 	addi	r3,r2,1
 8245594:	008209b4 	movhi	r2,2086
 8245598:	10b82804 	addi	r2,r2,-8032
 824559c:	10c00315 	stw	r3,12(r2)
         }
      }
      rc = IGMP_OK;
 82455a0:	e03ffb15 	stw	zero,-20(fp)
      break;
 82455a4:	00000a06 	br	82455d0 <igmpv1_input+0x274>
      
   default:
      ++igmpstats.igmpv1mode_unknown_pkttype;
 82455a8:	008209b4 	movhi	r2,2086
 82455ac:	10b82804 	addi	r2,r2,-8032
 82455b0:	10801017 	ldw	r2,64(r2)
 82455b4:	10c00044 	addi	r3,r2,1
 82455b8:	008209b4 	movhi	r2,2086
 82455bc:	10b82804 	addi	r2,r2,-8032
 82455c0:	10c01015 	stw	r3,64(r2)
      rc = IGMP_ERR;
 82455c4:	00bfffc4 	movi	r2,-1
 82455c8:	e0bffb15 	stw	r2,-20(fp)
      break;   
 82455cc:	0001883a 	nop
   }

   /* we're done with the received packet; return packet buffer back 
    * to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 82455d0:	01000084 	movi	r4,2
 82455d4:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   pk_free(p);
 82455d8:	e13fff17 	ldw	r4,-4(fp)
 82455dc:	822cbbc0 	call	822cbbc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 82455e0:	01000084 	movi	r4,2
 82455e4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      
   return rc;
 82455e8:	e0bffb17 	ldw	r2,-20(fp)
}
 82455ec:	e037883a 	mov	sp,fp
 82455f0:	dfc00117 	ldw	ra,4(sp)
 82455f4:	df000017 	ldw	fp,0(sp)
 82455f8:	dec00204 	addi	sp,sp,8
 82455fc:	f800283a 	ret

08245600 <igmpv2_input>:
 * from igmpv2_process_report (), IGMP_OK (for a received Leave Group
 * message only), or IGMP_ERR (for a message of an "unknown" type).
 */

int igmpv2_input (PACKET p)
{
 8245600:	defff904 	addi	sp,sp,-28
 8245604:	dfc00615 	stw	ra,24(sp)
 8245608:	df000515 	stw	fp,20(sp)
 824560c:	df000504 	addi	fp,sp,20
 8245610:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   u_char type;
   int rc;

   pip = ip_head (p);    
 8245614:	e0bfff17 	ldw	r2,-4(fp)
 8245618:	10800317 	ldw	r2,12(r2)
 824561c:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 8245620:	e0bffc17 	ldw	r2,-16(fp)
 8245624:	10800003 	ldbu	r2,0(r2)
 8245628:	10803fcc 	andi	r2,r2,255
 824562c:	108003cc 	andi	r2,r2,15
 8245630:	1085883a 	add	r2,r2,r2
 8245634:	1085883a 	add	r2,r2,r2
 8245638:	1007883a 	mov	r3,r2
 824563c:	e0bffc17 	ldw	r2,-16(fp)
 8245640:	10c5883a 	add	r2,r2,r3
 8245644:	e0bffd15 	stw	r2,-12(fp)
   /* extract the IGMP packet type from received packet */
   type = igmp->igmp_type;
 8245648:	e0bffd17 	ldw	r2,-12(fp)
 824564c:	10800003 	ldbu	r2,0(r2)
 8245650:	e0bffe05 	stb	r2,-8(fp)

   switch (type) 
 8245654:	e0bffe03 	ldbu	r2,-8(fp)
 8245658:	10c004a0 	cmpeqi	r3,r2,18
 824565c:	18000e1e 	bne	r3,zero,8245698 <igmpv2_input+0x98>
 8245660:	10c004c8 	cmpgei	r3,r2,19
 8245664:	1800031e 	bne	r3,zero,8245674 <igmpv2_input+0x74>
 8245668:	10800460 	cmpeqi	r2,r2,17
 824566c:	1000061e 	bne	r2,zero,8245688 <igmpv2_input+0x88>
 8245670:	00001606 	br	82456cc <igmpv2_input+0xcc>
 8245674:	10c005a0 	cmpeqi	r3,r2,22
 8245678:	1800071e 	bne	r3,zero,8245698 <igmpv2_input+0x98>
 824567c:	108005e0 	cmpeqi	r2,r2,23
 8245680:	1000091e 	bne	r2,zero,82456a8 <igmpv2_input+0xa8>
 8245684:	00001106 	br	82456cc <igmpv2_input+0xcc>
   {
      case IGMP_HOST_MEMBERSHIP_QUERY:
         rc = igmpv2_process_query (p);
 8245688:	e13fff17 	ldw	r4,-4(fp)
 824568c:	82458580 	call	8245858 <igmpv2_process_query>
 8245690:	e0bffb15 	stw	r2,-20(fp)
         break;
 8245694:	00001706 	br	82456f4 <igmpv2_input+0xf4>

      case IGMP_HOST_MEMBERSHIP_REPORT:
      case IGMPv2_MEMBERSHIP_REPORT:
         rc = igmpv2_process_report (p);
 8245698:	e13fff17 	ldw	r4,-4(fp)
 824569c:	82457240 	call	8245724 <igmpv2_process_report>
 82456a0:	e0bffb15 	stw	r2,-20(fp)
         break;
 82456a4:	00001306 	br	82456f4 <igmpv2_input+0xf4>
          * expect to receive such messages.  However, according to
          * RFC 2236, some implementations of an older version of the 
          * IGMPv2 specification send leave messages to the group 
          * being left.  If we do receive such a message, we will 
          * drop it. */       
         ++igmpstats.igmpv2mode_v2_leave_msgs_rcvd;
 82456a8:	008209b4 	movhi	r2,2086
 82456ac:	10b82804 	addi	r2,r2,-8032
 82456b0:	10800917 	ldw	r2,36(r2)
 82456b4:	10c00044 	addi	r3,r2,1
 82456b8:	008209b4 	movhi	r2,2086
 82456bc:	10b82804 	addi	r2,r2,-8032
 82456c0:	10c00915 	stw	r3,36(r2)
         rc = IGMP_OK;
 82456c4:	e03ffb15 	stw	zero,-20(fp)
         break;               
 82456c8:	00000a06 	br	82456f4 <igmpv2_input+0xf4>

      default:     
         ++igmpstats.igmpv2mode_unknown_pkttype;
 82456cc:	008209b4 	movhi	r2,2086
 82456d0:	10b82804 	addi	r2,r2,-8032
 82456d4:	10801517 	ldw	r2,84(r2)
 82456d8:	10c00044 	addi	r3,r2,1
 82456dc:	008209b4 	movhi	r2,2086
 82456e0:	10b82804 	addi	r2,r2,-8032
 82456e4:	10c01515 	stw	r3,84(r2)
         rc = IGMP_ERR;         
 82456e8:	00bfffc4 	movi	r2,-1
 82456ec:	e0bffb15 	stw	r2,-20(fp)
         break;
 82456f0:	0001883a 	nop
   } /* end SWITCH */

   /* we're done processing the received packet; return packet buffer 
    * back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 82456f4:	01000084 	movi	r4,2
 82456f8:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   pk_free(p);
 82456fc:	e13fff17 	ldw	r4,-4(fp)
 8245700:	822cbbc0 	call	822cbbc <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 8245704:	01000084 	movi	r4,2
 8245708:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
   
   return rc;
 824570c:	e0bffb17 	ldw	r2,-20(fp)
}
 8245710:	e037883a 	mov	sp,fp
 8245714:	dfc00117 	ldw	ra,4(sp)
 8245718:	df000017 	ldw	fp,0(sp)
 824571c:	dec00204 	addi	sp,sp,8
 8245720:	f800283a 	ret

08245724 <igmpv2_process_report>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_report (PACKET p)
{
 8245724:	defff904 	addi	sp,sp,-28
 8245728:	dfc00615 	stw	ra,24(sp)
 824572c:	df000515 	stw	fp,20(sp)
 8245730:	df000504 	addi	fp,sp,20
 8245734:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   NET netp;
   struct in_multi * inm;

   netp = p->net;
 8245738:	e0bfff17 	ldw	r2,-4(fp)
 824573c:	10800617 	ldw	r2,24(r2)
 8245740:	e0bffb15 	stw	r2,-20(fp)
   pip = ip_head (p);
 8245744:	e0bfff17 	ldw	r2,-4(fp)
 8245748:	10800317 	ldw	r2,12(r2)
 824574c:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 8245750:	e0bffc17 	ldw	r2,-16(fp)
 8245754:	10800003 	ldbu	r2,0(r2)
 8245758:	10803fcc 	andi	r2,r2,255
 824575c:	108003cc 	andi	r2,r2,15
 8245760:	1085883a 	add	r2,r2,r2
 8245764:	1085883a 	add	r2,r2,r2
 8245768:	1007883a 	mov	r3,r2
 824576c:	e0bffc17 	ldw	r2,-16(fp)
 8245770:	10c5883a 	add	r2,r2,r3
 8245774:	e0bffd15 	stw	r2,-12(fp)
    * processing IGMPv2 packets (it has "downgraded" itself because
    * there are IGMPv1 routers on that network); however, we do not
    * know that, and hence we don't cancel our timer (for the 
    * subsequent transmission of a IGMPv1 report).
    */
   inm = lookup_mcast(igmp->igmp_group, netp);
 8245778:	e0bffd17 	ldw	r2,-12(fp)
 824577c:	10800117 	ldw	r2,4(r2)
 8245780:	e17ffb17 	ldw	r5,-20(fp)
 8245784:	1009883a 	mov	r4,r2
 8245788:	82439f80 	call	82439f8 <lookup_mcast>
 824578c:	e0bffe15 	stw	r2,-8(fp)
   if (inm != NULL) 
 8245790:	e0bffe17 	ldw	r2,-8(fp)
 8245794:	10002326 	beq	r2,zero,8245824 <igmpv2_process_report+0x100>
   {
      if (inm->inm_timer != 0)
 8245798:	e0bffe17 	ldw	r2,-8(fp)
 824579c:	10800317 	ldw	r2,12(r2)
 82457a0:	10001826 	beq	r2,zero,8245804 <igmpv2_process_report+0xe0>
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 82457a4:	e0bffb17 	ldw	r2,-20(fp)
 82457a8:	10802d03 	ldbu	r2,180(r2)
 82457ac:	10803fcc 	andi	r2,r2,255
 82457b0:	10000526 	beq	r2,zero,82457c8 <igmpv2_process_report+0xa4>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
 82457b4:	e0bffd17 	ldw	r2,-12(fp)
 82457b8:	10800003 	ldbu	r2,0(r2)
   if (inm != NULL) 
   {
      if (inm->inm_timer != 0)
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 82457bc:	10803fcc 	andi	r2,r2,255
 82457c0:	108005a0 	cmpeqi	r2,r2,22
 82457c4:	10001e1e 	bne	r2,zero,8245840 <igmpv2_process_report+0x11c>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
         {
            /* cancel timer */
            inm->inm_timer = 0;
 82457c8:	e0bffe17 	ldw	r2,-8(fp)
 82457cc:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 82457d0:	d0a08617 	ldw	r2,-32232(gp)
 82457d4:	10bfffc4 	addi	r2,r2,-1
 82457d8:	d0a08615 	stw	r2,-32232(gp)
            /* indicate that we are not the last host to send a 
             * report for this group */
            inm->last2send_report = IGMP_FALSE;
 82457dc:	e0bffe17 	ldw	r2,-8(fp)
 82457e0:	10000405 	stb	zero,16(r2)
            ++igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer;
 82457e4:	008209b4 	movhi	r2,2086
 82457e8:	10b82804 	addi	r2,r2,-8032
 82457ec:	10800717 	ldw	r2,28(r2)
 82457f0:	10c00044 	addi	r3,r2,1
 82457f4:	008209b4 	movhi	r2,2086
 82457f8:	10b82804 	addi	r2,r2,-8032
 82457fc:	10c00715 	stw	r3,28(r2)
 8245800:	00000f06 	br	8245840 <igmpv2_process_report+0x11c>
      else
      {
         /* we don't have a timer running; perhaps the source
          * host has just joined the group, and has sent an
          * unsolicited report */
         ++igmpstats.igmpv2mode_v12_reports_rcvd_no_timer;   
 8245804:	008209b4 	movhi	r2,2086
 8245808:	10b82804 	addi	r2,r2,-8032
 824580c:	10800817 	ldw	r2,32(r2)
 8245810:	10c00044 	addi	r3,r2,1
 8245814:	008209b4 	movhi	r2,2086
 8245818:	10b82804 	addi	r2,r2,-8032
 824581c:	10c00815 	stw	r3,32(r2)
 8245820:	00000706 	br	8245840 <igmpv2_process_report+0x11c>
       * on that interface.  Even if imperfect filtering at the 
       * device level causes reports for unregistered groups to 
       * be passed up to the IP module, ip_rcv_phase2 () is 
       * responsible for dropping them, and so we should never
       * receive such packets. */
      ++igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd;
 8245824:	008209b4 	movhi	r2,2086
 8245828:	10b82804 	addi	r2,r2,-8032
 824582c:	10801317 	ldw	r2,76(r2)
 8245830:	10c00044 	addi	r3,r2,1
 8245834:	008209b4 	movhi	r2,2086
 8245838:	10b82804 	addi	r2,r2,-8032
 824583c:	10c01315 	stw	r3,76(r2)
   }
   
   return IGMP_OK;   
 8245840:	0005883a 	mov	r2,zero
}
 8245844:	e037883a 	mov	sp,fp
 8245848:	dfc00117 	ldw	ra,4(sp)
 824584c:	df000017 	ldw	fp,0(sp)
 8245850:	dec00204 	addi	sp,sp,8
 8245854:	f800283a 	ret

08245858 <igmpv2_process_query>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_query (PACKET p)
{
 8245858:	defff804 	addi	sp,sp,-32
 824585c:	dfc00715 	stw	ra,28(sp)
 8245860:	df000615 	stw	fp,24(sp)
 8245864:	df000604 	addi	fp,sp,24
 8245868:	e13fff15 	stw	r4,-4(fp)
   NET netp;
   u_short max_resp_time;
   u_char process_all;
   struct in_multi * inm;

   netp = p->net;
 824586c:	e0bfff17 	ldw	r2,-4(fp)
 8245870:	10800617 	ldw	r2,24(r2)
 8245874:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 8245878:	e0bfff17 	ldw	r2,-4(fp)
 824587c:	10800317 	ldw	r2,12(r2)
 8245880:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 8245884:	e0bffd17 	ldw	r2,-12(fp)
 8245888:	10800003 	ldbu	r2,0(r2)
 824588c:	10803fcc 	andi	r2,r2,255
 8245890:	108003cc 	andi	r2,r2,15
 8245894:	1085883a 	add	r2,r2,r2
 8245898:	1085883a 	add	r2,r2,r2
 824589c:	1007883a 	mov	r3,r2
 82458a0:	e0bffd17 	ldw	r2,-12(fp)
 82458a4:	10c5883a 	add	r2,r2,r3
 82458a8:	e0bffe15 	stw	r2,-8(fp)

   if (igmp->igmp_code == 0)
 82458ac:	e0bffe17 	ldw	r2,-8(fp)
 82458b0:	10800043 	ldbu	r2,1(r2)
 82458b4:	10803fcc 	andi	r2,r2,255
 82458b8:	1000121e 	bne	r2,zero,8245904 <igmpv2_process_query+0xac>
   {
      /* this is a IGMPv1 Host Membership Query */
      netp->igmpv1_rtr_present = IGMP_TRUE;
 82458bc:	e0bffc17 	ldw	r2,-16(fp)
 82458c0:	00c00044 	movi	r3,1
 82458c4:	10c02d05 	stb	r3,180(r2)
      netp->igmpv1_query_rcvd_time = cticks;      
 82458c8:	d0e0a817 	ldw	r3,-32096(gp)
 82458cc:	e0bffc17 	ldw	r2,-16(fp)
 82458d0:	10c02e15 	stw	r3,184(r2)
      ++igmpstats.igmpv2mode_v1_queries_rcvd;
 82458d4:	008209b4 	movhi	r2,2086
 82458d8:	10b82804 	addi	r2,r2,-8032
 82458dc:	10800417 	ldw	r2,16(r2)
 82458e0:	10c00044 	addi	r3,r2,1
 82458e4:	008209b4 	movhi	r2,2086
 82458e8:	10b82804 	addi	r2,r2,-8032
 82458ec:	10c00415 	stw	r3,16(r2)
      /* set maximum time to respond to the equivalent of 10 
       * seconds worth of "ticks" (the timeout routine is
       * intended to be invoked PR_FASTHZ (5) times a second,
       * so each tick is equal to 200 ms) */
      max_resp_time = IGMP_MAX_HOST_REPORT_DELAY * PR_FASTHZ;
 82458f0:	00800c84 	movi	r2,50
 82458f4:	e0bffa0d 	sth	r2,-24(fp)
      process_all = IGMP_TRUE;
 82458f8:	00800044 	movi	r2,1
 82458fc:	e0bffa85 	stb	r2,-22(fp)
 8245900:	00001d06 	br	8245978 <igmpv2_process_query+0x120>
   }
   else
   {
      /* this is either a IGMPv2 General Query or 
       * a IGMPv2 Group-Specific Query */
      if (igmp->igmp_group == 0)
 8245904:	e0bffe17 	ldw	r2,-8(fp)
 8245908:	10800117 	ldw	r2,4(r2)
 824590c:	10000a1e 	bne	r2,zero,8245938 <igmpv2_process_query+0xe0>
      {
         /* this is a IGMPv2 General Query */
         ++igmpstats.igmpv2mode_v2_general_queries_rcvd;
 8245910:	008209b4 	movhi	r2,2086
 8245914:	10b82804 	addi	r2,r2,-8032
 8245918:	10800517 	ldw	r2,20(r2)
 824591c:	10c00044 	addi	r3,r2,1
 8245920:	008209b4 	movhi	r2,2086
 8245924:	10b82804 	addi	r2,r2,-8032
 8245928:	10c00515 	stw	r3,20(r2)
         process_all = IGMP_TRUE;
 824592c:	00800044 	movi	r2,1
 8245930:	e0bffa85 	stb	r2,-22(fp)
 8245934:	00000806 	br	8245958 <igmpv2_process_query+0x100>
      }
      else
      {
         /* this is a IGMPv2 Group-Specific Query */       
         ++igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd;
 8245938:	008209b4 	movhi	r2,2086
 824593c:	10b82804 	addi	r2,r2,-8032
 8245940:	10800617 	ldw	r2,24(r2)
 8245944:	10c00044 	addi	r3,r2,1
 8245948:	008209b4 	movhi	r2,2086
 824594c:	10b82804 	addi	r2,r2,-8032
 8245950:	10c00615 	stw	r3,24(r2)
         process_all = IGMP_FALSE;
 8245954:	e03ffa85 	stb	zero,-22(fp)
       * IGMPv2 General Query or a IGMPv2 Group-Specific Query,
       * set maximum time to respond to value extracted 
       * from received message. The value in the message
       * is in tenths of a second.  max_resp_time is in
       * units of ticks (where one tick is 200 ms) */
      max_resp_time = (igmp->igmp_code * PR_FASTHZ) / 10;
 8245958:	e0bffe17 	ldw	r2,-8(fp)
 824595c:	10800043 	ldbu	r2,1(r2)
 8245960:	10803fcc 	andi	r2,r2,255
 8245964:	10800164 	muli	r2,r2,5
 8245968:	01400284 	movi	r5,10
 824596c:	1009883a 	mov	r4,r2
 8245970:	8202a940 	call	8202a94 <__divsi3>
 8245974:	e0bffa0d 	sth	r2,-24(fp)
   
   /* process all entries in a link's multicast address linked
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
 8245978:	e0bffa83 	ldbu	r2,-22(fp)
 824597c:	10001726 	beq	r2,zero,82459dc <igmpv2_process_query+0x184>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 8245980:	e0bffc17 	ldw	r2,-16(fp)
 8245984:	10802c17 	ldw	r2,176(r2)
 8245988:	e0bffb15 	stw	r2,-20(fp)
 824598c:	00001006 	br	82459d0 <igmpv2_process_query+0x178>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 8245990:	e0bffb17 	ldw	r2,-20(fp)
 8245994:	10800017 	ldw	r2,0(r2)
 8245998:	10000926 	beq	r2,zero,82459c0 <igmpv2_process_query+0x168>
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 824599c:	e0bffb17 	ldw	r2,-20(fp)
 82459a0:	10c00017 	ldw	r3,0(r2)
 82459a4:	d0a08817 	ldw	r2,-32224(gp)
 82459a8:	18800626 	beq	r3,r2,82459c4 <igmpv2_process_query+0x16c>
            igmpv2_chk_set_timer (inm, max_resp_time);
 82459ac:	e0bffa0b 	ldhu	r2,-24(fp)
 82459b0:	100b883a 	mov	r5,r2
 82459b4:	e13ffb17 	ldw	r4,-20(fp)
 82459b8:	8245a440 	call	8245a44 <igmpv2_chk_set_timer>
 82459bc:	00000106 	br	82459c4 <igmpv2_process_query+0x16c>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 82459c0:	0001883a 	nop
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 82459c4:	e0bffb17 	ldw	r2,-20(fp)
 82459c8:	10800517 	ldw	r2,20(r2)
 82459cc:	e0bffb15 	stw	r2,-20(fp)
 82459d0:	e0bffb17 	ldw	r2,-20(fp)
 82459d4:	103fee1e 	bne	r2,zero,8245990 <igmpv2_process_query+0x138>
 82459d8:	00001406 	br	8245a2c <igmpv2_process_query+0x1d4>
   {
      /* process one (for IGMPv2 Group-Specific Query) entry (the 
       * one that corresponds to the address listed in the received 
       * query) - it should be present in the link's multicast
       * address list */
      inm = lookup_mcast(igmp->igmp_group, netp);
 82459dc:	e0bffe17 	ldw	r2,-8(fp)
 82459e0:	10800117 	ldw	r2,4(r2)
 82459e4:	e17ffc17 	ldw	r5,-16(fp)
 82459e8:	1009883a 	mov	r4,r2
 82459ec:	82439f80 	call	82439f8 <lookup_mcast>
 82459f0:	e0bffb15 	stw	r2,-20(fp)
      if (inm != NULL)
 82459f4:	e0bffb17 	ldw	r2,-20(fp)
 82459f8:	10000526 	beq	r2,zero,8245a10 <igmpv2_process_query+0x1b8>
         igmpv2_chk_set_timer (inm, max_resp_time);
 82459fc:	e0bffa0b 	ldhu	r2,-24(fp)
 8245a00:	100b883a 	mov	r5,r2
 8245a04:	e13ffb17 	ldw	r4,-20(fp)
 8245a08:	8245a440 	call	8245a44 <igmpv2_chk_set_timer>
 8245a0c:	00000706 	br	8245a2c <igmpv2_process_query+0x1d4>
      else ++igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd;
 8245a10:	008209b4 	movhi	r2,2086
 8245a14:	10b82804 	addi	r2,r2,-8032
 8245a18:	10801217 	ldw	r2,72(r2)
 8245a1c:	10c00044 	addi	r3,r2,1
 8245a20:	008209b4 	movhi	r2,2086
 8245a24:	10b82804 	addi	r2,r2,-8032
 8245a28:	10c01215 	stw	r3,72(r2)
   } /* end ELSE (process ALL) */
   
   /* return success; caller will the received packet back to the 
    * free pool */
   return IGMP_OK;
 8245a2c:	0005883a 	mov	r2,zero
}
 8245a30:	e037883a 	mov	sp,fp
 8245a34:	dfc00117 	ldw	ra,4(sp)
 8245a38:	df000017 	ldw	fp,0(sp)
 8245a3c:	dec00204 	addi	sp,sp,8
 8245a40:	f800283a 	ret

08245a44 <igmpv2_chk_set_timer>:
 *
 * OUTPUT: None.
 */

void igmpv2_chk_set_timer (struct in_multi * inm, u_short max_resp_time)
{  
 8245a44:	defffc04 	addi	sp,sp,-16
 8245a48:	dfc00315 	stw	ra,12(sp)
 8245a4c:	df000215 	stw	fp,8(sp)
 8245a50:	df000204 	addi	fp,sp,8
 8245a54:	e13ffe15 	stw	r4,-8(fp)
 8245a58:	2805883a 	mov	r2,r5
 8245a5c:	e0bfff0d 	sth	r2,-4(fp)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 8245a60:	e0bffe17 	ldw	r2,-8(fp)
 8245a64:	10800317 	ldw	r2,12(r2)
 8245a68:	e0ffff0b 	ldhu	r3,-4(fp)
 8245a6c:	18800336 	bltu	r3,r2,8245a7c <igmpv2_chk_set_timer+0x38>
       (inm->inm_timer == 0))
 8245a70:	e0bffe17 	ldw	r2,-8(fp)
 8245a74:	10800317 	ldw	r2,12(r2)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 8245a78:	10003d1e 	bne	r2,zero,8245b70 <igmpv2_chk_set_timer+0x12c>
       (inm->inm_timer == 0))
   {
      if (inm->inm_timer == 0) ++igmp_timers_are_running;
 8245a7c:	e0bffe17 	ldw	r2,-8(fp)
 8245a80:	10800317 	ldw	r2,12(r2)
 8245a84:	1000031e 	bne	r2,zero,8245a94 <igmpv2_chk_set_timer+0x50>
 8245a88:	d0a08617 	ldw	r2,-32232(gp)
 8245a8c:	10800044 	addi	r2,r2,1
 8245a90:	d0a08615 	stw	r2,-32232(gp)
      inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY (max_resp_time, inm->inm_addr);                     
 8245a94:	008209b4 	movhi	r2,2086
 8245a98:	10ba6a04 	addi	r2,r2,-5720
 8245a9c:	10c00217 	ldw	r3,8(r2)
 8245aa0:	008209b4 	movhi	r2,2086
 8245aa4:	10b82404 	addi	r2,r2,-8048
 8245aa8:	10800017 	ldw	r2,0(r2)
 8245aac:	10800a17 	ldw	r2,40(r2)
 8245ab0:	1008d63a 	srli	r4,r2,24
 8245ab4:	008209b4 	movhi	r2,2086
 8245ab8:	10b82404 	addi	r2,r2,-8048
 8245abc:	10800017 	ldw	r2,0(r2)
 8245ac0:	10800a17 	ldw	r2,40(r2)
 8245ac4:	1004d23a 	srli	r2,r2,8
 8245ac8:	10bfc00c 	andi	r2,r2,65280
 8245acc:	2088b03a 	or	r4,r4,r2
 8245ad0:	008209b4 	movhi	r2,2086
 8245ad4:	10b82404 	addi	r2,r2,-8048
 8245ad8:	10800017 	ldw	r2,0(r2)
 8245adc:	10800a17 	ldw	r2,40(r2)
 8245ae0:	10bfc00c 	andi	r2,r2,65280
 8245ae4:	1004923a 	slli	r2,r2,8
 8245ae8:	2088b03a 	or	r4,r4,r2
 8245aec:	008209b4 	movhi	r2,2086
 8245af0:	10b82404 	addi	r2,r2,-8048
 8245af4:	10800017 	ldw	r2,0(r2)
 8245af8:	10800a17 	ldw	r2,40(r2)
 8245afc:	1004963a 	slli	r2,r2,24
 8245b00:	2084b03a 	or	r2,r4,r2
 8245b04:	1887883a 	add	r3,r3,r2
 8245b08:	e0bffe17 	ldw	r2,-8(fp)
 8245b0c:	10800017 	ldw	r2,0(r2)
 8245b10:	1008d63a 	srli	r4,r2,24
 8245b14:	e0bffe17 	ldw	r2,-8(fp)
 8245b18:	10800017 	ldw	r2,0(r2)
 8245b1c:	1004d23a 	srli	r2,r2,8
 8245b20:	10bfc00c 	andi	r2,r2,65280
 8245b24:	2088b03a 	or	r4,r4,r2
 8245b28:	e0bffe17 	ldw	r2,-8(fp)
 8245b2c:	10800017 	ldw	r2,0(r2)
 8245b30:	10bfc00c 	andi	r2,r2,65280
 8245b34:	1004923a 	slli	r2,r2,8
 8245b38:	2088b03a 	or	r4,r4,r2
 8245b3c:	e0bffe17 	ldw	r2,-8(fp)
 8245b40:	10800017 	ldw	r2,0(r2)
 8245b44:	1004963a 	slli	r2,r2,24
 8245b48:	2084b03a 	or	r2,r4,r2
 8245b4c:	1885883a 	add	r2,r3,r2
 8245b50:	e0ffff0b 	ldhu	r3,-4(fp)
 8245b54:	180b883a 	mov	r5,r3
 8245b58:	1009883a 	mov	r4,r2
 8245b5c:	8202bf00 	call	8202bf0 <__umodsi3>
 8245b60:	10c00044 	addi	r3,r2,1
 8245b64:	e0bffe17 	ldw	r2,-8(fp)
 8245b68:	10c00315 	stw	r3,12(r2)
   }

   return;
 8245b6c:	0001883a 	nop
 8245b70:	0001883a 	nop
}
 8245b74:	e037883a 	mov	sp,fp
 8245b78:	dfc00117 	ldw	ra,4(sp)
 8245b7c:	df000017 	ldw	fp,0(sp)
 8245b80:	dec00204 	addi	sp,sp,8
 8245b84:	f800283a 	ret

08245b88 <igmpv2_chk4_rtr_alert_opt>:
 *         the IP Router Alert option in the received
 *         packet, and IGMP_FALSE otherwise.
 */

u_char igmpv2_chk4_rtr_alert_opt (struct ip * pip)
{
 8245b88:	defffb04 	addi	sp,sp,-20
 8245b8c:	df000415 	stw	fp,16(sp)
 8245b90:	df000404 	addi	fp,sp,16
 8245b94:	e13fff15 	stw	r4,-4(fp)
   u_long * rtr_alert_optp;
   u_char total_optlen;
   u_char optlen;
   u_char optval;

   total_optlen = ip_hlen (pip) - sizeof (struct ip);
 8245b98:	e0bfff17 	ldw	r2,-4(fp)
 8245b9c:	10800003 	ldbu	r2,0(r2)
 8245ba0:	108003cc 	andi	r2,r2,15
 8245ba4:	1085883a 	add	r2,r2,r2
 8245ba8:	1085883a 	add	r2,r2,r2
 8245bac:	10bffb04 	addi	r2,r2,-20
 8245bb0:	e0bffd05 	stb	r2,-12(fp)

   if (total_optlen > 0)
 8245bb4:	e0bffd03 	ldbu	r2,-12(fp)
 8245bb8:	10003e26 	beq	r2,zero,8245cb4 <igmpv2_chk4_rtr_alert_opt+0x12c>
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
 8245bbc:	e0bfff17 	ldw	r2,-4(fp)
 8245bc0:	10800504 	addi	r2,r2,20
 8245bc4:	e0bffc15 	stw	r2,-16(fp)
  
      while (total_optlen > 0)
 8245bc8:	00003806 	br	8245cac <igmpv2_chk4_rtr_alert_opt+0x124>
      {
         /* only the lowermost 5 bits are significant */    
         optval = (*optp) & IPOPT_TYPE_MASK;
 8245bcc:	e0bffc17 	ldw	r2,-16(fp)
 8245bd0:	10800003 	ldbu	r2,0(r2)
 8245bd4:	108007cc 	andi	r2,r2,31
 8245bd8:	e0bffd85 	stb	r2,-10(fp)
         switch (optval)
 8245bdc:	e0bffd83 	ldbu	r2,-10(fp)
 8245be0:	10c00060 	cmpeqi	r3,r2,1
 8245be4:	1800071e 	bne	r3,zero,8245c04 <igmpv2_chk4_rtr_alert_opt+0x7c>
 8245be8:	10c00520 	cmpeqi	r3,r2,20
 8245bec:	1800081e 	bne	r3,zero,8245c10 <igmpv2_chk4_rtr_alert_opt+0x88>
 8245bf0:	1000201e 	bne	r2,zero,8245c74 <igmpv2_chk4_rtr_alert_opt+0xec>
         {
            case EOL_OPT:
               /* we've encountered the End of Option List option, 
                * and so setting optlen isn't necessary */
               optlen = 1;
 8245bf4:	00800044 	movi	r2,1
 8245bf8:	e0bffd45 	stb	r2,-11(fp)
               /* we're done - we couldn't locate the IP Router Alert 
                * option in this IP header */
               return IGMP_FALSE;
 8245bfc:	0005883a 	mov	r2,zero
 8245c00:	00002d06 	br	8245cb8 <igmpv2_chk4_rtr_alert_opt+0x130>
         
            case NOOP_OPT:
               /* skip past the one byte of the No Operation option */
               optlen = 1;
 8245c04:	00800044 	movi	r2,1
 8245c08:	e0bffd45 	stb	r2,-11(fp)
               break;
 8245c0c:	00001f06 	br	8245c8c <igmpv2_chk4_rtr_alert_opt+0x104>
         
            case IP_RTR_ALERT_OPT:
               rtr_alert_optp = (u_long *) optp; 
 8245c10:	e0bffc17 	ldw	r2,-16(fp)
 8245c14:	e0bffe15 	stw	r2,-8(fp)
               if ((ntohl (*rtr_alert_optp)) == IP_RTR_ALERT_OPT_DATA)
 8245c18:	e0bffe17 	ldw	r2,-8(fp)
 8245c1c:	10800017 	ldw	r2,0(r2)
 8245c20:	1006d63a 	srli	r3,r2,24
 8245c24:	e0bffe17 	ldw	r2,-8(fp)
 8245c28:	10800017 	ldw	r2,0(r2)
 8245c2c:	1004d23a 	srli	r2,r2,8
 8245c30:	10bfc00c 	andi	r2,r2,65280
 8245c34:	1886b03a 	or	r3,r3,r2
 8245c38:	e0bffe17 	ldw	r2,-8(fp)
 8245c3c:	10800017 	ldw	r2,0(r2)
 8245c40:	10bfc00c 	andi	r2,r2,65280
 8245c44:	1004923a 	slli	r2,r2,8
 8245c48:	1886b03a 	or	r3,r3,r2
 8245c4c:	e0bffe17 	ldw	r2,-8(fp)
 8245c50:	10800017 	ldw	r2,0(r2)
 8245c54:	1004963a 	slli	r2,r2,24
 8245c58:	1886b03a 	or	r3,r3,r2
 8245c5c:	00a50134 	movhi	r2,37892
 8245c60:	1880021e 	bne	r3,r2,8245c6c <igmpv2_chk4_rtr_alert_opt+0xe4>
                  /* found the option, return success */
                  return IGMP_TRUE;
 8245c64:	00800044 	movi	r2,1
 8245c68:	00001306 	br	8245cb8 <igmpv2_chk4_rtr_alert_opt+0x130>
               else return IGMP_FALSE;
 8245c6c:	0005883a 	mov	r2,zero
 8245c70:	00001106 	br	8245cb8 <igmpv2_chk4_rtr_alert_opt+0x130>
          
            default:
               /* extract the length of the current option, and compute
                * the total length of this option */
               optlen = (*(optp + 1)) + 2;
 8245c74:	e0bffc17 	ldw	r2,-16(fp)
 8245c78:	10800044 	addi	r2,r2,1
 8245c7c:	10800003 	ldbu	r2,0(r2)
 8245c80:	10800084 	addi	r2,r2,2
 8245c84:	e0bffd45 	stb	r2,-11(fp)
               break;
 8245c88:	0001883a 	nop
         }
         
         /* skip past the bytes associated with the current option to 
          * point to the next option. */
         optp += optlen;
 8245c8c:	e0bffd43 	ldbu	r2,-11(fp)
 8245c90:	e0fffc17 	ldw	r3,-16(fp)
 8245c94:	1885883a 	add	r2,r3,r2
 8245c98:	e0bffc15 	stw	r2,-16(fp)
         total_optlen -= optlen;
 8245c9c:	e0fffd03 	ldbu	r3,-12(fp)
 8245ca0:	e0bffd43 	ldbu	r2,-11(fp)
 8245ca4:	1885c83a 	sub	r2,r3,r2
 8245ca8:	e0bffd05 	stb	r2,-12(fp)
   if (total_optlen > 0)
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
  
      while (total_optlen > 0)
 8245cac:	e0bffd03 	ldbu	r2,-12(fp)
 8245cb0:	103fc61e 	bne	r2,zero,8245bcc <igmpv2_chk4_rtr_alert_opt+0x44>
         total_optlen -= optlen;
      } /* end WHILE */
   }

   /* didn't find IP Alert option in IP header of rcvd packet */
   return IGMP_FALSE;
 8245cb4:	0005883a 	mov	r2,zero
}
 8245cb8:	e037883a 	mov	sp,fp
 8245cbc:	df000017 	ldw	fp,0(sp)
 8245cc0:	dec00104 	addi	sp,sp,4
 8245cc4:	f800283a 	ret

08245cc8 <IPADDR_TO_NETP>:
 * RETURNS: 
 */

void
IPADDR_TO_NETP(ip_addr addr, NET* netp)
{
 8245cc8:	defffc04 	addi	sp,sp,-16
 8245ccc:	df000315 	stw	fp,12(sp)
 8245cd0:	df000304 	addi	fp,sp,12
 8245cd4:	e13ffe15 	stw	r4,-8(fp)
 8245cd8:	e17fff15 	stw	r5,-4(fp)
   u_short  idx   =  0;
 8245cdc:	e03ffd0d 	sth	zero,-12(fp)
   *netp = nets[idx];
 8245ce0:	e0fffd0b 	ldhu	r3,-12(fp)
 8245ce4:	008209b4 	movhi	r2,2086
 8245ce8:	10b82404 	addi	r2,r2,-8048
 8245cec:	18c7883a 	add	r3,r3,r3
 8245cf0:	18c7883a 	add	r3,r3,r3
 8245cf4:	10c5883a 	add	r2,r2,r3
 8245cf8:	10c00017 	ldw	r3,0(r2)
 8245cfc:	e0bfff17 	ldw	r2,-4(fp)
 8245d00:	10c00015 	stw	r3,0(r2)
/*
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
 8245d04:	e0bffe17 	ldw	r2,-8(fp)
 8245d08:	10002e1e 	bne	r2,zero,8245dc4 <IPADDR_TO_NETP+0xfc>
   {
      for (idx = 0; idx < ifNumber; idx++)
 8245d0c:	e03ffd0d 	sth	zero,-12(fp)
 8245d10:	00001606 	br	8245d6c <IPADDR_TO_NETP+0xa4>
      {
         if (nets[idx]->n_mcastlist)
 8245d14:	e0fffd0b 	ldhu	r3,-12(fp)
 8245d18:	008209b4 	movhi	r2,2086
 8245d1c:	10b82404 	addi	r2,r2,-8048
 8245d20:	18c7883a 	add	r3,r3,r3
 8245d24:	18c7883a 	add	r3,r3,r3
 8245d28:	10c5883a 	add	r2,r2,r3
 8245d2c:	10800017 	ldw	r2,0(r2)
 8245d30:	10802b17 	ldw	r2,172(r2)
 8245d34:	10000a26 	beq	r2,zero,8245d60 <IPADDR_TO_NETP+0x98>
         {
            *netp = nets[idx];
 8245d38:	e0fffd0b 	ldhu	r3,-12(fp)
 8245d3c:	008209b4 	movhi	r2,2086
 8245d40:	10b82404 	addi	r2,r2,-8048
 8245d44:	18c7883a 	add	r3,r3,r3
 8245d48:	18c7883a 	add	r3,r3,r3
 8245d4c:	10c5883a 	add	r2,r2,r3
 8245d50:	10c00017 	ldw	r3,0(r2)
 8245d54:	e0bfff17 	ldw	r2,-4(fp)
 8245d58:	10c00015 	stw	r3,0(r2)
            break;
 8245d5c:	00002206 	br	8245de8 <IPADDR_TO_NETP+0x120>
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
   {
      for (idx = 0; idx < ifNumber; idx++)
 8245d60:	e0bffd0b 	ldhu	r2,-12(fp)
 8245d64:	10800044 	addi	r2,r2,1
 8245d68:	e0bffd0d 	sth	r2,-12(fp)
 8245d6c:	e0fffd0b 	ldhu	r3,-12(fp)
 8245d70:	d0a08417 	ldw	r2,-32240(gp)
 8245d74:	18bfe736 	bltu	r3,r2,8245d14 <IPADDR_TO_NETP+0x4c>
         }
         else
            *netp = nets[idx];
      }
   }
}
 8245d78:	00001b06 	br	8245de8 <IPADDR_TO_NETP+0x120>
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
      {
         idx++;
 8245d7c:	e0bffd0b 	ldhu	r2,-12(fp)
 8245d80:	10800044 	addi	r2,r2,1
 8245d84:	e0bffd0d 	sth	r2,-12(fp)
         if (idx >= ifNumber)
 8245d88:	e0fffd0b 	ldhu	r3,-12(fp)
 8245d8c:	d0a08417 	ldw	r2,-32240(gp)
 8245d90:	18800336 	bltu	r3,r2,8245da0 <IPADDR_TO_NETP+0xd8>
         {
            *netp = NULL;
 8245d94:	e0bfff17 	ldw	r2,-4(fp)
 8245d98:	10000015 	stw	zero,0(r2)
            break;
 8245d9c:	00001206 	br	8245de8 <IPADDR_TO_NETP+0x120>
         }
         else
            *netp = nets[idx];
 8245da0:	e0fffd0b 	ldhu	r3,-12(fp)
 8245da4:	008209b4 	movhi	r2,2086
 8245da8:	10b82404 	addi	r2,r2,-8048
 8245dac:	18c7883a 	add	r3,r3,r3
 8245db0:	18c7883a 	add	r3,r3,r3
 8245db4:	10c5883a 	add	r2,r2,r3
 8245db8:	10c00017 	ldw	r3,0(r2)
 8245dbc:	e0bfff17 	ldw	r2,-4(fp)
 8245dc0:	10c00015 	stw	r3,0(r2)
         }
      }
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
 8245dc4:	e0bfff17 	ldw	r2,-4(fp)
 8245dc8:	10800017 	ldw	r2,0(r2)
 8245dcc:	10000626 	beq	r2,zero,8245de8 <IPADDR_TO_NETP+0x120>
 8245dd0:	e0bfff17 	ldw	r2,-4(fp)
 8245dd4:	10800017 	ldw	r2,0(r2)
 8245dd8:	10c00a17 	ldw	r3,40(r2)
 8245ddc:	e0bffe17 	ldw	r2,-8(fp)
 8245de0:	18bfe61e 	bne	r3,r2,8245d7c <IPADDR_TO_NETP+0xb4>
         }
         else
            *netp = nets[idx];
      }
   }
}
 8245de4:	00000006 	br	8245de8 <IPADDR_TO_NETP+0x120>
 8245de8:	0001883a 	nop
 8245dec:	e037883a 	mov	sp,fp
 8245df0:	df000017 	ldw	fp,0(sp)
 8245df4:	dec00104 	addi	sp,sp,4
 8245df8:	f800283a 	ret

08245dfc <ip_setmoptions>:
 * RETURNS: 
 */

int
ip_setmoptions(int optname, struct socket * so, void * val)
{
 8245dfc:	defff304 	addi	sp,sp,-52
 8245e00:	dfc00c15 	stw	ra,48(sp)
 8245e04:	df000b15 	stw	fp,44(sp)
 8245e08:	dc000a15 	stw	r16,40(sp)
 8245e0c:	df000b04 	addi	fp,sp,44
 8245e10:	e13ffc15 	stw	r4,-16(fp)
 8245e14:	e17ffd15 	stw	r5,-12(fp)
 8245e18:	e1bffe15 	stw	r6,-8(fp)
   int   error =  0;
 8245e1c:	e03ff515 	stw	zero,-44(fp)
   u_short  i;
   struct ip_mreq *  mreq;
   struct net *   netp  =  NULL;
 8245e20:	e03ffb15 	stw	zero,-20(fp)
   struct ip_moptions * imo   =  so->inp_moptions;
 8245e24:	e0bffd17 	ldw	r2,-12(fp)
 8245e28:	10800317 	ldw	r2,12(r2)
 8245e2c:	e0bff715 	stw	r2,-36(fp)
   struct ip_moptions **imop  =  &so->inp_moptions;
 8245e30:	e0bffd17 	ldw	r2,-12(fp)
 8245e34:	10800304 	addi	r2,r2,12
 8245e38:	e0bff815 	stw	r2,-32(fp)
   ip_addr addr;


   if (imo == NULL) 
 8245e3c:	e0bff717 	ldw	r2,-36(fp)
 8245e40:	1000141e 	bne	r2,zero,8245e94 <ip_setmoptions+0x98>
   {
   /*
    * No multicast option buffer attached to the pcb;
    * allocate one and initialize to default values.
    */
      imo = (struct ip_moptions*)IM_ALLOC(sizeof(*imo));
 8245e44:	01001604 	movi	r4,88
 8245e48:	822dfec0 	call	822dfec <npalloc>
 8245e4c:	e0bff715 	stw	r2,-36(fp)

      if (imo == NULL)
 8245e50:	e0bff717 	ldw	r2,-36(fp)
 8245e54:	1000021e 	bne	r2,zero,8245e60 <ip_setmoptions+0x64>
         return (ENOBUFS);
 8245e58:	00801a44 	movi	r2,105
 8245e5c:	00015306 	br	82463ac <ip_setmoptions+0x5b0>
      *imop = imo;
 8245e60:	e0bff817 	ldw	r2,-32(fp)
 8245e64:	e0fff717 	ldw	r3,-36(fp)
 8245e68:	10c00015 	stw	r3,0(r2)
      imo->imo_multicast_netp = NULL;
 8245e6c:	e0bff717 	ldw	r2,-36(fp)
 8245e70:	10000015 	stw	zero,0(r2)
      imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
 8245e74:	e0bff717 	ldw	r2,-36(fp)
 8245e78:	00c00044 	movi	r3,1
 8245e7c:	10c00105 	stb	r3,4(r2)
      imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
 8245e80:	e0bff717 	ldw	r2,-36(fp)
 8245e84:	00c00044 	movi	r3,1
 8245e88:	10c00145 	stb	r3,5(r2)
      imo->imo_num_memberships = 0;
 8245e8c:	e0bff717 	ldw	r2,-36(fp)
 8245e90:	1000018d 	sth	zero,6(r2)
   }

   switch (optname) 
 8245e94:	e0bffc17 	ldw	r2,-16(fp)
 8245e98:	10bffdc4 	addi	r2,r2,-9
 8245e9c:	10c00168 	cmpgeui	r3,r2,5
 8245ea0:	1801261e 	bne	r3,zero,824633c <ip_setmoptions+0x540>
 8245ea4:	100690ba 	slli	r3,r2,2
 8245ea8:	00820934 	movhi	r2,2084
 8245eac:	1097af04 	addi	r2,r2,24252
 8245eb0:	1885883a 	add	r2,r3,r2
 8245eb4:	10800017 	ldw	r2,0(r2)
 8245eb8:	1000683a 	jmp	r2
 8245ebc:	08245ed0 	cmplti	zero,at,-28293
 8245ec0:	08245f38 	rdprs	zero,at,-28292
 8245ec4:	08245f4c 	andi	zero,at,37245
 8245ec8:	08245f80 	call	8245f8 <OSCtxSw_SWITCH_PC+0x8245b8>
 8245ecc:	08246154 	ori	zero,at,37253

   case IP_MULTICAST_IF:
      /*
       * Select the interface for outgoing multicast packets.
       */
      addr = *(ip_addr *)val;
 8245ed0:	e0bffe17 	ldw	r2,-8(fp)
 8245ed4:	10800017 	ldw	r2,0(r2)
 8245ed8:	e0bff915 	stw	r2,-28(fp)
         /*
          * AADDR is used to remove a previous selection.
          * When no interface is selected, a default one is
          * chosen every time a multicast packet is sent.
          */
      if (addr == AADDR) 
 8245edc:	e0bff917 	ldw	r2,-28(fp)
 8245ee0:	1000031e 	bne	r2,zero,8245ef0 <ip_setmoptions+0xf4>
      {
         imo->imo_multicast_netp = NULL;
 8245ee4:	e0bff717 	ldw	r2,-36(fp)
 8245ee8:	10000015 	stw	zero,0(r2)
         break;
 8245eec:	00011706 	br	824634c <ip_setmoptions+0x550>
         /*
          * The selected interface is identified by its local
          * IP address.  Find the interface and confirm that
          * it supports multicasting.
          */
      IPADDR_TO_NETP(addr, &netp);
 8245ef0:	e0bffb04 	addi	r2,fp,-20
 8245ef4:	100b883a 	mov	r5,r2
 8245ef8:	e13ff917 	ldw	r4,-28(fp)
 8245efc:	8245cc80 	call	8245cc8 <IPADDR_TO_NETP>
      if ((netp == NULL) || (netp->n_mcastlist) == NULL) 
 8245f00:	e0bffb17 	ldw	r2,-20(fp)
 8245f04:	10000326 	beq	r2,zero,8245f14 <ip_setmoptions+0x118>
 8245f08:	e0bffb17 	ldw	r2,-20(fp)
 8245f0c:	10802b17 	ldw	r2,172(r2)
 8245f10:	1000031e 	bne	r2,zero,8245f20 <ip_setmoptions+0x124>
      {
         error = EADDRNOTAVAIL;
 8245f14:	00801f44 	movi	r2,125
 8245f18:	e0bff515 	stw	r2,-44(fp)
         break;
 8245f1c:	00010b06 	br	824634c <ip_setmoptions+0x550>
      }
      if (addr != AADDR) 
 8245f20:	e0bff917 	ldw	r2,-28(fp)
 8245f24:	10010826 	beq	r2,zero,8246348 <ip_setmoptions+0x54c>
         imo->imo_multicast_netp = netp;
 8245f28:	e0fffb17 	ldw	r3,-20(fp)
 8245f2c:	e0bff717 	ldw	r2,-36(fp)
 8245f30:	10c00015 	stw	r3,0(r2)
      break;
 8245f34:	00010406 	br	8246348 <ip_setmoptions+0x54c>

   case IP_MULTICAST_TTL:
      /*
       * Set the IP time-to-live for outgoing multicast packets.
       */
      imo->imo_multicast_ttl = *(u_char *)val;
 8245f38:	e0bffe17 	ldw	r2,-8(fp)
 8245f3c:	10c00003 	ldbu	r3,0(r2)
 8245f40:	e0bff717 	ldw	r2,-36(fp)
 8245f44:	10c00105 	stb	r3,4(r2)
      break;
 8245f48:	00010006 	br	824634c <ip_setmoptions+0x550>
   case IP_MULTICAST_LOOP:
      /*
       * Set the loopback flag for outgoing multicast packets.
       * Must be zero or one.
       */
      if (*(u_char *)val > 1) 
 8245f4c:	e0bffe17 	ldw	r2,-8(fp)
 8245f50:	10800003 	ldbu	r2,0(r2)
 8245f54:	10803fcc 	andi	r2,r2,255
 8245f58:	108000b0 	cmpltui	r2,r2,2
 8245f5c:	1000031e 	bne	r2,zero,8245f6c <ip_setmoptions+0x170>
      {
         error = EINVAL;
 8245f60:	00800584 	movi	r2,22
 8245f64:	e0bff515 	stw	r2,-44(fp)
         break;
 8245f68:	0000f806 	br	824634c <ip_setmoptions+0x550>
      }
      imo->imo_multicast_loop = *(u_char *)(val);
 8245f6c:	e0bffe17 	ldw	r2,-8(fp)
 8245f70:	10c00003 	ldbu	r3,0(r2)
 8245f74:	e0bff717 	ldw	r2,-36(fp)
 8245f78:	10c00145 	stb	r3,5(r2)
      break;
 8245f7c:	0000f306 	br	824634c <ip_setmoptions+0x550>
   case IP_ADD_MEMBERSHIP:
      /*
       * Add a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 8245f80:	e0bffe17 	ldw	r2,-8(fp)
 8245f84:	e0bffa15 	stw	r2,-24(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 8245f88:	e0bffa17 	ldw	r2,-24(fp)
 8245f8c:	10800017 	ldw	r2,0(r2)
 8245f90:	1006d63a 	srli	r3,r2,24
 8245f94:	e0bffa17 	ldw	r2,-24(fp)
 8245f98:	10800017 	ldw	r2,0(r2)
 8245f9c:	1004d23a 	srli	r2,r2,8
 8245fa0:	10bfc00c 	andi	r2,r2,65280
 8245fa4:	1886b03a 	or	r3,r3,r2
 8245fa8:	e0bffa17 	ldw	r2,-24(fp)
 8245fac:	10800017 	ldw	r2,0(r2)
 8245fb0:	10bfc00c 	andi	r2,r2,65280
 8245fb4:	1004923a 	slli	r2,r2,8
 8245fb8:	1886b03a 	or	r3,r3,r2
 8245fbc:	e0bffa17 	ldw	r2,-24(fp)
 8245fc0:	10800017 	ldw	r2,0(r2)
 8245fc4:	1004963a 	slli	r2,r2,24
 8245fc8:	1884b03a 	or	r2,r3,r2
 8245fcc:	10fc002c 	andhi	r3,r2,61440
 8245fd0:	00b80034 	movhi	r2,57344
 8245fd4:	18800326 	beq	r3,r2,8245fe4 <ip_setmoptions+0x1e8>
      {
         error = EINVAL;
 8245fd8:	00800584 	movi	r2,22
 8245fdc:	e0bff515 	stw	r2,-44(fp)
         break;
 8245fe0:	0000da06 	br	824634c <ip_setmoptions+0x550>
       * If no interface address was provided, use the interface of
       * the route to the given multicast address.
       * For the Iniche stack implementation, look for a default
       * interface that supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 8245fe4:	e0bffa17 	ldw	r2,-24(fp)
 8245fe8:	10800117 	ldw	r2,4(r2)
 8245fec:	e0fffb04 	addi	r3,fp,-20
 8245ff0:	180b883a 	mov	r5,r3
 8245ff4:	1009883a 	mov	r4,r2
 8245ff8:	8245cc80 	call	8245cc8 <IPADDR_TO_NETP>
      /*
       * See if we found an interface, and confirm that it
       * supports multicast.
       */
      if (netp == NULL || (netp->n_mcastlist) == NULL) 
 8245ffc:	e0bffb17 	ldw	r2,-20(fp)
 8246000:	10000326 	beq	r2,zero,8246010 <ip_setmoptions+0x214>
 8246004:	e0bffb17 	ldw	r2,-20(fp)
 8246008:	10802b17 	ldw	r2,172(r2)
 824600c:	1000031e 	bne	r2,zero,824601c <ip_setmoptions+0x220>
      {
         error = EADDRNOTAVAIL;
 8246010:	00801f44 	movi	r2,125
 8246014:	e0bff515 	stw	r2,-44(fp)
         break;
 8246018:	0000cc06 	br	824634c <ip_setmoptions+0x550>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 824601c:	e03ff60d 	sth	zero,-40(fp)
 8246020:	00001806 	br	8246084 <ip_setmoptions+0x288>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 8246024:	e0bff60b 	ldhu	r2,-40(fp)
 8246028:	e0fff717 	ldw	r3,-36(fp)
 824602c:	10800084 	addi	r2,r2,2
 8246030:	1085883a 	add	r2,r2,r2
 8246034:	1085883a 	add	r2,r2,r2
 8246038:	1885883a 	add	r2,r3,r2
 824603c:	10800017 	ldw	r2,0(r2)
 8246040:	10c00117 	ldw	r3,4(r2)
 8246044:	e0bffb17 	ldw	r2,-20(fp)
 8246048:	18800b1e 	bne	r3,r2,8246078 <ip_setmoptions+0x27c>
             imo->imo_membership[i]->inm_addr
 824604c:	e0bff60b 	ldhu	r2,-40(fp)
 8246050:	e0fff717 	ldw	r3,-36(fp)
 8246054:	10800084 	addi	r2,r2,2
 8246058:	1085883a 	add	r2,r2,r2
 824605c:	1085883a 	add	r2,r2,r2
 8246060:	1885883a 	add	r2,r3,r2
 8246064:	10800017 	ldw	r2,0(r2)
 8246068:	10c00017 	ldw	r3,0(r2)
             == mreq->imr_multiaddr)
 824606c:	e0bffa17 	ldw	r2,-24(fp)
 8246070:	10800017 	ldw	r2,0(r2)
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 8246074:	18800926 	beq	r3,r2,824609c <ip_setmoptions+0x2a0>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 8246078:	e0bff60b 	ldhu	r2,-40(fp)
 824607c:	10800044 	addi	r2,r2,1
 8246080:	e0bff60d 	sth	r2,-40(fp)
 8246084:	e0bff717 	ldw	r2,-36(fp)
 8246088:	1080018b 	ldhu	r2,6(r2)
 824608c:	10bfffcc 	andi	r2,r2,65535
 8246090:	e0fff60b 	ldhu	r3,-40(fp)
 8246094:	18bfe336 	bltu	r3,r2,8246024 <ip_setmoptions+0x228>
 8246098:	00000106 	br	82460a0 <ip_setmoptions+0x2a4>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
             imo->imo_membership[i]->inm_addr
             == mreq->imr_multiaddr)
         {
            break;
 824609c:	0001883a 	nop
         }
      }
      if (i < imo->imo_num_memberships) 
 82460a0:	e0bff717 	ldw	r2,-36(fp)
 82460a4:	1080018b 	ldhu	r2,6(r2)
 82460a8:	10bfffcc 	andi	r2,r2,65535
 82460ac:	e0fff60b 	ldhu	r3,-40(fp)
 82460b0:	1880032e 	bgeu	r3,r2,82460c0 <ip_setmoptions+0x2c4>
      {
         error = EADDRINUSE;
 82460b4:	00801c04 	movi	r2,112
 82460b8:	e0bff515 	stw	r2,-44(fp)
         break;
 82460bc:	0000a306 	br	824634c <ip_setmoptions+0x550>
      }
      if (i == IP_MAX_MEMBERSHIPS) 
 82460c0:	e0bff60b 	ldhu	r2,-40(fp)
 82460c4:	10800518 	cmpnei	r2,r2,20
 82460c8:	1000031e 	bne	r2,zero,82460d8 <ip_setmoptions+0x2dc>
      {
         error = ETOOMANYREFS;
 82460cc:	00802044 	movi	r2,129
 82460d0:	e0bff515 	stw	r2,-44(fp)
         break;
 82460d4:	00009d06 	br	824634c <ip_setmoptions+0x550>
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 82460d8:	e43ff60b 	ldhu	r16,-40(fp)
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
 82460dc:	e0bffa17 	ldw	r2,-24(fp)
 82460e0:	e0fffb17 	ldw	r3,-20(fp)
 82460e4:	01800104 	movi	r6,4
 82460e8:	180b883a 	mov	r5,r3
 82460ec:	1009883a 	mov	r4,r2
 82460f0:	82437a00 	call	82437a0 <in_addmulti>
 82460f4:	1009883a 	mov	r4,r2
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 82460f8:	e0fff717 	ldw	r3,-36(fp)
 82460fc:	80800084 	addi	r2,r16,2
 8246100:	1085883a 	add	r2,r2,r2
 8246104:	1085883a 	add	r2,r2,r2
 8246108:	1885883a 	add	r2,r3,r2
 824610c:	11000015 	stw	r4,0(r2)
 8246110:	e0fff717 	ldw	r3,-36(fp)
 8246114:	80800084 	addi	r2,r16,2
 8246118:	1085883a 	add	r2,r2,r2
 824611c:	1085883a 	add	r2,r2,r2
 8246120:	1885883a 	add	r2,r3,r2
 8246124:	10800017 	ldw	r2,0(r2)
 8246128:	1000031e 	bne	r2,zero,8246138 <ip_setmoptions+0x33c>
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
      {
         error = ENOBUFS;
 824612c:	00801a44 	movi	r2,105
 8246130:	e0bff515 	stw	r2,-44(fp)
         break;
 8246134:	00008506 	br	824634c <ip_setmoptions+0x550>
      }
      ++imo->imo_num_memberships;
 8246138:	e0bff717 	ldw	r2,-36(fp)
 824613c:	1080018b 	ldhu	r2,6(r2)
 8246140:	10800044 	addi	r2,r2,1
 8246144:	1007883a 	mov	r3,r2
 8246148:	e0bff717 	ldw	r2,-36(fp)
 824614c:	10c0018d 	sth	r3,6(r2)
      break;
 8246150:	00007e06 	br	824634c <ip_setmoptions+0x550>
   case IP_DROP_MEMBERSHIP:
      /*
       * Drop a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 8246154:	e0bffe17 	ldw	r2,-8(fp)
 8246158:	e0bffa15 	stw	r2,-24(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 824615c:	e0bffa17 	ldw	r2,-24(fp)
 8246160:	10800017 	ldw	r2,0(r2)
 8246164:	1006d63a 	srli	r3,r2,24
 8246168:	e0bffa17 	ldw	r2,-24(fp)
 824616c:	10800017 	ldw	r2,0(r2)
 8246170:	1004d23a 	srli	r2,r2,8
 8246174:	10bfc00c 	andi	r2,r2,65280
 8246178:	1886b03a 	or	r3,r3,r2
 824617c:	e0bffa17 	ldw	r2,-24(fp)
 8246180:	10800017 	ldw	r2,0(r2)
 8246184:	10bfc00c 	andi	r2,r2,65280
 8246188:	1004923a 	slli	r2,r2,8
 824618c:	1886b03a 	or	r3,r3,r2
 8246190:	e0bffa17 	ldw	r2,-24(fp)
 8246194:	10800017 	ldw	r2,0(r2)
 8246198:	1004963a 	slli	r2,r2,24
 824619c:	1884b03a 	or	r2,r3,r2
 82461a0:	10fc002c 	andhi	r3,r2,61440
 82461a4:	00b80034 	movhi	r2,57344
 82461a8:	18800326 	beq	r3,r2,82461b8 <ip_setmoptions+0x3bc>
      {
         error = EINVAL;
 82461ac:	00800584 	movi	r2,22
 82461b0:	e0bff515 	stw	r2,-44(fp)
         break;
 82461b4:	00006506 	br	824634c <ip_setmoptions+0x550>
       * If an interface address was specified, get a pointer
       * to its ifnet structure. If an interface address was not
       * specified, get a pointer to the first interface that
       * supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 82461b8:	e0bffa17 	ldw	r2,-24(fp)
 82461bc:	10800117 	ldw	r2,4(r2)
 82461c0:	e0fffb04 	addi	r3,fp,-20
 82461c4:	180b883a 	mov	r5,r3
 82461c8:	1009883a 	mov	r4,r2
 82461cc:	8245cc80 	call	8245cc8 <IPADDR_TO_NETP>
      if (netp == NULL) 
 82461d0:	e0bffb17 	ldw	r2,-20(fp)
 82461d4:	1000031e 	bne	r2,zero,82461e4 <ip_setmoptions+0x3e8>
      {
         error = EADDRNOTAVAIL;
 82461d8:	00801f44 	movi	r2,125
 82461dc:	e0bff515 	stw	r2,-44(fp)
         break;
 82461e0:	00005a06 	br	824634c <ip_setmoptions+0x550>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 82461e4:	e03ff60d 	sth	zero,-40(fp)
 82461e8:	00001a06 	br	8246254 <ip_setmoptions+0x458>
      {
         if ((netp == NULL ||
 82461ec:	e0bffb17 	ldw	r2,-20(fp)
 82461f0:	10000a26 	beq	r2,zero,824621c <ip_setmoptions+0x420>
             imo->imo_membership[i]->inm_netp == netp) &&
 82461f4:	e0bff60b 	ldhu	r2,-40(fp)
 82461f8:	e0fff717 	ldw	r3,-36(fp)
 82461fc:	10800084 	addi	r2,r2,2
 8246200:	1085883a 	add	r2,r2,r2
 8246204:	1085883a 	add	r2,r2,r2
 8246208:	1885883a 	add	r2,r3,r2
 824620c:	10800017 	ldw	r2,0(r2)
 8246210:	10c00117 	ldw	r3,4(r2)
 8246214:	e0bffb17 	ldw	r2,-20(fp)
      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if ((netp == NULL ||
 8246218:	18800b1e 	bne	r3,r2,8246248 <ip_setmoptions+0x44c>
             imo->imo_membership[i]->inm_netp == netp) &&
             imo->imo_membership[i]->inm_addr ==
 824621c:	e0bff60b 	ldhu	r2,-40(fp)
 8246220:	e0fff717 	ldw	r3,-36(fp)
 8246224:	10800084 	addi	r2,r2,2
 8246228:	1085883a 	add	r2,r2,r2
 824622c:	1085883a 	add	r2,r2,r2
 8246230:	1885883a 	add	r2,r3,r2
 8246234:	10800017 	ldw	r2,0(r2)
 8246238:	10c00017 	ldw	r3,0(r2)
             mreq->imr_multiaddr)
 824623c:	e0bffa17 	ldw	r2,-24(fp)
 8246240:	10800017 	ldw	r2,0(r2)
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if ((netp == NULL ||
             imo->imo_membership[i]->inm_netp == netp) &&
 8246244:	18800926 	beq	r3,r2,824626c <ip_setmoptions+0x470>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 8246248:	e0bff60b 	ldhu	r2,-40(fp)
 824624c:	10800044 	addi	r2,r2,1
 8246250:	e0bff60d 	sth	r2,-40(fp)
 8246254:	e0bff717 	ldw	r2,-36(fp)
 8246258:	1080018b 	ldhu	r2,6(r2)
 824625c:	10bfffcc 	andi	r2,r2,65535
 8246260:	e0fff60b 	ldhu	r3,-40(fp)
 8246264:	18bfe136 	bltu	r3,r2,82461ec <ip_setmoptions+0x3f0>
 8246268:	00000106 	br	8246270 <ip_setmoptions+0x474>
         if ((netp == NULL ||
             imo->imo_membership[i]->inm_netp == netp) &&
             imo->imo_membership[i]->inm_addr ==
             mreq->imr_multiaddr)
         {
            break;
 824626c:	0001883a 	nop
         }
      }
      if (i == imo->imo_num_memberships) 
 8246270:	e0bff717 	ldw	r2,-36(fp)
 8246274:	1080018b 	ldhu	r2,6(r2)
 8246278:	10ffffcc 	andi	r3,r2,65535
 824627c:	e0bff60b 	ldhu	r2,-40(fp)
 8246280:	1880031e 	bne	r3,r2,8246290 <ip_setmoptions+0x494>
      {
         error = EADDRNOTAVAIL;
 8246284:	00801f44 	movi	r2,125
 8246288:	e0bff515 	stw	r2,-44(fp)
         break;
 824628c:	00002f06 	br	824634c <ip_setmoptions+0x550>
      }
      /*
       * Give up the multicast address record to which the
       * membership points.
       */
      in_delmulti(imo->imo_membership[i]);
 8246290:	e0bff60b 	ldhu	r2,-40(fp)
 8246294:	e0fff717 	ldw	r3,-36(fp)
 8246298:	10800084 	addi	r2,r2,2
 824629c:	1085883a 	add	r2,r2,r2
 82462a0:	1085883a 	add	r2,r2,r2
 82462a4:	1885883a 	add	r2,r3,r2
 82462a8:	10800017 	ldw	r2,0(r2)
 82462ac:	1009883a 	mov	r4,r2
 82462b0:	82438ec0 	call	82438ec <in_delmulti>
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 82462b4:	e0bff60b 	ldhu	r2,-40(fp)
 82462b8:	10800044 	addi	r2,r2,1
 82462bc:	e0bff60d 	sth	r2,-40(fp)
 82462c0:	00001206 	br	824630c <ip_setmoptions+0x510>
         imo->imo_membership[i-1] = imo->imo_membership[i];
 82462c4:	e0bff60b 	ldhu	r2,-40(fp)
 82462c8:	117fffc4 	addi	r5,r2,-1
 82462cc:	e0bff60b 	ldhu	r2,-40(fp)
 82462d0:	e0fff717 	ldw	r3,-36(fp)
 82462d4:	10800084 	addi	r2,r2,2
 82462d8:	1085883a 	add	r2,r2,r2
 82462dc:	1085883a 	add	r2,r2,r2
 82462e0:	1885883a 	add	r2,r3,r2
 82462e4:	10c00017 	ldw	r3,0(r2)
 82462e8:	e13ff717 	ldw	r4,-36(fp)
 82462ec:	28800084 	addi	r2,r5,2
 82462f0:	1085883a 	add	r2,r2,r2
 82462f4:	1085883a 	add	r2,r2,r2
 82462f8:	2085883a 	add	r2,r4,r2
 82462fc:	10c00015 	stw	r3,0(r2)
       */
      in_delmulti(imo->imo_membership[i]);
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 8246300:	e0bff60b 	ldhu	r2,-40(fp)
 8246304:	10800044 	addi	r2,r2,1
 8246308:	e0bff60d 	sth	r2,-40(fp)
 824630c:	e0bff717 	ldw	r2,-36(fp)
 8246310:	1080018b 	ldhu	r2,6(r2)
 8246314:	10bfffcc 	andi	r2,r2,65535
 8246318:	e0fff60b 	ldhu	r3,-40(fp)
 824631c:	18bfe936 	bltu	r3,r2,82462c4 <ip_setmoptions+0x4c8>
         imo->imo_membership[i-1] = imo->imo_membership[i];
      --imo->imo_num_memberships;
 8246320:	e0bff717 	ldw	r2,-36(fp)
 8246324:	1080018b 	ldhu	r2,6(r2)
 8246328:	10bfffc4 	addi	r2,r2,-1
 824632c:	1007883a 	mov	r3,r2
 8246330:	e0bff717 	ldw	r2,-36(fp)
 8246334:	10c0018d 	sth	r3,6(r2)
      break;
 8246338:	00000406 	br	824634c <ip_setmoptions+0x550>

      default:
      error = EOPNOTSUPP;
 824633c:	008017c4 	movi	r2,95
 8246340:	e0bff515 	stw	r2,-44(fp)
      break;
 8246344:	00000106 	br	824634c <ip_setmoptions+0x550>
         error = EADDRNOTAVAIL;
         break;
      }
      if (addr != AADDR) 
         imo->imo_multicast_netp = netp;
      break;
 8246348:	0001883a 	nop
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 824634c:	e0bff717 	ldw	r2,-36(fp)
 8246350:	10800017 	ldw	r2,0(r2)
 8246354:	1000141e 	bne	r2,zero,82463a8 <ip_setmoptions+0x5ac>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
 8246358:	e0bff717 	ldw	r2,-36(fp)
 824635c:	10800103 	ldbu	r2,4(r2)
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 8246360:	10803fcc 	andi	r2,r2,255
 8246364:	10800058 	cmpnei	r2,r2,1
 8246368:	10000f1e 	bne	r2,zero,82463a8 <ip_setmoptions+0x5ac>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
 824636c:	e0bff717 	ldw	r2,-36(fp)
 8246370:	10800143 	ldbu	r2,5(r2)

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
 8246374:	10803fcc 	andi	r2,r2,255
 8246378:	10800058 	cmpnei	r2,r2,1
 824637c:	10000a1e 	bne	r2,zero,82463a8 <ip_setmoptions+0x5ac>
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
       imo->imo_num_memberships == 0) 
 8246380:	e0bff717 	ldw	r2,-36(fp)
 8246384:	1080018b 	ldhu	r2,6(r2)
      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
 8246388:	10bfffcc 	andi	r2,r2,65535
 824638c:	1000061e 	bne	r2,zero,82463a8 <ip_setmoptions+0x5ac>
       imo->imo_num_memberships == 0) 
   {
      IM_FREE(*imop);
 8246390:	e0bff817 	ldw	r2,-32(fp)
 8246394:	10800017 	ldw	r2,0(r2)
 8246398:	1009883a 	mov	r4,r2
 824639c:	822e0200 	call	822e020 <npfree>
      *imop = NULL;
 82463a0:	e0bff817 	ldw	r2,-32(fp)
 82463a4:	10000015 	stw	zero,0(r2)
   }
   return (error);
 82463a8:	e0bff517 	ldw	r2,-44(fp)
}
 82463ac:	e6ffff04 	addi	sp,fp,-4
 82463b0:	dfc00217 	ldw	ra,8(sp)
 82463b4:	df000117 	ldw	fp,4(sp)
 82463b8:	dc000017 	ldw	r16,0(sp)
 82463bc:	dec00304 	addi	sp,sp,12
 82463c0:	f800283a 	ret

082463c4 <ip_getmoptions>:
 * RETURNS: 
 */

int
ip_getmoptions(int optname, struct socket * so, void * val)
{
 82463c4:	defff804 	addi	sp,sp,-32
 82463c8:	df000715 	stw	fp,28(sp)
 82463cc:	df000704 	addi	fp,sp,28
 82463d0:	e13ffd15 	stw	r4,-12(fp)
 82463d4:	e17ffe15 	stw	r5,-8(fp)
 82463d8:	e1bfff15 	stw	r6,-4(fp)
   u_char * ttl;
   u_char * loop;
   ip_addr *addr;
   struct ip_moptions*  imo   =  so->inp_moptions;
 82463dc:	e0bffe17 	ldw	r2,-8(fp)
 82463e0:	10800317 	ldw	r2,12(r2)
 82463e4:	e0bff915 	stw	r2,-28(fp)
   /* The following code will be commented out for Iniche stack.
    * Don't allocate a buffer here.
    *
    *        *mp = m_get(M_WAIT, MT_SOOPTS);
    */
   switch (optname) 
 82463e8:	e0bffd17 	ldw	r2,-12(fp)
 82463ec:	10c002a0 	cmpeqi	r3,r2,10
 82463f0:	1800151e 	bne	r3,zero,8246448 <ip_getmoptions+0x84>
 82463f4:	10c002e0 	cmpeqi	r3,r2,11
 82463f8:	1800211e 	bne	r3,zero,8246480 <ip_getmoptions+0xbc>
 82463fc:	10800260 	cmpeqi	r2,r2,9
 8246400:	10002d26 	beq	r2,zero,82464b8 <ip_getmoptions+0xf4>
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
 8246404:	e0bfff17 	ldw	r2,-4(fp)
 8246408:	e0bffa15 	stw	r2,-24(fp)
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 824640c:	e0bff917 	ldw	r2,-28(fp)
 8246410:	10000326 	beq	r2,zero,8246420 <ip_getmoptions+0x5c>
 8246414:	e0bff917 	ldw	r2,-28(fp)
 8246418:	10800017 	ldw	r2,0(r2)
 824641c:	1000031e 	bne	r2,zero,824642c <ip_getmoptions+0x68>
         *addr = AADDR;
 8246420:	e0bffa17 	ldw	r2,-24(fp)
 8246424:	10000015 	stw	zero,0(r2)
 8246428:	00000506 	br	8246440 <ip_getmoptions+0x7c>
      else
         *addr = imo->imo_multicast_netp->n_ipaddr;
 824642c:	e0bff917 	ldw	r2,-28(fp)
 8246430:	10800017 	ldw	r2,0(r2)
 8246434:	10c00a17 	ldw	r3,40(r2)
 8246438:	e0bffa17 	ldw	r2,-24(fp)
 824643c:	10c00015 	stw	r3,0(r2)
      return (0);
 8246440:	0005883a 	mov	r2,zero
 8246444:	00001d06 	br	82464bc <ip_getmoptions+0xf8>

   case IP_MULTICAST_TTL:
      ttl = (u_char *)val;
 8246448:	e0bfff17 	ldw	r2,-4(fp)
 824644c:	e0bffb15 	stw	r2,-20(fp)
      if (imo == NULL)
 8246450:	e0bff917 	ldw	r2,-28(fp)
 8246454:	1000041e 	bne	r2,zero,8246468 <ip_getmoptions+0xa4>
         *ttl = IP_DEFAULT_MULTICAST_TTL;
 8246458:	e0bffb17 	ldw	r2,-20(fp)
 824645c:	00c00044 	movi	r3,1
 8246460:	10c00005 	stb	r3,0(r2)
 8246464:	00000406 	br	8246478 <ip_getmoptions+0xb4>
      else
         *ttl = imo->imo_multicast_ttl;
 8246468:	e0bff917 	ldw	r2,-28(fp)
 824646c:	10c00103 	ldbu	r3,4(r2)
 8246470:	e0bffb17 	ldw	r2,-20(fp)
 8246474:	10c00005 	stb	r3,0(r2)
      return (0);
 8246478:	0005883a 	mov	r2,zero
 824647c:	00000f06 	br	82464bc <ip_getmoptions+0xf8>

   case IP_MULTICAST_LOOP:
      loop = (u_char *)val;
 8246480:	e0bfff17 	ldw	r2,-4(fp)
 8246484:	e0bffc15 	stw	r2,-16(fp)
      if (imo == NULL)
 8246488:	e0bff917 	ldw	r2,-28(fp)
 824648c:	1000041e 	bne	r2,zero,82464a0 <ip_getmoptions+0xdc>
         *loop = IP_DEFAULT_MULTICAST_LOOP;
 8246490:	e0bffc17 	ldw	r2,-16(fp)
 8246494:	00c00044 	movi	r3,1
 8246498:	10c00005 	stb	r3,0(r2)
 824649c:	00000406 	br	82464b0 <ip_getmoptions+0xec>
      else
         *loop = imo->imo_multicast_loop;
 82464a0:	e0bff917 	ldw	r2,-28(fp)
 82464a4:	10c00143 	ldbu	r3,5(r2)
 82464a8:	e0bffc17 	ldw	r2,-16(fp)
 82464ac:	10c00005 	stb	r3,0(r2)
      return (0);
 82464b0:	0005883a 	mov	r2,zero
 82464b4:	00000106 	br	82464bc <ip_getmoptions+0xf8>

      default:
      return (EOPNOTSUPP);
 82464b8:	008017c4 	movi	r2,95
   }
}
 82464bc:	e037883a 	mov	sp,fp
 82464c0:	df000017 	ldw	fp,0(sp)
 82464c4:	dec00104 	addi	sp,sp,4
 82464c8:	f800283a 	ret

082464cc <ip_freemoptions>:
 * RETURNS: 
 */

void
ip_freemoptions(struct ip_moptions * imo)
{
 82464cc:	defffc04 	addi	sp,sp,-16
 82464d0:	dfc00315 	stw	ra,12(sp)
 82464d4:	df000215 	stw	fp,8(sp)
 82464d8:	df000204 	addi	fp,sp,8
 82464dc:	e13fff15 	stw	r4,-4(fp)
   u_short  i;

   if (imo != NULL) 
 82464e0:	e0bfff17 	ldw	r2,-4(fp)
 82464e4:	10001526 	beq	r2,zero,824653c <ip_freemoptions+0x70>
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 82464e8:	e03ffe0d 	sth	zero,-8(fp)
 82464ec:	00000c06 	br	8246520 <ip_freemoptions+0x54>
         in_delmulti(imo->imo_membership[i]);
 82464f0:	e0bffe0b 	ldhu	r2,-8(fp)
 82464f4:	e0ffff17 	ldw	r3,-4(fp)
 82464f8:	10800084 	addi	r2,r2,2
 82464fc:	1085883a 	add	r2,r2,r2
 8246500:	1085883a 	add	r2,r2,r2
 8246504:	1885883a 	add	r2,r3,r2
 8246508:	10800017 	ldw	r2,0(r2)
 824650c:	1009883a 	mov	r4,r2
 8246510:	82438ec0 	call	82438ec <in_delmulti>
{
   u_short  i;

   if (imo != NULL) 
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 8246514:	e0bffe0b 	ldhu	r2,-8(fp)
 8246518:	10800044 	addi	r2,r2,1
 824651c:	e0bffe0d 	sth	r2,-8(fp)
 8246520:	e0bfff17 	ldw	r2,-4(fp)
 8246524:	1080018b 	ldhu	r2,6(r2)
 8246528:	10bfffcc 	andi	r2,r2,65535
 824652c:	e0fffe0b 	ldhu	r3,-8(fp)
 8246530:	18bfef36 	bltu	r3,r2,82464f0 <ip_freemoptions+0x24>
         in_delmulti(imo->imo_membership[i]);
      npfree(imo);
 8246534:	e13fff17 	ldw	r4,-4(fp)
 8246538:	822e0200 	call	822e020 <npfree>
   }
}
 824653c:	0001883a 	nop
 8246540:	e037883a 	mov	sp,fp
 8246544:	dfc00117 	ldw	ra,4(sp)
 8246548:	df000017 	ldw	fp,0(sp)
 824654c:	dec00204 	addi	sp,sp,8
 8246550:	f800283a 	ret

08246554 <u_mctest_init>:
 *
 * RETURNS: 
 */

void u_mctest_init()
{
 8246554:	defffe04 	addi	sp,sp,-8
 8246558:	dfc00115 	stw	ra,4(sp)
 824655c:	df000015 	stw	fp,0(sp)
 8246560:	d839883a 	mov	fp,sp
   printf("mctest init called\n");
 8246564:	01020974 	movhi	r4,2085
 8246568:	2105d904 	addi	r4,r4,5988
 824656c:	82035a00 	call	82035a0 <puts>
// altera changes end (cadler@altera.com)
   install_menu(u_mctest_menu);
// altera changes begin (cadler@altera.com)
#endif //IN_MENUS
// altera changes end (cadler@altera.com)
}
 8246570:	0001883a 	nop
 8246574:	e037883a 	mov	sp,fp
 8246578:	dfc00117 	ldw	ra,4(sp)
 824657c:	df000017 	ldw	fp,0(sp)
 8246580:	dec00204 	addi	sp,sp,8
 8246584:	f800283a 	ret

08246588 <u_mctest_run>:
 *
 * RETURNS: 
 */

int u_mctest_run(void * pio)
{
 8246588:	defede04 	addi	sp,sp,-1160
 824658c:	dfc12115 	stw	ra,1156(sp)
 8246590:	df012015 	stw	fp,1152(sp)
 8246594:	df012004 	addi	fp,sp,1152
 8246598:	e13fff15 	stw	r4,-4(fp)
    struct sockaddr_in   stLocal, stTo, stFrom;
    char  achIn[BUFSIZE];
    char  achOut[] = "Message number:              ";
 824659c:	009cdcf4 	movhi	r2,29555
 82465a0:	10995344 	addi	r2,r2,25933
 82465a4:	e0bff215 	stw	r2,-56(fp)
 82465a8:	00881974 	movhi	r2,8293
 82465ac:	1099d844 	addi	r2,r2,26465
 82465b0:	e0bff315 	stw	r2,-52(fp)
 82465b4:	00989b74 	movhi	r2,25197
 82465b8:	109d5b84 	addi	r2,r2,30062
 82465bc:	e0bff415 	stw	r2,-48(fp)
 82465c0:	00880eb4 	movhi	r2,8250
 82465c4:	109c9944 	addi	r2,r2,29285
 82465c8:	e0bff515 	stw	r2,-44(fp)
 82465cc:	00880834 	movhi	r2,8224
 82465d0:	10880804 	addi	r2,r2,8224
 82465d4:	e0bff615 	stw	r2,-40(fp)
 82465d8:	00880834 	movhi	r2,8224
 82465dc:	10880804 	addi	r2,r2,8224
 82465e0:	e0bff715 	stw	r2,-36(fp)
 82465e4:	00880834 	movhi	r2,8224
 82465e8:	10880804 	addi	r2,r2,8224
 82465ec:	e0bff815 	stw	r2,-32(fp)
 82465f0:	00800804 	movi	r2,32
 82465f4:	e0bff90d 	sth	r2,-28(fp)
    struct ip_mreq stMreq;
    u_char cTmp;
    unsigned long endtime;

   /* get a datagram socket */
   s = t_socket(AF_INET,SOCK_DGRAM, 0);
 82465f8:	000d883a 	mov	r6,zero
 82465fc:	01400084 	movi	r5,2
 8246600:	01000084 	movi	r4,2
 8246604:	82302b00 	call	82302b0 <t_socket>
 8246608:	e0bee315 	stw	r2,-1140(fp)

   if (s == INVALID_SOCKET) 
 824660c:	e0bee317 	ldw	r2,-1140(fp)
 8246610:	10bfffd8 	cmpnei	r2,r2,-1
 8246614:	1000091e 	bne	r2,zero,824663c <u_mctest_run+0xb4>
   {
      ns_printf (pio,"t_socket() failed, Err: %d\n", t_errno(s));
 8246618:	e13ee317 	ldw	r4,-1140(fp)
 824661c:	823181c0 	call	823181c <t_errno>
 8246620:	100d883a 	mov	r6,r2
 8246624:	01420974 	movhi	r5,2085
 8246628:	2945de04 	addi	r5,r5,6008
 824662c:	e13fff17 	ldw	r4,-4(fp)
 8246630:	8228d040 	call	8228d04 <ns_printf>
      exit(1);
 8246634:	01000044 	movi	r4,1
 8246638:	824b4a80 	call	824b4a8 <exit>
   }

   /* avoid EADDRINUSE error on bind() */ 
   iTmp = 1;
 824663c:	00800044 	movi	r2,1
 8246640:	e0bffa15 	stw	r2,-24(fp)
   iRet = t_setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&iTmp, sizeof(iTmp));
 8246644:	e0fffa04 	addi	r3,fp,-24
 8246648:	00800104 	movi	r2,4
 824664c:	d8800015 	stw	r2,0(sp)
 8246650:	180f883a 	mov	r7,r3
 8246654:	01800104 	movi	r6,4
 8246658:	017fffc4 	movi	r5,-1
 824665c:	e13ee317 	ldw	r4,-1140(fp)
 8246660:	8230c900 	call	8230c90 <t_setsockopt>
 8246664:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246668:	e0bee417 	ldw	r2,-1136(fp)
 824666c:	10bfffd8 	cmpnei	r2,r2,-1
 8246670:	1000071e 	bne	r2,zero,8246690 <u_mctest_run+0x108>
   {
      ns_printf (pio,"t_setsockopt() SO_REUSEADDR failed, Err: %d\n",
 8246674:	e13ee317 	ldw	r4,-1140(fp)
 8246678:	823181c0 	call	823181c <t_errno>
 824667c:	100d883a 	mov	r6,r2
 8246680:	01420974 	movhi	r5,2085
 8246684:	2945e504 	addi	r5,r5,6036
 8246688:	e13fff17 	ldw	r4,-4(fp)
 824668c:	8228d040 	call	8228d04 <ns_printf>
       t_errno(s));
   }

   /* name the socket */
   stLocal.sin_family =   AF_INET;
 8246690:	00800084 	movi	r2,2
 8246694:	e0bee60d 	sth	r2,-1128(fp)
   stLocal.sin_addr.s_addr = htonl(INADDR_ANY);
 8246698:	e03ee715 	stw	zero,-1124(fp)
   stLocal.sin_port =   htons(TEST_PORT);
 824669c:	00a00344 	movi	r2,-32755
 82466a0:	e0bee68d 	sth	r2,-1126(fp)
   iRet = t_bind(s, (struct sockaddr*) &stLocal, sizeof(struct sockaddr_in));
 82466a4:	e0bee604 	addi	r2,fp,-1128
 82466a8:	01800404 	movi	r6,16
 82466ac:	100b883a 	mov	r5,r2
 82466b0:	e13ee317 	ldw	r4,-1140(fp)
 82466b4:	82303300 	call	8230330 <t_bind>
 82466b8:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 82466bc:	e0bee417 	ldw	r2,-1136(fp)
 82466c0:	10bfffd8 	cmpnei	r2,r2,-1
 82466c4:	1000061e 	bne	r2,zero,82466e0 <u_mctest_run+0x158>
   {
      printf ("t_bind() failed, Err: %d\n",
 82466c8:	e13ee317 	ldw	r4,-1140(fp)
 82466cc:	823181c0 	call	823181c <t_errno>
 82466d0:	100b883a 	mov	r5,r2
 82466d4:	01020974 	movhi	r4,2085
 82466d8:	2105f104 	addi	r4,r4,6084
 82466dc:	820331c0 	call	820331c <printf>
       t_errno(s));
   }

   /* join the multicast group. TEST_ADDR */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR);
 82466e0:	01820974 	movhi	r6,2085
 82466e4:	3185f804 	addi	r6,r6,6112
 82466e8:	01420974 	movhi	r5,2085
 82466ec:	2945fb04 	addi	r5,r5,6124
 82466f0:	e13fff17 	ldw	r4,-4(fp)
 82466f4:	8228d040 	call	8228d04 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 82466f8:	01020974 	movhi	r4,2085
 82466fc:	2105f804 	addi	r4,r4,6112
 8246700:	82476640 	call	8247664 <inet_addr>
 8246704:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 8246708:	008209b4 	movhi	r2,2086
 824670c:	10b76404 	addi	r2,r2,-8816
 8246710:	10800a17 	ldw	r2,40(r2)
 8246714:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP,
 8246718:	e0fffb04 	addi	r3,fp,-20
 824671c:	00800204 	movi	r2,8
 8246720:	d8800015 	stw	r2,0(sp)
 8246724:	180f883a 	mov	r7,r3
 8246728:	01800304 	movi	r6,12
 824672c:	000b883a 	mov	r5,zero
 8246730:	e13ee317 	ldw	r4,-1140(fp)
 8246734:	8230c900 	call	8230c90 <t_setsockopt>
 8246738:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 824673c:	e0bee417 	ldw	r2,-1136(fp)
 8246740:	10bfffd8 	cmpnei	r2,r2,-1
 8246744:	1000071e 	bne	r2,zero,8246764 <u_mctest_run+0x1dc>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 8246748:	e13ee317 	ldw	r4,-1140(fp)
 824674c:	823181c0 	call	823181c <t_errno>
 8246750:	100d883a 	mov	r6,r2
 8246754:	01420974 	movhi	r5,2085
 8246758:	29460304 	addi	r5,r5,6156
 824675c:	e13fff17 	ldw	r4,-4(fp)
 8246760:	8228d040 	call	8228d04 <ns_printf>
                     t_errno(s));
   } 
   tk_yield();
 8246764:	82296b00 	call	82296b0 <tk_yield>

   /* join the multicast group. TEST_ADDR1 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR1);
 8246768:	01820974 	movhi	r6,2085
 824676c:	31861004 	addi	r6,r6,6208
 8246770:	01420974 	movhi	r5,2085
 8246774:	2945fb04 	addi	r5,r5,6124
 8246778:	e13fff17 	ldw	r4,-4(fp)
 824677c:	8228d040 	call	8228d04 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR1);
 8246780:	01020974 	movhi	r4,2085
 8246784:	21061004 	addi	r4,r4,6208
 8246788:	82476640 	call	8247664 <inet_addr>
 824678c:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 8246790:	008209b4 	movhi	r2,2086
 8246794:	10b76404 	addi	r2,r2,-8816
 8246798:	10800a17 	ldw	r2,40(r2)
 824679c:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 82467a0:	e0fffb04 	addi	r3,fp,-20
 82467a4:	00800204 	movi	r2,8
 82467a8:	d8800015 	stw	r2,0(sp)
 82467ac:	180f883a 	mov	r7,r3
 82467b0:	01800304 	movi	r6,12
 82467b4:	000b883a 	mov	r5,zero
 82467b8:	e13ee317 	ldw	r4,-1140(fp)
 82467bc:	8230c900 	call	8230c90 <t_setsockopt>
 82467c0:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 82467c4:	e0bee417 	ldw	r2,-1136(fp)
 82467c8:	10bfffd8 	cmpnei	r2,r2,-1
 82467cc:	1000071e 	bne	r2,zero,82467ec <u_mctest_run+0x264>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 82467d0:	e13ee317 	ldw	r4,-1140(fp)
 82467d4:	823181c0 	call	823181c <t_errno>
 82467d8:	100d883a 	mov	r6,r2
 82467dc:	01420974 	movhi	r5,2085
 82467e0:	29460304 	addi	r5,r5,6156
 82467e4:	e13fff17 	ldw	r4,-4(fp)
 82467e8:	8228d040 	call	8228d04 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 82467ec:	82296b00 	call	82296b0 <tk_yield>

   /* join the multicast group. TEST_ADDR2 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR2);
 82467f0:	01820974 	movhi	r6,2085
 82467f4:	31861304 	addi	r6,r6,6220
 82467f8:	01420974 	movhi	r5,2085
 82467fc:	2945fb04 	addi	r5,r5,6124
 8246800:	e13fff17 	ldw	r4,-4(fp)
 8246804:	8228d040 	call	8228d04 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR2);
 8246808:	01020974 	movhi	r4,2085
 824680c:	21061304 	addi	r4,r4,6220
 8246810:	82476640 	call	8247664 <inet_addr>
 8246814:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 8246818:	008209b4 	movhi	r2,2086
 824681c:	10b76404 	addi	r2,r2,-8816
 8246820:	10800a17 	ldw	r2,40(r2)
 8246824:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 8246828:	e0fffb04 	addi	r3,fp,-20
 824682c:	00800204 	movi	r2,8
 8246830:	d8800015 	stw	r2,0(sp)
 8246834:	180f883a 	mov	r7,r3
 8246838:	01800304 	movi	r6,12
 824683c:	000b883a 	mov	r5,zero
 8246840:	e13ee317 	ldw	r4,-1140(fp)
 8246844:	8230c900 	call	8230c90 <t_setsockopt>
 8246848:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 824684c:	e0bee417 	ldw	r2,-1136(fp)
 8246850:	10bfffd8 	cmpnei	r2,r2,-1
 8246854:	1000071e 	bne	r2,zero,8246874 <u_mctest_run+0x2ec>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 8246858:	e13ee317 	ldw	r4,-1140(fp)
 824685c:	823181c0 	call	823181c <t_errno>
 8246860:	100d883a 	mov	r6,r2
 8246864:	01420974 	movhi	r5,2085
 8246868:	29460304 	addi	r5,r5,6156
 824686c:	e13fff17 	ldw	r4,-4(fp)
 8246870:	8228d040 	call	8228d04 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 8246874:	82296b00 	call	82296b0 <tk_yield>

   /* set TTL to traverse up to multiple routers */
   cTmp = TTL_VALUE;
 8246878:	00800084 	movi	r2,2
 824687c:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, (char *)&cTmp, sizeof(cTmp));
 8246880:	e0fffd04 	addi	r3,fp,-12
 8246884:	00800044 	movi	r2,1
 8246888:	d8800015 	stw	r2,0(sp)
 824688c:	180f883a 	mov	r7,r3
 8246890:	01800284 	movi	r6,10
 8246894:	000b883a 	mov	r5,zero
 8246898:	e13ee317 	ldw	r4,-1140(fp)
 824689c:	8230c900 	call	8230c90 <t_setsockopt>
 82468a0:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 82468a4:	e0bee417 	ldw	r2,-1136(fp)
 82468a8:	10bfffd8 	cmpnei	r2,r2,-1
 82468ac:	1000071e 	bne	r2,zero,82468cc <u_mctest_run+0x344>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_TTL failed, Err: %d\n",
 82468b0:	e13ee317 	ldw	r4,-1140(fp)
 82468b4:	823181c0 	call	823181c <t_errno>
 82468b8:	100d883a 	mov	r6,r2
 82468bc:	01420974 	movhi	r5,2085
 82468c0:	29461604 	addi	r5,r5,6232
 82468c4:	e13fff17 	ldw	r4,-4(fp)
 82468c8:	8228d040 	call	8228d04 <ns_printf>
                     t_errno(s));
   }

   /* enable loopback */
   cTmp = 1;
 82468cc:	00800044 	movi	r2,1
 82468d0:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, (char *)&cTmp, sizeof(cTmp));
 82468d4:	e0fffd04 	addi	r3,fp,-12
 82468d8:	00800044 	movi	r2,1
 82468dc:	d8800015 	stw	r2,0(sp)
 82468e0:	180f883a 	mov	r7,r3
 82468e4:	018002c4 	movi	r6,11
 82468e8:	000b883a 	mov	r5,zero
 82468ec:	e13ee317 	ldw	r4,-1140(fp)
 82468f0:	8230c900 	call	8230c90 <t_setsockopt>
 82468f4:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 82468f8:	e0bee417 	ldw	r2,-1136(fp)
 82468fc:	10bfffd8 	cmpnei	r2,r2,-1
 8246900:	1000071e 	bne	r2,zero,8246920 <u_mctest_run+0x398>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_LOOP failed, Err: %d\n",
 8246904:	e13ee317 	ldw	r4,-1140(fp)
 8246908:	823181c0 	call	823181c <t_errno>
 824690c:	100d883a 	mov	r6,r2
 8246910:	01420974 	movhi	r5,2085
 8246914:	29462304 	addi	r5,r5,6284
 8246918:	e13fff17 	ldw	r4,-4(fp)
 824691c:	8228d040 	call	8228d04 <ns_printf>
                     t_errno(s));
   }

   /* assign our destination address */
   stTo.sin_family =      AF_INET;
 8246920:	00800084 	movi	r2,2
 8246924:	e0beea0d 	sth	r2,-1112(fp)
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
 8246928:	01020974 	movhi	r4,2085
 824692c:	21061004 	addi	r4,r4,6208
 8246930:	82476640 	call	8247664 <inet_addr>
 8246934:	e0beeb15 	stw	r2,-1108(fp)
   stTo.sin_port =        htons(TEST_PORT);
 8246938:	00a00344 	movi	r2,-32755
 824693c:	e0beea8d 	sth	r2,-1110(fp)
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
 8246940:	01820974 	movhi	r6,2085
 8246944:	31861004 	addi	r6,r6,6208
 8246948:	01420974 	movhi	r5,2085
 824694c:	29463004 	addi	r5,r5,6336
 8246950:	e13fff17 	ldw	r4,-4(fp)
 8246954:	8228d040 	call	8228d04 <ns_printf>
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 8246958:	e03ee215 	stw	zero,-1144(fp)
 824695c:	00008606 	br	8246b78 <u_mctest_run+0x5f0>
   {
      static int iCounter = 1;

      /* send to the multicast address */
      sprintf(&achOut[16], "%d", iCounter++);
 8246960:	d0a05217 	ldw	r2,-32440(gp)
 8246964:	10c00044 	addi	r3,r2,1
 8246968:	d0e05215 	stw	r3,-32440(gp)
 824696c:	e0fff204 	addi	r3,fp,-56
 8246970:	18c00404 	addi	r3,r3,16
 8246974:	100d883a 	mov	r6,r2
 8246978:	01420974 	movhi	r5,2085
 824697c:	29463f04 	addi	r5,r5,6396
 8246980:	1809883a 	mov	r4,r3
 8246984:	82036940 	call	8203694 <sprintf>
      iRet = t_sendto(s, achOut, sizeof(achOut), 0, (struct sockaddr*)&stTo,
 8246988:	e0fff204 	addi	r3,fp,-56
 824698c:	00800404 	movi	r2,16
 8246990:	d8800115 	stw	r2,4(sp)
 8246994:	e0beea04 	addi	r2,fp,-1112
 8246998:	d8800015 	stw	r2,0(sp)
 824699c:	000f883a 	mov	r7,zero
 82469a0:	01800784 	movi	r6,30
 82469a4:	180b883a 	mov	r5,r3
 82469a8:	e13ee317 	ldw	r4,-1140(fp)
 82469ac:	82311fc0 	call	82311fc <t_sendto>
 82469b0:	e0bee415 	stw	r2,-1136(fp)
                      sizeof(struct sockaddr_in));
      if (iRet < 0) 
 82469b4:	e0bee417 	ldw	r2,-1136(fp)
 82469b8:	1000080e 	bge	r2,zero,82469dc <u_mctest_run+0x454>
      {
         /*      perror("sendto() failed\n"); */
         ns_printf (pio,"t_sendto() failed, Error: %d\n", t_errno(s));
 82469bc:	e13ee317 	ldw	r4,-1140(fp)
 82469c0:	823181c0 	call	823181c <t_errno>
 82469c4:	100d883a 	mov	r6,r2
 82469c8:	01420974 	movhi	r5,2085
 82469cc:	29464004 	addi	r5,r5,6400
 82469d0:	e13fff17 	ldw	r4,-4(fp)
 82469d4:	8228d040 	call	8228d04 <ns_printf>
         /*     exit(1); */
         goto exitloop;
 82469d8:	00006a06 	br	8246b84 <u_mctest_run+0x5fc>
      }

      /* make the socket non-blocking */
      iTmp = 1;
 82469dc:	00800044 	movi	r2,1
 82469e0:	e0bffa15 	stw	r2,-24(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&iTmp, sizeof(iTmp));
 82469e4:	e0fffa04 	addi	r3,fp,-24
 82469e8:	00800104 	movi	r2,4
 82469ec:	d8800015 	stw	r2,0(sp)
 82469f0:	180f883a 	mov	r7,r3
 82469f4:	01840584 	movi	r6,4118
 82469f8:	017fffc4 	movi	r5,-1
 82469fc:	e13ee317 	ldw	r4,-1140(fp)
 8246a00:	8230c900 	call	8230c90 <t_setsockopt>
 8246a04:	e0bee415 	stw	r2,-1136(fp)
      if (iRet == SOCKET_ERROR) 
 8246a08:	e0bee417 	ldw	r2,-1136(fp)
 8246a0c:	10bfffd8 	cmpnei	r2,r2,-1
 8246a10:	1000071e 	bne	r2,zero,8246a30 <u_mctest_run+0x4a8>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (1) failed, Err: %d\n",
 8246a14:	e13ee317 	ldw	r4,-1140(fp)
 8246a18:	823181c0 	call	823181c <t_errno>
 8246a1c:	100d883a 	mov	r6,r2
 8246a20:	01420974 	movhi	r5,2085
 8246a24:	29464804 	addi	r5,r5,6432
 8246a28:	e13fff17 	ldw	r4,-4(fp)
 8246a2c:	8228d040 	call	8228d04 <ns_printf>
                        t_errno(s));
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);
 8246a30:	d0a0a817 	ldw	r2,-32096(gp)
 8246a34:	10807d04 	addi	r2,r2,500
 8246a38:	e0bee515 	stw	r2,-1132(fp)

      while (cticks < endtime)
 8246a3c:	00003406 	br	8246b10 <u_mctest_run+0x588>
      {
         int sa_size = sizeof(struct sockaddr_in);
 8246a40:	00800404 	movi	r2,16
 8246a44:	e0bffe15 	stw	r2,-8(fp)
         tk_yield();
 8246a48:	82296b00 	call	82296b0 <tk_yield>

         iRet = t_recvfrom(s, achIn, BUFSIZE, 0, (struct sockaddr*)&stFrom, &sa_size);
 8246a4c:	e0fef204 	addi	r3,fp,-1080
 8246a50:	e0bffe04 	addi	r2,fp,-8
 8246a54:	d8800115 	stw	r2,4(sp)
 8246a58:	e0beee04 	addi	r2,fp,-1096
 8246a5c:	d8800015 	stw	r2,0(sp)
 8246a60:	000f883a 	mov	r7,zero
 8246a64:	01810004 	movi	r6,1024
 8246a68:	180b883a 	mov	r5,r3
 8246a6c:	e13ee317 	ldw	r4,-1140(fp)
 8246a70:	82310bc0 	call	82310bc <t_recvfrom>
 8246a74:	e0bee415 	stw	r2,-1136(fp)
         if (iRet < 0) 
 8246a78:	e0bee417 	ldw	r2,-1136(fp)
 8246a7c:	10000c0e 	bge	r2,zero,8246ab0 <u_mctest_run+0x528>
         {
            if (t_errno(s) != EWOULDBLOCK)
 8246a80:	e13ee317 	ldw	r4,-1140(fp)
 8246a84:	823181c0 	call	823181c <t_errno>
 8246a88:	108002e0 	cmpeqi	r2,r2,11
 8246a8c:	1000081e 	bne	r2,zero,8246ab0 <u_mctest_run+0x528>
            {
               /*      perror("recvfrom() failed\n"); */
               ns_printf (pio,"t_recvfrom() failed, Error: %d\n", t_errno(s));
 8246a90:	e13ee317 	ldw	r4,-1140(fp)
 8246a94:	823181c0 	call	823181c <t_errno>
 8246a98:	100d883a 	mov	r6,r2
 8246a9c:	01420974 	movhi	r5,2085
 8246aa0:	29465404 	addi	r5,r5,6480
 8246aa4:	e13fff17 	ldw	r4,-4(fp)
 8246aa8:	8228d040 	call	8228d04 <ns_printf>
 8246aac:	00003506 	br	8246b84 <u_mctest_run+0x5fc>
               /*     exit(1); */
               goto exitloop;
            }
         }
         if (iRet > 0)
 8246ab0:	e0bee417 	ldw	r2,-1136(fp)
 8246ab4:	0080160e 	bge	zero,r2,8246b10 <u_mctest_run+0x588>
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 8246ab8:	e0beef17 	ldw	r2,-1092(fp)
 8246abc:	1009883a 	mov	r4,r2
 8246ac0:	82289300 	call	8228930 <print_ipad>
 8246ac4:	1009883a 	mov	r4,r2
             print_ipad(stFrom.sin_addr.s_addr),
             ntohs(stFrom.sin_port), achIn);
 8246ac8:	e0beee8b 	ldhu	r2,-1094(fp)
 8246acc:	10bfffcc 	andi	r2,r2,65535
 8246ad0:	1004d23a 	srli	r2,r2,8
 8246ad4:	10bfffcc 	andi	r2,r2,65535
 8246ad8:	10c03fcc 	andi	r3,r2,255
 8246adc:	e0beee8b 	ldhu	r2,-1094(fp)
 8246ae0:	10bfffcc 	andi	r2,r2,65535
 8246ae4:	1004923a 	slli	r2,r2,8
 8246ae8:	10bfffcc 	andi	r2,r2,65535
               goto exitloop;
            }
         }
         if (iRet > 0)
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 8246aec:	1886b03a 	or	r3,r3,r2
 8246af0:	e0bef204 	addi	r2,fp,-1080
 8246af4:	d8800015 	stw	r2,0(sp)
 8246af8:	180f883a 	mov	r7,r3
 8246afc:	200d883a 	mov	r6,r4
 8246b00:	01420974 	movhi	r5,2085
 8246b04:	29465c04 	addi	r5,r5,6512
 8246b08:	e13fff17 	ldw	r4,-4(fp)
 8246b0c:	8228d040 	call	8228d04 <ns_printf>
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);

      while (cticks < endtime)
 8246b10:	d0e0a817 	ldw	r3,-32096(gp)
 8246b14:	e0bee517 	ldw	r2,-1132(fp)
 8246b18:	18bfc936 	bltu	r3,r2,8246a40 <u_mctest_run+0x4b8>
             ntohs(stFrom.sin_port), achIn);
         }
      }   /* end while (cticks...) */

      /* make the socket blocking */
      cTmp = 0;
 8246b1c:	e03ffd05 	stb	zero,-12(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&cTmp, sizeof(cTmp));
 8246b20:	e0fffd04 	addi	r3,fp,-12
 8246b24:	00800044 	movi	r2,1
 8246b28:	d8800015 	stw	r2,0(sp)
 8246b2c:	180f883a 	mov	r7,r3
 8246b30:	01840584 	movi	r6,4118
 8246b34:	017fffc4 	movi	r5,-1
 8246b38:	e13ee317 	ldw	r4,-1140(fp)
 8246b3c:	8230c900 	call	8230c90 <t_setsockopt>
 8246b40:	e0bee415 	stw	r2,-1136(fp)
      if (iRet == SOCKET_ERROR) 
 8246b44:	e0bee417 	ldw	r2,-1136(fp)
 8246b48:	10bfffd8 	cmpnei	r2,r2,-1
 8246b4c:	1000071e 	bne	r2,zero,8246b6c <u_mctest_run+0x5e4>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (0) failed, Err: %d\n",
 8246b50:	e13ee317 	ldw	r4,-1140(fp)
 8246b54:	823181c0 	call	823181c <t_errno>
 8246b58:	100d883a 	mov	r6,r2
 8246b5c:	01420974 	movhi	r5,2085
 8246b60:	29466304 	addi	r5,r5,6540
 8246b64:	e13fff17 	ldw	r4,-4(fp)
 8246b68:	8228d040 	call	8228d04 <ns_printf>
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
   stTo.sin_port =        htons(TEST_PORT);
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 8246b6c:	e0bee217 	ldw	r2,-1144(fp)
 8246b70:	10800044 	addi	r2,r2,1
 8246b74:	e0bee215 	stw	r2,-1144(fp)
 8246b78:	e0bee217 	ldw	r2,-1144(fp)
 8246b7c:	108000d0 	cmplti	r2,r2,3
 8246b80:	103f771e 	bne	r2,zero,8246960 <u_mctest_run+0x3d8>
      }
   }   /* end for(;;) */

exitloop:
   /* delete the multicast group. */
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 8246b84:	01020974 	movhi	r4,2085
 8246b88:	2105f804 	addi	r4,r4,6112
 8246b8c:	82476640 	call	8247664 <inet_addr>
 8246b90:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 8246b94:	008209b4 	movhi	r2,2086
 8246b98:	10b76404 	addi	r2,r2,-8816
 8246b9c:	10800a17 	ldw	r2,40(r2)
 8246ba0:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char *)&stMreq, sizeof(stMreq));
 8246ba4:	e0fffb04 	addi	r3,fp,-20
 8246ba8:	00800204 	movi	r2,8
 8246bac:	d8800015 	stw	r2,0(sp)
 8246bb0:	180f883a 	mov	r7,r3
 8246bb4:	01800344 	movi	r6,13
 8246bb8:	000b883a 	mov	r5,zero
 8246bbc:	e13ee317 	ldw	r4,-1140(fp)
 8246bc0:	8230c900 	call	8230c90 <t_setsockopt>
 8246bc4:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246bc8:	e0bee417 	ldw	r2,-1136(fp)
 8246bcc:	10bfffd8 	cmpnei	r2,r2,-1
 8246bd0:	1000071e 	bne	r2,zero,8246bf0 <u_mctest_run+0x668>
   {
      ns_printf (pio,"t_setsockopt() IP_DROP_MEMBERSHIP failed, Err: %d\n",
 8246bd4:	e13ee317 	ldw	r4,-1140(fp)
 8246bd8:	823181c0 	call	823181c <t_errno>
 8246bdc:	100d883a 	mov	r6,r2
 8246be0:	01420974 	movhi	r5,2085
 8246be4:	29466f04 	addi	r5,r5,6588
 8246be8:	e13fff17 	ldw	r4,-4(fp)
 8246bec:	8228d040 	call	8228d04 <ns_printf>
   {
      ns_printf (pio,"t_shutdown failed.  Err: %d\n", t_errno(s));
   }
#endif

   iRet = t_socketclose(s);
 8246bf0:	e13ee317 	ldw	r4,-1140(fp)
 8246bf4:	82316cc0 	call	82316cc <t_socketclose>
 8246bf8:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 8246bfc:	e0bee417 	ldw	r2,-1136(fp)
 8246c00:	10bfffd8 	cmpnei	r2,r2,-1
 8246c04:	1000071e 	bne	r2,zero,8246c24 <u_mctest_run+0x69c>
   {
      ns_printf (pio,"t_socketclose() failed.  Err: %d\n", t_errno(s));
 8246c08:	e13ee317 	ldw	r4,-1140(fp)
 8246c0c:	823181c0 	call	823181c <t_errno>
 8246c10:	100d883a 	mov	r6,r2
 8246c14:	01420974 	movhi	r5,2085
 8246c18:	29467c04 	addi	r5,r5,6640
 8246c1c:	e13fff17 	ldw	r4,-4(fp)
 8246c20:	8228d040 	call	8228d04 <ns_printf>
   }

   return(0);
 8246c24:	0005883a 	mov	r2,zero
}  /* end main() */  
 8246c28:	e037883a 	mov	sp,fp
 8246c2c:	dfc00117 	ldw	ra,4(sp)
 8246c30:	df000017 	ldw	fp,0(sp)
 8246c34:	dec00204 	addi	sp,sp,8
 8246c38:	f800283a 	ret

08246c3c <dhc_setup>:
 * RETURNS: void
 */

void
dhc_setup(void)
{  
 8246c3c:	defff604 	addi	sp,sp,-40
 8246c40:	dfc00915 	stw	ra,36(sp)
 8246c44:	df000815 	stw	fp,32(sp)
 8246c48:	df000804 	addi	fp,sp,32
   int      iface;
   ulong    dhcp_started;
   ip_addr  dhcp_saveaddr[STATIC_NETS];
   int      e;
   int      dhcnets = 0;   /* number of nets doing DHCP */
 8246c4c:	e03ff915 	stw	zero,-28(fp)

   e = dhc_init();
 8246c50:	82299700 	call	8229970 <dhc_init>
 8246c54:	e0bffa15 	stw	r2,-24(fp)

   if (e)
 8246c58:	e0bffa17 	ldw	r2,-24(fp)
 8246c5c:	10000526 	beq	r2,zero,8246c74 <dhc_setup+0x38>
   {
      printf("Error starting DHCP client code.\n");
 8246c60:	01020974 	movhi	r4,2085
 8246c64:	21068504 	addi	r4,r4,6676
 8246c68:	82035a00 	call	82035a0 <puts>
      netexit(1);
 8246c6c:	01000044 	movi	r4,1
 8246c70:	8243adc0 	call	8243adc <netexit>
   }

   dhcp_started = cticks;  /* init timeout */
 8246c74:	d0a0a817 	ldw	r2,-32096(gp)
 8246c78:	e0bffb15 	stw	r2,-20(fp)

   for (iface = 0; iface < STATIC_NETS; iface++)
 8246c7c:	e03ff815 	stw	zero,-32(fp)
 8246c80:	00005006 	br	8246dc4 <dhc_setup+0x188>
   {
      if (!nets[iface])
 8246c84:	008209b4 	movhi	r2,2086
 8246c88:	10b82404 	addi	r2,r2,-8048
 8246c8c:	e0fff817 	ldw	r3,-32(fp)
 8246c90:	18c7883a 	add	r3,r3,r3
 8246c94:	18c7883a 	add	r3,r3,r3
 8246c98:	10c5883a 	add	r2,r2,r3
 8246c9c:	10800017 	ldw	r2,0(r2)
 8246ca0:	10004226 	beq	r2,zero,8246dac <dhc_setup+0x170>
#ifdef INCLUDE_NVPARMS
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
 8246ca4:	008209b4 	movhi	r2,2086
 8246ca8:	10b82404 	addi	r2,r2,-8048
 8246cac:	e0fff817 	ldw	r3,-32(fp)
 8246cb0:	18c7883a 	add	r3,r3,r3
 8246cb4:	18c7883a 	add	r3,r3,r3
 8246cb8:	10c5883a 	add	r2,r2,r3
 8246cbc:	10800017 	ldw	r2,0(r2)
 8246cc0:	10802a17 	ldw	r2,168(r2)
 8246cc4:	1080400c 	andi	r2,r2,256
 8246cc8:	10003a26 	beq	r2,zero,8246db4 <dhc_setup+0x178>
         continue;

      /* If callback is not already in use (by AutoIP) grab it for
       * our printf routine.
       */
      if(dhc_states[iface].callback == NULL)
 8246ccc:	008209b4 	movhi	r2,2086
 8246cd0:	10b84a04 	addi	r2,r2,-7896
 8246cd4:	e0fff817 	ldw	r3,-32(fp)
 8246cd8:	18c00f24 	muli	r3,r3,60
 8246cdc:	10c5883a 	add	r2,r2,r3
 8246ce0:	10800e04 	addi	r2,r2,56
 8246ce4:	10800017 	ldw	r2,0(r2)
 8246ce8:	1000041e 	bne	r2,zero,8246cfc <dhc_setup+0xc0>
      {
         dhc_set_callback(iface, dhc_main_ipset);
 8246cec:	01420934 	movhi	r5,2084
 8246cf0:	295ba804 	addi	r5,r5,28320
 8246cf4:	e13ff817 	ldw	r4,-32(fp)
 8246cf8:	8229a200 	call	8229a20 <dhc_set_callback>
      }

      /* start DHCP on the iface - first save the default address */
      dhcp_saveaddr[iface] = nets[iface]->n_ipaddr;
 8246cfc:	008209b4 	movhi	r2,2086
 8246d00:	10b82404 	addi	r2,r2,-8048
 8246d04:	e0fff817 	ldw	r3,-32(fp)
 8246d08:	18c7883a 	add	r3,r3,r3
 8246d0c:	18c7883a 	add	r3,r3,r3
 8246d10:	10c5883a 	add	r2,r2,r3
 8246d14:	10800017 	ldw	r2,0(r2)
 8246d18:	10c00a17 	ldw	r3,40(r2)
 8246d1c:	e0bff817 	ldw	r2,-32(fp)
 8246d20:	1085883a 	add	r2,r2,r2
 8246d24:	1085883a 	add	r2,r2,r2
 8246d28:	e13ff804 	addi	r4,fp,-32
 8246d2c:	2085883a 	add	r2,r4,r2
 8246d30:	10800404 	addi	r2,r2,16
 8246d34:	10c00015 	stw	r3,0(r2)

      if (dhcp_saveaddr[iface] == 0L)  /* see if there is a default */
 8246d38:	e0bff817 	ldw	r2,-32(fp)
 8246d3c:	1085883a 	add	r2,r2,r2
 8246d40:	1085883a 	add	r2,r2,r2
 8246d44:	e0fff804 	addi	r3,fp,-32
 8246d48:	1885883a 	add	r2,r3,r2
 8246d4c:	10800404 	addi	r2,r2,16
 8246d50:	10800017 	ldw	r2,0(r2)
 8246d54:	1000041e 	bne	r2,zero,8246d68 <dhc_setup+0x12c>
         dhc_state_init(iface, TRUE);  /* Put DHCPClient in INIT state */
 8246d58:	01400044 	movi	r5,1
 8246d5c:	e13ff817 	ldw	r4,-32(fp)
 8246d60:	822c3180 	call	822c318 <dhc_state_init>
 8246d64:	00000306 	br	8246d74 <dhc_setup+0x138>
      else
         dhc_state_init(iface, FALSE); /* Put DHCPClient in INIT-REBOOT state */
 8246d68:	000b883a 	mov	r5,zero
 8246d6c:	e13ff817 	ldw	r4,-32(fp)
 8246d70:	822c3180 	call	822c318 <dhc_state_init>

      e=dhc_second();                  /* To send the DISCOVER/REQUEST pkt */
 8246d74:	822bb900 	call	822bb90 <dhc_second>
 8246d78:	e0bffa15 	stw	r2,-24(fp)
      if (e)
 8246d7c:	e0bffa17 	ldw	r2,-24(fp)
 8246d80:	10000626 	beq	r2,zero,8246d9c <dhc_setup+0x160>
      {
         printf("Error sending DHCP packet on iface %d.\n", iface);
 8246d84:	e17ff817 	ldw	r5,-32(fp)
 8246d88:	01020974 	movhi	r4,2085
 8246d8c:	21068e04 	addi	r4,r4,6712
 8246d90:	820331c0 	call	820331c <printf>
         netexit(1);
 8246d94:	01000044 	movi	r4,1
 8246d98:	8243adc0 	call	8243adc <netexit>
      /* If we are not using Auto IP then we want to block below waiting
       * for DHCP completion. If we are using Auto IP then we want to
       * return and let the Auto IP code handle the DHCP completion.
       * "dhcnets" is a flag which allows this.
       */
      dhcnets++;
 8246d9c:	e0bff917 	ldw	r2,-28(fp)
 8246da0:	10800044 	addi	r2,r2,1
 8246da4:	e0bff915 	stw	r2,-28(fp)
 8246da8:	00000306 	br	8246db8 <dhc_setup+0x17c>
   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
   {
      if (!nets[iface])
         continue; /* no valid iface for this network */
 8246dac:	0001883a 	nop
 8246db0:	00000106 	br	8246db8 <dhc_setup+0x17c>
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
         continue;
 8246db4:	0001883a 	nop
      netexit(1);
   }

   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
 8246db8:	e0bff817 	ldw	r2,-32(fp)
 8246dbc:	10800044 	addi	r2,r2,1
 8246dc0:	e0bff815 	stw	r2,-32(fp)
 8246dc4:	e0bff817 	ldw	r2,-32(fp)
 8246dc8:	10800110 	cmplti	r2,r2,4
 8246dcc:	103fad1e 	bne	r2,zero,8246c84 <dhc_setup+0x48>
       */
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
 8246dd0:	e0bff917 	ldw	r2,-28(fp)
 8246dd4:	10002c26 	beq	r2,zero,8246e88 <dhc_setup+0x24c>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 8246dd8:	00000206 	br	8246de4 <dhc_setup+0x1a8>
   {
      /* let other tasks spin. This is required, since some systems
       * increment cticks in tasks, or use a polling task to receive
       * packets. Without this activity this loop will never exit.
       */
      tk_yield();
 8246ddc:	82296b00 	call	82296b0 <tk_yield>
      pktdemux();
 8246de0:	82262000 	call	8226200 <pktdemux>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 8246de4:	d0e0a817 	ldw	r3,-32096(gp)
 8246de8:	e0bffb17 	ldw	r2,-20(fp)
 8246dec:	1885c83a 	sub	r2,r3,r2
 8246df0:	108cb228 	cmpgeui	r2,r2,13000
 8246df4:	1000021e 	bne	r2,zero,8246e00 <dhc_setup+0x1c4>
      (dhc_alldone() == FALSE))
 8246df8:	822c3700 	call	822c370 <dhc_alldone>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 8246dfc:	103ff726 	beq	r2,zero,8246ddc <dhc_setup+0x1a0>
#ifdef SUPERLOOP
      dhc_second ();
#endif
   }

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
 8246e00:	822c3700 	call	822c370 <dhc_alldone>
 8246e04:	1000211e 	bne	r2,zero,8246e8c <dhc_setup+0x250>
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
 8246e08:	01020974 	movhi	r4,2085
 8246e0c:	21069804 	addi	r4,r4,6752
 8246e10:	82035a00 	call	82035a0 <puts>
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 8246e14:	e03ff815 	stw	zero,-32(fp)
 8246e18:	00001706 	br	8246e78 <dhc_setup+0x23c>
      {
         if (dhc_ifacedone(iface) == FALSE)
 8246e1c:	e13ff817 	ldw	r4,-32(fp)
 8246e20:	822c3f80 	call	822c3f8 <dhc_ifacedone>
 8246e24:	1000111e 	bne	r2,zero,8246e6c <dhc_setup+0x230>
         {
            dhc_halt(iface);
 8246e28:	e13ff817 	ldw	r4,-32(fp)
 8246e2c:	822c0e00 	call	822c0e0 <dhc_halt>
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
 8246e30:	008209b4 	movhi	r2,2086
 8246e34:	10b82404 	addi	r2,r2,-8048
 8246e38:	e0fff817 	ldw	r3,-32(fp)
 8246e3c:	18c7883a 	add	r3,r3,r3
 8246e40:	18c7883a 	add	r3,r3,r3
 8246e44:	10c5883a 	add	r2,r2,r3
 8246e48:	10c00017 	ldw	r3,0(r2)
 8246e4c:	e0bff817 	ldw	r2,-32(fp)
 8246e50:	1085883a 	add	r2,r2,r2
 8246e54:	1085883a 	add	r2,r2,r2
 8246e58:	e13ff804 	addi	r4,fp,-32
 8246e5c:	2085883a 	add	r2,r4,r2
 8246e60:	10800404 	addi	r2,r2,16
 8246e64:	10800017 	ldw	r2,0(r2)
 8246e68:	18800a15 	stw	r2,40(r3)

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 8246e6c:	e0bff817 	ldw	r2,-32(fp)
 8246e70:	10800044 	addi	r2,r2,1
 8246e74:	e0bff815 	stw	r2,-32(fp)
 8246e78:	e0bff817 	ldw	r2,-32(fp)
 8246e7c:	10800110 	cmplti	r2,r2,4
 8246e80:	103fe61e 	bne	r2,zero,8246e1c <dhc_setup+0x1e0>
 8246e84:	00000106 	br	8246e8c <dhc_setup+0x250>
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
      return;
 8246e88:	0001883a 	nop
            dhc_halt(iface);
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
         }
      }
   }
}
 8246e8c:	e037883a 	mov	sp,fp
 8246e90:	dfc00117 	ldw	ra,4(sp)
 8246e94:	df000017 	ldw	fp,0(sp)
 8246e98:	dec00204 	addi	sp,sp,8
 8246e9c:	f800283a 	ret

08246ea0 <dhc_main_ipset>:
 * RETURNS: 
 */

int
dhc_main_ipset(int iface, int state)
{
 8246ea0:	defffc04 	addi	sp,sp,-16
 8246ea4:	dfc00315 	stw	ra,12(sp)
 8246ea8:	df000215 	stw	fp,8(sp)
 8246eac:	df000204 	addi	fp,sp,8
 8246eb0:	e13ffe15 	stw	r4,-8(fp)
 8246eb4:	e17fff15 	stw	r5,-4(fp)
   if ( state == DHCS_BOUND )
 8246eb8:	e0bfff17 	ldw	r2,-4(fp)
 8246ebc:	10800198 	cmpnei	r2,r2,6
 8246ec0:	1000361e 	bne	r2,zero,8246f9c <dhc_main_ipset+0xfc>
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
              nets[iface]->name);
 8246ec4:	008209b4 	movhi	r2,2086
 8246ec8:	10b82404 	addi	r2,r2,-8048
 8246ecc:	e0fffe17 	ldw	r3,-8(fp)
 8246ed0:	18c7883a 	add	r3,r3,r3
 8246ed4:	18c7883a 	add	r3,r3,r3
 8246ed8:	10c5883a 	add	r2,r2,r3
 8246edc:	10800017 	ldw	r2,0(r2)
 8246ee0:	10800104 	addi	r2,r2,4
dhc_main_ipset(int iface, int state)
{
   if ( state == DHCS_BOUND )
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
 8246ee4:	100b883a 	mov	r5,r2
 8246ee8:	01020974 	movhi	r4,2085
 8246eec:	2106a604 	addi	r4,r4,6808
 8246ef0:	820331c0 	call	820331c <printf>
              nets[iface]->name);

      printf("IP address : %s\n", print_ipad(nets[iface]->n_ipaddr));
 8246ef4:	008209b4 	movhi	r2,2086
 8246ef8:	10b82404 	addi	r2,r2,-8048
 8246efc:	e0fffe17 	ldw	r3,-8(fp)
 8246f00:	18c7883a 	add	r3,r3,r3
 8246f04:	18c7883a 	add	r3,r3,r3
 8246f08:	10c5883a 	add	r2,r2,r3
 8246f0c:	10800017 	ldw	r2,0(r2)
 8246f10:	10800a17 	ldw	r2,40(r2)
 8246f14:	1009883a 	mov	r4,r2
 8246f18:	82289300 	call	8228930 <print_ipad>
 8246f1c:	100b883a 	mov	r5,r2
 8246f20:	01020974 	movhi	r4,2085
 8246f24:	2106b404 	addi	r4,r4,6864
 8246f28:	820331c0 	call	820331c <printf>
      printf("Subnet Mask: %s\n", print_ipad(nets[iface]->snmask));
 8246f2c:	008209b4 	movhi	r2,2086
 8246f30:	10b82404 	addi	r2,r2,-8048
 8246f34:	e0fffe17 	ldw	r3,-8(fp)
 8246f38:	18c7883a 	add	r3,r3,r3
 8246f3c:	18c7883a 	add	r3,r3,r3
 8246f40:	10c5883a 	add	r2,r2,r3
 8246f44:	10800017 	ldw	r2,0(r2)
 8246f48:	10800c17 	ldw	r2,48(r2)
 8246f4c:	1009883a 	mov	r4,r2
 8246f50:	82289300 	call	8228930 <print_ipad>
 8246f54:	100b883a 	mov	r5,r2
 8246f58:	01020974 	movhi	r4,2085
 8246f5c:	2106b904 	addi	r4,r4,6884
 8246f60:	820331c0 	call	820331c <printf>
      printf("Gateway    : %s\n", print_ipad(nets[iface]->n_defgw));
 8246f64:	008209b4 	movhi	r2,2086
 8246f68:	10b82404 	addi	r2,r2,-8048
 8246f6c:	e0fffe17 	ldw	r3,-8(fp)
 8246f70:	18c7883a 	add	r3,r3,r3
 8246f74:	18c7883a 	add	r3,r3,r3
 8246f78:	10c5883a 	add	r2,r2,r3
 8246f7c:	10800017 	ldw	r2,0(r2)
 8246f80:	10800d17 	ldw	r2,52(r2)
 8246f84:	1009883a 	mov	r4,r2
 8246f88:	82289300 	call	8228930 <print_ipad>
 8246f8c:	100b883a 	mov	r5,r2
 8246f90:	01020974 	movhi	r4,2085
 8246f94:	2106be04 	addi	r4,r4,6904
 8246f98:	820331c0 	call	820331c <printf>
   }
   return 0;
 8246f9c:	0005883a 	mov	r2,zero
}
 8246fa0:	e037883a 	mov	sp,fp
 8246fa4:	dfc00117 	ldw	ra,4(sp)
 8246fa8:	df000017 	ldw	fp,0(sp)
 8246fac:	dec00204 	addi	sp,sp,8
 8246fb0:	f800283a 	ret

08246fb4 <init_memdev>:
 * RETURNS: 
 */

int
init_memdev(void)
{
 8246fb4:	deffff04 	addi	sp,sp,-4
 8246fb8:	df000015 	stw	fp,0(sp)
 8246fbc:	d839883a 	mov	fp,sp
   /* add our IO pointer to master list */
   mdio.next = vfsystems;
 8246fc0:	d0e0d417 	ldw	r3,-31920(gp)
 8246fc4:	00820974 	movhi	r2,2085
 8246fc8:	108f4504 	addi	r2,r2,15636
 8246fcc:	10c00015 	stw	r3,0(r2)
   vfsystems = &mdio;
 8246fd0:	00820974 	movhi	r2,2085
 8246fd4:	108f4504 	addi	r2,r2,15636
 8246fd8:	d0a0d415 	stw	r2,-31920(gp)

   /* add the memory device files to vfs list */
   mdlist[0].next = vfsfiles;
 8246fdc:	d0e0d617 	ldw	r3,-31912(gp)
 8246fe0:	00820974 	movhi	r2,2085
 8246fe4:	108f4e04 	addi	r2,r2,15672
 8246fe8:	10c00015 	stw	r3,0(r2)
   vfsfiles = &mdlist[3];
 8246fec:	00820974 	movhi	r2,2085
 8246ff0:	108f6f04 	addi	r2,r2,15804
 8246ff4:	d0a0d615 	stw	r2,-31912(gp)

   return 0;
 8246ff8:	0005883a 	mov	r2,zero
}
 8246ffc:	e037883a 	mov	sp,fp
 8247000:	df000017 	ldw	fp,0(sp)
 8247004:	dec00104 	addi	sp,sp,4
 8247008:	f800283a 	ret

0824700c <md_fopen>:
 * RETURNS: 
 */

VFILE* 
md_fopen(char * name, char * mode)
{
 824700c:	defffd04 	addi	sp,sp,-12
 8247010:	df000215 	stw	fp,8(sp)
 8247014:	df000204 	addi	fp,sp,8
 8247018:	e13ffe15 	stw	r4,-8(fp)
 824701c:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(mode);
   USE_ARG(name);
   return NULL;
 8247020:	0005883a 	mov	r2,zero
}
 8247024:	e037883a 	mov	sp,fp
 8247028:	df000017 	ldw	fp,0(sp)
 824702c:	dec00104 	addi	sp,sp,4
 8247030:	f800283a 	ret

08247034 <md_fclose>:
 * RETURNS: 
 */

void   
md_fclose(VFILE * vfd)
{
 8247034:	defffe04 	addi	sp,sp,-8
 8247038:	df000115 	stw	fp,4(sp)
 824703c:	df000104 	addi	fp,sp,4
 8247040:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);
}
 8247044:	0001883a 	nop
 8247048:	e037883a 	mov	sp,fp
 824704c:	df000017 	ldw	fp,0(sp)
 8247050:	dec00104 	addi	sp,sp,4
 8247054:	f800283a 	ret

08247058 <md_fread>:
 * RETURNS: 
 */

int    
md_fread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 8247058:	defff704 	addi	sp,sp,-36
 824705c:	dfc00815 	stw	ra,32(sp)
 8247060:	df000715 	stw	fp,28(sp)
 8247064:	df000704 	addi	fp,sp,28
 8247068:	e13ffc15 	stw	r4,-16(fp)
 824706c:	e17ffd15 	stw	r5,-12(fp)
 8247070:	e1bffe15 	stw	r6,-8(fp)
 8247074:	e1ffff15 	stw	r7,-4(fp)
   u_long   bcount;     /* number of bytes put in caller's buffer */
   u_long   location;   /* current offset into file */
   unsigned long file_size = MEMDEV_SIZE;
 8247078:	00800834 	movhi	r2,32
 824707c:	e0bffa15 	stw	r2,-24(fp)
   if(vfd && vfd->file)
 8247080:	e0bfff17 	ldw	r2,-4(fp)
 8247084:	10000726 	beq	r2,zero,82470a4 <md_fread+0x4c>
 8247088:	e0bfff17 	ldw	r2,-4(fp)
 824708c:	10800117 	ldw	r2,4(r2)
 8247090:	10000426 	beq	r2,zero,82470a4 <md_fread+0x4c>
   {
      file_size = vfd->file->real_size; 
 8247094:	e0bfff17 	ldw	r2,-4(fp)
 8247098:	10800117 	ldw	r2,4(r2)
 824709c:	10800717 	ldw	r2,28(r2)
 82470a0:	e0bffa15 	stw	r2,-24(fp)
#ifdef SEG16_16   /* 16-bit x86 must include segment. */
   if(vfd->cmploc == (u_char*)0xFFFFFFFF)   /* at EOF */
      return 0;
   location = (u_long)(((char huge *)vfd->cmploc) - ((char huge *)vfd->file->data));
#else
   location = (u_long)(vfd->cmploc - vfd->file->data);
 82470a4:	e0bfff17 	ldw	r2,-4(fp)
 82470a8:	10800217 	ldw	r2,8(r2)
 82470ac:	1007883a 	mov	r3,r2
 82470b0:	e0bfff17 	ldw	r2,-4(fp)
 82470b4:	10800117 	ldw	r2,4(r2)
 82470b8:	10800617 	ldw	r2,24(r2)
 82470bc:	1885c83a 	sub	r2,r3,r2
 82470c0:	e0bffb15 	stw	r2,-20(fp)
#endif   /* SEG16_16 */

   bcount = (items * (u_long)size);     /* number of bytes to transfer */
 82470c4:	e0fffe17 	ldw	r3,-8(fp)
 82470c8:	e0bffd17 	ldw	r2,-12(fp)
 82470cc:	1885383a 	mul	r2,r3,r2
 82470d0:	e0bff915 	stw	r2,-28(fp)

   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
 82470d4:	e0fffb17 	ldw	r3,-20(fp)
 82470d8:	e0bff917 	ldw	r2,-28(fp)
 82470dc:	1885883a 	add	r2,r3,r2
 82470e0:	e0fffa17 	ldw	r3,-24(fp)
 82470e4:	1880042e 	bgeu	r3,r2,82470f8 <md_fread+0xa0>
      bcount = ((u_long)file_size - location);
 82470e8:	e0fffa17 	ldw	r3,-24(fp)
 82470ec:	e0bffb17 	ldw	r2,-20(fp)
 82470f0:	1885c83a 	sub	r2,r3,r2
 82470f4:	e0bff915 	stw	r2,-28(fp)

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 82470f8:	e0fffb17 	ldw	r3,-20(fp)
 82470fc:	e0bffa17 	ldw	r2,-24(fp)
 8247100:	1880052e 	bgeu	r3,r2,8247118 <md_fread+0xc0>
      (bcount  & 0xFFFF0000) ||
 8247104:	e0bff917 	ldw	r2,-28(fp)
 8247108:	10bfffec 	andhi	r2,r2,65535
   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
      bcount = ((u_long)file_size - location);

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 824710c:	1000021e 	bne	r2,zero,8247118 <md_fread+0xc0>
      (bcount  & 0xFFFF0000) ||
 8247110:	e0bff917 	ldw	r2,-28(fp)
 8247114:	1000021e 	bne	r2,zero,8247120 <md_fread+0xc8>
      (bcount == 0))
   {
      return 0;
 8247118:	0005883a 	mov	r2,zero
 824711c:	00002006 	br	82471a0 <md_fread+0x148>
   /* Use VF_NODATA if memory devices have a size, but no
      data. This can be used to measure file read speed
      without introducing an undefined data copy. */
   /* VF_NODATA is defined in ../h/vfsfiles.h */
   
   if (!(vfd->file->flags & VF_NODATA))
 8247120:	e0bfff17 	ldw	r2,-4(fp)
 8247124:	10800117 	ldw	r2,4(r2)
 8247128:	1080058b 	ldhu	r2,22(r2)
 824712c:	10bfffcc 	andi	r2,r2,65535
 8247130:	10a0001c 	xori	r2,r2,32768
 8247134:	10a00004 	addi	r2,r2,-32768
 8247138:	10001016 	blt	r2,zero,824717c <md_fread+0x124>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 824713c:	e0bfff17 	ldw	r2,-4(fp)
 8247140:	10800117 	ldw	r2,4(r2)
 8247144:	10800103 	ldbu	r2,4(r2)
 8247148:	10803fcc 	andi	r2,r2,255
 824714c:	1080201c 	xori	r2,r2,128
 8247150:	10bfe004 	addi	r2,r2,-128
 8247154:	10801b58 	cmpnei	r2,r2,109
 8247158:	1000081e 	bne	r2,zero,824717c <md_fread+0x124>
         MEMCPY(buf, vfd->cmploc + MEMDEV_BASE, (unsigned)bcount);
 824715c:	e0bfff17 	ldw	r2,-4(fp)
 8247160:	10c00217 	ldw	r3,8(r2)
 8247164:	00800834 	movhi	r2,32
 8247168:	1885883a 	add	r2,r3,r2
 824716c:	e1bff917 	ldw	r6,-28(fp)
 8247170:	100b883a 	mov	r5,r2
 8247174:	e13ffc17 	ldw	r4,-16(fp)
 8247178:	8202e8c0 	call	8202e8c <memcpy>
         vfd->cmploc = (u_char *)cp;
      else     /* read wrapped memory, set pointer to EOF value */
         vfd->cmploc = (u_char*)(0xFFFFFFFF);  /* EOF */
   }
#else
   vfd->cmploc += bcount;  /* adjust location */
 824717c:	e0bfff17 	ldw	r2,-4(fp)
 8247180:	10c00217 	ldw	r3,8(r2)
 8247184:	e0bff917 	ldw	r2,-28(fp)
 8247188:	1887883a 	add	r3,r3,r2
 824718c:	e0bfff17 	ldw	r2,-4(fp)
 8247190:	10c00215 	stw	r3,8(r2)
#endif
   
   return ((int)bcount/size);
 8247194:	e17ffd17 	ldw	r5,-12(fp)
 8247198:	e13ff917 	ldw	r4,-28(fp)
 824719c:	8202b8c0 	call	8202b8c <__udivsi3>
}
 82471a0:	e037883a 	mov	sp,fp
 82471a4:	dfc00117 	ldw	ra,4(sp)
 82471a8:	df000017 	ldw	fp,0(sp)
 82471ac:	dec00204 	addi	sp,sp,8
 82471b0:	f800283a 	ret

082471b4 <md_fwrite>:
 * RETURNS: 
 */

int    
md_fwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 82471b4:	defffb04 	addi	sp,sp,-20
 82471b8:	df000415 	stw	fp,16(sp)
 82471bc:	df000404 	addi	fp,sp,16
 82471c0:	e13ffc15 	stw	r4,-16(fp)
 82471c4:	e17ffd15 	stw	r5,-12(fp)
 82471c8:	e1bffe15 	stw	r6,-8(fp)
 82471cc:	e1ffff15 	stw	r7,-4(fp)
   if (vfd->file->name[0] == 'm')   /* memory device */
 82471d0:	e0bfff17 	ldw	r2,-4(fp)
 82471d4:	10800117 	ldw	r2,4(r2)
 82471d8:	10800103 	ldbu	r2,4(r2)
 82471dc:	10803fcc 	andi	r2,r2,255
 82471e0:	1080201c 	xori	r2,r2,128
 82471e4:	10bfe004 	addi	r2,r2,-128
 82471e8:	10801b58 	cmpnei	r2,r2,109
 82471ec:	1000021e 	bne	r2,zero,82471f8 <md_fwrite+0x44>
      return 0;   /* not writable device */
 82471f0:	0005883a 	mov	r2,zero
 82471f4:	00000906 	br	824721c <md_fwrite+0x68>

   vfd->cmploc += (items * size);   /* adjust location */
 82471f8:	e0bfff17 	ldw	r2,-4(fp)
 82471fc:	10c00217 	ldw	r3,8(r2)
 8247200:	e13ffe17 	ldw	r4,-8(fp)
 8247204:	e0bffd17 	ldw	r2,-12(fp)
 8247208:	2085383a 	mul	r2,r4,r2
 824720c:	1887883a 	add	r3,r3,r2
 8247210:	e0bfff17 	ldw	r2,-4(fp)
 8247214:	10c00215 	stw	r3,8(r2)

   USE_ARG(buf);     /* supress compiler warnings */

   return (items);
 8247218:	e0bffe17 	ldw	r2,-8(fp)
}
 824721c:	e037883a 	mov	sp,fp
 8247220:	df000017 	ldw	fp,0(sp)
 8247224:	dec00104 	addi	sp,sp,4
 8247228:	f800283a 	ret

0824722c <md_fseek>:
 * RETURNS: 
 */

int
md_fseek(VFILE * vfd, long offset, int mode)
{
 824722c:	defffc04 	addi	sp,sp,-16
 8247230:	df000315 	stw	fp,12(sp)
 8247234:	df000304 	addi	fp,sp,12
 8247238:	e13ffd15 	stw	r4,-12(fp)
 824723c:	e17ffe15 	stw	r5,-8(fp)
 8247240:	e1bfff15 	stw	r6,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   USE_ARG(offset);
   USE_ARG(mode);
   return 0;
 8247244:	0005883a 	mov	r2,zero
}
 8247248:	e037883a 	mov	sp,fp
 824724c:	df000017 	ldw	fp,0(sp)
 8247250:	dec00104 	addi	sp,sp,4
 8247254:	f800283a 	ret

08247258 <md_ftell>:
 * RETURNS: 
 */

long   
md_ftell(VFILE * vfd)
{
 8247258:	defffe04 	addi	sp,sp,-8
 824725c:	df000115 	stw	fp,4(sp)
 8247260:	df000104 	addi	fp,sp,4
 8247264:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   return MEMDEV_SIZE;
 8247268:	00800834 	movhi	r2,32
}
 824726c:	e037883a 	mov	sp,fp
 8247270:	df000017 	ldw	fp,0(sp)
 8247274:	dec00104 	addi	sp,sp,4
 8247278:	f800283a 	ret

0824727c <md_fgetc>:
 * RETURNS: 
 */

int    
md_fgetc(VFILE * vfd)
{
 824727c:	defffc04 	addi	sp,sp,-16
 8247280:	df000315 	stw	fp,12(sp)
 8247284:	df000304 	addi	fp,sp,12
 8247288:	e13fff15 	stw	r4,-4(fp)
   unsigned location;   /* current offset infile */
   int   retval   =  0;
 824728c:	e03ffd15 	stw	zero,-12(fp)

   location = vfd->cmploc - vfd->file->data;
 8247290:	e0bfff17 	ldw	r2,-4(fp)
 8247294:	10800217 	ldw	r2,8(r2)
 8247298:	1007883a 	mov	r3,r2
 824729c:	e0bfff17 	ldw	r2,-4(fp)
 82472a0:	10800117 	ldw	r2,4(r2)
 82472a4:	10800617 	ldw	r2,24(r2)
 82472a8:	1885c83a 	sub	r2,r3,r2
 82472ac:	e0bffe15 	stw	r2,-8(fp)
   if (location >= vfd->file->real_size)     /* at end of file? */
 82472b0:	e0bfff17 	ldw	r2,-4(fp)
 82472b4:	10800117 	ldw	r2,4(r2)
 82472b8:	10800717 	ldw	r2,28(r2)
 82472bc:	e0fffe17 	ldw	r3,-8(fp)
 82472c0:	18800236 	bltu	r3,r2,82472cc <md_fgetc+0x50>
      return EOF;
 82472c4:	00bfffc4 	movi	r2,-1
 82472c8:	00001a06 	br	8247334 <md_fgetc+0xb8>

   if (!(vfd->file->flags & VF_NODATA))
 82472cc:	e0bfff17 	ldw	r2,-4(fp)
 82472d0:	10800117 	ldw	r2,4(r2)
 82472d4:	1080058b 	ldhu	r2,22(r2)
 82472d8:	10bfffcc 	andi	r2,r2,65535
 82472dc:	10a0001c 	xori	r2,r2,32768
 82472e0:	10a00004 	addi	r2,r2,-32768
 82472e4:	10000d16 	blt	r2,zero,824731c <md_fgetc+0xa0>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 82472e8:	e0bfff17 	ldw	r2,-4(fp)
 82472ec:	10800117 	ldw	r2,4(r2)
 82472f0:	10800103 	ldbu	r2,4(r2)
 82472f4:	10803fcc 	andi	r2,r2,255
 82472f8:	1080201c 	xori	r2,r2,128
 82472fc:	10bfe004 	addi	r2,r2,-128
 8247300:	10801b58 	cmpnei	r2,r2,109
 8247304:	1000051e 	bne	r2,zero,824731c <md_fgetc+0xa0>
         retval = (int)(*vfd->cmploc) & 0xFF ;
 8247308:	e0bfff17 	ldw	r2,-4(fp)
 824730c:	10800217 	ldw	r2,8(r2)
 8247310:	10800003 	ldbu	r2,0(r2)
 8247314:	10803fcc 	andi	r2,r2,255
 8247318:	e0bffd15 	stw	r2,-12(fp)
   }

   /* else for null device or files without data, 
      use whatever is in retval */

   vfd->cmploc++;    /* adjust location */
 824731c:	e0bfff17 	ldw	r2,-4(fp)
 8247320:	10800217 	ldw	r2,8(r2)
 8247324:	10c00044 	addi	r3,r2,1
 8247328:	e0bfff17 	ldw	r2,-4(fp)
 824732c:	10c00215 	stw	r3,8(r2)
   return retval;
 8247330:	e0bffd17 	ldw	r2,-12(fp)
}
 8247334:	e037883a 	mov	sp,fp
 8247338:	df000017 	ldw	fp,0(sp)
 824733c:	dec00104 	addi	sp,sp,4
 8247340:	f800283a 	ret

08247344 <md_unlink>:
 * RETURNS: 
 */

int    
md_unlink(char * filename)
{
 8247344:	defffe04 	addi	sp,sp,-8
 8247348:	df000115 	stw	fp,4(sp)
 824734c:	df000104 	addi	fp,sp,4
 8247350:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(filename);     /* supress compiler warnings */
   return 0;
 8247354:	0005883a 	mov	r2,zero
}
 8247358:	e037883a 	mov	sp,fp
 824735c:	df000017 	ldw	fp,0(sp)
 8247360:	dec00104 	addi	sp,sp,4
 8247364:	f800283a 	ret

08247368 <parse_ipad>:

char *   
parse_ipad(ip_addr * ipout,   /* pointer to IP address to set */
   unsigned *  sbits,      /* default subnet bit number */
   char *   stringin)      /* buffer with ascii to parse */
{
 8247368:	defff604 	addi	sp,sp,-40
 824736c:	dfc00915 	stw	ra,36(sp)
 8247370:	df000815 	stw	fp,32(sp)
 8247374:	df000804 	addi	fp,sp,32
 8247378:	e13ffd15 	stw	r4,-12(fp)
 824737c:	e17ffe15 	stw	r5,-8(fp)
 8247380:	e1bfff15 	stw	r6,-4(fp)
   char *   cp;
   int   dots  =  0; /* periods imbedded in input string */
 8247384:	e03ff915 	stw	zero,-28(fp)
   union   
   {
      u_char   c[4];
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";
 8247388:	00820974 	movhi	r2,2085
 824738c:	1086c304 	addi	r2,r2,6924
 8247390:	e0bffa15 	stw	r2,-24(fp)

   cp = stringin;
 8247394:	e0bfff17 	ldw	r2,-4(fp)
 8247398:	e0bff815 	stw	r2,-32(fp)
   while (*cp)
 824739c:	00002506 	br	8247434 <parse_ipad+0xcc>
   {
      if (*cp > '9' || *cp < '.' || *cp == '/')
 82473a0:	e0bff817 	ldw	r2,-32(fp)
 82473a4:	10800003 	ldbu	r2,0(r2)
 82473a8:	10803fcc 	andi	r2,r2,255
 82473ac:	1080201c 	xori	r2,r2,128
 82473b0:	10bfe004 	addi	r2,r2,-128
 82473b4:	10800e88 	cmpgei	r2,r2,58
 82473b8:	10000e1e 	bne	r2,zero,82473f4 <parse_ipad+0x8c>
 82473bc:	e0bff817 	ldw	r2,-32(fp)
 82473c0:	10800003 	ldbu	r2,0(r2)
 82473c4:	10803fcc 	andi	r2,r2,255
 82473c8:	1080201c 	xori	r2,r2,128
 82473cc:	10bfe004 	addi	r2,r2,-128
 82473d0:	10800b90 	cmplti	r2,r2,46
 82473d4:	1000071e 	bne	r2,zero,82473f4 <parse_ipad+0x8c>
 82473d8:	e0bff817 	ldw	r2,-32(fp)
 82473dc:	10800003 	ldbu	r2,0(r2)
 82473e0:	10803fcc 	andi	r2,r2,255
 82473e4:	1080201c 	xori	r2,r2,128
 82473e8:	10bfe004 	addi	r2,r2,-128
 82473ec:	10800bd8 	cmpnei	r2,r2,47
 82473f0:	1000031e 	bne	r2,zero,8247400 <parse_ipad+0x98>
         return("all chars must be digits (0-9) or dots (.)");
 82473f4:	00820974 	movhi	r2,2085
 82473f8:	1086cc04 	addi	r2,r2,6960
 82473fc:	00009406 	br	8247650 <parse_ipad+0x2e8>
      if (*cp == '.')dots++;
 8247400:	e0bff817 	ldw	r2,-32(fp)
 8247404:	10800003 	ldbu	r2,0(r2)
 8247408:	10803fcc 	andi	r2,r2,255
 824740c:	1080201c 	xori	r2,r2,128
 8247410:	10bfe004 	addi	r2,r2,-128
 8247414:	10800b98 	cmpnei	r2,r2,46
 8247418:	1000031e 	bne	r2,zero,8247428 <parse_ipad+0xc0>
 824741c:	e0bff917 	ldw	r2,-28(fp)
 8247420:	10800044 	addi	r2,r2,1
 8247424:	e0bff915 	stw	r2,-28(fp)
         cp++;
 8247428:	e0bff817 	ldw	r2,-32(fp)
 824742c:	10800044 	addi	r2,r2,1
 8247430:	e0bff815 	stw	r2,-32(fp)
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";

   cp = stringin;
   while (*cp)
 8247434:	e0bff817 	ldw	r2,-32(fp)
 8247438:	10800003 	ldbu	r2,0(r2)
 824743c:	10803fcc 	andi	r2,r2,255
 8247440:	1080201c 	xori	r2,r2,128
 8247444:	10bfe004 	addi	r2,r2,-128
 8247448:	103fd51e 	bne	r2,zero,82473a0 <parse_ipad+0x38>
         return("all chars must be digits (0-9) or dots (.)");
      if (*cp == '.')dots++;
         cp++;
   }

   if ( dots < 1 || dots > 3 )
 824744c:	e0bff917 	ldw	r2,-28(fp)
 8247450:	0080030e 	bge	zero,r2,8247460 <parse_ipad+0xf8>
 8247454:	e0bff917 	ldw	r2,-28(fp)
 8247458:	10800110 	cmplti	r2,r2,4
 824745c:	1000031e 	bne	r2,zero,824746c <parse_ipad+0x104>
      return("string must contain 1 - 3 dots (.)");
 8247460:	00820974 	movhi	r2,2085
 8247464:	1086d704 	addi	r2,r2,7004
 8247468:	00007906 	br	8247650 <parse_ipad+0x2e8>

   cp = stringin;
 824746c:	e0bfff17 	ldw	r2,-4(fp)
 8247470:	e0bff815 	stw	r2,-32(fp)
   if ((number = atoi(cp)) > 255)   /* set net number */
 8247474:	e13ff817 	ldw	r4,-32(fp)
 8247478:	824b4900 	call	824b490 <atoi>
 824747c:	e0bffb15 	stw	r2,-20(fp)
 8247480:	e0bffb17 	ldw	r2,-20(fp)
 8247484:	10804010 	cmplti	r2,r2,256
 8247488:	1000021e 	bne	r2,zero,8247494 <parse_ipad+0x12c>
      return(toobig);
 824748c:	e0bffa17 	ldw	r2,-24(fp)
 8247490:	00006f06 	br	8247650 <parse_ipad+0x2e8>

   retval.c[0] = (u_char)number;
 8247494:	e0bffb17 	ldw	r2,-20(fp)
 8247498:	e0bffc05 	stb	r2,-16(fp)

   while (*cp != '.')cp++; /* find dot (end of number) */
 824749c:	00000306 	br	82474ac <parse_ipad+0x144>
 82474a0:	e0bff817 	ldw	r2,-32(fp)
 82474a4:	10800044 	addi	r2,r2,1
 82474a8:	e0bff815 	stw	r2,-32(fp)
 82474ac:	e0bff817 	ldw	r2,-32(fp)
 82474b0:	10800003 	ldbu	r2,0(r2)
 82474b4:	10803fcc 	andi	r2,r2,255
 82474b8:	1080201c 	xori	r2,r2,128
 82474bc:	10bfe004 	addi	r2,r2,-128
 82474c0:	10800b98 	cmpnei	r2,r2,46
 82474c4:	103ff61e 	bne	r2,zero,82474a0 <parse_ipad+0x138>
      cp++;             /* point past dot */
 82474c8:	e0bff817 	ldw	r2,-32(fp)
 82474cc:	10800044 	addi	r2,r2,1
 82474d0:	e0bff815 	stw	r2,-32(fp)

   if (dots == 1 || dots == 2) retval.c[1] = 0;
 82474d4:	e0bff917 	ldw	r2,-28(fp)
 82474d8:	10800060 	cmpeqi	r2,r2,1
 82474dc:	1000031e 	bne	r2,zero,82474ec <parse_ipad+0x184>
 82474e0:	e0bff917 	ldw	r2,-28(fp)
 82474e4:	10800098 	cmpnei	r2,r2,2
 82474e8:	1000021e 	bne	r2,zero,82474f4 <parse_ipad+0x18c>
 82474ec:	e03ffc45 	stb	zero,-15(fp)
 82474f0:	00001806 	br	8247554 <parse_ipad+0x1ec>
      else
   {
      number = atoi(cp);
 82474f4:	e13ff817 	ldw	r4,-32(fp)
 82474f8:	824b4900 	call	824b490 <atoi>
 82474fc:	e0bffb15 	stw	r2,-20(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 8247500:	00000306 	br	8247510 <parse_ipad+0x1a8>
 8247504:	e0bff817 	ldw	r2,-32(fp)
 8247508:	10800044 	addi	r2,r2,1
 824750c:	e0bff815 	stw	r2,-32(fp)
 8247510:	e0bff817 	ldw	r2,-32(fp)
 8247514:	10800003 	ldbu	r2,0(r2)
 8247518:	10803fcc 	andi	r2,r2,255
 824751c:	1080201c 	xori	r2,r2,128
 8247520:	10bfe004 	addi	r2,r2,-128
 8247524:	10800b98 	cmpnei	r2,r2,46
 8247528:	103ff61e 	bne	r2,zero,8247504 <parse_ipad+0x19c>
         cp++;             /* point past dot */
 824752c:	e0bff817 	ldw	r2,-32(fp)
 8247530:	10800044 	addi	r2,r2,1
 8247534:	e0bff815 	stw	r2,-32(fp)
      if (number > 255) return(toobig);
 8247538:	e0bffb17 	ldw	r2,-20(fp)
 824753c:	10804010 	cmplti	r2,r2,256
 8247540:	1000021e 	bne	r2,zero,824754c <parse_ipad+0x1e4>
 8247544:	e0bffa17 	ldw	r2,-24(fp)
 8247548:	00004106 	br	8247650 <parse_ipad+0x2e8>
         retval.c[1] = (u_char)number;
 824754c:	e0bffb17 	ldw	r2,-20(fp)
 8247550:	e0bffc45 	stb	r2,-15(fp)
   }

   if (dots == 1) retval.c[2] = 0;
 8247554:	e0bff917 	ldw	r2,-28(fp)
 8247558:	10800058 	cmpnei	r2,r2,1
 824755c:	1000021e 	bne	r2,zero,8247568 <parse_ipad+0x200>
 8247560:	e03ffc85 	stb	zero,-14(fp)
 8247564:	00001806 	br	82475c8 <parse_ipad+0x260>
      else
   {
      number = atoi(cp);
 8247568:	e13ff817 	ldw	r4,-32(fp)
 824756c:	824b4900 	call	824b490 <atoi>
 8247570:	e0bffb15 	stw	r2,-20(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 8247574:	00000306 	br	8247584 <parse_ipad+0x21c>
 8247578:	e0bff817 	ldw	r2,-32(fp)
 824757c:	10800044 	addi	r2,r2,1
 8247580:	e0bff815 	stw	r2,-32(fp)
 8247584:	e0bff817 	ldw	r2,-32(fp)
 8247588:	10800003 	ldbu	r2,0(r2)
 824758c:	10803fcc 	andi	r2,r2,255
 8247590:	1080201c 	xori	r2,r2,128
 8247594:	10bfe004 	addi	r2,r2,-128
 8247598:	10800b98 	cmpnei	r2,r2,46
 824759c:	103ff61e 	bne	r2,zero,8247578 <parse_ipad+0x210>
         cp++;             /* point past dot */
 82475a0:	e0bff817 	ldw	r2,-32(fp)
 82475a4:	10800044 	addi	r2,r2,1
 82475a8:	e0bff815 	stw	r2,-32(fp)
      if (number > 255) return(toobig);
 82475ac:	e0bffb17 	ldw	r2,-20(fp)
 82475b0:	10804010 	cmplti	r2,r2,256
 82475b4:	1000021e 	bne	r2,zero,82475c0 <parse_ipad+0x258>
 82475b8:	e0bffa17 	ldw	r2,-24(fp)
 82475bc:	00002406 	br	8247650 <parse_ipad+0x2e8>
         retval.c[2] = (u_char)number;
 82475c0:	e0bffb17 	ldw	r2,-20(fp)
 82475c4:	e0bffc85 	stb	r2,-14(fp)
   }

   if ((number = atoi(cp)) > 255)
 82475c8:	e13ff817 	ldw	r4,-32(fp)
 82475cc:	824b4900 	call	824b490 <atoi>
 82475d0:	e0bffb15 	stw	r2,-20(fp)
 82475d4:	e0bffb17 	ldw	r2,-20(fp)
 82475d8:	10804010 	cmplti	r2,r2,256
 82475dc:	1000021e 	bne	r2,zero,82475e8 <parse_ipad+0x280>
      return(toobig);
 82475e0:	e0bffa17 	ldw	r2,-24(fp)
 82475e4:	00001a06 	br	8247650 <parse_ipad+0x2e8>
   retval.c[3] = (u_char)number;
 82475e8:	e0bffb17 	ldw	r2,-20(fp)
 82475ec:	e0bffcc5 	stb	r2,-13(fp)

   if (retval.c[0] < 128) *sbits = 8;
 82475f0:	e0bffc03 	ldbu	r2,-16(fp)
 82475f4:	10803fcc 	andi	r2,r2,255
 82475f8:	1080201c 	xori	r2,r2,128
 82475fc:	10bfe004 	addi	r2,r2,-128
 8247600:	10000416 	blt	r2,zero,8247614 <parse_ipad+0x2ac>
 8247604:	e0bffe17 	ldw	r2,-8(fp)
 8247608:	00c00204 	movi	r3,8
 824760c:	10c00015 	stw	r3,0(r2)
 8247610:	00000b06 	br	8247640 <parse_ipad+0x2d8>
      else if(retval.c[0] < 192) *sbits = 16;
 8247614:	e0bffc03 	ldbu	r2,-16(fp)
 8247618:	10803fcc 	andi	r2,r2,255
 824761c:	10803028 	cmpgeui	r2,r2,192
 8247620:	1000041e 	bne	r2,zero,8247634 <parse_ipad+0x2cc>
 8247624:	e0bffe17 	ldw	r2,-8(fp)
 8247628:	00c00404 	movi	r3,16
 824762c:	10c00015 	stw	r3,0(r2)
 8247630:	00000306 	br	8247640 <parse_ipad+0x2d8>
      else *sbits = 24;
 8247634:	e0bffe17 	ldw	r2,-8(fp)
 8247638:	00c00604 	movi	r3,24
 824763c:	10c00015 	stw	r3,0(r2)

      *ipout = retval.l;      /* everything went OK, return number */
 8247640:	e0fffc17 	ldw	r3,-16(fp)
 8247644:	e0bffd17 	ldw	r2,-12(fp)
 8247648:	10c00015 	stw	r3,0(r2)
   return(NULL);        /* return OK code (no error string) */
 824764c:	0005883a 	mov	r2,zero
}
 8247650:	e037883a 	mov	sp,fp
 8247654:	dfc00117 	ldw	ra,4(sp)
 8247658:	df000017 	ldw	fp,0(sp)
 824765c:	dec00204 	addi	sp,sp,8
 8247660:	f800283a 	ret

08247664 <inet_addr>:
 * RETURNS: u_long ipaddr
 */

u_long 
inet_addr(char FAR * str)
{
 8247664:	defffb04 	addi	sp,sp,-20
 8247668:	dfc00415 	stw	ra,16(sp)
 824766c:	df000315 	stw	fp,12(sp)
 8247670:	df000304 	addi	fp,sp,12
 8247674:	e13fff15 	stw	r4,-4(fp)
    * we need to make the conversion. Usually this function will be 
    * used for debugging, so I think we can bear the STRCPY overhead.
    */
   static char nearBuf[30];

   strcpy((char FAR *)nearBuf,str);
 8247678:	e17fff17 	ldw	r5,-4(fp)
 824767c:	01020974 	movhi	r4,2085
 8247680:	21121804 	addi	r4,r4,18528
 8247684:	824b6b80 	call	824b6b8 <strcpy>
   if ( parse_ipad(&ipaddr,&bits,nearBuf) == NULL )
 8247688:	e0bffe04 	addi	r2,fp,-8
 824768c:	01820974 	movhi	r6,2085
 8247690:	31921804 	addi	r6,r6,18528
 8247694:	100b883a 	mov	r5,r2
 8247698:	e13ffd04 	addi	r4,fp,-12
 824769c:	82473680 	call	8247368 <parse_ipad>
 82476a0:	1000021e 	bne	r2,zero,82476ac <inet_addr+0x48>
   {
      return ipaddr ;
 82476a4:	e0bffd17 	ldw	r2,-12(fp)
 82476a8:	00000106 	br	82476b0 <inet_addr+0x4c>
   }
   else
   {
      return (u_long)NULL ;
 82476ac:	0005883a 	mov	r2,zero
   }
}
 82476b0:	e037883a 	mov	sp,fp
 82476b4:	dfc00117 	ldw	ra,4(sp)
 82476b8:	df000017 	ldw	fp,0(sp)
 82476bc:	dec00204 	addi	sp,sp,8
 82476c0:	f800283a 	ret

082476c4 <hextoa>:
 * RETURNS: character 0-9 or A-F
 */

char
hextoa(int val)
{
 82476c4:	defffe04 	addi	sp,sp,-8
 82476c8:	df000115 	stw	fp,4(sp)
 82476cc:	df000104 	addi	fp,sp,4
 82476d0:	e13fff15 	stw	r4,-4(fp)
   val &= 0x0f;
 82476d4:	e0bfff17 	ldw	r2,-4(fp)
 82476d8:	108003cc 	andi	r2,r2,15
 82476dc:	e0bfff15 	stw	r2,-4(fp)
   if(val < 10)
 82476e0:	e0bfff17 	ldw	r2,-4(fp)
 82476e4:	10800288 	cmpgei	r2,r2,10
 82476e8:	1000031e 	bne	r2,zero,82476f8 <hextoa+0x34>
      return (char)(val + '0');
 82476ec:	e0bfff17 	ldw	r2,-4(fp)
 82476f0:	10800c04 	addi	r2,r2,48
 82476f4:	00000206 	br	8247700 <hextoa+0x3c>
   else
      return (char)(val + 55);   /* converts 10-15 -> "A-F" */
 82476f8:	e0bfff17 	ldw	r2,-4(fp)
 82476fc:	10800dc4 	addi	r2,r2,55
}
 8247700:	e037883a 	mov	sp,fp
 8247704:	df000017 	ldw	fp,0(sp)
 8247708:	dec00104 	addi	sp,sp,4
 824770c:	f800283a 	ret

08247710 <inet_pton>:

char * pton_error = "";

int
inet_pton(int af, const char * src, void * dst)
{
 8247710:	defff804 	addi	sp,sp,-32
 8247714:	dfc00715 	stw	ra,28(sp)
 8247718:	df000615 	stw	fp,24(sp)
 824771c:	df000604 	addi	fp,sp,24
 8247720:	e13ffd15 	stw	r4,-12(fp)
 8247724:	e17ffe15 	stw	r5,-8(fp)
 8247728:	e1bfff15 	stw	r6,-4(fp)
   int            words;   /* count of words written to dest */
#endif

#if defined(IP_V4) || defined(MINI_IP)
   /* RFC 2133 wants us to support both types of address */
   if(af == AF_INET)    /* wants a v4 address */
 824772c:	e0bffd17 	ldw	r2,-12(fp)
 8247730:	10800098 	cmpnei	r2,r2,2
 8247734:	1000151e 	bne	r2,zero,824778c <inet_pton+0x7c>
   {
      u_long ip4addr;
      unsigned sbits;
      char * err;
      
      err = parse_ipad(&ip4addr, &sbits, (char *) src);
 8247738:	e0fffc04 	addi	r3,fp,-16
 824773c:	e0bffb04 	addi	r2,fp,-20
 8247740:	e1bffe17 	ldw	r6,-8(fp)
 8247744:	180b883a 	mov	r5,r3
 8247748:	1009883a 	mov	r4,r2
 824774c:	82473680 	call	8247368 <parse_ipad>
 8247750:	e0bffa15 	stw	r2,-24(fp)
      if(err == NULL)
 8247754:	e0bffa17 	ldw	r2,-24(fp)
 8247758:	1000071e 	bne	r2,zero,8247778 <inet_pton+0x68>
      {
         /* copy the parsed address into caller's buffer, and 
          * return success
          */
         MEMCPY(dst, &ip4addr, sizeof (u_long));
 824775c:	e0bffb04 	addi	r2,fp,-20
 8247760:	01800104 	movi	r6,4
 8247764:	100b883a 	mov	r5,r2
 8247768:	e13fff17 	ldw	r4,-4(fp)
 824776c:	8202e8c0 	call	8202e8c <memcpy>
         return 0;
 8247770:	0005883a 	mov	r2,zero
 8247774:	00000606 	br	8247790 <inet_pton+0x80>
      }
      else
      {
         /* return failure */
         pton_error = "IPv4 address parse failure";
 8247778:	00820974 	movhi	r2,2085
 824777c:	1086e104 	addi	r2,r2,7044
 8247780:	d0a05415 	stw	r2,-32432(gp)
         return 1;
 8247784:	00800044 	movi	r2,1
 8247788:	00000106 	br	8247790 <inet_pton+0x80>
      pton_error = "too short - missing colon?";
      return 1;
   }
   
#endif /* IP_V6 */   
   return 0;
 824778c:	0005883a 	mov	r2,zero
}
 8247790:	e037883a 	mov	sp,fp
 8247794:	dfc00117 	ldw	ra,4(sp)
 8247798:	df000017 	ldw	fp,0(sp)
 824779c:	dec00204 	addi	sp,sp,8
 82477a0:	f800283a 	ret

082477a4 <inet_ntop>:
 * address output (40 bytes).
 */

const char *
inet_ntop(int af, const void *addr, char *str, size_t size)
{
 82477a4:	defff804 	addi	sp,sp,-32
 82477a8:	dfc00715 	stw	ra,28(sp)
 82477ac:	df000615 	stw	fp,24(sp)
 82477b0:	df000604 	addi	fp,sp,24
 82477b4:	e13ffc15 	stw	r4,-16(fp)
 82477b8:	e17ffd15 	stw	r5,-12(fp)
 82477bc:	e1bffe15 	stw	r6,-8(fp)
 82477c0:	e1ffff15 	stw	r7,-4(fp)
   char *cp;

#if defined(IP_V4) || defined(MINI_IP)
   if (af == AF_INET)
 82477c4:	e0bffc17 	ldw	r2,-16(fp)
 82477c8:	10800098 	cmpnei	r2,r2,2
 82477cc:	1000101e 	bne	r2,zero,8247810 <inet_ntop+0x6c>
   {
      u_long   ip4addr;

      ip4addr = *(u_long*)addr;
 82477d0:	e0bffd17 	ldw	r2,-12(fp)
 82477d4:	10800017 	ldw	r2,0(r2)
 82477d8:	e0bffa15 	stw	r2,-24(fp)
      cp = print_ipad(ip4addr);
 82477dc:	e13ffa17 	ldw	r4,-24(fp)
 82477e0:	82289300 	call	8228930 <print_ipad>
 82477e4:	e0bffb15 	stw	r2,-20(fp)
      if (strlen(cp) < size)
 82477e8:	e13ffb17 	ldw	r4,-20(fp)
 82477ec:	8203edc0 	call	8203edc <strlen>
 82477f0:	1007883a 	mov	r3,r2
 82477f4:	e0bfff17 	ldw	r2,-4(fp)
 82477f8:	1880052e 	bgeu	r3,r2,8247810 <inet_ntop+0x6c>
      {
         strcpy(str, cp);
 82477fc:	e17ffb17 	ldw	r5,-20(fp)
 8247800:	e13ffe17 	ldw	r4,-8(fp)
 8247804:	824b6b80 	call	824b6b8 <strcpy>
         return (str);
 8247808:	e0bffe17 	ldw	r2,-8(fp)
 824780c:	00000106 	br	8247814 <inet_ntop+0x70>
         return (str);
      }
   }
#endif

   return ((const char *)NULL);
 8247810:	0005883a 	mov	r2,zero
}
 8247814:	e037883a 	mov	sp,fp
 8247818:	dfc00117 	ldw	ra,4(sp)
 824781c:	df000017 	ldw	fp,0(sp)
 8247820:	dec00204 	addi	sp,sp,8
 8247824:	f800283a 	ret

08247828 <print46_addr>:
 *
 * RETURNS: Pointer to string with the address in readable format.
 */

char * print46_addr(struct sockaddr *ipaddr)
{
 8247828:	defffc04 	addi	sp,sp,-16
 824782c:	dfc00315 	stw	ra,12(sp)
 8247830:	df000215 	stw	fp,8(sp)
 8247834:	df000204 	addi	fp,sp,8
 8247838:	e13fff15 	stw	r4,-4(fp)
   if (ipaddr->sa_family == AF_INET)
 824783c:	e0bfff17 	ldw	r2,-4(fp)
 8247840:	1080000b 	ldhu	r2,0(r2)
 8247844:	10bfffcc 	andi	r2,r2,65535
 8247848:	10800098 	cmpnei	r2,r2,2
 824784c:	1000071e 	bne	r2,zero,824786c <print46_addr+0x44>
   {
      struct sockaddr_in * addr = (struct sockaddr_in *)ipaddr;
 8247850:	e0bfff17 	ldw	r2,-4(fp)
 8247854:	e0bffe15 	stw	r2,-8(fp)
      return print_ipad(addr->sin_addr.s_addr);
 8247858:	e0bffe17 	ldw	r2,-8(fp)
 824785c:	10800117 	ldw	r2,4(r2)
 8247860:	1009883a 	mov	r4,r2
 8247864:	82289300 	call	8228930 <print_ipad>
 8247868:	00000106 	br	8247870 <print46_addr+0x48>
      static char namebuf[46];  /* max len of IPv6 addr */
      return (char *)inet_ntop(AF_INET6,&addr->sin6_addr, namebuf, sizeof(namebuf));
   }
#endif

   return NULL;
 824786c:	0005883a 	mov	r2,zero
}
 8247870:	e037883a 	mov	sp,fp
 8247874:	dfc00117 	ldw	ra,4(sp)
 8247878:	df000017 	ldw	fp,0(sp)
 824787c:	dec00204 	addi	sp,sp,8
 8247880:	f800283a 	ret

08247884 <inet46_addr>:
 *
 */

int 
inet46_addr(char * str, struct sockaddr *address)
{
 8247884:	defffb04 	addi	sp,sp,-20
 8247888:	dfc00415 	stw	ra,16(sp)
 824788c:	df000315 	stw	fp,12(sp)
 8247890:	df000304 	addi	fp,sp,12
 8247894:	e13ffe15 	stw	r4,-8(fp)
 8247898:	e17fff15 	stw	r5,-4(fp)
   /* Read the IPv4/IPv6 address */
   address->sa_family = AF_INET; /* assume IPv4 address by default */
 824789c:	e0bfff17 	ldw	r2,-4(fp)
 82478a0:	00c00084 	movi	r3,2
 82478a4:	10c0000d 	sth	r3,0(r2)

   if ((str[1] == '.') || (str[2] == '.') || (str[3] == '.'))
 82478a8:	e0bffe17 	ldw	r2,-8(fp)
 82478ac:	10800044 	addi	r2,r2,1
 82478b0:	10800003 	ldbu	r2,0(r2)
 82478b4:	10803fcc 	andi	r2,r2,255
 82478b8:	1080201c 	xori	r2,r2,128
 82478bc:	10bfe004 	addi	r2,r2,-128
 82478c0:	10800ba0 	cmpeqi	r2,r2,46
 82478c4:	1000101e 	bne	r2,zero,8247908 <inet46_addr+0x84>
 82478c8:	e0bffe17 	ldw	r2,-8(fp)
 82478cc:	10800084 	addi	r2,r2,2
 82478d0:	10800003 	ldbu	r2,0(r2)
 82478d4:	10803fcc 	andi	r2,r2,255
 82478d8:	1080201c 	xori	r2,r2,128
 82478dc:	10bfe004 	addi	r2,r2,-128
 82478e0:	10800ba0 	cmpeqi	r2,r2,46
 82478e4:	1000081e 	bne	r2,zero,8247908 <inet46_addr+0x84>
 82478e8:	e0bffe17 	ldw	r2,-8(fp)
 82478ec:	108000c4 	addi	r2,r2,3
 82478f0:	10800003 	ldbu	r2,0(r2)
 82478f4:	10803fcc 	andi	r2,r2,255
 82478f8:	1080201c 	xori	r2,r2,128
 82478fc:	10bfe004 	addi	r2,r2,-128
 8247900:	10800b98 	cmpnei	r2,r2,46
 8247904:	10000a1e 	bne	r2,zero,8247930 <inet46_addr+0xac>
   {
      struct sockaddr_in *addr = (struct sockaddr_in *)address;
 8247908:	e0bfff17 	ldw	r2,-4(fp)
 824790c:	e0bffd15 	stw	r2,-12(fp)
      addr->sin_addr.s_addr = inet_addr(str);
 8247910:	e13ffe17 	ldw	r4,-8(fp)
 8247914:	82476640 	call	8247664 <inet_addr>
 8247918:	1007883a 	mov	r3,r2
 824791c:	e0bffd17 	ldw	r2,-12(fp)
 8247920:	10c00115 	stw	r3,4(r2)
      addr->sin_family = AF_INET;
 8247924:	e0bffd17 	ldw	r2,-12(fp)
 8247928:	00c00084 	movi	r3,2
 824792c:	10c0000d 	sth	r3,0(r2)
      inet_pton(AF_INET6, str, &addr->sin6_addr);
      addr->sin6_family = AF_INET6;
   }
#endif

   return 0;
 8247930:	0005883a 	mov	r2,zero
}
 8247934:	e037883a 	mov	sp,fp
 8247938:	dfc00117 	ldw	ra,4(sp)
 824793c:	df000017 	ldw	fp,0(sp)
 8247940:	dec00204 	addi	sp,sp,8
 8247944:	f800283a 	ret

08247948 <inet_setport>:
 *
 * RETURNS: -
 */

void inet_setport(struct sockaddr *addr,int port) 
{
 8247948:	defffc04 	addi	sp,sp,-16
 824794c:	df000315 	stw	fp,12(sp)
 8247950:	df000304 	addi	fp,sp,12
 8247954:	e13ffe15 	stw	r4,-8(fp)
 8247958:	e17fff15 	stw	r5,-4(fp)
   if (addr->sa_family == AF_INET)
 824795c:	e0bffe17 	ldw	r2,-8(fp)
 8247960:	1080000b 	ldhu	r2,0(r2)
 8247964:	10bfffcc 	andi	r2,r2,65535
 8247968:	10800098 	cmpnei	r2,r2,2
 824796c:	10000c1e 	bne	r2,zero,82479a0 <inet_setport+0x58>
   {
      struct sockaddr_in *si = (struct sockaddr_in *)addr;
 8247970:	e0bffe17 	ldw	r2,-8(fp)
 8247974:	e0bffd15 	stw	r2,-12(fp)
      si->sin_port = htons(port);  
 8247978:	e0bfff17 	ldw	r2,-4(fp)
 824797c:	1005d23a 	srai	r2,r2,8
 8247980:	10803fcc 	andi	r2,r2,255
 8247984:	1007883a 	mov	r3,r2
 8247988:	e0bfff17 	ldw	r2,-4(fp)
 824798c:	1004923a 	slli	r2,r2,8
 8247990:	1884b03a 	or	r2,r3,r2
 8247994:	1007883a 	mov	r3,r2
 8247998:	e0bffd17 	ldw	r2,-12(fp)
 824799c:	10c0008d 	sth	r3,2(r2)
      struct sockaddr_in6 *si = (struct sockaddr_in6 *)addr;
      si->sin6_port = htons(port);
   }
#endif

}
 82479a0:	0001883a 	nop
 82479a4:	e037883a 	mov	sp,fp
 82479a8:	df000017 	ldw	fp,0(sp)
 82479ac:	dec00104 	addi	sp,sp,4
 82479b0:	f800283a 	ret

082479b4 <convert_ip>:
 *Returns:
 *
 */

unsigned long convert_ip(const char *p)
{
 82479b4:	defff904 	addi	sp,sp,-28
 82479b8:	df000615 	stw	fp,24(sp)
 82479bc:	df000604 	addi	fp,sp,24
 82479c0:	e13fff15 	stw	r4,-4(fp)
   const char *cp = p;
 82479c4:	e0bfff17 	ldw	r2,-4(fp)
 82479c8:	e0bffa15 	stw	r2,-24(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
 82479cc:	e0bffe04 	addi	r2,fp,-8
 82479d0:	e0bffd15 	stw	r2,-12(fp)
   int n = 0;
 82479d4:	e03ffb15 	stw	zero,-20(fp)
   unsigned short v = 0;
 82479d8:	e03ffc0d 	sth	zero,-16(fp)
   dw = 0;
 82479dc:	e03ffe15 	stw	zero,-8(fp)
   while(*cp)
 82479e0:	00003106 	br	8247aa8 <convert_ip+0xf4>
   {
      if( *cp == '.')
 82479e4:	e0bffa17 	ldw	r2,-24(fp)
 82479e8:	10800003 	ldbu	r2,0(r2)
 82479ec:	10803fcc 	andi	r2,r2,255
 82479f0:	1080201c 	xori	r2,r2,128
 82479f4:	10bfe004 	addi	r2,r2,-128
 82479f8:	10800b98 	cmpnei	r2,r2,46
 82479fc:	10000e1e 	bne	r2,zero,8247a38 <convert_ip+0x84>
      {
         lpb[n] = (unsigned char) v;
 8247a00:	e0bffb17 	ldw	r2,-20(fp)
 8247a04:	e0fffd17 	ldw	r3,-12(fp)
 8247a08:	1885883a 	add	r2,r3,r2
 8247a0c:	e0fffc0b 	ldhu	r3,-16(fp)
 8247a10:	10c00005 	stb	r3,0(r2)
         v = 0;
 8247a14:	e03ffc0d 	sth	zero,-16(fp)
         n++;
 8247a18:	e0bffb17 	ldw	r2,-20(fp)
 8247a1c:	10800044 	addi	r2,r2,1
 8247a20:	e0bffb15 	stw	r2,-20(fp)
         if(n > 3)
 8247a24:	e0bffb17 	ldw	r2,-20(fp)
 8247a28:	10800110 	cmplti	r2,r2,4
 8247a2c:	10001b1e 	bne	r2,zero,8247a9c <convert_ip+0xe8>
         {
            return dw;
 8247a30:	e0bffe17 	ldw	r2,-8(fp)
 8247a34:	00002806 	br	8247ad8 <convert_ip+0x124>
         }
      }
      else if(((*cp >= '0') && (*cp <= '9')))
 8247a38:	e0bffa17 	ldw	r2,-24(fp)
 8247a3c:	10800003 	ldbu	r2,0(r2)
 8247a40:	10803fcc 	andi	r2,r2,255
 8247a44:	1080201c 	xori	r2,r2,128
 8247a48:	10bfe004 	addi	r2,r2,-128
 8247a4c:	10800c10 	cmplti	r2,r2,48
 8247a50:	1000121e 	bne	r2,zero,8247a9c <convert_ip+0xe8>
 8247a54:	e0bffa17 	ldw	r2,-24(fp)
 8247a58:	10800003 	ldbu	r2,0(r2)
 8247a5c:	10803fcc 	andi	r2,r2,255
 8247a60:	1080201c 	xori	r2,r2,128
 8247a64:	10bfe004 	addi	r2,r2,-128
 8247a68:	10800e88 	cmpgei	r2,r2,58
 8247a6c:	10000b1e 	bne	r2,zero,8247a9c <convert_ip+0xe8>
      {
         v = (v * 10) + (*cp - '0');
 8247a70:	e0bffc0b 	ldhu	r2,-16(fp)
 8247a74:	108002a4 	muli	r2,r2,10
 8247a78:	1007883a 	mov	r3,r2
 8247a7c:	e0bffa17 	ldw	r2,-24(fp)
 8247a80:	10800003 	ldbu	r2,0(r2)
 8247a84:	10803fcc 	andi	r2,r2,255
 8247a88:	1080201c 	xori	r2,r2,128
 8247a8c:	10bfe004 	addi	r2,r2,-128
 8247a90:	1885883a 	add	r2,r3,r2
 8247a94:	10bff404 	addi	r2,r2,-48
 8247a98:	e0bffc0d 	sth	r2,-16(fp)
      }
      cp++;
 8247a9c:	e0bffa17 	ldw	r2,-24(fp)
 8247aa0:	10800044 	addi	r2,r2,1
 8247aa4:	e0bffa15 	stw	r2,-24(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
   int n = 0;
   unsigned short v = 0;
   dw = 0;
   while(*cp)
 8247aa8:	e0bffa17 	ldw	r2,-24(fp)
 8247aac:	10800003 	ldbu	r2,0(r2)
 8247ab0:	10803fcc 	andi	r2,r2,255
 8247ab4:	1080201c 	xori	r2,r2,128
 8247ab8:	10bfe004 	addi	r2,r2,-128
 8247abc:	103fc91e 	bne	r2,zero,82479e4 <convert_ip+0x30>
      {
         v = (v * 10) + (*cp - '0');
      }
      cp++;
   }
   lpb[n] = (unsigned char) v;
 8247ac0:	e0bffb17 	ldw	r2,-20(fp)
 8247ac4:	e0fffd17 	ldw	r3,-12(fp)
 8247ac8:	1885883a 	add	r2,r3,r2
 8247acc:	e0fffc0b 	ldhu	r3,-16(fp)
 8247ad0:	10c00005 	stb	r3,0(r2)
   return dw;
 8247ad4:	e0bffe17 	ldw	r2,-8(fp)
}  /* convert_ip() */
 8247ad8:	e037883a 	mov	sp,fp
 8247adc:	df000017 	ldw	fp,0(sp)
 8247ae0:	dec00104 	addi	sp,sp,4
 8247ae4:	f800283a 	ret

08247ae8 <tcp_cksum>:
 * RETURNS: 
 */

unshort
tcp_cksum(struct ip * pip)
{
 8247ae8:	defff704 	addi	sp,sp,-36
 8247aec:	dfc00815 	stw	ra,32(sp)
 8247af0:	df000715 	stw	fp,28(sp)
 8247af4:	df000704 	addi	fp,sp,28
 8247af8:	e13fff15 	stw	r4,-4(fp)
   unshort  oldsum;
   unshort  newsum;
   struct tcphdr * tp;

#ifdef MUTE_WARNS    /* stifle compiler warnings */
   tcpdata = (char *)NULL;
 8247afc:	e03ffa15 	stw	zero,-24(fp)
#endif   /* MUTE_WARNS */

   IN_PROFILER(PF_TSUM, PF_ENTRY);

   oddchar = 0;
 8247b00:	e03ffb05 	stb	zero,-20(fp)

   iphlen = (unshort)ip_hlen(pip);
 8247b04:	e0bfff17 	ldw	r2,-4(fp)
 8247b08:	10800003 	ldbu	r2,0(r2)
 8247b0c:	10803fcc 	andi	r2,r2,255
 8247b10:	108003cc 	andi	r2,r2,15
 8247b14:	1085883a 	add	r2,r2,r2
 8247b18:	1085883a 	add	r2,r2,r2
 8247b1c:	e0bffc0d 	sth	r2,-16(fp)
   tcplen = htons(pip->ip_len) - iphlen;
 8247b20:	e0bfff17 	ldw	r2,-4(fp)
 8247b24:	1080008b 	ldhu	r2,2(r2)
 8247b28:	10bfffcc 	andi	r2,r2,65535
 8247b2c:	1004d23a 	srli	r2,r2,8
 8247b30:	1007883a 	mov	r3,r2
 8247b34:	e0bfff17 	ldw	r2,-4(fp)
 8247b38:	1080008b 	ldhu	r2,2(r2)
 8247b3c:	10bfffcc 	andi	r2,r2,65535
 8247b40:	1004923a 	slli	r2,r2,8
 8247b44:	1884b03a 	or	r2,r3,r2
 8247b48:	1007883a 	mov	r3,r2
 8247b4c:	e0bffc0b 	ldhu	r2,-16(fp)
 8247b50:	1885c83a 	sub	r2,r3,r2
 8247b54:	e0bff90d 	sth	r2,-28(fp)

   tp = (struct tcphdr*)ip_data(pip);     /* get TCP header */
 8247b58:	e0bfff17 	ldw	r2,-4(fp)
 8247b5c:	10800003 	ldbu	r2,0(r2)
 8247b60:	10803fcc 	andi	r2,r2,255
 8247b64:	108003cc 	andi	r2,r2,15
 8247b68:	1085883a 	add	r2,r2,r2
 8247b6c:	1085883a 	add	r2,r2,r2
 8247b70:	1007883a 	mov	r3,r2
 8247b74:	e0bfff17 	ldw	r2,-4(fp)
 8247b78:	10c5883a 	add	r2,r2,r3
 8247b7c:	e0bffd15 	stw	r2,-12(fp)
   oldsum = tp->th_sum;       /* Save passed checksum */
 8247b80:	e0bffd17 	ldw	r2,-12(fp)
 8247b84:	1080040b 	ldhu	r2,16(r2)
 8247b88:	e0bffe0d 	sth	r2,-8(fp)
    * cannot overflow a 16 bit field) and put them in the cksum field. 
    * We include the IP addresses by passing them to the lower level 
    * fast sum routine. This results in their values being factored into 
    * the sum and the cksum field contributes zero.
    */
   tp->th_sum = htons(tcplen + 6);
 8247b8c:	e0bff90b 	ldhu	r2,-28(fp)
 8247b90:	10800184 	addi	r2,r2,6
 8247b94:	1005d23a 	srai	r2,r2,8
 8247b98:	10803fcc 	andi	r2,r2,255
 8247b9c:	1007883a 	mov	r3,r2
 8247ba0:	e0bff90b 	ldhu	r2,-28(fp)
 8247ba4:	10800184 	addi	r2,r2,6
 8247ba8:	1004923a 	slli	r2,r2,8
 8247bac:	1884b03a 	or	r2,r3,r2
 8247bb0:	1007883a 	mov	r3,r2
 8247bb4:	e0bffd17 	ldw	r2,-12(fp)
 8247bb8:	10c0040d 	sth	r3,16(r2)

   /* zero pad odd sized packets for checksumming */
   if (tcplen & 1)   
 8247bbc:	e0bff90b 	ldhu	r2,-28(fp)
 8247bc0:	1080004c 	andi	r2,r2,1
 8247bc4:	10000e26 	beq	r2,zero,8247c00 <tcp_cksum+0x118>
   {
      tcpdata = ((char*)pip) + iphlen + tcplen;    /* end of packet */
 8247bc8:	e0fffc0b 	ldhu	r3,-16(fp)
 8247bcc:	e0bff90b 	ldhu	r2,-28(fp)
 8247bd0:	1885883a 	add	r2,r3,r2
 8247bd4:	e0ffff17 	ldw	r3,-4(fp)
 8247bd8:	1885883a 	add	r2,r3,r2
 8247bdc:	e0bffa15 	stw	r2,-24(fp)
      oddchar = *tcpdata;
 8247be0:	e0bffa17 	ldw	r2,-24(fp)
 8247be4:	10800003 	ldbu	r2,0(r2)
 8247be8:	e0bffb05 	stb	r2,-20(fp)
      *tcpdata = '\0';        /* zero out pad byte */
 8247bec:	e0bffa17 	ldw	r2,-24(fp)
 8247bf0:	10000005 	stb	zero,0(r2)
      tcplen++;               /* bump length to pass to cksum() */
 8247bf4:	e0bff90b 	ldhu	r2,-28(fp)
 8247bf8:	10800044 	addi	r2,r2,1
 8247bfc:	e0bff90d 	sth	r2,-28(fp)

   /* Pass a pointer to the beginning of the IP address area into the IP header
    * the the low level sum routine. Add the size of these two IP addresses to
    * the length, and convert the length to 16 bit words.
    */
   newsum = ~cksum(((char*)tp) - 8, (tcplen + 8) >> 1);
 8247c00:	e0bffd17 	ldw	r2,-12(fp)
 8247c04:	10fffe04 	addi	r3,r2,-8
 8247c08:	e0bff90b 	ldhu	r2,-28(fp)
 8247c0c:	10800204 	addi	r2,r2,8
 8247c10:	1005d07a 	srai	r2,r2,1
 8247c14:	100b883a 	mov	r5,r2
 8247c18:	1809883a 	mov	r4,r3
 8247c1c:	82286f00 	call	82286f0 <cksum>
 8247c20:	0084303a 	nor	r2,zero,r2
 8247c24:	e0bffb8d 	sth	r2,-18(fp)

   /* If the old checksum is 0xffff, but the actual checksum is 0x0000,
    * declare that to be a match.
    */
   if ((newsum != oldsum) && (oldsum == 0xffff) && (newsum == 0x0000))
 8247c28:	e0fffb8b 	ldhu	r3,-18(fp)
 8247c2c:	e0bffe0b 	ldhu	r2,-8(fp)
 8247c30:	18800726 	beq	r3,r2,8247c50 <tcp_cksum+0x168>
 8247c34:	e0fffe0b 	ldhu	r3,-8(fp)
 8247c38:	00bfffd4 	movui	r2,65535
 8247c3c:	1880041e 	bne	r3,r2,8247c50 <tcp_cksum+0x168>
 8247c40:	e0bffb8b 	ldhu	r2,-18(fp)
 8247c44:	1000021e 	bne	r2,zero,8247c50 <tcp_cksum+0x168>
      newsum = 0xffff;
 8247c48:	00bfffc4 	movi	r2,-1
 8247c4c:	e0bffb8d 	sth	r2,-18(fp)

   /* restore what we clobbered */
   tp->th_sum = oldsum;       /* put back passed checksum */
 8247c50:	e0bffd17 	ldw	r2,-12(fp)
 8247c54:	e0fffe0b 	ldhu	r3,-8(fp)
 8247c58:	10c0040d 	sth	r3,16(r2)
   if (oddchar)
 8247c5c:	e0bffb07 	ldb	r2,-20(fp)
 8247c60:	10000326 	beq	r2,zero,8247c70 <tcp_cksum+0x188>
      *tcpdata = oddchar;     /* restore odd byte if we zeroed it */
 8247c64:	e0bffa17 	ldw	r2,-24(fp)
 8247c68:	e0fffb03 	ldbu	r3,-20(fp)
 8247c6c:	10c00005 	stb	r3,0(r2)

   IN_PROFILER(PF_TSUM, PF_EXIT);

   return newsum;
 8247c70:	e0bffb8b 	ldhu	r2,-18(fp)
}
 8247c74:	e037883a 	mov	sp,fp
 8247c78:	dfc00117 	ldw	ra,4(sp)
 8247c7c:	df000017 	ldw	fp,0(sp)
 8247c80:	dec00204 	addi	sp,sp,8
 8247c84:	f800283a 	ret

08247c88 <in_pcballoc>:
 */

int
in_pcballoc(struct socket * so, 
   struct inpcb * head)
{
 8247c88:	defffb04 	addi	sp,sp,-20
 8247c8c:	dfc00415 	stw	ra,16(sp)
 8247c90:	df000315 	stw	fp,12(sp)
 8247c94:	df000304 	addi	fp,sp,12
 8247c98:	e13ffe15 	stw	r4,-8(fp)
 8247c9c:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;

   inp = INP_ALLOC (sizeof (*inp));
 8247ca0:	01000b04 	movi	r4,44
 8247ca4:	822dfec0 	call	822dfec <npalloc>
 8247ca8:	e0bffd15 	stw	r2,-12(fp)
   if (inp == 0)
 8247cac:	e0bffd17 	ldw	r2,-12(fp)
 8247cb0:	1000021e 	bne	r2,zero,8247cbc <in_pcballoc+0x34>
      return ENOMEM;
 8247cb4:	00800304 	movi	r2,12
 8247cb8:	00001006 	br	8247cfc <in_pcballoc+0x74>
   inp->inp_head = head;
 8247cbc:	e0bffd17 	ldw	r2,-12(fp)
 8247cc0:	e0ffff17 	ldw	r3,-4(fp)
 8247cc4:	10c00215 	stw	r3,8(r2)
   inp->inp_socket = so;
 8247cc8:	e0bffd17 	ldw	r2,-12(fp)
 8247ccc:	e0fffe17 	ldw	r3,-8(fp)
 8247cd0:	10c00815 	stw	r3,32(r2)

   /* Set Path MTU to a very small default. It should get expanded 
    * later by v4 or v6 specific SYN code. We don't want it zero 
    * in case it doesn't get expanded promptly.
    */
   inp->inp_pmtu = 512;
 8247cd4:	e0bffd17 	ldw	r2,-12(fp)
 8247cd8:	00c08004 	movi	r3,512
 8247cdc:	10c00615 	stw	r3,24(r2)
   insque(inp, head);
 8247ce0:	e17fff17 	ldw	r5,-4(fp)
 8247ce4:	e13ffd17 	ldw	r4,-12(fp)
 8247ce8:	822eb100 	call	822eb10 <insque>
   so->so_pcb = inp;
 8247cec:	e0bffe17 	ldw	r2,-8(fp)
 8247cf0:	e0fffd17 	ldw	r3,-12(fp)
 8247cf4:	10c00115 	stw	r3,4(r2)
   return 0;
 8247cf8:	0005883a 	mov	r2,zero
}
 8247cfc:	e037883a 	mov	sp,fp
 8247d00:	dfc00117 	ldw	ra,4(sp)
 8247d04:	df000017 	ldw	fp,0(sp)
 8247d08:	dec00204 	addi	sp,sp,8
 8247d0c:	f800283a 	ret

08247d10 <in_pcbdetach>:
 * RETURNS: 
 */

void
in_pcbdetach(struct inpcb * inp)
{
 8247d10:	defffc04 	addi	sp,sp,-16
 8247d14:	dfc00315 	stw	ra,12(sp)
 8247d18:	df000215 	stw	fp,8(sp)
 8247d1c:	df000204 	addi	fp,sp,8
 8247d20:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  inp->inp_socket;
 8247d24:	e0bfff17 	ldw	r2,-4(fp)
 8247d28:	10800817 	ldw	r2,32(r2)
 8247d2c:	e0bffe15 	stw	r2,-8(fp)

   so->so_pcb = 0;
 8247d30:	e0bffe17 	ldw	r2,-8(fp)
 8247d34:	10000115 	stw	zero,4(r2)
   sofree(so);
 8247d38:	e13ffe17 	ldw	r4,-8(fp)
 8247d3c:	8231b880 	call	8231b88 <sofree>
   remque(inp);
 8247d40:	e13fff17 	ldw	r4,-4(fp)
 8247d44:	822eaa00 	call	822eaa0 <remque>
   INP_FREE (inp);
 8247d48:	e13fff17 	ldw	r4,-4(fp)
 8247d4c:	822e0200 	call	822e020 <npfree>
}
 8247d50:	0001883a 	nop
 8247d54:	e037883a 	mov	sp,fp
 8247d58:	dfc00117 	ldw	ra,4(sp)
 8247d5c:	df000017 	ldw	fp,0(sp)
 8247d60:	dec00204 	addi	sp,sp,8
 8247d64:	f800283a 	ret

08247d68 <in_pcbbind>:

int
in_pcbbind(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 8247d68:	defff504 	addi	sp,sp,-44
 8247d6c:	dfc00a15 	stw	ra,40(sp)
 8247d70:	df000915 	stw	fp,36(sp)
 8247d74:	df000904 	addi	fp,sp,36
 8247d78:	e13ffe15 	stw	r4,-8(fp)
 8247d7c:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  inp->inp_socket;
 8247d80:	e0bffe17 	ldw	r2,-8(fp)
 8247d84:	10800817 	ldw	r2,32(r2)
 8247d88:	e0bffb15 	stw	r2,-20(fp)
   struct inpcb * head  =  inp->inp_head;
 8247d8c:	e0bffe17 	ldw	r2,-8(fp)
 8247d90:	10800217 	ldw	r2,8(r2)
 8247d94:	e0bffc15 	stw	r2,-16(fp)
   struct sockaddr_in * sin;
   u_short  lport =  0;
 8247d98:	e03ff90d 	sth	zero,-28(fp)


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
 8247d9c:	e0bffe17 	ldw	r2,-8(fp)
 8247da0:	1080078b 	ldhu	r2,30(r2)
 8247da4:	10bfffcc 	andi	r2,r2,65535
 8247da8:	1000031e 	bne	r2,zero,8247db8 <in_pcbbind+0x50>
 8247dac:	e0bffe17 	ldw	r2,-8(fp)
 8247db0:	10800417 	ldw	r2,16(r2)
 8247db4:	10000226 	beq	r2,zero,8247dc0 <in_pcbbind+0x58>
      return (EINVAL);
 8247db8:	00800584 	movi	r2,22
 8247dbc:	00006906 	br	8247f64 <in_pcbbind+0x1fc>
   if (nam == 0)
 8247dc0:	e0bfff17 	ldw	r2,-4(fp)
 8247dc4:	10003926 	beq	r2,zero,8247eac <in_pcbbind+0x144>
      goto noname;
   sin = mtod(nam, struct sockaddr_in *);
 8247dc8:	e0bfff17 	ldw	r2,-4(fp)
 8247dcc:	10800317 	ldw	r2,12(r2)
 8247dd0:	e0bffd15 	stw	r2,-12(fp)
   /*
    * removed test here for "if (nam->m_len != sizeof (*sin))"
    * since it really complicatges supporting dual IPv4/v6, and 
    * the 2.0 stack now checks this in t_bind(). -JB-
    */
   if (sin->sin_addr.s_addr != INADDR_ANY) 
 8247dd4:	e0bffd17 	ldw	r2,-12(fp)
 8247dd8:	10800117 	ldw	r2,4(r2)
 8247ddc:	10000a26 	beq	r2,zero,8247e08 <in_pcbbind+0xa0>
   {
      if (ip_mymach(sin->sin_addr.s_addr) != sin->sin_addr.s_addr)
 8247de0:	e0bffd17 	ldw	r2,-12(fp)
 8247de4:	10800117 	ldw	r2,4(r2)
 8247de8:	1009883a 	mov	r4,r2
 8247dec:	82408000 	call	8240800 <ip_mymach>
 8247df0:	1007883a 	mov	r3,r2
 8247df4:	e0bffd17 	ldw	r2,-12(fp)
 8247df8:	10800117 	ldw	r2,4(r2)
 8247dfc:	18800226 	beq	r3,r2,8247e08 <in_pcbbind+0xa0>
      return (EADDRNOTAVAIL);
 8247e00:	00801f44 	movi	r2,125
 8247e04:	00005706 	br	8247f64 <in_pcbbind+0x1fc>
   }
   lport = sin->sin_port;
 8247e08:	e0bffd17 	ldw	r2,-12(fp)
 8247e0c:	1080008b 	ldhu	r2,2(r2)
 8247e10:	e0bff90d 	sth	r2,-28(fp)
   if (lport) 
 8247e14:	e0bff90b 	ldhu	r2,-28(fp)
 8247e18:	10001f26 	beq	r2,zero,8247e98 <in_pcbbind+0x130>
   {
      int   wild  =  0;
 8247e1c:	e03ffa15 	stw	zero,-24(fp)

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 8247e20:	e0bffb17 	ldw	r2,-20(fp)
 8247e24:	10800417 	ldw	r2,16(r2)
 8247e28:	1080010c 	andi	r2,r2,4
 8247e2c:	10000c1e 	bne	r2,zero,8247e60 <in_pcbbind+0xf8>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
 8247e30:	e0bffb17 	ldw	r2,-20(fp)
 8247e34:	10800217 	ldw	r2,8(r2)
 8247e38:	1080010b 	ldhu	r2,4(r2)
 8247e3c:	10bfffcc 	andi	r2,r2,65535
 8247e40:	1080010c 	andi	r2,r2,4
   if (lport) 
   {
      int   wild  =  0;

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 8247e44:	10000426 	beq	r2,zero,8247e58 <in_pcbbind+0xf0>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
          (so->so_options & SO_ACCEPTCONN) == 0))
 8247e48:	e0bffb17 	ldw	r2,-20(fp)
 8247e4c:	10800417 	ldw	r2,16(r2)
 8247e50:	1080008c 	andi	r2,r2,2
   {
      int   wild  =  0;

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
 8247e54:	1000021e 	bne	r2,zero,8247e60 <in_pcbbind+0xf8>
          (so->so_options & SO_ACCEPTCONN) == 0))
      {
         wild = INPLOOKUP_WILDCARD;
 8247e58:	00800044 	movi	r2,1
 8247e5c:	e0bffa15 	stw	r2,-24(fp)
      }
      if (in_pcblookup(head,
 8247e60:	e0bffd17 	ldw	r2,-12(fp)
 8247e64:	11000117 	ldw	r4,4(r2)
 8247e68:	e0bff90b 	ldhu	r2,-28(fp)
 8247e6c:	e0fffa17 	ldw	r3,-24(fp)
 8247e70:	d8c00115 	stw	r3,4(sp)
 8247e74:	d8800015 	stw	r2,0(sp)
 8247e78:	200f883a 	mov	r7,r4
 8247e7c:	000d883a 	mov	r6,zero
 8247e80:	000b883a 	mov	r5,zero
 8247e84:	e13ffc17 	ldw	r4,-16(fp)
 8247e88:	82482bc0 	call	82482bc <in_pcblookup>
 8247e8c:	10000226 	beq	r2,zero,8247e98 <in_pcbbind+0x130>
          0L, 0, sin->sin_addr.s_addr, lport, wild))
      {
         return (EADDRINUSE);
 8247e90:	00801c04 	movi	r2,112
 8247e94:	00003306 	br	8247f64 <in_pcbbind+0x1fc>
      }
   }
   inp->inp_laddr = sin->sin_addr;
 8247e98:	e0bffe17 	ldw	r2,-8(fp)
 8247e9c:	e0fffd17 	ldw	r3,-12(fp)
 8247ea0:	18c00117 	ldw	r3,4(r3)
 8247ea4:	10c00415 	stw	r3,16(r2)
 8247ea8:	00000106 	br	8247eb0 <in_pcbbind+0x148>


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
      return (EINVAL);
   if (nam == 0)
      goto noname;
 8247eac:	0001883a 	nop
         return (EADDRINUSE);
      }
   }
   inp->inp_laddr = sin->sin_addr;
noname:
   if (lport == 0)
 8247eb0:	e0bff90b 	ldhu	r2,-28(fp)
 8247eb4:	1000271e 	bne	r2,zero,8247f54 <in_pcbbind+0x1ec>
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 8247eb8:	e0bffc17 	ldw	r2,-16(fp)
 8247ebc:	1080078b 	ldhu	r2,30(r2)
 8247ec0:	10c00044 	addi	r3,r2,1
 8247ec4:	1809883a 	mov	r4,r3
 8247ec8:	e0fffc17 	ldw	r3,-16(fp)
 8247ecc:	1900078d 	sth	r4,30(r3)
 8247ed0:	10bfffcc 	andi	r2,r2,65535
 8247ed4:	10810030 	cmpltui	r2,r2,1024
 8247ed8:	1000051e 	bne	r2,zero,8247ef0 <in_pcbbind+0x188>
             head->inp_lport > IPPORT_USERRESERVED)
 8247edc:	e0bffc17 	ldw	r2,-16(fp)
 8247ee0:	1080078b 	ldhu	r2,30(r2)
noname:
   if (lport == 0)
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 8247ee4:	10bfffcc 	andi	r2,r2,65535
 8247ee8:	1084e270 	cmpltui	r2,r2,5001
 8247eec:	1000031e 	bne	r2,zero,8247efc <in_pcbbind+0x194>
             head->inp_lport > IPPORT_USERRESERVED)
         {
            head->inp_lport = IPPORT_RESERVED;
 8247ef0:	e0bffc17 	ldw	r2,-16(fp)
 8247ef4:	00c10004 	movi	r3,1024
 8247ef8:	10c0078d 	sth	r3,30(r2)
         }
         lport = htons(head->inp_lport);
 8247efc:	e0bffc17 	ldw	r2,-16(fp)
 8247f00:	1080078b 	ldhu	r2,30(r2)
 8247f04:	10bfffcc 	andi	r2,r2,65535
 8247f08:	1004d23a 	srli	r2,r2,8
 8247f0c:	1007883a 	mov	r3,r2
 8247f10:	e0bffc17 	ldw	r2,-16(fp)
 8247f14:	1080078b 	ldhu	r2,30(r2)
 8247f18:	10bfffcc 	andi	r2,r2,65535
 8247f1c:	1004923a 	slli	r2,r2,8
 8247f20:	1884b03a 	or	r2,r3,r2
 8247f24:	e0bff90d 	sth	r2,-28(fp)
      } while(in_pcblookup(head, 0L, 0, inp->inp_laddr.s_addr, lport, 0));
 8247f28:	e0bffe17 	ldw	r2,-8(fp)
 8247f2c:	10c00417 	ldw	r3,16(r2)
 8247f30:	e0bff90b 	ldhu	r2,-28(fp)
 8247f34:	d8000115 	stw	zero,4(sp)
 8247f38:	d8800015 	stw	r2,0(sp)
 8247f3c:	180f883a 	mov	r7,r3
 8247f40:	000d883a 	mov	r6,zero
 8247f44:	000b883a 	mov	r5,zero
 8247f48:	e13ffc17 	ldw	r4,-16(fp)
 8247f4c:	82482bc0 	call	82482bc <in_pcblookup>
 8247f50:	103fd91e 	bne	r2,zero,8247eb8 <in_pcbbind+0x150>
   }
   inp->inp_lport = lport;
 8247f54:	e0bffe17 	ldw	r2,-8(fp)
 8247f58:	e0fff90b 	ldhu	r3,-28(fp)
 8247f5c:	10c0078d 	sth	r3,30(r2)
   return (0);
 8247f60:	0005883a 	mov	r2,zero
}
 8247f64:	e037883a 	mov	sp,fp
 8247f68:	dfc00117 	ldw	ra,4(sp)
 8247f6c:	df000017 	ldw	fp,0(sp)
 8247f70:	dec00204 	addi	sp,sp,8
 8247f74:	f800283a 	ret

08247f78 <in_pcbconnect>:
 */

int
in_pcbconnect(struct inpcb * inp, 
   struct mbuf *  nam)
{
 8247f78:	defff604 	addi	sp,sp,-40
 8247f7c:	dfc00915 	stw	ra,36(sp)
 8247f80:	df000815 	stw	fp,32(sp)
 8247f84:	df000804 	addi	fp,sp,32
 8247f88:	e13ffe15 	stw	r4,-8(fp)
 8247f8c:	e17fff15 	stw	r5,-4(fp)
   unsigned long ifaddr;
   struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 8247f90:	e0bfff17 	ldw	r2,-4(fp)
 8247f94:	10800317 	ldw	r2,12(r2)
 8247f98:	e0bffb15 	stw	r2,-20(fp)

   if (nam->m_len < sizeof (*sin))
 8247f9c:	e0bfff17 	ldw	r2,-4(fp)
 8247fa0:	10800217 	ldw	r2,8(r2)
 8247fa4:	10800428 	cmpgeui	r2,r2,16
 8247fa8:	1000021e 	bne	r2,zero,8247fb4 <in_pcbconnect+0x3c>
      return (EINVAL);
 8247fac:	00800584 	movi	r2,22
 8247fb0:	00006406 	br	8248144 <in_pcbconnect+0x1cc>
   if (sin->sin_family != AF_INET)
 8247fb4:	e0bffb17 	ldw	r2,-20(fp)
 8247fb8:	1080000b 	ldhu	r2,0(r2)
 8247fbc:	10bfffcc 	andi	r2,r2,65535
 8247fc0:	10a0001c 	xori	r2,r2,32768
 8247fc4:	10a00004 	addi	r2,r2,-32768
 8247fc8:	108000a0 	cmpeqi	r2,r2,2
 8247fcc:	1000021e 	bne	r2,zero,8247fd8 <in_pcbconnect+0x60>
      return (EAFNOSUPPORT);
 8247fd0:	00801a84 	movi	r2,106
 8247fd4:	00005b06 	br	8248144 <in_pcbconnect+0x1cc>
   if (sin->sin_port == 0)
 8247fd8:	e0bffb17 	ldw	r2,-20(fp)
 8247fdc:	1080008b 	ldhu	r2,2(r2)
 8247fe0:	10bfffcc 	andi	r2,r2,65535
 8247fe4:	1000021e 	bne	r2,zero,8247ff0 <in_pcbconnect+0x78>
      return (EADDRNOTAVAIL);
 8247fe8:	00801f44 	movi	r2,125
 8247fec:	00005506 	br	8248144 <in_pcbconnect+0x1cc>
    * use the primary local address.
    * If the supplied address is INADDR_BROADCAST,
    * and the primary interface supports broadcast,
    * choose the broadcast address for that interface.
    */
   if (sin->sin_addr.s_addr == INADDR_ANY)
 8247ff0:	e0bffb17 	ldw	r2,-20(fp)
 8247ff4:	10800117 	ldw	r2,4(r2)
 8247ff8:	10000d1e 	bne	r2,zero,8248030 <in_pcbconnect+0xb8>
   {
      if (inp && inp->ifp)
 8247ffc:	e0bffe17 	ldw	r2,-8(fp)
 8248000:	10000926 	beq	r2,zero,8248028 <in_pcbconnect+0xb0>
 8248004:	e0bffe17 	ldw	r2,-8(fp)
 8248008:	10800a17 	ldw	r2,40(r2)
 824800c:	10000626 	beq	r2,zero,8248028 <in_pcbconnect+0xb0>
         sin->sin_addr.s_addr = inp->ifp->n_ipaddr;
 8248010:	e0bffe17 	ldw	r2,-8(fp)
 8248014:	10800a17 	ldw	r2,40(r2)
 8248018:	10c00a17 	ldw	r3,40(r2)
 824801c:	e0bffb17 	ldw	r2,-20(fp)
 8248020:	10c00115 	stw	r3,4(r2)
 8248024:	00000806 	br	8248048 <in_pcbconnect+0xd0>
      else
         return (EADDRNOTAVAIL);
 8248028:	00801f44 	movi	r2,125
 824802c:	00004506 	br	8248144 <in_pcbconnect+0x1cc>
   }
   else if (sin->sin_addr.s_addr == INADDR_BROADCAST)
 8248030:	e0bffb17 	ldw	r2,-20(fp)
 8248034:	10800117 	ldw	r2,4(r2)
 8248038:	10bfffd8 	cmpnei	r2,r2,-1
 824803c:	1000021e 	bne	r2,zero,8248048 <in_pcbconnect+0xd0>
      return (EADDRNOTAVAIL);
 8248040:	00801f44 	movi	r2,125
 8248044:	00003f06 	br	8248144 <in_pcbconnect+0x1cc>


   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 8248048:	e0bffe17 	ldw	r2,-8(fp)
 824804c:	10800417 	ldw	r2,16(r2)
 8248050:	10000f1e 	bne	r2,zero,8248090 <in_pcbconnect+0x118>
   {
#ifdef MULTI_HOMED
      ip_addr hop1;     /* dummy for pass to iproute() */
      NET npnet;     /* the netport iface we can send on */
      /* call netport stack's IP routing */
      npnet = iproute(sin->sin_addr.s_addr, &hop1);
 8248054:	e0bffb17 	ldw	r2,-20(fp)
 8248058:	10800117 	ldw	r2,4(r2)
 824805c:	e0fffd04 	addi	r3,fp,-12
 8248060:	180b883a 	mov	r5,r3
 8248064:	1009883a 	mov	r4,r2
 8248068:	8240b4c0 	call	8240b4c <iproute>
 824806c:	e0bffc15 	stw	r2,-16(fp)
      if (!npnet)
 8248070:	e0bffc17 	ldw	r2,-16(fp)
 8248074:	1000021e 	bne	r2,zero,8248080 <in_pcbconnect+0x108>
         return EADDRNOTAVAIL;
 8248078:	00801f44 	movi	r2,125
 824807c:	00003106 	br	8248144 <in_pcbconnect+0x1cc>
      ifaddr = npnet->n_ipaddr;  /* local address for this host */
 8248080:	e0bffc17 	ldw	r2,-16(fp)
 8248084:	10800a17 	ldw	r2,40(r2)
 8248088:	e0bffa15 	stw	r2,-24(fp)
 824808c:	00000306 	br	824809c <in_pcbconnect+0x124>
#else    /* not netport MULTI_HOMED, use 0th (only) iface */
      ifaddr = nets[0]->n_ipaddr;
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */
 8248090:	e0bffe17 	ldw	r2,-8(fp)
 8248094:	10800417 	ldw	r2,16(r2)
 8248098:	e0bffa15 	stw	r2,-24(fp)

   if (in_pcblookup(inp->inp_head,
 824809c:	e0bffe17 	ldw	r2,-8(fp)
 82480a0:	10c00217 	ldw	r3,8(r2)
 82480a4:	e0bffb17 	ldw	r2,-20(fp)
 82480a8:	11000117 	ldw	r4,4(r2)
       sin->sin_addr.s_addr,
       sin->sin_port,
 82480ac:	e0bffb17 	ldw	r2,-20(fp)
 82480b0:	1080008b 	ldhu	r2,2(r2)
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */

   if (in_pcblookup(inp->inp_head,
 82480b4:	117fffcc 	andi	r5,r2,65535
       sin->sin_addr.s_addr,
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
 82480b8:	e0bffe17 	ldw	r2,-8(fp)
 82480bc:	1080078b 	ldhu	r2,30(r2)
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */

   if (in_pcblookup(inp->inp_head,
 82480c0:	10bfffcc 	andi	r2,r2,65535
 82480c4:	d8000115 	stw	zero,4(sp)
 82480c8:	d8800015 	stw	r2,0(sp)
 82480cc:	e1fffa17 	ldw	r7,-24(fp)
 82480d0:	280d883a 	mov	r6,r5
 82480d4:	200b883a 	mov	r5,r4
 82480d8:	1809883a 	mov	r4,r3
 82480dc:	82482bc0 	call	82482bc <in_pcblookup>
 82480e0:	10000226 	beq	r2,zero,82480ec <in_pcbconnect+0x174>
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
       0))
   {
      return (EADDRINUSE);
 82480e4:	00801c04 	movi	r2,112
 82480e8:	00001606 	br	8248144 <in_pcbconnect+0x1cc>
   }
   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 82480ec:	e0bffe17 	ldw	r2,-8(fp)
 82480f0:	10800417 	ldw	r2,16(r2)
 82480f4:	10000a1e 	bne	r2,zero,8248120 <in_pcbconnect+0x1a8>
   {
      if (inp->inp_lport == 0)
 82480f8:	e0bffe17 	ldw	r2,-8(fp)
 82480fc:	1080078b 	ldhu	r2,30(r2)
 8248100:	10bfffcc 	andi	r2,r2,65535
 8248104:	1000031e 	bne	r2,zero,8248114 <in_pcbconnect+0x19c>
         (void)in_pcbbind(inp, (struct mbuf *)0);
 8248108:	000b883a 	mov	r5,zero
 824810c:	e13ffe17 	ldw	r4,-8(fp)
 8248110:	8247d680 	call	8247d68 <in_pcbbind>
      inp->inp_laddr.s_addr = ifaddr;
 8248114:	e0bffe17 	ldw	r2,-8(fp)
 8248118:	e0fffa17 	ldw	r3,-24(fp)
 824811c:	10c00415 	stw	r3,16(r2)
   }
   inp->inp_faddr = sin->sin_addr;
 8248120:	e0bffe17 	ldw	r2,-8(fp)
 8248124:	e0fffb17 	ldw	r3,-20(fp)
 8248128:	18c00117 	ldw	r3,4(r3)
 824812c:	10c00315 	stw	r3,12(r2)
   inp->inp_fport = sin->sin_port;
 8248130:	e0bffb17 	ldw	r2,-20(fp)
 8248134:	10c0008b 	ldhu	r3,2(r2)
 8248138:	e0bffe17 	ldw	r2,-8(fp)
 824813c:	10c0070d 	sth	r3,28(r2)
   return 0;
 8248140:	0005883a 	mov	r2,zero
}
 8248144:	e037883a 	mov	sp,fp
 8248148:	dfc00117 	ldw	ra,4(sp)
 824814c:	df000017 	ldw	fp,0(sp)
 8248150:	dec00204 	addi	sp,sp,8
 8248154:	f800283a 	ret

08248158 <in_pcbdisconnect>:
 * RETURNS: 
 */

void
in_pcbdisconnect(struct inpcb * inp)
{
 8248158:	defffd04 	addi	sp,sp,-12
 824815c:	dfc00215 	stw	ra,8(sp)
 8248160:	df000115 	stw	fp,4(sp)
 8248164:	df000104 	addi	fp,sp,4
 8248168:	e13fff15 	stw	r4,-4(fp)

   inp->inp_faddr.s_addr = INADDR_ANY;
 824816c:	e0bfff17 	ldw	r2,-4(fp)
 8248170:	10000315 	stw	zero,12(r2)
   inp->inp_fport = 0;
 8248174:	e0bfff17 	ldw	r2,-4(fp)
 8248178:	1000070d 	sth	zero,28(r2)
   if (inp->inp_socket->so_state & SS_NOFDREF)
 824817c:	e0bfff17 	ldw	r2,-4(fp)
 8248180:	10800817 	ldw	r2,32(r2)
 8248184:	1080088b 	ldhu	r2,34(r2)
 8248188:	10bfffcc 	andi	r2,r2,65535
 824818c:	1080004c 	andi	r2,r2,1
 8248190:	10000226 	beq	r2,zero,824819c <in_pcbdisconnect+0x44>
      in_pcbdetach (inp);
 8248194:	e13fff17 	ldw	r4,-4(fp)
 8248198:	8247d100 	call	8247d10 <in_pcbdetach>
}
 824819c:	0001883a 	nop
 82481a0:	e037883a 	mov	sp,fp
 82481a4:	dfc00117 	ldw	ra,4(sp)
 82481a8:	df000017 	ldw	fp,0(sp)
 82481ac:	dec00204 	addi	sp,sp,8
 82481b0:	f800283a 	ret

082481b4 <in_setsockaddr>:
 */

void
in_setsockaddr(struct inpcb * inp, 
   struct mbuf *  nam)
{
 82481b4:	defffb04 	addi	sp,sp,-20
 82481b8:	dfc00415 	stw	ra,16(sp)
 82481bc:	df000315 	stw	fp,12(sp)
 82481c0:	df000304 	addi	fp,sp,12
 82481c4:	e13ffe15 	stw	r4,-8(fp)
 82481c8:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 82481cc:	e0bfff17 	ldw	r2,-4(fp)
 82481d0:	00c00404 	movi	r3,16
 82481d4:	10c00215 	stw	r3,8(r2)
   sin = mtod(nam, struct sockaddr_in *);
 82481d8:	e0bfff17 	ldw	r2,-4(fp)
 82481dc:	10800317 	ldw	r2,12(r2)
 82481e0:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 82481e4:	01800404 	movi	r6,16
 82481e8:	000b883a 	mov	r5,zero
 82481ec:	e13ffd17 	ldw	r4,-12(fp)
 82481f0:	82031300 	call	8203130 <memset>
   sin->sin_family = AF_INET;
 82481f4:	e0bffd17 	ldw	r2,-12(fp)
 82481f8:	00c00084 	movi	r3,2
 82481fc:	10c0000d 	sth	r3,0(r2)
   sin->sin_port = inp->inp_lport;
 8248200:	e0bffe17 	ldw	r2,-8(fp)
 8248204:	10c0078b 	ldhu	r3,30(r2)
 8248208:	e0bffd17 	ldw	r2,-12(fp)
 824820c:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_laddr;
 8248210:	e0bffd17 	ldw	r2,-12(fp)
 8248214:	e0fffe17 	ldw	r3,-8(fp)
 8248218:	18c00417 	ldw	r3,16(r3)
 824821c:	10c00115 	stw	r3,4(r2)
}
 8248220:	0001883a 	nop
 8248224:	e037883a 	mov	sp,fp
 8248228:	dfc00117 	ldw	ra,4(sp)
 824822c:	df000017 	ldw	fp,0(sp)
 8248230:	dec00204 	addi	sp,sp,8
 8248234:	f800283a 	ret

08248238 <in_setpeeraddr>:

void
in_setpeeraddr(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 8248238:	defffb04 	addi	sp,sp,-20
 824823c:	dfc00415 	stw	ra,16(sp)
 8248240:	df000315 	stw	fp,12(sp)
 8248244:	df000304 	addi	fp,sp,12
 8248248:	e13ffe15 	stw	r4,-8(fp)
 824824c:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 8248250:	e0bfff17 	ldw	r2,-4(fp)
 8248254:	00c00404 	movi	r3,16
 8248258:	10c00215 	stw	r3,8(r2)
   sin = mtod(nam, struct sockaddr_in *);
 824825c:	e0bfff17 	ldw	r2,-4(fp)
 8248260:	10800317 	ldw	r2,12(r2)
 8248264:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 8248268:	01800404 	movi	r6,16
 824826c:	000b883a 	mov	r5,zero
 8248270:	e13ffd17 	ldw	r4,-12(fp)
 8248274:	82031300 	call	8203130 <memset>
   sin->sin_family = AF_INET;
 8248278:	e0bffd17 	ldw	r2,-12(fp)
 824827c:	00c00084 	movi	r3,2
 8248280:	10c0000d 	sth	r3,0(r2)
   sin->sin_port = inp->inp_fport;
 8248284:	e0bffe17 	ldw	r2,-8(fp)
 8248288:	10c0070b 	ldhu	r3,28(r2)
 824828c:	e0bffd17 	ldw	r2,-12(fp)
 8248290:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_faddr;
 8248294:	e0bffd17 	ldw	r2,-12(fp)
 8248298:	e0fffe17 	ldw	r3,-8(fp)
 824829c:	18c00317 	ldw	r3,12(r3)
 82482a0:	10c00115 	stw	r3,4(r2)
}
 82482a4:	0001883a 	nop
 82482a8:	e037883a 	mov	sp,fp
 82482ac:	dfc00117 	ldw	ra,4(sp)
 82482b0:	df000017 	ldw	fp,0(sp)
 82482b4:	dec00204 	addi	sp,sp,8
 82482b8:	f800283a 	ret

082482bc <in_pcblookup>:
   u_long   faddr, 
   unshort  xfport,
   u_long   laddr,
   unshort  xlport,
   int   flags)
{
 82482bc:	defff504 	addi	sp,sp,-44
 82482c0:	df000a15 	stw	fp,40(sp)
 82482c4:	df000a04 	addi	fp,sp,40
 82482c8:	e13ffb15 	stw	r4,-20(fp)
 82482cc:	e17ffc15 	stw	r5,-16(fp)
 82482d0:	3007883a 	mov	r3,r6
 82482d4:	e1fffe15 	stw	r7,-8(fp)
 82482d8:	e0800117 	ldw	r2,4(fp)
 82482dc:	e0fffd0d 	sth	r3,-12(fp)
 82482e0:	e0bfff0d 	sth	r2,-4(fp)
   struct inpcb * inp, *   match =  0;
 82482e4:	e03ff715 	stw	zero,-36(fp)
   unshort  fport =  xfport; 
 82482e8:	e0bffd0b 	ldhu	r2,-12(fp)
 82482ec:	e0bffa0d 	sth	r2,-24(fp)
   unshort  lport =  xlport;
 82482f0:	e0bfff0b 	ldhu	r2,-4(fp)
 82482f4:	e0bffa8d 	sth	r2,-22(fp)
   int   matchwild   =  3;
 82482f8:	008000c4 	movi	r2,3
 82482fc:	e0bff815 	stw	r2,-32(fp)
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 8248300:	e0bffb17 	ldw	r2,-20(fp)
 8248304:	10800017 	ldw	r2,0(r2)
 8248308:	e0bff615 	stw	r2,-40(fp)
 824830c:	00004f06 	br	824844c <in_pcblookup+0x190>
   {
      if (inp->inp_lport != lport)
 8248310:	e0bff617 	ldw	r2,-40(fp)
 8248314:	1080078b 	ldhu	r2,30(r2)
 8248318:	10ffffcc 	andi	r3,r2,65535
 824831c:	e0bffa8b 	ldhu	r2,-22(fp)
 8248320:	1880401e 	bne	r3,r2,8248424 <in_pcblookup+0x168>
         continue;

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
 8248324:	e0bff617 	ldw	r2,-40(fp)
 8248328:	10800817 	ldw	r2,32(r2)
 824832c:	10800517 	ldw	r2,20(r2)
 8248330:	108000a0 	cmpeqi	r2,r2,2
 8248334:	10003d26 	beq	r2,zero,824842c <in_pcblookup+0x170>
         continue;

      wildcard = 0;
 8248338:	e03ff915 	stw	zero,-28(fp)
      if (inp->inp_laddr.s_addr != INADDR_ANY) 
 824833c:	e0bff617 	ldw	r2,-40(fp)
 8248340:	10800417 	ldw	r2,16(r2)
 8248344:	10000b26 	beq	r2,zero,8248374 <in_pcblookup+0xb8>
      {
         if (laddr == INADDR_ANY)
 8248348:	e0bffe17 	ldw	r2,-8(fp)
 824834c:	1000041e 	bne	r2,zero,8248360 <in_pcblookup+0xa4>
            wildcard++;
 8248350:	e0bff917 	ldw	r2,-28(fp)
 8248354:	10800044 	addi	r2,r2,1
 8248358:	e0bff915 	stw	r2,-28(fp)
 824835c:	00000a06 	br	8248388 <in_pcblookup+0xcc>
         else if (inp->inp_laddr.s_addr != laddr)
 8248360:	e0bff617 	ldw	r2,-40(fp)
 8248364:	10c00417 	ldw	r3,16(r2)
 8248368:	e0bffe17 	ldw	r2,-8(fp)
 824836c:	18800626 	beq	r3,r2,8248388 <in_pcblookup+0xcc>
            continue;
 8248370:	00003306 	br	8248440 <in_pcblookup+0x184>
      }
      else 
      {
         if (laddr != INADDR_ANY)
 8248374:	e0bffe17 	ldw	r2,-8(fp)
 8248378:	10000326 	beq	r2,zero,8248388 <in_pcblookup+0xcc>
            wildcard++;
 824837c:	e0bff917 	ldw	r2,-28(fp)
 8248380:	10800044 	addi	r2,r2,1
 8248384:	e0bff915 	stw	r2,-28(fp)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
 8248388:	e0bff617 	ldw	r2,-40(fp)
 824838c:	10800317 	ldw	r2,12(r2)
 8248390:	10001026 	beq	r2,zero,82483d4 <in_pcblookup+0x118>
      {
         if (faddr == INADDR_ANY)
 8248394:	e0bffc17 	ldw	r2,-16(fp)
 8248398:	1000041e 	bne	r2,zero,82483ac <in_pcblookup+0xf0>
            wildcard++;
 824839c:	e0bff917 	ldw	r2,-28(fp)
 82483a0:	10800044 	addi	r2,r2,1
 82483a4:	e0bff915 	stw	r2,-28(fp)
 82483a8:	00000f06 	br	82483e8 <in_pcblookup+0x12c>
         else if (inp->inp_faddr.s_addr != faddr ||
 82483ac:	e0bff617 	ldw	r2,-40(fp)
 82483b0:	10c00317 	ldw	r3,12(r2)
 82483b4:	e0bffc17 	ldw	r2,-16(fp)
 82483b8:	18801e1e 	bne	r3,r2,8248434 <in_pcblookup+0x178>
             inp->inp_fport != fport)
 82483bc:	e0bff617 	ldw	r2,-40(fp)
 82483c0:	1080070b 	ldhu	r2,28(r2)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
      {
         if (faddr == INADDR_ANY)
            wildcard++;
         else if (inp->inp_faddr.s_addr != faddr ||
 82483c4:	10ffffcc 	andi	r3,r2,65535
 82483c8:	e0bffa0b 	ldhu	r2,-24(fp)
 82483cc:	18800626 	beq	r3,r2,82483e8 <in_pcblookup+0x12c>
             inp->inp_fport != fport)
         {
            continue;
 82483d0:	00001806 	br	8248434 <in_pcblookup+0x178>
         }
      } else 
      {
         if (faddr != INADDR_ANY)
 82483d4:	e0bffc17 	ldw	r2,-16(fp)
 82483d8:	10000326 	beq	r2,zero,82483e8 <in_pcblookup+0x12c>
            wildcard++;
 82483dc:	e0bff917 	ldw	r2,-28(fp)
 82483e0:	10800044 	addi	r2,r2,1
 82483e4:	e0bff915 	stw	r2,-28(fp)
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
 82483e8:	e0bff917 	ldw	r2,-28(fp)
 82483ec:	10000326 	beq	r2,zero,82483fc <in_pcblookup+0x140>
 82483f0:	e0800217 	ldw	r2,8(fp)
 82483f4:	1080004c 	andi	r2,r2,1
 82483f8:	10001026 	beq	r2,zero,824843c <in_pcblookup+0x180>
         continue;
      if (wildcard < matchwild) 
 82483fc:	e0fff917 	ldw	r3,-28(fp)
 8248400:	e0bff817 	ldw	r2,-32(fp)
 8248404:	18800e0e 	bge	r3,r2,8248440 <in_pcblookup+0x184>
      {
         match = inp;
 8248408:	e0bff617 	ldw	r2,-40(fp)
 824840c:	e0bff715 	stw	r2,-36(fp)
         matchwild = wildcard;
 8248410:	e0bff917 	ldw	r2,-28(fp)
 8248414:	e0bff815 	stw	r2,-32(fp)
         if (matchwild == 0)
 8248418:	e0bff817 	ldw	r2,-32(fp)
 824841c:	10000f26 	beq	r2,zero,824845c <in_pcblookup+0x1a0>
 8248420:	00000706 	br	8248440 <in_pcblookup+0x184>
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
   {
      if (inp->inp_lport != lport)
         continue;
 8248424:	0001883a 	nop
 8248428:	00000506 	br	8248440 <in_pcblookup+0x184>

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
         continue;
 824842c:	0001883a 	nop
 8248430:	00000306 	br	8248440 <in_pcblookup+0x184>
         if (faddr == INADDR_ANY)
            wildcard++;
         else if (inp->inp_faddr.s_addr != faddr ||
             inp->inp_fport != fport)
         {
            continue;
 8248434:	0001883a 	nop
 8248438:	00000106 	br	8248440 <in_pcblookup+0x184>
      {
         if (faddr != INADDR_ANY)
            wildcard++;
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
         continue;
 824843c:	0001883a 	nop
   unshort  fport =  xfport; 
   unshort  lport =  xlport;
   int   matchwild   =  3;
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 8248440:	e0bff617 	ldw	r2,-40(fp)
 8248444:	10800017 	ldw	r2,0(r2)
 8248448:	e0bff615 	stw	r2,-40(fp)
 824844c:	e0fff617 	ldw	r3,-40(fp)
 8248450:	e0bffb17 	ldw	r2,-20(fp)
 8248454:	18bfae1e 	bne	r3,r2,8248310 <in_pcblookup+0x54>
 8248458:	00000106 	br	8248460 <in_pcblookup+0x1a4>
      if (wildcard < matchwild) 
      {
         match = inp;
         matchwild = wildcard;
         if (matchwild == 0)
            break;
 824845c:	0001883a 	nop
      }
   }
   if (match == NULL)
 8248460:	e0bff717 	ldw	r2,-36(fp)
 8248464:	1000021e 	bne	r2,zero,8248470 <in_pcblookup+0x1b4>
      return match;
 8248468:	e0bff717 	ldw	r2,-36(fp)
 824846c:	00002406 	br	8248500 <in_pcblookup+0x244>

   if (head->inp_next == match)  /* got cache hit? */
 8248470:	e0bffb17 	ldw	r2,-20(fp)
 8248474:	10c00017 	ldw	r3,0(r2)
 8248478:	e0bff717 	ldw	r2,-36(fp)
 824847c:	1880041e 	bne	r3,r2,8248490 <in_pcblookup+0x1d4>
   {
      inpcb_cachehits++;
 8248480:	d0a0d217 	ldw	r2,-31928(gp)
 8248484:	10800044 	addi	r2,r2,1
 8248488:	d0a0d215 	stw	r2,-31928(gp)
 824848c:	00001b06 	br	82484fc <in_pcblookup+0x240>
   }
   else
   {
      inpcb_cachemiss++;
 8248490:	d0a0d317 	ldw	r2,-31924(gp)
 8248494:	10800044 	addi	r2,r2,1
 8248498:	d0a0d315 	stw	r2,-31924(gp)
      /* "cache" the match to be first checked next time. */
      match->inp_next->inp_prev = match->inp_prev; /*unlink match */
 824849c:	e0bff717 	ldw	r2,-36(fp)
 82484a0:	10800017 	ldw	r2,0(r2)
 82484a4:	e0fff717 	ldw	r3,-36(fp)
 82484a8:	18c00117 	ldw	r3,4(r3)
 82484ac:	10c00115 	stw	r3,4(r2)
      match->inp_prev->inp_next = match->inp_next;
 82484b0:	e0bff717 	ldw	r2,-36(fp)
 82484b4:	10800117 	ldw	r2,4(r2)
 82484b8:	e0fff717 	ldw	r3,-36(fp)
 82484bc:	18c00017 	ldw	r3,0(r3)
 82484c0:	10c00015 	stw	r3,0(r2)

      /* relink match as head->inp_next */
      match->inp_next = head->inp_next;
 82484c4:	e0bffb17 	ldw	r2,-20(fp)
 82484c8:	10c00017 	ldw	r3,0(r2)
 82484cc:	e0bff717 	ldw	r2,-36(fp)
 82484d0:	10c00015 	stw	r3,0(r2)
      head->inp_next = match;
 82484d4:	e0bffb17 	ldw	r2,-20(fp)
 82484d8:	e0fff717 	ldw	r3,-36(fp)
 82484dc:	10c00015 	stw	r3,0(r2)
      match->inp_prev = head;
 82484e0:	e0bff717 	ldw	r2,-36(fp)
 82484e4:	e0fffb17 	ldw	r3,-20(fp)
 82484e8:	10c00115 	stw	r3,4(r2)
      match->inp_next->inp_prev = match;
 82484ec:	e0bff717 	ldw	r2,-36(fp)
 82484f0:	10800017 	ldw	r2,0(r2)
 82484f4:	e0fff717 	ldw	r3,-36(fp)
 82484f8:	10c00115 	stw	r3,4(r2)
   }
   return (match);
 82484fc:	e0bff717 	ldw	r2,-36(fp)
}
 8248500:	e037883a 	mov	sp,fp
 8248504:	df000017 	ldw	fp,0(sp)
 8248508:	dec00104 	addi	sp,sp,4
 824850c:	f800283a 	ret

08248510 <set_vfopen_error>:
 *
 * RETURNS: 
 */

void set_vfopen_error(int error)
{
 8248510:	defffe04 	addi	sp,sp,-8
 8248514:	df000115 	stw	fp,4(sp)
 8248518:	df000104 	addi	fp,sp,4
 824851c:	e13fff15 	stw	r4,-4(fp)
   vfopen_error = error;
 8248520:	e0bfff17 	ldw	r2,-4(fp)
 8248524:	d0a0d715 	stw	r2,-31908(gp)
}
 8248528:	0001883a 	nop
 824852c:	e037883a 	mov	sp,fp
 8248530:	df000017 	ldw	fp,0(sp)
 8248534:	dec00104 	addi	sp,sp,4
 8248538:	f800283a 	ret

0824853c <get_vfopen_error>:
 *
 * RETURNS: 
 */

int get_vfopen_error()
{
 824853c:	deffff04 	addi	sp,sp,-4
 8248540:	df000015 	stw	fp,0(sp)
 8248544:	d839883a 	mov	fp,sp
   return vfopen_error;
 8248548:	d0a0d717 	ldw	r2,-31908(gp)
}
 824854c:	e037883a 	mov	sp,fp
 8248550:	df000017 	ldw	fp,0(sp)
 8248554:	dec00104 	addi	sp,sp,4
 8248558:	f800283a 	ret

0824855c <vf_alloc_and_link_vop>:
 *
 * RETURNS: 
 */

VFILE * vf_alloc_and_link_vop()
{
 824855c:	defffd04 	addi	sp,sp,-12
 8248560:	dfc00215 	stw	ra,8(sp)
 8248564:	df000115 	stw	fp,4(sp)
 8248568:	df000104 	addi	fp,sp,4
   struct vfs_open * vop;

   /* enforce maximum number of simultaneously open files */
   if (vfs_open_files >= VFS_MAX_OPEN_FILES)
 824856c:	d0a0d917 	ldw	r2,-31900(gp)
 8248570:	10803ff0 	cmpltui	r2,r2,255
 8248574:	1000021e 	bne	r2,zero,8248580 <vf_alloc_and_link_vop+0x24>
   {
#ifdef VFS_VERBOSE
      dprintf("vfs_open_files too big (%ld) in vf_alloc_and_link_vop()\n",
       vfs_open_files);
#endif   /* VFS_VERBOSE */
      return NULL;
 8248578:	0005883a 	mov	r2,zero
 824857c:	00000e06 	br	82485b8 <vf_alloc_and_link_vop+0x5c>
   }

   /* allocate a structure to represent the open file */
   vop = VFS_VFS_OPEN_ALLOC();
 8248580:	01000504 	movi	r4,20
 8248584:	822dfec0 	call	822dfec <npalloc>
 8248588:	e0bfff15 	stw	r2,-4(fp)

   /* if the allocation succeeded */
   if (vop)
 824858c:	e0bfff17 	ldw	r2,-4(fp)
 8248590:	10000826 	beq	r2,zero,82485b4 <vf_alloc_and_link_vop+0x58>
   {
      /* add to the beginning of the list of open files */
      vop->next = vfiles;
 8248594:	d0e0d517 	ldw	r3,-31916(gp)
 8248598:	e0bfff17 	ldw	r2,-4(fp)
 824859c:	10c00015 	stw	r3,0(r2)
      vfiles = vop;
 82485a0:	e0bfff17 	ldw	r2,-4(fp)
 82485a4:	d0a0d515 	stw	r2,-31916(gp)
      /* increment the count of open files */
      vfs_open_files++;
 82485a8:	d0a0d917 	ldw	r2,-31900(gp)
 82485ac:	10800044 	addi	r2,r2,1
 82485b0:	d0a0d915 	stw	r2,-31900(gp)
#ifdef VFS_VERBOSE
   else
      dprintf("VFS_VFS_OPEN_ALLOC() failed in vf_alloc_and_link_vop()\n");
#endif   /* VFS_VERBOSE */

   return vop;
 82485b4:	e0bfff17 	ldw	r2,-4(fp)
}
 82485b8:	e037883a 	mov	sp,fp
 82485bc:	dfc00117 	ldw	ra,4(sp)
 82485c0:	df000017 	ldw	fp,0(sp)
 82485c4:	dec00204 	addi	sp,sp,8
 82485c8:	f800283a 	ret

082485cc <vf_alloc_buffer>:
 *
 * RETURNS: 
 */

unsigned char * vf_alloc_buffer(unsigned long size)
{
 82485cc:	defff904 	addi	sp,sp,-28
 82485d0:	dfc00615 	stw	ra,24(sp)
 82485d4:	df000515 	stw	fp,20(sp)
 82485d8:	df000504 	addi	fp,sp,20
 82485dc:	e13fff15 	stw	r4,-4(fp)
   unsigned int long_size,int_size;
#endif   /* MUTE_WARNS */

   /* make sure the requested allocation does not exceed the total
      memory space reserved for file buffers */
   if ((vfs_total_rw_space + size) > VFS_MAX_TOTAL_RW_SPACE)
 82485e0:	d0e0da17 	ldw	r3,-31896(gp)
 82485e4:	e0bfff17 	ldw	r2,-4(fp)
 82485e8:	1885883a 	add	r2,r3,r2
 82485ec:	00ffffd4 	movui	r3,65535
 82485f0:	1880022e 	bgeu	r3,r2,82485fc <vf_alloc_buffer+0x30>
      return NULL;
 82485f4:	0005883a 	mov	r2,zero
 82485f8:	00002106 	br	8248680 <vf_alloc_buffer+0xb4>
    * any bigger than what will fit in an unsigned int 
    */
#ifdef MUTE_WARNS
   /* the idiotic hoops you got to jump through to suppress compiler
      warnings */
   long_size   =  sizeof(unsigned   long);
 82485fc:	00800104 	movi	r2,4
 8248600:	e0bffb15 	stw	r2,-20(fp)
   int_size = sizeof(unsigned int);
 8248604:	00800104 	movi	r2,4
 8248608:	e0bffc15 	stw	r2,-16(fp)
   if (long_size > int_size)
 824860c:	e0bffb17 	ldw	r2,-20(fp)
 8248610:	e0fffc17 	ldw	r3,-16(fp)
 8248614:	1880102e 	bgeu	r3,r2,8248658 <vf_alloc_buffer+0x8c>
       * most systems where this "if" expression will evaluate to 
       * true (2 byte ints, 4 byte longs). if any of those upper bits 
       * are on in your requested size, you otta luck.
       */
#ifdef MUTE_WARNS
      switch (int_size)
 8248618:	e0bffc17 	ldw	r2,-16(fp)
 824861c:	108000a0 	cmpeqi	r2,r2,2
 8248620:	10000826 	beq	r2,zero,8248644 <vf_alloc_buffer+0x78>
#else
      switch (sizeof(unsigned int))
#endif   /* MUTE_WARNS */
      {
      case 2 :
         mem_mask = 0xffff0000;
 8248624:	00bffff4 	movhi	r2,65535
 8248628:	e0bffd15 	stw	r2,-12(fp)
         break;
 824862c:	0001883a 	nop
         default :
            dtrap();    /* you have a weird compiler */
         return NULL;
      }

      if (size & mem_mask)
 8248630:	e0ffff17 	ldw	r3,-4(fp)
 8248634:	e0bffd17 	ldw	r2,-12(fp)
 8248638:	1884703a 	and	r2,r3,r2
 824863c:	10000626 	beq	r2,zero,8248658 <vf_alloc_buffer+0x8c>
 8248640:	00000306 	br	8248650 <vf_alloc_buffer+0x84>
      {
      case 2 :
         mem_mask = 0xffff0000;
         break;
         default :
            dtrap();    /* you have a weird compiler */
 8248644:	822d4140 	call	822d414 <dtrap>
         return NULL;
 8248648:	0005883a 	mov	r2,zero
 824864c:	00000c06 	br	8248680 <vf_alloc_buffer+0xb4>
      }

      if (size & mem_mask)
         return NULL;
 8248650:	0005883a 	mov	r2,zero
 8248654:	00000a06 	br	8248680 <vf_alloc_buffer+0xb4>
   }

   /* try to allocate a buffer of the requested size */
   buffer = (unsigned char *) npalloc((unsigned int) size);
 8248658:	e13fff17 	ldw	r4,-4(fp)
 824865c:	822dfec0 	call	822dfec <npalloc>
 8248660:	e0bffe15 	stw	r2,-8(fp)

   /* if the allocation succeeded */
   if (buffer)
 8248664:	e0bffe17 	ldw	r2,-8(fp)
 8248668:	10000426 	beq	r2,zero,824867c <vf_alloc_buffer+0xb0>
   {
      /* add size to the count of total buffer space allocated */
      vfs_total_rw_space += size;
 824866c:	d0e0da17 	ldw	r3,-31896(gp)
 8248670:	e0bfff17 	ldw	r2,-4(fp)
 8248674:	1885883a 	add	r2,r3,r2
 8248678:	d0a0da15 	stw	r2,-31896(gp)
   }

   return buffer;
 824867c:	e0bffe17 	ldw	r2,-8(fp)
}
 8248680:	e037883a 	mov	sp,fp
 8248684:	dfc00117 	ldw	ra,4(sp)
 8248688:	df000017 	ldw	fp,0(sp)
 824868c:	dec00204 	addi	sp,sp,8
 8248690:	f800283a 	ret

08248694 <vf_free_buffer>:
 *
 * RETURNS: 
 */

void vf_free_buffer(unsigned char * buffer, unsigned long size)
{
 8248694:	defffc04 	addi	sp,sp,-16
 8248698:	dfc00315 	stw	ra,12(sp)
 824869c:	df000215 	stw	fp,8(sp)
 82486a0:	df000204 	addi	fp,sp,8
 82486a4:	e13ffe15 	stw	r4,-8(fp)
 82486a8:	e17fff15 	stw	r5,-4(fp)
   /* free the buffer */
   if (buffer)
 82486ac:	e0bffe17 	ldw	r2,-8(fp)
 82486b0:	10000226 	beq	r2,zero,82486bc <vf_free_buffer+0x28>
      npfree(buffer);
 82486b4:	e13ffe17 	ldw	r4,-8(fp)
 82486b8:	822e0200 	call	822e020 <npfree>

   /* and subtract its size from the total buffer space count */
   vfs_total_rw_space -= size;
 82486bc:	d0e0da17 	ldw	r3,-31896(gp)
 82486c0:	e0bfff17 	ldw	r2,-4(fp)
 82486c4:	1885c83a 	sub	r2,r3,r2
 82486c8:	d0a0da15 	stw	r2,-31896(gp)
}
 82486cc:	0001883a 	nop
 82486d0:	e037883a 	mov	sp,fp
 82486d4:	dfc00117 	ldw	ra,4(sp)
 82486d8:	df000017 	ldw	fp,0(sp)
 82486dc:	dec00204 	addi	sp,sp,8
 82486e0:	f800283a 	ret

082486e4 <vfopen_locked>:
 * RETURNS: 
 */

VFILE *
vfopen_locked(char * name, char * mode)
{
 82486e4:	defff904 	addi	sp,sp,-28
 82486e8:	dfc00615 	stw	ra,24(sp)
 82486ec:	df000515 	stw	fp,20(sp)
 82486f0:	df000504 	addi	fp,sp,20
 82486f4:	e13ffe15 	stw	r4,-8(fp)
 82486f8:	e17fff15 	stw	r5,-4(fp)
   struct vfs_file * vfp;
   struct vfs_open * vop;

   /* clear any previous vfopen() error */
   set_vfopen_error(0);
 82486fc:	0009883a 	mov	r4,zero
 8248700:	82485100 	call	8248510 <set_vfopen_error>

   /* the old code used to do special handling of '?' in files for 
    * the benefit of the web server. the web server should be doing 
    * this now. this is here to make sure that its doing it 
    */
   if (strchr(name,'?'))
 8248704:	01400fc4 	movi	r5,63
 8248708:	e13ffe17 	ldw	r4,-8(fp)
 824870c:	82037000 	call	8203700 <strchr>
 8248710:	10000326 	beq	r2,zero,8248720 <vfopen_locked+0x3c>
   {
      dtrap();
 8248714:	822d4140 	call	822d414 <dtrap>
      return NULL;
 8248718:	0005883a 	mov	r2,zero
 824871c:	0000ba06 	br	8248a08 <vfopen_locked+0x324>
   }

   /* determine if the file exists */
   /* if the directory exists, vfp will point to its directory entry
      structure else vfp will be NULL */
   vfp = vfslookup_locked(name);
 8248720:	e13ffe17 	ldw	r4,-8(fp)
 8248724:	82499680 	call	8249968 <vfslookup_locked>
 8248728:	e0bffc15 	stw	r2,-16(fp)

   /* if the file exists */
   if (vfp)
 824872c:	e0bffc17 	ldw	r2,-16(fp)
 8248730:	10004a26 	beq	r2,zero,824885c <vfopen_locked+0x178>

#ifdef HT_RWVFS

      /* if mode begins with 'w' we will truncate to end of file */
      /* make sure the file is writable before proceeding */
      if ((*mode == 'w') && !(vfp->flags & VF_WRITE))
 8248734:	e0bfff17 	ldw	r2,-4(fp)
 8248738:	10800003 	ldbu	r2,0(r2)
 824873c:	10803fcc 	andi	r2,r2,255
 8248740:	1080201c 	xori	r2,r2,128
 8248744:	10bfe004 	addi	r2,r2,-128
 8248748:	10801dd8 	cmpnei	r2,r2,119
 824874c:	1000091e 	bne	r2,zero,8248774 <vfopen_locked+0x90>
 8248750:	e0bffc17 	ldw	r2,-16(fp)
 8248754:	1080058b 	ldhu	r2,22(r2)
 8248758:	10bfffcc 	andi	r2,r2,65535
 824875c:	1080080c 	andi	r2,r2,32
 8248760:	1000041e 	bne	r2,zero,8248774 <vfopen_locked+0x90>
      {
         set_vfopen_error(ENP_FILEIO);
 8248764:	013ff984 	movi	r4,-26
 8248768:	82485100 	call	8248510 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("mode w with no VF_WRITE\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 824876c:	0005883a 	mov	r2,zero
 8248770:	0000a506 	br	8248a08 <vfopen_locked+0x324>
      }

#endif   /* HT_RWVFS */

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 8248774:	824855c0 	call	824855c <vf_alloc_and_link_vop>
 8248778:	e0bffd15 	stw	r2,-12(fp)

      /* check for failure */
      if (!vop)
 824877c:	e0bffd17 	ldw	r2,-12(fp)
 8248780:	1000041e 	bne	r2,zero,8248794 <vfopen_locked+0xb0>
      {
         set_vfopen_error(ENP_NOMEM);
 8248784:	013ffb04 	movi	r4,-20
 8248788:	82485100 	call	8248510 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 1\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 824878c:	0005883a 	mov	r2,zero
 8248790:	00009d06 	br	8248a08 <vfopen_locked+0x324>
      }

      /* link to the file's directory entry structure */
      vop->file = vfp;
 8248794:	e0bffd17 	ldw	r2,-12(fp)
 8248798:	e0fffc17 	ldw	r3,-16(fp)
 824879c:	10c00115 	stw	r3,4(r2)

      /* by default start at the beginning of the file */
      /* note that vfp->data could be NULL at this point since empty
         files might have no data buffer allocated to them */
      vop->cmploc = vfp->data;   /* start at beginning of file */
 82487a0:	e0bffc17 	ldw	r2,-16(fp)
 82487a4:	10c00617 	ldw	r3,24(r2)
 82487a8:	e0bffd17 	ldw	r2,-12(fp)
 82487ac:	10c00215 	stw	r3,8(r2)

#ifdef HT_RWVFS

      /* if mode begins with 'a', seek to end of file */
      if (*mode == 'a')
 82487b0:	e0bfff17 	ldw	r2,-4(fp)
 82487b4:	10800003 	ldbu	r2,0(r2)
 82487b8:	10803fcc 	andi	r2,r2,255
 82487bc:	1080201c 	xori	r2,r2,128
 82487c0:	10bfe004 	addi	r2,r2,-128
 82487c4:	10801858 	cmpnei	r2,r2,97
 82487c8:	10000a1e 	bne	r2,zero,82487f4 <vfopen_locked+0x110>
      {
         if (vfp->data)
 82487cc:	e0bffc17 	ldw	r2,-16(fp)
 82487d0:	10800617 	ldw	r2,24(r2)
 82487d4:	10000726 	beq	r2,zero,82487f4 <vfopen_locked+0x110>
         {
            vop->cmploc = vfp->data + vfp->comp_size;
 82487d8:	e0bffc17 	ldw	r2,-16(fp)
 82487dc:	10c00617 	ldw	r3,24(r2)
 82487e0:	e0bffc17 	ldw	r2,-16(fp)
 82487e4:	10800817 	ldw	r2,32(r2)
 82487e8:	1887883a 	add	r3,r3,r2
 82487ec:	e0bffd17 	ldw	r2,-12(fp)
 82487f0:	10c00215 	stw	r3,8(r2)
         }
      }

      /* if mode begins with 'w', truncate to end of file */
      if (*mode == 'w')
 82487f4:	e0bfff17 	ldw	r2,-4(fp)
 82487f8:	10800003 	ldbu	r2,0(r2)
 82487fc:	10803fcc 	andi	r2,r2,255
 8248800:	1080201c 	xori	r2,r2,128
 8248804:	10bfe004 	addi	r2,r2,-128
 8248808:	10801dd8 	cmpnei	r2,r2,119
 824880c:	1000111e 	bne	r2,zero,8248854 <vfopen_locked+0x170>
      {
         /* set the size of the file before compression to 0 */
         vfp->real_size = 0;
 8248810:	e0bffc17 	ldw	r2,-16(fp)
 8248814:	10000715 	stw	zero,28(r2)
         /* set the size of the compressed data to 0 */
         vfp->comp_size = 0;
 8248818:	e0bffc17 	ldw	r2,-16(fp)
 824881c:	10000815 	stw	zero,32(r2)
         /* note we leave the pointer to the file buffer and its length
            alone since first writes will go to it */
         /* flag that the file has been modified */
         vfp->flags |= VF_STALE;
 8248820:	e0bffc17 	ldw	r2,-16(fp)
 8248824:	1080058b 	ldhu	r2,22(r2)
 8248828:	10808014 	ori	r2,r2,512
 824882c:	1007883a 	mov	r3,r2
 8248830:	e0bffc17 	ldw	r2,-16(fp)
 8248834:	10c0058d 	sth	r3,22(r2)

         /* turn off the compression flag */
         vfp->flags &= ~VF_HTMLCOMPRESSED;
 8248838:	e0bffc17 	ldw	r2,-16(fp)
 824883c:	10c0058b 	ldhu	r3,22(r2)
 8248840:	00bfff84 	movi	r2,-2
 8248844:	1884703a 	and	r2,r3,r2
 8248848:	1007883a 	mov	r3,r2
 824884c:	e0bffc17 	ldw	r2,-16(fp)
 8248850:	10c0058d 	sth	r3,22(r2)
      }

#endif   /* HT_RWVFS */

      return vop;
 8248854:	e0bffd17 	ldw	r2,-12(fp)
 8248858:	00006b06 	br	8248a08 <vfopen_locked+0x324>

#ifdef HT_EXTDEV

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 824885c:	e0bfff17 	ldw	r2,-4(fp)
 8248860:	10800003 	ldbu	r2,0(r2)
 8248864:	10803fcc 	andi	r2,r2,255
 8248868:	1080201c 	xori	r2,r2,128
 824886c:	10bfe004 	addi	r2,r2,-128
 8248870:	10801ca0 	cmpeqi	r2,r2,114
 8248874:	1000121e 	bne	r2,zero,82488c0 <vfopen_locked+0x1dc>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 8248878:	d0a0d417 	ldw	r2,-31920(gp)
 824887c:	e0bffb15 	stw	r2,-20(fp)
 8248880:	00000d06 	br	82488b8 <vfopen_locked+0x1d4>
      {
         if ((vop = vfs->r_fopen(name, mode)) != NULL)
 8248884:	e0bffb17 	ldw	r2,-20(fp)
 8248888:	10800117 	ldw	r2,4(r2)
 824888c:	e17fff17 	ldw	r5,-4(fp)
 8248890:	e13ffe17 	ldw	r4,-8(fp)
 8248894:	103ee83a 	callr	r2
 8248898:	e0bffd15 	stw	r2,-12(fp)
 824889c:	e0bffd17 	ldw	r2,-12(fp)
 82488a0:	10000226 	beq	r2,zero,82488ac <vfopen_locked+0x1c8>
         {
            return vop;
 82488a4:	e0bffd17 	ldw	r2,-12(fp)
 82488a8:	00005706 	br	8248a08 <vfopen_locked+0x324>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 82488ac:	e0bffb17 	ldw	r2,-20(fp)
 82488b0:	10800017 	ldw	r2,0(r2)
 82488b4:	e0bffb15 	stw	r2,-20(fp)
 82488b8:	e0bffb17 	ldw	r2,-20(fp)
 82488bc:	103ff11e 	bne	r2,zero,8248884 <vfopen_locked+0x1a0>

#ifdef HT_RWVFS

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 82488c0:	e0bfff17 	ldw	r2,-4(fp)
 82488c4:	10800003 	ldbu	r2,0(r2)
 82488c8:	10803fcc 	andi	r2,r2,255
 82488cc:	1080201c 	xori	r2,r2,128
 82488d0:	10bfe004 	addi	r2,r2,-128
 82488d4:	10801ca0 	cmpeqi	r2,r2,114
 82488d8:	1000481e 	bne	r2,zero,82489fc <vfopen_locked+0x318>
   {
      /* enforce maximum number of files */
      if (vfs_total_dyna_files >= VFS_MAX_DYNA_FILES)
 82488dc:	d0a0db17 	ldw	r2,-31892(gp)
 82488e0:	10803ff0 	cmpltui	r2,r2,255
 82488e4:	1000041e 	bne	r2,zero,82488f8 <vfopen_locked+0x214>
      {
         set_vfopen_error(ENP_NOMEM);
 82488e8:	013ffb04 	movi	r4,-20
 82488ec:	82485100 	call	8248510 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_total_dyna_files too big in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 82488f0:	0005883a 	mov	r2,zero
 82488f4:	00004406 	br	8248a08 <vfopen_locked+0x324>
      }

      /* make sure the file name is not too long for the VFS */
      if (strlen(name) > FILENAMEMAX)
 82488f8:	e13ffe17 	ldw	r4,-8(fp)
 82488fc:	8203edc0 	call	8203edc <strlen>
 8248900:	10800470 	cmpltui	r2,r2,17
 8248904:	1000041e 	bne	r2,zero,8248918 <vfopen_locked+0x234>
      {
         set_vfopen_error(ENP_PARAM);
 8248908:	013ffd84 	movi	r4,-10
 824890c:	82485100 	call	8248510 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("file name too long in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248910:	0005883a 	mov	r2,zero
 8248914:	00003c06 	br	8248a08 <vfopen_locked+0x324>
      }

      /* allocate a vfs_file structure to hold the new file entry in */
      vfp = VFS_VFS_FILE_ALLOC();
 8248918:	01000b04 	movi	r4,44
 824891c:	822dfec0 	call	822dfec <npalloc>
 8248920:	e0bffc15 	stw	r2,-16(fp)

      /* check for memory allocation failure */
      if (!vfp)
 8248924:	e0bffc17 	ldw	r2,-16(fp)
 8248928:	1000041e 	bne	r2,zero,824893c <vfopen_locked+0x258>
      {
         set_vfopen_error(ENP_NOMEM);
 824892c:	013ffb04 	movi	r4,-20
 8248930:	82485100 	call	8248510 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("VFS_VFS_FILE_ALLOC() failed in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 8248934:	0005883a 	mov	r2,zero
 8248938:	00003306 	br	8248a08 <vfopen_locked+0x324>
      }

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 824893c:	824855c0 	call	824855c <vf_alloc_and_link_vop>
 8248940:	e0bffd15 	stw	r2,-12(fp)

      /* check for memory allocation failure */
      if (!vop)
 8248944:	e0bffd17 	ldw	r2,-12(fp)
 8248948:	1000061e 	bne	r2,zero,8248964 <vfopen_locked+0x280>
      {
         VFS_VFS_FILE_FREE(vfp); /* free the allocated vfs_file entry */
 824894c:	e13ffc17 	ldw	r4,-16(fp)
 8248950:	822e0200 	call	822e020 <npfree>
         set_vfopen_error(ENP_NOMEM);
 8248954:	013ffb04 	movi	r4,-20
 8248958:	82485100 	call	8248510 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 2\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 824895c:	0005883a 	mov	r2,zero
 8248960:	00002906 	br	8248a08 <vfopen_locked+0x324>
      }

      /* add the vfs_file structure to the head of the list */

      vfp->next = vfsfiles;
 8248964:	d0e0d617 	ldw	r3,-31912(gp)
 8248968:	e0bffc17 	ldw	r2,-16(fp)
 824896c:	10c00015 	stw	r3,0(r2)
      vfsfiles = vfp;
 8248970:	e0bffc17 	ldw	r2,-16(fp)
 8248974:	d0a0d615 	stw	r2,-31912(gp)

      /* increment count of total files */
      vfs_total_dyna_files++;
 8248978:	d0a0db17 	ldw	r2,-31892(gp)
 824897c:	10800044 	addi	r2,r2,1
 8248980:	d0a0db15 	stw	r2,-31892(gp)

      /* remove leading directory separator before storing name */
      if (*name == '/' || *name == '\\')
 8248984:	e0bffe17 	ldw	r2,-8(fp)
 8248988:	10800003 	ldbu	r2,0(r2)
 824898c:	10803fcc 	andi	r2,r2,255
 8248990:	1080201c 	xori	r2,r2,128
 8248994:	10bfe004 	addi	r2,r2,-128
 8248998:	10800be0 	cmpeqi	r2,r2,47
 824899c:	1000071e 	bne	r2,zero,82489bc <vfopen_locked+0x2d8>
 82489a0:	e0bffe17 	ldw	r2,-8(fp)
 82489a4:	10800003 	ldbu	r2,0(r2)
 82489a8:	10803fcc 	andi	r2,r2,255
 82489ac:	1080201c 	xori	r2,r2,128
 82489b0:	10bfe004 	addi	r2,r2,-128
 82489b4:	10801718 	cmpnei	r2,r2,92
 82489b8:	1000031e 	bne	r2,zero,82489c8 <vfopen_locked+0x2e4>
         name++;
 82489bc:	e0bffe17 	ldw	r2,-8(fp)
 82489c0:	10800044 	addi	r2,r2,1
 82489c4:	e0bffe15 	stw	r2,-8(fp)

      /* store the converted name in the directory entry structure */
      strcpy(vfp->name,name);
 82489c8:	e0bffc17 	ldw	r2,-16(fp)
 82489cc:	10800104 	addi	r2,r2,4
 82489d0:	e17ffe17 	ldw	r5,-8(fp)
 82489d4:	1009883a 	mov	r4,r2
 82489d8:	824b6b80 	call	824b6b8 <strcpy>

      /* set the flags */
      vfp->flags = VF_DYNAMICINFO   /* the directory entry was allocated */
 82489dc:	e0bffc17 	ldw	r2,-16(fp)
 82489e0:	00c0d804 	movi	r3,864
 82489e4:	10c0058d 	sth	r3,22(r2)
       * note that this means the data pointer contains a null 
       * because we don't allocate any buffer to hold the data 
       * in until the first write 
       */
      /* link to the file's directory entry structure */
      vop->file = vfp;
 82489e8:	e0bffd17 	ldw	r2,-12(fp)
 82489ec:	e0fffc17 	ldw	r3,-16(fp)
 82489f0:	10c00115 	stw	r3,4(r2)
      /* the cmploc and tag fields of the vop retain their NULLs from 
       * npalloc(). cmploc contains NULL because there is no data 
       * buffer to point to yet. tag contains NULL because no 
       * decompression operation has started yet
       */
      return vop;
 82489f4:	e0bffd17 	ldw	r2,-12(fp)
 82489f8:	00000306 	br	8248a08 <vfopen_locked+0x324>
   /* pass the open to the local file system */
   return (VFILE *) fopen(name,mode);

#else

   set_vfopen_error(ENP_NOFILE);
 82489fc:	013ff9c4 	movi	r4,-25
 8248a00:	82485100 	call	8248510 <set_vfopen_error>
#ifdef VFS_VERBOSE
   dprintf("fell thru to end of vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
   return NULL;
 8248a04:	0005883a 	mov	r2,zero

#endif   /* HT_LOCALFS */
}
 8248a08:	e037883a 	mov	sp,fp
 8248a0c:	dfc00117 	ldw	ra,4(sp)
 8248a10:	df000017 	ldw	fp,0(sp)
 8248a14:	dec00204 	addi	sp,sp,8
 8248a18:	f800283a 	ret

08248a1c <vfopen>:
 * RETURNS: 
 */

VFILE *
vfopen(char * name, char * mode)
{
 8248a1c:	defffb04 	addi	sp,sp,-20
 8248a20:	dfc00415 	stw	ra,16(sp)
 8248a24:	df000315 	stw	fp,12(sp)
 8248a28:	df000304 	addi	fp,sp,12
 8248a2c:	e13ffe15 	stw	r4,-8(fp)
 8248a30:	e17fff15 	stw	r5,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfopen() passed >%s<,%s\n",name,mode);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 8248a34:	01000144 	movi	r4,5
 8248a38:	822da280 	call	822da28 <wait_app_sem>

   vfd = vfopen_locked(name,mode);
 8248a3c:	e17fff17 	ldw	r5,-4(fp)
 8248a40:	e13ffe17 	ldw	r4,-8(fp)
 8248a44:	82486e40 	call	82486e4 <vfopen_locked>
 8248a48:	e0bffd15 	stw	r2,-12(fp)

   vfs_unlock();
 8248a4c:	01000144 	movi	r4,5
 8248a50:	822dae40 	call	822dae4 <post_app_sem>

   return vfd;
 8248a54:	e0bffd17 	ldw	r2,-12(fp)
}
 8248a58:	e037883a 	mov	sp,fp
 8248a5c:	dfc00117 	ldw	ra,4(sp)
 8248a60:	df000017 	ldw	fp,0(sp)
 8248a64:	dec00204 	addi	sp,sp,8
 8248a68:	f800283a 	ret

08248a6c <vfclose_locked>:
 * RETURNS: 
 */

void 
vfclose_locked(VFILE * vfd)
{
 8248a6c:	defff804 	addi	sp,sp,-32
 8248a70:	dfc00715 	stw	ra,28(sp)
 8248a74:	df000615 	stw	fp,24(sp)
 8248a78:	df000604 	addi	fp,sp,24
 8248a7c:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;
   VFILE * vlast;

   vlast = NULL;
 8248a80:	e03ffb15 	stw	zero,-20(fp)

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
 8248a84:	d0a0d517 	ldw	r2,-31916(gp)
 8248a88:	e0bffa15 	stw	r2,-24(fp)
   while (vtmp)
 8248a8c:	00000806 	br	8248ab0 <vfclose_locked+0x44>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
 8248a90:	e0ffff17 	ldw	r3,-4(fp)
 8248a94:	e0bffa17 	ldw	r2,-24(fp)
 8248a98:	18800826 	beq	r3,r2,8248abc <vfclose_locked+0x50>
         break;

      /* bump the next and previous pointers along to try the next one */
      vlast = vtmp;
 8248a9c:	e0bffa17 	ldw	r2,-24(fp)
 8248aa0:	e0bffb15 	stw	r2,-20(fp)
      vtmp = vtmp->next;
 8248aa4:	e0bffa17 	ldw	r2,-24(fp)
 8248aa8:	10800017 	ldw	r2,0(r2)
 8248aac:	e0bffa15 	stw	r2,-24(fp)
   vlast = NULL;

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
   while (vtmp)
 8248ab0:	e0bffa17 	ldw	r2,-24(fp)
 8248ab4:	103ff61e 	bne	r2,zero,8248a90 <vfclose_locked+0x24>
 8248ab8:	00000106 	br	8248ac0 <vfclose_locked+0x54>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
         break;
 8248abc:	0001883a 	nop
      vlast = vtmp;
      vtmp = vtmp->next;
   }

   /* if the passed in handle was not in the list we maintain */
   if (vfd != vtmp)
 8248ac0:	e0ffff17 	ldw	r3,-4(fp)
 8248ac4:	e0bffa17 	ldw	r2,-24(fp)
 8248ac8:	1880511e 	bne	r3,r2,8248c10 <vfclose_locked+0x1a4>

   /* this not really a forever loop. it exists so we can break easily
      and deal with all the ifdefs */
   while (1)
   {
      struct vfs_file * vfp   =  vfd->file;
 8248acc:	e0bfff17 	ldw	r2,-4(fp)
 8248ad0:	10800117 	ldw	r2,4(r2)
 8248ad4:	e0bffc15 	stw	r2,-16(fp)
      /* vfd->file will be null if somebody unlinked the file after
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
 8248ad8:	e0bffc17 	ldw	r2,-16(fp)
 8248adc:	10003826 	beq	r2,zero,8248bc0 <vfclose_locked+0x154>
         break;
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 8248ae0:	e0bffc17 	ldw	r2,-16(fp)
 8248ae4:	10800a17 	ldw	r2,40(r2)
 8248ae8:	10000826 	beq	r2,zero,8248b0c <vfclose_locked+0xa0>
      {
         /* call that file system's fclose() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)(vfp->method);
 8248aec:	e0bffc17 	ldw	r2,-16(fp)
 8248af0:	10800a17 	ldw	r2,40(r2)
 8248af4:	e0bffd15 	stw	r2,-12(fp)

         vfs->r_fclose(vfd);
 8248af8:	e0bffd17 	ldw	r2,-12(fp)
 8248afc:	10800217 	ldw	r2,8(r2)
 8248b00:	e13fff17 	ldw	r4,-4(fp)
 8248b04:	103ee83a 	callr	r2
         break;   /* break to list deletion code after end of phoney loop */
 8248b08:	00003006 	br	8248bcc <vfclose_locked+0x160>

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 8248b0c:	e0bffc17 	ldw	r2,-16(fp)
 8248b10:	1080058b 	ldhu	r2,22(r2)
 8248b14:	10bfffcc 	andi	r2,r2,65535
 8248b18:	1080200c 	andi	r2,r2,128
 8248b1c:	10002a26 	beq	r2,zero,8248bc8 <vfclose_locked+0x15c>
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
 8248b20:	e0bffc17 	ldw	r2,-16(fp)
 8248b24:	10c00917 	ldw	r3,36(r2)
 8248b28:	e0bffc17 	ldw	r2,-16(fp)
 8248b2c:	10800817 	ldw	r2,32(r2)
 8248b30:	1885c83a 	sub	r2,r3,r2

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 8248b34:	10804030 	cmpltui	r2,r2,256
 8248b38:	1000231e 	bne	r2,zero,8248bc8 <vfclose_locked+0x15c>
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
          vfp->data) /* this last test is a sanity check */
 8248b3c:	e0bffc17 	ldw	r2,-16(fp)
 8248b40:	10800617 	ldw	r2,24(r2)
      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
 8248b44:	10002026 	beq	r2,zero,8248bc8 <vfclose_locked+0x15c>
          vfp->data) /* this last test is a sanity check */
      {
         /* try to reclaim the unused data */

         /* allocate a new buffer just big enough for the data */
         new_buffer = vf_alloc_buffer(vfp->comp_size);
 8248b48:	e0bffc17 	ldw	r2,-16(fp)
 8248b4c:	10800817 	ldw	r2,32(r2)
 8248b50:	1009883a 	mov	r4,r2
 8248b54:	82485cc0 	call	82485cc <vf_alloc_buffer>
 8248b58:	e0bffe15 	stw	r2,-8(fp)

         /* if the allocation worked */
         if (new_buffer)
 8248b5c:	e0bffe17 	ldw	r2,-8(fp)
 8248b60:	10001926 	beq	r2,zero,8248bc8 <vfclose_locked+0x15c>
         {
            /* copy the old buffer to the new one */
            MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 8248b64:	e0bffc17 	ldw	r2,-16(fp)
 8248b68:	10c00617 	ldw	r3,24(r2)
 8248b6c:	e0bffc17 	ldw	r2,-16(fp)
 8248b70:	10800817 	ldw	r2,32(r2)
 8248b74:	100d883a 	mov	r6,r2
 8248b78:	180b883a 	mov	r5,r3
 8248b7c:	e13ffe17 	ldw	r4,-8(fp)
 8248b80:	8202e8c0 	call	8202e8c <memcpy>
            /* free the old buffer */
            vf_free_buffer(vfp->data,vfp->buf_size);
 8248b84:	e0bffc17 	ldw	r2,-16(fp)
 8248b88:	10c00617 	ldw	r3,24(r2)
 8248b8c:	e0bffc17 	ldw	r2,-16(fp)
 8248b90:	10800917 	ldw	r2,36(r2)
 8248b94:	100b883a 	mov	r5,r2
 8248b98:	1809883a 	mov	r4,r3
 8248b9c:	82486940 	call	8248694 <vf_free_buffer>
            /* update the buffer pointer and size to reflect the
               just big enough buffer */
            vfp->data = new_buffer;
 8248ba0:	e0bffc17 	ldw	r2,-16(fp)
 8248ba4:	e0fffe17 	ldw	r3,-8(fp)
 8248ba8:	10c00615 	stw	r3,24(r2)
            vfp->buf_size = vfp->comp_size;
 8248bac:	e0bffc17 	ldw	r2,-16(fp)
 8248bb0:	10c00817 	ldw	r3,32(r2)
 8248bb4:	e0bffc17 	ldw	r2,-16(fp)
 8248bb8:	10c00915 	stw	r3,36(r2)
#endif   /* VFS_AUTO_SYNC */

#endif   /* HT_RWVFS */

      /* break to list deletion code below */
      break;
 8248bbc:	00000206 	br	8248bc8 <vfclose_locked+0x15c>
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
         break;
 8248bc0:	0001883a 	nop
 8248bc4:	00000106 	br	8248bcc <vfclose_locked+0x160>
#endif   /* VFS_AUTO_SYNC */

#endif   /* HT_RWVFS */

      /* break to list deletion code below */
      break;
 8248bc8:	0001883a 	nop

   }

   if (vlast)  /* unlink from list of open files */
 8248bcc:	e0bffb17 	ldw	r2,-20(fp)
 8248bd0:	10000526 	beq	r2,zero,8248be8 <vfclose_locked+0x17c>
      vlast->next = vtmp->next;
 8248bd4:	e0bffa17 	ldw	r2,-24(fp)
 8248bd8:	10c00017 	ldw	r3,0(r2)
 8248bdc:	e0bffb17 	ldw	r2,-20(fp)
 8248be0:	10c00015 	stw	r3,0(r2)
 8248be4:	00000306 	br	8248bf4 <vfclose_locked+0x188>
   else
      vfiles = vtmp->next;
 8248be8:	e0bffa17 	ldw	r2,-24(fp)
 8248bec:	10800017 	ldw	r2,0(r2)
 8248bf0:	d0a0d515 	stw	r2,-31916(gp)

   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
 8248bf4:	e13ffa17 	ldw	r4,-24(fp)
 8248bf8:	822e0200 	call	822e020 <npfree>
   /* decrement the number of open files */
   vfs_open_files--;
 8248bfc:	d0a0d917 	ldw	r2,-31900(gp)
 8248c00:	10bfffc4 	addi	r2,r2,-1
 8248c04:	d0a0d915 	stw	r2,-31900(gp)
   return;
 8248c08:	0001883a 	nop
 8248c0c:	00000106 	br	8248c14 <vfclose_locked+0x1a8>

#ifdef HT_LOCALFS
      /* default to call on local system */
      fclose((FILE*)vfd);
#endif   /* HT_LOCALFS */
      return;
 8248c10:	0001883a 	nop
   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
   /* decrement the number of open files */
   vfs_open_files--;
   return;
}
 8248c14:	e037883a 	mov	sp,fp
 8248c18:	dfc00117 	ldw	ra,4(sp)
 8248c1c:	df000017 	ldw	fp,0(sp)
 8248c20:	dec00204 	addi	sp,sp,8
 8248c24:	f800283a 	ret

08248c28 <vfclose>:
 *
 * RETURNS: 
 */

void vfclose(VFILE * vfd)
{
 8248c28:	defffd04 	addi	sp,sp,-12
 8248c2c:	dfc00215 	stw	ra,8(sp)
 8248c30:	df000115 	stw	fp,4(sp)
 8248c34:	df000104 	addi	fp,sp,4
 8248c38:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 8248c3c:	01000144 	movi	r4,5
 8248c40:	822da280 	call	822da28 <wait_app_sem>

   vfclose_locked(vfd);
 8248c44:	e13fff17 	ldw	r4,-4(fp)
 8248c48:	8248a6c0 	call	8248a6c <vfclose_locked>

   vfs_unlock();
 8248c4c:	01000144 	movi	r4,5
 8248c50:	822dae40 	call	822dae4 <post_app_sem>
}
 8248c54:	0001883a 	nop
 8248c58:	e037883a 	mov	sp,fp
 8248c5c:	dfc00117 	ldw	ra,4(sp)
 8248c60:	df000017 	ldw	fp,0(sp)
 8248c64:	dec00204 	addi	sp,sp,8
 8248c68:	f800283a 	ret

08248c6c <vfflush>:
 *
 * RETURNS: 
 */

int vfflush(VFILE * vfd)
{
 8248c6c:	defffd04 	addi	sp,sp,-12
 8248c70:	dfc00215 	stw	ra,8(sp)
 8248c74:	df000115 	stw	fp,4(sp)
 8248c78:	df000104 	addi	fp,sp,4
 8248c7c:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 8248c80:	01000144 	movi	r4,5
 8248c84:	822da280 	call	822da28 <wait_app_sem>

   printf("vfflush(): This function needs to be implemented\n");
 8248c88:	01020974 	movhi	r4,2085
 8248c8c:	2106e804 	addi	r4,r4,7072
 8248c90:	82035a00 	call	82035a0 <puts>

   vfs_unlock();
 8248c94:	01000144 	movi	r4,5
 8248c98:	822dae40 	call	822dae4 <post_app_sem>
   return(0);
 8248c9c:	0005883a 	mov	r2,zero
}
 8248ca0:	e037883a 	mov	sp,fp
 8248ca4:	dfc00117 	ldw	ra,4(sp)
 8248ca8:	df000017 	ldw	fp,0(sp)
 8248cac:	dec00204 	addi	sp,sp,8
 8248cb0:	f800283a 	ret

08248cb4 <vfgets>:

char * vfgets(char * s, int lim, VFILE * fp) 
{
 8248cb4:	defff904 	addi	sp,sp,-28
 8248cb8:	dfc00615 	stw	ra,24(sp)
 8248cbc:	df000515 	stw	fp,20(sp)
 8248cc0:	df000504 	addi	fp,sp,20
 8248cc4:	e13ffd15 	stw	r4,-12(fp)
 8248cc8:	e17ffe15 	stw	r5,-8(fp)
 8248ccc:	e1bfff15 	stw	r6,-4(fp)
   int   c   = EOF;
 8248cd0:	00bfffc4 	movi	r2,-1
 8248cd4:	e0bffb15 	stw	r2,-20(fp)
   char* ret = s;
 8248cd8:	e0bffd17 	ldw	r2,-12(fp)
 8248cdc:	e0bffc15 	stw	r2,-16(fp)

   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 8248ce0:	00000b06 	br	8248d10 <vfgets+0x5c>
      if (( *ret ++ = c) == '\n')
 8248ce4:	e0bffc17 	ldw	r2,-16(fp)
 8248ce8:	10c00044 	addi	r3,r2,1
 8248cec:	e0fffc15 	stw	r3,-16(fp)
 8248cf0:	e0fffb17 	ldw	r3,-20(fp)
 8248cf4:	10c00005 	stb	r3,0(r2)
 8248cf8:	10800003 	ldbu	r2,0(r2)
 8248cfc:	10803fcc 	andi	r2,r2,255
 8248d00:	1080201c 	xori	r2,r2,128
 8248d04:	10bfe004 	addi	r2,r2,-128
 8248d08:	10800298 	cmpnei	r2,r2,10
 8248d0c:	10000c26 	beq	r2,zero,8248d40 <vfgets+0x8c>
char * vfgets(char * s, int lim, VFILE * fp) 
{
   int   c   = EOF;
   char* ret = s;

   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 8248d10:	e0bffe17 	ldw	r2,-8(fp)
 8248d14:	10bfffc4 	addi	r2,r2,-1
 8248d18:	e0bffe15 	stw	r2,-8(fp)
 8248d1c:	e0bffe17 	ldw	r2,-8(fp)
 8248d20:	0080080e 	bge	zero,r2,8248d44 <vfgets+0x90>
 8248d24:	e13fff17 	ldw	r4,-4(fp)
 8248d28:	82499200 	call	8249920 <vgetc>
 8248d2c:	e0bffb15 	stw	r2,-20(fp)
 8248d30:	e0bffb17 	ldw	r2,-20(fp)
 8248d34:	10bfffd8 	cmpnei	r2,r2,-1
 8248d38:	103fea1e 	bne	r2,zero,8248ce4 <vfgets+0x30>
 8248d3c:	00000106 	br	8248d44 <vfgets+0x90>
      if (( *ret ++ = c) == '\n')
         break;
 8248d40:	0001883a 	nop
   *ret = '\0';
 8248d44:	e0bffc17 	ldw	r2,-16(fp)
 8248d48:	10000005 	stb	zero,0(r2)
   return ( c == EOF && ret == s) ? NULL : s;
 8248d4c:	e0bffb17 	ldw	r2,-20(fp)
 8248d50:	10bfffd8 	cmpnei	r2,r2,-1
 8248d54:	1000031e 	bne	r2,zero,8248d64 <vfgets+0xb0>
 8248d58:	e0fffc17 	ldw	r3,-16(fp)
 8248d5c:	e0bffd17 	ldw	r2,-12(fp)
 8248d60:	18800226 	beq	r3,r2,8248d6c <vfgets+0xb8>
 8248d64:	e0bffd17 	ldw	r2,-12(fp)
 8248d68:	00000106 	br	8248d70 <vfgets+0xbc>
 8248d6c:	0005883a 	mov	r2,zero
}
 8248d70:	e037883a 	mov	sp,fp
 8248d74:	dfc00117 	ldw	ra,4(sp)
 8248d78:	df000017 	ldw	fp,0(sp)
 8248d7c:	dec00204 	addi	sp,sp,8
 8248d80:	f800283a 	ret

08248d84 <vfeof>:
 *
 * RETURNS: 1 if the file pointer is at EOF, otherwise 0
 */
 
int vfeof(VFILE * vfd)
{
 8248d84:	defffc04 	addi	sp,sp,-16
 8248d88:	dfc00315 	stw	ra,12(sp)
 8248d8c:	df000215 	stw	fp,8(sp)
 8248d90:	df000204 	addi	fp,sp,8
 8248d94:	e13fff15 	stw	r4,-4(fp)
   int c = 0;
 8248d98:	e03ffe15 	stw	zero,-8(fp)

#ifdef HT_LOCALFS
   return(feof((FILE*)vfd));
#endif
   if ((c = vgetc(vfd)) == EOF )
 8248d9c:	e13fff17 	ldw	r4,-4(fp)
 8248da0:	82499200 	call	8249920 <vgetc>
 8248da4:	e0bffe15 	stw	r2,-8(fp)
 8248da8:	e0bffe17 	ldw	r2,-8(fp)
 8248dac:	10bfffd8 	cmpnei	r2,r2,-1
 8248db0:	1000021e 	bne	r2,zero,8248dbc <vfeof+0x38>
   {
      return 1;
 8248db4:	00800044 	movi	r2,1
 8248db8:	00000106 	br	8248dc0 <vfeof+0x3c>
   }   
   return 0;
 8248dbc:	0005883a 	mov	r2,zero
}
 8248dc0:	e037883a 	mov	sp,fp
 8248dc4:	dfc00117 	ldw	ra,4(sp)
 8248dc8:	df000017 	ldw	fp,0(sp)
 8248dcc:	dec00204 	addi	sp,sp,8
 8248dd0:	f800283a 	ret

08248dd4 <vunlink_flag_open_files>:
 *
 * RETURNS: 
 */

void vunlink_flag_open_files(struct vfs_file * vfp)
{
 8248dd4:	defffd04 	addi	sp,sp,-12
 8248dd8:	df000215 	stw	fp,8(sp)
 8248ddc:	df000204 	addi	fp,sp,8
 8248de0:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8248de4:	d0a0d517 	ldw	r2,-31916(gp)
 8248de8:	e0bffe15 	stw	r2,-8(fp)
 8248dec:	00000906 	br	8248e14 <vunlink_flag_open_files+0x40>
   {
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
 8248df0:	e0bffe17 	ldw	r2,-8(fp)
 8248df4:	10c00117 	ldw	r3,4(r2)
 8248df8:	e0bfff17 	ldw	r2,-4(fp)
 8248dfc:	1880021e 	bne	r3,r2,8248e08 <vunlink_flag_open_files+0x34>
         vtmp->file = NULL;
 8248e00:	e0bffe17 	ldw	r2,-8(fp)
 8248e04:	10000115 	stw	zero,4(r2)
void vunlink_flag_open_files(struct vfs_file * vfp)
{
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8248e08:	e0bffe17 	ldw	r2,-8(fp)
 8248e0c:	10800017 	ldw	r2,0(r2)
 8248e10:	e0bffe15 	stw	r2,-8(fp)
 8248e14:	e0bffe17 	ldw	r2,-8(fp)
 8248e18:	103ff51e 	bne	r2,zero,8248df0 <vunlink_flag_open_files+0x1c>
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
         vtmp->file = NULL;
   }
}
 8248e1c:	0001883a 	nop
 8248e20:	e037883a 	mov	sp,fp
 8248e24:	df000017 	ldw	fp,0(sp)
 8248e28:	dec00104 	addi	sp,sp,4
 8248e2c:	f800283a 	ret

08248e30 <vunlink>:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
int
vunlink(const char * const_name)
{
 8248e30:	defff604 	addi	sp,sp,-40
 8248e34:	dfc00915 	stw	ra,36(sp)
 8248e38:	df000815 	stw	fp,32(sp)
 8248e3c:	df000804 	addi	fp,sp,32
 8248e40:	e13fff15 	stw	r4,-4(fp)
   struct vfs_file * vfp;
   int   rc =  0;
 8248e44:	e03ff815 	stw	zero,-32(fp)
/*
 * Altera Niche Stack Nios port modification:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
   char * name = malloc(strlen(const_name)+1);
 8248e48:	e13fff17 	ldw	r4,-4(fp)
 8248e4c:	8203edc0 	call	8203edc <strlen>
 8248e50:	10800044 	addi	r2,r2,1
 8248e54:	1009883a 	mov	r4,r2
 8248e58:	824b6900 	call	824b690 <malloc>
 8248e5c:	e0bffb15 	stw	r2,-20(fp)
   strcpy(name, const_name);
 8248e60:	e17fff17 	ldw	r5,-4(fp)
 8248e64:	e13ffb17 	ldw	r4,-20(fp)
 8248e68:	824b6b80 	call	824b6b8 <strcpy>
   if (vfs_log_file_name)
      dprintf("vunlink() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 8248e6c:	01000144 	movi	r4,5
 8248e70:	822da280 	call	822da28 <wait_app_sem>

   /* see if the converted name is one of the one's in our list */
   /* if it isn't */
   if ((vfp = vfslookup_locked(name)) == NULL)
 8248e74:	e13ffb17 	ldw	r4,-20(fp)
 8248e78:	82499680 	call	8249968 <vfslookup_locked>
 8248e7c:	e0bffc15 	stw	r2,-16(fp)
 8248e80:	e0bffc17 	ldw	r2,-16(fp)
 8248e84:	1000061e 	bne	r2,zero,8248ea0 <vunlink+0x70>
   {
      vfs_unlock();
 8248e88:	01000144 	movi	r4,5
 8248e8c:	822dae40 	call	822dae4 <post_app_sem>
#ifdef HT_LOCALFS
      /* default to call on local system */
      return remove(name);
#else
      /* no local file system, so return error condition */
      free(name);
 8248e90:	e13ffb17 	ldw	r4,-20(fp)
 8248e94:	824b6a40 	call	824b6a4 <free>
      return -1;
 8248e98:	00bfffc4 	movi	r2,-1
 8248e9c:	00005f06 	br	824901c <vunlink+0x1ec>
#ifdef   HT_RWVFS
   /* save the next link pointer since in one path through the code, 
    * the vfs_file structure gets freed before its unlinked from the 
    * list
    */
   vfnext = vfp->next;
 8248ea0:	e0bffc17 	ldw	r2,-16(fp)
 8248ea4:	10800017 	ldw	r2,0(r2)
 8248ea8:	e0bffd15 	stw	r2,-12(fp)

   /* search list of files to determine predecessor in list */
   vflast = NULL;
 8248eac:	e03ffa15 	stw	zero,-24(fp)
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 8248eb0:	d0a0d617 	ldw	r2,-31912(gp)
 8248eb4:	e0bff915 	stw	r2,-28(fp)
 8248eb8:	00000806 	br	8248edc <vunlink+0xac>
   {
      if (vtmp == vfp)
 8248ebc:	e0fff917 	ldw	r3,-28(fp)
 8248ec0:	e0bffc17 	ldw	r2,-16(fp)
 8248ec4:	18800826 	beq	r3,r2,8248ee8 <vunlink+0xb8>
         break;
      vflast = vtmp;
 8248ec8:	e0bff917 	ldw	r2,-28(fp)
 8248ecc:	e0bffa15 	stw	r2,-24(fp)
    */
   vfnext = vfp->next;

   /* search list of files to determine predecessor in list */
   vflast = NULL;
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 8248ed0:	e0bff917 	ldw	r2,-28(fp)
 8248ed4:	10800017 	ldw	r2,0(r2)
 8248ed8:	e0bff915 	stw	r2,-28(fp)
 8248edc:	e0bff917 	ldw	r2,-28(fp)
 8248ee0:	103ff61e 	bne	r2,zero,8248ebc <vunlink+0x8c>
 8248ee4:	00000106 	br	8248eec <vunlink+0xbc>
   {
      if (vtmp == vfp)
         break;
 8248ee8:	0001883a 	nop
      vflast = vtmp;
   }

   /* this shouldn't happen since vfslookup_locked() already searched
      the list, but just in case */
   if (vtmp == NULL)
 8248eec:	e0bff917 	ldw	r2,-28(fp)
 8248ef0:	1000071e 	bne	r2,zero,8248f10 <vunlink+0xe0>
   {
      dtrap();
 8248ef4:	822d4140 	call	822d414 <dtrap>
      vfs_unlock();
 8248ef8:	01000144 	movi	r4,5
 8248efc:	822dae40 	call	822dae4 <post_app_sem>
      free(name);
 8248f00:	e13ffb17 	ldw	r4,-20(fp)
 8248f04:	824b6a40 	call	824b6a4 <free>
      return -1;
 8248f08:	00bfffc4 	movi	r2,-1
 8248f0c:	00004306 	br	824901c <vunlink+0x1ec>
   while (1)
   {

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 8248f10:	e0bffc17 	ldw	r2,-16(fp)
 8248f14:	10800a17 	ldw	r2,40(r2)
 8248f18:	10000926 	beq	r2,zero,8248f40 <vunlink+0x110>
      {
         /* call that file system's unlink() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfp->method);
 8248f1c:	e0bffc17 	ldw	r2,-16(fp)
 8248f20:	10800a17 	ldw	r2,40(r2)
 8248f24:	e0bffe15 	stw	r2,-8(fp)

         rc = vfs->r_unlink(name);
 8248f28:	e0bffe17 	ldw	r2,-8(fp)
 8248f2c:	10800817 	ldw	r2,32(r2)
 8248f30:	e13ffb17 	ldw	r4,-20(fp)
 8248f34:	103ee83a 	callr	r2
 8248f38:	e0bff815 	stw	r2,-32(fp)
         break;   /* break to list deletion code after end of phoney loop */
 8248f3c:	00002606 	br	8248fd8 <vunlink+0x1a8>
      }
#endif   /* HT_EXTDEV */

      /* if the file is not write enabled, return error condition */
      if (!(vfp->flags & VF_WRITE))
 8248f40:	e0bffc17 	ldw	r2,-16(fp)
 8248f44:	1080058b 	ldhu	r2,22(r2)
 8248f48:	10bfffcc 	andi	r2,r2,65535
 8248f4c:	1080080c 	andi	r2,r2,32
 8248f50:	1000061e 	bne	r2,zero,8248f6c <vunlink+0x13c>
      {
         vfs_unlock();
 8248f54:	01000144 	movi	r4,5
 8248f58:	822dae40 	call	822dae4 <post_app_sem>
         free(name);
 8248f5c:	e13ffb17 	ldw	r4,-20(fp)
 8248f60:	824b6a40 	call	824b6a4 <free>
         return -1;
 8248f64:	00bfffc4 	movi	r2,-1
 8248f68:	00002c06 	br	824901c <vunlink+0x1ec>
      }

      /* if the data buffer containing the file's data was dynamically
         allocated and is not null */
      if ((vfp->flags & VF_DYNAMICDATA) && (vfp->data))
 8248f6c:	e0bffc17 	ldw	r2,-16(fp)
 8248f70:	1080058b 	ldhu	r2,22(r2)
 8248f74:	10bfffcc 	andi	r2,r2,65535
 8248f78:	1080200c 	andi	r2,r2,128
 8248f7c:	10000a26 	beq	r2,zero,8248fa8 <vunlink+0x178>
 8248f80:	e0bffc17 	ldw	r2,-16(fp)
 8248f84:	10800617 	ldw	r2,24(r2)
 8248f88:	10000726 	beq	r2,zero,8248fa8 <vunlink+0x178>
      {
         /* free the buffer */
         vf_free_buffer(vfp->data,vfp->buf_size);
 8248f8c:	e0bffc17 	ldw	r2,-16(fp)
 8248f90:	10c00617 	ldw	r3,24(r2)
 8248f94:	e0bffc17 	ldw	r2,-16(fp)
 8248f98:	10800917 	ldw	r2,36(r2)
 8248f9c:	100b883a 	mov	r5,r2
 8248fa0:	1809883a 	mov	r4,r3
 8248fa4:	82486940 	call	8248694 <vf_free_buffer>
      }

      /* if the vfs_file structure itself was allocated dynamically */
      if (vfp->flags & VF_DYNAMICINFO)
 8248fa8:	e0bffc17 	ldw	r2,-16(fp)
 8248fac:	1080058b 	ldhu	r2,22(r2)
 8248fb0:	10bfffcc 	andi	r2,r2,65535
 8248fb4:	1080100c 	andi	r2,r2,64
 8248fb8:	10000526 	beq	r2,zero,8248fd0 <vunlink+0x1a0>
      {
         /* decrement count of total files */
         vfs_total_dyna_files--;
 8248fbc:	d0a0db17 	ldw	r2,-31892(gp)
 8248fc0:	10bfffc4 	addi	r2,r2,-1
 8248fc4:	d0a0db15 	stw	r2,-31892(gp)

         /* free the vfs_file structure */
         VFS_VFS_FILE_FREE(vfp);
 8248fc8:	e13ffc17 	ldw	r4,-16(fp)
 8248fcc:	822e0200 	call	822e020 <npfree>
         the vfs_file has been deleted from the list */
#ifdef VFS_AUTO_SYNC
      do_sync = 1;
#endif
      /* we were successful at our unlink */
      rc = 0;
 8248fd0:	e03ff815 	stw	zero,-32(fp)

      break;
 8248fd4:	0001883a 	nop
   }

   /* delete the vfs_file structure from the list headed by vfsfiles */
   if (vflast)
 8248fd8:	e0bffa17 	ldw	r2,-24(fp)
 8248fdc:	10000426 	beq	r2,zero,8248ff0 <vunlink+0x1c0>
      vflast->next = vfnext;
 8248fe0:	e0bffa17 	ldw	r2,-24(fp)
 8248fe4:	e0fffd17 	ldw	r3,-12(fp)
 8248fe8:	10c00015 	stw	r3,0(r2)
 8248fec:	00000206 	br	8248ff8 <vunlink+0x1c8>
   else
      vfsfiles = vfnext;
 8248ff0:	e0bffd17 	ldw	r2,-12(fp)
 8248ff4:	d0a0d615 	stw	r2,-31912(gp)

   /* fix up references to deleted file in list of currently open VFILEs */
   vunlink_flag_open_files(vfp);
 8248ff8:	e13ffc17 	ldw	r4,-16(fp)
 8248ffc:	8248dd40 	call	8248dd4 <vunlink_flag_open_files>

   /* flag that the directory is stale so vfs_sync() knows it has to do
      something */
   vfs_dir_stale = TRUE;
 8249000:	00800044 	movi	r2,1
 8249004:	d0a0d815 	stw	r2,-31904(gp)

   /* unlinks not allowed on read-only VFS */
   rc = -1;

#endif   /* HT_RWVFS */
   vfs_unlock();
 8249008:	01000144 	movi	r4,5
 824900c:	822dae40 	call	822dae4 <post_app_sem>
   free(name);
 8249010:	e13ffb17 	ldw	r4,-20(fp)
 8249014:	824b6a40 	call	824b6a4 <free>
   return rc;
 8249018:	e0bff817 	ldw	r2,-32(fp)
}
 824901c:	e037883a 	mov	sp,fp
 8249020:	dfc00117 	ldw	ra,4(sp)
 8249024:	df000017 	ldw	fp,0(sp)
 8249028:	dec00204 	addi	sp,sp,8
 824902c:	f800283a 	ret

08249030 <vfread>:
 * RETURNS: 
 */

int 
vfread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 8249030:	defff604 	addi	sp,sp,-40
 8249034:	dfc00915 	stw	ra,36(sp)
 8249038:	df000815 	stw	fp,32(sp)
 824903c:	df000804 	addi	fp,sp,32
 8249040:	e13ffc15 	stw	r4,-16(fp)
 8249044:	e17ffd15 	stw	r5,-12(fp)
 8249048:	e1bffe15 	stw	r6,-8(fp)
 824904c:	e1ffff15 	stw	r7,-4(fp)
   unsigned bcount;  /* number of bytes put in caller's buffer */

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 8249050:	01000144 	movi	r4,5
 8249054:	822da280 	call	822da28 <wait_app_sem>

   /* if the file is in our list of open files */
   if (isvfile_locked(vfd))
 8249058:	e13fff17 	ldw	r4,-4(fp)
 824905c:	8249ca00 	call	8249ca0 <isvfile_locked>
 8249060:	10004e26 	beq	r2,zero,824919c <vfread+0x16c>
   {

#ifdef HT_RWVFS
      /* the caller is trying to read a handle to a file that's been
         deleted, so he gets 0 data back */
      if (vfd->file == NULL)
 8249064:	e0bfff17 	ldw	r2,-4(fp)
 8249068:	10800117 	ldw	r2,4(r2)
 824906c:	1000041e 	bne	r2,zero,8249080 <vfread+0x50>
      {
         vfs_unlock();
 8249070:	01000144 	movi	r4,5
 8249074:	822dae40 	call	822dae4 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 8249078:	0005883a 	mov	r2,zero
 824907c:	00004a06 	br	82491a8 <vfread+0x178>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfd->file->method)
 8249080:	e0bfff17 	ldw	r2,-4(fp)
 8249084:	10800117 	ldw	r2,4(r2)
 8249088:	10800a17 	ldw	r2,40(r2)
 824908c:	10001026 	beq	r2,zero,82490d0 <vfread+0xa0>
      {
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 8249090:	e0bfff17 	ldw	r2,-4(fp)
 8249094:	10800117 	ldw	r2,4(r2)
 8249098:	10800a17 	ldw	r2,40(r2)
 824909c:	e0bff915 	stw	r2,-28(fp)
         int   rc;

         /* call that system's fread() */
         rc = vfs->r_fread(buf,size,items,vfd);
 82490a0:	e0bff917 	ldw	r2,-28(fp)
 82490a4:	10800317 	ldw	r2,12(r2)
 82490a8:	e1ffff17 	ldw	r7,-4(fp)
 82490ac:	e1bffe17 	ldw	r6,-8(fp)
 82490b0:	e17ffd17 	ldw	r5,-12(fp)
 82490b4:	e13ffc17 	ldw	r4,-16(fp)
 82490b8:	103ee83a 	callr	r2
 82490bc:	e0bffa15 	stw	r2,-24(fp)
         vfs_unlock();
 82490c0:	01000144 	movi	r4,5
 82490c4:	822dae40 	call	822dae4 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return rc;
 82490c8:	e0bffa17 	ldw	r2,-24(fp)
 82490cc:	00003606 	br	82491a8 <vfread+0x178>
#ifdef HT_RWVFS
      /* the data pointer can be NULL if somebody tries to read from 
       * a freshly created file, in which case there is no data in 
       * the file, so return 0
       */
      if (!(vfd->file->data))
 82490d0:	e0bfff17 	ldw	r2,-4(fp)
 82490d4:	10800117 	ldw	r2,4(r2)
 82490d8:	10800617 	ldw	r2,24(r2)
 82490dc:	1000041e 	bne	r2,zero,82490f0 <vfread+0xc0>
      {
         vfs_unlock();
 82490e0:	01000144 	movi	r4,5
 82490e4:	822dae40 	call	822dae4 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 82490e8:	0005883a 	mov	r2,zero
 82490ec:	00002e06 	br	82491a8 <vfread+0x178>
      }
#endif   /* HT_RWVFS */

      bcount = items * size;  /* number of bytes to transfer */
 82490f0:	e0fffe17 	ldw	r3,-8(fp)
 82490f4:	e0bffd17 	ldw	r2,-12(fp)
 82490f8:	1885383a 	mul	r2,r3,r2
 82490fc:	e0bff815 	stw	r2,-32(fp)
         return(items); /* filled user buffer, return # items copied */
      }
      else  /* else fall to faster non-compression code */
#endif   /* HTML_COMPRESSION */
      {  /* get here to do simple uncompressed data read */
         unsigned location = vfd->cmploc - vfd->file->data;
 8249100:	e0bfff17 	ldw	r2,-4(fp)
 8249104:	10800217 	ldw	r2,8(r2)
 8249108:	1007883a 	mov	r3,r2
 824910c:	e0bfff17 	ldw	r2,-4(fp)
 8249110:	10800117 	ldw	r2,4(r2)
 8249114:	10800617 	ldw	r2,24(r2)
 8249118:	1885c83a 	sub	r2,r3,r2
 824911c:	e0bffb15 	stw	r2,-20(fp)

         if (((unsigned long)location + bcount) > vfd->file->comp_size)
 8249120:	e0fffb17 	ldw	r3,-20(fp)
 8249124:	e0bff817 	ldw	r2,-32(fp)
 8249128:	1885883a 	add	r2,r3,r2
 824912c:	e0ffff17 	ldw	r3,-4(fp)
 8249130:	18c00117 	ldw	r3,4(r3)
 8249134:	18c00817 	ldw	r3,32(r3)
 8249138:	1880062e 	bgeu	r3,r2,8249154 <vfread+0x124>
            bcount = (unsigned)(vfd->file->comp_size - location);
 824913c:	e0bfff17 	ldw	r2,-4(fp)
 8249140:	10800117 	ldw	r2,4(r2)
 8249144:	10c00817 	ldw	r3,32(r2)
 8249148:	e0bffb17 	ldw	r2,-20(fp)
 824914c:	1885c83a 	sub	r2,r3,r2
 8249150:	e0bff815 	stw	r2,-32(fp)
         MEMCPY(buf, vfd->cmploc, bcount);
 8249154:	e0bfff17 	ldw	r2,-4(fp)
 8249158:	10800217 	ldw	r2,8(r2)
 824915c:	e1bff817 	ldw	r6,-32(fp)
 8249160:	100b883a 	mov	r5,r2
 8249164:	e13ffc17 	ldw	r4,-16(fp)
 8249168:	8202e8c0 	call	8202e8c <memcpy>
         vfd->cmploc += bcount;
 824916c:	e0bfff17 	ldw	r2,-4(fp)
 8249170:	10c00217 	ldw	r3,8(r2)
 8249174:	e0bff817 	ldw	r2,-32(fp)
 8249178:	1887883a 	add	r3,r3,r2
 824917c:	e0bfff17 	ldw	r2,-4(fp)
 8249180:	10c00215 	stw	r3,8(r2)
      }
      vfs_unlock();
 8249184:	01000144 	movi	r4,5
 8249188:	822dae40 	call	822dae4 <post_app_sem>
      IN_PROFILER(PF_FS, PF_EXIT);
      return (bcount/size);
 824918c:	e17ffd17 	ldw	r5,-12(fp)
 8249190:	e13ff817 	ldw	r4,-32(fp)
 8249194:	8202b8c0 	call	8202b8c <__udivsi3>
 8249198:	00000306 	br	82491a8 <vfread+0x178>
   }

   vfs_unlock();
 824919c:	01000144 	movi	r4,5
 82491a0:	822dae40 	call	822dae4 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fread(buf, size, items, (FILE*)vfd));
#else
   return 0;
 82491a4:	0005883a 	mov	r2,zero
#endif   /* HT_LOCALFS */
}
 82491a8:	e037883a 	mov	sp,fp
 82491ac:	dfc00117 	ldw	ra,4(sp)
 82491b0:	df000017 	ldw	fp,0(sp)
 82491b4:	dec00204 	addi	sp,sp,8
 82491b8:	f800283a 	ret

082491bc <vfwrite_locked>:
 * RETURNS: 
 */

int 
vfwrite_locked(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 82491bc:	defff204 	addi	sp,sp,-56
 82491c0:	dfc00d15 	stw	ra,52(sp)
 82491c4:	df000c15 	stw	fp,48(sp)
 82491c8:	df000c04 	addi	fp,sp,48
 82491cc:	e13ffc15 	stw	r4,-16(fp)
 82491d0:	e17ffd15 	stw	r5,-12(fp)
 82491d4:	e1bffe15 	stw	r6,-8(fp)
 82491d8:	e1ffff15 	stw	r7,-4(fp)
   unsigned long current_offset;
   struct vfs_file * vfp;
#endif   /* HT_RWVFS */

   /* if the file is not in our list of files */
   if (!isvfile_locked(vfd))
 82491dc:	e13fff17 	ldw	r4,-4(fp)
 82491e0:	8249ca00 	call	8249ca0 <isvfile_locked>
 82491e4:	1000021e 	bne	r2,zero,82491f0 <vfwrite_locked+0x34>
   {
#ifdef HT_LOCALFS
      /* default to call on local system */
      return(fwrite(buf, size, items, (FILE*)vfd));
#else
      return EBADF;
 82491e8:	00800244 	movi	r2,9
 82491ec:	0000da06 	br	8249558 <vfwrite_locked+0x39c>
   }
   /* this file is in our list of files */

#ifdef HT_EXTDEV
   /* if the file was created by an external file system */
   if (vfd->file->method)
 82491f0:	e0bfff17 	ldw	r2,-4(fp)
 82491f4:	10800117 	ldw	r2,4(r2)
 82491f8:	10800a17 	ldw	r2,40(r2)
 82491fc:	10000e26 	beq	r2,zero,8249238 <vfwrite_locked+0x7c>
   {
      struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 8249200:	e0bfff17 	ldw	r2,-4(fp)
 8249204:	10800117 	ldw	r2,4(r2)
 8249208:	10800a17 	ldw	r2,40(r2)
 824920c:	e0bff415 	stw	r2,-48(fp)
      int   rc;

      /* call that system's fwrite() */
      rc = vfs->r_fwrite(buf,size,items,vfd);
 8249210:	e0bff417 	ldw	r2,-48(fp)
 8249214:	10800417 	ldw	r2,16(r2)
 8249218:	e1ffff17 	ldw	r7,-4(fp)
 824921c:	e1bffe17 	ldw	r6,-8(fp)
 8249220:	e17ffd17 	ldw	r5,-12(fp)
 8249224:	e13ffc17 	ldw	r4,-16(fp)
 8249228:	103ee83a 	callr	r2
 824922c:	e0bff515 	stw	r2,-44(fp)
      return rc;
 8249230:	e0bff517 	ldw	r2,-44(fp)
 8249234:	0000c806 	br	8249558 <vfwrite_locked+0x39c>

#else    /* HT_RWVFS */

   /* the caller is trying to write to a file that's been deleted,
      so he writes 0 data */
   if (vfd->file == NULL)
 8249238:	e0bfff17 	ldw	r2,-4(fp)
 824923c:	10800117 	ldw	r2,4(r2)
 8249240:	1000021e 	bne	r2,zero,824924c <vfwrite_locked+0x90>
   {
      return 0;
 8249244:	0005883a 	mov	r2,zero
 8249248:	0000c306 	br	8249558 <vfwrite_locked+0x39c>
   }

   vfp = vfd->file;
 824924c:	e0bfff17 	ldw	r2,-4(fp)
 8249250:	10800117 	ldw	r2,4(r2)
 8249254:	e0bff615 	stw	r2,-40(fp)

   /* if the file is not writable, return error condition */
   if (!(vfp->flags & VF_WRITE))
 8249258:	e0bff617 	ldw	r2,-40(fp)
 824925c:	1080058b 	ldhu	r2,22(r2)
 8249260:	10bfffcc 	andi	r2,r2,65535
 8249264:	1080080c 	andi	r2,r2,32
 8249268:	1000051e 	bne	r2,zero,8249280 <vfwrite_locked+0xc4>
   {
      vfd->error = ENP_FILEIO;
 824926c:	e0bfff17 	ldw	r2,-4(fp)
 8249270:	00fff984 	movi	r3,-26
 8249274:	10c00415 	stw	r3,16(r2)
      return 0;
 8249278:	0005883a 	mov	r2,zero
 824927c:	0000b606 	br	8249558 <vfwrite_locked+0x39c>
   }

   /* compute number of bytes to write */
   bcount = size * items;
 8249280:	e0fffd17 	ldw	r3,-12(fp)
 8249284:	e0bffe17 	ldw	r2,-8(fp)
 8249288:	1885383a 	mul	r2,r3,r2
 824928c:	e0bff715 	stw	r2,-36(fp)

   /* get rid of this degenerate case up front */
   if (bcount == 0)
 8249290:	e0bff717 	ldw	r2,-36(fp)
 8249294:	1000021e 	bne	r2,zero,82492a0 <vfwrite_locked+0xe4>
   {
      return 0;
 8249298:	0005883a 	mov	r2,zero
 824929c:	0000ae06 	br	8249558 <vfwrite_locked+0x39c>
   }

   /* if the file currently has no data buffer */
   if (vfp->data == NULL)
 82492a0:	e0bff617 	ldw	r2,-40(fp)
 82492a4:	10800617 	ldw	r2,24(r2)
 82492a8:	10003d1e 	bne	r2,zero,82493a0 <vfwrite_locked+0x1e4>
   {
      /* compute the size of the buffer to be created */
      /* we round up the size of the data to be written so we dont have
         the overhead of a memory allocation on every write */
      unsigned long buf_size = VFS_ROUND_UP((unsigned long)bcount);
 82492ac:	e0bff717 	ldw	r2,-36(fp)
 82492b0:	10bfffc4 	addi	r2,r2,-1
 82492b4:	1004d37a 	srli	r2,r2,13
 82492b8:	10800044 	addi	r2,r2,1
 82492bc:	1004937a 	slli	r2,r2,13
 82492c0:	e0bff815 	stw	r2,-32(fp)

      /* allocate a buffer of that size */
      vfp->data = vf_alloc_buffer(buf_size);
 82492c4:	e13ff817 	ldw	r4,-32(fp)
 82492c8:	82485cc0 	call	82485cc <vf_alloc_buffer>
 82492cc:	1007883a 	mov	r3,r2
 82492d0:	e0bff617 	ldw	r2,-40(fp)
 82492d4:	10c00615 	stw	r3,24(r2)

      /* if the allocation failed */
      if (!(vfp->data))
 82492d8:	e0bff617 	ldw	r2,-40(fp)
 82492dc:	10800617 	ldw	r2,24(r2)
 82492e0:	1000051e 	bne	r2,zero,82492f8 <vfwrite_locked+0x13c>
      {
         vfd->error = ENP_NOMEM;
 82492e4:	e0bfff17 	ldw	r2,-4(fp)
 82492e8:	00fffb04 	movi	r3,-20
 82492ec:	10c00415 	stw	r3,16(r2)
         return 0;
 82492f0:	0005883a 	mov	r2,zero
 82492f4:	00009806 	br	8249558 <vfwrite_locked+0x39c>
      }

      /* store the size of the allocated buffer */
      vfp->buf_size = buf_size;
 82492f8:	e0bff617 	ldw	r2,-40(fp)
 82492fc:	e0fff817 	ldw	r3,-32(fp)
 8249300:	10c00915 	stw	r3,36(r2)

      /* store the number of bytes written in the real and compressed
         file sizes */
      vfp->real_size = bcount;
 8249304:	e0bff617 	ldw	r2,-40(fp)
 8249308:	e0fff717 	ldw	r3,-36(fp)
 824930c:	10c00715 	stw	r3,28(r2)
      vfp->comp_size = bcount;
 8249310:	e0bff617 	ldw	r2,-40(fp)
 8249314:	e0fff717 	ldw	r3,-36(fp)
 8249318:	10c00815 	stw	r3,32(r2)

      /* set the file pointer to the first byte following the last
         byte written */
      vfd->cmploc = vfp->data + bcount;
 824931c:	e0bff617 	ldw	r2,-40(fp)
 8249320:	10c00617 	ldw	r3,24(r2)
 8249324:	e0bff717 	ldw	r2,-36(fp)
 8249328:	1887883a 	add	r3,r3,r2
 824932c:	e0bfff17 	ldw	r2,-4(fp)
 8249330:	10c00215 	stw	r3,8(r2)

      /* turn off the compression flag */
      vfp->flags &= ~VF_HTMLCOMPRESSED;
 8249334:	e0bff617 	ldw	r2,-40(fp)
 8249338:	10c0058b 	ldhu	r3,22(r2)
 824933c:	00bfff84 	movi	r2,-2
 8249340:	1884703a 	and	r2,r3,r2
 8249344:	1007883a 	mov	r3,r2
 8249348:	e0bff617 	ldw	r2,-40(fp)
 824934c:	10c0058d 	sth	r3,22(r2)

      /* the data in the file is stale */
      vfp->flags |= VF_STALE;
 8249350:	e0bff617 	ldw	r2,-40(fp)
 8249354:	1080058b 	ldhu	r2,22(r2)
 8249358:	10808014 	ori	r2,r2,512
 824935c:	1007883a 	mov	r3,r2
 8249360:	e0bff617 	ldw	r2,-40(fp)
 8249364:	10c0058d 	sth	r3,22(r2)

      /* the buffer data was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 8249368:	e0bff617 	ldw	r2,-40(fp)
 824936c:	1080058b 	ldhu	r2,22(r2)
 8249370:	10802014 	ori	r2,r2,128
 8249374:	1007883a 	mov	r3,r2
 8249378:	e0bff617 	ldw	r2,-40(fp)
 824937c:	10c0058d 	sth	r3,22(r2)

      /* copy the data to be written to the file buffer */
      MEMCPY(vfp->data,buf,bcount);
 8249380:	e0bff617 	ldw	r2,-40(fp)
 8249384:	10800617 	ldw	r2,24(r2)
 8249388:	e1bff717 	ldw	r6,-36(fp)
 824938c:	e17ffc17 	ldw	r5,-16(fp)
 8249390:	1009883a 	mov	r4,r2
 8249394:	8202e8c0 	call	8202e8c <memcpy>

      /* return the number of "items" written */
      return items;
 8249398:	e0bffe17 	ldw	r2,-8(fp)
 824939c:	00006e06 	br	8249558 <vfwrite_locked+0x39c>
   }

   /* compute the current offset into the file */
   current_offset = vfd->cmploc - vfp->data;
 82493a0:	e0bfff17 	ldw	r2,-4(fp)
 82493a4:	10800217 	ldw	r2,8(r2)
 82493a8:	1007883a 	mov	r3,r2
 82493ac:	e0bff617 	ldw	r2,-40(fp)
 82493b0:	10800617 	ldw	r2,24(r2)
 82493b4:	1885c83a 	sub	r2,r3,r2
 82493b8:	e0bff915 	stw	r2,-28(fp)

   /* if the data to be written wont fit into the file buffer */
   if ((current_offset + bcount) > vfp->buf_size)
 82493bc:	e0fff917 	ldw	r3,-28(fp)
 82493c0:	e0bff717 	ldw	r2,-36(fp)
 82493c4:	1885883a 	add	r2,r3,r2
 82493c8:	e0fff617 	ldw	r3,-40(fp)
 82493cc:	18c00917 	ldw	r3,36(r3)
 82493d0:	1880382e 	bgeu	r3,r2,82494b4 <vfwrite_locked+0x2f8>
   {
      /* compute the size of a new buffer to hold the data */
      unsigned long new_buf_size = VFS_ROUND_UP(current_offset + bcount);
 82493d4:	e0fff917 	ldw	r3,-28(fp)
 82493d8:	e0bff717 	ldw	r2,-36(fp)
 82493dc:	1885883a 	add	r2,r3,r2
 82493e0:	10bfffc4 	addi	r2,r2,-1
 82493e4:	1004d37a 	srli	r2,r2,13
 82493e8:	10800044 	addi	r2,r2,1
 82493ec:	1004937a 	slli	r2,r2,13
 82493f0:	e0bffa15 	stw	r2,-24(fp)
      unsigned char *new_buffer;

      /* allocate a new buffer */
      new_buffer = vf_alloc_buffer(new_buf_size);
 82493f4:	e13ffa17 	ldw	r4,-24(fp)
 82493f8:	82485cc0 	call	82485cc <vf_alloc_buffer>
 82493fc:	e0bffb15 	stw	r2,-20(fp)

      /* check for allocation failure */
      if (!new_buffer)
 8249400:	e0bffb17 	ldw	r2,-20(fp)
 8249404:	1000051e 	bne	r2,zero,824941c <vfwrite_locked+0x260>
      {
         vfd->error = ENP_NOMEM;
 8249408:	e0bfff17 	ldw	r2,-4(fp)
 824940c:	00fffb04 	movi	r3,-20
 8249410:	10c00415 	stw	r3,16(r2)
         return 0;
 8249414:	0005883a 	mov	r2,zero
 8249418:	00004f06 	br	8249558 <vfwrite_locked+0x39c>
      }

      /* copy the old buffer contents to the new buffer */
      MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 824941c:	e0bff617 	ldw	r2,-40(fp)
 8249420:	10c00617 	ldw	r3,24(r2)
 8249424:	e0bff617 	ldw	r2,-40(fp)
 8249428:	10800817 	ldw	r2,32(r2)
 824942c:	100d883a 	mov	r6,r2
 8249430:	180b883a 	mov	r5,r3
 8249434:	e13ffb17 	ldw	r4,-20(fp)
 8249438:	8202e8c0 	call	8202e8c <memcpy>

      /* if the old buffer had been dynamically allocated */
      if (vfp->flags & VF_DYNAMICDATA)
 824943c:	e0bff617 	ldw	r2,-40(fp)
 8249440:	1080058b 	ldhu	r2,22(r2)
 8249444:	10bfffcc 	andi	r2,r2,65535
 8249448:	1080200c 	andi	r2,r2,128
 824944c:	10000726 	beq	r2,zero,824946c <vfwrite_locked+0x2b0>
      {
         /* free it */
         vf_free_buffer(vfp->data,vfp->buf_size);
 8249450:	e0bff617 	ldw	r2,-40(fp)
 8249454:	10c00617 	ldw	r3,24(r2)
 8249458:	e0bff617 	ldw	r2,-40(fp)
 824945c:	10800917 	ldw	r2,36(r2)
 8249460:	100b883a 	mov	r5,r2
 8249464:	1809883a 	mov	r4,r3
 8249468:	82486940 	call	8248694 <vf_free_buffer>
      }

      /* store the new buffer in the file structure */
      vfp->data = new_buffer;
 824946c:	e0bff617 	ldw	r2,-40(fp)
 8249470:	e0fffb17 	ldw	r3,-20(fp)
 8249474:	10c00615 	stw	r3,24(r2)

      /* store the new buffer size in the file structure */
      vfp->buf_size = new_buf_size;
 8249478:	e0bff617 	ldw	r2,-40(fp)
 824947c:	e0fffa17 	ldw	r3,-24(fp)
 8249480:	10c00915 	stw	r3,36(r2)

      /* the new buffer was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 8249484:	e0bff617 	ldw	r2,-40(fp)
 8249488:	1080058b 	ldhu	r2,22(r2)
 824948c:	10802014 	ori	r2,r2,128
 8249490:	1007883a 	mov	r3,r2
 8249494:	e0bff617 	ldw	r2,-40(fp)
 8249498:	10c0058d 	sth	r3,22(r2)
       * buffer note that this means the VFS does not support 
       * simultaneous opens of the same file, since for that to work, 
       * all the other cmploc's that point to this file would 
       * have to be updated also 
       */
      vfd->cmploc = vfp->data + current_offset;
 824949c:	e0bff617 	ldw	r2,-40(fp)
 82494a0:	10c00617 	ldw	r3,24(r2)
 82494a4:	e0bff917 	ldw	r2,-28(fp)
 82494a8:	1887883a 	add	r3,r3,r2
 82494ac:	e0bfff17 	ldw	r2,-4(fp)
 82494b0:	10c00215 	stw	r3,8(r2)
   }

   /* copy the data to the current file pointer */
   MEMCPY(vfd->cmploc,buf,bcount);
 82494b4:	e0bfff17 	ldw	r2,-4(fp)
 82494b8:	10800217 	ldw	r2,8(r2)
 82494bc:	e1bff717 	ldw	r6,-36(fp)
 82494c0:	e17ffc17 	ldw	r5,-16(fp)
 82494c4:	1009883a 	mov	r4,r2
 82494c8:	8202e8c0 	call	8202e8c <memcpy>

   /* update the current file pointer */
   vfd->cmploc += bcount;
 82494cc:	e0bfff17 	ldw	r2,-4(fp)
 82494d0:	10c00217 	ldw	r3,8(r2)
 82494d4:	e0bff717 	ldw	r2,-36(fp)
 82494d8:	1887883a 	add	r3,r3,r2
 82494dc:	e0bfff17 	ldw	r2,-4(fp)
 82494e0:	10c00215 	stw	r3,8(r2)

   /* if the resulting current offset is greater than the file size */
   if (current_offset + bcount > vfp->comp_size)
 82494e4:	e0fff917 	ldw	r3,-28(fp)
 82494e8:	e0bff717 	ldw	r2,-36(fp)
 82494ec:	1885883a 	add	r2,r3,r2
 82494f0:	e0fff617 	ldw	r3,-40(fp)
 82494f4:	18c00817 	ldw	r3,32(r3)
 82494f8:	1880052e 	bgeu	r3,r2,8249510 <vfwrite_locked+0x354>
   {
      /* update the "compressed" file size */
      vfp->comp_size = current_offset + bcount;
 82494fc:	e0fff917 	ldw	r3,-28(fp)
 8249500:	e0bff717 	ldw	r2,-36(fp)
 8249504:	1887883a 	add	r3,r3,r2
 8249508:	e0bff617 	ldw	r2,-40(fp)
 824950c:	10c00815 	stw	r3,32(r2)
   }

   /* since we turn off the compression bit below, the "real" size and
      the compressed size must be the same */
   vfp->real_size = vfp->comp_size;
 8249510:	e0bff617 	ldw	r2,-40(fp)
 8249514:	10c00817 	ldw	r3,32(r2)
 8249518:	e0bff617 	ldw	r2,-40(fp)
 824951c:	10c00715 	stw	r3,28(r2)

   /* turn off the compression flag */
   vfp->flags &= ~VF_HTMLCOMPRESSED;
 8249520:	e0bff617 	ldw	r2,-40(fp)
 8249524:	10c0058b 	ldhu	r3,22(r2)
 8249528:	00bfff84 	movi	r2,-2
 824952c:	1884703a 	and	r2,r3,r2
 8249530:	1007883a 	mov	r3,r2
 8249534:	e0bff617 	ldw	r2,-40(fp)
 8249538:	10c0058d 	sth	r3,22(r2)

   /* the data in the file is stale */
   vfp->flags |= VF_STALE;
 824953c:	e0bff617 	ldw	r2,-40(fp)
 8249540:	1080058b 	ldhu	r2,22(r2)
 8249544:	10808014 	ori	r2,r2,512
 8249548:	1007883a 	mov	r3,r2
 824954c:	e0bff617 	ldw	r2,-40(fp)
 8249550:	10c0058d 	sth	r3,22(r2)

   /* return the number of "items" written */
   return items;
 8249554:	e0bffe17 	ldw	r2,-8(fp)

#endif   /* HT_RWVFS */
}
 8249558:	e037883a 	mov	sp,fp
 824955c:	dfc00117 	ldw	ra,4(sp)
 8249560:	df000017 	ldw	fp,0(sp)
 8249564:	dec00204 	addi	sp,sp,8
 8249568:	f800283a 	ret

0824956c <vfwrite>:
 * RETURNS: 
 */

int
vfwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 824956c:	defff904 	addi	sp,sp,-28
 8249570:	dfc00615 	stw	ra,24(sp)
 8249574:	df000515 	stw	fp,20(sp)
 8249578:	df000504 	addi	fp,sp,20
 824957c:	e13ffc15 	stw	r4,-16(fp)
 8249580:	e17ffd15 	stw	r5,-12(fp)
 8249584:	e1bffe15 	stw	r6,-8(fp)
 8249588:	e1ffff15 	stw	r7,-4(fp)
   int   rc;

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 824958c:	01000144 	movi	r4,5
 8249590:	822da280 	call	822da28 <wait_app_sem>

   /* do the write */
   rc = vfwrite_locked(buf, size, items, vfd);
 8249594:	e1ffff17 	ldw	r7,-4(fp)
 8249598:	e1bffe17 	ldw	r6,-8(fp)
 824959c:	e17ffd17 	ldw	r5,-12(fp)
 82495a0:	e13ffc17 	ldw	r4,-16(fp)
 82495a4:	82491bc0 	call	82491bc <vfwrite_locked>
 82495a8:	e0bffb15 	stw	r2,-20(fp)

   /* unlock the VFS */
   vfs_unlock();
 82495ac:	01000144 	movi	r4,5
 82495b0:	822dae40 	call	822dae4 <post_app_sem>

   IN_PROFILER(PF_FS, PF_EXIT);

   return rc;
 82495b4:	e0bffb17 	ldw	r2,-20(fp)
}
 82495b8:	e037883a 	mov	sp,fp
 82495bc:	dfc00117 	ldw	ra,4(sp)
 82495c0:	df000017 	ldw	fp,0(sp)
 82495c4:	dec00204 	addi	sp,sp,8
 82495c8:	f800283a 	ret

082495cc <vfseek>:
 * RETURNS: 
 */

int 
vfseek(VFILE * vfd, long offset, int mode)
{
 82495cc:	defff904 	addi	sp,sp,-28
 82495d0:	dfc00615 	stw	ra,24(sp)
 82495d4:	df000515 	stw	fp,20(sp)
 82495d8:	df000504 	addi	fp,sp,20
 82495dc:	e13ffd15 	stw	r4,-12(fp)
 82495e0:	e17ffe15 	stw	r5,-8(fp)
 82495e4:	e1bfff15 	stw	r6,-4(fp)
   /* lock the VFS */
   vfs_lock();
 82495e8:	01000144 	movi	r4,5
 82495ec:	822da280 	call	822da28 <wait_app_sem>

   if (isvfile_locked(vfd))
 82495f0:	e13ffd17 	ldw	r4,-12(fp)
 82495f4:	8249ca00 	call	8249ca0 <isvfile_locked>
 82495f8:	10003f26 	beq	r2,zero,82496f8 <vfseek+0x12c>
   {
#ifdef HT_RWVFS
      /* the caller is trying to seek a file that's been deleted,
         so return an error indication */
      if (vfd->file == NULL)
 82495fc:	e0bffd17 	ldw	r2,-12(fp)
 8249600:	10800117 	ldw	r2,4(r2)
 8249604:	1000041e 	bne	r2,zero,8249618 <vfseek+0x4c>
      {
         vfs_unlock();
 8249608:	01000144 	movi	r4,5
 824960c:	822dae40 	call	822dae4 <post_app_sem>
         return -1;
 8249610:	00bfffc4 	movi	r2,-1
 8249614:	00003b06 	br	8249704 <vfseek+0x138>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 8249618:	e0bffd17 	ldw	r2,-12(fp)
 824961c:	10800117 	ldw	r2,4(r2)
 8249620:	10800a17 	ldw	r2,40(r2)
 8249624:	10000f26 	beq	r2,zero,8249664 <vfseek+0x98>
      {
         struct vfroutines *vfp = (struct vfroutines*)(vfd->file->method);
 8249628:	e0bffd17 	ldw	r2,-12(fp)
 824962c:	10800117 	ldw	r2,4(r2)
 8249630:	10800a17 	ldw	r2,40(r2)
 8249634:	e0bffb15 	stw	r2,-20(fp)
         int   rc;

         rc = vfp->r_fseek(vfd, offset, mode);
 8249638:	e0bffb17 	ldw	r2,-20(fp)
 824963c:	10800517 	ldw	r2,20(r2)
 8249640:	e1bfff17 	ldw	r6,-4(fp)
 8249644:	e17ffe17 	ldw	r5,-8(fp)
 8249648:	e13ffd17 	ldw	r4,-12(fp)
 824964c:	103ee83a 	callr	r2
 8249650:	e0bffc15 	stw	r2,-16(fp)
         vfs_unlock();
 8249654:	01000144 	movi	r4,5
 8249658:	822dae40 	call	822dae4 <post_app_sem>
         return rc;
 824965c:	e0bffc17 	ldw	r2,-16(fp)
 8249660:	00002806 	br	8249704 <vfseek+0x138>
      }
#endif   /* HT_EXTDEV */
      /* this vfseek() currently only supports seek to exact
         end or begining of file */
      switch (mode)
 8249664:	e0bfff17 	ldw	r2,-4(fp)
 8249668:	10c00060 	cmpeqi	r3,r2,1
 824966c:	18000b1e 	bne	r3,zero,824969c <vfseek+0xd0>
 8249670:	10c000a0 	cmpeqi	r3,r2,2
 8249674:	1800101e 	bne	r3,zero,82496b8 <vfseek+0xec>
 8249678:	10001b1e 	bne	r2,zero,82496e8 <vfseek+0x11c>
      {
      case SEEK_SET:
         vfd->cmploc = vfd->file->data + offset;
 824967c:	e0bffd17 	ldw	r2,-12(fp)
 8249680:	10800117 	ldw	r2,4(r2)
 8249684:	10c00617 	ldw	r3,24(r2)
 8249688:	e0bffe17 	ldw	r2,-8(fp)
 824968c:	1887883a 	add	r3,r3,r2
 8249690:	e0bffd17 	ldw	r2,-12(fp)
 8249694:	10c00215 	stw	r3,8(r2)
         break;
 8249698:	00001306 	br	82496e8 <vfseek+0x11c>
      case SEEK_CUR:
         /* If the file is compressed, then the following
          * adjustment is inaccurate. Currently we don't have
          * any scenario where this happens. - handle later */
         vfd->cmploc += offset; 
 824969c:	e0bffd17 	ldw	r2,-12(fp)
 82496a0:	10c00217 	ldw	r3,8(r2)
 82496a4:	e0bffe17 	ldw	r2,-8(fp)
 82496a8:	1887883a 	add	r3,r3,r2
 82496ac:	e0bffd17 	ldw	r2,-12(fp)
 82496b0:	10c00215 	stw	r3,8(r2)
         break;
 82496b4:	00000c06 	br	82496e8 <vfseek+0x11c>
      case SEEK_END:
         vfd->cmploc = vfd->file->data + vfd->file->comp_size + offset;
 82496b8:	e0bffd17 	ldw	r2,-12(fp)
 82496bc:	10800117 	ldw	r2,4(r2)
 82496c0:	10c00617 	ldw	r3,24(r2)
 82496c4:	e0bffd17 	ldw	r2,-12(fp)
 82496c8:	10800117 	ldw	r2,4(r2)
 82496cc:	11000817 	ldw	r4,32(r2)
 82496d0:	e0bffe17 	ldw	r2,-8(fp)
 82496d4:	2085883a 	add	r2,r4,r2
 82496d8:	1887883a 	add	r3,r3,r2
 82496dc:	e0bffd17 	ldw	r2,-12(fp)
 82496e0:	10c00215 	stw	r3,8(r2)
         break;
 82496e4:	0001883a 	nop
      }
      vfs_unlock();
 82496e8:	01000144 	movi	r4,5
 82496ec:	822dae40 	call	822dae4 <post_app_sem>
      return(0);
 82496f0:	0005883a 	mov	r2,zero
 82496f4:	00000306 	br	8249704 <vfseek+0x138>
   }

   vfs_unlock();
 82496f8:	01000144 	movi	r4,5
 82496fc:	822dae40 	call	822dae4 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fseek((FILE*)vfd, offset, mode));
#else
   return -1;
 8249700:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 8249704:	e037883a 	mov	sp,fp
 8249708:	dfc00117 	ldw	ra,4(sp)
 824970c:	df000017 	ldw	fp,0(sp)
 8249710:	dec00204 	addi	sp,sp,8
 8249714:	f800283a 	ret

08249718 <vftell>:
 * RETURNS: 
 */

long
vftell(VFILE * vfd)
{
 8249718:	defffb04 	addi	sp,sp,-20
 824971c:	dfc00415 	stw	ra,16(sp)
 8249720:	df000315 	stw	fp,12(sp)
 8249724:	df000304 	addi	fp,sp,12
 8249728:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 824972c:	01000144 	movi	r4,5
 8249730:	822da280 	call	822da28 <wait_app_sem>

   if (isvfile_locked(vfd))
 8249734:	e13fff17 	ldw	r4,-4(fp)
 8249738:	8249ca00 	call	8249ca0 <isvfile_locked>
 824973c:	10003226 	beq	r2,zero,8249808 <vftell+0xf0>
   {
#ifdef HT_RWVFS
      /* the caller is trying to ftell a deleted file,
         so return an error condition */
      if (vfd->file == NULL)
 8249740:	e0bfff17 	ldw	r2,-4(fp)
 8249744:	10800117 	ldw	r2,4(r2)
 8249748:	1000041e 	bne	r2,zero,824975c <vftell+0x44>
      {
         vfs_unlock();
 824974c:	01000144 	movi	r4,5
 8249750:	822dae40 	call	822dae4 <post_app_sem>
         return -1;
 8249754:	00bfffc4 	movi	r2,-1
 8249758:	00002e06 	br	8249814 <vftell+0xfc>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 824975c:	e0bfff17 	ldw	r2,-4(fp)
 8249760:	10800117 	ldw	r2,4(r2)
 8249764:	10800a17 	ldw	r2,40(r2)
 8249768:	10000d26 	beq	r2,zero,82497a0 <vftell+0x88>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 824976c:	e0bfff17 	ldw	r2,-4(fp)
 8249770:	10800117 	ldw	r2,4(r2)
 8249774:	10800a17 	ldw	r2,40(r2)
 8249778:	e0bffd15 	stw	r2,-12(fp)
         long  rc;

         rc = vfp->r_ftell(vfd);
 824977c:	e0bffd17 	ldw	r2,-12(fp)
 8249780:	10800617 	ldw	r2,24(r2)
 8249784:	e13fff17 	ldw	r4,-4(fp)
 8249788:	103ee83a 	callr	r2
 824978c:	e0bffe15 	stw	r2,-8(fp)
         vfs_unlock();
 8249790:	01000144 	movi	r4,5
 8249794:	822dae40 	call	822dae4 <post_app_sem>
         return rc;
 8249798:	e0bffe17 	ldw	r2,-8(fp)
 824979c:	00001d06 	br	8249814 <vftell+0xfc>
      }
#endif   /* HT_EXTDEV */
      /* if file has been fseeked to end, return uncompressed size.
         else return current location in compression stream */
      if (vfd->cmploc == vfd->file->data + vfd->file->comp_size)
 82497a0:	e0bfff17 	ldw	r2,-4(fp)
 82497a4:	10c00217 	ldw	r3,8(r2)
 82497a8:	e0bfff17 	ldw	r2,-4(fp)
 82497ac:	10800117 	ldw	r2,4(r2)
 82497b0:	11000617 	ldw	r4,24(r2)
 82497b4:	e0bfff17 	ldw	r2,-4(fp)
 82497b8:	10800117 	ldw	r2,4(r2)
 82497bc:	10800817 	ldw	r2,32(r2)
 82497c0:	2085883a 	add	r2,r4,r2
 82497c4:	1880061e 	bne	r3,r2,82497e0 <vftell+0xc8>
      {
         vfs_unlock();
 82497c8:	01000144 	movi	r4,5
 82497cc:	822dae40 	call	822dae4 <post_app_sem>

         return vfd->file->comp_size;
 82497d0:	e0bfff17 	ldw	r2,-4(fp)
 82497d4:	10800117 	ldw	r2,4(r2)
 82497d8:	10800817 	ldw	r2,32(r2)
 82497dc:	00000d06 	br	8249814 <vftell+0xfc>
      }
      else
      {
         vfs_unlock();
 82497e0:	01000144 	movi	r4,5
 82497e4:	822dae40 	call	822dae4 <post_app_sem>

         return (vfd->cmploc - vfd->file->data);
 82497e8:	e0bfff17 	ldw	r2,-4(fp)
 82497ec:	10800217 	ldw	r2,8(r2)
 82497f0:	1007883a 	mov	r3,r2
 82497f4:	e0bfff17 	ldw	r2,-4(fp)
 82497f8:	10800117 	ldw	r2,4(r2)
 82497fc:	10800617 	ldw	r2,24(r2)
 8249800:	1885c83a 	sub	r2,r3,r2
 8249804:	00000306 	br	8249814 <vftell+0xfc>
      }
   }

   vfs_unlock();
 8249808:	01000144 	movi	r4,5
 824980c:	822dae40 	call	822dae4 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(ftell((FILE*)vfd));
#else
   return EBADF;
 8249810:	00800244 	movi	r2,9
#endif   /* HT_LOCALFS */
}
 8249814:	e037883a 	mov	sp,fp
 8249818:	dfc00117 	ldw	ra,4(sp)
 824981c:	df000017 	ldw	fp,0(sp)
 8249820:	dec00204 	addi	sp,sp,8
 8249824:	f800283a 	ret

08249828 <vgetc_locked>:
 * RETURNS: 
 */

int
vgetc_locked(VFILE * vfd)
{
 8249828:	defffb04 	addi	sp,sp,-20
 824982c:	dfc00415 	stw	ra,16(sp)
 8249830:	df000315 	stw	fp,12(sp)
 8249834:	df000304 	addi	fp,sp,12
 8249838:	e13fff15 	stw	r4,-4(fp)
   int   chr;

   if (isvfile_locked(vfd))
 824983c:	e13fff17 	ldw	r4,-4(fp)
 8249840:	8249ca00 	call	8249ca0 <isvfile_locked>
 8249844:	10002f26 	beq	r2,zero,8249904 <vgetc_locked+0xdc>
   {
#ifdef HT_RWVFS
      /* the caller is trying to read a file that's been deleted,
         so return an error condition */
      if (vfd->file == NULL)
 8249848:	e0bfff17 	ldw	r2,-4(fp)
 824984c:	10800117 	ldw	r2,4(r2)
 8249850:	1000021e 	bne	r2,zero,824985c <vgetc_locked+0x34>
      {
         return EOF;
 8249854:	00bfffc4 	movi	r2,-1
 8249858:	00002c06 	br	824990c <vgetc_locked+0xe4>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 824985c:	e0bfff17 	ldw	r2,-4(fp)
 8249860:	10800117 	ldw	r2,4(r2)
 8249864:	10800a17 	ldw	r2,40(r2)
 8249868:	10000926 	beq	r2,zero,8249890 <vgetc_locked+0x68>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 824986c:	e0bfff17 	ldw	r2,-4(fp)
 8249870:	10800117 	ldw	r2,4(r2)
 8249874:	10800a17 	ldw	r2,40(r2)
 8249878:	e0bffe15 	stw	r2,-8(fp)
         return (vfp->r_fgetc(vfd));
 824987c:	e0bffe17 	ldw	r2,-8(fp)
 8249880:	10800717 	ldw	r2,28(r2)
 8249884:	e13fff17 	ldw	r4,-4(fp)
 8249888:	103ee83a 	callr	r2
 824988c:	00001f06 	br	824990c <vgetc_locked+0xe4>
#endif   /* HT_EXTDEV */

#ifdef HT_RWVFS
      /* a freshly created file might not have a data buffer associated
         with it yet */
      if (vfd->file->data == NULL)
 8249890:	e0bfff17 	ldw	r2,-4(fp)
 8249894:	10800117 	ldw	r2,4(r2)
 8249898:	10800617 	ldw	r2,24(r2)
 824989c:	1000021e 	bne	r2,zero,82498a8 <vgetc_locked+0x80>
         return EOF;
 82498a0:	00bfffc4 	movi	r2,-1
 82498a4:	00001906 	br	824990c <vgetc_locked+0xe4>
      }
      else  /* HTML compression flag not set */
      {
#endif   /* HTML_COMPRESSION */
         /* Check to see if read has advanced to end of file */
         if (vfd->cmploc >= (vfd->file->data + vfd->file->comp_size))
 82498a8:	e0bfff17 	ldw	r2,-4(fp)
 82498ac:	10c00217 	ldw	r3,8(r2)
 82498b0:	e0bfff17 	ldw	r2,-4(fp)
 82498b4:	10800117 	ldw	r2,4(r2)
 82498b8:	11000617 	ldw	r4,24(r2)
 82498bc:	e0bfff17 	ldw	r2,-4(fp)
 82498c0:	10800117 	ldw	r2,4(r2)
 82498c4:	10800817 	ldw	r2,32(r2)
 82498c8:	2085883a 	add	r2,r4,r2
 82498cc:	18800336 	bltu	r3,r2,82498dc <vgetc_locked+0xb4>
            chr = EOF;
 82498d0:	00bfffc4 	movi	r2,-1
 82498d4:	e0bffd15 	stw	r2,-12(fp)
 82498d8:	00000806 	br	82498fc <vgetc_locked+0xd4>
         else  /* else just get next char to return */
            chr = *(vfd->cmploc++);
 82498dc:	e0bfff17 	ldw	r2,-4(fp)
 82498e0:	10800217 	ldw	r2,8(r2)
 82498e4:	11000044 	addi	r4,r2,1
 82498e8:	e0ffff17 	ldw	r3,-4(fp)
 82498ec:	19000215 	stw	r4,8(r3)
 82498f0:	10800003 	ldbu	r2,0(r2)
 82498f4:	10803fcc 	andi	r2,r2,255
 82498f8:	e0bffd15 	stw	r2,-12(fp)
#ifdef HTML_COMPRESSION
      }  /* need to close brace form if...else; */
#endif   /* HTML_COMPRESSION */

      return chr;
 82498fc:	e0bffd17 	ldw	r2,-12(fp)
 8249900:	00000206 	br	824990c <vgetc_locked+0xe4>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(getc((FILE*)vfd));
#else
   dtrap(); /* can this happen? */
 8249904:	822d4140 	call	822d414 <dtrap>
   return EOF;
 8249908:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 824990c:	e037883a 	mov	sp,fp
 8249910:	dfc00117 	ldw	ra,4(sp)
 8249914:	df000017 	ldw	fp,0(sp)
 8249918:	dec00204 	addi	sp,sp,8
 824991c:	f800283a 	ret

08249920 <vgetc>:
 * RETURNS: 
 */

int
vgetc(VFILE * vfd)
{
 8249920:	defffc04 	addi	sp,sp,-16
 8249924:	dfc00315 	stw	ra,12(sp)
 8249928:	df000215 	stw	fp,8(sp)
 824992c:	df000204 	addi	fp,sp,8
 8249930:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 8249934:	01000144 	movi	r4,5
 8249938:	822da280 	call	822da28 <wait_app_sem>

   /* get the character */
   rc = vgetc_locked(vfd);
 824993c:	e13fff17 	ldw	r4,-4(fp)
 8249940:	82498280 	call	8249828 <vgetc_locked>
 8249944:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 8249948:	01000144 	movi	r4,5
 824994c:	822dae40 	call	822dae4 <post_app_sem>
   return rc;
 8249950:	e0bffe17 	ldw	r2,-8(fp)
}
 8249954:	e037883a 	mov	sp,fp
 8249958:	dfc00117 	ldw	ra,4(sp)
 824995c:	df000017 	ldw	fp,0(sp)
 8249960:	dec00204 	addi	sp,sp,8
 8249964:	f800283a 	ret

08249968 <vfslookup_locked>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup_locked(char * name)
{
 8249968:	defffb04 	addi	sp,sp,-20
 824996c:	dfc00415 	stw	ra,16(sp)
 8249970:	df000315 	stw	fp,12(sp)
 8249974:	df000304 	addi	fp,sp,12
 8249978:	e13fff15 	stw	r4,-4(fp)

#ifdef VFS_STRIPPATH
   char *   cp;

   /* If root path is prepended to name, skip past it */
   if (*name == '/' || *name == '\\')
 824997c:	e0bfff17 	ldw	r2,-4(fp)
 8249980:	10800003 	ldbu	r2,0(r2)
 8249984:	10803fcc 	andi	r2,r2,255
 8249988:	1080201c 	xori	r2,r2,128
 824998c:	10bfe004 	addi	r2,r2,-128
 8249990:	10800be0 	cmpeqi	r2,r2,47
 8249994:	1000071e 	bne	r2,zero,82499b4 <vfslookup_locked+0x4c>
 8249998:	e0bfff17 	ldw	r2,-4(fp)
 824999c:	10800003 	ldbu	r2,0(r2)
 82499a0:	10803fcc 	andi	r2,r2,255
 82499a4:	1080201c 	xori	r2,r2,128
 82499a8:	10bfe004 	addi	r2,r2,-128
 82499ac:	10801718 	cmpnei	r2,r2,92
 82499b0:	1000191e 	bne	r2,zero,8249a18 <vfslookup_locked+0xb0>
   {
      cp = strippath(name);
 82499b4:	e13fff17 	ldw	r4,-4(fp)
 82499b8:	8249ad40 	call	8249ad4 <strippath>
 82499bc:	e0bffe15 	stw	r2,-8(fp)

      if (!cp) /* strippath coundn't match our path */
 82499c0:	e0bffe17 	ldw	r2,-8(fp)
 82499c4:	1000121e 	bne	r2,zero,8249a10 <vfslookup_locked+0xa8>
      {
         /* Files like "/hub47.gif" need to be taken care of */
         if (*name == '/' || *name == '\\')
 82499c8:	e0bfff17 	ldw	r2,-4(fp)
 82499cc:	10800003 	ldbu	r2,0(r2)
 82499d0:	10803fcc 	andi	r2,r2,255
 82499d4:	1080201c 	xori	r2,r2,128
 82499d8:	10bfe004 	addi	r2,r2,-128
 82499dc:	10800be0 	cmpeqi	r2,r2,47
 82499e0:	1000071e 	bne	r2,zero,8249a00 <vfslookup_locked+0x98>
 82499e4:	e0bfff17 	ldw	r2,-4(fp)
 82499e8:	10800003 	ldbu	r2,0(r2)
 82499ec:	10803fcc 	andi	r2,r2,255
 82499f0:	1080201c 	xori	r2,r2,128
 82499f4:	10bfe004 	addi	r2,r2,-128
 82499f8:	10801718 	cmpnei	r2,r2,92
 82499fc:	1000061e 	bne	r2,zero,8249a18 <vfslookup_locked+0xb0>
            name++;
 8249a00:	e0bfff17 	ldw	r2,-4(fp)
 8249a04:	10800044 	addi	r2,r2,1
 8249a08:	e0bfff15 	stw	r2,-4(fp)
 8249a0c:	00000206 	br	8249a18 <vfslookup_locked+0xb0>
      }
      else
         name = cp ;
 8249a10:	e0bffe17 	ldw	r2,-8(fp)
 8249a14:	e0bfff15 	stw	r2,-4(fp)
   }
#endif   /* VFS_STRIPPATH */

   /* see if there is a question mark in the file name */
   if (strchr(name,'?'))
 8249a18:	01400fc4 	movi	r5,63
 8249a1c:	e13fff17 	ldw	r4,-4(fp)
 8249a20:	82037000 	call	8203700 <strchr>
 8249a24:	10000326 	beq	r2,zero,8249a34 <vfslookup_locked+0xcc>
   {
      dtrap(); /* is this still allowed? */
 8249a28:	822d4140 	call	822d414 <dtrap>
      return NULL;
 8249a2c:	0005883a 	mov	r2,zero
 8249a30:	00001106 	br	8249a78 <vfslookup_locked+0x110>
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 8249a34:	d0a0d617 	ldw	r2,-31912(gp)
 8249a38:	e0bffd15 	stw	r2,-12(fp)
 8249a3c:	00000b06 	br	8249a6c <vfslookup_locked+0x104>
   {
      if (strcmp(name, vp->name) == 0)
 8249a40:	e0bffd17 	ldw	r2,-12(fp)
 8249a44:	10800104 	addi	r2,r2,4
 8249a48:	100b883a 	mov	r5,r2
 8249a4c:	e13fff17 	ldw	r4,-4(fp)
 8249a50:	820df280 	call	820df28 <strcmp>
 8249a54:	1000021e 	bne	r2,zero,8249a60 <vfslookup_locked+0xf8>
         return vp;
 8249a58:	e0bffd17 	ldw	r2,-12(fp)
 8249a5c:	00000606 	br	8249a78 <vfslookup_locked+0x110>
   {
      dtrap(); /* is this still allowed? */
      return NULL;
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 8249a60:	e0bffd17 	ldw	r2,-12(fp)
 8249a64:	10800017 	ldw	r2,0(r2)
 8249a68:	e0bffd15 	stw	r2,-12(fp)
 8249a6c:	e0bffd17 	ldw	r2,-12(fp)
 8249a70:	103ff31e 	bne	r2,zero,8249a40 <vfslookup_locked+0xd8>
   {
      if (strcmp(name, vp->name) == 0)
         return vp;
   }

   return NULL;   /* fall to here if not found in for loop */
 8249a74:	0005883a 	mov	r2,zero
}
 8249a78:	e037883a 	mov	sp,fp
 8249a7c:	dfc00117 	ldw	ra,4(sp)
 8249a80:	df000017 	ldw	fp,0(sp)
 8249a84:	dec00204 	addi	sp,sp,8
 8249a88:	f800283a 	ret

08249a8c <vfslookup>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup(char * name) 
{
 8249a8c:	defffc04 	addi	sp,sp,-16
 8249a90:	dfc00315 	stw	ra,12(sp)
 8249a94:	df000215 	stw	fp,8(sp)
 8249a98:	df000204 	addi	fp,sp,8
 8249a9c:	e13fff15 	stw	r4,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfslookup() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 8249aa0:	01000144 	movi	r4,5
 8249aa4:	822da280 	call	822da28 <wait_app_sem>

   /* do the lookup */
   vp = vfslookup_locked(name);
 8249aa8:	e13fff17 	ldw	r4,-4(fp)
 8249aac:	82499680 	call	8249968 <vfslookup_locked>
 8249ab0:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 8249ab4:	01000144 	movi	r4,5
 8249ab8:	822dae40 	call	822dae4 <post_app_sem>
   return vp;
 8249abc:	e0bffe17 	ldw	r2,-8(fp)
}
 8249ac0:	e037883a 	mov	sp,fp
 8249ac4:	dfc00117 	ldw	ra,4(sp)
 8249ac8:	df000017 	ldw	fp,0(sp)
 8249acc:	dec00204 	addi	sp,sp,8
 8249ad0:	f800283a 	ret

08249ad4 <strippath>:
 * have the http_root_path prepended; or on any error. 
 */

char * 
strippath(char * name)
{
 8249ad4:	defff904 	addi	sp,sp,-28
 8249ad8:	dfc00615 	stw	ra,24(sp)
 8249adc:	df000515 	stw	fp,20(sp)
 8249ae0:	df000504 	addi	fp,sp,20
 8249ae4:	e13fff15 	stw	r4,-4(fp)
   char *   path; /* pointer into system path */
   char *   ptmp; /* another pointer into path */
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
 8249ae8:	e13fff17 	ldw	r4,-4(fp)
 8249aec:	8228c880 	call	8228c88 <uslash>
 8249af0:	e0bffc15 	stw	r2,-16(fp)
   path = http_root_path; /* The servers root path, at least one UNIX slash */
 8249af4:	d0a05517 	ldw	r2,-32428(gp)
 8249af8:	e0bffb15 	stw	r2,-20(fp)
   while (*path && *ntmp)
 8249afc:	00003a06 	br	8249be8 <strippath+0x114>
   {
      while (*path == '/') path++;   /* strip leading slash */
 8249b00:	e0bffb17 	ldw	r2,-20(fp)
 8249b04:	10800044 	addi	r2,r2,1
 8249b08:	e0bffb15 	stw	r2,-20(fp)
 8249b0c:	e0bffb17 	ldw	r2,-20(fp)
 8249b10:	10800003 	ldbu	r2,0(r2)
 8249b14:	10803fcc 	andi	r2,r2,255
 8249b18:	1080201c 	xori	r2,r2,128
 8249b1c:	10bfe004 	addi	r2,r2,-128
 8249b20:	10800be0 	cmpeqi	r2,r2,47
 8249b24:	103ff61e 	bne	r2,zero,8249b00 <strippath+0x2c>
         if (*path == 0)
 8249b28:	e0bffb17 	ldw	r2,-20(fp)
 8249b2c:	10800003 	ldbu	r2,0(r2)
 8249b30:	10803fcc 	andi	r2,r2,255
 8249b34:	1080201c 	xori	r2,r2,128
 8249b38:	10bfe004 	addi	r2,r2,-128
 8249b3c:	10003726 	beq	r2,zero,8249c1c <strippath+0x148>
         break;
      /* find number of chars in this directory layer's name */
      ptmp = strchr(path, '/');   /* location of next slash in path */
 8249b40:	01400bc4 	movi	r5,47
 8249b44:	e13ffb17 	ldw	r4,-20(fp)
 8249b48:	82037000 	call	8203700 <strchr>
 8249b4c:	e0bffe15 	stw	r2,-8(fp)
      if (ptmp)
 8249b50:	e0bffe17 	ldw	r2,-8(fp)
 8249b54:	10000526 	beq	r2,zero,8249b6c <strippath+0x98>
         dirlen = ptmp - path;
 8249b58:	e0fffe17 	ldw	r3,-8(fp)
 8249b5c:	e0bffb17 	ldw	r2,-20(fp)
 8249b60:	1885c83a 	sub	r2,r3,r2
 8249b64:	e0bffd15 	stw	r2,-12(fp)
 8249b68:	00000706 	br	8249b88 <strippath+0xb4>
      else
         dirlen = strlen(path);
 8249b6c:	e13ffb17 	ldw	r4,-20(fp)
 8249b70:	8203edc0 	call	8203edc <strlen>
 8249b74:	e0bffd15 	stw	r2,-12(fp)

      while (*ntmp == '/') ntmp++;   /* strip leading slash */
 8249b78:	00000306 	br	8249b88 <strippath+0xb4>
 8249b7c:	e0bffc17 	ldw	r2,-16(fp)
 8249b80:	10800044 	addi	r2,r2,1
 8249b84:	e0bffc15 	stw	r2,-16(fp)
 8249b88:	e0bffc17 	ldw	r2,-16(fp)
 8249b8c:	10800003 	ldbu	r2,0(r2)
 8249b90:	10803fcc 	andi	r2,r2,255
 8249b94:	1080201c 	xori	r2,r2,128
 8249b98:	10bfe004 	addi	r2,r2,-128
 8249b9c:	10800be0 	cmpeqi	r2,r2,47
 8249ba0:	103ff61e 	bne	r2,zero,8249b7c <strippath+0xa8>
         if (strncmp(ntmp, path, dirlen) == 0)
 8249ba4:	e0bffd17 	ldw	r2,-12(fp)
 8249ba8:	100d883a 	mov	r6,r2
 8249bac:	e17ffb17 	ldw	r5,-20(fp)
 8249bb0:	e13ffc17 	ldw	r4,-16(fp)
 8249bb4:	824b7480 	call	824b748 <strncmp>
 8249bb8:	1000091e 	bne	r2,zero,8249be0 <strippath+0x10c>
      {
         path += dirlen;
 8249bbc:	e0bffd17 	ldw	r2,-12(fp)
 8249bc0:	e0fffb17 	ldw	r3,-20(fp)
 8249bc4:	1885883a 	add	r2,r3,r2
 8249bc8:	e0bffb15 	stw	r2,-20(fp)
         ntmp += dirlen;
 8249bcc:	e0bffd17 	ldw	r2,-12(fp)
 8249bd0:	e0fffc17 	ldw	r3,-16(fp)
 8249bd4:	1885883a 	add	r2,r3,r2
 8249bd8:	e0bffc15 	stw	r2,-16(fp)
 8249bdc:	00000206 	br	8249be8 <strippath+0x114>
      }
      else
         return NULL;   /* didn't match */
 8249be0:	0005883a 	mov	r2,zero
 8249be4:	00002906 	br	8249c8c <strippath+0x1b8>
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
   path = http_root_path; /* The servers root path, at least one UNIX slash */
   while (*path && *ntmp)
 8249be8:	e0bffb17 	ldw	r2,-20(fp)
 8249bec:	10800003 	ldbu	r2,0(r2)
 8249bf0:	10803fcc 	andi	r2,r2,255
 8249bf4:	1080201c 	xori	r2,r2,128
 8249bf8:	10bfe004 	addi	r2,r2,-128
 8249bfc:	10000826 	beq	r2,zero,8249c20 <strippath+0x14c>
 8249c00:	e0bffc17 	ldw	r2,-16(fp)
 8249c04:	10800003 	ldbu	r2,0(r2)
 8249c08:	10803fcc 	andi	r2,r2,255
 8249c0c:	1080201c 	xori	r2,r2,128
 8249c10:	10bfe004 	addi	r2,r2,-128
 8249c14:	103fbd1e 	bne	r2,zero,8249b0c <strippath+0x38>
 8249c18:	00000106 	br	8249c20 <strippath+0x14c>
   {
      while (*path == '/') path++;   /* strip leading slash */
         if (*path == 0)
         break;
 8249c1c:	0001883a 	nop
         ntmp += dirlen;
      }
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
 8249c20:	e0bffb17 	ldw	r2,-20(fp)
 8249c24:	10800003 	ldbu	r2,0(r2)
 8249c28:	10803fcc 	andi	r2,r2,255
 8249c2c:	1080201c 	xori	r2,r2,128
 8249c30:	10bfe004 	addi	r2,r2,-128
 8249c34:	1000141e 	bne	r2,zero,8249c88 <strippath+0x1b4>
   {
      while (*ntmp == '\\' || *ntmp == '/')
 8249c38:	00000306 	br	8249c48 <strippath+0x174>
         ntmp++;
 8249c3c:	e0bffc17 	ldw	r2,-16(fp)
 8249c40:	10800044 	addi	r2,r2,1
 8249c44:	e0bffc15 	stw	r2,-16(fp)
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
   {
      while (*ntmp == '\\' || *ntmp == '/')
 8249c48:	e0bffc17 	ldw	r2,-16(fp)
 8249c4c:	10800003 	ldbu	r2,0(r2)
 8249c50:	10803fcc 	andi	r2,r2,255
 8249c54:	1080201c 	xori	r2,r2,128
 8249c58:	10bfe004 	addi	r2,r2,-128
 8249c5c:	10801720 	cmpeqi	r2,r2,92
 8249c60:	103ff61e 	bne	r2,zero,8249c3c <strippath+0x168>
 8249c64:	e0bffc17 	ldw	r2,-16(fp)
 8249c68:	10800003 	ldbu	r2,0(r2)
 8249c6c:	10803fcc 	andi	r2,r2,255
 8249c70:	1080201c 	xori	r2,r2,128
 8249c74:	10bfe004 	addi	r2,r2,-128
 8249c78:	10800be0 	cmpeqi	r2,r2,47
 8249c7c:	103fef1e 	bne	r2,zero,8249c3c <strippath+0x168>
         ntmp++;
      return ntmp;
 8249c80:	e0bffc17 	ldw	r2,-16(fp)
 8249c84:	00000106 	br	8249c8c <strippath+0x1b8>
   }
   else
      return NULL;
 8249c88:	0005883a 	mov	r2,zero
}
 8249c8c:	e037883a 	mov	sp,fp
 8249c90:	dfc00117 	ldw	ra,4(sp)
 8249c94:	df000017 	ldw	fp,0(sp)
 8249c98:	dec00204 	addi	sp,sp,8
 8249c9c:	f800283a 	ret

08249ca0 <isvfile_locked>:
 * RETURNS: 
 */

int
isvfile_locked(VFILE * vfp)
{
 8249ca0:	defffd04 	addi	sp,sp,-12
 8249ca4:	df000215 	stw	fp,8(sp)
 8249ca8:	df000204 	addi	fp,sp,8
 8249cac:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8249cb0:	d0a0d517 	ldw	r2,-31916(gp)
 8249cb4:	e0bffe15 	stw	r2,-8(fp)
 8249cb8:	00000806 	br	8249cdc <isvfile_locked+0x3c>
      if (vtmp == vfp)
 8249cbc:	e0fffe17 	ldw	r3,-8(fp)
 8249cc0:	e0bfff17 	ldw	r2,-4(fp)
 8249cc4:	1880021e 	bne	r3,r2,8249cd0 <isvfile_locked+0x30>
      return TRUE;
 8249cc8:	00800044 	movi	r2,1
 8249ccc:	00000606 	br	8249ce8 <isvfile_locked+0x48>
int
isvfile_locked(VFILE * vfp)
{
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 8249cd0:	e0bffe17 	ldw	r2,-8(fp)
 8249cd4:	10800017 	ldw	r2,0(r2)
 8249cd8:	e0bffe15 	stw	r2,-8(fp)
 8249cdc:	e0bffe17 	ldw	r2,-8(fp)
 8249ce0:	103ff61e 	bne	r2,zero,8249cbc <isvfile_locked+0x1c>
      if (vtmp == vfp)
      return TRUE;

   return FALSE;  /* passed pointer not found in list */
 8249ce4:	0005883a 	mov	r2,zero
}
 8249ce8:	e037883a 	mov	sp,fp
 8249cec:	df000017 	ldw	fp,0(sp)
 8249cf0:	dec00104 	addi	sp,sp,4
 8249cf4:	f800283a 	ret

08249cf8 <isvfile>:
 * RETURNS: 
 */

int
isvfile(VFILE * vfp)
{
 8249cf8:	defffc04 	addi	sp,sp,-16
 8249cfc:	dfc00315 	stw	ra,12(sp)
 8249d00:	df000215 	stw	fp,8(sp)
 8249d04:	df000204 	addi	fp,sp,8
 8249d08:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 8249d0c:	01000144 	movi	r4,5
 8249d10:	822da280 	call	822da28 <wait_app_sem>

   /* do the lookup */
   rc = isvfile_locked(vfp);
 8249d14:	e13fff17 	ldw	r4,-4(fp)
 8249d18:	8249ca00 	call	8249ca0 <isvfile_locked>
 8249d1c:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 8249d20:	01000144 	movi	r4,5
 8249d24:	822dae40 	call	822dae4 <post_app_sem>
   return rc;
 8249d28:	e0bffe17 	ldw	r2,-8(fp)
}
 8249d2c:	e037883a 	mov	sp,fp
 8249d30:	dfc00117 	ldw	ra,4(sp)
 8249d34:	df000017 	ldw	fp,0(sp)
 8249d38:	dec00204 	addi	sp,sp,8
 8249d3c:	f800283a 	ret

08249d40 <vferror>:
 * RETURNS: 
 */

int
vferror(VFILE * vfd)
{
 8249d40:	defffd04 	addi	sp,sp,-12
 8249d44:	dfc00215 	stw	ra,8(sp)
 8249d48:	df000115 	stw	fp,4(sp)
 8249d4c:	df000104 	addi	fp,sp,4
 8249d50:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 8249d54:	01000144 	movi	r4,5
 8249d58:	822da280 	call	822da28 <wait_app_sem>

   if (isvfile_locked(vfd))
 8249d5c:	e13fff17 	ldw	r4,-4(fp)
 8249d60:	8249ca00 	call	8249ca0 <isvfile_locked>
 8249d64:	10000526 	beq	r2,zero,8249d7c <vferror+0x3c>
   {
      vfs_unlock();
 8249d68:	01000144 	movi	r4,5
 8249d6c:	822dae40 	call	822dae4 <post_app_sem>

      return vfd->error;
 8249d70:	e0bfff17 	ldw	r2,-4(fp)
 8249d74:	10800417 	ldw	r2,16(r2)
 8249d78:	00000306 	br	8249d88 <vferror+0x48>
   }

   vfs_unlock();
 8249d7c:	01000144 	movi	r4,5
 8249d80:	822dae40 	call	822dae4 <post_app_sem>

#ifdef HT_LOCALFS
   return(ferror((FILE*)vfd));
#else /* not a VFILE, and no local FS */
   return -1;  /* should this be an error? */
 8249d84:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 8249d88:	e037883a 	mov	sp,fp
 8249d8c:	dfc00117 	ldw	ra,4(sp)
 8249d90:	df000017 	ldw	fp,0(sp)
 8249d94:	dec00204 	addi	sp,sp,8
 8249d98:	f800283a 	ret

08249d9c <vclearerr>:
 *
 * RETURNS: 
 */

void vclearerr(VFILE * vfd)
{
 8249d9c:	defffd04 	addi	sp,sp,-12
 8249da0:	dfc00215 	stw	ra,8(sp)
 8249da4:	df000115 	stw	fp,4(sp)
 8249da8:	df000104 	addi	fp,sp,4
 8249dac:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 8249db0:	01000144 	movi	r4,5
 8249db4:	822da280 	call	822da28 <wait_app_sem>

   if (isvfile_locked(vfd))
 8249db8:	e13fff17 	ldw	r4,-4(fp)
 8249dbc:	8249ca00 	call	8249ca0 <isvfile_locked>
 8249dc0:	10000526 	beq	r2,zero,8249dd8 <vclearerr+0x3c>
   {
      vfs_unlock();
 8249dc4:	01000144 	movi	r4,5
 8249dc8:	822dae40 	call	822dae4 <post_app_sem>

      vfd->error = 0;
 8249dcc:	e0bfff17 	ldw	r2,-4(fp)
 8249dd0:	10000415 	stw	zero,16(r2)
      return;
 8249dd4:	00000206 	br	8249de0 <vclearerr+0x44>
   }

   vfs_unlock();
 8249dd8:	01000144 	movi	r4,5
 8249ddc:	822dae40 	call	822dae4 <post_app_sem>

#ifdef HT_LOCALFS
   clearerr((FILE *) vfd);
#endif   /* HT_LOCALFS */
}
 8249de0:	e037883a 	mov	sp,fp
 8249de4:	dfc00117 	ldw	ra,4(sp)
 8249de8:	df000017 	ldw	fp,0(sp)
 8249dec:	dec00204 	addi	sp,sp,8
 8249df0:	f800283a 	ret

08249df4 <prep_vfs>:
 * PARAMS: NONE
 *
 * RETURNS: Error Code or 0 for OK
 */
int prep_vfs(void)
{
 8249df4:	defffe04 	addi	sp,sp,-8
 8249df8:	df000115 	stw	fp,4(sp)
 8249dfc:	df000104 	addi	fp,sp,4
int e = 0;
 8249e00:	e03fff15 	stw	zero,-4(fp)
   {
      dprintf("unable to install VFS NVPARMS, reconfigure nv_formats[]\n");
      dtrap();
   }
#endif   /* INCLUDE_NVPARMS */
   return e;
 8249e04:	e0bfff17 	ldw	r2,-4(fp)
}
 8249e08:	e037883a 	mov	sp,fp
 8249e0c:	df000017 	ldw	fp,0(sp)
 8249e10:	dec00104 	addi	sp,sp,4
 8249e14:	f800283a 	ret

08249e18 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 8249e18:	defffa04 	addi	sp,sp,-24
 8249e1c:	dfc00515 	stw	ra,20(sp)
 8249e20:	df000415 	stw	fp,16(sp)
 8249e24:	df000404 	addi	fp,sp,16
 8249e28:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 8249e2c:	008000c4 	movi	r2,3
 8249e30:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
 8249e34:	e0fffd17 	ldw	r3,-12(fp)
 8249e38:	008003f4 	movhi	r2,15
 8249e3c:	10909004 	addi	r2,r2,16960
 8249e40:	1885383a 	mul	r2,r3,r2
 8249e44:	100b883a 	mov	r5,r2
 8249e48:	0100bef4 	movhi	r4,763
 8249e4c:	213c2004 	addi	r4,r4,-3968
 8249e50:	8202b8c0 	call	8202b8c <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 8249e54:	100b883a 	mov	r5,r2
 8249e58:	01200034 	movhi	r4,32768
 8249e5c:	213fffc4 	addi	r4,r4,-1
 8249e60:	8202b8c0 	call	8202b8c <__udivsi3>
 8249e64:	100b883a 	mov	r5,r2
 8249e68:	e13fff17 	ldw	r4,-4(fp)
 8249e6c:	8202b8c0 	call	8202b8c <__udivsi3>
 8249e70:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 8249e74:	e0bffe17 	ldw	r2,-8(fp)
 8249e78:	10002a26 	beq	r2,zero,8249f24 <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
 8249e7c:	e03ffc15 	stw	zero,-16(fp)
 8249e80:	00001706 	br	8249ee0 <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 8249e84:	00a00034 	movhi	r2,32768
 8249e88:	10bfffc4 	addi	r2,r2,-1
 8249e8c:	10bfffc4 	addi	r2,r2,-1
 8249e90:	103ffe1e 	bne	r2,zero,8249e8c <alt_busy_sleep+0x74>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
 8249e94:	e0fffd17 	ldw	r3,-12(fp)
 8249e98:	008003f4 	movhi	r2,15
 8249e9c:	10909004 	addi	r2,r2,16960
 8249ea0:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 8249ea4:	100b883a 	mov	r5,r2
 8249ea8:	0100bef4 	movhi	r4,763
 8249eac:	213c2004 	addi	r4,r4,-3968
 8249eb0:	8202b8c0 	call	8202b8c <__udivsi3>
 8249eb4:	100b883a 	mov	r5,r2
 8249eb8:	01200034 	movhi	r4,32768
 8249ebc:	213fffc4 	addi	r4,r4,-1
 8249ec0:	8202b8c0 	call	8202b8c <__udivsi3>
 8249ec4:	1007883a 	mov	r3,r2
 8249ec8:	e0bfff17 	ldw	r2,-4(fp)
 8249ecc:	10c5c83a 	sub	r2,r2,r3
 8249ed0:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 8249ed4:	e0bffc17 	ldw	r2,-16(fp)
 8249ed8:	10800044 	addi	r2,r2,1
 8249edc:	e0bffc15 	stw	r2,-16(fp)
 8249ee0:	e0fffc17 	ldw	r3,-16(fp)
 8249ee4:	e0bffe17 	ldw	r2,-8(fp)
 8249ee8:	18bfe616 	blt	r3,r2,8249e84 <alt_busy_sleep+0x6c>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 8249eec:	e0fffd17 	ldw	r3,-12(fp)
 8249ef0:	008003f4 	movhi	r2,15
 8249ef4:	10909004 	addi	r2,r2,16960
 8249ef8:	1885383a 	mul	r2,r3,r2
 8249efc:	100b883a 	mov	r5,r2
 8249f00:	0100bef4 	movhi	r4,763
 8249f04:	213c2004 	addi	r4,r4,-3968
 8249f08:	8202b8c0 	call	8202b8c <__udivsi3>
 8249f0c:	1007883a 	mov	r3,r2
 8249f10:	e0bfff17 	ldw	r2,-4(fp)
 8249f14:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 8249f18:	10bfffc4 	addi	r2,r2,-1
 8249f1c:	103ffe1e 	bne	r2,zero,8249f18 <alt_busy_sleep+0x100>
 8249f20:	00000d06 	br	8249f58 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 8249f24:	e0fffd17 	ldw	r3,-12(fp)
 8249f28:	008003f4 	movhi	r2,15
 8249f2c:	10909004 	addi	r2,r2,16960
 8249f30:	1885383a 	mul	r2,r3,r2
 8249f34:	100b883a 	mov	r5,r2
 8249f38:	0100bef4 	movhi	r4,763
 8249f3c:	213c2004 	addi	r4,r4,-3968
 8249f40:	8202b8c0 	call	8202b8c <__udivsi3>
 8249f44:	1007883a 	mov	r3,r2
 8249f48:	e0bfff17 	ldw	r2,-4(fp)
 8249f4c:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 8249f50:	10bfffc4 	addi	r2,r2,-1
 8249f54:	00bffe16 	blt	zero,r2,8249f50 <alt_busy_sleep+0x138>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 8249f58:	0005883a 	mov	r2,zero
}
 8249f5c:	e037883a 	mov	sp,fp
 8249f60:	dfc00117 	ldw	ra,4(sp)
 8249f64:	df000017 	ldw	fp,0(sp)
 8249f68:	dec00204 	addi	sp,sp,8
 8249f6c:	f800283a 	ret

08249f70 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 8249f70:	defffe04 	addi	sp,sp,-8
 8249f74:	dfc00115 	stw	ra,4(sp)
 8249f78:	df000015 	stw	fp,0(sp)
 8249f7c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8249f80:	d0a04717 	ldw	r2,-32484(gp)
 8249f84:	10000326 	beq	r2,zero,8249f94 <alt_get_errno+0x24>
 8249f88:	d0a04717 	ldw	r2,-32484(gp)
 8249f8c:	103ee83a 	callr	r2
 8249f90:	00000106 	br	8249f98 <alt_get_errno+0x28>
 8249f94:	d0a06304 	addi	r2,gp,-32372
}
 8249f98:	e037883a 	mov	sp,fp
 8249f9c:	dfc00117 	ldw	ra,4(sp)
 8249fa0:	df000017 	ldw	fp,0(sp)
 8249fa4:	dec00204 	addi	sp,sp,8
 8249fa8:	f800283a 	ret

08249fac <alt_fcntl>:
 *
 * ALT_FCNTL is mapped onto the fcntl() system call in alt_syscall.h
 */
 
int ALT_FCNTL (int file, int cmd, ...)
{ 
 8249fac:	defff704 	addi	sp,sp,-36
 8249fb0:	dfc00615 	stw	ra,24(sp)
 8249fb4:	df000515 	stw	fp,20(sp)
 8249fb8:	df000504 	addi	fp,sp,20
 8249fbc:	e13ffe15 	stw	r4,-8(fp)
 8249fc0:	e17fff15 	stw	r5,-4(fp)
 8249fc4:	e1800215 	stw	r6,8(fp)
 8249fc8:	e1c00315 	stw	r7,12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 8249fcc:	e0bffe17 	ldw	r2,-8(fp)
 8249fd0:	10000616 	blt	r2,zero,8249fec <alt_fcntl+0x40>
 8249fd4:	e0bffe17 	ldw	r2,-8(fp)
 8249fd8:	10c00324 	muli	r3,r2,12
 8249fdc:	00820974 	movhi	r2,2085
 8249fe0:	108edc04 	addi	r2,r2,15216
 8249fe4:	1885883a 	add	r2,r3,r2
 8249fe8:	00000106 	br	8249ff0 <alt_fcntl+0x44>
 8249fec:	0005883a 	mov	r2,zero
 8249ff0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 8249ff4:	e0bffb17 	ldw	r2,-20(fp)
 8249ff8:	10002a26 	beq	r2,zero,824a0a4 <alt_fcntl+0xf8>
  {
    switch (cmd)
 8249ffc:	e0bfff17 	ldw	r2,-4(fp)
 824a000:	10c000e0 	cmpeqi	r3,r2,3
 824a004:	1800031e 	bne	r3,zero,824a014 <alt_fcntl+0x68>
 824a008:	10800120 	cmpeqi	r2,r2,4
 824a00c:	1000071e 	bne	r2,zero,824a02c <alt_fcntl+0x80>
 824a010:	00001e06 	br	824a08c <alt_fcntl+0xe0>
    {
    case F_GETFL:
      return fd->fd_flags & ~((alt_u32) ALT_FD_FLAGS_MASK);
 824a014:	e0bffb17 	ldw	r2,-20(fp)
 824a018:	10c00217 	ldw	r3,8(r2)
 824a01c:	00900034 	movhi	r2,16384
 824a020:	10bfffc4 	addi	r2,r2,-1
 824a024:	1884703a 	and	r2,r3,r2
 824a028:	00002306 	br	824a0b8 <alt_fcntl+0x10c>
    case F_SETFL:
      va_start(argp, cmd);
 824a02c:	e0800204 	addi	r2,fp,8
 824a030:	e0bffd15 	stw	r2,-12(fp)
      flags = va_arg(argp, long);
 824a034:	e0bffd17 	ldw	r2,-12(fp)
 824a038:	10c00104 	addi	r3,r2,4
 824a03c:	e0fffd15 	stw	r3,-12(fp)
 824a040:	10800017 	ldw	r2,0(r2)
 824a044:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags &= ~ALT_FCNTL_FLAGS_MASK;
 824a048:	e0bffb17 	ldw	r2,-20(fp)
 824a04c:	10c00217 	ldw	r3,8(r2)
 824a050:	00affdc4 	movi	r2,-16393
 824a054:	1886703a 	and	r3,r3,r2
 824a058:	e0bffb17 	ldw	r2,-20(fp)
 824a05c:	10c00215 	stw	r3,8(r2)
      fd->fd_flags |= (flags & ALT_FCNTL_FLAGS_MASK);
 824a060:	e0bffb17 	ldw	r2,-20(fp)
 824a064:	10800217 	ldw	r2,8(r2)
 824a068:	1007883a 	mov	r3,r2
 824a06c:	e0bffc17 	ldw	r2,-16(fp)
 824a070:	1090020c 	andi	r2,r2,16392
 824a074:	1884b03a 	or	r2,r3,r2
 824a078:	1007883a 	mov	r3,r2
 824a07c:	e0bffb17 	ldw	r2,-20(fp)
 824a080:	10c00215 	stw	r3,8(r2)
      va_end(argp);
      return 0;
 824a084:	0005883a 	mov	r2,zero
 824a088:	00000b06 	br	824a0b8 <alt_fcntl+0x10c>
    default:
      ALT_ERRNO = EINVAL;
 824a08c:	8249f700 	call	8249f70 <alt_get_errno>
 824a090:	1007883a 	mov	r3,r2
 824a094:	00800584 	movi	r2,22
 824a098:	18800015 	stw	r2,0(r3)
      return -1;
 824a09c:	00bfffc4 	movi	r2,-1
 824a0a0:	00000506 	br	824a0b8 <alt_fcntl+0x10c>
    }
  }

  ALT_ERRNO = EBADFD;
 824a0a4:	8249f700 	call	8249f70 <alt_get_errno>
 824a0a8:	1007883a 	mov	r3,r2
 824a0ac:	00801444 	movi	r2,81
 824a0b0:	18800015 	stw	r2,0(r3)
  return -1;
 824a0b4:	00bfffc4 	movi	r2,-1
}
 824a0b8:	e037883a 	mov	sp,fp
 824a0bc:	dfc00117 	ldw	ra,4(sp)
 824a0c0:	df000017 	ldw	fp,0(sp)
 824a0c4:	dec00404 	addi	sp,sp,16
 824a0c8:	f800283a 	ret

0824a0cc <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 824a0cc:	defffb04 	addi	sp,sp,-20
 824a0d0:	dfc00415 	stw	ra,16(sp)
 824a0d4:	df000315 	stw	fp,12(sp)
 824a0d8:	df000304 	addi	fp,sp,12
 824a0dc:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 824a0e0:	d0a04217 	ldw	r2,-32504(gp)
 824a0e4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 824a0e8:	00003106 	br	824a1b0 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 824a0ec:	e0bffd17 	ldw	r2,-12(fp)
 824a0f0:	10800217 	ldw	r2,8(r2)
 824a0f4:	1009883a 	mov	r4,r2
 824a0f8:	8203edc0 	call	8203edc <strlen>
 824a0fc:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 824a100:	e0bffd17 	ldw	r2,-12(fp)
 824a104:	10c00217 	ldw	r3,8(r2)
 824a108:	e0bffe17 	ldw	r2,-8(fp)
 824a10c:	10bfffc4 	addi	r2,r2,-1
 824a110:	1885883a 	add	r2,r3,r2
 824a114:	10800003 	ldbu	r2,0(r2)
 824a118:	10803fcc 	andi	r2,r2,255
 824a11c:	1080201c 	xori	r2,r2,128
 824a120:	10bfe004 	addi	r2,r2,-128
 824a124:	10800bd8 	cmpnei	r2,r2,47
 824a128:	1000031e 	bne	r2,zero,824a138 <alt_find_file+0x6c>
    {
      len -= 1;
 824a12c:	e0bffe17 	ldw	r2,-8(fp)
 824a130:	10bfffc4 	addi	r2,r2,-1
 824a134:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 824a138:	e0bffe17 	ldw	r2,-8(fp)
 824a13c:	e0ffff17 	ldw	r3,-4(fp)
 824a140:	1885883a 	add	r2,r3,r2
 824a144:	10800003 	ldbu	r2,0(r2)
 824a148:	10803fcc 	andi	r2,r2,255
 824a14c:	1080201c 	xori	r2,r2,128
 824a150:	10bfe004 	addi	r2,r2,-128
 824a154:	10800be0 	cmpeqi	r2,r2,47
 824a158:	1000081e 	bne	r2,zero,824a17c <alt_find_file+0xb0>
 824a15c:	e0bffe17 	ldw	r2,-8(fp)
 824a160:	e0ffff17 	ldw	r3,-4(fp)
 824a164:	1885883a 	add	r2,r3,r2
 824a168:	10800003 	ldbu	r2,0(r2)
 824a16c:	10803fcc 	andi	r2,r2,255
 824a170:	1080201c 	xori	r2,r2,128
 824a174:	10bfe004 	addi	r2,r2,-128
 824a178:	10000a1e 	bne	r2,zero,824a1a4 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 824a17c:	e0bffd17 	ldw	r2,-12(fp)
 824a180:	10800217 	ldw	r2,8(r2)
 824a184:	e0fffe17 	ldw	r3,-8(fp)
 824a188:	180d883a 	mov	r6,r3
 824a18c:	e17fff17 	ldw	r5,-4(fp)
 824a190:	1009883a 	mov	r4,r2
 824a194:	820c5580 	call	820c558 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 824a198:	1000021e 	bne	r2,zero,824a1a4 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 824a19c:	e0bffd17 	ldw	r2,-12(fp)
 824a1a0:	00000706 	br	824a1c0 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 824a1a4:	e0bffd17 	ldw	r2,-12(fp)
 824a1a8:	10800017 	ldw	r2,0(r2)
 824a1ac:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 824a1b0:	e0fffd17 	ldw	r3,-12(fp)
 824a1b4:	d0a04204 	addi	r2,gp,-32504
 824a1b8:	18bfcc1e 	bne	r3,r2,824a0ec <alt_find_file+0x20>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 824a1bc:	0005883a 	mov	r2,zero
}
 824a1c0:	e037883a 	mov	sp,fp
 824a1c4:	dfc00117 	ldw	ra,4(sp)
 824a1c8:	df000017 	ldw	fp,0(sp)
 824a1cc:	dec00204 	addi	sp,sp,8
 824a1d0:	f800283a 	ret

0824a1d4 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 824a1d4:	defff904 	addi	sp,sp,-28
 824a1d8:	dfc00615 	stw	ra,24(sp)
 824a1dc:	df000515 	stw	fp,20(sp)
 824a1e0:	df000504 	addi	fp,sp,20
 824a1e4:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 824a1e8:	00bffa04 	movi	r2,-24
 824a1ec:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 824a1f0:	d0a0b617 	ldw	r2,-32040(gp)
 824a1f4:	e0bffd15 	stw	r2,-12(fp)
 824a1f8:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 824a1fc:	e0bffe0b 	ldhu	r2,-8(fp)
 824a200:	e0fffe84 	addi	r3,fp,-6
 824a204:	180d883a 	mov	r6,r3
 824a208:	100b883a 	mov	r5,r2
 824a20c:	e13ffd17 	ldw	r4,-12(fp)
 824a210:	821a0380 	call	821a038 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 824a214:	e03ffb15 	stw	zero,-20(fp)
 824a218:	00001906 	br	824a280 <alt_get_fd+0xac>
  {
    if (!alt_fd_list[i].dev)
 824a21c:	00820974 	movhi	r2,2085
 824a220:	108edc04 	addi	r2,r2,15216
 824a224:	e0fffb17 	ldw	r3,-20(fp)
 824a228:	18c00324 	muli	r3,r3,12
 824a22c:	10c5883a 	add	r2,r2,r3
 824a230:	10800017 	ldw	r2,0(r2)
 824a234:	10000f1e 	bne	r2,zero,824a274 <alt_get_fd+0xa0>
    {
      alt_fd_list[i].dev = dev;
 824a238:	00820974 	movhi	r2,2085
 824a23c:	108edc04 	addi	r2,r2,15216
 824a240:	e0fffb17 	ldw	r3,-20(fp)
 824a244:	18c00324 	muli	r3,r3,12
 824a248:	10c5883a 	add	r2,r2,r3
 824a24c:	e0ffff17 	ldw	r3,-4(fp)
 824a250:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 824a254:	d0e04617 	ldw	r3,-32488(gp)
 824a258:	e0bffb17 	ldw	r2,-20(fp)
 824a25c:	1880020e 	bge	r3,r2,824a268 <alt_get_fd+0x94>
      {
        alt_max_fd = i;
 824a260:	e0bffb17 	ldw	r2,-20(fp)
 824a264:	d0a04615 	stw	r2,-32488(gp)
      }
      rc = i;
 824a268:	e0bffb17 	ldw	r2,-20(fp)
 824a26c:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
 824a270:	00000606 	br	824a28c <alt_get_fd+0xb8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 824a274:	e0bffb17 	ldw	r2,-20(fp)
 824a278:	10800044 	addi	r2,r2,1
 824a27c:	e0bffb15 	stw	r2,-20(fp)
 824a280:	e0bffb17 	ldw	r2,-20(fp)
 824a284:	10800810 	cmplti	r2,r2,32
 824a288:	103fe41e 	bne	r2,zero,824a21c <alt_get_fd+0x48>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 824a28c:	d0a0b617 	ldw	r2,-32040(gp)
 824a290:	1009883a 	mov	r4,r2
 824a294:	821a3b00 	call	821a3b0 <OSSemPost>

  return rc;
 824a298:	e0bffc17 	ldw	r2,-16(fp)
}
 824a29c:	e037883a 	mov	sp,fp
 824a2a0:	dfc00117 	ldw	ra,4(sp)
 824a2a4:	df000017 	ldw	fp,0(sp)
 824a2a8:	dec00204 	addi	sp,sp,8
 824a2ac:	f800283a 	ret

0824a2b0 <icmprcv>:
};
#endif /* USER_PING_TSTAMP */

int
icmprcv(PACKET p)      /* the incoming packet */
{
 824a2b0:	deffef04 	addi	sp,sp,-68
 824a2b4:	dfc01015 	stw	ra,64(sp)
 824a2b8:	df000f15 	stw	fp,60(sp)
 824a2bc:	dc400e15 	stw	r17,56(sp)
 824a2c0:	dc000d15 	stw	r16,52(sp)
 824a2c4:	df000f04 	addi	fp,sp,60
 824a2c8:	e13ffd15 	stw	r4,-12(fp)
   unsigned short xsum;
#ifdef FULL_ICMP
   struct redirect * rd;
   struct destun *   pdp;
#endif   /* FULL_ICMP */
   char sav_ch = 0;
 824a2cc:	e03ff305 	stb	zero,-52(fp)
   int i;

   icmp_mib.icmpInMsgs++;                 /* received one more icmp */
 824a2d0:	008209b4 	movhi	r2,2086
 824a2d4:	10ba8804 	addi	r2,r2,-5600
 824a2d8:	10800017 	ldw	r2,0(r2)
 824a2dc:	10c00044 	addi	r3,r2,1
 824a2e0:	008209b4 	movhi	r2,2086
 824a2e4:	10ba8804 	addi	r2,r2,-5600
 824a2e8:	10c00015 	stw	r3,0(r2)

   pip = ip_head(p);                      /* find IP header */
 824a2ec:	e0bffd17 	ldw	r2,-12(fp)
 824a2f0:	10800317 	ldw	r2,12(r2)
 824a2f4:	e0bff415 	stw	r2,-48(fp)
   len = p->nb_plen - (ip_hlen(pip));     /* strip IP header length */
 824a2f8:	e0bffd17 	ldw	r2,-12(fp)
 824a2fc:	10c00417 	ldw	r3,16(r2)
 824a300:	e0bff417 	ldw	r2,-48(fp)
 824a304:	10800003 	ldbu	r2,0(r2)
 824a308:	10803fcc 	andi	r2,r2,255
 824a30c:	108003cc 	andi	r2,r2,15
 824a310:	1085883a 	add	r2,r2,r2
 824a314:	1085883a 	add	r2,r2,r2
 824a318:	1885c83a 	sub	r2,r3,r2
 824a31c:	e0bff515 	stw	r2,-44(fp)
   host = p->fhost;                       /* filled in by IP layer */
 824a320:	e0bffd17 	ldw	r2,-12(fp)
 824a324:	10800717 	ldw	r2,28(r2)
 824a328:	e0bff615 	stw	r2,-40(fp)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824a32c:	d0a08317 	ldw	r2,-32244(gp)
 824a330:	1081000c 	andi	r2,r2,1024
 824a334:	10001526 	beq	r2,zero,824a38c <icmprcv+0xdc>
 824a338:	d0a08317 	ldw	r2,-32244(gp)
 824a33c:	1080800c 	andi	r2,r2,512
 824a340:	10001226 	beq	r2,zero,824a38c <icmprcv+0xdc>
      dprintf("ICMP: p[%u] from %u.%u.%u.%u\n", len, PUSH_IPADDR(host));
 824a344:	e0bff617 	ldw	r2,-40(fp)
 824a348:	11003fcc 	andi	r4,r2,255
 824a34c:	e0bff617 	ldw	r2,-40(fp)
 824a350:	1004d23a 	srli	r2,r2,8
 824a354:	11403fcc 	andi	r5,r2,255
 824a358:	e0bff617 	ldw	r2,-40(fp)
 824a35c:	1004d43a 	srli	r2,r2,16
 824a360:	10803fcc 	andi	r2,r2,255
 824a364:	e0fff617 	ldw	r3,-40(fp)
 824a368:	1806d63a 	srli	r3,r3,24
 824a36c:	d8c00115 	stw	r3,4(sp)
 824a370:	d8800015 	stw	r2,0(sp)
 824a374:	280f883a 	mov	r7,r5
 824a378:	200d883a 	mov	r6,r4
 824a37c:	e17ff517 	ldw	r5,-44(fp)
 824a380:	01020974 	movhi	r4,2085
 824a384:	2106f504 	addi	r4,r4,7124
 824a388:	820331c0 	call	820331c <printf>
#endif

   e = (struct ping *)ip_data(pip);       /* finally, extract ICMP header */
 824a38c:	e0bff417 	ldw	r2,-48(fp)
 824a390:	10800003 	ldbu	r2,0(r2)
 824a394:	10803fcc 	andi	r2,r2,255
 824a398:	108003cc 	andi	r2,r2,15
 824a39c:	1085883a 	add	r2,r2,r2
 824a3a0:	1085883a 	add	r2,r2,r2
 824a3a4:	1007883a 	mov	r3,r2
 824a3a8:	e0bff417 	ldw	r2,-48(fp)
 824a3ac:	10c5883a 	add	r2,r2,r3
 824a3b0:	e0bff715 	stw	r2,-36(fp)

   osum = e->pchksum;
 824a3b4:	e0bff717 	ldw	r2,-36(fp)
 824a3b8:	1080008b 	ldhu	r2,2(r2)
 824a3bc:	e0bff80d 	sth	r2,-32(fp)
   e->pchksum = 0;
 824a3c0:	e0bff717 	ldw	r2,-36(fp)
 824a3c4:	1000008d 	sth	zero,2(r2)

   if (len&1)
 824a3c8:	e0bff517 	ldw	r2,-44(fp)
 824a3cc:	1080004c 	andi	r2,r2,1
 824a3d0:	10000926 	beq	r2,zero,824a3f8 <icmprcv+0x148>
   {
      sav_ch = *(((char *) e) + len);
 824a3d4:	e0fff717 	ldw	r3,-36(fp)
 824a3d8:	e0bff517 	ldw	r2,-44(fp)
 824a3dc:	1885883a 	add	r2,r3,r2
 824a3e0:	10800003 	ldbu	r2,0(r2)
 824a3e4:	e0bff305 	stb	r2,-52(fp)
      ((char *)e)[len] = 0;
 824a3e8:	e0fff717 	ldw	r3,-36(fp)
 824a3ec:	e0bff517 	ldw	r2,-44(fp)
 824a3f0:	1885883a 	add	r2,r3,r2
 824a3f4:	10000005 	stb	zero,0(r2)
   }

   xsum = ~cksum(e, (len+1)>>1);
 824a3f8:	e0bff517 	ldw	r2,-44(fp)
 824a3fc:	10800044 	addi	r2,r2,1
 824a400:	1004d07a 	srli	r2,r2,1
 824a404:	100b883a 	mov	r5,r2
 824a408:	e13ff717 	ldw	r4,-36(fp)
 824a40c:	82286f00 	call	82286f0 <cksum>
 824a410:	0084303a 	nor	r2,zero,r2
 824a414:	e0bff88d 	sth	r2,-30(fp)
   if (len&1) *(((char *) e) + len) = sav_ch;
 824a418:	e0bff517 	ldw	r2,-44(fp)
 824a41c:	1080004c 	andi	r2,r2,1
 824a420:	10000526 	beq	r2,zero,824a438 <icmprcv+0x188>
 824a424:	e0fff717 	ldw	r3,-36(fp)
 824a428:	e0bff517 	ldw	r2,-44(fp)
 824a42c:	1885883a 	add	r2,r3,r2
 824a430:	e0fff303 	ldbu	r3,-52(fp)
 824a434:	10c00005 	stb	r3,0(r2)
   if (xsum != osum)
 824a438:	e0fff88b 	ldhu	r3,-30(fp)
 824a43c:	e0bff80b 	ldhu	r2,-32(fp)
 824a440:	18802426 	beq	r3,r2,824a4d4 <icmprcv+0x224>
   {
      e->pchksum = osum;
 824a444:	e0bff717 	ldw	r2,-36(fp)
 824a448:	e0fff80b 	ldhu	r3,-32(fp)
 824a44c:	10c0008d 	sth	r3,2(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824a450:	d0a08317 	ldw	r2,-32244(gp)
 824a454:	1081000c 	andi	r2,r2,1024
 824a458:	10000f26 	beq	r2,zero,824a498 <icmprcv+0x1e8>
 824a45c:	d0a08317 	ldw	r2,-32244(gp)
 824a460:	1080800c 	andi	r2,r2,512
 824a464:	10000c26 	beq	r2,zero,824a498 <icmprcv+0x1e8>
      {
         dprintf("ICMP: Bad xsum %04x should have been %04x\n",
 824a468:	e0bff80b 	ldhu	r2,-32(fp)
 824a46c:	e0fff88b 	ldhu	r3,-30(fp)
 824a470:	180d883a 	mov	r6,r3
 824a474:	100b883a 	mov	r5,r2
 824a478:	01020974 	movhi	r4,2085
 824a47c:	2106fd04 	addi	r4,r4,7156
 824a480:	820331c0 	call	820331c <printf>
          osum, xsum);
         if (NDEBUG & DUMP) ip_dump(p);
 824a484:	d0a08317 	ldw	r2,-32244(gp)
 824a488:	1080008c 	andi	r2,r2,2
 824a48c:	10000226 	beq	r2,zero,824a498 <icmprcv+0x1e8>
 824a490:	e13ffd17 	ldw	r4,-12(fp)
 824a494:	82408a40 	call	82408a4 <ip_dump>
      }
#endif
      icmp_mib.icmpInErrors++;
 824a498:	008209b4 	movhi	r2,2086
 824a49c:	10ba8804 	addi	r2,r2,-5600
 824a4a0:	10800117 	ldw	r2,4(r2)
 824a4a4:	10c00044 	addi	r3,r2,1
 824a4a8:	008209b4 	movhi	r2,2086
 824a4ac:	10ba8804 	addi	r2,r2,-5600
 824a4b0:	10c00115 	stw	r3,4(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824a4b4:	01000084 	movi	r4,2
 824a4b8:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(p);
 824a4bc:	e13ffd17 	ldw	r4,-12(fp)
 824a4c0:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824a4c4:	01000084 	movi	r4,2
 824a4c8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 824a4cc:	00bff804 	movi	r2,-32
 824a4d0:	00024906 	br	824adf8 <icmprcv+0xb48>
   }

   e->pchksum = osum;
 824a4d4:	e0bff717 	ldw	r2,-36(fp)
 824a4d8:	e0fff80b 	ldhu	r3,-32(fp)
 824a4dc:	10c0008d 	sth	r3,2(r2)

   switch (e->ptype) 
 824a4e0:	e0bff717 	ldw	r2,-36(fp)
 824a4e4:	10800003 	ldbu	r2,0(r2)
 824a4e8:	10803fcc 	andi	r2,r2,255
 824a4ec:	1080201c 	xori	r2,r2,128
 824a4f0:	10bfe004 	addi	r2,r2,-128
 824a4f4:	10c00428 	cmpgeui	r3,r2,16
 824a4f8:	1802251e 	bne	r3,zero,824ad90 <icmprcv+0xae0>
 824a4fc:	100690ba 	slli	r3,r2,2
 824a500:	00820974 	movhi	r2,2085
 824a504:	10a94504 	addi	r2,r2,-23276
 824a508:	1885883a 	add	r2,r3,r2
 824a50c:	10800017 	ldw	r2,0(r2)
 824a510:	1000683a 	jmp	r2
 824a514:	0824a7c8 	cmpgei	zero,at,-28001
 824a518:	0824ad90 	cmplti	zero,at,-27978
 824a51c:	0824ad90 	cmplti	zero,at,-27978
 824a520:	0824a7f0 	cmpltui	zero,at,37535
 824a524:	0824a8ec 	andhi	zero,at,37539
 824a528:	0824a988 	cmpgei	zero,at,-27994
 824a52c:	0824ad90 	cmplti	zero,at,-27978
 824a530:	0824ad90 	cmplti	zero,at,-27978
 824a534:	0824a554 	ori	zero,at,37525
 824a538:	0824ad90 	cmplti	zero,at,-27978
 824a53c:	0824ad90 	cmplti	zero,at,-27978
 824a540:	0824aabc 	xorhi	zero,at,37546
 824a544:	0824abc4 	addi	zero,at,-27985
 824a548:	0824ac28 	cmpgeui	zero,at,37552
 824a54c:	0824ad90 	cmplti	zero,at,-27978
 824a550:	0824ad5c 	xori	zero,at,37557
   {
   case ECHOREQ:  /* got ping request, send reply */
      icmp_mib.icmpInEchos++;
 824a554:	008209b4 	movhi	r2,2086
 824a558:	10ba8804 	addi	r2,r2,-5600
 824a55c:	10800717 	ldw	r2,28(r2)
 824a560:	10c00044 	addi	r3,r2,1
 824a564:	008209b4 	movhi	r2,2086
 824a568:	10ba8804 	addi	r2,r2,-5600
 824a56c:	10c00715 	stw	r3,28(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 824a570:	d0a08317 	ldw	r2,-32244(gp)
 824a574:	1081000c 	andi	r2,r2,1024
 824a578:	10001426 	beq	r2,zero,824a5cc <icmprcv+0x31c>
 824a57c:	d0a08317 	ldw	r2,-32244(gp)
 824a580:	1080800c 	andi	r2,r2,512
 824a584:	10001126 	beq	r2,zero,824a5cc <icmprcv+0x31c>
         dprintf("ICMP: echo reply to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824a588:	e0bff617 	ldw	r2,-40(fp)
 824a58c:	10c03fcc 	andi	r3,r2,255
 824a590:	e0bff617 	ldw	r2,-40(fp)
 824a594:	1004d23a 	srli	r2,r2,8
 824a598:	11003fcc 	andi	r4,r2,255
 824a59c:	e0bff617 	ldw	r2,-40(fp)
 824a5a0:	1004d43a 	srli	r2,r2,16
 824a5a4:	11403fcc 	andi	r5,r2,255
 824a5a8:	e0bff617 	ldw	r2,-40(fp)
 824a5ac:	1004d63a 	srli	r2,r2,24
 824a5b0:	d8800015 	stw	r2,0(sp)
 824a5b4:	280f883a 	mov	r7,r5
 824a5b8:	200d883a 	mov	r6,r4
 824a5bc:	180b883a 	mov	r5,r3
 824a5c0:	01020974 	movhi	r4,2085
 824a5c4:	21070804 	addi	r4,r4,7200
 824a5c8:	820331c0 	call	820331c <printf>
#endif
      e->ptype = ECHOREP;
 824a5cc:	e0bff717 	ldw	r2,-36(fp)
 824a5d0:	10000005 	stb	zero,0(r2)
      e->pchksum = 0;
 824a5d4:	e0bff717 	ldw	r2,-36(fp)
 824a5d8:	1000008d 	sth	zero,2(r2)
      if (len&1)  /* pad odd length packets for checksum routine */
 824a5dc:	e0bff517 	ldw	r2,-44(fp)
 824a5e0:	1080004c 	andi	r2,r2,1
 824a5e4:	10000926 	beq	r2,zero,824a60c <icmprcv+0x35c>
      {
         sav_ch = *(((char *) e) + len);
 824a5e8:	e0fff717 	ldw	r3,-36(fp)
 824a5ec:	e0bff517 	ldw	r2,-44(fp)
 824a5f0:	1885883a 	add	r2,r3,r2
 824a5f4:	10800003 	ldbu	r2,0(r2)
 824a5f8:	e0bff305 	stb	r2,-52(fp)
         ((char *)e)[len] = 0;
 824a5fc:	e0fff717 	ldw	r3,-36(fp)
 824a600:	e0bff517 	ldw	r2,-44(fp)
 824a604:	1885883a 	add	r2,r3,r2
 824a608:	10000005 	stb	zero,0(r2)
      }

      e->pchksum = ~cksum(e, (len+1)>>1);
 824a60c:	e0bff517 	ldw	r2,-44(fp)
 824a610:	10800044 	addi	r2,r2,1
 824a614:	1004d07a 	srli	r2,r2,1
 824a618:	100b883a 	mov	r5,r2
 824a61c:	e13ff717 	ldw	r4,-36(fp)
 824a620:	82286f00 	call	82286f0 <cksum>
 824a624:	0084303a 	nor	r2,zero,r2
 824a628:	1007883a 	mov	r3,r2
 824a62c:	e0bff717 	ldw	r2,-36(fp)
 824a630:	10c0008d 	sth	r3,2(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
 824a634:	e0bff517 	ldw	r2,-44(fp)
 824a638:	1080004c 	andi	r2,r2,1
 824a63c:	10000526 	beq	r2,zero,824a654 <icmprcv+0x3a4>
 824a640:	e0fff717 	ldw	r3,-36(fp)
 824a644:	e0bff517 	ldw	r2,-44(fp)
 824a648:	1885883a 	add	r2,r3,r2
 824a64c:	e0fff303 	ldbu	r3,-52(fp)
 824a650:	10c00005 	stb	r3,0(r2)
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 824a654:	e0bff417 	ldw	r2,-48(fp)
 824a658:	10800417 	ldw	r2,16(r2)
 824a65c:	10bfffe0 	cmpeqi	r2,r2,-1
 824a660:	10001f1e 	bne	r2,zero,824a6e0 <icmprcv+0x430>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
 824a664:	e0bff417 	ldw	r2,-48(fp)
 824a668:	10800417 	ldw	r2,16(r2)
 824a66c:	1006d63a 	srli	r3,r2,24
 824a670:	e0bff417 	ldw	r2,-48(fp)
 824a674:	10800417 	ldw	r2,16(r2)
 824a678:	1004d23a 	srli	r2,r2,8
 824a67c:	10bfc00c 	andi	r2,r2,65280
 824a680:	1886b03a 	or	r3,r3,r2
 824a684:	e0bff417 	ldw	r2,-48(fp)
 824a688:	10800417 	ldw	r2,16(r2)
 824a68c:	10bfc00c 	andi	r2,r2,65280
 824a690:	1004923a 	slli	r2,r2,8
 824a694:	1886b03a 	or	r3,r3,r2
 824a698:	e0bff417 	ldw	r2,-48(fp)
 824a69c:	10800417 	ldw	r2,16(r2)
 824a6a0:	1004963a 	slli	r2,r2,24
 824a6a4:	1884b03a 	or	r2,r3,r2
 824a6a8:	10fc002c 	andhi	r3,r2,61440
      if (len&1) *(((char *) e) + len) = sav_ch;
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 824a6ac:	00b80034 	movhi	r2,57344
 824a6b0:	18800b26 	beq	r3,r2,824a6e0 <icmprcv+0x430>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
 824a6b4:	e0bff417 	ldw	r2,-48(fp)
 824a6b8:	10c00417 	ldw	r3,16(r2)
 824a6bc:	e0bffd17 	ldw	r2,-12(fp)
 824a6c0:	10800617 	ldw	r2,24(r2)
 824a6c4:	11000a17 	ldw	r4,40(r2)
 824a6c8:	e0bffd17 	ldw	r2,-12(fp)
 824a6cc:	10800617 	ldw	r2,24(r2)
 824a6d0:	10800c17 	ldw	r2,48(r2)
 824a6d4:	0084303a 	nor	r2,zero,r2
 824a6d8:	2084b03a 	or	r2,r4,r2
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
 824a6dc:	1880061e 	bne	r3,r2,824a6f8 <icmprcv+0x448>
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
 824a6e0:	e0bffd17 	ldw	r2,-12(fp)
 824a6e4:	10800617 	ldw	r2,24(r2)
 824a6e8:	10c00a17 	ldw	r3,40(r2)
 824a6ec:	e0bff417 	ldw	r2,-48(fp)
 824a6f0:	10c00315 	stw	r3,12(r2)
 824a6f4:	00000406 	br	824a708 <icmprcv+0x458>
      }
      else pip->ip_src = pip->ip_dest;
 824a6f8:	e0bff417 	ldw	r2,-48(fp)
 824a6fc:	10c00417 	ldw	r3,16(r2)
 824a700:	e0bff417 	ldw	r2,-48(fp)
 824a704:	10c00315 	stw	r3,12(r2)

      pip->ip_dest = host;
 824a708:	e0bff417 	ldw	r2,-48(fp)
 824a70c:	e0fff617 	ldw	r3,-40(fp)
 824a710:	10c00415 	stw	r3,16(r2)
      icmp_mib.icmpOutEchoReps++;
 824a714:	008209b4 	movhi	r2,2086
 824a718:	10ba8804 	addi	r2,r2,-5600
 824a71c:	10801517 	ldw	r2,84(r2)
 824a720:	10c00044 	addi	r3,r2,1
 824a724:	008209b4 	movhi	r2,2086
 824a728:	10ba8804 	addi	r2,r2,-5600
 824a72c:	10c01515 	stw	r3,84(r2)
      icmp_mib.icmpOutMsgs++;
 824a730:	008209b4 	movhi	r2,2086
 824a734:	10ba8804 	addi	r2,r2,-5600
 824a738:	10800d17 	ldw	r2,52(r2)
 824a73c:	10c00044 	addi	r3,r2,1
 824a740:	008209b4 	movhi	r2,2086
 824a744:	10ba8804 	addi	r2,r2,-5600
 824a748:	10c00d15 	stw	r3,52(r2)
      p->fhost = host;
 824a74c:	e0bffd17 	ldw	r2,-12(fp)
 824a750:	e0fff617 	ldw	r3,-40(fp)
 824a754:	10c00715 	stw	r3,28(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 824a758:	e0bffd17 	ldw	r2,-12(fp)
 824a75c:	10c00317 	ldw	r3,12(r2)
 824a760:	e0bff417 	ldw	r2,-48(fp)
 824a764:	10800003 	ldbu	r2,0(r2)
 824a768:	10803fcc 	andi	r2,r2,255
 824a76c:	108003cc 	andi	r2,r2,15
 824a770:	1085883a 	add	r2,r2,r2
 824a774:	1085883a 	add	r2,r2,r2
 824a778:	1887883a 	add	r3,r3,r2
 824a77c:	e0bffd17 	ldw	r2,-12(fp)
 824a780:	10c00315 	stw	r3,12(r2)
      p->nb_plen = len;
 824a784:	e0bffd17 	ldw	r2,-12(fp)
 824a788:	e0fff517 	ldw	r3,-44(fp)
 824a78c:	10c00415 	stw	r3,16(r2)

      i = ip_write(ICMP_PROT, p);
 824a790:	e17ffd17 	ldw	r5,-12(fp)
 824a794:	01000044 	movi	r4,1
 824a798:	823f7b00 	call	823f7b0 <ip_write>
 824a79c:	e0bff915 	stw	r2,-28(fp)
      if (i < 0)
 824a7a0:	e0bff917 	ldw	r2,-28(fp)
 824a7a4:	1000060e 	bge	r2,zero,824a7c0 <icmprcv+0x510>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (UPCTRACE))
 824a7a8:	d0a08317 	ldw	r2,-32244(gp)
 824a7ac:	1081000c 	andi	r2,r2,1024
 824a7b0:	10000326 	beq	r2,zero,824a7c0 <icmprcv+0x510>
            dprintf("icmp: reply failed\n");
 824a7b4:	01020974 	movhi	r4,2085
 824a7b8:	21071104 	addi	r4,r4,7236
 824a7bc:	82035a00 	call	82035a0 <puts>
#endif
      }
      /* reused p will be freed by net->xxx_send() */
      return 0;
 824a7c0:	0005883a 	mov	r2,zero
 824a7c4:	00018c06 	br	824adf8 <icmprcv+0xb48>
   case ECHOREP:
      icmp_mib.icmpInEchoReps++;
 824a7c8:	008209b4 	movhi	r2,2086
 824a7cc:	10ba8804 	addi	r2,r2,-5600
 824a7d0:	10800817 	ldw	r2,32(r2)
 824a7d4:	10c00044 	addi	r3,r2,1
 824a7d8:	008209b4 	movhi	r2,2086
 824a7dc:	10ba8804 	addi	r2,r2,-5600
 824a7e0:	10c00815 	stw	r3,32(r2)
      
/* 
 * Altera Niche Stack Nios port modification
 */
#if defined(ALT_INICHE) && !defined(PING_APP) && defined(IP_RAW)
      return(ip_raw_input(p));
 824a7e4:	e13ffd17 	ldw	r4,-12(fp)
 824a7e8:	8243cc40 	call	8243cc4 <ip_raw_input>
 824a7ec:	00018206 	br	824adf8 <icmprcv+0xb48>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
      return(0);
#endif   /* PING_APP */
#ifdef FULL_ICMP
   case DESTIN:
      icmp_mib.icmpInDestUnreachs++;
 824a7f0:	008209b4 	movhi	r2,2086
 824a7f4:	10ba8804 	addi	r2,r2,-5600
 824a7f8:	10800217 	ldw	r2,8(r2)
 824a7fc:	10c00044 	addi	r3,r2,1
 824a800:	008209b4 	movhi	r2,2086
 824a804:	10ba8804 	addi	r2,r2,-5600
 824a808:	10c00215 	stw	r3,8(r2)
      pdp = (struct destun *)e;
 824a80c:	e0bff717 	ldw	r2,-36(fp)
 824a810:	e0bffa15 	stw	r2,-24(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824a814:	d0a08317 	ldw	r2,-32244(gp)
 824a818:	1081000c 	andi	r2,r2,1024
 824a81c:	10002f26 	beq	r2,zero,824a8dc <icmprcv+0x62c>
      {
         dprintf("ICMP: got dest unreachable type ");
 824a820:	01020974 	movhi	r4,2085
 824a824:	21071604 	addi	r4,r4,7256
 824a828:	820331c0 	call	820331c <printf>
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a82c:	e0bffa17 	ldw	r2,-24(fp)
 824a830:	10800043 	ldbu	r2,1(r2)
 824a834:	11003fcc 	andi	r4,r2,255
 824a838:	2100201c 	xori	r4,r4,128
 824a83c:	213fe004 	addi	r4,r4,-128
          PUSH_IPADDR(pdp->dip.ip_dest));
 824a840:	e0bffa17 	ldw	r2,-24(fp)
 824a844:	10800617 	ldw	r2,24(r2)
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a848:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 824a84c:	e0bffa17 	ldw	r2,-24(fp)
 824a850:	10800617 	ldw	r2,24(r2)
 824a854:	1004d23a 	srli	r2,r2,8
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a858:	11803fcc 	andi	r6,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 824a85c:	e0bffa17 	ldw	r2,-24(fp)
 824a860:	10800617 	ldw	r2,24(r2)
 824a864:	1004d43a 	srli	r2,r2,16
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a868:	10803fcc 	andi	r2,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 824a86c:	e0fffa17 	ldw	r3,-24(fp)
 824a870:	18c00617 	ldw	r3,24(r3)
 824a874:	1806d63a 	srli	r3,r3,24
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 824a878:	d8c00115 	stw	r3,4(sp)
 824a87c:	d8800015 	stw	r2,0(sp)
 824a880:	300f883a 	mov	r7,r6
 824a884:	280d883a 	mov	r6,r5
 824a888:	200b883a 	mov	r5,r4
 824a88c:	01020974 	movhi	r4,2085
 824a890:	21071f04 	addi	r4,r4,7292
 824a894:	820331c0 	call	820331c <printf>
          PUSH_IPADDR(pdp->dip.ip_dest));
         dprintf("from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824a898:	e0bff617 	ldw	r2,-40(fp)
 824a89c:	10c03fcc 	andi	r3,r2,255
 824a8a0:	e0bff617 	ldw	r2,-40(fp)
 824a8a4:	1004d23a 	srli	r2,r2,8
 824a8a8:	11003fcc 	andi	r4,r2,255
 824a8ac:	e0bff617 	ldw	r2,-40(fp)
 824a8b0:	1004d43a 	srli	r2,r2,16
 824a8b4:	11403fcc 	andi	r5,r2,255
 824a8b8:	e0bff617 	ldw	r2,-40(fp)
 824a8bc:	1004d63a 	srli	r2,r2,24
 824a8c0:	d8800015 	stw	r2,0(sp)
 824a8c4:	280f883a 	mov	r7,r5
 824a8c8:	200d883a 	mov	r6,r4
 824a8cc:	180b883a 	mov	r5,r3
 824a8d0:	01020974 	movhi	r4,2085
 824a8d4:	21072404 	addi	r4,r4,7312
 824a8d8:	820331c0 	call	820331c <printf>
      }
#endif   /* NPDEBUG */
      icmp_du(p, pdp);
 824a8dc:	e17ffa17 	ldw	r5,-24(fp)
 824a8e0:	e13ffd17 	ldw	r4,-12(fp)
 824a8e4:	824b4280 	call	824b428 <icmp_du>
      break;
 824a8e8:	00014206 	br	824adf4 <icmprcv+0xb44>
   case SOURCEQ:
      icmp_mib.icmpInSrcQuenchs++;
 824a8ec:	008209b4 	movhi	r2,2086
 824a8f0:	10ba8804 	addi	r2,r2,-5600
 824a8f4:	10800517 	ldw	r2,20(r2)
 824a8f8:	10c00044 	addi	r3,r2,1
 824a8fc:	008209b4 	movhi	r2,2086
 824a900:	10ba8804 	addi	r2,r2,-5600
 824a904:	10c00515 	stw	r3,20(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824a908:	d0a08317 	ldw	r2,-32244(gp)
 824a90c:	1081000c 	andi	r2,r2,1024
 824a910:	10001626 	beq	r2,zero,824a96c <icmprcv+0x6bc>
      {
         dprintf("ICMP: source quench from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 824a914:	e0bff617 	ldw	r2,-40(fp)
 824a918:	10c03fcc 	andi	r3,r2,255
 824a91c:	e0bff617 	ldw	r2,-40(fp)
 824a920:	1004d23a 	srli	r2,r2,8
 824a924:	11003fcc 	andi	r4,r2,255
 824a928:	e0bff617 	ldw	r2,-40(fp)
 824a92c:	1004d43a 	srli	r2,r2,16
 824a930:	11403fcc 	andi	r5,r2,255
 824a934:	e0bff617 	ldw	r2,-40(fp)
 824a938:	1004d63a 	srli	r2,r2,24
 824a93c:	d8800015 	stw	r2,0(sp)
 824a940:	280f883a 	mov	r7,r5
 824a944:	200d883a 	mov	r6,r4
 824a948:	180b883a 	mov	r5,r3
 824a94c:	01020974 	movhi	r4,2085
 824a950:	21072904 	addi	r4,r4,7332
 824a954:	820331c0 	call	820331c <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824a958:	d0a08317 	ldw	r2,-32244(gp)
 824a95c:	1080008c 	andi	r2,r2,2
 824a960:	10000226 	beq	r2,zero,824a96c <icmprcv+0x6bc>
 824a964:	e13ffd17 	ldw	r4,-12(fp)
 824a968:	82408a40 	call	82408a4 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824a96c:	01000084 	movi	r4,2
 824a970:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(p);
 824a974:	e13ffd17 	ldw	r4,-12(fp)
 824a978:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824a97c:	01000084 	movi	r4,2
 824a980:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      break;
 824a984:	00011b06 	br	824adf4 <icmprcv+0xb44>
   case REDIR:          /* got an icmp redirect */
      icmp_mib.icmpInRedirects++;
 824a988:	008209b4 	movhi	r2,2086
 824a98c:	10ba8804 	addi	r2,r2,-5600
 824a990:	10800617 	ldw	r2,24(r2)
 824a994:	10c00044 	addi	r3,r2,1
 824a998:	008209b4 	movhi	r2,2086
 824a99c:	10ba8804 	addi	r2,r2,-5600
 824a9a0:	10c00615 	stw	r3,24(r2)
      rd = (struct redirect *)e;
 824a9a4:	e0bff717 	ldw	r2,-36(fp)
 824a9a8:	e0bffb15 	stw	r2,-20(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824a9ac:	d0a08317 	ldw	r2,-32244(gp)
 824a9b0:	1081000c 	andi	r2,r2,1024
 824a9b4:	10002a26 	beq	r2,zero,824aa60 <icmprcv+0x7b0>
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
          PUSH_IPADDR(rd->rdip.ip_dest));
 824a9b8:	e0bffb17 	ldw	r2,-20(fp)
 824a9bc:	10800617 	ldw	r2,24(r2)
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824a9c0:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 824a9c4:	e0bffb17 	ldw	r2,-20(fp)
 824a9c8:	10800617 	ldw	r2,24(r2)
 824a9cc:	1004d23a 	srli	r2,r2,8
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824a9d0:	11003fcc 	andi	r4,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 824a9d4:	e0bffb17 	ldw	r2,-20(fp)
 824a9d8:	10800617 	ldw	r2,24(r2)
 824a9dc:	1004d43a 	srli	r2,r2,16
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824a9e0:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 824a9e4:	e0bffb17 	ldw	r2,-20(fp)
 824a9e8:	10800617 	ldw	r2,24(r2)
 824a9ec:	1004d63a 	srli	r2,r2,24
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 824a9f0:	d8800015 	stw	r2,0(sp)
 824a9f4:	280f883a 	mov	r7,r5
 824a9f8:	200d883a 	mov	r6,r4
 824a9fc:	180b883a 	mov	r5,r3
 824aa00:	01020974 	movhi	r4,2085
 824aa04:	21073304 	addi	r4,r4,7372
 824aa08:	820331c0 	call	820331c <printf>
          PUSH_IPADDR(rd->rdip.ip_dest));
         dprintf("to %u.%u.%u.%u\n", PUSH_IPADDR(rd->rdgw));
 824aa0c:	e0bffb17 	ldw	r2,-20(fp)
 824aa10:	10800117 	ldw	r2,4(r2)
 824aa14:	10c03fcc 	andi	r3,r2,255
 824aa18:	e0bffb17 	ldw	r2,-20(fp)
 824aa1c:	10800117 	ldw	r2,4(r2)
 824aa20:	1004d23a 	srli	r2,r2,8
 824aa24:	11003fcc 	andi	r4,r2,255
 824aa28:	e0bffb17 	ldw	r2,-20(fp)
 824aa2c:	10800117 	ldw	r2,4(r2)
 824aa30:	1004d43a 	srli	r2,r2,16
 824aa34:	11403fcc 	andi	r5,r2,255
 824aa38:	e0bffb17 	ldw	r2,-20(fp)
 824aa3c:	10800117 	ldw	r2,4(r2)
 824aa40:	1004d63a 	srli	r2,r2,24
 824aa44:	d8800015 	stw	r2,0(sp)
 824aa48:	280f883a 	mov	r7,r5
 824aa4c:	200d883a 	mov	r6,r4
 824aa50:	180b883a 	mov	r5,r3
 824aa54:	01020974 	movhi	r4,2085
 824aa58:	21073d04 	addi	r4,r4,7412
 824aa5c:	820331c0 	call	820331c <printf>
      }
#endif   /* NPDEBUG */
#ifdef IP_ROUTING
      /* try to add/update route table */
      add_route(rd->rdip.ip_dest, 0xFFFFFFFF, rd->rdgw, 
 824aa60:	e0bffb17 	ldw	r2,-20(fp)
 824aa64:	14000617 	ldw	r16,24(r2)
 824aa68:	e0bffb17 	ldw	r2,-20(fp)
 824aa6c:	14400117 	ldw	r17,4(r2)
 824aa70:	e0bffd17 	ldw	r2,-12(fp)
 824aa74:	10800617 	ldw	r2,24(r2)
 824aa78:	1009883a 	mov	r4,r2
 824aa7c:	8226ba40 	call	8226ba4 <if_netnumber>
 824aa80:	1007883a 	mov	r3,r2
 824aa84:	00800104 	movi	r2,4
 824aa88:	d8800015 	stw	r2,0(sp)
 824aa8c:	180f883a 	mov	r7,r3
 824aa90:	880d883a 	mov	r6,r17
 824aa94:	017fffc4 	movi	r5,-1
 824aa98:	8009883a 	mov	r4,r16
 824aa9c:	82441800 	call	8244180 <add_route>
       net_num(p->net), IPRP_ICMP);
#endif   /* IP_ROUTING */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824aaa0:	01000084 	movi	r4,2
 824aaa4:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(p);
 824aaa8:	e13ffd17 	ldw	r4,-12(fp)
 824aaac:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824aab0:	01000084 	movi	r4,2
 824aab4:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      break;
 824aab8:	0000ce06 	br	824adf4 <icmprcv+0xb44>
   case TIMEX:
      icmp_mib.icmpInTimeExcds++;
 824aabc:	008209b4 	movhi	r2,2086
 824aac0:	10ba8804 	addi	r2,r2,-5600
 824aac4:	10800317 	ldw	r2,12(r2)
 824aac8:	10c00044 	addi	r3,r2,1
 824aacc:	008209b4 	movhi	r2,2086
 824aad0:	10ba8804 	addi	r2,r2,-5600
 824aad4:	10c00315 	stw	r3,12(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824aad8:	d0a08317 	ldw	r2,-32244(gp)
 824aadc:	1081000c 	andi	r2,r2,1024
 824aae0:	10003126 	beq	r2,zero,824aba8 <icmprcv+0x8f8>
      {
         struct timex * pt =  (struct  timex *)e;
 824aae4:	e0bff717 	ldw	r2,-36(fp)
 824aae8:	e0bffc15 	stw	r2,-16(fp)

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
          PUSH_IPADDR(p->fhost));
 824aaec:	e0bffd17 	ldw	r2,-12(fp)
 824aaf0:	10800717 	ldw	r2,28(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824aaf4:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(p->fhost));
 824aaf8:	e0bffd17 	ldw	r2,-12(fp)
 824aafc:	10800717 	ldw	r2,28(r2)
 824ab00:	1004d23a 	srli	r2,r2,8
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824ab04:	11003fcc 	andi	r4,r2,255
          PUSH_IPADDR(p->fhost));
 824ab08:	e0bffd17 	ldw	r2,-12(fp)
 824ab0c:	10800717 	ldw	r2,28(r2)
 824ab10:	1004d43a 	srli	r2,r2,16
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824ab14:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(p->fhost));
 824ab18:	e0bffd17 	ldw	r2,-12(fp)
 824ab1c:	10800717 	ldw	r2,28(r2)
 824ab20:	1004d63a 	srli	r2,r2,24
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 824ab24:	d8800015 	stw	r2,0(sp)
 824ab28:	280f883a 	mov	r7,r5
 824ab2c:	200d883a 	mov	r6,r4
 824ab30:	180b883a 	mov	r5,r3
 824ab34:	01020974 	movhi	r4,2085
 824ab38:	21074104 	addi	r4,r4,7428
 824ab3c:	820331c0 	call	820331c <printf>
          PUSH_IPADDR(p->fhost));
         dprintf(" about %u.%u.%u.%u\n", PUSH_IPADDR(pt->tip.ip_dest));
 824ab40:	e0bffc17 	ldw	r2,-16(fp)
 824ab44:	10800617 	ldw	r2,24(r2)
 824ab48:	10c03fcc 	andi	r3,r2,255
 824ab4c:	e0bffc17 	ldw	r2,-16(fp)
 824ab50:	10800617 	ldw	r2,24(r2)
 824ab54:	1004d23a 	srli	r2,r2,8
 824ab58:	11003fcc 	andi	r4,r2,255
 824ab5c:	e0bffc17 	ldw	r2,-16(fp)
 824ab60:	10800617 	ldw	r2,24(r2)
 824ab64:	1004d43a 	srli	r2,r2,16
 824ab68:	11403fcc 	andi	r5,r2,255
 824ab6c:	e0bffc17 	ldw	r2,-16(fp)
 824ab70:	10800617 	ldw	r2,24(r2)
 824ab74:	1004d63a 	srli	r2,r2,24
 824ab78:	d8800015 	stw	r2,0(sp)
 824ab7c:	280f883a 	mov	r7,r5
 824ab80:	200d883a 	mov	r6,r4
 824ab84:	180b883a 	mov	r5,r3
 824ab88:	01020974 	movhi	r4,2085
 824ab8c:	21074a04 	addi	r4,r4,7464
 824ab90:	820331c0 	call	820331c <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824ab94:	d0a08317 	ldw	r2,-32244(gp)
 824ab98:	1080008c 	andi	r2,r2,2
 824ab9c:	10000226 	beq	r2,zero,824aba8 <icmprcv+0x8f8>
 824aba0:	e13ffd17 	ldw	r4,-12(fp)
 824aba4:	82408a40 	call	82408a4 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824aba8:	01000084 	movi	r4,2
 824abac:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(p);
 824abb0:	e13ffd17 	ldw	r4,-12(fp)
 824abb4:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824abb8:	01000084 	movi	r4,2
 824abbc:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      break;
 824abc0:	00008c06 	br	824adf4 <icmprcv+0xb44>
   case PARAM:
      icmp_mib.icmpInParmProbs++;
 824abc4:	008209b4 	movhi	r2,2086
 824abc8:	10ba8804 	addi	r2,r2,-5600
 824abcc:	10800417 	ldw	r2,16(r2)
 824abd0:	10c00044 	addi	r3,r2,1
 824abd4:	008209b4 	movhi	r2,2086
 824abd8:	10ba8804 	addi	r2,r2,-5600
 824abdc:	10c00415 	stw	r3,16(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824abe0:	d0a08317 	ldw	r2,-32244(gp)
 824abe4:	1081000c 	andi	r2,r2,1024
 824abe8:	10000326 	beq	r2,zero,824abf8 <icmprcv+0x948>
         dprintf("ICMP: got param problem message\n");
 824abec:	01020974 	movhi	r4,2085
 824abf0:	21074f04 	addi	r4,r4,7484
 824abf4:	82035a00 	call	82035a0 <puts>
      if (NDEBUG & DUMP)
 824abf8:	d0a08317 	ldw	r2,-32244(gp)
 824abfc:	1080008c 	andi	r2,r2,2
 824ac00:	10000226 	beq	r2,zero,824ac0c <icmprcv+0x95c>
      {
         ip_dump(p);
 824ac04:	e13ffd17 	ldw	r4,-12(fp)
 824ac08:	82408a40 	call	82408a4 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824ac0c:	01000084 	movi	r4,2
 824ac10:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(p);
 824ac14:	e13ffd17 	ldw	r4,-12(fp)
 824ac18:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824ac1c:	01000084 	movi	r4,2
 824ac20:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      break;
 824ac24:	00007306 	br	824adf4 <icmprcv+0xb44>
   case TIMEREQ:
      icmp_mib.icmpInTimestamps++;
 824ac28:	008209b4 	movhi	r2,2086
 824ac2c:	10ba8804 	addi	r2,r2,-5600
 824ac30:	10800917 	ldw	r2,36(r2)
 824ac34:	10c00044 	addi	r3,r2,1
 824ac38:	008209b4 	movhi	r2,2086
 824ac3c:	10ba8804 	addi	r2,r2,-5600
 824ac40:	10c00915 	stw	r3,36(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824ac44:	d0a08317 	ldw	r2,-32244(gp)
 824ac48:	1081000c 	andi	r2,r2,1024
 824ac4c:	10000326 	beq	r2,zero,824ac5c <icmprcv+0x9ac>
         dprintf("ICMP: got timestamp request\n");
 824ac50:	01020974 	movhi	r4,2085
 824ac54:	21075704 	addi	r4,r4,7516
 824ac58:	82035a00 	call	82035a0 <puts>
#endif   /* NPDEBUG */
      e->ptype = TIMEREP;
 824ac5c:	e0bff717 	ldw	r2,-36(fp)
 824ac60:	00c00384 	movi	r3,14
 824ac64:	10c00005 	stb	r3,0(r2)
      e->pchksum = 0;
 824ac68:	e0bff717 	ldw	r2,-36(fp)
 824ac6c:	1000008d 	sth	zero,2(r2)
		   */
		  sstmp->dtstamp[1] = sstmp->dtstamp[2] = user_UTCtime();
	  }
#endif /* USER_PING_TSTAMP */

      e->pchksum = ~cksum(e, sizeof(struct tstamp)>>1);
 824ac70:	01400284 	movi	r5,10
 824ac74:	e13ff717 	ldw	r4,-36(fp)
 824ac78:	82286f00 	call	82286f0 <cksum>
 824ac7c:	0084303a 	nor	r2,zero,r2
 824ac80:	1007883a 	mov	r3,r2
 824ac84:	e0bff717 	ldw	r2,-36(fp)
 824ac88:	10c0008d 	sth	r3,2(r2)
      pip->ip_src = pip->ip_dest;
 824ac8c:	e0bff417 	ldw	r2,-48(fp)
 824ac90:	10c00417 	ldw	r3,16(r2)
 824ac94:	e0bff417 	ldw	r2,-48(fp)
 824ac98:	10c00315 	stw	r3,12(r2)
      pip->ip_dest = host;
 824ac9c:	e0bff417 	ldw	r2,-48(fp)
 824aca0:	e0fff617 	ldw	r3,-40(fp)
 824aca4:	10c00415 	stw	r3,16(r2)
      icmp_mib.icmpOutMsgs++;
 824aca8:	008209b4 	movhi	r2,2086
 824acac:	10ba8804 	addi	r2,r2,-5600
 824acb0:	10800d17 	ldw	r2,52(r2)
 824acb4:	10c00044 	addi	r3,r2,1
 824acb8:	008209b4 	movhi	r2,2086
 824acbc:	10ba8804 	addi	r2,r2,-5600
 824acc0:	10c00d15 	stw	r3,52(r2)
      icmp_mib.icmpOutTimestampReps++;
 824acc4:	008209b4 	movhi	r2,2086
 824acc8:	10ba8804 	addi	r2,r2,-5600
 824accc:	10801717 	ldw	r2,92(r2)
 824acd0:	10c00044 	addi	r3,r2,1
 824acd4:	008209b4 	movhi	r2,2086
 824acd8:	10ba8804 	addi	r2,r2,-5600
 824acdc:	10c01715 	stw	r3,92(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 824ace0:	e0bffd17 	ldw	r2,-12(fp)
 824ace4:	10c00317 	ldw	r3,12(r2)
 824ace8:	e0bff417 	ldw	r2,-48(fp)
 824acec:	10800003 	ldbu	r2,0(r2)
 824acf0:	10803fcc 	andi	r2,r2,255
 824acf4:	108003cc 	andi	r2,r2,15
 824acf8:	1085883a 	add	r2,r2,r2
 824acfc:	1085883a 	add	r2,r2,r2
 824ad00:	1887883a 	add	r3,r3,r2
 824ad04:	e0bffd17 	ldw	r2,-12(fp)
 824ad08:	10c00315 	stw	r3,12(r2)
      p->nb_plen = sizeof(struct tstamp);
 824ad0c:	e0bffd17 	ldw	r2,-12(fp)
 824ad10:	00c00504 	movi	r3,20
 824ad14:	10c00415 	stw	r3,16(r2)
      p->fhost = host;
 824ad18:	e0bffd17 	ldw	r2,-12(fp)
 824ad1c:	e0fff617 	ldw	r3,-40(fp)
 824ad20:	10c00715 	stw	r3,28(r2)
      i = ip_write(ICMP_PROT, p);
 824ad24:	e17ffd17 	ldw	r5,-12(fp)
 824ad28:	01000044 	movi	r4,1
 824ad2c:	823f7b00 	call	823f7b0 <ip_write>
 824ad30:	e0bff915 	stw	r2,-28(fp)
      if (i < 0)
 824ad34:	e0bff917 	ldw	r2,-28(fp)
 824ad38:	1000060e 	bge	r2,zero,824ad54 <icmprcv+0xaa4>
      {
#ifdef   NPDEBUG
         if (NDEBUG & UPCTRACE)
 824ad3c:	d0a08317 	ldw	r2,-32244(gp)
 824ad40:	1081000c 	andi	r2,r2,1024
 824ad44:	10000326 	beq	r2,zero,824ad54 <icmprcv+0xaa4>
            dprintf("icmp: can't send timestamp reply\n");
 824ad48:	01020974 	movhi	r4,2085
 824ad4c:	21075e04 	addi	r4,r4,7544
 824ad50:	82035a00 	call	82035a0 <puts>
#endif   /* NPDEBUG */
      }
      /* re-used packet was pk_free()d by net->send() */
      return (0);
 824ad54:	0005883a 	mov	r2,zero
 824ad58:	00002706 	br	824adf8 <icmprcv+0xb48>
   case INFO:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824ad5c:	d0a08317 	ldw	r2,-32244(gp)
 824ad60:	1081000c 	andi	r2,r2,1024
 824ad64:	10000326 	beq	r2,zero,824ad74 <icmprcv+0xac4>
         dprintf("icmp: got info request\n");
 824ad68:	01020974 	movhi	r4,2085
 824ad6c:	21076704 	addi	r4,r4,7580
 824ad70:	82035a00 	call	82035a0 <puts>
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824ad74:	01000084 	movi	r4,2
 824ad78:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(p);
 824ad7c:	e13ffd17 	ldw	r4,-12(fp)
 824ad80:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824ad84:	01000084 	movi	r4,2
 824ad88:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      break;
 824ad8c:	00001906 	br	824adf4 <icmprcv+0xb44>
#endif   /* FULL_ICMP */
   default:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 824ad90:	d0a08317 	ldw	r2,-32244(gp)
 824ad94:	1081000c 	andi	r2,r2,1024
 824ad98:	10000e26 	beq	r2,zero,824add4 <icmprcv+0xb24>
      {
         dprintf("icmp: unhandled type %u\n", e->ptype);
 824ad9c:	e0bff717 	ldw	r2,-36(fp)
 824ada0:	10800003 	ldbu	r2,0(r2)
 824ada4:	10803fcc 	andi	r2,r2,255
 824ada8:	1080201c 	xori	r2,r2,128
 824adac:	10bfe004 	addi	r2,r2,-128
 824adb0:	100b883a 	mov	r5,r2
 824adb4:	01020974 	movhi	r4,2085
 824adb8:	21076d04 	addi	r4,r4,7604
 824adbc:	820331c0 	call	820331c <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 824adc0:	d0a08317 	ldw	r2,-32244(gp)
 824adc4:	1080008c 	andi	r2,r2,2
 824adc8:	10000226 	beq	r2,zero,824add4 <icmprcv+0xb24>
 824adcc:	e13ffd17 	ldw	r4,-12(fp)
 824add0:	82408a40 	call	82408a4 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 824add4:	01000084 	movi	r4,2
 824add8:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
      pk_free(p);
 824addc:	e13ffd17 	ldw	r4,-12(fp)
 824ade0:	822cbbc0 	call	822cbbc <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824ade4:	01000084 	movi	r4,2
 824ade8:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>
      return ENP_NOT_MINE;
 824adec:	00800084 	movi	r2,2
 824adf0:	00000106 	br	824adf8 <icmprcv+0xb48>
   }
#ifdef FULL_ICMP
   return ENP_NOT_MINE;
 824adf4:	00800084 	movi	r2,2
#endif   /* FULL_ICMP */
}
 824adf8:	e6fffe04 	addi	sp,fp,-8
 824adfc:	dfc00317 	ldw	ra,12(sp)
 824ae00:	df000217 	ldw	fp,8(sp)
 824ae04:	dc400117 	ldw	r17,4(sp)
 824ae08:	dc000017 	ldw	r16,0(sp)
 824ae0c:	dec00404 	addi	sp,sp,16
 824ae10:	f800283a 	ret

0824ae14 <icmp_destun>:
icmp_destun(ip_addr host,  /* host to complain to */
   ip_addr src_addr, /* source address for outgoing ICMP/IP packet header */
   struct ip * ip,   /* IP header of offending packet */
   unsigned typecode,    /* type & code of DU to send (PROT, PORT, HOST) */
   NET   net)        /* interface that this packet came in on */
{
 824ae14:	defff404 	addi	sp,sp,-48
 824ae18:	dfc00b15 	stw	ra,44(sp)
 824ae1c:	df000a15 	stw	fp,40(sp)
 824ae20:	df000a04 	addi	fp,sp,40
 824ae24:	e13ffc15 	stw	r4,-16(fp)
 824ae28:	e17ffd15 	stw	r5,-12(fp)
 824ae2c:	e1bffe15 	stw	r6,-8(fp)
 824ae30:	e1ffff15 	stw	r7,-4(fp)
   struct destun *   d;
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 824ae34:	d0a08317 	ldw	r2,-32244(gp)
 824ae38:	1080040c 	andi	r2,r2,16
 824ae3c:	10001a26 	beq	r2,zero,824aea8 <icmp_destun+0x94>
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824ae40:	e0bfff17 	ldw	r2,-4(fp)
 824ae44:	10c03fcc 	andi	r3,r2,255
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824ae48:	00820974 	movhi	r2,2085
 824ae4c:	108f9a04 	addi	r2,r2,15976
 824ae50:	18c7883a 	add	r3,r3,r3
 824ae54:	18c7883a 	add	r3,r3,r3
 824ae58:	10c5883a 	add	r2,r2,r3
 824ae5c:	11000017 	ldw	r4,0(r2)
 824ae60:	e0bffc17 	ldw	r2,-16(fp)
 824ae64:	11403fcc 	andi	r5,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824ae68:	e0bffc17 	ldw	r2,-16(fp)
 824ae6c:	1004d23a 	srli	r2,r2,8
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824ae70:	11803fcc 	andi	r6,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824ae74:	e0bffc17 	ldw	r2,-16(fp)
 824ae78:	1004d43a 	srli	r2,r2,16
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824ae7c:	10803fcc 	andi	r2,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 824ae80:	e0fffc17 	ldw	r3,-16(fp)
 824ae84:	1806d63a 	srli	r3,r3,24
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 824ae88:	d8c00115 	stw	r3,4(sp)
 824ae8c:	d8800015 	stw	r2,0(sp)
 824ae90:	300f883a 	mov	r7,r6
 824ae94:	280d883a 	mov	r6,r5
 824ae98:	200b883a 	mov	r5,r4
 824ae9c:	01020974 	movhi	r4,2085
 824aea0:	21078704 	addi	r4,r4,7708
 824aea4:	820331c0 	call	820331c <printf>
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(FREEQ_RESID);
 824aea8:	01000084 	movi	r4,2
 824aeac:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
   p = pk_alloc(512 + IPHSIZ);   /* get packet to send icmp dest unreachable */
 824aeb0:	01008504 	movi	r4,532
 824aeb4:	822c86c0 	call	822c86c <pk_alloc>
 824aeb8:	e0bff815 	stw	r2,-32(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824aebc:	01000084 	movi	r4,2
 824aec0:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 824aec4:	e0bff817 	ldw	r2,-32(fp)
 824aec8:	10000e1e 	bne	r2,zero,824af04 <icmp_destun+0xf0>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 824aecc:	d0a08317 	ldw	r2,-32244(gp)
 824aed0:	1080800c 	andi	r2,r2,512
 824aed4:	10000326 	beq	r2,zero,824aee4 <icmp_destun+0xd0>
         dprintf("icmp: can't alloc pkt\n");
 824aed8:	01020974 	movhi	r4,2085
 824aedc:	21079404 	addi	r4,r4,7760
 824aee0:	82035a00 	call	82035a0 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 824aee4:	008209b4 	movhi	r2,2086
 824aee8:	10ba8804 	addi	r2,r2,-5600
 824aeec:	10800e17 	ldw	r2,56(r2)
 824aef0:	10c00044 	addi	r3,r2,1
 824aef4:	008209b4 	movhi	r2,2086
 824aef8:	10ba8804 	addi	r2,r2,-5600
 824aefc:	10c00e15 	stw	r3,56(r2)
      return;
 824af00:	00007f06 	br	824b100 <icmp_destun+0x2ec>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 824af04:	e0bff817 	ldw	r2,-32(fp)
 824af08:	10800317 	ldw	r2,12(r2)
 824af0c:	e0bff915 	stw	r2,-28(fp)
   pip->ip_src = src_addr;
 824af10:	e0bff917 	ldw	r2,-28(fp)
 824af14:	e0fffd17 	ldw	r3,-12(fp)
 824af18:	10c00315 	stw	r3,12(r2)
   pip->ip_dest = host;
 824af1c:	e0bff917 	ldw	r2,-28(fp)
 824af20:	e0fffc17 	ldw	r3,-16(fp)
 824af24:	10c00415 	stw	r3,16(r2)

   /* allow space for icmp header */
   p->nb_prot += sizeof(struct ip);
 824af28:	e0bff817 	ldw	r2,-32(fp)
 824af2c:	10800317 	ldw	r2,12(r2)
 824af30:	10c00504 	addi	r3,r2,20
 824af34:	e0bff817 	ldw	r2,-32(fp)
 824af38:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= sizeof(struct ip);
 824af3c:	e0bff817 	ldw	r2,-32(fp)
 824af40:	10800417 	ldw	r2,16(r2)
 824af44:	10fffb04 	addi	r3,r2,-20
 824af48:	e0bff817 	ldw	r2,-32(fp)
 824af4c:	10c00415 	stw	r3,16(r2)
   p->net = net;     /* Put in the interface that this packet came in on */
 824af50:	e0bff817 	ldw	r2,-32(fp)
 824af54:	e0c00217 	ldw	r3,8(fp)
 824af58:	10c00615 	stw	r3,24(r2)

   d = (struct destun *)p->nb_prot;
 824af5c:	e0bff817 	ldw	r2,-32(fp)
 824af60:	10800317 	ldw	r2,12(r2)
 824af64:	e0bffa15 	stw	r2,-24(fp)

   if (typecode & 0xFF00)               /* if the type was sent */
 824af68:	e0bfff17 	ldw	r2,-4(fp)
 824af6c:	10bfc00c 	andi	r2,r2,65280
 824af70:	10000626 	beq	r2,zero,824af8c <icmp_destun+0x178>
      d->dtype = (char)(typecode >>8);  /* then use it */
 824af74:	e0bfff17 	ldw	r2,-4(fp)
 824af78:	1004d23a 	srli	r2,r2,8
 824af7c:	1007883a 	mov	r3,r2
 824af80:	e0bffa17 	ldw	r2,-24(fp)
 824af84:	10c00005 	stb	r3,0(r2)
 824af88:	00000306 	br	824af98 <icmp_destun+0x184>
   else                                 /* else use default */
      d->dtype = DESTIN;
 824af8c:	e0bffa17 	ldw	r2,-24(fp)
 824af90:	00c000c4 	movi	r3,3
 824af94:	10c00005 	stb	r3,0(r2)
   d->dcode = (char)(typecode & 0xFF);
 824af98:	e0bfff17 	ldw	r2,-4(fp)
 824af9c:	1007883a 	mov	r3,r2
 824afa0:	e0bffa17 	ldw	r2,-24(fp)
 824afa4:	10c00045 	stb	r3,1(r2)
   d->dno1 = d->dno2 = 0;
 824afa8:	e0bffa17 	ldw	r2,-24(fp)
 824afac:	1000018d 	sth	zero,6(r2)
 824afb0:	e0bffa17 	ldw	r2,-24(fp)
 824afb4:	10c0018b 	ldhu	r3,6(r2)
 824afb8:	e0bffa17 	ldw	r2,-24(fp)
 824afbc:	10c0010d 	sth	r3,4(r2)
#ifndef ICMP_SUPPRESS_PMTU
   if ((typecode & 0xFF) == DSTFRAG)
 824afc0:	e0bfff17 	ldw	r2,-4(fp)
 824afc4:	10803fcc 	andi	r2,r2,255
 824afc8:	10800118 	cmpnei	r2,r2,4
 824afcc:	1000121e 	bne	r2,zero,824b018 <icmp_destun+0x204>
      d->dno2 = htons(net->n_mtu - net->n_lnh);
 824afd0:	e0800217 	ldw	r2,8(fp)
 824afd4:	10c00917 	ldw	r3,36(r2)
 824afd8:	e0800217 	ldw	r2,8(fp)
 824afdc:	10800817 	ldw	r2,32(r2)
 824afe0:	1885c83a 	sub	r2,r3,r2
 824afe4:	1005d23a 	srai	r2,r2,8
 824afe8:	10803fcc 	andi	r2,r2,255
 824afec:	1009883a 	mov	r4,r2
 824aff0:	e0800217 	ldw	r2,8(fp)
 824aff4:	10c00917 	ldw	r3,36(r2)
 824aff8:	e0800217 	ldw	r2,8(fp)
 824affc:	10800817 	ldw	r2,32(r2)
 824b000:	1885c83a 	sub	r2,r3,r2
 824b004:	1004923a 	slli	r2,r2,8
 824b008:	2084b03a 	or	r2,r4,r2
 824b00c:	1007883a 	mov	r3,r2
 824b010:	e0bffa17 	ldw	r2,-24(fp)
 824b014:	10c0018d 	sth	r3,6(r2)
#endif    /* ICMP_SUPPRESS_PMTU */
   MEMCPY(&d->dip, ip, (sizeof(struct ip) + ICMPDUDATA));
 824b018:	e0bffa17 	ldw	r2,-24(fp)
 824b01c:	10800204 	addi	r2,r2,8
 824b020:	01800704 	movi	r6,28
 824b024:	e17ffe17 	ldw	r5,-8(fp)
 824b028:	1009883a 	mov	r4,r2
 824b02c:	8202e8c0 	call	8202e8c <memcpy>

   d->dchksum = 0;
 824b030:	e0bffa17 	ldw	r2,-24(fp)
 824b034:	1000008d 	sth	zero,2(r2)
   d->dchksum = ~cksum(d, sizeof(struct destun)>>1);
 824b038:	01400484 	movi	r5,18
 824b03c:	e13ffa17 	ldw	r4,-24(fp)
 824b040:	82286f00 	call	82286f0 <cksum>
 824b044:	0084303a 	nor	r2,zero,r2
 824b048:	1007883a 	mov	r3,r2
 824b04c:	e0bffa17 	ldw	r2,-24(fp)
 824b050:	10c0008d 	sth	r3,2(r2)

   p->nb_plen =  sizeof(struct destun);
 824b054:	e0bff817 	ldw	r2,-32(fp)
 824b058:	00c00904 	movi	r3,36
 824b05c:	10c00415 	stw	r3,16(r2)
   p->fhost = host;
 824b060:	e0bff817 	ldw	r2,-32(fp)
 824b064:	e0fffc17 	ldw	r3,-16(fp)
 824b068:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 824b06c:	e17ff817 	ldw	r5,-32(fp)
 824b070:	01000044 	movi	r4,1
 824b074:	823f7b00 	call	823f7b0 <ip_write>
 824b078:	e0bffb15 	stw	r2,-20(fp)
   if (i < 0)
 824b07c:	e0bffb17 	ldw	r2,-20(fp)
 824b080:	10000e0e 	bge	r2,zero,824b0bc <icmp_destun+0x2a8>
   {
      icmp_mib.icmpOutErrors++;
 824b084:	008209b4 	movhi	r2,2086
 824b088:	10ba8804 	addi	r2,r2,-5600
 824b08c:	10800e17 	ldw	r2,56(r2)
 824b090:	10c00044 	addi	r3,r2,1
 824b094:	008209b4 	movhi	r2,2086
 824b098:	10ba8804 	addi	r2,r2,-5600
 824b09c:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 824b0a0:	d0a08317 	ldw	r2,-32244(gp)
 824b0a4:	1080860c 	andi	r2,r2,536
 824b0a8:	10001426 	beq	r2,zero,824b0fc <icmp_destun+0x2e8>
         dprintf("ICMP: Can't send dest unreachable\n");
 824b0ac:	01020974 	movhi	r4,2085
 824b0b0:	21079a04 	addi	r4,r4,7784
 824b0b4:	82035a00 	call	82035a0 <puts>
#endif   /* NPDEBUG  */
      return;
 824b0b8:	00001006 	br	824b0fc <icmp_destun+0x2e8>
   }
   icmp_mib.icmpOutMsgs++;
 824b0bc:	008209b4 	movhi	r2,2086
 824b0c0:	10ba8804 	addi	r2,r2,-5600
 824b0c4:	10800d17 	ldw	r2,52(r2)
 824b0c8:	10c00044 	addi	r3,r2,1
 824b0cc:	008209b4 	movhi	r2,2086
 824b0d0:	10ba8804 	addi	r2,r2,-5600
 824b0d4:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutDestUnreachs++;
 824b0d8:	008209b4 	movhi	r2,2086
 824b0dc:	10ba8804 	addi	r2,r2,-5600
 824b0e0:	10800f17 	ldw	r2,60(r2)
 824b0e4:	10c00044 	addi	r3,r2,1
 824b0e8:	008209b4 	movhi	r2,2086
 824b0ec:	10ba8804 	addi	r2,r2,-5600
 824b0f0:	10c00f15 	stw	r3,60(r2)
   return;
 824b0f4:	0001883a 	nop
 824b0f8:	00000106 	br	824b100 <icmp_destun+0x2ec>
      icmp_mib.icmpOutErrors++;
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
         dprintf("ICMP: Can't send dest unreachable\n");
#endif   /* NPDEBUG  */
      return;
 824b0fc:	0001883a 	nop
   }
   icmp_mib.icmpOutMsgs++;
   icmp_mib.icmpOutDestUnreachs++;
   return;
}
 824b100:	e037883a 	mov	sp,fp
 824b104:	dfc00117 	ldw	ra,4(sp)
 824b108:	df000017 	ldw	fp,0(sp)
 824b10c:	dec00204 	addi	sp,sp,8
 824b110:	f800283a 	ret

0824b114 <icmp_timex>:
 *
 * RETURNS: void
 */

void icmp_timex (struct ip * ip, char code) 
{
 824b114:	defff504 	addi	sp,sp,-44
 824b118:	dfc00a15 	stw	ra,40(sp)
 824b11c:	df000915 	stw	fp,36(sp)
 824b120:	df000904 	addi	fp,sp,36
 824b124:	e13ffe15 	stw	r4,-8(fp)
 824b128:	2805883a 	mov	r2,r5
 824b12c:	e0bfff05 	stb	r2,-4(fp)
   struct ip * pip;
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 824b130:	d0a08317 	ldw	r2,-32244(gp)
 824b134:	1080040c 	andi	r2,r2,16
 824b138:	10003026 	beq	r2,zero,824b1fc <icmp_timex+0xe8>
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b13c:	e17fff07 	ldb	r5,-4(fp)
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b140:	e0bffe17 	ldw	r2,-8(fp)
 824b144:	10800317 	ldw	r2,12(r2)
 824b148:	1004d23a 	srli	r2,r2,8
 824b14c:	10c03fcc 	andi	r3,r2,255
 824b150:	e0bffe17 	ldw	r2,-8(fp)
 824b154:	10800317 	ldw	r2,12(r2)
 824b158:	1004923a 	slli	r2,r2,8
 824b15c:	10bfffcc 	andi	r2,r2,65535
 824b160:	1884b03a 	or	r2,r3,r2
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b164:	11803fcc 	andi	r6,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b168:	e0bffe17 	ldw	r2,-8(fp)
 824b16c:	10800317 	ldw	r2,12(r2)
 824b170:	1004d23a 	srli	r2,r2,8
 824b174:	10c03fcc 	andi	r3,r2,255
 824b178:	e0bffe17 	ldw	r2,-8(fp)
 824b17c:	10800317 	ldw	r2,12(r2)
 824b180:	1004923a 	slli	r2,r2,8
 824b184:	10bfffcc 	andi	r2,r2,65535
 824b188:	1884b03a 	or	r2,r3,r2
 824b18c:	1004d23a 	srli	r2,r2,8
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b190:	11c03fcc 	andi	r7,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b194:	e0bffe17 	ldw	r2,-8(fp)
 824b198:	10800317 	ldw	r2,12(r2)
 824b19c:	1004d23a 	srli	r2,r2,8
 824b1a0:	10c03fcc 	andi	r3,r2,255
 824b1a4:	e0bffe17 	ldw	r2,-8(fp)
 824b1a8:	10800317 	ldw	r2,12(r2)
 824b1ac:	1004923a 	slli	r2,r2,8
 824b1b0:	10bfffcc 	andi	r2,r2,65535
 824b1b4:	1884b03a 	or	r2,r3,r2
 824b1b8:	1004d43a 	srli	r2,r2,16
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b1bc:	10803fcc 	andi	r2,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 824b1c0:	e0fffe17 	ldw	r3,-8(fp)
 824b1c4:	18c00317 	ldw	r3,12(r3)
 824b1c8:	1806d23a 	srli	r3,r3,8
 824b1cc:	19003fcc 	andi	r4,r3,255
 824b1d0:	e0fffe17 	ldw	r3,-8(fp)
 824b1d4:	18c00317 	ldw	r3,12(r3)
 824b1d8:	1806923a 	slli	r3,r3,8
 824b1dc:	18ffffcc 	andi	r3,r3,65535
 824b1e0:	20c6b03a 	or	r3,r4,r3
 824b1e4:	1806d63a 	srli	r3,r3,24
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 824b1e8:	d8c00115 	stw	r3,4(sp)
 824b1ec:	d8800015 	stw	r2,0(sp)
 824b1f0:	01020974 	movhi	r4,2085
 824b1f4:	2107a304 	addi	r4,r4,7820
 824b1f8:	820331c0 	call	820331c <printf>
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
#endif   /* NPDEBUG */

   icmp_pkt_len = ICMPTIMEX_HDR_LEN + ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN;
 824b1fc:	e0bffe17 	ldw	r2,-8(fp)
 824b200:	10800003 	ldbu	r2,0(r2)
 824b204:	108003cc 	andi	r2,r2,15
 824b208:	1085883a 	add	r2,r2,r2
 824b20c:	1085883a 	add	r2,r2,r2
 824b210:	10800404 	addi	r2,r2,16
 824b214:	e0bff905 	stb	r2,-28(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 824b218:	01000084 	movi	r4,2
 824b21c:	822d6900 	call	822d690 <LOCK_NET_RESOURCE>
    * length of the "outer" IP header, length of the ICMP header (ICMPTIMEX_HDR_LEN,
    * 8 bytes), length of the "inner" IP header, and length of "user" data 
    * (ICMPTIMEX_PAYLOAD_DATA_LEN, 8 bytes) (just past the "inner" IP header).  The 
    * latter two items are from the packet that the ICMP Time Exceeded message is 
    * being sent in response to. */
   p = pk_alloc(MaxLnh + IPHSIZ + icmp_pkt_len);
 824b220:	e0bff903 	ldbu	r2,-28(fp)
 824b224:	d0e08117 	ldw	r3,-32252(gp)
 824b228:	10c5883a 	add	r2,r2,r3
 824b22c:	10800504 	addi	r2,r2,20
 824b230:	1009883a 	mov	r4,r2
 824b234:	822c86c0 	call	822c86c <pk_alloc>
 824b238:	e0bffa15 	stw	r2,-24(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 824b23c:	01000084 	movi	r4,2
 824b240:	822d7540 	call	822d754 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 824b244:	e0bffa17 	ldw	r2,-24(fp)
 824b248:	10000e1e 	bne	r2,zero,824b284 <icmp_timex+0x170>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 824b24c:	d0a08317 	ldw	r2,-32244(gp)
 824b250:	1080800c 	andi	r2,r2,512
 824b254:	10000326 	beq	r2,zero,824b264 <icmp_timex+0x150>
         dprintf("icmp: can't alloc pkt\n");
 824b258:	01020974 	movhi	r4,2085
 824b25c:	21079404 	addi	r4,r4,7760
 824b260:	82035a00 	call	82035a0 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 824b264:	008209b4 	movhi	r2,2086
 824b268:	10ba8804 	addi	r2,r2,-5600
 824b26c:	10800e17 	ldw	r2,56(r2)
 824b270:	10c00044 	addi	r3,r2,1
 824b274:	008209b4 	movhi	r2,2086
 824b278:	10ba8804 	addi	r2,r2,-5600
 824b27c:	10c00e15 	stw	r3,56(r2)
      return;
 824b280:	00006406 	br	824b414 <icmp_timex+0x300>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 824b284:	e0bffa17 	ldw	r2,-24(fp)
 824b288:	10800317 	ldw	r2,12(r2)
 824b28c:	e0bffb15 	stw	r2,-20(fp)
   /* source IP address of packet is our address (i.e., destination IP address 
    * in the datagram whose reassembly timed out) */
   pip->ip_src = ip->ip_dest;
 824b290:	e0bffe17 	ldw	r2,-8(fp)
 824b294:	10c00417 	ldw	r3,16(r2)
 824b298:	e0bffb17 	ldw	r2,-20(fp)
 824b29c:	10c00315 	stw	r3,12(r2)
   /* the destination address is the same as the source IP address of the 
    * datagram whose reassembly timed out */
   pip->ip_dest = ip->ip_src;
 824b2a0:	e0bffe17 	ldw	r2,-8(fp)
 824b2a4:	10c00317 	ldw	r3,12(r2)
 824b2a8:	e0bffb17 	ldw	r2,-20(fp)
 824b2ac:	10c00415 	stw	r3,16(r2)

   /* move past space for IP header to get to start of ICMP header */
   p->nb_prot += sizeof(struct ip);
 824b2b0:	e0bffa17 	ldw	r2,-24(fp)
 824b2b4:	10800317 	ldw	r2,12(r2)
 824b2b8:	10c00504 	addi	r3,r2,20
 824b2bc:	e0bffa17 	ldw	r2,-24(fp)
 824b2c0:	10c00315 	stw	r3,12(r2)

   tx = (struct timex *) p->nb_prot;
 824b2c4:	e0bffa17 	ldw	r2,-24(fp)
 824b2c8:	10800317 	ldw	r2,12(r2)
 824b2cc:	e0bffc15 	stw	r2,-16(fp)

   tx->ttype = TIMEX;
 824b2d0:	e0bffc17 	ldw	r2,-16(fp)
 824b2d4:	00c002c4 	movi	r3,11
 824b2d8:	10c00005 	stb	r3,0(r2)
   tx->tcode = code;
 824b2dc:	e0bffc17 	ldw	r2,-16(fp)
 824b2e0:	e0ffff03 	ldbu	r3,-4(fp)
 824b2e4:	10c00045 	stb	r3,1(r2)
   tx->tno1 = tx->tno2 = 0;
 824b2e8:	e0bffc17 	ldw	r2,-16(fp)
 824b2ec:	1000018d 	sth	zero,6(r2)
 824b2f0:	e0bffc17 	ldw	r2,-16(fp)
 824b2f4:	10c0018b 	ldhu	r3,6(r2)
 824b2f8:	e0bffc17 	ldw	r2,-16(fp)
 824b2fc:	10c0010d 	sth	r3,4(r2)
   MEMCPY(&tx->tip, ip, (ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN));
 824b300:	e0bffc17 	ldw	r2,-16(fp)
 824b304:	10c00204 	addi	r3,r2,8
 824b308:	e0bffe17 	ldw	r2,-8(fp)
 824b30c:	10800003 	ldbu	r2,0(r2)
 824b310:	10803fcc 	andi	r2,r2,255
 824b314:	108003cc 	andi	r2,r2,15
 824b318:	1085883a 	add	r2,r2,r2
 824b31c:	1085883a 	add	r2,r2,r2
 824b320:	10800204 	addi	r2,r2,8
 824b324:	100d883a 	mov	r6,r2
 824b328:	e17ffe17 	ldw	r5,-8(fp)
 824b32c:	1809883a 	mov	r4,r3
 824b330:	8202e8c0 	call	8202e8c <memcpy>

   tx->tchksum = 0;
 824b334:	e0bffc17 	ldw	r2,-16(fp)
 824b338:	1000008d 	sth	zero,2(r2)
   tx->tchksum = ~cksum(tx, (icmp_pkt_len>>1));
 824b33c:	e0bff903 	ldbu	r2,-28(fp)
 824b340:	1004d07a 	srli	r2,r2,1
 824b344:	10803fcc 	andi	r2,r2,255
 824b348:	100b883a 	mov	r5,r2
 824b34c:	e13ffc17 	ldw	r4,-16(fp)
 824b350:	82286f00 	call	82286f0 <cksum>
 824b354:	0084303a 	nor	r2,zero,r2
 824b358:	1007883a 	mov	r3,r2
 824b35c:	e0bffc17 	ldw	r2,-16(fp)
 824b360:	10c0008d 	sth	r3,2(r2)

   p->nb_plen = icmp_pkt_len;
 824b364:	e0fff903 	ldbu	r3,-28(fp)
 824b368:	e0bffa17 	ldw	r2,-24(fp)
 824b36c:	10c00415 	stw	r3,16(r2)
   /* p->fhost is expected to be in network byte order */
   p->fhost = pip->ip_dest;
 824b370:	e0bffb17 	ldw	r2,-20(fp)
 824b374:	10c00417 	ldw	r3,16(r2)
 824b378:	e0bffa17 	ldw	r2,-24(fp)
 824b37c:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 824b380:	e17ffa17 	ldw	r5,-24(fp)
 824b384:	01000044 	movi	r4,1
 824b388:	823f7b00 	call	823f7b0 <ip_write>
 824b38c:	e0bffd15 	stw	r2,-12(fp)
   if (i < 0)
 824b390:	e0bffd17 	ldw	r2,-12(fp)
 824b394:	10000e0e 	bge	r2,zero,824b3d0 <icmp_timex+0x2bc>
   {
      icmp_mib.icmpOutErrors++;
 824b398:	008209b4 	movhi	r2,2086
 824b39c:	10ba8804 	addi	r2,r2,-5600
 824b3a0:	10800e17 	ldw	r2,56(r2)
 824b3a4:	10c00044 	addi	r3,r2,1
 824b3a8:	008209b4 	movhi	r2,2086
 824b3ac:	10ba8804 	addi	r2,r2,-5600
 824b3b0:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 824b3b4:	d0a08317 	ldw	r2,-32244(gp)
 824b3b8:	1080860c 	andi	r2,r2,536
 824b3bc:	10001426 	beq	r2,zero,824b410 <icmp_timex+0x2fc>
         dprintf("ICMP: Can't send Time Exceeded\n");
 824b3c0:	01020974 	movhi	r4,2085
 824b3c4:	2107b304 	addi	r4,r4,7884
 824b3c8:	82035a00 	call	82035a0 <puts>
#endif   /* NPDEBUG  */
      return;
 824b3cc:	00001006 	br	824b410 <icmp_timex+0x2fc>
   }
   icmp_mib.icmpOutMsgs++;
 824b3d0:	008209b4 	movhi	r2,2086
 824b3d4:	10ba8804 	addi	r2,r2,-5600
 824b3d8:	10800d17 	ldw	r2,52(r2)
 824b3dc:	10c00044 	addi	r3,r2,1
 824b3e0:	008209b4 	movhi	r2,2086
 824b3e4:	10ba8804 	addi	r2,r2,-5600
 824b3e8:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutTimeExcds++;
 824b3ec:	008209b4 	movhi	r2,2086
 824b3f0:	10ba8804 	addi	r2,r2,-5600
 824b3f4:	10801017 	ldw	r2,64(r2)
 824b3f8:	10c00044 	addi	r3,r2,1
 824b3fc:	008209b4 	movhi	r2,2086
 824b400:	10ba8804 	addi	r2,r2,-5600
 824b404:	10c01015 	stw	r3,64(r2)
   return;
 824b408:	0001883a 	nop
 824b40c:	00000106 	br	824b414 <icmp_timex+0x300>
      icmp_mib.icmpOutErrors++;
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
         dprintf("ICMP: Can't send Time Exceeded\n");
#endif   /* NPDEBUG  */
      return;
 824b410:	0001883a 	nop
   }
   icmp_mib.icmpOutMsgs++;
   icmp_mib.icmpOutTimeExcds++;
   return;
}
 824b414:	e037883a 	mov	sp,fp
 824b418:	dfc00117 	ldw	ra,4(sp)
 824b41c:	df000017 	ldw	fp,0(sp)
 824b420:	dec00204 	addi	sp,sp,8
 824b424:	f800283a 	ret

0824b428 <icmp_du>:
 * RETURNS: void
 */

void  
icmp_du(PACKET p, struct destun * pdp)
{
 824b428:	defffc04 	addi	sp,sp,-16
 824b42c:	dfc00315 	stw	ra,12(sp)
 824b430:	df000215 	stw	fp,8(sp)
 824b434:	df000204 	addi	fp,sp,8
 824b438:	e13ffe15 	stw	r4,-8(fp)
 824b43c:	e17fff15 	stw	r5,-4(fp)
   /* see if user app wants notification first */
   if (icmpdu_hook)
 824b440:	d0a0dc17 	ldw	r2,-31888(gp)
 824b444:	10000426 	beq	r2,zero,824b458 <icmp_du+0x30>
      icmpdu_hook(p, pdp);
 824b448:	d0a0dc17 	ldw	r2,-31888(gp)
 824b44c:	e17fff17 	ldw	r5,-4(fp)
 824b450:	e13ffe17 	ldw	r4,-8(fp)
 824b454:	103ee83a 	callr	r2

#ifdef INCLUDE_TCP
   /* Tell the sockets layer so it can correct the problem. */
   so_icmpdu(p, pdp);   /* this call should free packet p */
 824b458:	e17fff17 	ldw	r5,-4(fp)
 824b45c:	e13ffe17 	ldw	r4,-8(fp)
 824b460:	822f5300 	call	822f530 <so_icmpdu>
done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(p); /* else just free packet */
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif   /* INCLUDE_TCP */
}
 824b464:	0001883a 	nop
 824b468:	e037883a 	mov	sp,fp
 824b46c:	dfc00117 	ldw	ra,4(sp)
 824b470:	df000017 	ldw	fp,0(sp)
 824b474:	dec00204 	addi	sp,sp,8
 824b478:	f800283a 	ret

0824b47c <atexit>:
 824b47c:	200b883a 	mov	r5,r4
 824b480:	000f883a 	mov	r7,zero
 824b484:	000d883a 	mov	r6,zero
 824b488:	0009883a 	mov	r4,zero
 824b48c:	824bbf01 	jmpi	824bbf0 <__register_exitproc>

0824b490 <atoi>:
 824b490:	01800284 	movi	r6,10
 824b494:	000b883a 	mov	r5,zero
 824b498:	824bb3c1 	jmpi	824bb3c <strtol>

0824b49c <_atoi_r>:
 824b49c:	01c00284 	movi	r7,10
 824b4a0:	000d883a 	mov	r6,zero
 824b4a4:	824b9041 	jmpi	824b904 <_strtol_r>

0824b4a8 <exit>:
 824b4a8:	defffe04 	addi	sp,sp,-8
 824b4ac:	000b883a 	mov	r5,zero
 824b4b0:	dc000015 	stw	r16,0(sp)
 824b4b4:	dfc00115 	stw	ra,4(sp)
 824b4b8:	2021883a 	mov	r16,r4
 824b4bc:	824bd080 	call	824bd08 <__call_exitprocs>
 824b4c0:	00820974 	movhi	r2,2085
 824b4c4:	108fa104 	addi	r2,r2,16004
 824b4c8:	11000017 	ldw	r4,0(r2)
 824b4cc:	20800f17 	ldw	r2,60(r4)
 824b4d0:	10000126 	beq	r2,zero,824b4d8 <exit+0x30>
 824b4d4:	103ee83a 	callr	r2
 824b4d8:	8009883a 	mov	r4,r16
 824b4dc:	824bea00 	call	824bea0 <_exit>

0824b4e0 <memalign>:
 824b4e0:	00820974 	movhi	r2,2085
 824b4e4:	108fa204 	addi	r2,r2,16008
 824b4e8:	280d883a 	mov	r6,r5
 824b4ec:	200b883a 	mov	r5,r4
 824b4f0:	11000017 	ldw	r4,0(r2)
 824b4f4:	824b4f81 	jmpi	824b4f8 <_memalign_r>

0824b4f8 <_memalign_r>:
 824b4f8:	00800204 	movi	r2,8
 824b4fc:	1140532e 	bgeu	r2,r5,824b64c <_memalign_r+0x154>
 824b500:	defffa04 	addi	sp,sp,-24
 824b504:	dd000415 	stw	r20,16(sp)
 824b508:	dc400115 	stw	r17,4(sp)
 824b50c:	dfc00515 	stw	ra,20(sp)
 824b510:	dcc00315 	stw	r19,12(sp)
 824b514:	dc800215 	stw	r18,8(sp)
 824b518:	dc000015 	stw	r16,0(sp)
 824b51c:	008003c4 	movi	r2,15
 824b520:	2823883a 	mov	r17,r5
 824b524:	2029883a 	mov	r20,r4
 824b528:	11400136 	bltu	r2,r5,824b530 <_memalign_r+0x38>
 824b52c:	04400404 	movi	r17,16
 824b530:	308002c4 	addi	r2,r6,11
 824b534:	00c00584 	movi	r3,22
 824b538:	18803e2e 	bgeu	r3,r2,824b634 <_memalign_r+0x13c>
 824b53c:	04bffe04 	movi	r18,-8
 824b540:	14a4703a 	and	r18,r2,r18
 824b544:	90003d16 	blt	r18,zero,824b63c <_memalign_r+0x144>
 824b548:	91803c36 	bltu	r18,r6,824b63c <_memalign_r+0x144>
 824b54c:	89400404 	addi	r5,r17,16
 824b550:	2c8b883a 	add	r5,r5,r18
 824b554:	a009883a 	mov	r4,r20
 824b558:	820bc680 	call	820bc68 <_malloc_r>
 824b55c:	1027883a 	mov	r19,r2
 824b560:	10004926 	beq	r2,zero,824b688 <_memalign_r+0x190>
 824b564:	a009883a 	mov	r4,r20
 824b568:	82149740 	call	8214974 <__malloc_lock>
 824b56c:	880b883a 	mov	r5,r17
 824b570:	9809883a 	mov	r4,r19
 824b574:	9c3ffe04 	addi	r16,r19,-8
 824b578:	8202bf00 	call	8202bf0 <__umodsi3>
 824b57c:	10001c26 	beq	r2,zero,824b5f0 <_memalign_r+0xf8>
 824b580:	88bfffc4 	addi	r2,r17,-1
 824b584:	9887883a 	add	r3,r19,r2
 824b588:	0445c83a 	sub	r2,zero,r17
 824b58c:	1884703a 	and	r2,r3,r2
 824b590:	10bffe04 	addi	r2,r2,-8
 824b594:	1409c83a 	sub	r4,r2,r16
 824b598:	014003c4 	movi	r5,15
 824b59c:	8007883a 	mov	r3,r16
 824b5a0:	29002c0e 	bge	r5,r4,824b654 <_memalign_r+0x15c>
 824b5a4:	1021883a 	mov	r16,r2
 824b5a8:	993fff17 	ldw	r4,-4(r19)
 824b5ac:	00bfff04 	movi	r2,-4
 824b5b0:	80c7c83a 	sub	r3,r16,r3
 824b5b4:	2084703a 	and	r2,r4,r2
 824b5b8:	10c5c83a 	sub	r2,r2,r3
 824b5bc:	11000054 	ori	r4,r2,1
 824b5c0:	81000115 	stw	r4,4(r16)
 824b5c4:	8085883a 	add	r2,r16,r2
 824b5c8:	11800117 	ldw	r6,4(r2)
 824b5cc:	980b883a 	mov	r5,r19
 824b5d0:	a009883a 	mov	r4,r20
 824b5d4:	31800054 	ori	r6,r6,1
 824b5d8:	11800115 	stw	r6,4(r2)
 824b5dc:	98bfff17 	ldw	r2,-4(r19)
 824b5e0:	1080004c 	andi	r2,r2,1
 824b5e4:	10c6b03a 	or	r3,r2,r3
 824b5e8:	98ffff15 	stw	r3,-4(r19)
 824b5ec:	820b07c0 	call	820b07c <_free_r>
 824b5f0:	80c00117 	ldw	r3,4(r16)
 824b5f4:	00bfff04 	movi	r2,-4
 824b5f8:	1884703a 	and	r2,r3,r2
 824b5fc:	1485c83a 	sub	r2,r2,r18
 824b600:	00c003c4 	movi	r3,15
 824b604:	18801516 	blt	r3,r2,824b65c <_memalign_r+0x164>
 824b608:	a009883a 	mov	r4,r20
 824b60c:	8214a940 	call	8214a94 <__malloc_unlock>
 824b610:	80800204 	addi	r2,r16,8
 824b614:	dfc00517 	ldw	ra,20(sp)
 824b618:	dd000417 	ldw	r20,16(sp)
 824b61c:	dcc00317 	ldw	r19,12(sp)
 824b620:	dc800217 	ldw	r18,8(sp)
 824b624:	dc400117 	ldw	r17,4(sp)
 824b628:	dc000017 	ldw	r16,0(sp)
 824b62c:	dec00604 	addi	sp,sp,24
 824b630:	f800283a 	ret
 824b634:	04800404 	movi	r18,16
 824b638:	91bfc42e 	bgeu	r18,r6,824b54c <_memalign_r+0x54>
 824b63c:	00800304 	movi	r2,12
 824b640:	a0800015 	stw	r2,0(r20)
 824b644:	0005883a 	mov	r2,zero
 824b648:	003ff206 	br	824b614 <_memalign_r+0x11c>
 824b64c:	300b883a 	mov	r5,r6
 824b650:	820bc681 	jmpi	820bc68 <_malloc_r>
 824b654:	1461883a 	add	r16,r2,r17
 824b658:	003fd306 	br	824b5a8 <_memalign_r+0xb0>
 824b65c:	848b883a 	add	r5,r16,r18
 824b660:	10800054 	ori	r2,r2,1
 824b664:	28800115 	stw	r2,4(r5)
 824b668:	80800117 	ldw	r2,4(r16)
 824b66c:	29400204 	addi	r5,r5,8
 824b670:	a009883a 	mov	r4,r20
 824b674:	1080004c 	andi	r2,r2,1
 824b678:	14a4b03a 	or	r18,r2,r18
 824b67c:	84800115 	stw	r18,4(r16)
 824b680:	820b07c0 	call	820b07c <_free_r>
 824b684:	003fe006 	br	824b608 <_memalign_r+0x110>
 824b688:	0005883a 	mov	r2,zero
 824b68c:	003fe106 	br	824b614 <_memalign_r+0x11c>

0824b690 <malloc>:
 824b690:	00820974 	movhi	r2,2085
 824b694:	108fa204 	addi	r2,r2,16008
 824b698:	200b883a 	mov	r5,r4
 824b69c:	11000017 	ldw	r4,0(r2)
 824b6a0:	820bc681 	jmpi	820bc68 <_malloc_r>

0824b6a4 <free>:
 824b6a4:	00820974 	movhi	r2,2085
 824b6a8:	108fa204 	addi	r2,r2,16008
 824b6ac:	200b883a 	mov	r5,r4
 824b6b0:	11000017 	ldw	r4,0(r2)
 824b6b4:	820b07c1 	jmpi	820b07c <_free_r>

0824b6b8 <strcpy>:
 824b6b8:	2906b03a 	or	r3,r5,r4
 824b6bc:	18c000cc 	andi	r3,r3,3
 824b6c0:	2005883a 	mov	r2,r4
 824b6c4:	1800161e 	bne	r3,zero,824b720 <strcpy+0x68>
 824b6c8:	29c00017 	ldw	r7,0(r5)
 824b6cc:	02ffbff4 	movhi	r11,65279
 824b6d0:	5affbfc4 	addi	r11,r11,-257
 824b6d4:	02a02074 	movhi	r10,32897
 824b6d8:	01c6303a 	nor	r3,zero,r7
 824b6dc:	3ac9883a 	add	r4,r7,r11
 824b6e0:	52a02004 	addi	r10,r10,-32640
 824b6e4:	20c6703a 	and	r3,r4,r3
 824b6e8:	1a86703a 	and	r3,r3,r10
 824b6ec:	18000c1e 	bne	r3,zero,824b720 <strcpy+0x68>
 824b6f0:	1011883a 	mov	r8,r2
 824b6f4:	41c00015 	stw	r7,0(r8)
 824b6f8:	29400104 	addi	r5,r5,4
 824b6fc:	29c00017 	ldw	r7,0(r5)
 824b700:	41800104 	addi	r6,r8,4
 824b704:	3011883a 	mov	r8,r6
 824b708:	3ad3883a 	add	r9,r7,r11
 824b70c:	01c6303a 	nor	r3,zero,r7
 824b710:	48c6703a 	and	r3,r9,r3
 824b714:	1a86703a 	and	r3,r3,r10
 824b718:	183ff626 	beq	r3,zero,824b6f4 <strcpy+0x3c>
 824b71c:	00000106 	br	824b724 <strcpy+0x6c>
 824b720:	100d883a 	mov	r6,r2
 824b724:	28c00003 	ldbu	r3,0(r5)
 824b728:	31800044 	addi	r6,r6,1
 824b72c:	29400044 	addi	r5,r5,1
 824b730:	30ffffc5 	stb	r3,-1(r6)
 824b734:	18c03fcc 	andi	r3,r3,255
 824b738:	18c0201c 	xori	r3,r3,128
 824b73c:	18ffe004 	addi	r3,r3,-128
 824b740:	183ff81e 	bne	r3,zero,824b724 <strcpy+0x6c>
 824b744:	f800283a 	ret

0824b748 <strncmp>:
 824b748:	30003126 	beq	r6,zero,824b810 <strncmp+0xc8>
 824b74c:	2144b03a 	or	r2,r4,r5
 824b750:	108000cc 	andi	r2,r2,3
 824b754:	10001e1e 	bne	r2,zero,824b7d0 <strncmp+0x88>
 824b758:	024000c4 	movi	r9,3
 824b75c:	49801c2e 	bgeu	r9,r6,824b7d0 <strncmp+0x88>
 824b760:	20800017 	ldw	r2,0(r4)
 824b764:	28c00017 	ldw	r3,0(r5)
 824b768:	10c0191e 	bne	r2,r3,824b7d0 <strncmp+0x88>
 824b76c:	31bfff04 	addi	r6,r6,-4
 824b770:	30002726 	beq	r6,zero,824b810 <strncmp+0xc8>
 824b774:	02ffbff4 	movhi	r11,65279
 824b778:	5affbfc4 	addi	r11,r11,-257
 824b77c:	0086303a 	nor	r3,zero,r2
 824b780:	02a02074 	movhi	r10,32897
 824b784:	12c5883a 	add	r2,r2,r11
 824b788:	52a02004 	addi	r10,r10,-32640
 824b78c:	10c4703a 	and	r2,r2,r3
 824b790:	1284703a 	and	r2,r2,r10
 824b794:	10000b26 	beq	r2,zero,824b7c4 <strncmp+0x7c>
 824b798:	00001d06 	br	824b810 <strncmp+0xc8>
 824b79c:	20c00017 	ldw	r3,0(r4)
 824b7a0:	29c00017 	ldw	r7,0(r5)
 824b7a4:	1ad1883a 	add	r8,r3,r11
 824b7a8:	00c4303a 	nor	r2,zero,r3
 824b7ac:	4084703a 	and	r2,r8,r2
 824b7b0:	1284703a 	and	r2,r2,r10
 824b7b4:	19c0061e 	bne	r3,r7,824b7d0 <strncmp+0x88>
 824b7b8:	31bfff04 	addi	r6,r6,-4
 824b7bc:	30001426 	beq	r6,zero,824b810 <strncmp+0xc8>
 824b7c0:	1000131e 	bne	r2,zero,824b810 <strncmp+0xc8>
 824b7c4:	21000104 	addi	r4,r4,4
 824b7c8:	29400104 	addi	r5,r5,4
 824b7cc:	49bff336 	bltu	r9,r6,824b79c <strncmp+0x54>
 824b7d0:	28800007 	ldb	r2,0(r5)
 824b7d4:	20c00007 	ldb	r3,0(r4)
 824b7d8:	31bfffc4 	addi	r6,r6,-1
 824b7dc:	10c0081e 	bne	r2,r3,824b800 <strncmp+0xb8>
 824b7e0:	30000b26 	beq	r6,zero,824b810 <strncmp+0xc8>
 824b7e4:	10000a26 	beq	r2,zero,824b810 <strncmp+0xc8>
 824b7e8:	21000044 	addi	r4,r4,1
 824b7ec:	29400044 	addi	r5,r5,1
 824b7f0:	20800007 	ldb	r2,0(r4)
 824b7f4:	28c00007 	ldb	r3,0(r5)
 824b7f8:	31bfffc4 	addi	r6,r6,-1
 824b7fc:	10fff826 	beq	r2,r3,824b7e0 <strncmp+0x98>
 824b800:	20800003 	ldbu	r2,0(r4)
 824b804:	28c00003 	ldbu	r3,0(r5)
 824b808:	10c5c83a 	sub	r2,r2,r3
 824b80c:	f800283a 	ret
 824b810:	0005883a 	mov	r2,zero
 824b814:	f800283a 	ret

0824b818 <strncpy>:
 824b818:	2906b03a 	or	r3,r5,r4
 824b81c:	18c000cc 	andi	r3,r3,3
 824b820:	2005883a 	mov	r2,r4
 824b824:	18002c1e 	bne	r3,zero,824b8d8 <strncpy+0xc0>
 824b828:	010000c4 	movi	r4,3
 824b82c:	21802a2e 	bgeu	r4,r6,824b8d8 <strncpy+0xc0>
 824b830:	033fbff4 	movhi	r12,65279
 824b834:	02e02074 	movhi	r11,32897
 824b838:	633fbfc4 	addi	r12,r12,-257
 824b83c:	5ae02004 	addi	r11,r11,-32640
 824b840:	100f883a 	mov	r7,r2
 824b844:	2a000017 	ldw	r8,0(r5)
 824b848:	3815883a 	mov	r10,r7
 824b84c:	4313883a 	add	r9,r8,r12
 824b850:	0206303a 	nor	r3,zero,r8
 824b854:	48c6703a 	and	r3,r9,r3
 824b858:	1ac6703a 	and	r3,r3,r11
 824b85c:	1800261e 	bne	r3,zero,824b8f8 <strncpy+0xe0>
 824b860:	39c00104 	addi	r7,r7,4
 824b864:	52000015 	stw	r8,0(r10)
 824b868:	31bfff04 	addi	r6,r6,-4
 824b86c:	3811883a 	mov	r8,r7
 824b870:	29400104 	addi	r5,r5,4
 824b874:	21bff336 	bltu	r4,r6,824b844 <strncpy+0x2c>
 824b878:	30001e26 	beq	r6,zero,824b8f4 <strncpy+0xdc>
 824b87c:	29c00003 	ldbu	r7,0(r5)
 824b880:	31bfffc4 	addi	r6,r6,-1
 824b884:	40c00044 	addi	r3,r8,1
 824b888:	41c00005 	stb	r7,0(r8)
 824b88c:	39c03fcc 	andi	r7,r7,255
 824b890:	39c0201c 	xori	r7,r7,128
 824b894:	39ffe004 	addi	r7,r7,-128
 824b898:	29400044 	addi	r5,r5,1
 824b89c:	38001026 	beq	r7,zero,824b8e0 <strncpy+0xc8>
 824b8a0:	1811883a 	mov	r8,r3
 824b8a4:	00000906 	br	824b8cc <strncpy+0xb4>
 824b8a8:	29c00003 	ldbu	r7,0(r5)
 824b8ac:	31bfffc4 	addi	r6,r6,-1
 824b8b0:	29400044 	addi	r5,r5,1
 824b8b4:	41c00005 	stb	r7,0(r8)
 824b8b8:	39c03fcc 	andi	r7,r7,255
 824b8bc:	39c0201c 	xori	r7,r7,128
 824b8c0:	39ffe004 	addi	r7,r7,-128
 824b8c4:	1811883a 	mov	r8,r3
 824b8c8:	38000526 	beq	r7,zero,824b8e0 <strncpy+0xc8>
 824b8cc:	18c00044 	addi	r3,r3,1
 824b8d0:	303ff51e 	bne	r6,zero,824b8a8 <strncpy+0x90>
 824b8d4:	f800283a 	ret
 824b8d8:	1011883a 	mov	r8,r2
 824b8dc:	003fe606 	br	824b878 <strncpy+0x60>
 824b8e0:	30000726 	beq	r6,zero,824b900 <strncpy+0xe8>
 824b8e4:	198d883a 	add	r6,r3,r6
 824b8e8:	18000005 	stb	zero,0(r3)
 824b8ec:	18c00044 	addi	r3,r3,1
 824b8f0:	19bffd1e 	bne	r3,r6,824b8e8 <strncpy+0xd0>
 824b8f4:	f800283a 	ret
 824b8f8:	3811883a 	mov	r8,r7
 824b8fc:	003fdf06 	br	824b87c <strncpy+0x64>
 824b900:	f800283a 	ret

0824b904 <_strtol_r>:
 824b904:	00820974 	movhi	r2,2085
 824b908:	defff404 	addi	sp,sp,-48
 824b90c:	108fa004 	addi	r2,r2,16000
 824b910:	dd400715 	stw	r21,28(sp)
 824b914:	15400017 	ldw	r21,0(r2)
 824b918:	dd800815 	stw	r22,32(sp)
 824b91c:	dd000615 	stw	r20,24(sp)
 824b920:	dcc00515 	stw	r19,20(sp)
 824b924:	d9000015 	stw	r4,0(sp)
 824b928:	dfc00b15 	stw	ra,44(sp)
 824b92c:	df000a15 	stw	fp,40(sp)
 824b930:	ddc00915 	stw	r23,36(sp)
 824b934:	dc800415 	stw	r18,16(sp)
 824b938:	dc400315 	stw	r17,12(sp)
 824b93c:	dc000215 	stw	r16,8(sp)
 824b940:	2829883a 	mov	r20,r5
 824b944:	3027883a 	mov	r19,r6
 824b948:	382d883a 	mov	r22,r7
 824b94c:	2809883a 	mov	r4,r5
 824b950:	24000003 	ldbu	r16,0(r4)
 824b954:	24400044 	addi	r17,r4,1
 824b958:	2007883a 	mov	r3,r4
 824b95c:	ac05883a 	add	r2,r21,r16
 824b960:	10800043 	ldbu	r2,1(r2)
 824b964:	8809883a 	mov	r4,r17
 824b968:	1080020c 	andi	r2,r2,8
 824b96c:	103ff81e 	bne	r2,zero,824b950 <_strtol_r+0x4c>
 824b970:	00800b44 	movi	r2,45
 824b974:	80805826 	beq	r16,r2,824bad8 <_strtol_r+0x1d4>
 824b978:	00800ac4 	movi	r2,43
 824b97c:	80805a26 	beq	r16,r2,824bae8 <_strtol_r+0x1e4>
 824b980:	0039883a 	mov	fp,zero
 824b984:	b0004426 	beq	r22,zero,824ba98 <_strtol_r+0x194>
 824b988:	00800404 	movi	r2,16
 824b98c:	b0806026 	beq	r22,r2,824bb10 <_strtol_r+0x20c>
 824b990:	b02f883a 	mov	r23,r22
 824b994:	00a00034 	movhi	r2,32768
 824b998:	e025003a 	cmpeq	r18,fp,zero
 824b99c:	14a5c83a 	sub	r18,r2,r18
 824b9a0:	b80b883a 	mov	r5,r23
 824b9a4:	9009883a 	mov	r4,r18
 824b9a8:	8202bf00 	call	8202bf0 <__umodsi3>
 824b9ac:	b80b883a 	mov	r5,r23
 824b9b0:	9009883a 	mov	r4,r18
 824b9b4:	d8800115 	stw	r2,4(sp)
 824b9b8:	8202b8c0 	call	8202b8c <__udivsi3>
 824b9bc:	ac07883a 	add	r3,r21,r16
 824b9c0:	18c00043 	ldbu	r3,1(r3)
 824b9c4:	880b883a 	mov	r5,r17
 824b9c8:	000d883a 	mov	r6,zero
 824b9cc:	1a00010c 	andi	r8,r3,4
 824b9d0:	0009883a 	mov	r4,zero
 824b9d4:	02800044 	movi	r10,1
 824b9d8:	027fffc4 	movi	r9,-1
 824b9dc:	d9c00117 	ldw	r7,4(sp)
 824b9e0:	40000e26 	beq	r8,zero,824ba1c <_strtol_r+0x118>
 824b9e4:	843ff404 	addi	r16,r16,-48
 824b9e8:	8580120e 	bge	r16,r22,824ba34 <_strtol_r+0x130>
 824b9ec:	32400526 	beq	r6,r9,824ba04 <_strtol_r+0x100>
 824b9f0:	11002536 	bltu	r2,r4,824ba88 <_strtol_r+0x184>
 824b9f4:	20802326 	beq	r4,r2,824ba84 <_strtol_r+0x180>
 824b9f8:	25c9383a 	mul	r4,r4,r23
 824b9fc:	01800044 	movi	r6,1
 824ba00:	8109883a 	add	r4,r16,r4
 824ba04:	2c000003 	ldbu	r16,0(r5)
 824ba08:	29400044 	addi	r5,r5,1
 824ba0c:	ac07883a 	add	r3,r21,r16
 824ba10:	18c00043 	ldbu	r3,1(r3)
 824ba14:	1a00010c 	andi	r8,r3,4
 824ba18:	403ff21e 	bne	r8,zero,824b9e4 <_strtol_r+0xe0>
 824ba1c:	18c000cc 	andi	r3,r3,3
 824ba20:	18000426 	beq	r3,zero,824ba34 <_strtol_r+0x130>
 824ba24:	1a801a26 	beq	r3,r10,824ba90 <_strtol_r+0x18c>
 824ba28:	00c015c4 	movi	r3,87
 824ba2c:	80e1c83a 	sub	r16,r16,r3
 824ba30:	85bfee16 	blt	r16,r22,824b9ec <_strtol_r+0xe8>
 824ba34:	00bfffc4 	movi	r2,-1
 824ba38:	30801e26 	beq	r6,r2,824bab4 <_strtol_r+0x1b0>
 824ba3c:	e0001b1e 	bne	fp,zero,824baac <_strtol_r+0x1a8>
 824ba40:	2005883a 	mov	r2,r4
 824ba44:	98000326 	beq	r19,zero,824ba54 <_strtol_r+0x150>
 824ba48:	3000211e 	bne	r6,zero,824bad0 <_strtol_r+0x1cc>
 824ba4c:	a00b883a 	mov	r5,r20
 824ba50:	99400015 	stw	r5,0(r19)
 824ba54:	dfc00b17 	ldw	ra,44(sp)
 824ba58:	df000a17 	ldw	fp,40(sp)
 824ba5c:	ddc00917 	ldw	r23,36(sp)
 824ba60:	dd800817 	ldw	r22,32(sp)
 824ba64:	dd400717 	ldw	r21,28(sp)
 824ba68:	dd000617 	ldw	r20,24(sp)
 824ba6c:	dcc00517 	ldw	r19,20(sp)
 824ba70:	dc800417 	ldw	r18,16(sp)
 824ba74:	dc400317 	ldw	r17,12(sp)
 824ba78:	dc000217 	ldw	r16,8(sp)
 824ba7c:	dec00c04 	addi	sp,sp,48
 824ba80:	f800283a 	ret
 824ba84:	3c3fdc0e 	bge	r7,r16,824b9f8 <_strtol_r+0xf4>
 824ba88:	01bfffc4 	movi	r6,-1
 824ba8c:	003fdd06 	br	824ba04 <_strtol_r+0x100>
 824ba90:	00c00dc4 	movi	r3,55
 824ba94:	003fe506 	br	824ba2c <_strtol_r+0x128>
 824ba98:	00800c04 	movi	r2,48
 824ba9c:	80801626 	beq	r16,r2,824baf8 <_strtol_r+0x1f4>
 824baa0:	05800284 	movi	r22,10
 824baa4:	b02f883a 	mov	r23,r22
 824baa8:	003fba06 	br	824b994 <_strtol_r+0x90>
 824baac:	0109c83a 	sub	r4,zero,r4
 824bab0:	003fe306 	br	824ba40 <_strtol_r+0x13c>
 824bab4:	d9000017 	ldw	r4,0(sp)
 824bab8:	00c00884 	movi	r3,34
 824babc:	e005003a 	cmpeq	r2,fp,zero
 824bac0:	20c00015 	stw	r3,0(r4)
 824bac4:	00e00034 	movhi	r3,32768
 824bac8:	1885c83a 	sub	r2,r3,r2
 824bacc:	983fe126 	beq	r19,zero,824ba54 <_strtol_r+0x150>
 824bad0:	297fffc4 	addi	r5,r5,-1
 824bad4:	003fde06 	br	824ba50 <_strtol_r+0x14c>
 824bad8:	1c400084 	addi	r17,r3,2
 824badc:	1c000043 	ldbu	r16,1(r3)
 824bae0:	07000044 	movi	fp,1
 824bae4:	003fa706 	br	824b984 <_strtol_r+0x80>
 824bae8:	1c400084 	addi	r17,r3,2
 824baec:	1c000043 	ldbu	r16,1(r3)
 824baf0:	0039883a 	mov	fp,zero
 824baf4:	003fa306 	br	824b984 <_strtol_r+0x80>
 824baf8:	88800003 	ldbu	r2,0(r17)
 824bafc:	00c01604 	movi	r3,88
 824bb00:	108037cc 	andi	r2,r2,223
 824bb04:	10c00826 	beq	r2,r3,824bb28 <_strtol_r+0x224>
 824bb08:	05800204 	movi	r22,8
 824bb0c:	003fa006 	br	824b990 <_strtol_r+0x8c>
 824bb10:	00800c04 	movi	r2,48
 824bb14:	80bf9e1e 	bne	r16,r2,824b990 <_strtol_r+0x8c>
 824bb18:	88800003 	ldbu	r2,0(r17)
 824bb1c:	00c01604 	movi	r3,88
 824bb20:	108037cc 	andi	r2,r2,223
 824bb24:	10ff9a1e 	bne	r2,r3,824b990 <_strtol_r+0x8c>
 824bb28:	05c00404 	movi	r23,16
 824bb2c:	8c000043 	ldbu	r16,1(r17)
 824bb30:	b82d883a 	mov	r22,r23
 824bb34:	8c400084 	addi	r17,r17,2
 824bb38:	003f9606 	br	824b994 <_strtol_r+0x90>

0824bb3c <strtol>:
 824bb3c:	00820974 	movhi	r2,2085
 824bb40:	108fa204 	addi	r2,r2,16008
 824bb44:	300f883a 	mov	r7,r6
 824bb48:	280d883a 	mov	r6,r5
 824bb4c:	200b883a 	mov	r5,r4
 824bb50:	11000017 	ldw	r4,0(r2)
 824bb54:	824b9041 	jmpi	824b904 <_strtol_r>

0824bb58 <vprintf>:
 824bb58:	00820974 	movhi	r2,2085
 824bb5c:	108fa204 	addi	r2,r2,16008
 824bb60:	200d883a 	mov	r6,r4
 824bb64:	11000017 	ldw	r4,0(r2)
 824bb68:	280f883a 	mov	r7,r5
 824bb6c:	21400217 	ldw	r5,8(r4)
 824bb70:	824be881 	jmpi	824be88 <_vfprintf_r>

0824bb74 <_vprintf_r>:
 824bb74:	300f883a 	mov	r7,r6
 824bb78:	280d883a 	mov	r6,r5
 824bb7c:	21400217 	ldw	r5,8(r4)
 824bb80:	824be881 	jmpi	824be88 <_vfprintf_r>

0824bb84 <_vsprintf_r>:
 824bb84:	00a00034 	movhi	r2,32768
 824bb88:	deffe504 	addi	sp,sp,-108
 824bb8c:	10bfffc4 	addi	r2,r2,-1
 824bb90:	2807883a 	mov	r3,r5
 824bb94:	02008204 	movi	r8,520
 824bb98:	d8800215 	stw	r2,8(sp)
 824bb9c:	d8800515 	stw	r2,20(sp)
 824bba0:	d80b883a 	mov	r5,sp
 824bba4:	00bfffc4 	movi	r2,-1
 824bba8:	d8c00015 	stw	r3,0(sp)
 824bbac:	d8c00415 	stw	r3,16(sp)
 824bbb0:	dfc01a15 	stw	ra,104(sp)
 824bbb4:	da00030d 	sth	r8,12(sp)
 824bbb8:	d880038d 	sth	r2,14(sp)
 824bbbc:	82047d80 	call	82047d8 <___svfprintf_internal_r>
 824bbc0:	d8c00017 	ldw	r3,0(sp)
 824bbc4:	18000005 	stb	zero,0(r3)
 824bbc8:	dfc01a17 	ldw	ra,104(sp)
 824bbcc:	dec01b04 	addi	sp,sp,108
 824bbd0:	f800283a 	ret

0824bbd4 <vsprintf>:
 824bbd4:	00820974 	movhi	r2,2085
 824bbd8:	108fa204 	addi	r2,r2,16008
 824bbdc:	300f883a 	mov	r7,r6
 824bbe0:	280d883a 	mov	r6,r5
 824bbe4:	200b883a 	mov	r5,r4
 824bbe8:	11000017 	ldw	r4,0(r2)
 824bbec:	824bb841 	jmpi	824bb84 <_vsprintf_r>

0824bbf0 <__register_exitproc>:
 824bbf0:	defffa04 	addi	sp,sp,-24
 824bbf4:	dc000315 	stw	r16,12(sp)
 824bbf8:	04020974 	movhi	r16,2085
 824bbfc:	840fa104 	addi	r16,r16,16004
 824bc00:	80c00017 	ldw	r3,0(r16)
 824bc04:	dc400415 	stw	r17,16(sp)
 824bc08:	dfc00515 	stw	ra,20(sp)
 824bc0c:	18805217 	ldw	r2,328(r3)
 824bc10:	2023883a 	mov	r17,r4
 824bc14:	10003726 	beq	r2,zero,824bcf4 <__register_exitproc+0x104>
 824bc18:	10c00117 	ldw	r3,4(r2)
 824bc1c:	010007c4 	movi	r4,31
 824bc20:	20c00e16 	blt	r4,r3,824bc5c <__register_exitproc+0x6c>
 824bc24:	1a000044 	addi	r8,r3,1
 824bc28:	8800221e 	bne	r17,zero,824bcb4 <__register_exitproc+0xc4>
 824bc2c:	18c00084 	addi	r3,r3,2
 824bc30:	18c7883a 	add	r3,r3,r3
 824bc34:	18c7883a 	add	r3,r3,r3
 824bc38:	12000115 	stw	r8,4(r2)
 824bc3c:	10c7883a 	add	r3,r2,r3
 824bc40:	19400015 	stw	r5,0(r3)
 824bc44:	0005883a 	mov	r2,zero
 824bc48:	dfc00517 	ldw	ra,20(sp)
 824bc4c:	dc400417 	ldw	r17,16(sp)
 824bc50:	dc000317 	ldw	r16,12(sp)
 824bc54:	dec00604 	addi	sp,sp,24
 824bc58:	f800283a 	ret
 824bc5c:	00820974 	movhi	r2,2085
 824bc60:	10ada404 	addi	r2,r2,-18800
 824bc64:	10002626 	beq	r2,zero,824bd00 <__register_exitproc+0x110>
 824bc68:	01006404 	movi	r4,400
 824bc6c:	d9400015 	stw	r5,0(sp)
 824bc70:	d9800115 	stw	r6,4(sp)
 824bc74:	d9c00215 	stw	r7,8(sp)
 824bc78:	824b6900 	call	824b690 <malloc>
 824bc7c:	d9400017 	ldw	r5,0(sp)
 824bc80:	d9800117 	ldw	r6,4(sp)
 824bc84:	d9c00217 	ldw	r7,8(sp)
 824bc88:	10001d26 	beq	r2,zero,824bd00 <__register_exitproc+0x110>
 824bc8c:	81000017 	ldw	r4,0(r16)
 824bc90:	10000115 	stw	zero,4(r2)
 824bc94:	02000044 	movi	r8,1
 824bc98:	22405217 	ldw	r9,328(r4)
 824bc9c:	0007883a 	mov	r3,zero
 824bca0:	12400015 	stw	r9,0(r2)
 824bca4:	20805215 	stw	r2,328(r4)
 824bca8:	10006215 	stw	zero,392(r2)
 824bcac:	10006315 	stw	zero,396(r2)
 824bcb0:	883fde26 	beq	r17,zero,824bc2c <__register_exitproc+0x3c>
 824bcb4:	18c9883a 	add	r4,r3,r3
 824bcb8:	2109883a 	add	r4,r4,r4
 824bcbc:	1109883a 	add	r4,r2,r4
 824bcc0:	21802215 	stw	r6,136(r4)
 824bcc4:	01800044 	movi	r6,1
 824bcc8:	12406217 	ldw	r9,392(r2)
 824bccc:	30cc983a 	sll	r6,r6,r3
 824bcd0:	4992b03a 	or	r9,r9,r6
 824bcd4:	12406215 	stw	r9,392(r2)
 824bcd8:	21c04215 	stw	r7,264(r4)
 824bcdc:	01000084 	movi	r4,2
 824bce0:	893fd21e 	bne	r17,r4,824bc2c <__register_exitproc+0x3c>
 824bce4:	11006317 	ldw	r4,396(r2)
 824bce8:	218cb03a 	or	r6,r4,r6
 824bcec:	11806315 	stw	r6,396(r2)
 824bcf0:	003fce06 	br	824bc2c <__register_exitproc+0x3c>
 824bcf4:	18805304 	addi	r2,r3,332
 824bcf8:	18805215 	stw	r2,328(r3)
 824bcfc:	003fc606 	br	824bc18 <__register_exitproc+0x28>
 824bd00:	00bfffc4 	movi	r2,-1
 824bd04:	003fd006 	br	824bc48 <__register_exitproc+0x58>

0824bd08 <__call_exitprocs>:
 824bd08:	defff504 	addi	sp,sp,-44
 824bd0c:	df000915 	stw	fp,36(sp)
 824bd10:	dd400615 	stw	r21,24(sp)
 824bd14:	dc800315 	stw	r18,12(sp)
 824bd18:	dfc00a15 	stw	ra,40(sp)
 824bd1c:	ddc00815 	stw	r23,32(sp)
 824bd20:	dd800715 	stw	r22,28(sp)
 824bd24:	dd000515 	stw	r20,20(sp)
 824bd28:	dcc00415 	stw	r19,16(sp)
 824bd2c:	dc400215 	stw	r17,8(sp)
 824bd30:	dc000115 	stw	r16,4(sp)
 824bd34:	d9000015 	stw	r4,0(sp)
 824bd38:	2839883a 	mov	fp,r5
 824bd3c:	04800044 	movi	r18,1
 824bd40:	057fffc4 	movi	r21,-1
 824bd44:	00820974 	movhi	r2,2085
 824bd48:	108fa104 	addi	r2,r2,16004
 824bd4c:	12000017 	ldw	r8,0(r2)
 824bd50:	45005217 	ldw	r20,328(r8)
 824bd54:	44c05204 	addi	r19,r8,328
 824bd58:	a0001c26 	beq	r20,zero,824bdcc <__call_exitprocs+0xc4>
 824bd5c:	a0800117 	ldw	r2,4(r20)
 824bd60:	15ffffc4 	addi	r23,r2,-1
 824bd64:	b8000d16 	blt	r23,zero,824bd9c <__call_exitprocs+0x94>
 824bd68:	14000044 	addi	r16,r2,1
 824bd6c:	8421883a 	add	r16,r16,r16
 824bd70:	8421883a 	add	r16,r16,r16
 824bd74:	84402004 	addi	r17,r16,128
 824bd78:	a463883a 	add	r17,r20,r17
 824bd7c:	a421883a 	add	r16,r20,r16
 824bd80:	e0001e26 	beq	fp,zero,824bdfc <__call_exitprocs+0xf4>
 824bd84:	80804017 	ldw	r2,256(r16)
 824bd88:	e0801c26 	beq	fp,r2,824bdfc <__call_exitprocs+0xf4>
 824bd8c:	bdffffc4 	addi	r23,r23,-1
 824bd90:	843fff04 	addi	r16,r16,-4
 824bd94:	8c7fff04 	addi	r17,r17,-4
 824bd98:	bd7ff91e 	bne	r23,r21,824bd80 <__call_exitprocs+0x78>
 824bd9c:	00820974 	movhi	r2,2085
 824bda0:	10ada904 	addi	r2,r2,-18780
 824bda4:	10000926 	beq	r2,zero,824bdcc <__call_exitprocs+0xc4>
 824bda8:	a0800117 	ldw	r2,4(r20)
 824bdac:	1000301e 	bne	r2,zero,824be70 <__call_exitprocs+0x168>
 824bdb0:	a0800017 	ldw	r2,0(r20)
 824bdb4:	10003226 	beq	r2,zero,824be80 <__call_exitprocs+0x178>
 824bdb8:	a009883a 	mov	r4,r20
 824bdbc:	98800015 	stw	r2,0(r19)
 824bdc0:	824b6a40 	call	824b6a4 <free>
 824bdc4:	9d000017 	ldw	r20,0(r19)
 824bdc8:	a03fe41e 	bne	r20,zero,824bd5c <__call_exitprocs+0x54>
 824bdcc:	dfc00a17 	ldw	ra,40(sp)
 824bdd0:	df000917 	ldw	fp,36(sp)
 824bdd4:	ddc00817 	ldw	r23,32(sp)
 824bdd8:	dd800717 	ldw	r22,28(sp)
 824bddc:	dd400617 	ldw	r21,24(sp)
 824bde0:	dd000517 	ldw	r20,20(sp)
 824bde4:	dcc00417 	ldw	r19,16(sp)
 824bde8:	dc800317 	ldw	r18,12(sp)
 824bdec:	dc400217 	ldw	r17,8(sp)
 824bdf0:	dc000117 	ldw	r16,4(sp)
 824bdf4:	dec00b04 	addi	sp,sp,44
 824bdf8:	f800283a 	ret
 824bdfc:	a0800117 	ldw	r2,4(r20)
 824be00:	80c00017 	ldw	r3,0(r16)
 824be04:	10bfffc4 	addi	r2,r2,-1
 824be08:	15c01426 	beq	r2,r23,824be5c <__call_exitprocs+0x154>
 824be0c:	80000015 	stw	zero,0(r16)
 824be10:	183fde26 	beq	r3,zero,824bd8c <__call_exitprocs+0x84>
 824be14:	95c8983a 	sll	r4,r18,r23
 824be18:	a0806217 	ldw	r2,392(r20)
 824be1c:	a5800117 	ldw	r22,4(r20)
 824be20:	2084703a 	and	r2,r4,r2
 824be24:	10000b26 	beq	r2,zero,824be54 <__call_exitprocs+0x14c>
 824be28:	a0806317 	ldw	r2,396(r20)
 824be2c:	2088703a 	and	r4,r4,r2
 824be30:	20000c1e 	bne	r4,zero,824be64 <__call_exitprocs+0x15c>
 824be34:	89400017 	ldw	r5,0(r17)
 824be38:	d9000017 	ldw	r4,0(sp)
 824be3c:	183ee83a 	callr	r3
 824be40:	a0800117 	ldw	r2,4(r20)
 824be44:	15bfbf1e 	bne	r2,r22,824bd44 <__call_exitprocs+0x3c>
 824be48:	98800017 	ldw	r2,0(r19)
 824be4c:	153fcf26 	beq	r2,r20,824bd8c <__call_exitprocs+0x84>
 824be50:	003fbc06 	br	824bd44 <__call_exitprocs+0x3c>
 824be54:	183ee83a 	callr	r3
 824be58:	003ff906 	br	824be40 <__call_exitprocs+0x138>
 824be5c:	a5c00115 	stw	r23,4(r20)
 824be60:	003feb06 	br	824be10 <__call_exitprocs+0x108>
 824be64:	89000017 	ldw	r4,0(r17)
 824be68:	183ee83a 	callr	r3
 824be6c:	003ff406 	br	824be40 <__call_exitprocs+0x138>
 824be70:	a0800017 	ldw	r2,0(r20)
 824be74:	a027883a 	mov	r19,r20
 824be78:	1029883a 	mov	r20,r2
 824be7c:	003fb606 	br	824bd58 <__call_exitprocs+0x50>
 824be80:	0005883a 	mov	r2,zero
 824be84:	003ffb06 	br	824be74 <__call_exitprocs+0x16c>

0824be88 <_vfprintf_r>:
 824be88:	deffff04 	addi	sp,sp,-4
 824be8c:	dfc00015 	stw	ra,0(sp)
 824be90:	82069b80 	call	82069b8 <___vfprintf_internal_r>
 824be94:	dfc00017 	ldw	ra,0(sp)
 824be98:	dec00104 	addi	sp,sp,4
 824be9c:	f800283a 	ret

0824bea0 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 824bea0:	defffd04 	addi	sp,sp,-12
 824bea4:	df000215 	stw	fp,8(sp)
 824bea8:	df000204 	addi	fp,sp,8
 824beac:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 824beb0:	d0206b45 	stb	zero,-32339(gp)
 824beb4:	e0bfff17 	ldw	r2,-4(fp)
 824beb8:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 824bebc:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 824bec0:	10000226 	beq	r2,zero,824becc <_exit+0x2c>
    ALT_SIM_FAIL();
 824bec4:	002af070 	cmpltui	zero,zero,43969
 824bec8:	00000106 	br	824bed0 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 824becc:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 824bed0:	003fff06 	br	824bed0 <_exit+0x30>
